[
    {
        "title": "Maximize Sum Of Array After K Negations",
        "question_content": "Given an integer array nums and an integer k, modify the array in the following way:\n\n\tchoose an index i and replace nums[i] with -nums[i].\n\nYou should apply this process exactly k times. You may choose the same index i multiple times.\nReturn the largest possible sum of the array after modifying it in this way.\n&nbsp;\nExample 1:\n\nInput: nums = [4,2,3], k = 1\nOutput: 5\nExplanation: Choose index 1 and nums becomes [4,-2,3].\n\nExample 2:\n\nInput: nums = [3,-1,0,2], k = 3\nOutput: 6\nExplanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].\n\nExample 3:\n\nInput: nums = [2,-3,-1,5,-4], k = 2\nOutput: 13\nExplanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-100 <= nums[i] <= 100\n\t1 <= k <= 104",
        "solutions": [
            {
                "id": 3540706,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nlong long getSum(vector<int> negate, vector<int>positive)\\n{\\n    long long sum =0;\\n                for(int i=0;i<negate.size();i++)\\n            {\\n                sum+=negate[i];\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                sum+=positive[i];\\n            }\\n            return sum;\\n}\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n   vector<int>negate;\\n   vector<int>positive;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>=0)\\n        {\\n            positive.push_back(nums[i]);\\n        }\\n        else{\\n            negate.push_back(nums[i]);\\n        }\\n    }\\n    if(negate.size()>k)\\n    {\\n        sort(negate.begin(), negate.end());\\n        for(int i=0;i<k;i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        return getSum(negate, positive);\\n    } else {\\n        for(int i=0;i<negate.size();i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        int remainingcount = k-negate.size();\\n        if(remainingcount%2==0)\\n        {\\n            return getSum(negate, positive);\\n        } else {\\n        int mini = INT_MAX;\\n            for(int i=0;i<negate.size();i++)\\n            {\\n                mini = min(mini, negate[i]);\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                mini = min(mini, positive[i]);\\n            }\\ncout<<mini<<endl;\\ncout<<getSum(negate, positive)<<endl;\\n            return (getSum(negate, positive) - 2*mini);\\n        }\\n    }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums = sorted(nums)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] = -nums[i]\\n                k -= 1\\n        nums = sorted(nums)\\n        if k > 0 and k % 2 != 0: \\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nlong long getSum(vector<int> negate, vector<int>positive)\\n{\\n    long long sum =0;\\n                for(int i=0;i<negate.size();i++)\\n            {\\n                sum+=negate[i];\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                sum+=positive[i];\\n            }\\n            return sum;\\n}\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n   vector<int>negate;\\n   vector<int>positive;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>=0)\\n        {\\n            positive.push_back(nums[i]);\\n        }\\n        else{\\n            negate.push_back(nums[i]);\\n        }\\n    }\\n    if(negate.size()>k)\\n    {\\n        sort(negate.begin(), negate.end());\\n        for(int i=0;i<k;i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        return getSum(negate, positive);\\n    } else {\\n        for(int i=0;i<negate.size();i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        int remainingcount = k-negate.size();\\n        if(remainingcount%2==0)\\n        {\\n            return getSum(negate, positive);\\n        } else {\\n        int mini = INT_MAX;\\n            for(int i=0;i<negate.size();i++)\\n            {\\n                mini = min(mini, negate[i]);\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                mini = min(mini, positive[i]);\\n            }\\ncout<<mini<<endl;\\ncout<<getSum(negate, positive)<<endl;\\n            return (getSum(negate, positive) - 2*mini);\\n        }\\n    }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums = sorted(nums)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] = -nums[i]\\n                k -= 1\\n        nums = sorted(nums)\\n        if k > 0 and k % 2 != 0: \\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```\n```Java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 252254,
                "title": "java-c-python-sort",
                "content": "## **Explanation**\\n@codePower:\\nIn case someone needs an explanation:\\n1- sort the numbers in ascending order\\n2- flip all the negative numbers, as long as k > 0\\n3- find the sum of the new array (with flipped numbers if any) and keep track of the minimum number\\n4- Now for the return statement\\n\\n`res` is the total sum of the new array\\n`K % 2` check if the remaining `K` is odd.\\n\\nBecause if it\\'s even, it will have no effect\\n(we will flip a number and then get it back to the original)\\n\\nIf it\\'s odd,\\nflip the minimum number and remove twice its value from the result\\n(twice because we already added it as positive in our sum operation)\\n<br>\\n\\n## **Complexity**\\nTime `O(NlogN)` for sorting.\\nSpace `O(1)` extra space, in-place sort\\n\\nTime can be easily improved to `O(N)`,\\nby quick selecting the `k`th negative.\\n<br>\\n\\n**Java**\\n```java\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        for (int i = 0; K > 0 && i < A.length && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        int res = 0, min = Integer.MAX_VALUE;\\n        for (int a : A) {\\n            res += a;\\n            min = Math.min(min, a);\\n        }\\n        return res - (K % 2) * min * 2;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        for (int i = 0; K > 0 && i < A.size() && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        return accumulate(A.begin(), A.end(), 0) - (K%2) * *min_element(A.begin(), A.end()) * 2;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def largestSumAfterKNegations(self, A, K):\\n        A.sort()\\n        i = 0\\n        while i < len(A) and i < K and A[i] < 0:\\n            A[i] = -A[i]\\n            i += 1\\n        return sum(A) - (K - i) % 2 * min(A) * 2\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        for (int i = 0; K > 0 && i < A.length && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        int res = 0, min = Integer.MAX_VALUE;\\n        for (int a : A) {\\n            res += a;\\n            min = Math.min(min, a);\\n        }\\n        return res - (K % 2) * min * 2;\\n    }\\n```\n```cpp\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        for (int i = 0; K > 0 && i < A.size() && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        return accumulate(A.begin(), A.end(), 0) - (K%2) * *min_element(A.begin(), A.end()) * 2;\\n    }\\n```\n```py\\n    def largestSumAfterKNegations(self, A, K):\\n        A.sort()\\n        i = 0\\n        while i < len(A) and i < K and A[i] < 0:\\n            A[i] = -A[i]\\n            i += 1\\n        return sum(A) - (K - i) % 2 * min(A) * 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 252228,
                "title": "a-very-simple-java-solution",
                "content": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        \\n        for(int x: A) pq.add(x);\\n        while( K--  > 0) pq.add(-pq.poll());\\n  \\n        int sum  = 0;\\n        for(int i = 0; i < A.length; i++){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        \\n        for(int x: A) pq.add(x);\\n        while( K--  > 0) pq.add(-pq.poll());\\n  \\n        int sum  = 0;\\n        for(int i = 0; i < A.length; i++){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252849,
                "title": "c-java-o-n-o-1",
                "content": "Since the ```A[i]``` is limited to [-100, 100], we can use an fixed-size array ```cnt``` to count occurrences. Bucket sort (or, more precise, countint sort), in other words :)\\n\\nThen, as we process numbers ```[-100, 100]```, we flip the negative numbers by moving count from ```cnt[i + 100]``` to ```cnt[-i + 100]```. This guaranties that, if ```K > 0``` after processing all negative numbers, the first positive number will have the smallest absolute value.\\n\\nTherefore, when we encounter the first positive number, and our ```K % 2 == 1```, we negate one occurrence of that number.\\n```\\nint largestSumAfterKNegations(vector<int>& A, int K) {\\n  int cnt[201] = {}, j = -100;\\n  for (auto i : A) ++cnt[i + 100];\\n  for (auto i = -100; i <= 100 && K; ++i) {\\n    if (cnt[i + 100]) {\\n      auto k = i < 0 ? min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  return accumulate(begin(cnt), end(cnt), 0, [&](int s, int cnt) { return s + cnt * j++; });\\n}\\n```\\nJava version:\\n```\\npublic int largestSumAfterKNegations(int[] A, int K) {\\n  int[] cnt = new int[201];\\n  int res = 0;\\n  for (int i : A) ++cnt[i + 100];\\n  for (int i = -100; i <= 100 && K > 0; ++i) {\\n    if (cnt[i + 100] > 0) {\\n      int k = i < 0 ? Math.min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  for (int i = -100; i <= 100; ++i) res += i * cnt[i + 100];\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```A[i]```\n```cnt```\n```[-100, 100]```\n```cnt[i + 100]```\n```cnt[-i + 100]```\n```K > 0```\n```K % 2 == 1```\n```\\nint largestSumAfterKNegations(vector<int>& A, int K) {\\n  int cnt[201] = {}, j = -100;\\n  for (auto i : A) ++cnt[i + 100];\\n  for (auto i = -100; i <= 100 && K; ++i) {\\n    if (cnt[i + 100]) {\\n      auto k = i < 0 ? min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  return accumulate(begin(cnt), end(cnt), 0, [&](int s, int cnt) { return s + cnt * j++; });\\n}\\n```\n```\\npublic int largestSumAfterKNegations(int[] A, int K) {\\n  int[] cnt = new int[201];\\n  int res = 0;\\n  for (int i : A) ++cnt[i + 100];\\n  for (int i = -100; i <= 100 && K > 0; ++i) {\\n    if (cnt[i + 100] > 0) {\\n      int k = i < 0 ? Math.min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  for (int i = -100; i <= 100; ++i) res += i * cnt[i + 100];\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252596,
                "title": "python-straightforward-self-explanatory-concise",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696962,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while (K--) {\\n            int x = pq.top();\\n            pq.pop();\\n\\n            pq.push(-1 * x);\\n        }\\n        int res = 0;\\n        while (!pq.empty()) {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while (K--) {\\n            int x = pq.top();\\n            pq.pop();\\n\\n            pq.push(-1 * x);\\n        }\\n        int res = 0;\\n        while (!pq.empty()) {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628859,
                "title": "min-heap-o-n-k-log-n-time-o-1-space",
                "content": "Hi LeetCoders \\uD83D\\uDC4B\\nHere is my simple and clean solution to this problem with use of min-heap.\\n\\n**Code:**\\n```\\nfrom heapq import heapify, heapreplace\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        while k and nums[0] < 0:\\n            heapreplace(nums, -nums[0])\\n            k -= 1\\n        if k % 2:\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```\\n\\n**Idea explanation:**\\n* negate negative numbers as many as you can\\n* if ```k % 2 == 1``` negate the smallest element in the heap\\n\\n**Notes:**\\nAvoid using ```heappush + heappop``` because it takes ```O(2 * log (n))``` time, use ```heapreplace``` instead and pay just ```O(log (n))```. Isn\\'t that a great deal?\\n\\n**Algorithm complexity:**\\n*n = len(nums)*\\n*Time complexity: O(n + k * log (n))*\\n*Space complexity: O(1)*\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I hope you learned something and wish you an enjoyable time on LeetCode. \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heapreplace\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        while k and nums[0] < 0:\\n            heapreplace(nums, -nums[0])\\n            k -= 1\\n        if k % 2:\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```\n```k % 2 == 1```\n```heappush + heappop```\n```O(2 * log (n))```\n```heapreplace```\n```O(log (n))```",
                "codeTag": "Java"
            },
            {
                "id": 301380,
                "title": "java-simple-greedy-solution-explained-beats-100",
                "content": "The intution is - \\n1. Sort the array.\\n2. Check if first element of the array is positive.\\n\\ti. If K is even, don\\'t modify anything.\\n\\tii. Else, modify the lowest element.\\n3. Else, mark all -ve elements positive for a given K.\\n4. If K after operations is not even then, mark the lowest element -ve.\\n5. Sum up and return.\\n\\n\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        if (A[0] >= 0 && K % 2 != 0) {\\n            A[0] = - A[0];\\n        } else if (A[0] < 0 ) { //&& K % 2 == 0) {\\n            int change = 0;\\n            while (K > 0 && A[change] < 0 && change < A.length) {\\n                A[change] = - A[change++];\\n                K--;\\n            }\\n            if (K % 2 != 0) {\\n                int index = A[change] < A[change - 1] ? change : change - 1;\\n                A[index] = - A[index];\\n            }\\n        }\\n        for (int val : A) sum += val;\\n        return sum;\\n    }\\n}\\n```\\n\\nIf you liked the post please do upvote and any suggestions are most welcome.\\nPS: I see a few people posting solution with PriorityQueue, which is awesome, however, the question says \\'modify the array\\'.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        if (A[0] >= 0 && K % 2 != 0) {\\n            A[0] = - A[0];\\n        } else if (A[0] < 0 ) { //&& K % 2 == 0) {\\n            int change = 0;\\n            while (K > 0 && A[change] < 0 && change < A.length) {\\n                A[change] = - A[change++];\\n                K--;\\n            }\\n            if (K % 2 != 0) {\\n                int index = A[change] < A[change - 1] ? change : change - 1;\\n                A[index] = - A[index];\\n            }\\n        }\\n        for (int val : A) sum += val;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895079,
                "title": "c-solution-100-faster-memory-efficient",
                "content": "A pure greedy question.\\nAlgorithm\\n1. Sort the vector\\n2. Run a loop until looping variable reaches to size of vector or K.\\n\\t* If the vector element is found greater than or equal to 0, terminate the loop\\n\\t* If the vector element is found less than 0 then negate its value.\\n3. Sort the value again \\n4. Check if looping variable is less than K then calculate its difference. \\n5. If the difference is not divisible by 2 then negate A[0].\\n\\n\\nNote:\\n1. Sorting of vector in step 3 is required to arrange back the numbers to ascending order as in previous loop the negative number was made positive too.\\n2. Step 5 is checked because we can negate a number as many times possible. So we will negate the smallest number only to get maximum result.(Also twice negation of a number results to same number. So the difference is calculated and checked for its divisibility by 2.)\\n3. Sorting and step 5 are showing the greedy nature of the problem.\\n\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        int i, t=0, n=A.size();\\n        \\n        for(i=0; i < min(n, K); i++) {\\n            if(A[t]>=0) break;\\n            \\n            else {\\n                A[t]=-A[t];\\n                t++;\\n            }\\n        }\\n        \\n        sort(A.begin(), A.end());\\n        if(i<K) {\\n            if((K-i)%2) {\\n                A[0]=-A[0];\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(i=0; i<A.size(); i++) {\\n            sum += A[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        int i, t=0, n=A.size();\\n        \\n        for(i=0; i < min(n, K); i++) {\\n            if(A[t]>=0) break;\\n            \\n            else {\\n                A[t]=-A[t];\\n                t++;\\n            }\\n        }\\n        \\n        sort(A.begin(), A.end());\\n        if(i<K) {\\n            if((K-i)%2) {\\n                A[0]=-A[0];\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(i=0; i<A.size(); i++) {\\n            sum += A[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278596,
                "title": "heapq-python",
                "content": "```\\nimport heapq\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        heapq.heapify(A)\\n        while K:\\n            heapq.heapreplace(A, -A[0])\\n            K -= 1\\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        heapq.heapify(A)\\n        while K:\\n            heapq.heapreplace(A, -A[0])\\n            K -= 1\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688733,
                "title": "python-3-min-heap-few-lines-easy-to-read-solution",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, min_heap: List[int], K: int) -> int:\\n        heapify(min_heap)\\n        while K > 0:\\n            heappush(min_heap , - (heappop(min_heap)))            \\n            K -= 1\\n        return sum(min_heap)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, min_heap: List[int], K: int) -> int:\\n        heapify(min_heap)\\n        while K > 0:\\n            heappush(min_heap , - (heappop(min_heap)))            \\n            K -= 1\\n        return sum(min_heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157105,
                "title": "super-simple-c-o-nlog-n-solution-w-explanation",
                "content": "# Intuition\\nSorting is your best friend here. That way we can make as many negative values as possible become positive (maximizing the final sum).\\n\\nThe other key detail to notice is that if every element is already positive, changing the sign of any element twice reduces `k` by $$2$$ without reducing the final sum.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Sort the input\\n2. Loop through as many negatives elements as possible, `k` permitting\\n3. Lastly check if `k` is odd. If it is, then sort the array again and negate the first (a.k.a. smallest) element\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        while(i<nums.size() && nums[i]<0 && k>0)\\n        {\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        if(k%2 == 1)\\n        {\\n            sort(nums.begin(),nums.end());\\n            nums[0] *= -1;\\n        }\\n        int sum = 0;\\n        for(int n : nums)\\n        {\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        while(i<nums.size() && nums[i]<0 && k>0)\\n        {\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        if(k%2 == 1)\\n        {\\n            sort(nums.begin(),nums.end());\\n            nums[0] *= -1;\\n        }\\n        int sum = 0;\\n        for(int n : nums)\\n        {\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808062,
                "title": "easy-to-understand-apprach-without-cases",
                "content": "Basic idea is to sort the array based on their absolute value and then start taking ones having greater absolute value. If we encouter a negative element, we can use one negation to negate it and add it\\'s absolute value, otherwise we have no other option, we have to take it\\'s original value. In the last, we will check if we have some K left i.e. we have to negate more elements. Most optimal choice here is to negate the minimum absolute value element. If K is even, it will not have any effect otherwise we have to subtract it\\'s *absolute value* twice from our sum as we have taken it once before also.\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        int n = A.size();\\n        auto cmp = [](int a, int b) {\\n            return abs(a) > abs(b);\\n        };\\n        \\n        sort(A.begin(), A.end(), cmp);\\n        int sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(A[i] < 0 && K > 0) {\\n                sum += -A[i];\\n                K--;\\n            }\\n            else {\\n                sum += A[i];\\n            }\\n        }\\n        \\n        if(K&1) {\\n            sum -= 2*(abs(A[n-1]));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        int n = A.size();\\n        auto cmp = [](int a, int b) {\\n            return abs(a) > abs(b);\\n        };\\n        \\n        sort(A.begin(), A.end(), cmp);\\n        int sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(A[i] < 0 && K > 0) {\\n                sum += -A[i];\\n                K--;\\n            }\\n            else {\\n                sum += A[i];\\n            }\\n        }\\n        \\n        if(K&1) {\\n            sum -= 2*(abs(A[n-1]));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254652,
                "title": "beat-94-56-with-explain-o-nlgn",
                "content": "Sort the array first.\\n\\nThe negation rules are quite simple\\uFF1A\\n\\n1. execute negation for K times\\uFF0Cso use a for loop\\n2. after negation, if the next number (if has) is smaller, the next number is next to negation (if still in for loop). Here we use a greedy strategy. If the next number is non-negative and smaller than the current one, negation it will result in less sum loss(for example current is 4, and next is 1), if the next number is negative and smaller than the current one, negation it will result in more sum (for example current is 4 and next is -3). \\n\\nAfter that , compute the sum.\\n\\n    class Solution {\\n        public int largestSumAfterKNegations(int[] A, int K) {\\n            Arrays.sort(A);\\n            int idx = 0;\\n            for (int i = 0; i < K; ++i) {\\n                A[idx] = -A[idx];\\n                if (idx + 1 < A.length) {\\n                    if (A[idx + 1] < A[idx]) idx += 1;\\n                }\\n            }\\n            int sum = 0;\\n            for (int i = 0; i < A.length; ++i) sum += A[i];\\n            return sum;\\n        }\\n    }\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n        public int largestSumAfterKNegations(int[] A, int K) {\\n            Arrays.sort(A);\\n            int idx = 0;\\n            for (int i = 0; i < K; ++i) {\\n                A[idx] = -A[idx];\\n                if (idx + 1 < A.length) {\\n                    if (A[idx + 1] < A[idx]) idx += 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 384970,
                "title": "python-5-lines-very-easy-solution",
                "content": "```python\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K):\\n\\t\\tfor _ in range(K):\\n            target = min(A)\\n            A.remove(target)\\n            A.append(-target)\\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K):\\n\\t\\tfor _ in range(K):\\n            target = min(A)\\n            A.remove(target)\\n            A.append(-target)\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776207,
                "title": "simple-java-solution-stream-api",
                "content": "```\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n\\n        var minHeap = new PriorityQueue<Integer>(Arrays.stream(nums).boxed().toList());\\n        \\n        IntStream.range(0, k).forEach(i -> minHeap.add(-minHeap.remove()));\\n        \\n        return minHeap.stream().reduce(0, (intermediateResult, num) -> intermediateResult + num);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n\\n        var minHeap = new PriorityQueue<Integer>(Arrays.stream(nums).boxed().toList());\\n        \\n        IntStream.range(0, k).forEach(i -> minHeap.add(-minHeap.remove()));\\n        \\n        return minHeap.stream().reduce(0, (intermediateResult, num) -> intermediateResult + num);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120243,
                "title": "weeb-explains-python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/deac20d6-f25b-4f9f-9a91-4f79bcb66724_1620122556.4046779.png)\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\t\\t\\tA.sort()\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i < len(A) and K>0:\\n\\t\\t\\t\\tif A[i] < 0: # negative value\\n\\t\\t\\t\\t\\tA[i] = A[i] * -1 # update the list, change negative to positive\\n\\t\\t\\t\\t\\tK-=1\\n\\n\\t\\t\\t\\telif A[i] > 0: # positive value\\n\\t\\t\\t\\t\\tif K % 2 == 0: # let K==2(must be even value), this means -1*-1==1 so it has no effect on sum\\n\\t\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\t\\telse: return sum(A) - 2 * min(A) # let A==[1,2,3],K=1, so equation is 6-2(1)==4, same as -1+2+3=4 after taking the minimum in the list to give the largest possible sum required in the question\\n\\n\\t\\t\\t\\telse: return sum(A) # if A[i]==0,just sum cuz 0 is neutral: 1-0==1 or 1+0==1 thus no change just sum\\n\\n\\t\\t\\t\\ti+=1\\n\\n\\t\\t\\tif K > len(A): # that means we have changed all values to positive\\n\\t\\t\\t\\tA.sort() # cuz now its the opposite let A = [-4,-2,-3], K = 8, now flipping all negatives to positives, we have a new minimum which is 2\\n\\t\\t\\t\\tif K % 2 == 0: # Here onwards is basically the same thing from before\\n\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\telse: return sum(A) - 2 * min(A)\\n\\n\\t\\t\\treturn sum(A)\\n\\nAight, time for some anime recommendations\\n# try watching ***Uzaki-chan Wants to Hang Out!***\\n# Genres: Romantic comedy, Slice of life\\n# Episodes: 12\\n\\nOverall, this anime is quite fun to watch. Although i have to warn you, this anime does contain some ecchi(perverted) elements in it, but its not extreme.\\n\\nNow go take a break and watch some anime.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/deac20d6-f25b-4f9f-9a91-4f79bcb66724_1620122556.4046779.png)\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\t\\t\\tA.sort()\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i < len(A) and K>0:\\n\\t\\t\\t\\tif A[i] < 0: # negative value\\n\\t\\t\\t\\t\\tA[i] = A[i] * -1 # update the list, change negative to positive\\n\\t\\t\\t\\t\\tK-=1\\n\\n\\t\\t\\t\\telif A[i] > 0: # positive value\\n\\t\\t\\t\\t\\tif K % 2 == 0: # let K==2(must be even value), this means -1*-1==1 so it has no effect on sum\\n\\t\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\t\\telse: return sum(A) - 2 * min(A) # let A==[1,2,3],K=1, so equation is 6-2(1)==4, same as -1+2+3=4 after taking the minimum in the list to give the largest possible sum required in the question\\n\\n\\t\\t\\t\\telse: return sum(A) # if A[i]==0,just sum cuz 0 is neutral: 1-0==1 or 1+0==1 thus no change just sum\\n\\n\\t\\t\\t\\ti+=1\\n\\n\\t\\t\\tif K > len(A): # that means we have changed all values to positive\\n\\t\\t\\t\\tA.sort() # cuz now its the opposite let A = [-4,-2,-3], K = 8, now flipping all negatives to positives, we have a new minimum which is 2\\n\\t\\t\\t\\tif K % 2 == 0: # Here onwards is basically the same thing from before\\n\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\telse: return sum(A) - 2 * min(A)\\n\\n\\t\\t\\treturn sum(A)\\n\\nAight, time for some anime recommendations\\n# try watching ***Uzaki-chan Wants to Hang Out!***\\n# Genres: Romantic comedy, Slice of life\\n# Episodes: 12\\n\\nOverall, this anime is quite fun to watch. Although i have to warn you, this anime does contain some ecchi(perverted) elements in it, but its not extreme.\\n\\nNow go take a break and watch some anime.\\n",
                "codeTag": "Java"
            },
            {
                "id": 891225,
                "title": "java-easy-to-understand",
                "content": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n\\n        for(int i = 0; i < A.length && K > 0 && A[i] < 0; i++){\\n            A[i] = -A[i];\\n            K--;\\n        }\\n\\n        Arrays.sort(A);\\n        for(int a : A) sum+= a;\\n        if(K > 0 && K % 2 == 1){\\n            sum -= A[0] * 2;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n\\n        for(int i = 0; i < A.length && K > 0 && A[i] < 0; i++){\\n            A[i] = -A[i];\\n            K--;\\n        }\\n\\n        Arrays.sort(A);\\n        for(int a : A) sum+= a;\\n        if(K > 0 && K % 2 == 1){\\n            sum -= A[0] * 2;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252410,
                "title": "o-n-k-logn-using-min-heap",
                "content": "1.build a min-heap (cost O(n));\\n2.negate the root node\\'s val then heapify the heap\\nrepeat step 2  K times\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void heapify(int arr[], int n, int i) { \\n        int smallest = i;  \\n        int l = 2*i + 1; // left = 2*i + 1 \\n        int r = 2*i + 2; // right = 2*i + 2 \\n        if (l < n && arr[l] < arr[smallest]) smallest = l; \\n        if (r < n && arr[r] < arr[smallest]) smallest = r; \\n        if (smallest != i) { \\n            swap(arr[i], arr[smallest]); \\n            heapify(arr, n, smallest); \\n        } \\n    } \\n  \\n    void helper(int arr[], int n, int K) { \\n        for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);   \\n        for(int i = 0; i < K; ++i) {\\n            arr[0] = -arr[0];\\n            heapify(arr, n, 0);\\n        }\\n    } \\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        if(A.empty()) return -1;\\n        int sum = 0;\\n        helper(A.data(), A.size(), K);\\n        for(auto &e:A) sum += e;\\n        return sum;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void heapify(int arr[], int n, int i) { \\n        int smallest = i;  \\n        int l = 2*i + 1; // left = 2*i + 1 \\n        int r = 2*i + 2; // right = 2*i + 2 \\n        if (l < n && arr[l] < arr[smallest]) smallest = l; \\n        if (r < n && arr[r] < arr[smallest]) smallest = r; \\n        if (smallest != i) { \\n            swap(arr[i], arr[smallest]); \\n            heapify(arr, n, smallest); \\n        } \\n    } \\n  \\n    void helper(int arr[], int n, int K) { \\n        for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);   \\n        for(int i = 0; i < K; ++i) {\\n            arr[0] = -arr[0];\\n            heapify(arr, n, 0);\\n        }\\n    } \\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        if(A.empty()) return -1;\\n        int sum = 0;\\n        helper(A.data(), A.size(), K);\\n        for(auto &e:A) sum += e;\\n        return sum;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637579,
                "title": "python-3-min-heap-for-negative-values-with-comments-beats-80",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # if k <= n(count of negative numbers )=> need make highest negative values positive (here using heap for this)\\n        # if k > n(count of negative numbers) and k-n is odd => need make all negative numbers positive and minVal make negative\\n        heap, res, minVal = [], 0, 101\\n\\n        for n in nums:\\n            if n > 0: res += n\\n            elif n < 0: heappush(heap, n)\\n            minVal = min(minVal, abs(n))\\n\\n        # make highest negative values positive while k opertions available\\n        while heap and k > 0:\\n            res += -heappop(heap) #add negative value\\n            k -= 1\\n        # if still exists negative value, just add them to final sum\\n        if heap:\\n            res += sum(heap)\\n        # if k > 0 and it\\'s odd need make minVal negative (if 0 exists it will be smalles value)\\n        if k % 2:\\n            res = res - 2 * minVal\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # if k <= n(count of negative numbers )=> need make highest negative values positive (here using heap for this)\\n        # if k > n(count of negative numbers) and k-n is odd => need make all negative numbers positive and minVal make negative\\n        heap, res, minVal = [], 0, 101\\n\\n        for n in nums:\\n            if n > 0: res += n\\n            elif n < 0: heappush(heap, n)\\n            minVal = min(minVal, abs(n))\\n\\n        # make highest negative values positive while k opertions available\\n        while heap and k > 0:\\n            res += -heappop(heap) #add negative value\\n            k -= 1\\n        # if still exists negative value, just add them to final sum\\n        if heap:\\n            res += sum(heap)\\n        # if k > 0 and it\\'s odd need make minVal negative (if 0 exists it will be smalles value)\\n        if k % 2:\\n            res = res - 2 * minVal\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738913,
                "title": "java-ms-solution",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }\\n                else\\n                {\\n                    count+=i;\\n                }\\n            }\\n            else if(i==0)\\n            {\\n                k=0;\\n            }\\n            else\\n            {\\n                if(k%2==0)\\n                {\\n                    count+=i;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    if(prev==0)\\n                    {\\n                        count+=(-1*i);\\n                        k=0;\\n                    }\\n                    else\\n                    {\\n                        if(prev>i || Math.abs(prev)>i)\\n                        {\\n                            count+=(-1*i);\\n                        }\\n                        else\\n                        {\\n                            count+=prev;\\n                            count+=(prev + i);\\n                        }\\n                        k=0;\\n                    }\\n                }\\n            }\\n        }\\n        if(k%2!=0)\\n        {\\n            count+=(prev + prev);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }\\n                else\\n                {\\n                    count+=i;\\n                }\\n            }\\n            else if(i==0)\\n            {\\n                k=0;\\n            }\\n            else\\n            {\\n                if(k%2==0)\\n                {\\n                    count+=i;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    if(prev==0)\\n                    {\\n                        count+=(-1*i);\\n                        k=0;\\n                    }\\n                    else\\n                    {\\n                        if(prev>i || Math.abs(prev)>i)\\n                        {\\n                            count+=(-1*i);\\n                        }\\n                        else\\n                        {\\n                            count+=prev;\\n                            count+=(prev + i);\\n                        }\\n                        k=0;\\n                    }\\n                }\\n            }\\n        }\\n        if(k%2!=0)\\n        {\\n            count+=(prev + prev);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241273,
                "title": "100-faster-sol-c",
                "content": "The time complexity of this approach is O(n+n log n).\\nhope you will find it helpful.\\n```\\nint largestSumAfterKNegations(vector<int>& nums, int k) {\\n       sort(nums.begin(),nums.end());\\n        int i=0,sum=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0&& k>0)\\n            {\\n                nums[i]*=(-1);\\n                k--;\\n            }\\n            else if(nums[i]>=0)\\n                break;\\n            i++;\\n        }\\n        if(k%2!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n                nums[0]*=(-1);           \\n        }               \\n        for(auto a:nums)\\n            sum+=a;\\n        return sum; \\n    }\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint largestSumAfterKNegations(vector<int>& nums, int k) {\\n       sort(nums.begin(),nums.end());\\n        int i=0,sum=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0&& k>0)\\n            {\\n                nums[i]*=(-1);\\n                k--;\\n            }\\n            else if(nums[i]>=0)\\n                break;\\n            i++;\\n        }\\n        if(k%2!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n                nums[0]*=(-1);           \\n        }               \\n        for(auto a:nums)\\n            sum+=a;\\n        return sum; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753580,
                "title": "c-easy-heap-solution",
                "content": "```\\nBefore discussing the problem, let me tell you something, it\\'s our coding nature \\nwhen we see to find max/min sum , element we think of sorting . But what if i tell \\nyou do sorting but in a better and optimized way, sort only those elements which \\nneed to be sorted.\\n\\nOk let\\'s talk about logic to the problem, we have to negate any index element \\nk times so array elements yields max sum. So it is clear we have to always \\nnegate smallest element, so we can use \" min Heap \" which will ensure you have \\nsmallest element always on top no matter how many insertion or deletion you make.\\n```\\n```\\nclass Solution {\\npublic:\\n    int find_sum(vector<int>&v, int k){\\n        priority_queue<int,vector<int>,greater<int>>q;       // Mean Heap\\n        for(int i=0; i<v.size(); i++)\\n            q.push(v[i]);\\n        while(k){                        // Negate k times ( min element will always be on top )\\n            int res = -q.top();\\n            q.pop();\\n            q.push(res);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n        return sum;\\n    }\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = find_sum(nums,k);\\n        return sum;\\n    }\\n};\\n```\\n```\\nLet me tell you a secret, if question is based on array and you feel there is a need of sorting always think of heap solution as a possibility.\\n```\\nIf you liked my solution please upvote to motivate me. Happy Coding :)\\n",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nBefore discussing the problem, let me tell you something, it\\'s our coding nature \\nwhen we see to find max/min sum , element we think of sorting . But what if i tell \\nyou do sorting but in a better and optimized way, sort only those elements which \\nneed to be sorted.\\n\\nOk let\\'s talk about logic to the problem, we have to negate any index element \\nk times so array elements yields max sum. So it is clear we have to always \\nnegate smallest element, so we can use \" min Heap \" which will ensure you have \\nsmallest element always on top no matter how many insertion or deletion you make.\\n```\n```\\nclass Solution {\\npublic:\\n    int find_sum(vector<int>&v, int k){\\n        priority_queue<int,vector<int>,greater<int>>q;       // Mean Heap\\n        for(int i=0; i<v.size(); i++)\\n            q.push(v[i]);\\n        while(k){                        // Negate k times ( min element will always be on top )\\n            int res = -q.top();\\n            q.pop();\\n            q.push(res);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n        return sum;\\n    }\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = find_sum(nums,k);\\n        return sum;\\n    }\\n};\\n```\n```\\nLet me tell you a secret, if question is based on array and you feel there is a need of sorting always think of heap solution as a possibility.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582378,
                "title": "c-only-for-beginners-simple-and-clean-solution",
                "content": "**Please Upvote If it helped You !!!\\nHappy Coding :)**\\n```\\nint largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        \\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        while(k>0)\\n        {\\n            nums[0]= -1*nums[0];\\n            k--;\\n            sort(nums.begin(),nums.end());\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum= sum+nums[i];\\n        }\\n        return sum;\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        \\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        while(k>0)\\n        {\\n            nums[0]= -1*nums[0];\\n            k--;\\n            sort(nums.begin(),nums.end());\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum= sum+nums[i];\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385477,
                "title": "python-logic",
                "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \\n        while k > 0:\\n            nums.sort()\\n            nums[0] = nums[0] * -1\\n            k = k -1\\n        return sum(nums)\\n            \\n## \\t\\t\\t``",
                "solutionTags": [],
                "code": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \\n        while k > 0:\\n            nums.sort()\\n            nums[0] = nums[0] * -1\\n            k = k -1\\n        return sum(nums)\\n            \\n## \\t\\t\\t``",
                "codeTag": "Java"
            },
            {
                "id": 1191474,
                "title": "javascript-concise",
                "content": "```\\nvar largestSumAfterKNegations = function(A, K) {\\n    while(K > 0 ){ \\n        let v = Math.min(...A)\\n        let i = A.indexOf(v)\\n        A[i] = - A[i]\\n        K--\\n    }\\n    \\n    return A.reduce((a,c) => a+c,0)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestSumAfterKNegations = function(A, K) {\\n    while(K > 0 ){ \\n        let v = Math.min(...A)\\n        let i = A.indexOf(v)\\n        A[i] = - A[i]\\n        K--\\n    }\\n    \\n    return A.reduce((a,c) => a+c,0)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 518152,
                "title": "simple-java-solution",
                "content": "```\\npublic int largestSumAfterKNegations(int[] arr, int k) {\\n\\tArrays.sort(arr);\\n\\tint sum = 0, len = arr.length, minIndex = 0;\\n\\twhile (k > 0) {\\n\\t\\tarr[minIndex] *= -1;\\n\\t\\tk--;\\n\\t\\tif (minIndex + 1 < len && arr[minIndex] > arr[minIndex + 1]) minIndex++;\\n\\t}\\n\\tfor (int i : arr) sum += i;\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int largestSumAfterKNegations(int[] arr, int k) {\\n\\tArrays.sort(arr);\\n\\tint sum = 0, len = arr.length, minIndex = 0;\\n\\twhile (k > 0) {\\n\\t\\tarr[minIndex] *= -1;\\n\\t\\tk--;\\n\\t\\tif (minIndex + 1 < len && arr[minIndex] > arr[minIndex + 1]) minIndex++;\\n\\t}\\n\\tfor (int i : arr) sum += i;\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252520,
                "title": "java-solution-o-1-space-one-pass",
                "content": "Traverse the array, track the number of negative elements\\nIf number of negative elements is smaller than K, we can flip it to positive, otherwise, keep it as negative.\\nAfter the traversal, if we still have K - count flips to finish, it means we have flipped all negative elements, and have to touch a positive element. if K - count is even, flip any element is ok since it does not change anything. If K - count is odd, choose the smallest element which we have kept tracking in the traversal by minPositive.\\n\\n```java\\n        Arrays.sort(A);\\n        int count = 0, sum = 0, minPositive = Integer.MAX_VALUE;\\n        for (int num : A) {\\n            if (num < 0 && ++count <= K) {\\n                num = -num;\\n            }\\n            sum += num;\\n            minPositive = Math.min(minPositive, num);\\n        }\\n        if (count > K || (K - count) % 2 == 0) {\\n            return sum;\\n        } else {\\n            return sum - minPositive * 2;\\n        }\\n```",
                "solutionTags": [],
                "code": "```java\\n        Arrays.sort(A);\\n        int count = 0, sum = 0, minPositive = Integer.MAX_VALUE;\\n        for (int num : A) {\\n            if (num < 0 && ++count <= K) {\\n                num = -num;\\n            }\\n            sum += num;\\n            minPositive = Math.min(minPositive, num);\\n        }\\n        if (count > K || (K - count) % 2 == 0) {\\n            return sum;\\n        } else {\\n            return sum - minPositive * 2;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2478851,
                "title": "java-easy-priority-queue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        for(int n:nums){\\n            q.add(n);\\n        }\\n        while(k>0)\\n        {\\n            int val=q.poll();\\n            q.add(-val);\\n            k--;\\n        }\\n        int sum=0;\\n        while(!q.isEmpty())\\n        {\\n            sum+=q.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        for(int n:nums){\\n            q.add(n);\\n        }\\n        while(k>0)\\n        {\\n            int val=q.poll();\\n            q.add(-val);\\n            k--;\\n        }\\n        int sum=0;\\n        while(!q.isEmpty())\\n        {\\n            sum+=q.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431212,
                "title": "3ms-t-c-java-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        Arrays.sort(nums);\\n\\n        int sum = 0;\\n        int min = 100;\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right){\\n            min = Math.min(min, Math.abs(nums[left]));\\n            if (k == 0) {\\n                sum += nums[left];\\n                left++;\\n            }\\n            else if (nums[right] < Math.abs(nums[left])){\\n                sum += Math.abs(nums[left]);\\n                left++;\\n                k--;\\n            }\\n            else {\\n                sum += nums[right];\\n                right--;\\n            }\\n        }\\n\\n        return k % 2 == 0 ? sum : sum - 2 * min;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816680,
                "title": "fastest-3-liner-solution-with-inbuilt-functions",
                "content": "```\\nvar largestSumAfterKNegations = function(nums, k) {\\n    while(k>0){\\n        let i = nums.indexOf(Math.min(...nums)); //find the index of minimum item in array using inbuilt function\\n        nums[i]*=-1; //Toggle the minimum value to get the maximum sum\\n        k--;\\n    }\\n    return nums.reduce((acc, curr)=>acc+curr); //return the sum using reduce function\\n};\\n```\\n\\n**Please upvote if I could help**\\nOpen to Suggestions :)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestSumAfterKNegations = function(nums, k) {\\n    while(k>0){\\n        let i = nums.indexOf(Math.min(...nums)); //find the index of minimum item in array using inbuilt function\\n        nums[i]*=-1; //Toggle the minimum value to get the maximum sum\\n        k--;\\n    }\\n    return nums.reduce((acc, curr)=>acc+curr); //return the sum using reduce function\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756738,
                "title": "java-simple-explained",
                "content": "**Idea:**\\n* To maximize the sum, negate the negatives and then the smallest number\\n* Negation of negation of n gives back n. \\n* This means if k is even, then we can exhaust it on the smallest int without changing it. So ignore even value k after loop  \\n* If k is odd, only then you need to actually negate the smallest int for maximum sum\\n>**T/S:** O(n lg n)/O(1), where n = size(nums) (ignored extra space of Arrays.sort)\\n```\\npublic int largestSumAfterKNegations(int[] nums, int k) {\\n\\tArrays.sort(nums);\\n\\tvar minIndex = 0;\\n\\t\\n\\tfor (var i = 0; i < nums.length && k > 0; i++) {\\n\\t\\tif (nums[i] < 0) {\\n\\t\\t\\tnums[i] *= -1;\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\tif (nums[minIndex] > nums[i])\\n\\t\\t\\tminIndex = i;\\n\\t}\\n\\n\\tif ((k & 1) == 1)\\n\\t\\tnums[minIndex] *= -1;\\n\\t\\t\\n\\treturn Arrays.stream(nums)\\n\\t\\t\\t\\t .sum();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int largestSumAfterKNegations(int[] nums, int k) {\\n\\tArrays.sort(nums);\\n\\tvar minIndex = 0;\\n\\t\\n\\tfor (var i = 0; i < nums.length && k > 0; i++) {\\n\\t\\tif (nums[i] < 0) {\\n\\t\\t\\tnums[i] *= -1;\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\tif (nums[minIndex] > nums[i])\\n\\t\\t\\tminIndex = i;\\n\\t}\\n\\n\\tif ((k & 1) == 1)\\n\\t\\tnums[minIndex] *= -1;\\n\\t\\t\\n\\treturn Arrays.stream(nums)\\n\\t\\t\\t\\t .sum();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388659,
                "title": "c-greedy-using-priority-queue-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375639,
                "title": "1005-maximize-sum-of-array-after-k-negations",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # sort nums according to each num\\'s absolute value in descending order\\n        nums = sorted(nums, key = abs, reverse = True)\\n        \\n        # we first negate the smallest negative num (it\\'s absolute value is the largest), so it adds most to the sum of nums\\n        for i in range(len(nums)):\\n            if k > 0 and nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n        \\n        # after negating all negative numbers, if k is still not zero (we need to do more negation), we negate the smallest positive number (which is the last element in nums) k times. Only if k is odd it will be negated \\n        if k % 2 == 1:\\n            nums[-1] *= -1\\n        \\n        return sum(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # sort nums according to each num\\'s absolute value in descending order\\n        nums = sorted(nums, key = abs, reverse = True)\\n        \\n        # we first negate the smallest negative num (it\\'s absolute value is the largest), so it adds most to the sum of nums\\n        for i in range(len(nums)):\\n            if k > 0 and nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n        \\n        # after negating all negative numbers, if k is still not zero (we need to do more negation), we negate the smallest positive number (which is the last element in nums) k times. Only if k is odd it will be negated \\n        if k % 2 == 1:\\n            nums[-1] *= -1\\n        \\n        return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285244,
                "title": "java-solution-priority-queue-code-with-comments",
                "content": "```\\n// TC: O(nlogn)\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        // Create a priority queue and insert all array elements in the priority queue      TC: O(n)\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int num : nums)\\n            pq.add(num);\\n        // Do k negations by removing a minimum element k times         TC: O(log n)\\n        while(k--> 0) {\\n            int temp = pq.poll();   // Retrieve and remove min element\\n            \\n            temp *= -1;     // Modify the min element and add it back to priority queue\\n            pq.add(temp);\\n        }\\n        \\n        // Compute sum of all elements in priority queue\\n        int sum = 0;\\n        for(int num : pq)\\n            sum += num;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// TC: O(nlogn)\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        // Create a priority queue and insert all array elements in the priority queue      TC: O(n)\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int num : nums)\\n            pq.add(num);\\n        // Do k negations by removing a minimum element k times         TC: O(log n)\\n        while(k--> 0) {\\n            int temp = pq.poll();   // Retrieve and remove min element\\n            \\n            temp *= -1;     // Modify the min element and add it back to priority queue\\n            pq.add(temp);\\n        }\\n        \\n        // Compute sum of all elements in priority queue\\n        int sum = 0;\\n        for(int num : pq)\\n            sum += num;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001349,
                "title": "java-straightforward-priority-queue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int x : A) {\\n            pq.offer(x);\\n        }\\n        while (K > 0) {\\n            pq.offer(-pq.poll());\\n            K--;\\n        }\\n        return pq.stream().mapToInt(i -> i).sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int x : A) {\\n            pq.offer(x);\\n        }\\n        while (K > 0) {\\n            pq.offer(-pq.poll());\\n            K--;\\n        }\\n        return pq.stream().mapToInt(i -> i).sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875597,
                "title": "python-4-lines-heapq-o-n-klogn",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): \\n            heapq.heapreplace(A, -A[0])\\n        return sum(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): \\n            heapq.heapreplace(A, -A[0])\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515509,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(A, K) {\\n  A.sort((a, b) => a - b);\\n  for (let i = 0; i < A.length && K > 0 && A[i] < 0; i++, K--) A[i] = -A[i];\\n  if (K > 0 && K % 2 == 1) {\\n    const minI = A.reduce((min, cur, i) => (cur < A[min] ? i : min), 0);\\n    A[minI] = -A[minI];\\n  }\\n  return A.reduce((acc, cur) => acc + cur);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(A, K) {\\n  A.sort((a, b) => a - b);\\n  for (let i = 0; i < A.length && K > 0 && A[i] < 0; i++, K--) A[i] = -A[i];\\n  if (K > 0 && K % 2 == 1) {\\n    const minI = A.reduce((min, cur, i) => (cur < A[min] ? i : min), 0);\\n    A[minI] = -A[minI];\\n  }\\n  return A.reduce((acc, cur) => acc + cur);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350855,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n    \\tS, a = sum(A), sorted([i for i in A if i < 0])\\n    \\tL, b = len(a), min([i for i in A if i >= 0])\\n    \\tif L == 0: return S if K % 2 == 0 else S - 2*b\\n    \\tif K <= L or (K - L) % 2 == 0: return S - 2*sum(a[:min(K,L)])\\n    \\treturn S - 2*sum(a[:-1]) if -a[-1] < b else S - 2*sum(a) - 2*b\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n    \\tS, a = sum(A), sorted([i for i in A if i < 0])\\n    \\tL, b = len(a), min([i for i in A if i >= 0])\\n    \\tif L == 0: return S if K % 2 == 0 else S - 2*b\\n    \\tif K <= L or (K - L) % 2 == 0: return S - 2*sum(a[:min(K,L)])\\n    \\treturn S - 2*sum(a[:-1]) if -a[-1] < b else S - 2*sum(a) - 2*b\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 253429,
                "title": "java-solutions",
                "content": "**Solution 1: Linear Search Approach**\\n\\n- The idea is to replace the minimum element `A[minIndex]` in array by `-A[minIndex]` for current operation. In this way we can make `sum` of array maximum after `K` operations. \\n- One interesting case is, once minimum element becomes `0`, we don\\u2019t need to make any more changes.\\n- Here we use linear search to find minimum element. So the time complexity of the this solution is `O(K * n)`.\\n\\nTime complexity: `O(K * n)` - where `n` is the length of an input array.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        int sum = 0;\\n        \\n        while(K-- > 0)\\n        {\\n            int minIndex = findMinIndex(A);\\n\\t\\t\\t\\n\\t\\t\\tif(A[minIndex] == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n                A[minIndex] = -A[minIndex];\\n        }\\n        \\n        for(int n : A)\\n            sum += n;\\n        return sum;\\n    }\\n    \\n    private int findMinIndex(int[] A)\\n    {\\n        int minIndex = 0;\\n\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            if(A[i] <= A[minIndex])\\n                minIndex = i;\\n        }\\n        return minIndex;\\n    }\\n}\\n```\\n\\n**Solution 2: Using minHeap**\\n\\n- Here an optimized solution is implemented that uses a `PriorityQueue` to find the minimum element quickly.\\n- The time complexity to insert `n` elements in to the `PriorityQueue` takes `O(n log n)` time in the general case. An `O(n)` algorithm exists for the special case where the input is already ordered, but this is not provided in `java.util.PriorityQueue` class. Also adding and removing `K` elements from the `minHeap` of size `n` takes `O(K log n)`, so the total complexity is `O(n log n + K log n) = (n + K) * log n`.\\n\\nTime complexity: `O(n log n + K log n) = (n + K) * log n` - where `n` is the length of an input array.\\nSpace complexity: `O(n)` - space required for the `minHeap`\\n\\n```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        int sum = 0;\\n        \\n        for(int n : A)\\n            minHeap.add(n);\\n        \\n        while(K-- > 0 && minHeap.peek() != 0)\\n            minHeap.add(-minHeap.poll());\\n        \\n        while(!minHeap.isEmpty())\\n            sum += minHeap.poll();\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        int sum = 0;\\n        \\n        while(K-- > 0)\\n        {\\n            int minIndex = findMinIndex(A);\\n\\t\\t\\t\\n\\t\\t\\tif(A[minIndex] == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n                A[minIndex] = -A[minIndex];\\n        }\\n        \\n        for(int n : A)\\n            sum += n;\\n        return sum;\\n    }\\n    \\n    private int findMinIndex(int[] A)\\n    {\\n        int minIndex = 0;\\n\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            if(A[i] <= A[minIndex])\\n                minIndex = i;\\n        }\\n        return minIndex;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        int sum = 0;\\n        \\n        for(int n : A)\\n            minHeap.add(n);\\n        \\n        while(K-- > 0 && minHeap.peek() != 0)\\n            minHeap.add(-minHeap.poll());\\n        \\n        while(!minHeap.isEmpty())\\n            sum += minHeap.poll();\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545228,
                "title": "explanation-of-the-whole-idea",
                "content": "## Explanation\\n```\\nAssume nums = [8,-1,8,-3,2,-2], k = 2\\n\\nTo get the LARGEST SUM we will make positive -3 and -2 as they are the SMALLEST NEGATIVE\\nNUMBERS. This finding process would be easier if we sort first:\\n\\n               -3,-2,-1,2,8,8 \\n\\nIf k were 5, first we would turn all the negative numbers to positive numbers, right?\\nCause the Q asked us LARGEST SUM!\\n\\n               3,2,1,2,8,8 and now k = 5 - 3 = 2\\n\\nAs we can choose the same index multiple times SO AFTER TURNING NEGATIVE NUMBERS\\nTO POSITIVE NUMBERS, OBVIOUSLY WE WILL NOW PICK THE SMALLEST NUMBER TO CHANGE IT\\'S SIGN\\nTO REMAINING K TIMES TO GET THE LARGEST SUM.\\n\\nHere the smallest number now is 1 and k = 2, so -1,1 which is same as 1 cause \\n       if k is even, sign won\\'t change, but if k is odd, sign will change 100%.\\n```\\n\\n```CPP []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        for(int i=0; i<nums.size() && nums[i]<0 && k>0; i++, k--)\\n            nums[i] = -nums[i];    \\n\\n        nums[min_element(begin(nums),end(nums))-begin(nums)] *= ((k&1) == 1? -1 : 1);\\n        return accumulate(begin(nums),end(nums),0);      \\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int :\\n        nums.sort()\\n        i = 0\\n        while i<len(nums) and k>0 and nums[i]<0 :\\n            nums[i] = -nums[i]\\n            i, k = i+1, k-1\\n        nums[nums.index(min(nums))] *= -1 if k&1 else 1\\n        return sum(nums) \\n```\\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(sort)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nAssume nums = [8,-1,8,-3,2,-2], k = 2\\n\\nTo get the LARGEST SUM we will make positive -3 and -2 as they are the SMALLEST NEGATIVE\\nNUMBERS. This finding process would be easier if we sort first:\\n\\n               -3,-2,-1,2,8,8 \\n\\nIf k were 5, first we would turn all the negative numbers to positive numbers, right?\\nCause the Q asked us LARGEST SUM!\\n\\n               3,2,1,2,8,8 and now k = 5 - 3 = 2\\n\\nAs we can choose the same index multiple times SO AFTER TURNING NEGATIVE NUMBERS\\nTO POSITIVE NUMBERS, OBVIOUSLY WE WILL NOW PICK THE SMALLEST NUMBER TO CHANGE IT\\'S SIGN\\nTO REMAINING K TIMES TO GET THE LARGEST SUM.\\n\\nHere the smallest number now is 1 and k = 2, so -1,1 which is same as 1 cause \\n       if k is even, sign won\\'t change, but if k is odd, sign will change 100%.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        for(int i=0; i<nums.size() && nums[i]<0 && k>0; i++, k--)\\n            nums[i] = -nums[i];    \\n\\n        nums[min_element(begin(nums),end(nums))-begin(nums)] *= ((k&1) == 1? -1 : 1);\\n        return accumulate(begin(nums),end(nums),0);      \\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int :\\n        nums.sort()\\n        i = 0\\n        while i<len(nums) and k>0 and nums[i]<0 :\\n            nums[i] = -nums[i]\\n            i, k = i+1, k-1\\n        nums[nums.index(min(nums))] *= -1 if k&1 else 1\\n        return sum(nums) \\n```\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(sort)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496667,
                "title": "maximize-sum-of-array-after-k-negations-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int i, j=0, sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<k ; i++)\\n        {\\n            if(nums[j]<0)\\n            {\\n                nums[j] *= (-1);\\n                if(j<nums.size()-1 && nums[j+1]<abs(nums[j]))\\n                    j++;\\n            }\\n            else if(nums[j]>=0)\\n            {\\n                nums[j] *= -1;\\n            }\\n        }\\n        sum = accumulate(nums.begin(), nums.end(), 0);\\n        return sum;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4615bd62-f688-4d57-965e-a6968997c323_1683460834.4019096.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int i, j=0, sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<k ; i++)\\n        {\\n            if(nums[j]<0)\\n            {\\n                nums[j] *= (-1);\\n                if(j<nums.size()-1 && nums[j+1]<abs(nums[j]))\\n                    j++;\\n            }\\n            else if(nums[j]>=0)\\n            {\\n                nums[j] *= -1;\\n            }\\n        }\\n        sum = accumulate(nums.begin(), nums.end(), 0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486353,
                "title": "beats-100-java-c-python-non-queue-solution",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\nDont forget to upvote if you like the content below. \\uD83D\\uDE43\\n\\n# Intuition\\nGiven the problem, we should always aim to negate the smallest number in the array in each iteration to maximize the final sum. However, we can use a micro-optimization by calculating the sum once at the beginning and then adjusting it after each negation.\\n\\n# Approach\\nWe start by creating a frequency array, $$numbers$$, with the index representing the number in the original array + $$100$$. This allows us to handle negative numbers seamlessly.\\n\\nNext, we iterate through the $$nums$$ array, count the frequencies, and calculate the sum. Simultaneously, we keep track of the maximum absolute value in the array ($$maxAbs$$), which we will use later to determine the start index for the negation process.\\n\\nIf $$maxAbs$$ is zero after the first pass, it means all elements in the array are zero, and we return $$0$$, as negating zero doesn\\'t change the sum.\\n\\nThen, we perform $$k$$ negations. For each negation, we start at the index $$i$$ equal to $$100 - maxAbs$$, which represents the smallest possible number in the array. We find the first index with a non-zero frequency, decrement its frequency, increment the frequency of its negation $$(200 - i)$$, and adjust the sum by subtracting twice the current number (since we have negated it).\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is $$O(n + k)$$, where $$n$$ is the length of the array and $$k$$ is the number of negations. $$n$$ is for the initial iteration through the nums array, and $$k$$ is for the negations.\\n\\n- Space complexity:\\nThe space complexity is $$O(1)$$, as we only use a constant amount of extra space. The numbers array\\'s size is a constant $$201$$, accommodating all possible values from $$-100$$ to $$100$$.\\n\\nThis solution is optimal for the problem constraints. While a PriorityQueue-based solution could also work, it might not be as fast due to overheads associated with creating and managing the PriorityQueue. Our solution avoids these overheads by using a simple frequency count array and a single pass through the array. The index calculation $$(number + 100)$$ and the negation index calculation $$(200 - index)$$ are straightforward and efficient, making this solution particularly suitable for the given constraints.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        vector<int> numbers(201, 0);\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n : nums) {\\n            maxAbs = max(maxAbs, abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        numbers = [0] * 201\\n        total_sum = 0\\n        max_abs = 0\\n        \\n        for n in nums:\\n            max_abs = max(max_abs, abs(n))\\n            numbers[100 + n] += 1\\n            total_sum += n\\n\\n        if max_abs == 0:\\n            return 0\\n\\n        while k > 0:\\n            k -= 1\\n            i = 100 - max_abs\\n            while numbers[i] == 0:\\n                i += 1\\n            numbers[i] -= 1\\n            numbers[200 - i] += 1\\n            total_sum -= 2 * (i - 100)\\n\\n        return total_sum\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Counting"
                ],
                "code": "```java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        vector<int> numbers(201, 0);\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n : nums) {\\n            maxAbs = max(maxAbs, abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        numbers = [0] * 201\\n        total_sum = 0\\n        max_abs = 0\\n        \\n        for n in nums:\\n            max_abs = max(max_abs, abs(n))\\n            numbers[100 + n] += 1\\n            total_sum += n\\n\\n        if max_abs == 0:\\n            return 0\\n\\n        while k > 0:\\n            k -= 1\\n            i = 100 - max_abs\\n            while numbers[i] == 0:\\n                i += 1\\n            numbers[i] -= 1\\n            numbers[200 - i] += 1\\n            total_sum -= 2 * (i - 100)\\n\\n        return total_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459930,
                "title": "5-line-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nklog(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        int sum=0;\\n        while(k>0)\\n        {\\n                nums[0]=-nums[0];\\n                sort(begin(nums),end(nums));\\n                 k--;\\n        }\\n         for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        int sum=0;\\n        while(k>0)\\n        {\\n                nums[0]=-nums[0];\\n                sort(begin(nums),end(nums));\\n                 k--;\\n        }\\n         for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315221,
                "title": "1005-simple-solution-beats-91",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        last_negative, last_ind = nums[0], 0\\n        for x, item in enumerate(nums):\\n            if k <= 0 or item == 0: break\\n            if item < 0:\\n                last_negative = -item\\n                last_ind = x\\n                nums[x] = -1 * item\\n                k -= 1\\n            elif item > 0:\\n                if k % 2 == 0: break\\n                else:\\n                    if item > last_negative:\\n                        nums[last_ind] = -1* last_negative\\n                        break\\n                    else:\\n                        nums[x] = -item\\n                        break\\n        else:\\n            nums[last_ind] = (-1**k)* last_negative\\n        return sum(nums)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        last_negative, last_ind = nums[0], 0\\n        for x, item in enumerate(nums):\\n            if k <= 0 or item == 0: break\\n            if item < 0:\\n                last_negative = -item\\n                last_ind = x\\n                nums[x] = -1 * item\\n                k -= 1\\n            elif item > 0:\\n                if k % 2 == 0: break\\n                else:\\n                    if item > last_negative:\\n                        nums[last_ind] = -1* last_negative\\n                        break\\n                    else:\\n                        nums[x] = -item\\n                        break\\n        else:\\n            nums[last_ind] = (-1**k)* last_negative\\n        return sum(nums)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060253,
                "title": "easy-python3-intuition-approach",
                "content": "# Code1\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k):\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]\\n        return sum(nums)\\n```\\n\\n# Code2\\n\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k,0,-1):\\n            if min(nums)>=0 and i%2==0:return sum(nums)\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]            \\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k):\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]\\n        return sum(nums)\\n```\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k,0,-1):\\n            if min(nums)>=0 and i%2==0:return sum(nums)\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]            \\n        return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674119,
                "title": "java-priorityqueue-approach",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int p : nums){\\n            pq.offer(p);\\n        }\\n        while(k --> 0){\\n            int temp = pq.poll();\\n            temp = -temp;\\n            pq.offer(temp);\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty()){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int p : nums){\\n            pq.offer(p);\\n        }\\n        while(k --> 0){\\n            int temp = pq.poll();\\n            temp = -temp;\\n            pq.offer(temp);\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty()){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506908,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\n var largestSumAfterKNegations = function(nums, k) {\\n    const sortedNums = nums.sort((a,b) => a-b);\\n    let lowestPos = 0;\\n    for (let i = 0; i < k; i++) {\\n        // keep track of the lowest positive number\\n        if (sortedNums[i] < sortedNums[lowestPos]) lowestPos = i;\\n        // if the number is negative, flip it, otherwise continue to flip the lowest positive number\\n        sortedNums[i] < 0 ? sortedNums[i] = -sortedNums[i] : sortedNums[lowestPos] = -sortedNums[lowestPos];\\n    }\\n    return sortedNums.reduce((a,b) => a + b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n var largestSumAfterKNegations = function(nums, k) {\\n    const sortedNums = nums.sort((a,b) => a-b);\\n    let lowestPos = 0;\\n    for (let i = 0; i < k; i++) {\\n        // keep track of the lowest positive number\\n        if (sortedNums[i] < sortedNums[lowestPos]) lowestPos = i;\\n        // if the number is negative, flip it, otherwise continue to flip the lowest positive number\\n        sortedNums[i] < 0 ? sortedNums[i] = -sortedNums[i] : sortedNums[lowestPos] = -sortedNums[lowestPos];\\n    }\\n    return sortedNums.reduce((a,b) => a + b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096202,
                "title": "python-use-min-heap-to-always-operate-the-minelement-k-times",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        heapq.heapify(nums)\\n        while k > 0:\\n            _min = heapq.heappop(nums)\\n            heapq.heappush(nums, -_min)\\n            k -= 1\\n        res = 0\\n        while n > 0:\\n            res += heapq.heappop(nums)\\n            n -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        heapq.heapify(nums)\\n        while k > 0:\\n            _min = heapq.heappop(nums)\\n            heapq.heappush(nums, -_min)\\n            k -= 1\\n        res = 0\\n        while n > 0:\\n            res += heapq.heappop(nums)\\n            n -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882763,
                "title": "c-solution-beginner-friendly-using-priority-queue",
                "content": "```\\nint n=a.size(),c=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<n;i++)\\n            pq.push(a[i]);\\n        while(k--)\\n        {\\n            int p=pq.top();\\n            pq.pop();\\n            pq.push(-p);\\n        }\\n        while(!pq.empty())\\n        {\\n            c+=pq.top();\\n            pq.pop();\\n        }\\n       return c; \\n    }\\n```\\n``` If you like my approach then please upvote me.```",
                "solutionTags": [],
                "code": "```\\nint n=a.size(),c=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<n;i++)\\n            pq.push(a[i]);\\n        while(k--)\\n        {\\n            int p=pq.top();\\n            pq.pop();\\n            pq.push(-p);\\n        }\\n        while(!pq.empty())\\n        {\\n            c+=pq.top();\\n            pq.pop();\\n        }\\n       return c; \\n    }\\n```\n``` If you like my approach then please upvote me.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809612,
                "title": "greedy-approach-python",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort(key=abs, reverse=True)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] *= -1\\n                k -= 1\\n            if k == 0:\\n                break\\n        if k % 2 != 0:\\n            nums[-1] *= -1\\n        return sum(nums)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort(key=abs, reverse=True)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] *= -1\\n                k -= 1\\n            if k == 0:\\n                break\\n        if k % 2 != 0:\\n            nums[-1] *= -1\\n        return sum(nums)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1794751,
                "title": "python3-priority-queue-min-heap-easy-understanding",
                "content": "TC: O(n + klog(x)) with x < n\\nSC: O(1)\\n\\n```\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        \\n        for _ in range(k):\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        \\n        for _ in range(k):\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1595423,
                "title": "c-solution-with-explanation",
                "content": "```\\nint cmp(const void *a, const void *b){\\n    return *(int*)a > *(int*)b;\\n}\\n\\nint largestSumAfterKNegations(int* nums, int numsSize, int k){\\n    // Sort the array first. \\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int i, N = numsSize, j = 0, sum = 0;\\n    \\n    // Concept: Flip the smallest element at each round. If it becomes larger than the next smallest element, don\\'t flip it in later rounds and switch to the next element. \\n    for(; k > 0; k--){  \\n        nums[j] = -nums[j];\\n        if(j == N - 1){\\n            continue;\\n        }\\n        if(nums[j] > nums[j + 1]){\\n            j++;\\n        }\\n    }\\n    for(i = 0; i < N; i++){\\n        sum += nums[i];\\n    }\\n    \\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(const void *a, const void *b){\\n    return *(int*)a > *(int*)b;\\n}\\n\\nint largestSumAfterKNegations(int* nums, int numsSize, int k){\\n    // Sort the array first. \\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int i, N = numsSize, j = 0, sum = 0;\\n    \\n    // Concept: Flip the smallest element at each round. If it becomes larger than the next smallest element, don\\'t flip it in later rounds and switch to the next element. \\n    for(; k > 0; k--){  \\n        nums[j] = -nums[j];\\n        if(j == N - 1){\\n            continue;\\n        }\\n        if(nums[j] > nums[j + 1]){\\n            j++;\\n        }\\n    }\\n    for(i = 0; i < N; i++){\\n        sum += nums[i];\\n    }\\n    \\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1547583,
                "title": "c-100-lengthy-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        int i=0;\\n        \\n       sort(nums.begin(),nums.end());\\n       while(i<nums.size()&&(k>0&&nums[i]<=0)){\\n           if(nums[i]<0){\\n               nums[i]=-nums[i];\\n               k--;\\n           }\\n           else {\\n               k=0;\\n               break;\\n           }\\n           i++;\\n           }\\n        while(i<nums.size()&&(k>0&&nums[i]>0)){\\n            if(i!=0){\\n                if(nums[i]<=nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i]=-nums[i];\\n                        k=0;\\n                    }\\n                }\\n                if(nums[i]>nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i-1]=-nums[i-1];\\n                        k=0;\\n                    }\\n                }\\n            }\\n            else{\\n                if(k%2!=0){\\n                    \\n                    nums[i]=-nums[i];\\n                    cout<<nums[i]<<endl;\\n                    k=0;\\n                }\\n            }\\n            i++;\\n}\\n            if(k%2!=0){\\n                nums[nums.size()-1]=-nums[nums.size()-1];\\n                k=0;\\n            }      \\n        \\n        for(int j=0;j<nums.size();j++){\\n            sum+=nums[j];\\n        }\\n        return sum;\\n       }\\n    };\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        int i=0;\\n        \\n       sort(nums.begin(),nums.end());\\n       while(i<nums.size()&&(k>0&&nums[i]<=0)){\\n           if(nums[i]<0){\\n               nums[i]=-nums[i];\\n               k--;\\n           }\\n           else {\\n               k=0;\\n               break;\\n           }\\n           i++;\\n           }\\n        while(i<nums.size()&&(k>0&&nums[i]>0)){\\n            if(i!=0){\\n                if(nums[i]<=nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i]=-nums[i];\\n                        k=0;\\n                    }\\n                }\\n                if(nums[i]>nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i-1]=-nums[i-1];\\n                        k=0;\\n                    }\\n                }\\n            }\\n            else{\\n                if(k%2!=0){\\n                    \\n                    nums[i]=-nums[i];\\n                    cout<<nums[i]<<endl;\\n                    k=0;\\n                }\\n            }\\n            i++;\\n}\\n            if(k%2!=0){\\n                nums[nums.size()-1]=-nums[nums.size()-1];\\n                k=0;\\n            }      \\n        \\n        for(int j=0;j<nums.size();j++){\\n            sum+=nums[j];\\n        }\\n        return sum;\\n       }\\n    };\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1502226,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] nums, int k) {     \\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tint min = 101;\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i){\\n\\t\\t\\t\\tif(nums[i] < 0 && k > 0){ // flip a negative number, \\n\\t\\t\\t\\t\\tnums[i] = -nums[i];\\n\\t\\t\\t\\t\\tk--; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(nums[i] < min){\\n\\t\\t\\t\\t\\tmin=nums[i]; // find the minimum in the array \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres += nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tif(k%2==1) \\n\\t\\t\\t\\tres -= 2*min;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\t\\t\\t// step 1 sort \\n\\t\\t\\t// step 2 if there are negative numbers, flip the negatives according to k, and find the minimum in the array \\n\\t\\t\\t// step 3 if k%2==1, we will subtract min twice. \\n\\t\\t\\t// time O(nlogn)\\n\\t\\t\\t// space O(1)",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] nums, int k) {     \\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tint min = 101;\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i){\\n\\t\\t\\t\\tif(nums[i] < 0 && k > 0){ // flip a negative number, \\n\\t\\t\\t\\t\\tnums[i] = -nums[i];\\n\\t\\t\\t\\t\\tk--; \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1115003,
                "title": "easy-way-of-using-priorityqueue-java",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        \\n        //Using of min heap.\\n        //Min heap by default.\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=0;i<A.length;i++)\\n            pq.add(A[i]);\\n        int start = 0;\\n        while(start<K)\\n        {\\n            int min_value = pq.poll();\\n            pq.add(min_value*(-1));\\n            start++;\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum = sum + pq.poll();\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        \\n        //Using of min heap.\\n        //Min heap by default.\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=0;i<A.length;i++)\\n            pq.add(A[i]);\\n        int start = 0;\\n        while(start<K)\\n        {\\n            int min_value = pq.poll();\\n            pq.add(min_value*(-1));\\n            start++;\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum = sum + pq.poll();\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087877,
                "title": "java-minheap-simple-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        \\n        for(int elem: A){\\n            minHeap.add(elem);\\n        }\\n        \\n        for(int i=0 ; i<K ; ++i){\\n            int curr = minHeap.poll();\\n            minHeap.add(-1*curr);\\n        }\\n        \\n        int sum = 0;\\n        while(!minHeap.isEmpty()){\\n            sum += minHeap.poll();\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        \\n        for(int elem: A){\\n            minHeap.add(elem);\\n        }\\n        \\n        for(int i=0 ; i<K ; ++i){\\n            int curr = minHeap.poll();\\n            minHeap.add(-1*curr);\\n        }\\n        \\n        int sum = 0;\\n        while(!minHeap.isEmpty()){\\n            sum += minHeap.poll();\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986825,
                "title": "two-months-of-python-solution",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K) -> int:\\n\\n        minvalue = min(A)\\n        start = 0\\n\\n        while start != K:\\n            for i in range(len(A)):\\n                if A[i] == minvalue:\\n                    A[i] = - A[i]\\n                    break\\n\\n            minvalue = min(A)\\n            start +=1\\n\\n        return sum(A)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K) -> int:\\n\\n        minvalue = min(A)\\n        start = 0\\n\\n        while start != K:\\n            for i in range(len(A)):\\n                if A[i] == minvalue:\\n                    A[i] = - A[i]\\n                    break\\n\\n            minvalue = min(A)\\n            start +=1\\n\\n        return sum(A)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917150,
                "title": "easy-adn-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());      // sorting in begining\\n        int sum=0;\\n        for(int i=0;i<a.size()&&k>0;i++)\\n        {\\n            if(a[i]<0)       // for all negative elements\\n            {\\n                a[i]=-a[i];\\n                k--;\\n            }\\n            else \\n                break;      // else breaking out of loop\\n        }\\n        sort(a.begin(),a.end());           // sorting again to find out the smallest element in the modified array\\n        for(int i=1;i<a.size();i++)            // calculating sum except the smallest element i.e a[0]\\n                sum+=a[i];\\n        if(k%2==0)\\n            return sum+a[0];                    // adding smallest element as it is if k is even\\n        else\\n            return sum-a[0];                   // adding smallest element after changinf sign if k is odd\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());      // sorting in begining\\n        int sum=0;\\n        for(int i=0;i<a.size()&&k>0;i++)\\n        {\\n            if(a[i]<0)       // for all negative elements\\n            {\\n                a[i]=-a[i];\\n                k--;\\n            }\\n            else \\n                break;      // else breaking out of loop\\n        }\\n        sort(a.begin(),a.end());           // sorting again to find out the smallest element in the modified array\\n        for(int i=1;i<a.size();i++)            // calculating sum except the smallest element i.e a[0]\\n                sum+=a[i];\\n        if(k%2==0)\\n            return sum+a[0];                    // adding smallest element as it is if k is even\\n        else\\n            return sum-a[0];                   // adding smallest element after changinf sign if k is odd\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761620,
                "title": "java-2-solutions-using-heap-sorting",
                "content": "Using Priority Queue :\\n```\\nPriorityQueue<Integer> pq = new PriorityQueue<>();\\nfor(int num : A) pq.add(num);\\n\\nwhile(K-- > 0)\\n\\tpq.add(-pq.poll());\\n\\nint sum = 0;\\nwhile(!pq.isEmpty())\\n\\tsum += pq.poll();\\nreturn sum;\\n```\\n\\nUsing Sorting :\\n\\n```\\nArrays.sort(A);\\nint sum = 0;\\n\\nfor(int i = 0; i < A.length; i++){\\n\\n\\twhile(A[i] < 0 && K > 0){\\n\\t\\tA[i] = -A[i];\\n\\t\\tK--;\\n\\t\\ti++;\\n\\t}\\n\\n\\tK = K%2 == 0 ? 0 : 1;\\n\\tif(K > 0){\\n\\t\\tif(i > 0 && A[i] > A[i-1])\\n\\t\\t\\tA[i-1] = -A[i-1];\\n\\t\\telse\\n\\t\\t\\tA[i] = -A[i];\\n\\t}\\n\\tbreak;\\n}\\nfor(int num : A)\\n\\tsum += num;\\nreturn sum;\\n```",
                "solutionTags": [],
                "code": "```\\nPriorityQueue<Integer> pq = new PriorityQueue<>();\\nfor(int num : A) pq.add(num);\\n\\nwhile(K-- > 0)\\n\\tpq.add(-pq.poll());\\n\\nint sum = 0;\\nwhile(!pq.isEmpty())\\n\\tsum += pq.poll();\\nreturn sum;\\n```\n```\\nArrays.sort(A);\\nint sum = 0;\\n\\nfor(int i = 0; i < A.length; i++){\\n\\n\\twhile(A[i] < 0 && K > 0){\\n\\t\\tA[i] = -A[i];\\n\\t\\tK--;\\n\\t\\ti++;\\n\\t}\\n\\n\\tK = K%2 == 0 ? 0 : 1;\\n\\tif(K > 0){\\n\\t\\tif(i > 0 && A[i] > A[i-1])\\n\\t\\t\\tA[i-1] = -A[i-1];\\n\\t\\telse\\n\\t\\t\\tA[i] = -A[i];\\n\\t}\\n\\tbreak;\\n}\\nfor(int num : A)\\n\\tsum += num;\\nreturn sum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601888,
                "title": "java-99-9-1-ms-only-sorting",
                "content": "```\\n private int largestSumAfterKNegations(int[] A,int K){\\n        Arrays.sort(A); \\n        int minIdx = 0;\\n        while(K-- > 0){\\n            if(minIdx < A.length && A[minIdx] < 0){\\n                A[minIdx] = -A[minIdx];\\n\\t\\t\\t\\t//Move minIdx only if the next number is less than min\\n                if(minIdx+1 < A.length && A[minIdx+1] < A[minIdx])minIdx++;\\n            }else{\\n                 A[minIdx] = -A[minIdx];\\n            }\\n            \\n        }\\n        int sum = 0;\\n        for(int num:A){\\n            sum += num;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n private int largestSumAfterKNegations(int[] A,int K){\\n        Arrays.sort(A); \\n        int minIdx = 0;\\n        while(K-- > 0){\\n            if(minIdx < A.length && A[minIdx] < 0){\\n                A[minIdx] = -A[minIdx];\\n\\t\\t\\t\\t//Move minIdx only if the next number is less than min\\n                if(minIdx+1 < A.length && A[minIdx+1] < A[minIdx])minIdx++;\\n            }else{\\n                 A[minIdx] = -A[minIdx];\\n            }\\n            \\n        }\\n        int sum = 0;\\n        for(int num:A){\\n            sum += num;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560334,
                "title": "6-lines-solution-with-c-stl",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        for (int i = 0; i < K; i++)\\n        {\\n            auto itr = min_element(A.begin(), A.end());\\n            *itr = -(*itr);\\n        }\\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```\\n**PEACE**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        for (int i = 0; i < K; i++)\\n        {\\n            auto itr = min_element(A.begin(), A.end());\\n            *itr = -(*itr);\\n        }\\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456042,
                "title": "1005-maximize-sum-of-array-after-k-negations-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Min Heap**\\n| O(T): O(nlgn) | O(S): O(1) | Rt: 48ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\\nComment: always negate the minimum. \\nAlternative: slightly improved. | Rt: 40ms |\\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K % (2 * len(A))): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\\nComment: if you do 2 * len(A) negating, you can always get the original input list. \\nTriple: further improved.  | Rt: 48ms |\\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        K %= 2*len(A)\\n        for i in range(K):\\n            if A[0] >= 0: return sum(A) - ((K - i) & 1) * 2 * A[0] \\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\\nComment: Once all elements are positive, stop the game and check the remaining times need to modify. If the remaining is even, it is the sum of current list (you negate the minimun even times, it remains the same). Otherwise, you need to deduct the minimum twice because you already added it to the sum once (and it is negative after odd times negating). This should boost the runtime however it didn\\'t ....\\n\\nQuestion: could we reduce K by % 2(len(A))? I think not, but the solution get passed. **I clarify the \"Reduce K\" trick in the above solutions (and below) may not be applicable in case some troubles .** \\n\\n\\n**II). Remove and Append**\\n| O(T): O(kn) | O(S): O(1) | Rt: 136ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\\nAlternative: slightly improved.  | Rt: 124ms | O(T): n^2 |\\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K % (2*len(A))): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\\n\\n\\n**III). Greedy**\\n| O(T): O(nlgn) | O(S): O(1) | Rt: 56ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(); K %= 2 * len(A); i = 0\\n        while A[i] < 0 and i < K: A[i], i = -A[i], i + 1\\n        return sum(A) - ((K-i) % 2) * 2 * min(A)\\n```\\n\\n\\n**IV). Counting Sort**\\n| O(T): O(n) | O(S): O(n) | Rt: 56ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        ct = collections.Counter(A)\\n        for i in range(-100, 0):\\n            if K == 0: break\\n            if i in ct: \\n                amt = min(K, ct[i])\\n                ct[i] -= amt\\n                ct[-i] += amt\\n                K -= amt\\n        a = list(ct.elements())\\n        return sum(a) - (K&1) * 2 * min(a) \\n```\\nReferrence: https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/discuss/252254/C++Python-Sort/246430\\nComment: take advantage of the -100 <= A[i] <= 100.\\n\\n\\n**V). Bucket Collect then Counting Sort**\\n| O(T): O(n) | O(S): O(1) | Rt: 48ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        m = [0] * 201\\n        for i in A: m[i+100] += 1\\n        for i in range(0, 100):\\n            if K == 0: break\\n            if m[i]: \\n                amt = min(K, m[i])\\n                m[i] -= amt\\n                # -(i - 100) + 100 = 200 -i\\n                m[200 - i] += amt\\n                K -= amt\\n        suma = sum((i-100) * v for i, v in enumerate(m) if v)\\n        # mina = next(i - 100 for i, v in enumerate(m) if v)\\n        return suma - (K&1) * 2 * min(map(abs, A)) \\n```\\nReferrence: idea from https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/discuss/252849/C%2B%2BJava-O(n)-or-O(1)\\nQuestion: min([5,6,9,-3,3], key=abs) == -3 and min([5,6,9,-4,3], key=abs) == 3. Who tell me Why?\\n",
                "solutionTags": [],
                "code": "```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K % (2 * len(A))): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        K %= 2*len(A)\\n        for i in range(K):\\n            if A[0] >= 0: return sum(A) - ((K - i) & 1) * 2 * A[0] \\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K % (2*len(A))): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(); K %= 2 * len(A); i = 0\\n        while A[i] < 0 and i < K: A[i], i = -A[i], i + 1\\n        return sum(A) - ((K-i) % 2) * 2 * min(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        ct = collections.Counter(A)\\n        for i in range(-100, 0):\\n            if K == 0: break\\n            if i in ct: \\n                amt = min(K, ct[i])\\n                ct[i] -= amt\\n                ct[-i] += amt\\n                K -= amt\\n        a = list(ct.elements())\\n        return sum(a) - (K&1) * 2 * min(a) \\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        m = [0] * 201\\n        for i in A: m[i+100] += 1\\n        for i in range(0, 100):\\n            if K == 0: break\\n            if m[i]: \\n                amt = min(K, m[i])\\n                m[i] -= amt\\n                # -(i - 100) + 100 = 200 -i\\n                m[200 - i] += amt\\n                K -= amt\\n        suma = sum((i-100) * v for i, v in enumerate(m) if v)\\n        # mina = next(i - 100 for i, v in enumerate(m) if v)\\n        return suma - (K&1) * 2 * min(map(abs, A)) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 422182,
                "title": "simple-solution-with-python-40ms",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        i = 0\\n        while K > 0 and A[i] < 0:\\n            A[i] *= -1\\n            i += 1\\n            K -= 1\\n        if K % 2 == 0:\\n            return sum(A)\\n        else:\\n            return sum(A) - 2 * min(A[i],A[i-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        i = 0\\n        while K > 0 and A[i] < 0:\\n            A[i] *= -1\\n            i += 1\\n            K -= 1\\n        if K % 2 == 0:\\n            return sum(A)\\n        else:\\n            return sum(A) - 2 * min(A[i],A[i-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332070,
                "title": "straightforward-java-o-nlogn-and-constant-space-with-thinking-process",
                "content": "The idea is pretty simple:\\n1. The sum maximizes when all numbers are positive.\\n2. If K >= neg(count of negative numbers), we use neg flips to make all negative numbers to positive. If (K - neg) % 2 == 0, good, nothing will be changed; If not, flip the number that has min Math.abs(number) once. \\n3. If K < neg, we just need to flip the first K negative numbers in a sorted array. \\n```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int neg = 0, sum = 0, close = Integer.MAX_VALUE;\\n        for(int i : A){\\n            if(i < 0) neg++;\\n            if(Math.abs(i) < close) close = Math.abs(i);\\n        }\\n        if(K >= neg){\\n            int remain = K - neg;\\n            for(int i : A) sum += Math.abs(i);\\n            return remain % 2 == 0? sum : sum - 2*close;\\n        }\\n        else {\\n            Arrays.sort(A);\\n            for(int i : A){\\n                if(K > 0){\\n                    sum += Math.abs(i);\\n                    K--;\\n                }\\n                else sum += i;\\n            }\\n            return sum;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int neg = 0, sum = 0, close = Integer.MAX_VALUE;\\n        for(int i : A){\\n            if(i < 0) neg++;\\n            if(Math.abs(i) < close) close = Math.abs(i);\\n        }\\n        if(K >= neg){\\n            int remain = K - neg;\\n            for(int i : A) sum += Math.abs(i);\\n            return remain % 2 == 0? sum : sum - 2*close;\\n        }\\n        else {\\n            Arrays.sort(A);\\n            for(int i : A){\\n                if(K > 0){\\n                    sum += Math.abs(i);\\n                    K--;\\n                }\\n                else sum += i;\\n            }\\n            return sum;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331164,
                "title": "javascript-beats-99-5",
                "content": "Runtime: 52 ms, faster than 99.50% of JavaScript online submissions\\nMemory Usage: 35.9 MB, less than 33.80% of JavaScript online submissions\\n\\nTrying to take every short circuit I can.\\n\\n```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (A, K) => {\\n  A.sort((a, b) => a - b);\\n  let sum = 0;\\n  for (let i = 0; i < A.length; i++) {\\n    let val = A[i];\\n    if (0 < K) {\\n      if (val < 0) {\\n        let next = A[i + 1];\\n        if (Math.abs(val) < next && 0 === K % 2) K = 0;\\n        else [val, K] = [-val, K - 1];\\n      } else if (0 !== val && 1 === K % 2) [val, K] = [-val, 0];\\n      else K = 0;\\n    }\\n    sum += val;\\n  }\\n  return sum;\\n};\\n```\\n\\nAnd here is a recursive solution.\\n\\nRuntime: 68 ms, faster than 72.92% of JavaScript online submissions\\nMemory Usage: 36.3 MB, less than 50.00% of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (a, k) => {\\n  if (0 === k) return a.reduce((acc, curr) => acc + curr);\\n  let [min, mindex] = [Infinity];\\n  for (let i = 0; i < a.length; i++) if (a[i] < min) [min, mindex] = [a[i], i];\\n  if (min < 0 || k % 2) a[mindex] = -a[mindex];\\n  return largestSumAfterKNegations(a, min < 0 ? k - 1 : 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (A, K) => {\\n  A.sort((a, b) => a - b);\\n  let sum = 0;\\n  for (let i = 0; i < A.length; i++) {\\n    let val = A[i];\\n    if (0 < K) {\\n      if (val < 0) {\\n        let next = A[i + 1];\\n        if (Math.abs(val) < next && 0 === K % 2) K = 0;\\n        else [val, K] = [-val, K - 1];\\n      } else if (0 !== val && 1 === K % 2) [val, K] = [-val, 0];\\n      else K = 0;\\n    }\\n    sum += val;\\n  }\\n  return sum;\\n};\\n```\n```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (a, k) => {\\n  if (0 === k) return a.reduce((acc, curr) => acc + curr);\\n  let [min, mindex] = [Infinity];\\n  for (let i = 0; i < a.length; i++) if (a[i] < min) [min, mindex] = [a[i], i];\\n  if (min < 0 || k % 2) a[mindex] = -a[mindex];\\n  return largestSumAfterKNegations(a, min < 0 ? k - 1 : 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 253629,
                "title": "c-10-lines-o-nlogn-time-o-1-space-use-only-sort-comparison-beat-99-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(), A.end());\\n        int minIdx = 0;\\n        // Do K steps\\n        for(int i = 0; i < K; i++){\\n            // change the sign of the smallest element\\n            A[minIdx] = -A[minIdx];\\n            if(minIdx == A.size()-1  || A[minIdx] > A[minIdx + 1])  minIdx++;\\n        }\\n        int sum = 0;\\n        for(auto a: A)  sum += a;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(), A.end());\\n        int minIdx = 0;\\n        // Do K steps\\n        for(int i = 0; i < K; i++){\\n            // change the sign of the smallest element\\n            A[minIdx] = -A[minIdx];\\n            if(minIdx == A.size()-1  || A[minIdx] > A[minIdx + 1])  minIdx++;\\n        }\\n        int sum = 0;\\n        for(auto a: A)  sum += a;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253368,
                "title": "quickselect-o-n-solution",
                "content": "We don\\'t need sorted sequence. We just need the K smallest negative elements to negate their sign and if we have less than K negative elements  and the left number of operations is odd - choose the smallest positive (or zero) and negate its sign.\\n```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n\\n        nth_element(A.begin(), A.begin() + K, A.end());\\n        int cnt = K;\\n        int minIdx = 0;\\n        \\n        for (int i = 0; i < K; ++i) {\\n            if (A[i] < 0) {\\n                A[i] = -A[i];\\n                cnt--;\\n            }\\n            if (A[i] < A[minIdx]) minIdx = i;\\n        }\\n        if (cnt % 2 != 0) {\\n            A[minIdx] = -A[minIdx];\\n        }\\n        \\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n\\n        nth_element(A.begin(), A.begin() + K, A.end());\\n        int cnt = K;\\n        int minIdx = 0;\\n        \\n        for (int i = 0; i < K; ++i) {\\n            if (A[i] < 0) {\\n                A[i] = -A[i];\\n                cnt--;\\n            }\\n            if (A[i] < A[minIdx]) minIdx = i;\\n        }\\n        if (cnt % 2 != 0) {\\n            A[minIdx] = -A[minIdx];\\n        }\\n        \\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252965,
                "title": "simple-python-heap-solution",
                "content": "Keep negating the minimum value:\\n\\n```\\nimport heapq\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, S, K):\\n        heapq.heapify(S)\\n        for _ in range(K):\\n            v = heapq.heappop(S)\\n            heapq.heappush(S, -v)\\n        return sum(S)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, S, K):\\n        heapq.heapify(S)\\n        for _ in range(K):\\n            v = heapq.heappop(S)\\n            heapq.heappush(S, -v)\\n        return sum(S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622679,
                "title": "c-min-heap-different-approach",
                "content": "**Test on this example:**\\n`[-8,3,-5,-3,-5,-2]` to understand `if (-smallest > -pq.top())`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        // O(n), min heap\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());    \\n\\n        // while smallest numbers are negative\\n        while (k > 0 && pq.top() < 0) {\\n            int smallest = pq.top();\\n            sum -= 2 * smallest;\\n            pq.pop();\\n            if (-smallest > -pq.top())\\n                pq.push(-smallest);\\n            k--;\\n        }\\n        // when all negatives are done, negate the 0 or smallest positive number multiple times\\n        if (k % 2 == 1) sum -= 2*pq.top(); \\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        // O(n), min heap\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());    \\n\\n        // while smallest numbers are negative\\n        while (k > 0 && pq.top() < 0) {\\n            int smallest = pq.top();\\n            sum -= 2 * smallest;\\n            pq.pop();\\n            if (-smallest > -pq.top())\\n                pq.push(-smallest);\\n            k--;\\n        }\\n        // when all negatives are done, negate the 0 or smallest positive number multiple times\\n        if (k % 2 == 1) sum -= 2*pq.top(); \\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496724,
                "title": "c-solution-simple-to-understand",
                "content": "## Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        for(; i<n; i++){\\n            if (k==0)break;\\n            if (nums[i]>=0)break;\\n            nums[i]*= -1;\\n            k--;\\n        }\\n        if (k&1){\\n            if (i-1>=0){\\n                if (abs(nums[i-1])<abs(nums[i]))nums[i-1]*=-1;\\n                else nums[i]*=-1;\\n            }\\n            else nums[i]*=-1;\\n\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            ans+= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        for(; i<n; i++){\\n            if (k==0)break;\\n            if (nums[i]>=0)break;\\n            nums[i]*= -1;\\n            k--;\\n        }\\n        if (k&1){\\n            if (i-1>=0){\\n                if (abs(nums[i-1])<abs(nums[i]))nums[i-1]*=-1;\\n                else nums[i]*=-1;\\n            }\\n            else nums[i]*=-1;\\n\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            ans+= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231286,
                "title": "c-easy-code",
                "content": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue <int, vector<int>, greater<int> > pq;\\n        for(auto it:nums)\\n        {\\n            pq.push(it);\\n        }\\n        vector<int> ans;\\n        int cnt=0,sum=0;\\n        while(cnt!=k)\\n        {\\n            if(pq.top()==0)\\n            {\\n                ans.push_back(0);\\n            }\\n            int x=pq.top();\\n            pq.pop();\\n            int y=(-1)*(x);\\n            pq.push(y);\\n            cnt++;\\n        }\\n        for(auto it:ans)\\n        {\\n            pq.push(it);\\n        }\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue <int, vector<int>, greater<int> > pq;\\n        for(auto it:nums)\\n        {\\n            pq.push(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3062731,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func largestSumAfterKNegations(_ nums: [Int], _ k: Int) -> Int {\\n        \\n        var ns = nums.sorted()\\n        var i = 0\\n        \\n        while i < k, i < nums.count, ns[i] < 0 {\\n            ns[i] = -ns[i]\\n            i += 1\\n        }\\n        \\n        guard i > k || (k - i) % 2 == 1 else { return ns.reduce(0, +) }\\n        \\n        var mi = ns[min(i, ns.count - 1)]\\n        if i > 0, ns[i - 1] < mi { mi = ns[i - 1] }\\n        \\n        return ns.reduce(0, +) - 2 * mi\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestSumAfterKNegations(_ nums: [Int], _ k: Int) -> Int {\\n        \\n        var ns = nums.sorted()\\n        var i = 0\\n        \\n        while i < k, i < nums.count, ns[i] < 0 {\\n            ns[i] = -ns[i]\\n            i += 1\\n        }\\n        \\n        guard i > k || (k - i) % 2 == 1 else { return ns.reduce(0, +) }\\n        \\n        var mi = ns[min(i, ns.count - 1)]\\n        if i > 0, ns[i - 1] < mi { mi = ns[i - 1] }\\n        \\n        return ns.reduce(0, +) - 2 * mi\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971088,
                "title": "1005-java-2-approach",
                "content": "# Complexity\\n- Time complexity || Runtime : 2 ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity || Memory : 42 MB \\n\\n- Beats : 99.10%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            index++;\\n        }\\n        Arrays.sort(nums);\\n        if(k % 2 == 1) ans -= (nums[0] + nums[0]);\\n        return ans;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity || Runtime : 2 ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity || Memory : 41.7 MB \\n\\n- Beats : 99.10%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 2\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0 , min = Integer.MAX_VALUE;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            if(i < min) min = nums[index];\\n            index++;\\n        }\\n        if(k % 2 == 1) ans -= min + min;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            index++;\\n        }\\n        Arrays.sort(nums);\\n        if(k % 2 == 1) ans -= (nums[0] + nums[0]);\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0 , min = Integer.MAX_VALUE;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            if(i < min) min = nums[index];\\n            index++;\\n        }\\n        if(k % 2 == 1) ans -= min + min;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932116,
                "title": "js-javascript-greedy-easy-to-understand-solution",
                "content": "\\n## Optimized Solution\\nTC :\\nSC: \\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {    \\n    nums.sort((a, b) => a - b);\\n    let modify = 0;\\n    let i = 0;\\n    while (k > 0) {\\n        if (nums[i] < nums[modify]) modify = i;\\n        if (i + 1 < nums.length) i ++;\\n        nums[modify] = -nums[modify];\\n        k --;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```\\n\\n\\n## Easy To Understand \\n- slow\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {\\n    let i = 0;\\n    while (i < k) {\\n        nums.sort((a, b) => a - b);\\n        nums[0] = -nums[0];\\n        i ++;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {    \\n    nums.sort((a, b) => a - b);\\n    let modify = 0;\\n    let i = 0;\\n    while (k > 0) {\\n        if (nums[i] < nums[modify]) modify = i;\\n        if (i + 1 < nums.length) i ++;\\n        nums[modify] = -nums[modify];\\n        k --;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {\\n    let i = 0;\\n    while (i < k) {\\n        nums.sort((a, b) => a - b);\\n        nums[0] = -nums[0];\\n        i ++;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2657499,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = 0,i=0,length=nums.size();\\n        sort(nums.begin(), nums.end());\\n        while(nums[i]<0 && i<length){\\n            if(k<=0)\\n                break;\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k>0 && nums[0]!=0)\\n            if(k%2)\\n                nums[0] *= -1;\\n        for(auto x:nums){\\n            sum += x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = 0,i=0,length=nums.size();\\n        sort(nums.begin(), nums.end());\\n        while(nums[i]<0 && i<length){\\n            if(k<=0)\\n                break;\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k>0 && nums[0]!=0)\\n            if(k%2)\\n                nums[0] *= -1;\\n        for(auto x:nums){\\n            sum += x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549142,
                "title": "c-min-heap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n       priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while(k--){\\n            int t=pq.top();pq.pop();\\n            pq.push(t*-1);\\n        }\\n    \\n        int n=0;\\n       while(!pq.empty()){\\n           int t=pq.top();pq.pop();\\n           n+=t;\\n       }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n       priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while(k--){\\n            int t=pq.top();pq.pop();\\n            pq.push(t*-1);\\n        }\\n    \\n        int n=0;\\n       while(!pq.empty()){\\n           int t=pq.top();pq.pop();\\n           n+=t;\\n       }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544881,
                "title": "c-min-heap-explained",
                "content": "\\t*********please upvote if it helps.\\n\\tclass Solution {\\n\\tpublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n      int n=nums.size();\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto x:nums){\\n            pq.push(x);\\n        }\\n\\t\\t//min will at top so if if we push negative of that then only ans will be minimum\\n        while(k--){\\n            int x=pq.top();\\n            pq.pop();\\n            pq.push(-x);\\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n      int n=nums.size();\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto x:nums){\\n            pq.push(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2480046,
                "title": "c-simple-if-else",
                "content": "**hope u find it helpful**\\n\\n\\t int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin() , nums.end());\\n        \\n        while(k > 0)\\n        {\\n           if(nums[0] == 0)\\n           {\\n               break;\\n           }\\n            \\n           else if(nums[0] > 0)\\n            {\\n                k = k%2 ;\\n                if(k)\\n                {\\n                    nums[0] = -nums[0];\\n                    k=0;\\n                }\\n            }\\n            else{\\n                nums[0] = -nums[0];\\n                k--;\\n                sort(nums.begin() , nums.end());\\n            }\\n        }\\n        int sum = 0;\\n        for(auto i:nums)\\n        {\\n            sum += i;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "**hope u find it helpful**\\n\\n\\t int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin() , nums.end());\\n        \\n        while(k > 0)\\n        {\\n           if(nums[0] == 0)\\n           {\\n               break;\\n           }\\n            \\n           else if(nums[0] > 0)\\n            {\\n                k = k%2 ;\\n                if(k)\\n                {\\n                    nums[0] = -nums[0];\\n                    k=0;\\n                }\\n            }\\n            else{\\n                nums[0] = -nums[0];\\n                k--;\\n                sort(nums.begin() , nums.end());\\n            }\\n        }\\n        int sum = 0;\\n        for(auto i:nums)\\n        {\\n            sum += i;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2465321,
                "title": "c-100-beats-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0, n = nums.size();\\n        while((i<n) && k){\\n            if(nums[i]<0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }else{\\n                break;\\n            }\\n            i++;\\n        }\\n        if(k%2){\\n            if(i==n){\\n                nums[i-1] = -nums[i-1];\\n            }\\n            else if(i>0 && nums[i]>nums[i-1]){\\n                nums[i-1] = -nums[i-1];\\n            }else{\\n                nums[i] = -nums[i];\\n            }\\n        }\\n        int sum = 0;\\n        for(auto &i: nums){\\n            // cout<<i<<\" \";\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0, n = nums.size();\\n        while((i<n) && k){\\n            if(nums[i]<0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }else{\\n                break;\\n            }\\n            i++;\\n        }\\n        if(k%2){\\n            if(i==n){\\n                nums[i-1] = -nums[i-1];\\n            }\\n            else if(i>0 && nums[i]>nums[i-1]){\\n                nums[i-1] = -nums[i-1];\\n            }else{\\n                nums[i] = -nums[i];\\n            }\\n        }\\n        int sum = 0;\\n        for(auto &i: nums){\\n            // cout<<i<<\" \";\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2336382,
                "title": "you-have-to-be-greedy-to-understand-greedy",
                "content": "```\\n  int largestSumAfterKNegations(vector<int>& arr, int k) {\\n    \\n        sort(arr.begin(),arr.end());\\n        \\n        //make the negative numbers positve as many you can\\n        int mino=INT_MAX;\\n        for(int i=0;i<arr.size() and k>0;i++)\\n        {\\n            if(arr[i]<0)  //jitne negative numbers ko positive bna skte bnalo\\n            {\\n                arr[i]=-arr[i]; \\n                k--;\\n            }              \\n            mino=min(arr[i],mino);  //min nikalo bcha hua \\'k\\' jo hoga isi number p krege\\n        }\\n        \\n        int sum=0;\\n        for(auto i:arr)\\n            sum+=i;\\n        \\n    //if even k=2 then 2 3 7  --> -2 3 7 --> 2 3 7 even me no change in array same sum \\n//if odd k=3 then 2 3 7 --> -2 3 7 --> 2 3 7 --> -2 3 7 odd me sum-=2*mino sum-=4 \\n        return k%2?sum-2*mino:sum;  \\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n  int largestSumAfterKNegations(vector<int>& arr, int k) {\\n    \\n        sort(arr.begin(),arr.end());\\n        \\n        //make the negative numbers positve as many you can\\n        int mino=INT_MAX;\\n        for(int i=0;i<arr.size() and k>0;i++)\\n        {\\n            if(arr[i]<0)  //jitne negative numbers ko positive bna skte bnalo\\n            {\\n                arr[i]=-arr[i]; \\n                k--;\\n            }              \\n            mino=min(arr[i],mino);  //min nikalo bcha hua \\'k\\' jo hoga isi number p krege\\n        }\\n        \\n        int sum=0;\\n        for(auto i:arr)\\n            sum+=i;\\n        \\n    //if even k=2 then 2 3 7  --> -2 3 7 --> 2 3 7 even me no change in array same sum \\n//if odd k=3 then 2 3 7 --> -2 3 7 --> 2 3 7 --> -2 3 7 odd me sum-=2*mino sum-=4 \\n        return k%2?sum-2*mino:sum;  \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2298751,
                "title": "java-easy-solution-3ms-faster",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (count < k) {\\n                if (nums[i] < 0) {\\n                    nums[i] = -1 * nums[i];\\n                    count++;\\n                }\\n            }\\n        }\\n        if (count < k) {\\n            Arrays.sort(nums);\\n            while (count < k) {\\n                nums[0] = -1 * nums[0];\\n                count++;\\n            }\\n        }\\n\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n\\n        return sum; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (count < k) {\\n                if (nums[i] < 0) {\\n                    nums[i] = -1 * nums[i];\\n                    count++;\\n                }\\n            }\\n        }\\n        if (count < k) {\\n            Arrays.sort(nums);\\n            while (count < k) {\\n                nums[0] = -1 * nums[0];\\n                count++;\\n            }\\n        }\\n\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n\\n        return sum; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118546,
                "title": "c-faster-6ms-run-time-solution",
                "content": "Firstly, we ```sort then convert``` the negative numbers in the array to positive while decreasing \\'k\\' with each operetion...```[first we sort so the grater negative numbers are changed first]```\\n ```-[if in this process the number of opertions is passed we return the sum of the elements]```\\nThen, if all elements are positive we change the sign of the minimum number in the array for the remaining no. of operations and return the total sum. \\n\\n         Runtime: 6 ms, faster than 69.56%\\n    Memory Usage: 9 MB,   less than 65.64% \\n\\n                     \\nCode:\\n\\n                        UPVOTE if you like the Explanition / Solution \\n\\t\\t \\n```\\nclass Solution \\n{\\npublic:\\n    int largestSumAfterKNegations(vector<int>& n, int k) \\n    {\\n        sort(n.begin(),n.end()); //sorting\\n        for(int i=0;i<n.size();i++)\\n        {\\n            if(n[i]<0){n[i]*=-1;k--;}//converting negative elements if any\\n            if(k==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t\\t//at any point if no. of operations is reached we return the present sum\\n        }\\n        if(k%2==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t//if remaining no. of operations are even the minimum element will not change thus we return current total sum\\n        \\n\\t\\t//else no. of operations are odd the least element will change sign....\\n\\t\\t//hence we subtract it twice from total sum\\n\\t\\tint l=*min_element(n.begin(),n.end());\\n        return accumulate(n.begin(),n.end(),0)-(2*l);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```sort then convert```\n```[first we sort so the grater negative numbers are changed first]```\n```-[if in this process the number of opertions is passed we return the sum of the elements]```\n```\\nclass Solution \\n{\\npublic:\\n    int largestSumAfterKNegations(vector<int>& n, int k) \\n    {\\n        sort(n.begin(),n.end()); //sorting\\n        for(int i=0;i<n.size();i++)\\n        {\\n            if(n[i]<0){n[i]*=-1;k--;}//converting negative elements if any\\n            if(k==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t\\t//at any point if no. of operations is reached we return the present sum\\n        }\\n        if(k%2==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t//if remaining no. of operations are even the minimum element will not change thus we return current total sum\\n        \\n\\t\\t//else no. of operations are odd the least element will change sign....\\n\\t\\t//hence we subtract it twice from total sum\\n\\t\\tint l=*min_element(n.begin(),n.end());\\n        return accumulate(n.begin(),n.end(),0)-(2*l);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104403,
                "title": "c-maximize-sum-of-array-after-k-negations",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int largestSumAfterKNegations(vector<int> &nums, int k)\\n        {\\n            sort(nums.begin(), nums.end());\\n            int i = 0;\\n            while (i < nums.size() and nums[i] < 0 and k > 0)\\n            {\\n                nums[i] = -nums[i];\\n                k--;\\n                i++;\\n            }\\n            bool isOdd = k % 2 != 0;\\n            sort(nums.begin(), nums.end());\\n            if (i < nums.size() and isOdd or k > 0 and isOdd)\\n                nums[0] = -nums[0];\\n            int sum = 0;\\n            for (int x: nums)\\n                sum += x;\\n            return sum;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int largestSumAfterKNegations(vector<int> &nums, int k)\\n        {\\n            sort(nums.begin(), nums.end());\\n            int i = 0;\\n            while (i < nums.size() and nums[i] < 0 and k > 0)\\n            {\\n                nums[i] = -nums[i];\\n                k--;\\n                i++;\\n            }\\n            bool isOdd = k % 2 != 0;\\n            sort(nums.begin(), nums.end());\\n            if (i < nums.size() and isOdd or k > 0 and isOdd)\\n                nums[0] = -nums[0];\\n            int sum = 0;\\n            for (int x: nums)\\n                sum += x;\\n            return sum;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100016,
                "title": "java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num : nums)\\n            pq.add(num);\\n        \\n        while(k > 0 && !pq.isEmpty())\\n        {\\n            pq.add(pq.poll() * -1);\\n            k -= 1;\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum += pq.poll();\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num : nums)\\n            pq.add(num);\\n        \\n        while(k > 0 && !pq.isEmpty())\\n        {\\n            pq.add(pq.poll() * -1);\\n            k -= 1;\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum += pq.poll();\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087015,
                "title": "o-n-using-quick-select-and-no-extra-memory",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int l = nums.length;\\n        int minI = 0, minVal, sum=Math.abs(nums[0]),t,s,e;\\n        for(int i=1;i<l;i++) {\\n            if(Math.abs(nums[i])<= Math.abs(nums[minI])) minI = i;\\n            sum+=Math.abs(nums[i]);\\n        }\\n        minVal = Math.abs(nums[minI]);\\n        swap(nums,minI,l-1);\\n        minI = partition(nums,0,l-1);\\n        if(minI<l && nums[minI]< 0) minI++;\\n        if(k>=minI){\\n            if((k-minI)%2==1) sum -=(2* minVal);\\n        }else{\\n            s = 0;e=minI-1;\\n            t=partition(nums,s,e);\\n            while(t!=k-1){\\n                if(t<k-1) s = t+1; else e = t-1;\\n                t=partition(nums,s,e);\\n            }\\n            for(int i =t+1;i<minI;i++) sum+=2*(nums[i]);\\n        }\\n        return sum;\\n    }\\n    \\n    int partition(int[] nums, int start,int end){\\n        int pivotId = end, slow = start, fast = start;\\n        if(nums[pivotId]>=0)\\n        for(;fast<end; fast++) {if(nums[fast]<nums[pivotId]) swap(nums, fast, slow++);}\\n        else\\n        for(;fast<end; fast++) {if(nums[fast]<=nums[pivotId]) swap(nums, fast, slow++);}\\n        swap(nums, pivotId, slow);\\n        return slow;\\n    }\\n    \\n    void swap(int[] nums, int a,int b){\\n        if (nums[a]==nums[b]) return;\\n        nums[a] = nums[a]^nums[b];\\n        nums[b] = nums[a]^nums[b];\\n        nums[a] = nums[a]^nums[b];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int l = nums.length;\\n        int minI = 0, minVal, sum=Math.abs(nums[0]),t,s,e;\\n        for(int i=1;i<l;i++) {\\n            if(Math.abs(nums[i])<= Math.abs(nums[minI])) minI = i;\\n            sum+=Math.abs(nums[i]);\\n        }\\n        minVal = Math.abs(nums[minI]);\\n        swap(nums,minI,l-1);\\n        minI = partition(nums,0,l-1);\\n        if(minI<l && nums[minI]< 0) minI++;\\n        if(k>=minI){\\n            if((k-minI)%2==1) sum -=(2* minVal);\\n        }else{\\n            s = 0;e=minI-1;\\n            t=partition(nums,s,e);\\n            while(t!=k-1){\\n                if(t<k-1) s = t+1; else e = t-1;\\n                t=partition(nums,s,e);\\n            }\\n            for(int i =t+1;i<minI;i++) sum+=2*(nums[i]);\\n        }\\n        return sum;\\n    }\\n    \\n    int partition(int[] nums, int start,int end){\\n        int pivotId = end, slow = start, fast = start;\\n        if(nums[pivotId]>=0)\\n        for(;fast<end; fast++) {if(nums[fast]<nums[pivotId]) swap(nums, fast, slow++);}\\n        else\\n        for(;fast<end; fast++) {if(nums[fast]<=nums[pivotId]) swap(nums, fast, slow++);}\\n        swap(nums, pivotId, slow);\\n        return slow;\\n    }\\n    \\n    void swap(int[] nums, int a,int b){\\n        if (nums[a]==nums[b]) return;\\n        nums[a] = nums[a]^nums[b];\\n        nums[b] = nums[a]^nums[b];\\n        nums[a] = nums[a]^nums[b];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061193,
                "title": "simple-solution-using-sorting-with-explanation",
                "content": "```go\\nfunc largestSumAfterKNegations(nums []int, k int) int {\\n  // First sort the numbers in ascending order\\n  sort.Ints(nums)\\n  // Let\\'s try to make as much negative numbers positive as possible\\n  // and also compute the sum as a result of this.\\n  // We\\'ll also keep track of the minimum element in this loop that we\\'l use later.\\n  var sum int\\n  min := math.MaxInt32\\n  for i := 0; i < len(nums); i++ {\\n    if k > 0 && nums[i] < 0 {\\n      nums[i] = -nums[i]\\n      k--\\n    }\\n    sum += nums[i]\\n    if nums[i] < min {\\n      min = nums[i]\\n    }\\n  }\\n  // We\\'ve applied as much negations on negative numbers. Now we don\\'t have any more\\n  // negative numbers. If k is even, we don\\'t need to do anything because the negations\\n  // cancel out. If it is odd, we\\'ll apply all the remaining negations on the min of the\\n  // result of the previous step.\\n  if k%2 != 0 {\\n    sum -= 2 * min\\n  }\\n  return sum\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```go\\nfunc largestSumAfterKNegations(nums []int, k int) int {\\n  // First sort the numbers in ascending order\\n  sort.Ints(nums)\\n  // Let\\'s try to make as much negative numbers positive as possible\\n  // and also compute the sum as a result of this.\\n  // We\\'ll also keep track of the minimum element in this loop that we\\'l use later.\\n  var sum int\\n  min := math.MaxInt32\\n  for i := 0; i < len(nums); i++ {\\n    if k > 0 && nums[i] < 0 {\\n      nums[i] = -nums[i]\\n      k--\\n    }\\n    sum += nums[i]\\n    if nums[i] < min {\\n      min = nums[i]\\n    }\\n  }\\n  // We\\'ve applied as much negations on negative numbers. Now we don\\'t have any more\\n  // negative numbers. If k is even, we don\\'t need to do anything because the negations\\n  // cancel out. If it is odd, we\\'ll apply all the remaining negations on the min of the\\n  // result of the previous step.\\n  if k%2 != 0 {\\n    sum -= 2 * min\\n  }\\n  return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008660,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/7cad9926-b5d3-458c-9b5c-7130c339fce5_1651692881.4312992.png)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S in place \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heappush(nums, -heapq.heappop(nums)) for _ in range(k)]\\n        return sum(nums)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heapreplace(nums, -nums[0]) for _ in range(k)] # some optimization\\n        return sum(nums)",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/7cad9926-b5d3-458c-9b5c-7130c339fce5_1651692881.4312992.png)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S in place \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heappush(nums, -heapq.heappop(nums)) for _ in range(k)]\\n        return sum(nums)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heapreplace(nums, -nums[0]) for _ in range(k)] # some optimization\\n        return sum(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 1999055,
                "title": "textbook-greedy-problem",
                "content": "```\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(k==0)\\n                break;\\n            if(nums[i]<0){\\n                nums[i]=nums[i]*-1;\\n                k--;\\n            }\\n            else \\n                break;\\n        }\\n        if(k!=0){\\n            sort(nums.begin(),nums.end());\\n            k=k-(k/2)*2;\\n            if(k==1)\\n                nums[0]=nums[0]*-1;\\n        }\\n        int sum = 0;\\n        for(int x:nums){\\n            sum=sum+x;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(k==0)\\n                break;\\n            if(nums[i]<0){\\n                nums[i]=nums[i]*-1;\\n                k--;\\n            }\\n            else \\n                break;\\n        }\\n        if(k!=0){\\n            sort(nums.begin(),nums.end());\\n            k=k-(k/2)*2;\\n            if(k==1)\\n                nums[0]=nums[0]*-1;\\n        }\\n        int sum = 0;\\n        for(int x:nums){\\n            sum=sum+x;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906868,
                "title": "priority-queue-in-js-or-negation-logic-detailed-explanation-with-time-space-complexity-analysis",
                "content": "2 approaches \\n# Priority Queues\\n\\n- First, we put the array into the priority queue pq\\n- For each negation, we try to negate the **smallest** possible element via` num = pq.peak().element`\\n\\t- If the element is positive -> it becomes only negative (since other elements are larger than this)\\n\\t- If the element is negative -> it becomes positive \\n- After that, we enqueue the negated version of it \\n- After the all iterations, sum all elements to get the sum.\\n\\nTime complexity: O(K log N) - K iterations and heap enqueue and dequeue operate in O(logN) \\nSpace complexity: O(N)\\n```\\n\\nvar largestSumAfterKNegations = function(nums, k) {\\n    const pq = new MinPriorityQueue();\\n    let sum = 0;\\n    \\n    nums.map(e => {\\n        pq.enqueue(e);\\n    });\\n        \\n    for (let i = 1; i <= k; i++) {\\n        let num = pq.dequeue().element;\\n        pq.enqueue(-num);\\n    }\\n            \\n    return pq.toArray().reduce((prev, curr) => {\\n        return prev + curr.element;\\n    }, 0);\\n};\\n```\\n\\n# Negating logic\\n- First, we sort the array\\n- Second, we loop through the array and negate the negative values of the array \\n\\t- Case 1, if the negation K <= the numbers of negative value => all the negations are used correctly, since it will produce the largest sum\\n\\t- Case 2, if the negation K > the numbers of negative value \\n\\t\\t- all the negative ones are now positive\\n\\t\\t- we sum all the numbers\\n\\t\\t- we keep track of the smallest positive value since the all the next negations are actually time this number by -1\\n\\t\\t\\t- When it is positive, it is the smallest\\n\\t\\t\\t- When it is negative, it is also the smallest\\n\\t\\t- depending the leftover negation are odd or even\\n\\t\\t\\t- if odd => sum = sum - (smallest * 2) \\n\\t\\t\\t- if even => sum = sum\\n\\t\\nTime complexity: O(NlogN)\\nSpace complexity: O(1)\\n\\n```\\nvar largestSumAfterKNegations = (A, K) => {\\n    A.sort((a, b) => a - b);\\n    \\n    let negations = 0, sum = 0, smallest = A[0];\\n    \\n    for (let i = 0; i < A.length; i++) {\\n        if (A[i] < 0 && negations < K) {\\n            A[i] = -A[i];\\n            negations++;\\n        }\\n        \\n        sum += A[i];\\n        smallest = Math.min(smallest, A[i]);\\n    }\\n    \\n    return (K - negations) % 2 === 0 ? sum : sum - (smallest * 2);\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nvar largestSumAfterKNegations = function(nums, k) {\\n    const pq = new MinPriorityQueue();\\n    let sum = 0;\\n    \\n    nums.map(e => {\\n        pq.enqueue(e);\\n    });\\n        \\n    for (let i = 1; i <= k; i++) {\\n        let num = pq.dequeue().element;\\n        pq.enqueue(-num);\\n    }\\n            \\n    return pq.toArray().reduce((prev, curr) => {\\n        return prev + curr.element;\\n    }, 0);\\n};\\n```\n```\\nvar largestSumAfterKNegations = (A, K) => {\\n    A.sort((a, b) => a - b);\\n    \\n    let negations = 0, sum = 0, smallest = A[0];\\n    \\n    for (let i = 0; i < A.length; i++) {\\n        if (A[i] < 0 && negations < K) {\\n            A[i] = -A[i];\\n            negations++;\\n        }\\n        \\n        sum += A[i];\\n        smallest = Math.min(smallest, A[i]);\\n    }\\n    \\n    return (K - negations) % 2 === 0 ? sum : sum - (smallest * 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1852427,
                "title": "priority-queue-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        h = []\\n        for num in nums:\\n            heappush(h, num)\\n        while k:\\n            num = heappop(h)\\n            heappush(h, -num)\\n            k -= 1\\n        return sum(h)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        h = []\\n        for num in nums:\\n            heappush(h, num)\\n        while k:\\n            num = heappop(h)\\n            heappush(h, -num)\\n            k -= 1\\n        return sum(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831321,
                "title": "c-simple-concise-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (auto &n: nums) pq.push(n);\\n        for (;k--;) {\\n            int x = pq.top();\\n            pq.pop();\\n            pq.push(x * -1);\\n        }\\n        int ans = 0;\\n        for (;!pq.empty(); ans += pq.top(), pq.pop());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (auto &n: nums) pq.push(n);\\n        for (;k--;) {\\n            int x = pq.top();\\n            pq.pop();\\n            pq.push(x * -1);\\n        }\\n        int ans = 0;\\n        for (;!pq.empty(); ans += pq.top(), pq.pop());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763840,
                "title": "greedy-java-o-n-k-log-n",
                "content": "First toggle the signs of as many negative numbers as you can, starting from the smallest negative number as the smallest negative number will be the largest one (when you toggle the sign of any negative number) and will contribute more to the sum.\\nIn case there is no more negative numbers and `k>0`, toggle the sign of the smallest number k times. So if `k%2==0` there is ultimately no change to the sign of that number, else it becomes negative.\\n\\n```\\npublic int largestSumAfterKNegations1(int[] nums, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue();\\n        int sum=0;\\n        \\n        for(int i:nums){\\n            pq.add(i);\\n            sum+=i;\\n        }\\n        \\n        while(k>0 && pq.peek()<0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n            k--;\\n        }\\n        if(k>0 && k%2!=0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int largestSumAfterKNegations1(int[] nums, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue();\\n        int sum=0;\\n        \\n        for(int i:nums){\\n            pq.add(i);\\n            sum+=i;\\n        }\\n        \\n        while(k>0 && pq.peek()<0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n            k--;\\n        }\\n        if(k>0 && k%2!=0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715780,
                "title": "fastest-but-complex-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            //System.out.println(i+\" \"+count);\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }\\n                else\\n                {\\n                    count+=i;\\n                }\\n                //System.out.println(count+\" \"+k);\\n            }\\n            else if(i==0)\\n            {\\n                k=0;\\n            }\\n            else\\n            {\\n                //System.out.println(count+\" \"+k);\\n                if(k%2==0)\\n                {\\n                    count+=i;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    if(prev==0)\\n                    {\\n                        count+=(-1*i);\\n                        k=0;\\n                    }\\n                    else\\n                    {\\n                        if(prev>i || Math.abs(prev)>i)\\n                        {\\n                            count+=(-1*i);\\n                        }\\n                        else\\n                        {\\n                            count+=prev;\\n                            count+=(prev + i);\\n                        }\\n                        k=0;\\n                    }\\n                }\\n            }\\n        }\\n        if(k%2!=0)\\n        {\\n            count+=(prev + prev);\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            //System.out.println(i+\" \"+count);\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1701952,
                "title": "c-very-simple-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n\\t\\t//negate the minimum element\\n        //start negating negative element \\n\\t\\t//can also use min heap\\n        sort(nums.begin(),nums.end());\\n        \\n        int i=0;\\n        while(k--)\\n        {\\n            nums[i]=-nums[i];\\n            //decesion to increment i -> this is trick\\n            i++;\\n            if(i==nums.size() || nums[i]>nums[i-1]) i--;\\n        }\\n        \\n        int sum=0;\\n        sum=accumulate(nums.begin(),nums.end(),sum);  //sum of all elements\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n\\t\\t//negate the minimum element\\n        //start negating negative element \\n\\t\\t//can also use min heap\\n        sort(nums.begin(),nums.end());\\n        \\n        int i=0;\\n        while(k--)\\n        {\\n            nums[i]=-nums[i];\\n            //decesion to increment i -> this is trick\\n            i++;\\n            if(i==nums.size() || nums[i]>nums[i-1]) i--;\\n        }\\n        \\n        int sum=0;\\n        sum=accumulate(nums.begin(),nums.end(),sum);  //sum of all elements\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644297,
                "title": "c-greedy-with-intuition",
                "content": "intuition : First of all sort the vector and then check if the element at the 0th position is negative (say -a ) ,then replace it by -(-a) and decrement the value of k by 1 else if its 0 then keep it as it is and decrement the value of k by k i.e now k=0 ; else if the 0th element is positive then replace the element by -(a) and decrement k by 1.Do the same until k becomes 0. And finally return the sum of all elemnts .\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int i=0;\\n        while(k!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n            if(nums[i]<0)\\n            {\\n                nums[i]= -nums[i];\\n                k--;\\n            }\\n            else if(nums[i]==0)\\n            {\\n                nums[i]=nums[i];\\n                k=k-k;\\n            }\\n            else\\n            {\\n                nums[i]=-nums[i];\\n                k--;\\n            }\\n        }\\n        int sum=0;\\n        for(auto i:nums)\\n            sum+=i;\\n        return sum;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int i=0;\\n        while(k!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n            if(nums[i]<0)\\n            {\\n                nums[i]= -nums[i];\\n                k--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1640773,
                "title": "maximize-sum-of-array-after-k-negations-c-easy-solution",
                "content": "**Please Upvote \\n If you Liked solution**\\n\\n\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] < 0 && k!=0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }\\n        }\\n        long long int sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            sum += nums[i];\\n        }\\n        if(k%2!=0){\\n            sum = sum - (*min_element(nums.begin(),nums.end())*2);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] < 0 && k!=0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1624514,
                "title": "here-is-my-c-cpp-solutionon-0ms-beats-100-other-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        vector<int>neg;\\n        vector<int>ans;\\n        bool z = false;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                neg.push_back(nums[i]);\\n            }\\n            else\\n                ans.push_back(nums[i]);\\n            if(nums[i] == 0)\\n                z = true;\\n        }\\n        sort(neg.begin(),neg.end());\\n        for(int i = 0;i<neg.size() and k>0;i++)\\n        {\\n            neg[i] *= -1;\\n            k--;\\n        }\\n        for(int i = 0;i<neg.size();i++)\\n        {\\n            ans.push_back(neg[i]);\\n        }\\n        k %= 2;\\n        if(k == 0)return accumulate(ans.begin(),ans.end(),0);\\n        if(k)\\n        {\\n            if(z)\\n            {\\n                return accumulate(ans.begin(),ans.end(),0);\\n            }\\n        }\\n        int mn = *min_element(ans.begin(),ans.end());\\n        for(int i = 0;i<ans.size();i++)\\n        {\\n            if(ans[i] == mn)\\n            {\\n                ans[i] *= -1;\\n                break;\\n            }\\n        }\\n        int sum = accumulate(ans.begin(),ans.end(),0);\\n        return sum;\\n    }\\n};\\nIf you like the solution Please upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        vector<int>neg;\\n        vector<int>ans;\\n        bool z = false;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                neg.push_back(nums[i]);\\n            }\\n            else\\n                ans.push_back(nums[i]);\\n            if(nums[i] == 0)\\n                z = true;\\n        }\\n        sort(neg.begin(),neg.end());\\n        for(int i = 0;i<neg.size() and k>0;i++)\\n        {\\n            neg[i] *= -1;\\n            k--;\\n        }\\n        for(int i = 0;i<neg.size();i++)\\n        {\\n            ans.push_back(neg[i]);\\n        }\\n        k %= 2;\\n        if(k == 0)return accumulate(ans.begin(),ans.end(),0);\\n        if(k)\\n        {\\n            if(z)\\n            {\\n                return accumulate(ans.begin(),ans.end(),0);\\n            }\\n        }\\n        int mn = *min_element(ans.begin(),ans.end());\\n        for(int i = 0;i<ans.size();i++)\\n        {\\n            if(ans[i] == mn)\\n            {\\n                ans[i] *= -1;\\n                break;\\n            }\\n        }\\n        int sum = accumulate(ans.begin(),ans.end(),0);\\n        return sum;\\n    }\\n};\\nIf you like the solution Please upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607986,
                "title": "k-nlog-n-time-complexicity-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n        while(k != 0){\\n            sort(nums.begin(), nums.end());\\n            nums[0] = -nums[0];\\n            k -= 1;    \\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)sum += nums[i];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n        while(k != 0){\\n            sort(nums.begin(), nums.end());\\n            nums[0] = -nums[0];\\n            k -= 1;    \\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)sum += nums[i];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587950,
                "title": "python-40ms-faster-than-95-simplest-logic-no-extra-edge-cases",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        i=0\\n        n = len(nums)\\n        while(i<n and k>0):\\n            if nums[i]<0:\\n                #make it positive\\n                nums[i] = -nums[i]\\n                k-=1\\n                i+=1\\n            elif nums[i]>=0:\\n                break\\n        if k%2==1:\\n            return sum(nums)-2*(min(nums))\\n        else:\\n            return sum(nums)\\n\\t\\t\\t#if k is odd, we will have to take the minimum element 2k+1 times\\n\\t\\t\\t#if its even, we can take whole nums, as it has k nonnegative values\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        i=0\\n        n = len(nums)\\n        while(i<n and k>0):\\n            if nums[i]<0:\\n                #make it positive\\n                nums[i] = -nums[i]\\n                k-=1\\n                i+=1\\n            elif nums[i]>=0:\\n                break\\n        if k%2==1:\\n            return sum(nums)-2*(min(nums))\\n        else:\\n            return sum(nums)\\n\\t\\t\\t#if k is odd, we will have to take the minimum element 2k+1 times\\n\\t\\t\\t#if its even, we can take whole nums, as it has k nonnegative values\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570660,
                "title": "c-o-n-time-85-faster-with-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(auto i: a) pq.push(i);\\n        while(k--) {\\n            int t = pq.top();\\n            pq.pop();\\n            t *= -1;\\n            pq.push(t);\\n        }\\n        int sum = 0;\\n        while(pq.size()) {\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(auto i: a) pq.push(i);\\n        while(k--) {\\n            int t = pq.top();\\n            pq.pop();\\n            t *= -1;\\n            pq.push(t);\\n        }\\n        int sum = 0;\\n        while(pq.size()) {\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519826,
                "title": "c-0ms-stl-accumulate-min-element-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int ops) {//ops => operations remaining\\n\\t\\tsort(a.begin(),a.end());//sort will bring negative elements at the starting\\n        for(int i=0;i<a.size();i++){\\n            if(ops>0&&a[i]<0)a[i]=-a[i],ops--; //turning smallest negative numbers into positive numbers\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Turning -5 -> 5 is better rather than -2 -> 2\\n\\t\\t\\t\\tif(ops==0){         //If run out of operations, stop\\n                return accumulate(a.begin(),a.end(),0);  //sum all elements to 0\\n            }\\n        }\\n\\t\\t//at this point there will be no negative elements remaining in the vector\\n\\t\\t//if number of operations are even, we can change any same element\\'s sign and it will not affect the result\\n        if(ops%2==0)return accumulate(a.begin(),a.end(),0);\\n\\t\\t\\n\\t\\t//if we have odd operations, we can turn smallest number to negative\\n        return accumulate(a.begin(),a.end(),0) -2* (*min_element(a.begin(),a.end()));\\n\\t\\t//We have already counted the positive/zero number in sum, hence subtracting twice\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int ops) {//ops => operations remaining\\n\\t\\tsort(a.begin(),a.end());//sort will bring negative elements at the starting\\n        for(int i=0;i<a.size();i++){\\n            if(ops>0&&a[i]<0)a[i]=-a[i],ops--; //turning smallest negative numbers into positive numbers\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Turning -5 -> 5 is better rather than -2 -> 2\\n\\t\\t\\t\\tif(ops==0){         //If run out of operations, stop\\n                return accumulate(a.begin(),a.end(),0);  //sum all elements to 0\\n            }\\n        }\\n\\t\\t//at this point there will be no negative elements remaining in the vector\\n\\t\\t//if number of operations are even, we can change any same element\\'s sign and it will not affect the result\\n        if(ops%2==0)return accumulate(a.begin(),a.end(),0);\\n\\t\\t\\n\\t\\t//if we have odd operations, we can turn smallest number to negative\\n        return accumulate(a.begin(),a.end(),0) -2* (*min_element(a.begin(),a.end()));\\n\\t\\t//We have already counted the positive/zero number in sum, hence subtracting twice\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424648,
                "title": "python3-nice-trick-faster-than-97-09-memory-less-than-81-00",
                "content": "Explanation:\\nCheck if the array is just a positive numbers, if yes then if k is even then this would not affect anything otherwise flip the minimun element.\\n\\nif there is negative elements in the array, sort the array with absolute value[no importance for the sign] then start from the last element which is the larger one in his absolute value, if this element is negative then flip his sign and decrease k by 1\\nif you reach the minimum element and k != 0 then we have more move to make, in this case if k is even then as usual it has no affect otherwise flip his sign then sum up all the elements.\\n\\n![image](https://assets.leetcode.com/users/images/1cdf6bd7-42a5-4a18-bcc5-31b3ab1dfddb_1629865210.0578444.png)\\n\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\n        less = False\\n        for i in nums:\\n            if i < 0:\\n                less = True\\n                break\\n        \\n        nums.sort(key = lambda x : abs(x))\\n\\n        if not less:\\n            if k % 2 == 0:\\n                return sum(nums)\\n            else:\\n                return sum(nums[1:]) - nums[0]\\n\\n        i = len(nums) - 1\\n        while(k > 0):\\n            if nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n            i -= 1\\n\\n            if i == 0 and k > 0:\\n                if nums[0] > 0:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n                else:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n\\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\n        less = False\\n        for i in nums:\\n            if i < 0:\\n                less = True\\n                break\\n        \\n        nums.sort(key = lambda x : abs(x))\\n\\n        if not less:\\n            if k % 2 == 0:\\n                return sum(nums)\\n            else:\\n                return sum(nums[1:]) - nums[0]\\n\\n        i = len(nums) - 1\\n        while(k > 0):\\n            if nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n            i -= 1\\n\\n            if i == 0 and k > 0:\\n                if nums[0] > 0:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n                else:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n\\n        return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420953,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size() && k>0; i++)\\n        {\\n           if(nums[i]>=0)\\n               break;\\n            nums[i]*=-1;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k%2)\\n            nums[0]*=-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size() && k>0; i++)\\n        {\\n           if(nums[i]>=0)\\n               break;\\n            nums[i]*=-1;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k%2)\\n            nums[0]*=-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395789,
                "title": "python3-priority-queue-very-easy",
                "content": "\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\t\\t\\theapq.heapify(nums)\\n\\t\\t\\twhile k > 0:\\n\\t\\t\\t\\tval=heapq.heappop(nums)\\n\\t\\t\\t\\tval *=  -1\\n\\t\\t\\t\\theapq.heappush(nums,val)\\n\\t\\t\\t\\tk = k -1\\n\\t\\t\\treturn sum(nums)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\t\\t\\theapq.heapify(nums)\\n\\t\\t\\twhile k > 0:\\n\\t\\t\\t\\tval=heapq.heappop(nums)\\n\\t\\t\\t\\tval *=  -1\\n\\t\\t\\t\\theapq.heappush(nums,val)\\n\\t\\t\\t\\tk = k -1\\n\\t\\t\\treturn sum(nums)",
                "codeTag": "Java"
            },
            {
                "id": 1388198,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344662,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(), nums.end());\\n        while(k>0){\\n            k--;\\n            nums[0]=-nums[0];\\n            sort(nums.begin(), nums.end());\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            ans += nums[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(), nums.end());\\n        while(k>0){\\n            k--;\\n            nums[0]=-nums[0];\\n            sort(nums.begin(), nums.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1340418,
                "title": "easy-to-understand-java-beats-99-87",
                "content": "```class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int i=0;\\n        while(i<nums.length && nums[i]<0 && k>0){\\n            nums[i]= -nums[i];\\n            i++;\\n            k--;\\n        }\\n        \\n        if(k>0 && k%2==1){\\n            Arrays.sort(nums);\\n            nums[0]= -nums[0];\\n        }\\n        \\n        int res=0;\\n        for(int n : nums){\\n            res+=n;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int i=0;\\n        while(i<nums.length && nums[i]<0 && k>0){\\n            nums[i]= -nums[i];\\n            i++;\\n            k--;\\n        }\\n        \\n        if(k>0 && k%2==1){\\n            Arrays.sort(nums);\\n            nums[0]= -nums[0];\\n        }\\n        \\n        int res=0;\\n        for(int n : nums){\\n            res+=n;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1331217,
                "title": "c-code",
                "content": "```\\nint largestSumAfterKNegations(vector<int>& v, int k) {\\n        sort(v.begin(), v.end());\\n        \\n        int count{};\\n        //counting negative numbers\\n        for(int i = 0 ; i < v.size(); i++){\\n           if(v[i] >= 0) break;\\n            count++;\\n        }\\n        \\n        //if negative numbers are more than k\\n        if(count > k){ \\n        for(int i = 0; i < k; i++){\\n            v[i] = -v[i];\\n        }}\\n        //negative numbers less than k\\n        else{\\n            int i = 0;\\n            for(; i < count; i++){\\n               v[i] = -v[i];\\n               k--;\\n            } \\n            //k%2 to decrease the value of k\\n             k = k%2;\\n            if(k > 0){\\n             if(i==0 && k > 0) v[0] = -v[0];\\n             else if(v[i] < v[i-1] && k > 0) v[i] = -v[i];\\n             else v[i-1] = -v[i-1];}\\n           }\\n        \\n        int sum{};\\n        for(auto val : v){\\n           sum += val; \\n        }\\n        \\n        return sum;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\nint largestSumAfterKNegations(vector<int>& v, int k) {\\n        sort(v.begin(), v.end());\\n        \\n        int count{};\\n        //counting negative numbers\\n        for(int i = 0 ; i < v.size(); i++){\\n           if(v[i] >= 0) break;\\n            count++;\\n        }\\n        \\n        //if negative numbers are more than k\\n        if(count > k){ \\n        for(int i = 0; i < k; i++){\\n            v[i] = -v[i];\\n        }}\\n        //negative numbers less than k\\n        else{\\n            int i = 0;\\n            for(; i < count; i++){\\n               v[i] = -v[i];\\n               k--;\\n            } \\n            //k%2 to decrease the value of k\\n             k = k%2;\\n            if(k > 0){\\n             if(i==0 && k > 0) v[0] = -v[0];\\n             else if(v[i] < v[i-1] && k > 0) v[i] = -v[i];\\n             else v[i-1] = -v[i-1];}\\n           }\\n        \\n        int sum{};\\n        for(auto val : v){\\n           sum += val; \\n        }\\n        \\n        return sum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1305157,
                "title": "java-quick-sort-faster-than-99-66",
                "content": "I am a newbie just learnt quick sort. If you know any algorithm which can make it even faster, please tell me and I will appreciate it!\\n\\n```\\npublic class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int length = nums.length;\\n        int negNum = 0;\\n        boolean[] neg = new boolean[length];\\n        for (int i = 0; i < length; i++)\\n            if (nums[i] < 0) {\\n                neg[i] = true;\\n                negNum++;\\n                nums[i] = -nums[i];\\n            }\\n\\n        quickSort(neg, nums, 0, length - 1);\\n\\n        if (k < negNum) {\\n            int reverse = 0;\\n            for (int i = 0; i < length; i++) {\\n                if (k <= reverse) {\\n                    for (int j = i; j < length; j++)\\n                        if (neg[j])\\n                            nums[j] = -nums[j];\\n\\n                    break;\\n                }\\n                else {\\n                    if (neg[i])\\n                        reverse++;\\n                }\\n            }\\n        }\\n        else {\\n            k = (k - negNum) % 2;\\n            if (k == 1)\\n                nums[length - 1] = -nums[length - 1];\\n        }\\n\\n        int answer = 0;\\n        for (int i = 0; i < length; i++)\\n            answer += nums[i];\\n\\n        return answer;\\n    }\\n\\n    public static void quickSort(boolean[] neg, int[] arr, int start, int end) {\\n        if (start >= end) return;\\n\\n        int pivot = arr[start];\\n        int i = start, j = end;\\n\\n        while (i != j) {\\n            while (i < j && arr[j] <= pivot)\\n                j--;\\n            swap(neg, arr, i, j);\\n            while (i < j && arr[i] >= pivot)\\n                i++;\\n            swap(neg, arr, i, j);\\n        }\\n\\n        quickSort(neg, arr, start, i-1);\\n        quickSort(neg, arr, i+1, end);\\n    }\\n\\n    public static void swap(boolean[] neg, int[] arr, int a, int b) {\\n        int c = arr[a];\\n        boolean cb = neg[a];\\n\\n        arr[a] = arr[b];\\n        neg[a] = neg[b];\\n\\n        arr[b] = c;\\n        neg[b] = cb;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int length = nums.length;\\n        int negNum = 0;\\n        boolean[] neg = new boolean[length];\\n        for (int i = 0; i < length; i++)\\n            if (nums[i] < 0) {\\n                neg[i] = true;\\n                negNum++;\\n                nums[i] = -nums[i];\\n            }\\n\\n        quickSort(neg, nums, 0, length - 1);\\n\\n        if (k < negNum) {\\n            int reverse = 0;\\n            for (int i = 0; i < length; i++) {\\n                if (k <= reverse) {\\n                    for (int j = i; j < length; j++)\\n                        if (neg[j])\\n                            nums[j] = -nums[j];\\n\\n                    break;\\n                }\\n                else {\\n                    if (neg[i])\\n                        reverse++;\\n                }\\n            }\\n        }\\n        else {\\n            k = (k - negNum) % 2;\\n            if (k == 1)\\n                nums[length - 1] = -nums[length - 1];\\n        }\\n\\n        int answer = 0;\\n        for (int i = 0; i < length; i++)\\n            answer += nums[i];\\n\\n        return answer;\\n    }\\n\\n    public static void quickSort(boolean[] neg, int[] arr, int start, int end) {\\n        if (start >= end) return;\\n\\n        int pivot = arr[start];\\n        int i = start, j = end;\\n\\n        while (i != j) {\\n            while (i < j && arr[j] <= pivot)\\n                j--;\\n            swap(neg, arr, i, j);\\n            while (i < j && arr[i] >= pivot)\\n                i++;\\n            swap(neg, arr, i, j);\\n        }\\n\\n        quickSort(neg, arr, start, i-1);\\n        quickSort(neg, arr, i+1, end);\\n    }\\n\\n    public static void swap(boolean[] neg, int[] arr, int a, int b) {\\n        int c = arr[a];\\n        boolean cb = neg[a];\\n\\n        arr[a] = arr[b];\\n        neg[a] = neg[b];\\n\\n        arr[b] = c;\\n        neg[b] = cb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272999,
                "title": "python-simple-heap-solution-o-nlogk",
                "content": "```python\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:        \\n        heapify(nums)\\n        while nums[0] < 0 and k:\\n            heappush(nums, -heappop(nums))\\n            k -= 1\\n        if k%2:\\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:        \\n        heapify(nums)\\n        while nums[0] < 0 and k:\\n            heappush(nums, -heappop(nums))\\n            k -= 1\\n        if k%2:\\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1265322,
                "title": "o-n-min-k-n-logn-no-sort-only-negatives-in-minheap-and-some-idea-for-special-case-o-n-d",
                "content": "```\\n\\t\\t# O(N+min(K,N)*logN) idea -> divide into positive and negative nums\\n        # make two heaps, try to always remove most negative and make \\n        # him positive, if over then take smallest positive\\n        # and make it neg, if odd count\\n        # if even count just discard\\n        res = 0\\n        negs = [x for x in nums if x < 0]\\n        heapify(negs)\\n        minPos = min([x for x in nums if x >= 0])\\n\\n        \\n        while negs and k:\\n            k -= 1\\n            v = -(heappop(negs))\\n            nums.append(v) # he is now a positive number so he\\n            minPos = min(minPos, v) #  is included in minPos (testcase 78)!\\n            \\n        if negs and k==0:\\n            return  sum(negs) + sum([x for x in nums if x > 0])\\n        \\n        elif k % 2:\\n            return res + sum([x for x in nums if x >= 0]) - 2*minPos\\n        \\n        return  sum([x for x in nums if x >= 0])\\n    \\n    \\n        # can do quickselect for K smallest.. negs O(Negs) but too lazy\\n        # another optimization, if K > no. of negatives THEN no \\n        # q needed!!! just add all absolute values - min abs() \\n        # and return  :D\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\t\\t# O(N+min(K,N)*logN) idea -> divide into positive and negative nums\\n        # make two heaps, try to always remove most negative and make \\n        # him positive, if over then take smallest positive\\n        # and make it neg, if odd count\\n        # if even count just discard\\n        res = 0\\n        negs = [x for x in nums if x < 0]\\n        heapify(negs)\\n        minPos = min([x for x in nums if x >= 0])\\n\\n        \\n        while negs and k:\\n            k -= 1\\n            v = -(heappop(negs))\\n            nums.append(v) # he is now a positive number so he\\n            minPos = min(minPos, v) #  is included in minPos (testcase 78)!\\n            \\n        if negs and k==0:\\n            return  sum(negs) + sum([x for x in nums if x > 0])\\n        \\n        elif k % 2:\\n            return res + sum([x for x in nums if x >= 0]) - 2*minPos\\n        \\n        return  sum([x for x in nums if x >= 0])\\n    \\n    \\n        # can do quickselect for K smallest.. negs O(Negs) but too lazy\\n        # another optimization, if K > no. of negatives THEN no \\n        # q needed!!! just add all absolute values - min abs() \\n        # and return  :D\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1254689,
                "title": "simple-java-solution-easy-to-understand",
                "content": "For every bit remain the cur % 10, and check (cur * 2 + bit) % 5 == 0.\\n\\n```java\\n// AC: Runtime: 3 ms, faster than 59.64% of Java online submissions for Binary Prefix Divisible By 5.\\n// Memory Usage: 39.6 MB, less than 54.20% of Java online submissions for Binary Prefix Divisible By 5.\\n// every bit remain the cur % 10, and check (cur * 2 + bit) % 5 == 0.\\n// T:O(n), S:O(1)\\n//\\nclass Solution {\\n    public List<Boolean> prefixesDivBy5(int[] nums) {\\n        List<Boolean> ret = new LinkedList<>();\\n        int cur = 0;\\n        for (int num : nums) {\\n            cur = cur * 2 + num;\\n            ret.add(cur % 5 == 0);\\n            cur %= 10;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// AC: Runtime: 3 ms, faster than 59.64% of Java online submissions for Binary Prefix Divisible By 5.\\n// Memory Usage: 39.6 MB, less than 54.20% of Java online submissions for Binary Prefix Divisible By 5.\\n// every bit remain the cur % 10, and check (cur * 2 + bit) % 5 == 0.\\n// T:O(n), S:O(1)\\n//\\nclass Solution {\\n    public List<Boolean> prefixesDivBy5(int[] nums) {\\n        List<Boolean> ret = new LinkedList<>();\\n        int cur = 0;\\n        for (int num : nums) {\\n            cur = cur * 2 + num;\\n            ret.add(cur % 5 == 0);\\n            cur %= 10;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243544,
                "title": "c-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());        \\n        \\n        while(k-- != 0) {\\n            int x = pq.top();\\n            \\n            pq.pop();\\n            x *= -1;\\n            pq.push(x);\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());        \\n        \\n        while(k-- != 0) {\\n            int x = pq.top();\\n            \\n            pq.pop();\\n            x *= -1;\\n            pq.push(x);\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243074,
                "title": "c-simple-easy-to-understand-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        while(k--)\\n        {\\n            int x=pq.top();\\n            pq.pop();\\n            x=x*(-1);\\n            pq.push(x);\\n            \\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        while(k--)\\n        {\\n            int x=pq.top();\\n            pq.pop();\\n            x=x*(-1);\\n            pq.push(x);\\n            \\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228053,
                "title": "simple-readable-java-code-beats-99-60-time-o-nlogn",
                "content": "```\\nclass Solution { \\n    public int largestSumAfterKNegations(int[] nums, int k) {    \\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int l = 0;\\n        while(l<nums.length && k>=1){\\n            if(nums[l]<0){\\n                nums[l]=(-1)*nums[l];\\n                k--;\\n                l++;\\n            }\\n            else{\\n               break;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        if(nums[0]==0 || k==0){\\n            for(int i=0; i<nums.length; i++){\\n                ans = ans + nums[i];\\n            }\\n        } \\n        else{  \\n            if(k%2==0){\\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n            }\\n            else{  \\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n                ans = ans-2*(nums[0]);\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    public int largestSumAfterKNegations(int[] nums, int k) {    \\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int l = 0;\\n        while(l<nums.length && k>=1){\\n            if(nums[l]<0){\\n                nums[l]=(-1)*nums[l];\\n                k--;\\n                l++;\\n            }\\n            else{\\n               break;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        if(nums[0]==0 || k==0){\\n            for(int i=0; i<nums.length; i++){\\n                ans = ans + nums[i];\\n            }\\n        } \\n        else{  \\n            if(k%2==0){\\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n            }\\n            else{  \\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n                ans = ans-2*(nums[0]);\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223059,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n                if(nums[i]<0 ){\\n                        if(k>0){\\n                                nums[i]=-nums[i];\\n                                k--;\\n                        }\\n                        else{\\n                                break;\\n                        }\\n                }\\n        }\\n            int res=0;\\n            for(int x:nums){\\n                    res+=x;\\n            }\\n            cout<<res;\\n            if(k==0 or k%2==0){\\n                    return res;\\n            }\\n            sort(nums.begin(),nums.end());\\n            res=res-2*nums[0];\\n            return res;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n                if(nums[i]<0 ){\\n                        if(k>0){\\n                                nums[i]=-nums[i];\\n                                k--;\\n                        }\\n                        else{\\n                                break;\\n                        }\\n                }\\n        }\\n            int res=0;\\n            for(int x:nums){\\n                    res+=x;\\n            }\\n            cout<<res;\\n            if(k==0 or k%2==0){\\n                    return res;\\n            }\\n            sort(nums.begin(),nums.end());\\n            res=res-2*nums[0];\\n            return res;\\n            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1184981,
                "title": "java-o-nlogn-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i = 0;\\n       while(K > 0) {\\n           if(A[i] > 0) {\\n               if(K % 2 == 0)\\n                   K = 0;\\n               else {\\n                   A[i] = -1*A[i];\\n                   K = 0;\\n               }\\n           }\\n           else if(A[i] < 0){\\n               if(i + 1 != A.length && A[i + 1] > 0 && A[i + 1] > -1*A[i]) {\\n                   K--;\\n                   if(K % 2 == 0) {\\n                       A[i] = -1* A[i];\\n                       K = 0;\\n                       \\n                   }\\n                   else{\\n                       K = 0;\\n                       }\\n               }\\n               else{\\n               A[i] = -1* A[i];\\n               K--;\\n               i++;\\n               }\\n           }\\n           else{\\n               K = 0;\\n           }\\n       }\\n        int sum = 0;\\n        for(int j = 0; j < A.length; j++) {\\n            sum += A[j];\\n        }\\n        return sum;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i = 0;\\n       while(K > 0) {\\n           if(A[i] > 0) {\\n               if(K % 2 == 0)\\n                   K = 0;\\n               else {\\n                   A[i] = -1*A[i];\\n                   K = 0;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1155292,
                "title": "c-0ms-100-basket-sort-with-comments",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximize Sum Of Array After K Negations.\\nMemory Usage: 9.1 MB, less than 41.00% of C++ online submissions for Maximize Sum Of Array After K Negations.\\n**General idea:** \\n1. Use basket sort and contain all numbers into array table\\n2. Travers through negative numbers and do two operation : transforme (K negative numbers) and find the greater negative number (flag - for mark : we transform all negative numbers or not) and culculate total sum\\n3.  Travers through positive numbers : culculate total sum and find the minimal positive number.\\n4.  After these if we have K is even or we have 0 in array - our sum is answer;\\n in other case we check mn and mp (minimal negative and minimal positive number) and delete minimal from sum. \\n\\n```\\nclass Solution {\\npublic:\\n  int largestSumAfterKNegations(vector<int>& A, int K) {\\n    int table[201] = {0}, sum = 0, i = 0, j = -100, mn = -1000, mp = 1000;\\n    bool flag = false;\\n    \\n    for(int i = 0 ; i != A.size(); i++) table[A[i] + 100]++;\\n    \\n    for(;i != 100 && K;i++,j++){\\n      if(table[i]){\\n        mn = j;\\n        if(K >= table[i]) {sum -= j*table[i]; K -= table[i];} \\n        else {sum -= j*K; sum += j*(table[i] - K); K = 0; flag = true;} \\n      }\\n    }\\n    for(;i != 100;i++,j++){\\n      if(table[i]){\\n        flag = true;\\n        mn = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n    i = 200, j = 100;\\n    for(;j ;i--,j--){\\n      if(table[i]){\\n        mp = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n   \\n    if(table[100] || K%2 == 0) return sum;\\n    if(!flag || mn == -1000) mn = -mn;\\n   \\n    return mp < mn ? sum - mp*2 : sum - mn*2;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int largestSumAfterKNegations(vector<int>& A, int K) {\\n    int table[201] = {0}, sum = 0, i = 0, j = -100, mn = -1000, mp = 1000;\\n    bool flag = false;\\n    \\n    for(int i = 0 ; i != A.size(); i++) table[A[i] + 100]++;\\n    \\n    for(;i != 100 && K;i++,j++){\\n      if(table[i]){\\n        mn = j;\\n        if(K >= table[i]) {sum -= j*table[i]; K -= table[i];} \\n        else {sum -= j*K; sum += j*(table[i] - K); K = 0; flag = true;} \\n      }\\n    }\\n    for(;i != 100;i++,j++){\\n      if(table[i]){\\n        flag = true;\\n        mn = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n    i = 200, j = 100;\\n    for(;j ;i--,j--){\\n      if(table[i]){\\n        mp = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n   \\n    if(table[100] || K%2 == 0) return sum;\\n    if(!flag || mn == -1000) mn = -mn;\\n   \\n    return mp < mn ? sum - mp*2 : sum - mn*2;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100048,
                "title": "really-simple-solution-using-a-min-heap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        int total = accumulate(A.begin(), A.end(), 0);\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        for(int i : A)  q.push(i);\\n        while(k--){\\n            int t = q.top();\\n            q.pop();\\n            q.push((-t));\\n            total = total + ((-t) - t);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        int total = accumulate(A.begin(), A.end(), 0);\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        for(int i : A)  q.push(i);\\n        while(k--){\\n            int t = q.top();\\n            q.pop();\\n            q.push((-t));\\n            total = total + ((-t) - t);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078815,
                "title": "faster-than-100-percent-c",
                "content": "sort(A.begin(),A.end());\\n        int n=A.size();\\n        int i;\\n        int sum=0;\\n        int negative_c=0;\\n        if(A[0]>=0&&k%2==0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n        }\\n        else if(A[0]>=0&&k%2==1)\\n        {\\n             for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n            sum-=A[0];\\n            sum-=A[0];\\n        }\\n        else \\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                if(A[i]<0)\\n                {\\n                    negative_c++;\\n                }\\n            }\\n            if(negative_c==k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    sum+=abs(A[i]);\\n                }\\n            }\\n            else if(negative_c>k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    if(k>0&&A[i]<0)\\n                    {\\n                        sum+=abs(A[i]);\\n                        k--;\\n                    }\\n                    else if(k<=0)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n            }\\n            else if(k>negative_c)\\n            {\\n                k=k-negative_c;\\n                for(i=0;i<n;i++)\\n                {\\n                    A[i]=abs(A[i]);\\n                }\\n                sort(A.begin(),A.end());\\n                if(k%2==0)\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n                else\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                    sum-=A[0];\\n                    sum-=A[0];\\n                }\\n            }\\n        }\\n        return sum;",
                "solutionTags": [],
                "code": "sort(A.begin(),A.end());\\n        int n=A.size();\\n        int i;\\n        int sum=0;\\n        int negative_c=0;\\n        if(A[0]>=0&&k%2==0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n        }\\n        else if(A[0]>=0&&k%2==1)\\n        {\\n             for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n            sum-=A[0];\\n            sum-=A[0];\\n        }\\n        else \\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                if(A[i]<0)\\n                {\\n                    negative_c++;\\n                }\\n            }\\n            if(negative_c==k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    sum+=abs(A[i]);\\n                }\\n            }\\n            else if(negative_c>k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    if(k>0&&A[i]<0)\\n                    {\\n                        sum+=abs(A[i]);\\n                        k--;\\n                    }\\n                    else if(k<=0)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n            }\\n            else if(k>negative_c)\\n            {\\n                k=k-negative_c;\\n                for(i=0;i<n;i++)\\n                {\\n                    A[i]=abs(A[i]);\\n                }\\n                sort(A.begin(),A.end());\\n                if(k%2==0)\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n                else\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                    sum-=A[0];\\n                    sum-=A[0];\\n                }\\n            }\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 986268,
                "title": "faster-than-99-of-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i] < 0 && K>0)   // if element is negative, reverse it until k iterations\\n            {\\n                A[i]=A[i]*(-1);\\n                K--;\\n            }\\n        }\\n        int index=min_element(A.begin(),A.end())-A.begin(); // find index of minimum element\\n        \\n        if(K%2==1)   // if k is even, no change in array required.. if odd, then reverse                           // smallest\\n        {\\n            A[index]=A[index]*(-1);\\n          \\n        }\\n        int sum=0;\\n\\n        for(auto it:A)\\n            sum+=it;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i] < 0 && K>0)   // if element is negative, reverse it until k iterations\\n            {\\n                A[i]=A[i]*(-1);\\n                K--;\\n            }\\n        }\\n        int index=min_element(A.begin(),A.end())-A.begin(); // find index of minimum element\\n        \\n        if(K%2==1)   // if k is even, no change in array required.. if odd, then reverse                           // smallest\\n        {\\n            A[index]=A[index]*(-1);\\n          \\n        }\\n        int sum=0;\\n\\n        for(auto it:A)\\n            sum+=it;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976835,
                "title": "sort-and-then-one-pass",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i=0,s=0;\\n        while(K>0 && A[i]<0)\\n        {\\n            s-=A[i];\\n            K--;\\n            i++;\\n        }\\n        if(A[0]<0 && K%2!=0 && A[i]!=0)\\n        {\\n            if(-A[i-1]<A[i])\\n            {\\n                s+=2*A[i-1];\\n            }\\n            else\\n            {\\n                s-=A[i++];\\n            }\\n        }\\n        else if(A[i]!=0 && K%2!=0)\\n        {\\n            s-=A[i++];\\n        }\\n        for(;i<A.length;i++)\\n        {\\n            s+=A[i];\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i=0,s=0;\\n        while(K>0 && A[i]<0)\\n        {\\n            s-=A[i];\\n            K--;\\n            i++;\\n        }\\n        if(A[0]<0 && K%2!=0 && A[i]!=0)\\n        {\\n            if(-A[i-1]<A[i])\\n            {\\n                s+=2*A[i-1];\\n            }\\n            else\\n            {\\n                s-=A[i++];\\n            }\\n        }\\n        else if(A[i]!=0 && K%2!=0)\\n        {\\n            s-=A[i++];\\n        }\\n        for(;i<A.length;i++)\\n        {\\n            s+=A[i];\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890598,
                "title": "python-heap-time-o-n-k-ln-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            a = heapq.heappop(A)\\n            heapq.heappush(A, -a)        \\n        return sum(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            a = heapq.heappop(A)\\n            heapq.heappush(A, -a)        \\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857619,
                "title": "c-simple-o-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size(),sum=0,neg=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            if(A[i]<0)\\n                neg++;\\n        }\\n      \\n        if(neg>=k)\\n            for(int i=0;i<k;i++)\\n                A[i]*=-1;\\n        else{\\n            for(int i=0;i<neg;i++)\\n                A[i]*=-1;\\n            k-=neg;\\n            sort(A.begin(),A.end());    \\n            if(k%2!=0)\\n                A[0]*=-1;\\n            }\\n       \\n        for(int i=0;i<n;i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size(),sum=0,neg=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            if(A[i]<0)\\n                neg++;\\n        }\\n      \\n        if(neg>=k)\\n            for(int i=0;i<k;i++)\\n                A[i]*=-1;\\n        else{\\n            for(int i=0;i<neg;i++)\\n                A[i]*=-1;\\n            k-=neg;\\n            sort(A.begin(),A.end());    \\n            if(k%2!=0)\\n                A[0]*=-1;\\n            }\\n       \\n        for(int i=0;i<n;i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854867,
                "title": "go-solution-with-sort",
                "content": "https://github.com/phea/leetcode-go\\n```go\\nfunc largestSumAfterKNegations(A []int, K int) int {\\n\\tsort.Ints(A)\\n\\tvar pos int\\n\\tfor K > 0 {\\n\\t\\tif A[pos] == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif pos < len(A)-1 {\\n\\t\\t\\tif (A[pos] < 0 && A[pos+1] < 0) || A[pos]*-1 > A[pos+1] {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t\\tpos++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tA[pos] *= -1\\n\\t\\t}\\n\\n\\t\\tK--\\n\\t}\\n\\n\\tvar total int\\n\\tfor _, n := range A {\\n\\t\\ttotal += n\\n\\t}\\n\\n\\treturn total\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc largestSumAfterKNegations(A []int, K int) int {\\n\\tsort.Ints(A)\\n\\tvar pos int\\n\\tfor K > 0 {\\n\\t\\tif A[pos] == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif pos < len(A)-1 {\\n\\t\\t\\tif (A[pos] < 0 && A[pos+1] < 0) || A[pos]*-1 > A[pos+1] {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t\\tpos++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tA[pos] *= -1\\n\\t\\t}\\n\\n\\t\\tK--\\n\\t}\\n\\n\\tvar total int\\n\\tfor _, n := range A {\\n\\t\\ttotal += n\\n\\t}\\n\\n\\treturn total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845908,
                "title": "java-brutal-force",
                "content": "I don\\'t think this should be an easy quesiton.\\n```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int m = A.length, neg = 0, min = Integer.MAX_VALUE, sum = 0;\\n        for (int n : A) {\\n            if (n < 0) neg++;\\n            else min = Math.min(n, min);  //find the min to keep turning;\\n            sum += n;\\n        }\\n        if (neg != 0) {\\n            if (neg > K) { // find the smallest negs to turn to positive;\\n                PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);  // min queue\\n                for (int n : A) {\\n                    if (n < 0) pq.offer(n);\\n                    if (pq.size() > K) pq.poll();\\n                }\\n                while (!pq.isEmpty()) sum -= 2 * pq.poll();\\n                return sum;\\n            }\\n            K -= neg;  // turn all neg to positive;\\n            for (int n : A) {\\n                if (n < 0) {\\n                    n *= -1;\\n                    sum += n * 2;\\n                }\\n                min = Math.min(n, min);\\n            }\\n        }\\n        if (K % 2 == 0) return sum;\\n        return sum - 2 * min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int m = A.length, neg = 0, min = Integer.MAX_VALUE, sum = 0;\\n        for (int n : A) {\\n            if (n < 0) neg++;\\n            else min = Math.min(n, min);  //find the min to keep turning;\\n            sum += n;\\n        }\\n        if (neg != 0) {\\n            if (neg > K) { // find the smallest negs to turn to positive;\\n                PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);  // min queue\\n                for (int n : A) {\\n                    if (n < 0) pq.offer(n);\\n                    if (pq.size() > K) pq.poll();\\n                }\\n                while (!pq.isEmpty()) sum -= 2 * pq.poll();\\n                return sum;\\n            }\\n            K -= neg;  // turn all neg to positive;\\n            for (int n : A) {\\n                if (n < 0) {\\n                    n *= -1;\\n                    sum += n * 2;\\n                }\\n                min = Math.min(n, min);\\n            }\\n        }\\n        if (K % 2 == 0) return sum;\\n        return sum - 2 * min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840510,
                "title": "very-simple-pyhon3-solution-using-sort-faster-than-50-46",
                "content": "```\\n\\t\\tfor i in range(K):\\n            A.sort()\\n            A[0] = 0 - A[0]\\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tfor i in range(K):\\n            A.sort()\\n            A[0] = 0 - A[0]\\n        return sum(A)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753996,
                "title": "python-with-explanation-on-greedy",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        #globally optimal strategy:\\n        #if there are negative nums, pick all of these, and pick the smaller ones first\\n        # if there are no negative nums, pick and stick to the smallest one\\n        A.sort()\\n        index = 0\\n        for i in range(len(A)): \\n            if K == 0: \\n                return sum(A)\\n            if A[i] < 0: \\n                A[i] = -A[i]\\n                K -= 1\\n            elif A[i] >= 0: # no more negative nums in A anymore\\n                #look for the smallest num in A\\n                index = A.index(min(A))\\n                break\\n        if K%2 != 0: \\n            A[index] = -A[index]\\n        return sum(A)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        #globally optimal strategy:\\n        #if there are negative nums, pick all of these, and pick the smaller ones first\\n        # if there are no negative nums, pick and stick to the smallest one\\n        A.sort()\\n        index = 0\\n        for i in range(len(A)): \\n            if K == 0: \\n                return sum(A)\\n            if A[i] < 0: \\n                A[i] = -A[i]\\n                K -= 1\\n            elif A[i] >= 0: # no more negative nums in A anymore\\n                #look for the smallest num in A\\n                index = A.index(min(A))\\n                break\\n        if K%2 != 0: \\n            A[index] = -A[index]\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753524,
                "title": "c-o-n-time-o-1-space-using-nth-element",
                "content": "```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        bool flag_zero = 0;\\n        int max_sum = 0;\\n        int min_el = INT_MAX;\\n        \\n        std::nth_element(A.begin(), A.begin() + K, A.end());\\n        \\n        for (int x : A) {\\n            min_el = std::min(min_el, std::abs(x));\\n            \\n            if (x == 0)\\n                flag_zero = 1;\\n            \\n            if (K > 0 && x < 0) {\\n                max_sum -= x;\\n                K--;\\n            } else\\n                max_sum += x;\\n        }\\n        \\n        if (flag_zero || K % 2 == 0)\\n            return max_sum;\\n        \\n        return max_sum - 2 * min_el;    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        bool flag_zero = 0;\\n        int max_sum = 0;\\n        int min_el = INT_MAX;\\n        \\n        std::nth_element(A.begin(), A.begin() + K, A.end());\\n        \\n        for (int x : A) {\\n            min_el = std::min(min_el, std::abs(x));\\n            \\n            if (x == 0)\\n                flag_zero = 1;\\n            \\n            if (K > 0 && x < 0) {\\n                max_sum -= x;\\n                K--;\\n            } else\\n                max_sum += x;\\n        }\\n        \\n        if (flag_zero || K % 2 == 0)\\n            return max_sum;\\n        \\n        return max_sum - 2 * min_el;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 752030,
                "title": "java-99-88",
                "content": "class Solution {\\n\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum =0;\\n        int i=0;\\n        int index=0;\\n        while(K-- >0){\\n            index=i;\\n            if(A[i]>A[i+1]){\\n                i++;\\n                index=i;\\n            }\\n            A[index]=-A[index];\\n        }\\n        for(int a:A){\\n            sum+=a;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum =0;\\n        int i=0;\\n        int index=0;\\n        while(K-- >0){\\n            index=i;\\n            if(A[i]>A[i+1]){\\n                i++;\\n                index=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 744515,
                "title": "java-with-comments-using-priority-queue-very-short-and-simple",
                "content": "```\\n public int largestSumAfterKNegations(int[] A, int K) {    \\n    PriorityQueue<Integer>  minHeap = new  PriorityQueue<Integer>();     \\n    for ( int a : A ) minHeap.add(a);\\n    // for K times , pick the smallest element , multiple by -1 andd into PQ .\\n    // replace A[i] with -A[i], and we repeat this process K times in total.\\n    while( K-- > 0 )  minHeap.add((-1)*minHeap.remove());    \\n    // Now add all elements , which will give max sum .        \\n    int sum =0 ;\\n    while(!minHeap.isEmpty()) sum+= minHeap.remove();\\n    return(sum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int largestSumAfterKNegations(int[] A, int K) {    \\n    PriorityQueue<Integer>  minHeap = new  PriorityQueue<Integer>();     \\n    for ( int a : A ) minHeap.add(a);\\n    // for K times , pick the smallest element , multiple by -1 andd into PQ .\\n    // replace A[i] with -A[i], and we repeat this process K times in total.\\n    while( K-- > 0 )  minHeap.add((-1)*minHeap.remove());    \\n    // Now add all elements , which will give max sum .        \\n    int sum =0 ;\\n    while(!minHeap.isEmpty()) sum+= minHeap.remove();\\n    return(sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732238,
                "title": "simple-python-solution-sort-by-absolute-value",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(key=abs, reverse=True)\\n        k = 0\\n        for i in range(len(A)):\\n            if A[i] < 0:\\n                A[i] = -A[i]\\n                k += 1\\n            if k >= K:\\n                return sum(A)\\n        if (K - k) % 2 == 1:\\n            A[-1] = -A[-1]\\n        return sum(A)\\n```\\nWorks well with very large K.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(key=abs, reverse=True)\\n        k = 0\\n        for i in range(len(A)):\\n            if A[i] < 0:\\n                A[i] = -A[i]\\n                k += 1\\n            if k >= K:\\n                return sum(A)\\n        if (K - k) % 2 == 1:\\n            A[-1] = -A[-1]\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671331,
                "title": "java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        int i = 0;\\n        while(A[i] < 0 && K > 0) {\\n            A[i] = -1 * A[i];\\n            i++;\\n            K--;\\n        }\\n        Arrays.sort(A);\\n        if(K % 2 == 1) {\\n            A[0] = -1 * A[0];\\n        }\\n        for(int j = 0; j < A.length; j++) {\\n            sum += A[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        int i = 0;\\n        while(A[i] < 0 && K > 0) {\\n            A[i] = -1 * A[i];\\n            i++;\\n            K--;\\n        }\\n        Arrays.sort(A);\\n        if(K % 2 == 1) {\\n            A[0] = -1 * A[0];\\n        }\\n        for(int j = 0; j < A.length; j++) {\\n            sum += A[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649806,
                "title": "easy-to-understand-solution-c",
                "content": "The solution is to invert the negative numbers first (as many as possible), so that sum becomes larger. After all the negatives are inverted and we still have K > 0, check for following:\\n* If K is even, return the sum of the array (as no negatives are present at this point)\\n* If K is odd, we need to change sign only for minimum element in current array (so subtract twice of that minimum element from new sum calculated)\\n\\nHope this helps for someone! : )\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        for(int i=0;i<A.size() && K>0 && A[i]<0;i++,K--)\\n            A[i] = -A[i];\\n        int sum = 0, minVal = INT_MAX;\\n        for(int x : A){\\n            sum += x;\\n            minVal = min(x,minVal);\\n        }\\n        if(K & 1)\\n            return (sum - 2 * minVal);\\n        else\\n            return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        for(int i=0;i<A.size() && K>0 && A[i]<0;i++,K--)\\n            A[i] = -A[i];\\n        int sum = 0, minVal = INT_MAX;\\n        for(int x : A){\\n            sum += x;\\n            minVal = min(x,minVal);\\n        }\\n        if(K & 1)\\n            return (sum - 2 * minVal);\\n        else\\n            return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645310,
                "title": "java-2-different-solutions-accepted",
                "content": "ok lets do this!\\n\\nFirst of all this is a problem which can solved using **Greedy Algorithm**!\\nwhy?\\n\\n# intuiton-\\n**we are said to negate an element of the array for k times,and maximise the sum of the array elements!\\nso basically what should come to mind immediately that we should negate the smallest number in the array so that our maximum gets decreased as little as possible!\\nhence we are greedily choosing the lowest element at each iteration !**\\n\\nfirst thing that comes to mind is that we should sort the array in ascending order!\\nthat is correct ,but remember k can be greater than one ,hence we need to sort the array for each iteration of k;\\n\\ncode-\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    Arrays.sort(A);\\n        int t=0;\\n        while(K-- > 0)\\n        {\\n     t=A[0];    //each time choosing the smallest element\\n    A[0]=-t;\\n            Arrays.sort(A);\\n        }\\n        \\n        int s=0;\\n        for(int i  :A)\\n        {\\n            s+=i;\\n        }\\n        return s;       \\n    }\\n}\\n```\\n\\nthis solution does the job but we are sorting the array k times,hence the runtime will be higher!\\n\\nwe can get through this problem of sorting everytime by using a **priority queue**!\\nthe priority queue will itself maintain its first element as the lowest one!\\n\\ncode-\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    \\n        PriorityQueue<Integer> q = new PriorityQueue<>();  //queue will maintain ascending order \\n        for(int k :  A)\\n        {\\n            q.add(k);\\n        }\\n    \\n    \\n    while(K-- > 0)\\n    {\\n       int x=q.poll();\\n        q.add(-x);  //adding the negative value of the lowest element\\n    }\\n    int s=0;\\n        \\n       while(!q.isEmpty())\\n        {\\n            s+=q.poll() ;\\n        }\\n   return s;\\n    }\\n}\\n```\\n\\n\\nhope it helps!\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    Arrays.sort(A);\\n        int t=0;\\n        while(K-- > 0)\\n        {\\n     t=A[0];    //each time choosing the smallest element\\n    A[0]=-t;\\n            Arrays.sort(A);\\n        }\\n        \\n        int s=0;\\n        for(int i  :A)\\n        {\\n            s+=i;\\n        }\\n        return s;       \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    \\n        PriorityQueue<Integer> q = new PriorityQueue<>();  //queue will maintain ascending order \\n        for(int k :  A)\\n        {\\n            q.add(k);\\n        }\\n    \\n    \\n    while(K-- > 0)\\n    {\\n       int x=q.poll();\\n        q.add(-x);  //adding the negative value of the lowest element\\n    }\\n    int s=0;\\n        \\n       while(!q.isEmpty())\\n        {\\n            s+=q.poll() ;\\n        }\\n   return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633557,
                "title": "simpla-java-priority-queue-implementation",
                "content": "Though Process\\n1. Each time we need to flip smallest number\\n2. To Track smallest number use priority queue\\n3. Alternatively you can use loop to track smallest number but it will be tedious to do so\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        int sum=0;\\n        for(int i=0;i<A.length;i++)\\n        {\\n            q.offer(A[i]);\\n            sum=sum+A[i];\\n        }\\n        for(int i=1;i<=K;i++)\\n        {\\n            int item=q.poll();\\n            sum=sum-item;\\n            q.offer(-item);\\n            sum=sum-item;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        int sum=0;\\n        for(int i=0;i<A.length;i++)\\n        {\\n            q.offer(A[i]);\\n            sum=sum+A[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 629515,
                "title": "python-3-heap-97-runtime",
                "content": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        \\n        while(K>0):\\n            min_v = heapq.heappop(A)\\n            heapq.heappush(A, min_v * -1)\\n            K -= 1\\n            \\n        return sum(A)",
                "solutionTags": [],
                "code": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        \\n        while(K>0):\\n            min_v = heapq.heappop(A)\\n            heapq.heappush(A, min_v * -1)\\n            K -= 1\\n            \\n        return sum(A)",
                "codeTag": "Java"
            },
            {
                "id": 610700,
                "title": "cpp-simple-priority-queue-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int> > q(begin(A),end(A));\\n        int x;\\n        while(K--){\\n            x=q.top();\\n            q.pop();\\n            q.push(-x);\\n        }\\n        int s=0;\\n        while(!q.empty()){\\n            s+=q.top();\\n            q.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int> > q(begin(A),end(A));\\n        int x;\\n        while(K--){\\n            x=q.top();\\n            q.pop();\\n            q.push(-x);\\n        }\\n        int s=0;\\n        while(!q.empty()){\\n            s+=q.top();\\n            q.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595661,
                "title": "python-easy-to-understand",
                "content": "```\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(K):\\n            index = A.index(min(A))\\n            A[index] = -A[index]\\n        return sum(A)\\n\\n```\\n\\n************* If helped dont forget to give it a star******************",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(K):\\n            index = A.index(min(A))\\n            A[index] = -A[index]\\n        return sum(A)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590356,
                "title": "c-solution-partial-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        // if there is a single item inverse the item K times \\n        if (1 == A.size())\\n            return 0 == K % 2 ? A[0] : -A[0];\\n        \\n        // use partial sort to set at most K items in order\\n        std::partial_sort(A.begin(), A.begin() + std::min(static_cast<int>(A.size()), K), A.end());\\n        \\n        // inverse by negating at most K negative items\\n        auto it = A.begin();\\n        for (; it != A.end() && *it < 0 && 0 != K; ++it, --K)\\n            *it = -*it;\\n        \\n        // if there is an odd number of inversions left\\n        // and the iterator does not address \\'0\\' value\\n        // we continue maximization by selecting\\n        // an item that the negation of will result in\\n        // the topmost maximum of the sum\\n        if (0 != K % 2 && (it == A.end() || 0 != *it))\\n        {\\n            // if the pointer is at the end then the original array consisted of\\n            // only negative numbers, then we need to inverse the last modified item\\n            // to maximize the sum\\n            if (A.end() == it)\\n                --it;\\n            // if the pointer is at a middle we need to\\n            // decide between two adjacent items which one could result better in the ultimate sum\\n            // be aware, in the modified array order could be violated since negations might have taken place\\n            // in the above\\n            // if the pointer is at the beginning then the array consists of only positive numbers\\n            // then we need to only inverse the first since it is the smallest\\n            else if (A.begin() != it)\\n                it = std::min(it - 1, it, [](auto a, auto b){ return *a < *b; });\\n            *it = -*it;\\n        }\\n        \\n        // summarize the result array\\n        return std::accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        // if there is a single item inverse the item K times \\n        if (1 == A.size())\\n            return 0 == K % 2 ? A[0] : -A[0];\\n        \\n        // use partial sort to set at most K items in order\\n        std::partial_sort(A.begin(), A.begin() + std::min(static_cast<int>(A.size()), K), A.end());\\n        \\n        // inverse by negating at most K negative items\\n        auto it = A.begin();\\n        for (; it != A.end() && *it < 0 && 0 != K; ++it, --K)\\n            *it = -*it;\\n        \\n        // if there is an odd number of inversions left\\n        // and the iterator does not address \\'0\\' value\\n        // we continue maximization by selecting\\n        // an item that the negation of will result in\\n        // the topmost maximum of the sum\\n        if (0 != K % 2 && (it == A.end() || 0 != *it))\\n        {\\n            // if the pointer is at the end then the original array consisted of\\n            // only negative numbers, then we need to inverse the last modified item\\n            // to maximize the sum\\n            if (A.end() == it)\\n                --it;\\n            // if the pointer is at a middle we need to\\n            // decide between two adjacent items which one could result better in the ultimate sum\\n            // be aware, in the modified array order could be violated since negations might have taken place\\n            // in the above\\n            // if the pointer is at the beginning then the array consists of only positive numbers\\n            // then we need to only inverse the first since it is the smallest\\n            else if (A.begin() != it)\\n                it = std::min(it - 1, it, [](auto a, auto b){ return *a < *b; });\\n            *it = -*it;\\n        }\\n        \\n        // summarize the result array\\n        return std::accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574462,
                "title": "c-100-fast-o-k-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        int index=0;\\n        int i=0;\\n        int min=INT_MAX;\\n        int sum=0;\\n            while(A[i]<0 && K)\\n            {\\n                A[i]=-A[i];\\n                if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n                K--;\\n                i++;\\n            }\\n            \\n              if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n              if(K%2==1)\\n                A[index]=-A[index];\\n                \\n        for(int i=0;i<A.size();i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        int index=0;\\n        int i=0;\\n        int min=INT_MAX;\\n        int sum=0;\\n            while(A[i]<0 && K)\\n            {\\n                A[i]=-A[i];\\n                if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n                K--;\\n                i++;\\n            }\\n            \\n              if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n              if(K%2==1)\\n                A[index]=-A[index];\\n                \\n        for(int i=0;i<A.size();i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530233,
                "title": "c-solution-use-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int,vector<int>,greater<int>> q;\\n        for(int i:A)q.push(i);\\n        int res=0;\\n        while(K--){\\n            if(q.top()==0)break;\\n            int k=q.top();q.pop();\\n            q.push(k*-1);\\n        }\\n        while(!q.empty()){\\n            res+=q.top();q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int,vector<int>,greater<int>> q;\\n        for(int i:A)q.push(i);\\n        int res=0;\\n        while(K--){\\n            if(q.top()==0)break;\\n            int k=q.top();q.pop();\\n            q.push(k*-1);\\n        }\\n        while(!q.empty()){\\n            res+=q.top();q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507282,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        i = 0\\n        while K > 0:\\n            A[i] = -A[i]\\n            if A[i] > A[i+1]:\\n                i = i+1\\n            K = K-1\\n            \\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        i = 0\\n        while K > 0:\\n            A[i] = -A[i]\\n            if A[i] > A[i+1]:\\n                i = i+1\\n            K = K-1\\n            \\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495271,
                "title": "a-c-python-3-solution-recursion-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        # print(\" A = \", A)\\n        # print(\"K = \", K)\\n\\n        if (K == 0):\\n            return sum(A)\\n        elif (K == 1):\\n\\n            A[0] = 0-A[0]\\n            return sum(A)\\n        elif (K > 1):\\n\\n            A[0] = 0-A[0]\\n            return self.largestSumAfterKNegations(A, K-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        # print(\" A = \", A)\\n        # print(\"K = \", K)\\n\\n        if (K == 0):\\n            return sum(A)\\n        elif (K == 1):\\n\\n            A[0] = 0-A[0]\\n            return sum(A)\\n        elif (K > 1):\\n\\n            A[0] = 0-A[0]\\n            return self.largestSumAfterKNegations(A, K-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484496,
                "title": "java-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        if(A == null || A.length == 0)\\n            return 0;\\n        int sum = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(int num : A)\\n            pq.add(num);\\n        while(K>0)\\n        {\\n            int num = pq.poll();\\n            pq.add(num*-1);\\n            K--;\\n        }\\n        while(!pq.isEmpty())\\n        {\\n            sum+=pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        if(A == null || A.length == 0)\\n            return 0;\\n        int sum = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(int num : A)\\n            pq.add(num);\\n        while(K>0)\\n        {\\n            int num = pq.poll();\\n            pq.add(num*-1);\\n            K--;\\n        }\\n        while(!pq.isEmpty())\\n        {\\n            sum+=pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451306,
                "title": "o-klogn-solution",
                "content": "Data Structure Used : \\n\\tMin-Heap\\nLogic : \\n\\t  &nbsp; 1) If minimum element is negative, we just change sign of that element and push back into min heap.\\n\\t&nbsp; 2) If minimum element in the array is non negative: ( Base case )\\n\\t\\t&nbsp; &nbsp; a) if K is even:\\n\\t\\t\\t&nbsp; &nbsp; We can just use same index for changing sign even number of times, so our answer is just sum of the array.\\n\\t\\t&nbsp; &nbsp; b) If K is odd:\\n\\t\\t\\t&nbsp; &nbsp; We can do same as before, hence K odd is as good as K  = 1, so we just change sign of minimum element.\\n\\n\\nPython3 Code : \\n\\n```\\nimport heapq \\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        while K:\\n            if A[0] >= 0:\\n                if K & 1:\\n                    heapq.heappush(A,-1*heapq.heappop(A))                    \\n                break\\n            else:\\n                heapq.heappush(A,-1*heapq.heappop(A))                      \\n            K -= 1\\n        return sum(A)\\n```\\nTime Complexity   :   O(N+KLogN)\\nSpace Complexity  :  O(1)",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq \\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        while K:\\n            if A[0] >= 0:\\n                if K & 1:\\n                    heapq.heappush(A,-1*heapq.heappop(A))                    \\n                break\\n            else:\\n                heapq.heappush(A,-1*heapq.heappop(A))                      \\n            K -= 1\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429423,
                "title": "java-greedy-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] A, int K) {\\n\\t\\t\\tQueue<Integer> q = new PriorityQueue<>();\\n\\t\\t\\tfor(int a:A) q.add(a);\\n\\t\\t\\twhile(K>0){\\n\\t\\t\\t\\tq.add(-q.poll());\\n\\t\\t\\t\\tK--;\\n\\t\\t\\t}\\n\\t\\t\\tint res = 0;\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tres += q.poll();\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] A, int K) {\\n\\t\\t\\tQueue<Integer> q = new PriorityQueue<>();\\n\\t\\t\\tfor(int a:A) q.add(a);\\n\\t\\t\\twhile(K>0){\\n\\t\\t\\t\\tq.add(-q.poll());\\n\\t\\t\\t\\tK--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 424914,
                "title": "simple-heap-solution",
                "content": "```\\ndef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\th = heapq.heapify(A)\\n\\tfor _ in range(K):\\n\\t\\tm = heapq.heappop(A)\\n\\t\\theapq.heappush(A, -m)\\n\\treturn sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\th = heapq.heapify(A)\\n\\tfor _ in range(K):\\n\\t\\tm = heapq.heappop(A)\\n\\t\\theapq.heappush(A, -m)\\n\\treturn sum(A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 383851,
                "title": "java-solution-2ms-87-faster-with-comments",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int k) {\\n        /*\\n            Greedy\\n        */\\n        \\n        // first sort the array\\n        Arrays.sort(A);\\n        \\n        /*\\n            keep fliping the negative values in the array, until \\n                there is no more negative values or\\n                k reaches zero or\\n                we are at the end of the array\\n        */\\n        int index = 0;\\n        for (; index < A.length; ++index) {\\n            if (k > 0 && A[index] < 0) {\\n                k--;\\n                A[index] = -A[index];\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        /*\\n            at this stage, if k is even, we just skip this step and calculate the sum\\n            if k is odd, \\n                if index is zero, which means whole array are all positive numbers at the begining, we simply flip the first value\\n                if index >= A.length, we are at the end of the array, flip the last value in the array\\n                if A[index] >= A[index - 1], we are at middle of the array, and we want to flip the smallest value in the array\\n                which is either A[index], or A[index - 1], so we compare them and flip the smaller one\\n        */\\n        if (k % 2 != 0) {\\n            if (index == 0) A[index] = -A[index]; \\n            else if (index >= A.length || A[index] >= A[index - 1]) A[index - 1] = -A[index - 1];\\n            else A[index] = -A[index];\\n        }\\n        \\n        int sum = 0;\\n        for (int i : A) {\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int k) {\\n        /*\\n            Greedy\\n        */\\n        \\n        // first sort the array\\n        Arrays.sort(A);\\n        \\n        /*\\n            keep fliping the negative values in the array, until \\n                there is no more negative values or\\n                k reaches zero or\\n                we are at the end of the array\\n        */\\n        int index = 0;\\n        for (; index < A.length; ++index) {\\n            if (k > 0 && A[index] < 0) {\\n                k--;\\n                A[index] = -A[index];\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        /*\\n            at this stage, if k is even, we just skip this step and calculate the sum\\n            if k is odd, \\n                if index is zero, which means whole array are all positive numbers at the begining, we simply flip the first value\\n                if index >= A.length, we are at the end of the array, flip the last value in the array\\n                if A[index] >= A[index - 1], we are at middle of the array, and we want to flip the smallest value in the array\\n                which is either A[index], or A[index - 1], so we compare them and flip the smaller one\\n        */\\n        if (k % 2 != 0) {\\n            if (index == 0) A[index] = -A[index]; \\n            else if (index >= A.length || A[index] >= A[index - 1]) A[index - 1] = -A[index - 1];\\n            else A[index] = -A[index];\\n        }\\n        \\n        int sum = 0;\\n        for (int i : A) {\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1714633,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1929395,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1835017,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1752530,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 2028770,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1941381,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1876946,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1828596,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1724874,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1699153,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1714633,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1929395,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1835017,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1752530,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 2028770,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1941381,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1876946,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1828596,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1724874,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1699153,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Two Non-overlapping Sub-arrays Each With Target Sum",
        "question_content": "<p>You are given an array of integers <code>arr</code> and an integer <code>target</code>.</p>\n\n<p>You have to find <strong>two non-overlapping sub-arrays</strong> of <code>arr</code> each with a sum equal <code>target</code>. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is <strong>minimum</strong>.</p>\n\n<p>Return <em>the minimum sum of the lengths</em> of the two required sub-arrays, or return <code>-1</code> if you cannot find such two sub-arrays.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [3,2,2,4,3], target = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [7,3,4,7], target = 7\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [4,3,2,6,2,3,4], target = 6\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> We have only one sub-array of sum = 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= target &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 685486,
                "title": "java-o-n-time-two-pass-solution-using-hashmap",
                "content": "Concept: First traverse through the array once and store the (key,value) pair as (sum(arr[0:i+1]),i) for 0<=i<size of arr. Put, (0,-1) in hashmap as default. Now traverse through the array again, and for every i, find the minimum value of length of sub-array on the left or starting with i whose value is equal to target. Find another sub-array starting with i+1, whose sum is target. Update the result with the minimum value of the sum of both the sub-array. This is possible because all values are positive and the value of sum is strictly increasing.\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        HashMap<Integer,Integer> hmap=new HashMap<>();\\n        int sum=0,lsize=Integer.MAX_VALUE,result=Integer.MAX_VALUE;\\n        hmap.put(0,-1);\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            hmap.put(sum,i); // stores key as sum upto index i, and value as i.\\n        }\\n        sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            if(hmap.get(sum-target)!=null){\\n                lsize=Math.min(lsize,i-hmap.get(sum-target));      // stores minimum length of sub-array ending with index<= i with sum target. This ensures non- overlapping property.\\n            }\\n\\t\\t\\t//hmap.get(sum+target) searches for any sub-array starting with index i+1 with sum target.\\n            if(hmap.get(sum+target)!=null&&lsize<Integer.MAX_VALUE){\\n                result=Math.min(result,hmap.get(sum+target)-i+lsize); // updates the result only if both left and right sub-array exists.\\n            }\\n        }\\n        return result==Integer.MAX_VALUE?-1:result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        HashMap<Integer,Integer> hmap=new HashMap<>();\\n        int sum=0,lsize=Integer.MAX_VALUE,result=Integer.MAX_VALUE;\\n        hmap.put(0,-1);\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            hmap.put(sum,i); // stores key as sum upto index i, and value as i.\\n        }\\n        sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            if(hmap.get(sum-target)!=null){\\n                lsize=Math.min(lsize,i-hmap.get(sum-target));      // stores minimum length of sub-array ending with index<= i with sum target. This ensures non- overlapping property.\\n            }\\n\\t\\t\\t//hmap.get(sum+target) searches for any sub-array starting with index i+1 with sum target.\\n            if(hmap.get(sum+target)!=null&&lsize<Integer.MAX_VALUE){\\n                result=Math.min(result,hmap.get(sum+target)-i+lsize); // updates the result only if both left and right sub-array exists.\\n            }\\n        }\\n        return result==Integer.MAX_VALUE?-1:result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686105,
                "title": "java-sliding-window-with-only-one-array-no-hasmap",
                "content": "I see, mot of the people confused this with 560. `Subarray Sum Equals K` off course that would give correct answer, no doubt about that. But I think we can leverage the constraint here, which says `a[i] >= 1` due to this constraint we don\\'t need a `HashMap` here. Problem can be solved by vanilla sliding window.\\n\\n ```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int best[] = new int[n];\\n        Arrays.fill(best, Integer.MAX_VALUE);\\n        int sum = 0, start = 0, ans = Integer.MAX_VALUE, bestSoFar = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target){\\n                sum -= arr[start];\\n                start++;\\n            }\\n            if(sum == target){\\n                if(start > 0 && best[start - 1] != Integer.MAX_VALUE){\\n                    ans = min(ans, best[start - 1] + i - start + 1);\\n                }\\n                bestSoFar = min(bestSoFar, i - start + 1);\\n            }\\n            best[i] = bestSoFar;\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int best[] = new int[n];\\n        Arrays.fill(best, Integer.MAX_VALUE);\\n        int sum = 0, start = 0, ans = Integer.MAX_VALUE, bestSoFar = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target){\\n                sum -= arr[start];\\n                start++;\\n            }\\n            if(sum == target){\\n                if(start > 0 && best[start - 1] != Integer.MAX_VALUE){\\n                    ans = min(ans, best[start - 1] + i - start + 1);\\n                }\\n                bestSoFar = min(bestSoFar, i - start + 1);\\n            }\\n            best[i] = bestSoFar;\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685470,
                "title": "python-one-pass-prefix-sum-o-n",
                "content": "Keep track of the running prefix-sum and the length of the shortest sub-array that sums to the target up to that point (`best_till` in my solution).\\nEach time we find another such sub-array, look up that length value at the index right before it starts.\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = {0: -1}\\n        best_till = [math.inf] * len(arr)\\n        ans = best = math.inf\\n        for i, curr in enumerate(itertools.accumulate(arr)):\\n            if curr - target in prefix:\\n                end = prefix[curr - target]\\n                if end > -1:\\n                    ans = min(ans, i - end + best_till[end])\\n                best = min(best, i - end)\\n            best_till[i] = best\\n            prefix[curr] = i\\n        return -1 if ans == math.inf else ans\\n```\\nIn the contest I misread sub-array as subsequence so ran out of time \\uD83D\\uDE22",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = {0: -1}\\n        best_till = [math.inf] * len(arr)\\n        ans = best = math.inf\\n        for i, curr in enumerate(itertools.accumulate(arr)):\\n            if curr - target in prefix:\\n                end = prefix[curr - target]\\n                if end > -1:\\n                    ans = min(ans, i - end + best_till[end])\\n                best = min(best, i - end)\\n            best_till[i] = best\\n            prefix[curr] = i\\n        return -1 if ans == math.inf else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688689,
                "title": "c-general-dp-solution-n-non-overlapping-sub-arrays",
                "content": "What if the problem changes to find **N** Non-overlapping Sub-arrays Each With Target Sum, **instead of two**?\\n\\nI would like to provide a more **General** solution here:\\n\\nDenote `dp[i][j]` as: \\nWe are only using `arr[1,2,...,i]`, and we have found `j` non-overlapping sub-arrays with target sum. The value of `dp[i][j`] is the minimum sum of the lengths of the sub-arrays.\\n\\nThen we have the equation:\\n```\\ndp[i][j] = min(dp[i-1][j], dp[d][j-1] + i - d)\\n```\\n\\nExplanation:\\n1. `dp[i][j] <= dp[i-1][j]`: \\nThis is because, we are considering more elements than before, hence the result can only be better (the length is smaller).\\n2. `dp[d][j-1] + i - d`: \\nThe `d` here is the index satisfying `sum(arr[i-d+1,...,i]) = target`. This sub-array has length = `i-d`.\\nTo ensure the sub-arrays don\\'t overlap, the rest of the sub-arrays must use index `<= d`, hence this is why we use `dp[d][j-1]` here.\\nTo quickly find such `d`, use a unordered_map to keep track of the prefix sum.\\n\\nIn the code:\\nNotice that we are using index from 1 to n, hence we can easily use index 0 to prevent extra checking.\\nAlso notice that we are initializing `dp[i][0] = 0`, because if we can\\'t find any subarray, the sum of length must be 0.\\n\\nThen, the answer is given by` dp[n][j]`. In this problem,` j = 2`.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100005][3];  //if asking for n subarrays, change 3 to n+1\\n    unordered_map<int,int> sm;  // keep track of (prefixsum : index)  \\n    \\n    int minSumOfLengths(vector<int>& arr, int tar) {\\n        int n = arr.size(), cursum = 0;\\n        sm[0] = 0;\\n        memset(dp, 127, sizeof(dp));  //initialize to INF\\n        for (int i = 0; i < 100005; i++) dp[i][0] = 0;  //if we doesn\\'t find a subarray, len = 0\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int d = -1;  //initialize to -1\\n            cursum += arr[i-1];\\n            sm[cursum] = i;\\n            if (sm.count(cursum - tar)) d = sm[cursum-tar];\\n            \\n            for (int j = 1; j <= 2; j++) {  // if asking for n subarrays, change 2 to n\\n                dp[i][j] = min(dp[i][j], dp[i-1][j]);  //dp[i][j] must <= dp[i-1][j]\\n                if (d != -1) dp[i][j] = min(dp[i][j],dp[d][j-1] + i - d);\\n            }\\n        }\\n        if (dp[n][2] > 1e9) return -1;   // if asking for n subarrays, change 2 to n\\n        return dp[n][2];   // if asking for n subarrays, change 2 to n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][j] = min(dp[i-1][j], dp[d][j-1] + i - d)\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100005][3];  //if asking for n subarrays, change 3 to n+1\\n    unordered_map<int,int> sm;  // keep track of (prefixsum : index)  \\n    \\n    int minSumOfLengths(vector<int>& arr, int tar) {\\n        int n = arr.size(), cursum = 0;\\n        sm[0] = 0;\\n        memset(dp, 127, sizeof(dp));  //initialize to INF\\n        for (int i = 0; i < 100005; i++) dp[i][0] = 0;  //if we doesn\\'t find a subarray, len = 0\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int d = -1;  //initialize to -1\\n            cursum += arr[i-1];\\n            sm[cursum] = i;\\n            if (sm.count(cursum - tar)) d = sm[cursum-tar];\\n            \\n            for (int j = 1; j <= 2; j++) {  // if asking for n subarrays, change 2 to n\\n                dp[i][j] = min(dp[i][j], dp[i-1][j]);  //dp[i][j] must <= dp[i-1][j]\\n                if (d != -1) dp[i][j] = min(dp[i][j],dp[d][j-1] + i - d);\\n            }\\n        }\\n        if (dp[n][2] > 1e9) return -1;   // if asking for n subarrays, change 2 to n\\n        return dp[n][2];   // if asking for n subarrays, change 2 to n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685600,
                "title": "python-similar-to-buy-and-sell-stock-3-simple-dp-solution-logic-and-intuition-explained",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##        \\n\\t\\t## Similar to Leetcode: 123 Best Time To Buy And Sell Stock III ##\\n        ## LOGIC ##\\n        ## 1. Like typical subarray sum problem, calculate the valid subarray lengths at that particular index using running/prefix sum\\n        ## 2. dp will have the minimum subarray length with sum = target found till that index.\\n        ## 3. now reverse the array and compute the same. (we now have both dp_left and dp_right)\\n        ## 4. As there should not be any overlaps, we consider minimum found till index - 1 in left side and minimum found from this current index till end on right side. Compute the sum and store in ans.\\n\\t\\t\\n\\t\\t## INTUITION ## (How did I get to know that I have to use dp_left and dp_ right ?)\\n\\t\\t## As we are finding only 2 best cases, if we consider any particular index, one best case can be to its left side , othe best case can be to its right side ##\\n        \\n\\t\\t## TIME COMPLEXICITY : O(3xN) ##\\n\\t\\t## SPACE COMPLEXICITY : O(N) ##\\n        \\n        def get_sub_arrays( arr ):\\n            lookup = collections.defaultdict(int)\\n            running_sum = 0\\n            dp = [float(\\'inf\\')] * len(arr)\\n            \\n            for i, num in enumerate(arr):\\n                running_sum += num\\n                if running_sum == target:\\n                    dp[i] = i - 0 + 1\\n                elif running_sum - target in lookup:\\n                    dp[i] = i - lookup[running_sum - target] + 1\\n                lookup[running_sum] = i+1\\n                dp[i] = min( dp[i-1], dp[i] )\\n            return dp\\n        \\n        dp_left = get_sub_arrays( arr )                     # from front\\n        dp_right = get_sub_arrays( arr[::-1] )[::-1]        # from backwards\\n        \\n        ans = float(\\'inf\\')\\n        for i in range( 1, len(arr) ):\\n            ans = min( ans, dp_left[i-1] + dp_right[i] )\\n        return ans if( ans != float(\\'inf\\') ) else -1\\n```\\nUPVOTE IF YOU LIKE MY SOLUTION.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##        \\n\\t\\t## Similar to Leetcode: 123 Best Time To Buy And Sell Stock III ##\\n        ## LOGIC ##\\n        ## 1. Like typical subarray sum problem, calculate the valid subarray lengths at that particular index using running/prefix sum\\n        ## 2. dp will have the minimum subarray length with sum = target found till that index.\\n        ## 3. now reverse the array and compute the same. (we now have both dp_left and dp_right)\\n        ## 4. As there should not be any overlaps, we consider minimum found till index - 1 in left side and minimum found from this current index till end on right side. Compute the sum and store in ans.\\n\\t\\t\\n\\t\\t## INTUITION ## (How did I get to know that I have to use dp_left and dp_ right ?)\\n\\t\\t## As we are finding only 2 best cases, if we consider any particular index, one best case can be to its left side , othe best case can be to its right side ##\\n        \\n\\t\\t## TIME COMPLEXICITY : O(3xN) ##\\n\\t\\t## SPACE COMPLEXICITY : O(N) ##\\n        \\n        def get_sub_arrays( arr ):\\n            lookup = collections.defaultdict(int)\\n            running_sum = 0\\n            dp = [float(\\'inf\\')] * len(arr)\\n            \\n            for i, num in enumerate(arr):\\n                running_sum += num\\n                if running_sum == target:\\n                    dp[i] = i - 0 + 1\\n                elif running_sum - target in lookup:\\n                    dp[i] = i - lookup[running_sum - target] + 1\\n                lookup[running_sum] = i+1\\n                dp[i] = min( dp[i-1], dp[i] )\\n            return dp\\n        \\n        dp_left = get_sub_arrays( arr )                     # from front\\n        dp_right = get_sub_arrays( arr[::-1] )[::-1]        # from backwards\\n        \\n        ans = float(\\'inf\\')\\n        for i in range( 1, len(arr) ):\\n            ans = min( ans, dp_left[i-1] + dp_right[i] )\\n        return ans if( ans != float(\\'inf\\') ) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685463,
                "title": "c-o-n-solution-by-prefix-sum-and-dp",
                "content": "1. precalculate at each position, i, the min length of array with target sum from left and from right respectively. \\n\\ta. fromLeft[i]: from the leftmost to position, i, ```(i.e. [0 .. i])```, the min length of the array with target sum\\n\\tb. fromRight[i]: from the rightmost to position, i, ```(i.e. [i .. n-1])```, the min length of the array with target sum\\n2. use DP to find the min sum of length at each pisition, i. ```(i.e. , dp[i] = fromLeft[i] + fromRight[i+1])```\\n\\ta. consider the minimal sum of two arrays\\' length at each index, i. ```(i.e. min sum of length at index i = min length in the range of [0 .. i] + min length in the range of [i+1 .. n-1])```\\n\\tb. reverse the given array and apply the same subfunction to simply the code.  \\n3. complexity \\n\\ta. Time complexity : O(N)\\n\\tb. Space complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        // from the left, min length of array with sum = target\\n        vector<int> left = minLen(arr, target);\\n\\n        // from the right, min length of array with sum = target\\n        vector<int> arrReverse(arr.begin(), arr.end());\\n        reverse(arrReverse.begin(), arrReverse.end());\\n        vector<int> right = minLen(arrReverse, target);\\n        \\n        // consider each position to find the min sum of length of the two array with target sum\\n        int min_val = arr.size() + 1;\\n        int n = arr.size();\\n        for(int i = 0; i < arr.size() - 1; ++i) {\\n            min_val = min(min_val, left[i] + right[n-1-i-1]);\\n        }\\n        return min_val == arr.size() + 1 ? -1 : min_val;\\n    }\\n    \\n    // at each position, i, find the min length of array with target sum \\n    vector<int> minLen(vector<int> &arr, int target) {\\n        int n = arr.size();\\n        vector<int> presum(n, 0);\\n        unordered_map<int, int> idx;\\n        vector<int> ans(n, n + 1);\\n        idx[0] = -1;\\n        for(int i = 0; i < arr.size(); ++i) {\\n            presum[i] = i == 0 ? arr[i] : arr[i] + presum[i-1];\\n            int len = arr.size() + 1;\\n            if(idx.find(presum[i] - target) != idx.end()) {\\n                len = i - idx[presum[i]-target];\\n            }\\n            idx[presum[i]] = i;\\n            ans[i] = i == 0 ? len : min(ans[i-1], len);    \\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```(i.e. [0 .. i])```\n```(i.e. [i .. n-1])```\n```(i.e. , dp[i] = fromLeft[i] + fromRight[i+1])```\n```(i.e. min sum of length at index i = min length in the range of [0 .. i] + min length in the range of [i+1 .. n-1])```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        // from the left, min length of array with sum = target\\n        vector<int> left = minLen(arr, target);\\n\\n        // from the right, min length of array with sum = target\\n        vector<int> arrReverse(arr.begin(), arr.end());\\n        reverse(arrReverse.begin(), arrReverse.end());\\n        vector<int> right = minLen(arrReverse, target);\\n        \\n        // consider each position to find the min sum of length of the two array with target sum\\n        int min_val = arr.size() + 1;\\n        int n = arr.size();\\n        for(int i = 0; i < arr.size() - 1; ++i) {\\n            min_val = min(min_val, left[i] + right[n-1-i-1]);\\n        }\\n        return min_val == arr.size() + 1 ? -1 : min_val;\\n    }\\n    \\n    // at each position, i, find the min length of array with target sum \\n    vector<int> minLen(vector<int> &arr, int target) {\\n        int n = arr.size();\\n        vector<int> presum(n, 0);\\n        unordered_map<int, int> idx;\\n        vector<int> ans(n, n + 1);\\n        idx[0] = -1;\\n        for(int i = 0; i < arr.size(); ++i) {\\n            presum[i] = i == 0 ? arr[i] : arr[i] + presum[i-1];\\n            int len = arr.size() + 1;\\n            if(idx.find(presum[i] - target) != idx.end()) {\\n                len = i - idx[presum[i]-target];\\n            }\\n            idx[presum[i]] = i;\\n            ans[i] = i == 0 ? len : min(ans[i-1], len);    \\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775374,
                "title": "python-o-n-sliding-window-with-comments",
                "content": "```py\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        INF = len(arr) + 1\\n        best_at_i = [INF]*len(arr) # the ith index represents the smallest length subarray we\\'ve found ending <= i that sums to target\\n        best = INF # output \\n        curr_sum = 0 # current sum between left and right\\n        \\n        left = 0\\n        for right in range(len(arr)):\\n            # update the running sum\\n            curr_sum += arr[right]\\n            \\n            # arr is strictly positive, so shrink window until we\\'re not above target\\n            while curr_sum > target and left <= right:\\n                curr_sum -= arr[left]\\n                left += 1\\n                \\n            if curr_sum == target:\\n                # we have a new shortest candidate to consider\\n                best = min(best, best_at_i[left-1] + right - left + 1)\\n                best_at_i[right] = min(best_at_i[right-1], right - left + 1)\\n            else:\\n                # best we\\'ve seen is the previous best (overlaps to end if right == 0)\\n                best_at_i[right] = best_at_i[right-1]\\n        \\n        if best == INF:\\n            return -1\\n        return best\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```py\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        INF = len(arr) + 1\\n        best_at_i = [INF]*len(arr) # the ith index represents the smallest length subarray we\\'ve found ending <= i that sums to target\\n        best = INF # output \\n        curr_sum = 0 # current sum between left and right\\n        \\n        left = 0\\n        for right in range(len(arr)):\\n            # update the running sum\\n            curr_sum += arr[right]\\n            \\n            # arr is strictly positive, so shrink window until we\\'re not above target\\n            while curr_sum > target and left <= right:\\n                curr_sum -= arr[left]\\n                left += 1\\n                \\n            if curr_sum == target:\\n                # we have a new shortest candidate to consider\\n                best = min(best, best_at_i[left-1] + right - left + 1)\\n                best_at_i[right] = min(best_at_i[right-1], right - left + 1)\\n            else:\\n                # best we\\'ve seen is the previous best (overlaps to end if right == 0)\\n                best_at_i[right] = best_at_i[right-1]\\n        \\n        if best == INF:\\n            return -1\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685548,
                "title": "java-sliding-window-with-dp-o-n-20-lines",
                "content": "This problem is similar to [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/discuss/?currentPage=1&orderBy=most_votes&query=)\\n\\nLike `Subarray Sum Equals K` we use `HashMap` to remember the prefix sum, here we choose `sum - target` as our key and `index` as value, so `length = i - map.get(sum - target)`. In case the first x element\\'s sum equals `target` we should put `(0 , -1)` first.\\n\\nSince we need to calculate the length of two sub-arrays, we can use dp to memorize the minimum length of previous subarray.\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        map.put(0, -1);\\n        int[] min = new int[arr.length];\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            min[i] = i > 0? min[i - 1] : Integer.MAX_VALUE;\\n            if (map.containsKey(sum - target)) {\\n                int pre = map.get(sum - target);\\n                min[i] = Math.min(min[i], i - pre);\\n\\t\\t\\t\\t// if pre equals -1 means we only get one sub-array whoes sum eqauls target\\n                if (pre != -1 && min[pre] != Integer.MAX_VALUE) {\\n                    res = Math.min(res, min[pre] + i - pre);\\n                }\\n            }\\n            map.put(sum, i);\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        map.put(0, -1);\\n        int[] min = new int[arr.length];\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            min[i] = i > 0? min[i - 1] : Integer.MAX_VALUE;\\n            if (map.containsKey(sum - target)) {\\n                int pre = map.get(sum - target);\\n                min[i] = Math.min(min[i], i - pre);\\n\\t\\t\\t\\t// if pre equals -1 means we only get one sub-array whoes sum eqauls target\\n                if (pre != -1 && min[pre] != Integer.MAX_VALUE) {\\n                    res = Math.min(res, min[pre] + i - pre);\\n                }\\n            }\\n            map.put(sum, i);\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743967,
                "title": "c-sliding-window-dp-o-n",
                "content": "Let us assume that dp[i] stores the length of the previous shortest subarray whose sum=target before index i. Now suppose after index i, we encounter another subarray of some length l at index r whose sum is also equal to target, then our ans would be the current length, l+dp[r-l] since l length from index r would be used and if there is any subarray whose sum equals target before index (r-l) then we can add that to our ans and that would be some feasible ans and then we take take the minimum of all these feasible answers to find the optimum value.\\n\\nWe can also guarantee that there would be atleast two such arrays if ans!=INT_MAX by checking if dp[r-l] contains some valid value otherwise this is the first subarray with target sum.\\n\\nHere is the code:\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int l=0,r=0,csum=0,ans=INT_MAX;\\n        vector<int> dp(arr.size(),INT_MAX);\\n        for(;r<arr.size();r++){\\n            csum+=arr[r];\\n            while(csum>target)\\n                csum-=arr[l++];\\n            if(csum==target){\\n                dp[r]=r-l+1;\\n                if(l-1>=0 && dp[l-1]!=INT_MAX)\\n                    ans=min(ans,dp[r]+dp[l-1]);\\n            }\\n            if(r-1>=0)\\n                dp[r]=min(dp[r-1],dp[r]);\\n        }\\n        \\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int l=0,r=0,csum=0,ans=INT_MAX;\\n        vector<int> dp(arr.size(),INT_MAX);\\n        for(;r<arr.size();r++){\\n            csum+=arr[r];\\n            while(csum>target)\\n                csum-=arr[l++];\\n            if(csum==target){\\n                dp[r]=r-l+1;\\n                if(l-1>=0 && dp[l-1]!=INT_MAX)\\n                    ans=min(ans,dp[r]+dp[l-1]);\\n            }\\n            if(r-1>=0)\\n                dp[r]=min(dp[r-1],dp[r]);\\n        }\\n        \\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000782,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int sum = 0, n = arr.size(), ans = INT_MAX, len = INT_MAX;\\n        vector<int> min_len(n, INT_MAX);\\n        int start = 0;\\n        for (int end = 0; end < n; end++) {\\n            sum += arr[end];\\n            //shrink the window\\n            while (sum > target) {\\n                sum -= arr[start];\\n                start++;\\n            }\\n            if (sum == target) {\\n                //update the min_len\\n                int curLen = end - start + 1;\\n                if (start > 0 && min_len[start-1] != INT_MAX) {\\n                    ans = min(ans, curLen + min_len[start-1]);\\n                }\\n                len = min(curLen, len); \\n            }\\n            min_len[end] = len;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int sum = 0, n = arr.size(), ans = INT_MAX, len = INT_MAX;\\n        vector<int> min_len(n, INT_MAX);\\n        int start = 0;\\n        for (int end = 0; end < n; end++) {\\n            sum += arr[end];\\n            //shrink the window\\n            while (sum > target) {\\n                sum -= arr[start];\\n                start++;\\n            }\\n            if (sum == target) {\\n                //update the min_len\\n                int curLen = end - start + 1;\\n                if (start > 0 && min_len[start-1] != INT_MAX) {\\n                    ans = min(ans, curLen + min_len[start-1]);\\n                }\\n                len = min(curLen, len); \\n            }\\n            min_len[end] = len;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686648,
                "title": "c-prefix-sum-hash-two-pass",
                "content": "Based on C++ version of @pramitb\\'s JAVA solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        unordered_map<int, int>hm;\\n        hm[0] = -1;\\n        int sum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            hm[sum] = i;\\n        }\\n        \\n        sum = 0;\\n        int msize = INT_MAX, res = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            \\n            if (hm.find(sum-target) != hm.end())\\n                msize = min(msize, i-hm[sum-target]);\\n            \\n            if (hm.find(sum+target) != hm.end() && msize != INT_MAX)\\n                res = min(res, msize + hm[sum+target]-i);\\n        }\\n        \\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        unordered_map<int, int>hm;\\n        hm[0] = -1;\\n        int sum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            hm[sum] = i;\\n        }\\n        \\n        sum = 0;\\n        int msize = INT_MAX, res = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            \\n            if (hm.find(sum-target) != hm.end())\\n                msize = min(msize, i-hm[sum-target]);\\n            \\n            if (hm.find(sum+target) != hm.end() && msize != INT_MAX)\\n                res = min(res, msize + hm[sum+target]-i);\\n        }\\n        \\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687163,
                "title": "java-prefix-suffix-sum",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] left = findMinLengths(0, arr.length, target,arr);\\n        int[] right = findMinLengths(arr.length-1, 0,target,arr);\\n        \\n        for(int i=1;i<arr.length;i++)\\n            left[i] = Math.min(left[i],left[i-1]);\\n        \\n        for(int i=arr.length-2;i>=0;i--)\\n            right[i] = Math.min(right[i],right[i+1]);\\n        \\n        int min = arr.length+1;\\n        \\n        for(int i=0;i<arr.length-1;i++)\\n            min = Math.min(min,left[i] + right[i+1]);\\n        \\n        return min == arr.length+1 ? -1 : min;\\n    }\\n    \\n    private int[] findMinLengths(int start,int end,int target,int[] arr){\\n        int[] ans = new int[arr.length];\\n        \\n        Arrays.fill(ans,arr.length);\\n        \\n        int i = start,j = start;\\n        int sum = 0;\\n        \\n        int dir = (int)Math.signum(end-start);\\n        \\n        while(j != end){\\n            sum += arr[j];\\n            \\n            while(sum > target){\\n                sum -= arr[i];\\n                i += dir;\\n            }\\n                \\n            if(sum == target){\\n                ans[j] = Math.abs(i-j)+1;\\n            }\\n            \\n            j+=dir;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] left = findMinLengths(0, arr.length, target,arr);\\n        int[] right = findMinLengths(arr.length-1, 0,target,arr);\\n        \\n        for(int i=1;i<arr.length;i++)\\n            left[i] = Math.min(left[i],left[i-1]);\\n        \\n        for(int i=arr.length-2;i>=0;i--)\\n            right[i] = Math.min(right[i],right[i+1]);\\n        \\n        int min = arr.length+1;\\n        \\n        for(int i=0;i<arr.length-1;i++)\\n            min = Math.min(min,left[i] + right[i+1]);\\n        \\n        return min == arr.length+1 ? -1 : min;\\n    }\\n    \\n    private int[] findMinLengths(int start,int end,int target,int[] arr){\\n        int[] ans = new int[arr.length];\\n        \\n        Arrays.fill(ans,arr.length);\\n        \\n        int i = start,j = start;\\n        int sum = 0;\\n        \\n        int dir = (int)Math.signum(end-start);\\n        \\n        while(j != end){\\n            sum += arr[j];\\n            \\n            while(sum > target){\\n                sum -= arr[i];\\n                i += dir;\\n            }\\n                \\n            if(sum == target){\\n                ans[j] = Math.abs(i-j)+1;\\n            }\\n            \\n            j+=dir;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685354,
                "title": "clean-python-3-o-n-with-sliding-window-fixed",
                "content": "Make a targets list of all possible subarrays with their corresponding length.\\nAnd then find its possible minimun pair by a premin list.\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        i, window, targets = 0, 0, [float(\\'inf\\')] * len(arr)\\n        for j, num in enumerate(arr):\\n            window += num\\n            while window > target:\\n                window -= arr[i]\\n                i += 1\\n            if window == target: targets[j] = j - i + 1\\n        premin, result = [float(\\'inf\\')] * len(arr), float(\\'inf\\')\\n        for i, target in enumerate(targets):\\n            if i - target >= 0: result = min(result, target + premin[i - target])\\n            premin[i] = target if i == 0 else min(target, premin[i - 1])\\n        return result if result < float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        i, window, targets = 0, 0, [float(\\'inf\\')] * len(arr)\\n        for j, num in enumerate(arr):\\n            window += num\\n            while window > target:\\n                window -= arr[i]\\n                i += 1\\n            if window == target: targets[j] = j - i + 1\\n        premin, result = [float(\\'inf\\')] * len(arr), float(\\'inf\\')\\n        for i, target in enumerate(targets):\\n            if i - target >= 0: result = min(result, target + premin[i - target])\\n            premin[i] = target if i == 0 else min(target, premin[i - 1])\\n        return result if result < float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848400,
                "title": "c-easy-to-understand-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int currsum=0;\\n        int st=0;\\n        int len=INT_MAX;\\n        vector<int> dp(arr.size(),INT_MAX);\\n        int anslen=INT_MAX;\\n        int i=0;\\n        while(i<arr.size())\\n        {\\n            currsum+=arr[i];\\n            while(currsum>target)\\n            {\\n                currsum-=arr[st];\\n                st++;\\n            }\\n            if(currsum==target)\\n            {\\n                if(st>0 and dp[st-1]!=INT_MAX)\\n                    len=min(len,dp[st-1]+i-st+1);\\n                anslen=min(anslen,i-st+1);\\n            }\\n            dp[i]=anslen;\\n            i++;\\n        }\\n        return len==INT_MAX?-1:len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int currsum=0;\\n        int st=0;\\n        int len=INT_MAX;\\n        vector<int> dp(arr.size(),INT_MAX);\\n        int anslen=INT_MAX;\\n        int i=0;\\n        while(i<arr.size())\\n        {\\n            currsum+=arr[i];\\n            while(currsum>target)\\n            {\\n                currsum-=arr[st];\\n                st++;\\n            }\\n            if(currsum==target)\\n            {\\n                if(st>0 and dp[st-1]!=INT_MAX)\\n                    len=min(len,dp[st-1]+i-st+1);\\n                anslen=min(anslen,i-st+1);\\n            }\\n            dp[i]=anslen;\\n            i++;\\n        }\\n        return len==INT_MAX?-1:len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237424,
                "title": "c-sliding-widow-easy-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n, INT_MAX);\\n        \\n        int sum = 0;      \\n        int ans = INT_MAX;\\n        int len = INT_MAX;     \\n        int start = 0;\\n        int end = 0;\\n        \\n        for (end = 0; end < n; end++) {\\n            sum += arr[end];\\n            \\n            while (sum > target) {\\n                sum -= arr[start];\\n                start++;\\n            }\\n            \\n            if (sum == target) {\\n                int curLen = end - start + 1;\\n                if (start > 0 && dp[start-1] != INT_MAX) \\n                {\\n                    ans = min(ans, curLen + dp[start-1]); // ans will be the 2 sub-array length or current length + last min length( which is stored in dp)\\n                }\\n                len = min(curLen, len); \\n            }\\n            dp[end] = len;  // dp stores the previous min length\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n, INT_MAX);\\n        \\n        int sum = 0;      \\n        int ans = INT_MAX;\\n        int len = INT_MAX;     \\n        int start = 0;\\n        int end = 0;\\n        \\n        for (end = 0; end < n; end++) {\\n            sum += arr[end];\\n            \\n            while (sum > target) {\\n                sum -= arr[start];\\n                start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 685916,
                "title": "java-one-pass-o-n-the-simplest-solution-with-explanation",
                "content": "This problem can be divided to two small problems: 1) find all subarray whose sum is equal to target; 2) find two subarrays from the former result which are not overlapping and whose total length is minimum.\\n\\nFor subproblem 1), we can use sliding window to find all subarray; basically use two pointers, i, j to scan the arr and check the sum between i and j; \\n\\nFor subproblem 2) we can use an array, e.g. dp to record that for every index i, the shortest length subarray whose sum is equal to target up until index i and including index i itself. \\n\\nNotice subproblem 2) can be solved along with subproblem 1);  Also the final result can solved along the two subproblem, bascially when we find subarray[i, j], notice the previous non-overlapping subarray length will be dp[i-1], so we can update the result with dp[i-1] + (j - i + 1);\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {        \\n        int result = Integer.MAX_VALUE; // the final result\\n        int len = arr.length;\\n        int[] dp = new int[len]; //min subarray length so far until the index\\n        int i = 0, j = 0; // i is left pointer, j is right pointer\\n        int sum = 0;\\n        while(j<len) {\\n            dp[j] = Integer.MAX_VALUE; // initialize the value\\n            sum += arr[j];\\n            while(i<len && sum > target) { // move left pointer if sum is larger than target\\n                sum -= arr[i];\\n                i++;\\n            }\\n            \\n            if(sum == target) {\\n                dp[j] = j - i + 1;  // set the dp value to current subarray\\n                \\n                if(i-1>=0 && dp[i-1] != Integer.MAX_VALUE) // dp[i-1] will the min length of non-overlapping subarray \\n                    result = Math.min(dp[j] + dp[i-1], re); \\n            }\\n            \\n            if(j-1>=0)\\n               dp[j] = Math.min(dp[j], dp[j-1]); // dp[i] represents the shortest length subarray so far\\n            \\n            j++;\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? -1 : result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {        \\n        int result = Integer.MAX_VALUE; // the final result\\n        int len = arr.length;\\n        int[] dp = new int[len]; //min subarray length so far until the index\\n        int i = 0, j = 0; // i is left pointer, j is right pointer\\n        int sum = 0;\\n        while(j<len) {\\n            dp[j] = Integer.MAX_VALUE; // initialize the value\\n            sum += arr[j];\\n            while(i<len && sum > target) { // move left pointer if sum is larger than target\\n                sum -= arr[i];\\n                i++;\\n            }\\n            \\n            if(sum == target) {\\n                dp[j] = j - i + 1;  // set the dp value to current subarray\\n                \\n                if(i-1>=0 && dp[i-1] != Integer.MAX_VALUE) // dp[i-1] will the min length of non-overlapping subarray \\n                    result = Math.min(dp[j] + dp[i-1], re); \\n            }\\n            \\n            if(j-1>=0)\\n               dp[j] = Math.min(dp[j], dp[j-1]); // dp[i] represents the shortest length subarray so far\\n            \\n            j++;\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? -1 : result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685326,
                "title": "o-n-o-n-2-window-sliding-simple-approach-w-video-explanation-of-subarray-sum",
                "content": "**UPDATE** \\nO(N) approach is based on this beautiful solution here,\\nhttps://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/discuss/685486/JAVA-O(N)-Time-Two-Pass-Solution-using-HashMap by @pramitb\\n\\n**O(N^2) Approach**\\n\\n\\nI am using simple approach from the following video, where I have explained how can we find a subarray whose sum is equal to a given target, \\nIn this case I am just storing length of each such subarray, start and end index in a vector. \\nAnd then sort this vector by length, \\n\\n\\nhttps://www.youtube.com/watch?v=1XLTftBtqZs\\n\\n\\n```\\n// using subarray sum equals to target, \\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        map<int, int> _map; // can use unordered_map as well\\n        vector<pair<int, pair<int, int> > > subs;\\n        \\n        _map[0] = -1;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            \\n            if(sum - target >= 0 && _map.find(sum - target) != _map.end()) {\\n                subs.push_back({i - _map[sum-target], {_map[sum - target] + 1, i}});\\n            }\\n            _map[sum] = i;\\n        }\\n        \\n        sort(subs.begin(), subs.end());\\n        if(subs.size() < 2)\\n            return -1;\\n        \\n        \\n        for(int i = 0; i < subs.size() - 1; i++) {\\n            \\n            for(int j = i + 1; j < subs.size(); j++) {\\n                if(subs[i].second.second < subs[j].second.first || subs[i].second.first > subs[j].second.second)\\n                    return subs[i].first + subs[j].first; \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n\\n**O(N)** ( thanks to @pramitb for his solution)\\n\\nBetter approach is that we can compute and store all the prefix sum. And then traverse the array again and restart computing the prefix sum ( i.e  `sum = 0`). And this time for each `i` we also check if there is a subarray whose sum is equals to `sum + target` , if we find such value in map that means there exist a subarray on the right of current whose sum will be equals to `target`. And then we can compare both of them, and store the minimum answer. Check below the code for better understanding.\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        map<int, int> _map;\\n        \\n        _map[0] = -1;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            _map[sum] = i;\\n        }\\n       \\n        sum = 0;\\n        \\n        int ans = INT_MAX;\\n        int min_left = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++){\\n            sum += arr[i];\\n            \\n            if(_map.find(sum - target) != _map.end()){\\n                min_left = min(min_left, i - _map[sum - target]); \\n            }\\n\\t\\t\\t\\n            if( _map.find(sum + target) != _map.end() && min_left < INT_MAX){\\n                ans = min(ans, _map[sum + target] - i + min_left);\\n            }\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n// using subarray sum equals to target, \\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        map<int, int> _map; // can use unordered_map as well\\n        vector<pair<int, pair<int, int> > > subs;\\n        \\n        _map[0] = -1;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            \\n            if(sum - target >= 0 && _map.find(sum - target) != _map.end()) {\\n                subs.push_back({i - _map[sum-target], {_map[sum - target] + 1, i}});\\n            }\\n            _map[sum] = i;\\n        }\\n        \\n        sort(subs.begin(), subs.end());\\n        if(subs.size() < 2)\\n            return -1;\\n        \\n        \\n        for(int i = 0; i < subs.size() - 1; i++) {\\n            \\n            for(int j = i + 1; j < subs.size(); j++) {\\n                if(subs[i].second.second < subs[j].second.first || subs[i].second.first > subs[j].second.second)\\n                    return subs[i].first + subs[j].first; \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        map<int, int> _map;\\n        \\n        _map[0] = -1;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            _map[sum] = i;\\n        }\\n       \\n        sum = 0;\\n        \\n        int ans = INT_MAX;\\n        int min_left = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++){\\n            sum += arr[i];\\n            \\n            if(_map.find(sum - target) != _map.end()){\\n                min_left = min(min_left, i - _map[sum - target]); \\n            }\\n\\t\\t\\t\\n            if( _map.find(sum + target) != _map.end() && min_left < INT_MAX){\\n                ans = min(ans, _map[sum + target] - i + min_left);\\n            }\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685320,
                "title": "java-o-n-12ms",
                "content": "* Storing all the index of sub arrays with sum equals to target using sliding window.\\n* `dp[en] = st`, where st, en represents the start and end of the sub array respectively.\\n* ans = Math.min(ans, length of curr subarray **+** min length of subarray with index < start of curr subarray) => `Math.min(ans, (i - dp[i] + 1) + dp[dp[i]-1])`\\n* Updating dp[i] with min length encountered till index i => `dp[i] = Math.min(dp[i-1], i-dp[i] + 1)`\\n\\n\\n```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int []dp = new int[n+1];\\n        int st = 0;\\n        int en = 0;\\n        int sum = 0;\\n        int ans = Integer.MAX_VALUE;\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        while(en < n){\\n            sum += arr[en];\\n            while(st <= en && sum > target){\\n                sum -= arr[st++];\\n            }\\n            if(sum == target){\\n                dp[en+1] = st+1;\\n            }\\n            en ++;\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(dp[i] != Integer.MAX_VALUE){\\n                if(dp[dp[i]-1] != Integer.MAX_VALUE){\\n                    ans = Math.min(ans, dp[dp[i]-1] + i - dp[i] + 1);\\n                }\\n                dp[i] = Math.min(i-dp[i]+1, dp[i-1]);\\n            }else{\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int []dp = new int[n+1];\\n        int st = 0;\\n        int en = 0;\\n        int sum = 0;\\n        int ans = Integer.MAX_VALUE;\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        while(en < n){\\n            sum += arr[en];\\n            while(st <= en && sum > target){\\n                sum -= arr[st++];\\n            }\\n            if(sum == target){\\n                dp[en+1] = st+1;\\n            }\\n            en ++;\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(dp[i] != Integer.MAX_VALUE){\\n                if(dp[dp[i]-1] != Integer.MAX_VALUE){\\n                    ans = Math.min(ans, dp[dp[i]-1] + i - dp[i] + 1);\\n                }\\n                dp[i] = Math.min(i-dp[i]+1, dp[i-1]);\\n            }else{\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1987219,
                "title": "python-sliding-window-o-n-with-detail-comments",
                "content": "\\n```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        l, windowSum, res = 0, 0, float(\\'inf\\')\\n        min_till = [float(\\'inf\\')] * len(arr) # records smallest lenth of subarry with target sum up till index i.\\n        for r, num in enumerate(arr): # r:right pointer and index of num in arr\\n            windowSum += num\\n            while windowSum > target: \\n\\t\\t\\t# when the sum of current window is larger then target, shrink the left end of the window one by one until windowSum <= target\\n                windowSum -= arr[l]\\n                l += 1\\n\\t\\t\\t# the case when we found a new target sub-array, i.e. current window\\n            if windowSum == target:\\n\\t\\t\\t   # length of current window\\n                curLen = r - l + 1\\n\\t\\t\\t\\t# min_till[l - 1]: the subarray with min len up till the previous position of left end of the current window: \\n\\t\\t\\t\\t# avoid overlap with cur window\\n\\t\\t\\t\\t# new_sum_of_two_subarray = length of current window + the previous min length of target subarray without overlapping\\n\\t\\t\\t\\t# , if < res, update res.\\n                res = min(res, curLen + min_till[l - 1])\\n\\t\\t\\t\\t# Everytime we found a target window, update the min_till of current right end of the window, \\n\\t\\t\\t\\t# for future use when sum up to new length of sum_of_two_subarray and update the res.\\n                min_till[r] = min(curLen, min_till[r - 1])\\n            else:\\n\\t\\t\\t# If windowSum < target: window with current arr[r] as right end does not have any target subarry, \\n\\t\\t\\t# the min_till[r] doesn\\'t get any new minimum update, i.e it equals to previous min_till at index r - 1. \\n                min_till[r] = min_till[r - 1]\\n        return res if res < float(\\'inf\\') else -1\\n\\t\\nTime = O(n): when sliding the window, left and right pointers traverse the array once.\\nSpace = O(n): we use one additional list min_till[] to record min length of target subarray till index i.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "\\n```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        l, windowSum, res = 0, 0, float(\\'inf\\')\\n        min_till = [float(\\'inf\\')] * len(arr) # records smallest lenth of subarry with target sum up till index i.\\n        for r, num in enumerate(arr): # r:right pointer and index of num in arr\\n            windowSum += num\\n            while windowSum > target: \\n\\t\\t\\t# when the sum of current window is larger then target, shrink the left end of the window one by one until windowSum <= target\\n                windowSum -= arr[l]\\n                l += 1\\n\\t\\t\\t# the case when we found a new target sub-array, i.e. current window\\n            if windowSum == target:\\n\\t\\t\\t   # length of current window\\n                curLen = r - l + 1\\n\\t\\t\\t\\t# min_till[l - 1]: the subarray with min len up till the previous position of left end of the current window: \\n\\t\\t\\t\\t# avoid overlap with cur window\\n\\t\\t\\t\\t# new_sum_of_two_subarray = length of current window + the previous min length of target subarray without overlapping\\n\\t\\t\\t\\t# , if < res, update res.\\n                res = min(res, curLen + min_till[l - 1])\\n\\t\\t\\t\\t# Everytime we found a target window, update the min_till of current right end of the window, \\n\\t\\t\\t\\t# for future use when sum up to new length of sum_of_two_subarray and update the res.\\n                min_till[r] = min(curLen, min_till[r - 1])\\n            else:\\n\\t\\t\\t# If windowSum < target: window with current arr[r] as right end does not have any target subarry, \\n\\t\\t\\t# the min_till[r] doesn\\'t get any new minimum update, i.e it equals to previous min_till at index r - 1. \\n                min_till[r] = min_till[r - 1]\\n        return res if res < float(\\'inf\\') else -1\\n\\t\\nTime = O(n): when sliding the window, left and right pointers traverse the array once.\\nSpace = O(n): we use one additional list min_till[] to record min length of target subarray till index i.",
                "codeTag": "Java"
            },
            {
                "id": 1787274,
                "title": "summary-for-3-ways-by-using-prefix-sum-or-sliding-window",
                "content": "prefix sum and iterate twice\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) { //this fits the case when there\\'s negative number, kind like 560\\n        if (arr == null || arr.length == 0) return 0;\\n        Map<Integer, Integer> map = new HashMap<>(); //sum - index\\n        map.put(0, -1);\\n        int sum = 0;\\n        for (int i = 0; i < arr.length; i++) { //record preSum and index\\n            sum += arr[i];\\n            map.put(sum, i);\\n        }\\n        sum = 0;\\n        int size = arr.length + 1, res = arr.length + 1;//note if we set size as MAX_VALUE the line 16 may overflow\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            if (map.containsKey(sum - target)) size = Math.min(size, i - map.get(sum - target)); //find the subarray from the previous index to current one\\n            if (map.containsKey(sum + target)) res = Math.min(res, size + map.get(sum + target) - i); //from the current index to next one, this avoid overlap\\n        }\\n        return res == arr.length + 1 ? -1 : res;\\n    }\\n}\\n```\\n\\nprefix sum just iterate once by using extra array to record previous valid subarray length\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0, n = arr.length, res = n + 1;\\n        map.put(0, -1);\\n        int[] min = new int[n];\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            min[i] = i > 0 ? min[i - 1] : n + 1;\\n            if (map.containsKey(sum - target)) {\\n                int pre = map.get(sum - target);\\n                min[i] = Math.min(min[i], i - pre);\\n\\t\\t\\t\\t// if pre equals -1 means we only get one sub-array whoes sum eqauls target\\n                if (pre != -1 && min[pre] != n + 1) res = Math.min(res, min[pre] + i - pre);\\n            }\\n            map.put(sum, i);\\n        }\\n        return res == n + 1 ? -1 : res;\\n    }\\n}\\n```\\n\\nSliding window without hashmap to iterate once and also use extra array to record previous valid subarray length\\nNote this only works when all elements >= 0\\n```\\nclass Solution { \\n   public int minSumOfLengths(int[] arr, int target) {\\n       if (arr == null || arr.length == 0) return 0;\\n       int n = arr.length;\\n       int[] best = new int[n];\\n       Arrays.fill(best, n + 1);\\n       int sum = 0, start = 0, ans = n + 1, bestSoFar = n + 1;\\n       for(int i = 0; i < n; i++){\\n           sum += arr[i];\\n           while(sum > target) sum -= arr[start++];\\n           if(sum == target){\\n               int cur = i - start + 1;\\n               if(start > 0 && best[start - 1] != n + 1) ans = Math.min(ans, best[start - 1] + cur); //first subarray exists\\n               bestSoFar = Math.min(bestSoFar, cur); //update current one\\n           }\\n           best[i] = bestSoFar;\\n       }\\n       return ans == n + 1 ? -1 : ans;\\n   }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) { //this fits the case when there\\'s negative number, kind like 560\\n        if (arr == null || arr.length == 0) return 0;\\n        Map<Integer, Integer> map = new HashMap<>(); //sum - index\\n        map.put(0, -1);\\n        int sum = 0;\\n        for (int i = 0; i < arr.length; i++) { //record preSum and index\\n            sum += arr[i];\\n            map.put(sum, i);\\n        }\\n        sum = 0;\\n        int size = arr.length + 1, res = arr.length + 1;//note if we set size as MAX_VALUE the line 16 may overflow\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            if (map.containsKey(sum - target)) size = Math.min(size, i - map.get(sum - target)); //find the subarray from the previous index to current one\\n            if (map.containsKey(sum + target)) res = Math.min(res, size + map.get(sum + target) - i); //from the current index to next one, this avoid overlap\\n        }\\n        return res == arr.length + 1 ? -1 : res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0, n = arr.length, res = n + 1;\\n        map.put(0, -1);\\n        int[] min = new int[n];\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            min[i] = i > 0 ? min[i - 1] : n + 1;\\n            if (map.containsKey(sum - target)) {\\n                int pre = map.get(sum - target);\\n                min[i] = Math.min(min[i], i - pre);\\n\\t\\t\\t\\t// if pre equals -1 means we only get one sub-array whoes sum eqauls target\\n                if (pre != -1 && min[pre] != n + 1) res = Math.min(res, min[pre] + i - pre);\\n            }\\n            map.put(sum, i);\\n        }\\n        return res == n + 1 ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948086,
                "title": "python-one-pass",
                "content": "It\\'s standard to find valid intervals with sum equal to `target`. To find the min sum of lengths, we maintain the minimal length of such intervals that don\\'t overlap with current interval, and keep the min of sum when we traverse all possible intervals.\\n```\\n   def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        min_l = math.inf\\n        d = {0: -1}\\n        q = deque()\\n        s = 0\\n        res = math.inf\\n        for right_end, a in enumerate(arr):\\n            s += a\\n            if (s - target) in d:\\n                left_end = d[s - target]\\n\\t\\t        # The current interval is (left_end, right_end], left_end excluded. \\n                cur_l = right_end - left_end\\n\\t\\t\\t\\t# q maintain all previous valid intervals with [right_end, interval_length].\\n                while q and q[0][0] <= left_end:\\n                    min_l = min(min_l, q.popleft()[1])\\n\\t\\t\\t\\t# We can take any interval whose right_end <= current left end, we might as well take the shortest one.\\n                res = min(res, min_l + cur_l)\\n                q.append([i, cur_l])\\n            d[s] = right_end\\n        if res < math.inf:\\n            return res\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\n   def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        min_l = math.inf\\n        d = {0: -1}\\n        q = deque()\\n        s = 0\\n        res = math.inf\\n        for right_end, a in enumerate(arr):\\n            s += a\\n            if (s - target) in d:\\n                left_end = d[s - target]\\n\\t\\t        # The current interval is (left_end, right_end], left_end excluded. \\n                cur_l = right_end - left_end\\n\\t\\t\\t\\t# q maintain all previous valid intervals with [right_end, interval_length].\\n                while q and q[0][0] <= left_end:\\n                    min_l = min(min_l, q.popleft()[1])\\n\\t\\t\\t\\t# We can take any interval whose right_end <= current left end, we might as well take the shortest one.\\n                res = min(res, min_l + cur_l)\\n                q.append([i, cur_l])\\n            d[s] = right_end\\n        if res < math.inf:\\n            return res\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1079426,
                "title": "c-solution-with-detailed-explanation",
                "content": "According to the constraints, we know that values stored in \"arr\" are all positive value.\\nWhich give us 2 preconditions:\\n1. there\\'s no duplicates if we calculate accumulative sum \"Accum\" for all possible value of i. (0 <= i < arr.size())\\n- Accum[i] stores the sum of arr[0] + arr[1] + ... + arr[i] \\n2. \"Accum\" array is in increasing order.\\n\\nWith above preconditions, \\n1. We loop through \"arr\" for the first time and setup a hash table \"tbl\" that store {accum[i], i} as {key, value} pair.\\n2. Loop through \"arr\" again, this time we keep track of current accumulative sum \"sum\". (current index).\\n3. if \"sum - target\" exist in the hash table, which means there\\'s a subarray on the left and ends at index i with length of i - tbl[sum - target].  Update the \"l_len\" to keep track of minimum length of left subarray .\\n- Since \"sum\" and \"target\" are both positive integer and accum[i] is in increasing order, tbl[sum - target] would guarantee to be smaller than i\\n4. if \"sum + target\" exist in the hash table, which means there\\'s a subarray on the right that starts from index i + 1 with length of tbl[sum + target] - i. Update \"ret\" to keep track of minimum sum of two subarray length.\\n\\nNote that Step#3 & #4 would guarantee two subrarry are non-overlapping.\\n\\n\\n```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n        unordered_map<int, int> tbl;\\n        int sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            tbl[sum] = i;\\n        }\\n        int l_len = INT_MAX;\\n        int ret = INT_MAX;\\n        sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            if (tbl.count(sum - target))\\n                l_len = min(l_len, i - tbl[sum - target]);\\n            else if (sum == target)\\n                l_len = min(l_len, tbl[sum] + 1);\\n            if (tbl.count(sum + target) && l_len != INT_MAX)\\n                ret = min(ret, tbl[sum + target] - i + l_len);\\n        }\\n        return (ret == INT_MAX) ? (-1):(ret);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n        unordered_map<int, int> tbl;\\n        int sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            tbl[sum] = i;\\n        }\\n        int l_len = INT_MAX;\\n        int ret = INT_MAX;\\n        sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            if (tbl.count(sum - target))\\n                l_len = min(l_len, i - tbl[sum - target]);\\n            else if (sum == target)\\n                l_len = min(l_len, tbl[sum] + 1);\\n            if (tbl.count(sum + target) && l_len != INT_MAX)\\n                ret = min(ret, tbl[sum + target] - i + l_len);\\n        }\\n        return (ret == INT_MAX) ? (-1):(ret);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807629,
                "title": "how-i-gradually-optimized-c",
                "content": "\\nHOW I APPROACHED AND GRADUALLY OPTIMIZED\\n\\nFIRST (TLE) 53/60 passed\\n\\n1) prefix sum array\\n2) collect all the subarray {start, end} whose sum matches target\\n3) loop through unique pair subarrays N*(N-1)/2\\n4) compare non-overlapping and minimize the sum of their lengths\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        arr.insert(arr.begin(),0);\\n        \\n        for(int i=1;i<=n;i++)\\n            arr[i]+=arr[i-1];\\n        \\n        vector<pair<int,int>> vtr;\\n        for(int i=0;i<n;i++){\\n           for(int j=i;j<n;j++){\\n               int subsum = arr[j+1]-arr[i];\\n               if(subsum==target)\\n                   vtr.push_back({i,j});\\n           }\\n        }\\n\\n        int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\\n\\n\\nSECOND 54/60 (TLE) PASSED\\n\\n1) JUST BREAKING THE LOOP WHEN SUBARRAY SUM IS GREATER THAN THE TARGET\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        arr.insert(arr.begin(),0);\\n        \\n        for(int i=1;i<=n;i++)\\n            arr[i]+=arr[i-1];\\n        \\n\\n        vector<pair<int,int>> vtr;\\n        for(int i=0;i<n;i++){\\n           for(int j=i;j<n;j++){\\n               int subsum = arr[j+1]-arr[i];\\n               if(subsum>target)\\n                   break;\\n               if(subsum==target)\\n                   vtr.push_back({i,j});\\n           }\\n        }\\n     \\n        int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\\n\\nTHIRD 54/60 (TLE) PASSED\\n\\n1) INSTEAD OF PREFIX SUM ARRAY, I USED A HASHMAP TO STORE THE {SUM, ending_array_index}\\n2) WITH THE HELP OF THE MAP COLLECT SUBARRAY INDICES {start, end} WHOSE SUM EQUALS TARGET\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                vtr.push_back({mp[sum-target]+1, i});\\n            }\\n            mp[sum]=i;\\n        }\\n        for(auto x:vtr)\\n            cout<<x.first<<\" \"<<x.second<<endl;\\n        \\n        \\n         int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\\n\\nFOURTH (WRONG) 56/60 PASSED\\n\\n1) TO OPTIMIZE THE SECOND PART, I DO NOT CHECK THAT OVERLAPPING CONDITION\\n2) JUST ADDED THE TWO MEAN SUBARRAY LENGTH AND RETURNED\\n\\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                vtr.push_back({mp[sum-target]+1, i});\\n            }\\n            mp[sum]=i;\\n        }\\n        if(vtr.size()<=1)\\n            return -1;\\n        sort(vtr.begin(), vtr.end(), comp);\\n        return vtr[0].second - vtr[0].first+1+vtr[1].second - vtr[1].first+1;\\n        \\n    }\\n};\\n```\\n\\nFIFTH (WRONG) 57/60 PASSED\\n\\n1) JUST ADDED A OVERLAP CHECKER TWO THE PREVIOUSLY INSERTED SUBARRAY INDICES\\n\\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                if(vtr.size()==0)\\n                    vtr.push_back({mp[sum-target]+1, i});\\n                else{\\n                    if(vtr.back().second<mp[sum-target]+1){\\n                        vtr.push_back({mp[sum-target]+1, i});\\n                    }\\n                }\\n            }\\n            mp[sum]=i;\\n        }\\n        if(vtr.size()<=1)\\n            return -1;\\n        sort(vtr.begin(), vtr.end(), comp);\\n        return vtr[0].second - vtr[0].first+1+vtr[1].second - vtr[1].first+1;\\n       \\n        \\n    }\\n};\\n```\\n\\nSIXTH (CORRECT) ALL PASSED (60/60)\\n\\n1) USED MAP TO STORE {KEY: ARRAY_INDEX -> VAL: PREFIX_SUM}\\n2) FOR EACH INDEX\\n    I SEARCHED IF TARGET SUM SUBARRAYS EXSIST IN THE LEFT OR NOT\\n        IF EXSIST I CONSIDER THE MINIMUM OF THEIR LENGTH\\n    I SEARCHED IF A TARGET SUM SUBARRAY EXSISTS IN ITS JUST RIGHT OR NOT\\n        IF EXSISTS ALONG WITH A VALID LEFT SUBARRAY I CONSIDER THE MINIMUM OF LENGTH SUM OF THE TWO\\n\\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            \\n        }\\n        \\n        int left =INT_MAX/2;\\n        int right=0;\\n        int mini = INT_MAX;\\n        sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                left = min(left,i-mp[sum-target]);\\n            }\\n            if(mp.find(sum+target)!=mp.end()){\\n                right = mp[sum+target]-i;\\n                if(left!=INT_MAX/2)\\n                    mini=min(mini, right+left);\\n            }\\n            \\n        }\\n        if(mini==INT_MAX)\\n            return -1;\\n        return mini;\\n    \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        arr.insert(arr.begin(),0);\\n        \\n        for(int i=1;i<=n;i++)\\n            arr[i]+=arr[i-1];\\n        \\n        vector<pair<int,int>> vtr;\\n        for(int i=0;i<n;i++){\\n           for(int j=i;j<n;j++){\\n               int subsum = arr[j+1]-arr[i];\\n               if(subsum==target)\\n                   vtr.push_back({i,j});\\n           }\\n        }\\n\\n        int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        arr.insert(arr.begin(),0);\\n        \\n        for(int i=1;i<=n;i++)\\n            arr[i]+=arr[i-1];\\n        \\n\\n        vector<pair<int,int>> vtr;\\n        for(int i=0;i<n;i++){\\n           for(int j=i;j<n;j++){\\n               int subsum = arr[j+1]-arr[i];\\n               if(subsum>target)\\n                   break;\\n               if(subsum==target)\\n                   vtr.push_back({i,j});\\n           }\\n        }\\n     \\n        int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                vtr.push_back({mp[sum-target]+1, i});\\n            }\\n            mp[sum]=i;\\n        }\\n        for(auto x:vtr)\\n            cout<<x.first<<\" \"<<x.second<<endl;\\n        \\n        \\n         int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                vtr.push_back({mp[sum-target]+1, i});\\n            }\\n            mp[sum]=i;\\n        }\\n        if(vtr.size()<=1)\\n            return -1;\\n        sort(vtr.begin(), vtr.end(), comp);\\n        return vtr[0].second - vtr[0].first+1+vtr[1].second - vtr[1].first+1;\\n        \\n    }\\n};\\n```\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                if(vtr.size()==0)\\n                    vtr.push_back({mp[sum-target]+1, i});\\n                else{\\n                    if(vtr.back().second<mp[sum-target]+1){\\n                        vtr.push_back({mp[sum-target]+1, i});\\n                    }\\n                }\\n            }\\n            mp[sum]=i;\\n        }\\n        if(vtr.size()<=1)\\n            return -1;\\n        sort(vtr.begin(), vtr.end(), comp);\\n        return vtr[0].second - vtr[0].first+1+vtr[1].second - vtr[1].first+1;\\n       \\n        \\n    }\\n};\\n```\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            \\n        }\\n        \\n        int left =INT_MAX/2;\\n        int right=0;\\n        int mini = INT_MAX;\\n        sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                left = min(left,i-mp[sum-target]);\\n            }\\n            if(mp.find(sum+target)!=mp.end()){\\n                right = mp[sum+target]-i;\\n                if(left!=INT_MAX/2)\\n                    mini=min(mini, right+left);\\n            }\\n            \\n        }\\n        if(mini==INT_MAX)\\n            return -1;\\n        return mini;\\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 685490,
                "title": "c-o-n-sliding-window-find-all-intervals-pick-two-non-overlapping-smallest",
                "content": "**Update**:  We can maintain minimum length so far at each array index so when sum == target, we can look up if there is length encountered which is minimum as well as non-overlapping by checking the value at index `start - 1`\\n\\n```csharp\\npublic int MinSumOfLengths(int[] arr, int target)\\n{\\n\\tint[] minLengths = new int[arr.Length];\\n\\tfor (int i = 0; i < arr.Length; i++)\\n\\t{\\n\\t\\tminLengths[i] = int.MaxValue;\\n\\t}\\n\\n\\tint sum = 0;\\n\\tint start = 0;\\n\\tint result = int.MaxValue;\\n\\tint currentMinLength = int.MaxValue;\\n\\n\\tfor (int end = 0; end < arr.Length; end++)\\n\\t{\\n\\t\\tsum += arr[end];\\n\\n\\t\\twhile (sum > target)\\n\\t\\t{\\n\\t\\t\\tsum -= arr[start];\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tif (sum == target)\\n\\t\\t{\\n\\t\\t\\tint currentLength = end - start + 1;\\n\\n\\t\\t\\tif (start > 0 && minLengths[start - 1] != int.MaxValue)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = Math.Min(result, minLengths[start - 1] + currentLength);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentMinLength = Math.Min(currentMinLength, currentLength);\\n\\t\\t}\\n\\n\\t\\tminLengths[end] = currentMinLength;\\n\\t}\\n\\n\\treturn result == int.MaxValue ? -1 : result;\\n}\\n```\\n\\nBelow is original incorrect solution - min length may not be correct as first pick since for test cases like [1,1,3,2,1,1,1]  - it would pick(3, 2) and block (1,1,3) (2,1,1,1) as lengths to be considered giving no solution.\\n\\n```csharp\\npublic int MinSumOfLengths(int[] arr, int target) \\n{\\n\\tList<(int Start, int End, int Length)> lengths = new List<(int, int, int)>();\\n\\tint sum = 0;\\n\\tint start = 0;\\n\\n\\tfor(int end = 0; end < arr.Length; end++)\\n\\t{\\n\\t\\tsum += arr[end];\\n\\n\\t\\twhile(sum > target && start <= end)\\n\\t\\t{\\n\\t\\t\\tsum -= arr[start];\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tif(sum == target)\\n\\t\\t{\\n\\t\\t\\tlengths.Add((start, end, end - start + 1));\\n\\t\\t}\\n\\t}\\n\\n\\tif(lengths.Count < 2)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tlengths = lengths.OrderBy(x => x.Length).ToList();\\n\\tvar first = lengths[0];\\n\\tforeach(var len in lengths)\\n\\t{\\n\\t\\tif(len.Start > first.End || len.End < first.Start)\\n\\t\\t{\\n\\t\\t\\treturn first.Length + len.Length;\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinSumOfLengths(int[] arr, int target)\\n{\\n\\tint[] minLengths = new int[arr.Length];\\n\\tfor (int i = 0; i < arr.Length; i++)\\n\\t{\\n\\t\\tminLengths[i] = int.MaxValue;\\n\\t}\\n\\n\\tint sum = 0;\\n\\tint start = 0;\\n\\tint result = int.MaxValue;\\n\\tint currentMinLength = int.MaxValue;\\n\\n\\tfor (int end = 0; end < arr.Length; end++)\\n\\t{\\n\\t\\tsum += arr[end];\\n\\n\\t\\twhile (sum > target)\\n\\t\\t{\\n\\t\\t\\tsum -= arr[start];\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tif (sum == target)\\n\\t\\t{\\n\\t\\t\\tint currentLength = end - start + 1;\\n\\n\\t\\t\\tif (start > 0 && minLengths[start - 1] != int.MaxValue)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = Math.Min(result, minLengths[start - 1] + currentLength);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentMinLength = Math.Min(currentMinLength, currentLength);\\n\\t\\t}\\n\\n\\t\\tminLengths[end] = currentMinLength;\\n\\t}\\n\\n\\treturn result == int.MaxValue ? -1 : result;\\n}\\n```\n```csharp\\npublic int MinSumOfLengths(int[] arr, int target) \\n{\\n\\tList<(int Start, int End, int Length)> lengths = new List<(int, int, int)>();\\n\\tint sum = 0;\\n\\tint start = 0;\\n\\n\\tfor(int end = 0; end < arr.Length; end++)\\n\\t{\\n\\t\\tsum += arr[end];\\n\\n\\t\\twhile(sum > target && start <= end)\\n\\t\\t{\\n\\t\\t\\tsum -= arr[start];\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tif(sum == target)\\n\\t\\t{\\n\\t\\t\\tlengths.Add((start, end, end - start + 1));\\n\\t\\t}\\n\\t}\\n\\n\\tif(lengths.Count < 2)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tlengths = lengths.OrderBy(x => x.Length).ToList();\\n\\tvar first = lengths[0];\\n\\tforeach(var len in lengths)\\n\\t{\\n\\t\\tif(len.Start > first.End || len.End < first.Start)\\n\\t\\t{\\n\\t\\t\\treturn first.Length + len.Length;\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685356,
                "title": "google-onsite-question-very-easy-java-o-n-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    private int INF = 1000000;\\n    \\n    public int minSumOfLengths(int[] arr, int target) {\\n        if(arr == null || arr.length == 0 || target <= 0) {\\n            return 0;\\n        }\\n        \\n        int[] left = findLeft(arr, target); // Calculate length of all sub arrays whose sum is target & ends at i, starts at any j >= 0 where j <= i.\\n        int[] right = findLeft(reverse(arr), target); // Do the same thing for right side.\\n        right = reverse(right);\\n        \\n\\t\\t// Now start from the left, for all i, replace left[i] with the best (minimum most) length, we do this so that at any point i, we know the most optimal sub array length from the left. We will use this information after some time.\\n        int minLeft = left[0];\\n        for(int i = 1; i < left.length; i++) {\\n            minLeft = Math.min(minLeft, left[i]);\\n            left[i] = minLeft;\\n        }\\n        \\n        int result = INF;\\n\\t\\t// Now, left[i] already contains most optimal left side sub array length with sum = target from 0 to i.\\n\\t\\t// We will start with right side, make sum of right[i] & left[i-1] since we need to take non-overlapping sub arrays, and compare the sum with result & set the result if necessary.\\n        for(int i = right.length - 1; i > 0; i--) {\\n            if(right[i] + left[i-1] < result) {\\n                result = right[i] + left[i-1];\\n            }\\n        }\\n        \\n        return result < INF ? result : -1;\\n    }\\n    \\n    private int[] reverse(int[] a) {\\n        int[] r = new int[a.length];\\n        int i = 0;\\n        for(; i < a.length; i++) {\\n            r[i] = a[a.length - 1 - i];\\n        }\\n        \\n        return r;\\n    } \\n    \\n    private int[] findLeft(int[] arr, int target) {\\n        int start = 0, i = 0;\\n        int sum = 0;\\n        int[] left = new int[arr.length];\\n        Arrays.fill(left, INF);\\n        \\n        while(i < arr.length) {\\n            sum += arr[i];\\n            \\n            while(sum > target && start <= i) {\\n                sum -= arr[start];\\n                start++;\\n            }\\n            \\n            if(sum == target) {\\n                left[i] = i - start + 1;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int INF = 1000000;\\n    \\n    public int minSumOfLengths(int[] arr, int target) {\\n        if(arr == null || arr.length == 0 || target <= 0) {\\n            return 0;\\n        }\\n        \\n        int[] left = findLeft(arr, target); // Calculate length of all sub arrays whose sum is target & ends at i, starts at any j >= 0 where j <= i.\\n        int[] right = findLeft(reverse(arr), target); // Do the same thing for right side.\\n        right = reverse(right);\\n        \\n\\t\\t// Now start from the left, for all i, replace left[i] with the best (minimum most) length, we do this so that at any point i, we know the most optimal sub array length from the left. We will use this information after some time.\\n        int minLeft = left[0];\\n        for(int i = 1; i < left.length; i++) {\\n            minLeft = Math.min(minLeft, left[i]);\\n            left[i] = minLeft;\\n        }\\n        \\n        int result = INF;\\n\\t\\t// Now, left[i] already contains most optimal left side sub array length with sum = target from 0 to i.\\n\\t\\t// We will start with right side, make sum of right[i] & left[i-1] since we need to take non-overlapping sub arrays, and compare the sum with result & set the result if necessary.\\n        for(int i = right.length - 1; i > 0; i--) {\\n            if(right[i] + left[i-1] < result) {\\n                result = right[i] + left[i-1];\\n            }\\n        }\\n        \\n        return result < INF ? result : -1;\\n    }\\n    \\n    private int[] reverse(int[] a) {\\n        int[] r = new int[a.length];\\n        int i = 0;\\n        for(; i < a.length; i++) {\\n            r[i] = a[a.length - 1 - i];\\n        }\\n        \\n        return r;\\n    } \\n    \\n    private int[] findLeft(int[] arr, int target) {\\n        int start = 0, i = 0;\\n        int sum = 0;\\n        int[] left = new int[arr.length];\\n        Arrays.fill(left, INF);\\n        \\n        while(i < arr.length) {\\n            sum += arr[i];\\n            \\n            while(sum > target && start <= i) {\\n                sum -= arr[start];\\n                start++;\\n            }\\n            \\n            if(sum == target) {\\n                left[i] = i - start + 1;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329637,
                "title": "c-sliding-window-prefix-sum-dp-solution-o-n",
                "content": "Runtime: 108 ms, faster than 76.46% of C++ online submissions for Find Two Non-overlapping Sub-arrays Each With Target Sum.\\nMemory Usage: 77 MB, less than 65.79% of C++ online submissions for Find Two Non-overlapping Sub-arrays Each With Target Sum.\\n\\n```\\nFinding target sum sub-array can be done using Sliding Window and Prefix Sum approach easily. \\nChallenge is tracking the total min length of 2 target sum subarray who has min length and there is where DP is needed. \\nWhat to store in DP so that we can get the min length non-overlapping array while\\nwe find a target subarray 2nd time ? We can store the min length of possible target sum subarray\\nin DP and so we can use that later to calculate total min length 2 target sum subarray when we find\\ntarget sum subarray again where DP[first-1] will return a previous non-overlapping taregt sum subarray min length.\\n```\\n\\n**NOTE: Below sliding window code iteration is index 1 based.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        // track prefix sum of array \\n        vector<int>sum(n+1,0);\\n        \\n        // track the min length target sum subarray till last pointer\\n        vector<int>dp(n+1,INT_MAX);\\n        \\n        sum[0] = 0;\\n        \\n        // first pointer of the window \\n        int first = 1;        \\n        \\n        // result min length sum of 2 target sum sub array\\n        int min_length_sum = INT_MAX;\\n        \\n        // current window length\\n        int curr_len = 0;\\n        \\n        // min length target sum subarray till last pointer\\n        int min_len = INT_MAX;\\n        \\n        // loop through array and check target sum subarray and previous min length target sum subarray\\n        for(int last=1;last<=n;last++)\\n        {\\n            // update prefix sum for current last pointer\\n            sum[last] = sum[last-1] + arr[last-1];\\n            curr_len++;\\n            \\n            // shrink window until window sum <= target \\n            while((sum[last] - sum[first-1]) > target)\\n                first++,curr_len--;\\n            \\n            // check for previous valid target sum subarray of min length if current window sum == target\\n            if((sum[last] - sum[first-1])==target)\\n            {\\n                // if previous target sum subarray exists then update min_length_sum\\n                // if no previous target sum subarray exists then dp[first-2] will be INT_MAX\\n                // dp[first-2] returns min length of target sum subarray which has last < current first\\n                if(first>1 && dp[first-2]!=INT_MAX)\\n                    min_length_sum = min(min_length_sum,(dp[first-2] + curr_len));\\n                \\n                // update min length only any target sum subarray found \\n                min_len = min(min_len,curr_len);                                        \\n            }\\n            \\n            // update DP[last-1] with min_len which stores the min length of possible target sum subrray till last\\n            dp[last-1] = min_len;\\n        }\\n        \\n        // no result found if min_length_sum is INT_MAX\\n        return min_length_sum==INT_MAX?-1 : min_length_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nFinding target sum sub-array can be done using Sliding Window and Prefix Sum approach easily. \\nChallenge is tracking the total min length of 2 target sum subarray who has min length and there is where DP is needed. \\nWhat to store in DP so that we can get the min length non-overlapping array while\\nwe find a target subarray 2nd time ? We can store the min length of possible target sum subarray\\nin DP and so we can use that later to calculate total min length 2 target sum subarray when we find\\ntarget sum subarray again where DP[first-1] will return a previous non-overlapping taregt sum subarray min length.\\n```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        // track prefix sum of array \\n        vector<int>sum(n+1,0);\\n        \\n        // track the min length target sum subarray till last pointer\\n        vector<int>dp(n+1,INT_MAX);\\n        \\n        sum[0] = 0;\\n        \\n        // first pointer of the window \\n        int first = 1;        \\n        \\n        // result min length sum of 2 target sum sub array\\n        int min_length_sum = INT_MAX;\\n        \\n        // current window length\\n        int curr_len = 0;\\n        \\n        // min length target sum subarray till last pointer\\n        int min_len = INT_MAX;\\n        \\n        // loop through array and check target sum subarray and previous min length target sum subarray\\n        for(int last=1;last<=n;last++)\\n        {\\n            // update prefix sum for current last pointer\\n            sum[last] = sum[last-1] + arr[last-1];\\n            curr_len++;\\n            \\n            // shrink window until window sum <= target \\n            while((sum[last] - sum[first-1]) > target)\\n                first++,curr_len--;\\n            \\n            // check for previous valid target sum subarray of min length if current window sum == target\\n            if((sum[last] - sum[first-1])==target)\\n            {\\n                // if previous target sum subarray exists then update min_length_sum\\n                // if no previous target sum subarray exists then dp[first-2] will be INT_MAX\\n                // dp[first-2] returns min length of target sum subarray which has last < current first\\n                if(first>1 && dp[first-2]!=INT_MAX)\\n                    min_length_sum = min(min_length_sum,(dp[first-2] + curr_len));\\n                \\n                // update min length only any target sum subarray found \\n                min_len = min(min_len,curr_len);                                        \\n            }\\n            \\n            // update DP[last-1] with min_len which stores the min length of possible target sum subrray till last\\n            dp[last-1] = min_len;\\n        }\\n        \\n        // no result found if min_length_sum is INT_MAX\\n        return min_length_sum==INT_MAX?-1 : min_length_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305708,
                "title": "java-o-n-time-o-n-space-using-two-pointers",
                "content": "```class Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] minsFound = new int[arr.length + 1];\\n        minsFound[0] = 2 * arr.length;\\n        int minLen = 2 * arr.length;\\n        int twoMinLens = 2 * arr.length;\\n        int sum = 0;\\n        int b = 0;\\n        int e = 0;\\n        while (b < arr.length) {\\n            if (sum == target) {\\n                minLen = Math.min(e - b, minLen);\\n                twoMinLens = Math.min(twoMinLens, e - b + minsFound[b]);\\n            }\\n            if (sum >= target || e == arr.length) {\\n                sum -= arr[b];\\n                b++;\\n            } else {\\n                minsFound[e] = minLen;\\n                sum += arr[e];\\n                e++;\\n            }\\n        }\\n        return twoMinLens < 2 * arr.length ? twoMinLens : -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] minsFound = new int[arr.length + 1];\\n        minsFound[0] = 2 * arr.length;\\n        int minLen = 2 * arr.length;\\n        int twoMinLens = 2 * arr.length;\\n        int sum = 0;\\n        int b = 0;\\n        int e = 0;\\n        while (b < arr.length) {\\n            if (sum == target) {\\n                minLen = Math.min(e - b, minLen);\\n                twoMinLens = Math.min(twoMinLens, e - b + minsFound[b]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 848325,
                "title": "beat-100-and-dp-space-o-n-time-o-n",
                "content": "In fact, we don\\'t need to create all DP cache memory of entire array to store each found length\\nbecause only when the known minimal length of window changes(when we find window sum equals target), \\nwe need to store it into cache.\\nWe can use result to control the minimal sum of the two sub-arrays.\\n\\nThe cache size of minimal length only depends on \\n*how shorter length than target we find first.*  \\nIf target is 10 and we find one 10 first, the cache size will be always 1.\\nIf we find 9,1 first, the cache size will be always smaller than or equal 2.\\n\\n**The key point** in short is \\nwe only need to store minimal found length and result.\\n\\n**For example,**\\n(cache only stores the new minimum)\\nSuppose windows have no overlaps in the following example.\\nIf overlap, we just need to find the found length in cache without overlap, \\nbut cache is small, so it\\'s very fast. I will show it in code.\\n```\\nRound 0\\ncache {}, result {}, found length {}\\n```\\n```\\nRound 1\\ncache {2}, result {2}, found length {2}\\n```\\n```\\nRound 2\\ncache {2}, result {2+3}, found length {3}\\n```\\n```\\nRound 3\\ncache {2}, result {2+2}, found length {2}\\n```\\n```\\nRound 4\\ncache {2, 1}, result {2+1}, found length {1}\\n```\\n```\\nRound 5\\ncache {2, 1}, result {2+1}, found length {3}\\n```\\nIn a result, perfermance don\\'t change, \\nbut we save memory from using all DP cache memory of entire array.\\nCode with clear comments as below\\n\\n```\\nclass Solution: # best, 804 ms\\n  def minSumOfLengths(self, arr, target):\\n    result = inf = 2**31-1\\n    i = window = count = 0\\n    # preMin: store (index, previous shortest length)\\n    preMin = [(-1, inf)]\\n\\n    # i: window start, j: window end\\n    for j, num in enumerate(arr):\\n      window += num\\n      while window > target:\\n        window -= arr[i]\\n        i += 1\\n      if window == target:\\n        # curr: current length\\n        curr = j - i + 1\\n\\t\\t\\n\\t    # early stopping if found two single targets\\n        if curr == 1: \\n\\t\\t    count += 1\\n            if count == 2: return 2\\n\\t\\t\\n        n = 0 \\n        # find first minimal length n before window start i\\n        for index, length in preMin[::-1]:\\n          if index <= i-1: \\n            n = length           \\n            break\\n\\t\\t\\t\\n        # update result  \\n        if result > curr + n: result = curr + n\\n            \\n        # update shortest length\\n        if curr < preMin[-1][-1]: preMin.append((j, curr))\\n\\n    return result if result < inf else -1\\n```\\nwelcome upvote and comments",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nRound 0\\ncache {}, result {}, found length {}\\n```\n```\\nRound 1\\ncache {2}, result {2}, found length {2}\\n```\n```\\nRound 2\\ncache {2}, result {2+3}, found length {3}\\n```\n```\\nRound 3\\ncache {2}, result {2+2}, found length {2}\\n```\n```\\nRound 4\\ncache {2, 1}, result {2+1}, found length {1}\\n```\n```\\nRound 5\\ncache {2, 1}, result {2+1}, found length {3}\\n```\n```\\nclass Solution: # best, 804 ms\\n  def minSumOfLengths(self, arr, target):\\n    result = inf = 2**31-1\\n    i = window = count = 0\\n    # preMin: store (index, previous shortest length)\\n    preMin = [(-1, inf)]\\n\\n    # i: window start, j: window end\\n    for j, num in enumerate(arr):\\n      window += num\\n      while window > target:\\n        window -= arr[i]\\n        i += 1\\n      if window == target:\\n        # curr: current length\\n        curr = j - i + 1\\n\\t\\t\\n\\t    # early stopping if found two single targets\\n        if curr == 1: \\n\\t\\t    count += 1\\n            if count == 2: return 2\\n\\t\\t\\n        n = 0 \\n        # find first minimal length n before window start i\\n        for index, length in preMin[::-1]:\\n          if index <= i-1: \\n            n = length           \\n            break\\n\\t\\t\\t\\n        # update result  \\n        if result > curr + n: result = curr + n\\n            \\n        # update shortest length\\n        if curr < preMin[-1][-1]: preMin.append((j, curr))\\n\\n    return result if result < inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766171,
                "title": "javascript-o-n-with-hashmap-and-sliding-window",
                "content": "These are Java solutions with great votes. I\\'ve just converted them in to Javascript\\n\\n**Hashmap**\\n```\\nfunction minSumOfLengths(arr, target) {\\n  let hmap = new Map();\\n  let sum = 0, lsize = Number.MAX_VALUE, result = Number.MAX_VALUE;\\n  hmap.set(0, -1);\\n  for (let i = 0; i < arr.length; i++) {\\n    sum += arr[i];\\n    hmap.set(sum, i); // stores key as sum upto index i, and value as i.\\n  }\\n  sum = 0;\\n  for (let i = 0; i < arr.length; i++) {\\n    sum += arr[i];\\n    if (hmap.get(sum - target) != null) {\\n      lsize = Math.min(lsize, i - hmap.get(sum - target));      // stores minimum length of sub-array ending with index<= i with sum target. This ensures non- overlapping property.\\n    }\\n    //hmap.get(sum+target) searches for any sub-array starting with index i+1 with sum target.\\n    if (hmap.get(sum + target) != null && lsize < Number.MAX_VALUE) {\\n      result = Math.min(result, hmap.get(sum + target) - i + lsize); // updates the result only if both left and right sub-array exists.\\n    }\\n  }\\n  return result == Number.MAX_VALUE ? -1 : result;\\n}\\n```\\n\\n**Sliding Window**\\n```\\nvar minSumOfLengths = function (arr, target) {\\n  let n = arr.length;\\n  let best = new Array(n).fill(Number.MAX_VALUE);\\n  let sum = 0, start = 0, ans = Number.MAX_VALUE, bestSoFar = Number.MAX_VALUE;\\n  for (let i = 0; i < n; i++) {\\n    sum += arr[i];\\n    while (sum > target) {\\n      sum -= arr[start];\\n      start++;\\n    }\\n    if (sum == target) {\\n      if (start > 0 && best[start - 1] != Number.MAX_VALUE) {\\n        ans = Math.min(ans, best[start - 1] + i - start + 1);\\n      }\\n      bestSoFar = Math.min(bestSoFar, i - start + 1);\\n    }\\n    best[i] = bestSoFar;\\n  }\\n  return ans == Number.MAX_VALUE ? -1 : ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nfunction minSumOfLengths(arr, target) {\\n  let hmap = new Map();\\n  let sum = 0, lsize = Number.MAX_VALUE, result = Number.MAX_VALUE;\\n  hmap.set(0, -1);\\n  for (let i = 0; i < arr.length; i++) {\\n    sum += arr[i];\\n    hmap.set(sum, i); // stores key as sum upto index i, and value as i.\\n  }\\n  sum = 0;\\n  for (let i = 0; i < arr.length; i++) {\\n    sum += arr[i];\\n    if (hmap.get(sum - target) != null) {\\n      lsize = Math.min(lsize, i - hmap.get(sum - target));      // stores minimum length of sub-array ending with index<= i with sum target. This ensures non- overlapping property.\\n    }\\n    //hmap.get(sum+target) searches for any sub-array starting with index i+1 with sum target.\\n    if (hmap.get(sum + target) != null && lsize < Number.MAX_VALUE) {\\n      result = Math.min(result, hmap.get(sum + target) - i + lsize); // updates the result only if both left and right sub-array exists.\\n    }\\n  }\\n  return result == Number.MAX_VALUE ? -1 : result;\\n}\\n```\n```\\nvar minSumOfLengths = function (arr, target) {\\n  let n = arr.length;\\n  let best = new Array(n).fill(Number.MAX_VALUE);\\n  let sum = 0, start = 0, ans = Number.MAX_VALUE, bestSoFar = Number.MAX_VALUE;\\n  for (let i = 0; i < n; i++) {\\n    sum += arr[i];\\n    while (sum > target) {\\n      sum -= arr[start];\\n      start++;\\n    }\\n    if (sum == target) {\\n      if (start > 0 && best[start - 1] != Number.MAX_VALUE) {\\n        ans = Math.min(ans, best[start - 1] + i - start + 1);\\n      }\\n      bestSoFar = Math.min(bestSoFar, i - start + 1);\\n    }\\n    best[i] = bestSoFar;\\n  }\\n  return ans == Number.MAX_VALUE ? -1 : ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753675,
                "title": "python-rust-prefix-sum",
                "content": "-  **Python**\\n\\n```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        s, lsize, res = 0, float(\\'inf\\'), float(\\'inf\\')\\n        prefixSum = { 0: -1 }\\n        \\n        for i, val in enumerate(arr):\\n            s += val\\n            prefixSum[s] = i\\n            \\n        s = 0\\n        for i, val in enumerate(arr):\\n            s += val\\n            \\n            if s - target in prefixSum:\\n                lsize = min(i - prefixSum[s - target], lsize)\\n            \\n            if s + target in prefixSum and lsize != float(\\'inf\\'):\\n                rsize = prefixSum[s + target] - i\\n                res = min(res, rsize + lsize)\\n                \\n        return res if res != float(\\'inf\\') else -1\\n```\\n\\n- **Rust**\\n\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_sum_of_lengths(arr: Vec<i32>, target: i32) -> i32 {\\n        let (mut sum, mut res, mut lsize) = (0, std::i32::MAX, std::i32::MAX);\\n        let mut prefixSum: HashMap<i32, i32> = HashMap::new();\\n        \\n        prefixSum.insert(0, -1);\\n        \\n        for (i, val) in arr.iter().enumerate() {\\n            sum += *val;\\n            prefixSum.insert(sum, i as i32);\\n        }\\n        \\n        sum = 0;\\n        for (i, val) in arr.iter().enumerate() {\\n            sum += *val;\\n            let index = i as i32;\\n            \\n            if prefixSum.contains_key(&(sum - target)) {\\n                lsize = lsize.min(index - *prefixSum.get(&(sum - target)).unwrap());\\n            }\\n            \\n            if prefixSum.contains_key(&(sum + target)) && lsize != std::i32::MAX {\\n                let rsize = *prefixSum.get(&(sum + target)).unwrap() - index;\\n                res = res.min(rsize + lsize);\\n            }\\n        }\\n        \\n        return if res == std::i32::MAX { -1 } else { res }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        s, lsize, res = 0, float(\\'inf\\'), float(\\'inf\\')\\n        prefixSum = { 0: -1 }\\n        \\n        for i, val in enumerate(arr):\\n            s += val\\n            prefixSum[s] = i\\n            \\n        s = 0\\n        for i, val in enumerate(arr):\\n            s += val\\n            \\n            if s - target in prefixSum:\\n                lsize = min(i - prefixSum[s - target], lsize)\\n            \\n            if s + target in prefixSum and lsize != float(\\'inf\\'):\\n                rsize = prefixSum[s + target] - i\\n                res = min(res, rsize + lsize)\\n                \\n        return res if res != float(\\'inf\\') else -1\\n```\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_sum_of_lengths(arr: Vec<i32>, target: i32) -> i32 {\\n        let (mut sum, mut res, mut lsize) = (0, std::i32::MAX, std::i32::MAX);\\n        let mut prefixSum: HashMap<i32, i32> = HashMap::new();\\n        \\n        prefixSum.insert(0, -1);\\n        \\n        for (i, val) in arr.iter().enumerate() {\\n            sum += *val;\\n            prefixSum.insert(sum, i as i32);\\n        }\\n        \\n        sum = 0;\\n        for (i, val) in arr.iter().enumerate() {\\n            sum += *val;\\n            let index = i as i32;\\n            \\n            if prefixSum.contains_key(&(sum - target)) {\\n                lsize = lsize.min(index - *prefixSum.get(&(sum - target)).unwrap());\\n            }\\n            \\n            if prefixSum.contains_key(&(sum + target)) && lsize != std::i32::MAX {\\n                let rsize = *prefixSum.get(&(sum + target)).unwrap() - index;\\n                res = res.min(rsize + lsize);\\n            }\\n        }\\n        \\n        return if res == std::i32::MAX { -1 } else { res }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738733,
                "title": "c-one-pass-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int size=arr.size(),sum=0,ans=INT_MAX;\\n        unordered_map<int,int>mp;\\n        // to handle corner cases,you can say it is also one pass,but i am just ignoring it :P\\n        arr.insert(arr.begin(),0);\\n        size++;\\n        // trackmin[i] will give you the minimum length of subarray till i(included) ,whose sum is equals to target\\n        vector<int>trackmin(size,INT_MAX);\\n        mp[0]=0;\\n        for(int i=1;i<size;i++){\\n           sum+=arr[i];\\n            // if we find subarray whose sum== target\\n            if(mp.find(sum-target)!=mp.end()){\\n                // calculate surrent length\\n                int curlen=i-mp[sum-target];\\n                // get previous length from trackmin\\n                int premin=trackmin[mp[sum-target]];\\n                if(premin!=INT_MAX)\\n                    ans=min(ans,curlen+premin);\\n                // update trackmin[i]\\n                trackmin[i]=min(curlen,trackmin[i-1]);\\n            }\\n            else\\n               trackmin[i]=trackmin[i-1];\\n            mp[sum]=i;\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```\\nDo **UPVOTE** is it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int size=arr.size(),sum=0,ans=INT_MAX;\\n        unordered_map<int,int>mp;\\n        // to handle corner cases,you can say it is also one pass,but i am just ignoring it :P\\n        arr.insert(arr.begin(),0);\\n        size++;\\n        // trackmin[i] will give you the minimum length of subarray till i(included) ,whose sum is equals to target\\n        vector<int>trackmin(size,INT_MAX);\\n        mp[0]=0;\\n        for(int i=1;i<size;i++){\\n           sum+=arr[i];\\n            // if we find subarray whose sum== target\\n            if(mp.find(sum-target)!=mp.end()){\\n                // calculate surrent length\\n                int curlen=i-mp[sum-target];\\n                // get previous length from trackmin\\n                int premin=trackmin[mp[sum-target]];\\n                if(premin!=INT_MAX)\\n                    ans=min(ans,curlen+premin);\\n                // update trackmin[i]\\n                trackmin[i]=min(curlen,trackmin[i-1]);\\n            }\\n            else\\n               trackmin[i]=trackmin[i-1];\\n            mp[sum]=i;\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580326,
                "title": "o-n-sliding-window-prefix-suffix-sums-suffix-min",
                "content": "Given an array of length `n` of positive numbers, our goal is to find two non-overlapping subarrays which:\\n- both sum to a specified target value  `T`\\n- whose sum of individual lengths are minimized\\n\\n**FINDING SUBARRAYS: SLIDING WINDOW + PREFIX/SUFFIX SUMS**\\nFor each index `i` of our array, we consider the following:\\n* The shortest subarray length ending at index `i` that sums to target `T`, denoted `end(i)`\\n* The shortest subarray length starting at index `i` that sums to target `T`, denoted `start(i)`\\n\\nTo compute `end(i)` for each ending index `i`, we can leverage prefix sums and a queue of already encountered indices as follows:\\n\\n* `prefix_sum(i) < T`: no subarray ending at `i` sums to `T` (since all entries are positive)\\n* `prefix_sum(i) = T`: The subarray from index 0 to `i` of length `i+1` is the unique one that ends at index `i` and sums to `T`\\n* `prefix_sum(i) > T`: Start going from the front of our queue of previously handled end indexes, and pop away anything for which the difference of prefix_sums between index `i` and that top index exceeds `T`. We know that we no longer have to bother checking that prior index, when we go to later/greater values `i`, since our prefix sum is monotonic increasing function (all values in the original array are positive), so if `prefix_sum(i) - prefix_sum(q(0)) > T`, then necessarily `prefix_sum(i+1) - prefix_sum(q(0)) > prefix_sum(i) - prefix_sum(q(0)) > T`. If we arrive finally at a difference in prefix sums that equals our target `T`, we\\'ve found a valid subarray ending at index `i`.\\n\\nWe can do the same thing for `start(i)`, but in this case, we are looking at differences of suffix sums (i.e. iterating from the back of the array, but still leveraging this sliding window/queue approach).\\n\\n**PUTTING IT ALL TOGETHER: SUFFIX MIN**\\nSo we now have a way of getting the length of subarrays that start/end at each index and sum to our target `T`. It follows now that for each possible index `i`, we need to determine the sum of lengths of:\\n\\n* the subarray ending at index `i` which sums to `T`\\n* the mimimum length of a subarray starting after index `i` which sums to `T`\\n\\nOr to put in more succinct notation:\\n```\\nend(i) + min_{j > i} {start(j)}\\n```\\nOur final answer wlll then just be the global min over all possible such first-end indices `i`:\\n```\\nmin_{i = 0, ..., n-1} {end(i) + min_{j > i} {start(j)}}\\n```\\n\\nIn order to avoid performing the `min_{j > i} start(j)` calculation `n` different times, we can leverage a suffix min here, given by the recursive formula:\\n```\\nsuffix_min(n-1) = min{infty, start(n-1)}\\nsuffix_min(j) = min(suffix_min(j+1), start(j)}  j = n-2, ..., 1, 0\\n```\\nand thus this last quantity involving nested mins can be done in linear time.\\n\\n**CODE**\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        \\n        # STEP 1: For each possible index, find the minimum length subarray ending at that index which\\n        # sums to our desired target (infinity if no such subarray exists)\\n        prefix_sum = [0] * n\\n        min_len_ending_at = [float(\"inf\")] * n\\n        q = []\\n        for i in range(n):\\n            prefix_sum[i] = prefix_sum[i-1] + arr[i]\\n            if prefix_sum[i] == target:\\n                min_len_ending_at[i] = i + 1\\n            else:\\n                while q and prefix_sum[i] - prefix_sum[q[0]] > target:\\n                    q.pop(0)\\n                if len(q) > 0 and prefix_sum[i] - prefix_sum[q[0]] == target:\\n                    min_len_ending_at[i] = i - q[0]\\n            q.append(i)\\n        \\n        # STEP 2: For each possible index, find the minimum length subarray starting at that index which\\n        # sums to our desired target (infinity if no such subarray exists)\\n        suffix_sum = [0] * n\\n        min_len_starting_at = [float(\"inf\")] * n\\n        q = []\\n        for i in range(n-1, -1, -1):\\n            suffix_sum[i] = suffix_sum[(i+1) % n] + arr[i]\\n            if suffix_sum[i] == target:\\n                min_len_starting_at[i] = n - i\\n            else:\\n                while len(q) > 0 and suffix_sum[i] - suffix_sum[q[0]] > target:\\n                    q.pop(0)\\n                if len(q) > 0 and suffix_sum[i] - suffix_sum[q[0]] == target:\\n                    min_len_starting_at[i] = q[0] - i\\n            q.append(i)\\n        \\n        # STEP 3: For each possible index, determine the minimum length of any subarray starting at or after\\n        # this index, which sums to our desired target\\n        suffix_min_len_after = [float(inf)] * n\\n        for i in range(n-1, -1, -1):\\n            suffix_min_len_after[i] = min(suffix_min_len_after[(i+1) % n], min_len_starting_at[i])\\n        \\n        # STEP 4: For each possible end index, determine the sum of the:\\n        # - length of the subarray ending at the index which sums to target (infinity if no such subarray exists)\\n        # - length of shortest subarray starting AFTER this end index, which also sums to our target\\n        # and compare to current smallest such sum of interval lengths.\\n        res = float(\"inf\")\\n        for i in range(n-1):\\n            res = min(res, min_len_ending_at[i] + suffix_min_len_after[i+1])\\n        \\n        if res == float(\"inf\"):\\n            return -1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nend(i) + min_{j > i} {start(j)}\\n```\n```\\nmin_{i = 0, ..., n-1} {end(i) + min_{j > i} {start(j)}}\\n```\n```\\nsuffix_min(n-1) = min{infty, start(n-1)}\\nsuffix_min(j) = min(suffix_min(j+1), start(j)}  j = n-2, ..., 1, 0\\n```\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        \\n        # STEP 1: For each possible index, find the minimum length subarray ending at that index which\\n        # sums to our desired target (infinity if no such subarray exists)\\n        prefix_sum = [0] * n\\n        min_len_ending_at = [float(\"inf\")] * n\\n        q = []\\n        for i in range(n):\\n            prefix_sum[i] = prefix_sum[i-1] + arr[i]\\n            if prefix_sum[i] == target:\\n                min_len_ending_at[i] = i + 1\\n            else:\\n                while q and prefix_sum[i] - prefix_sum[q[0]] > target:\\n                    q.pop(0)\\n                if len(q) > 0 and prefix_sum[i] - prefix_sum[q[0]] == target:\\n                    min_len_ending_at[i] = i - q[0]\\n            q.append(i)\\n        \\n        # STEP 2: For each possible index, find the minimum length subarray starting at that index which\\n        # sums to our desired target (infinity if no such subarray exists)\\n        suffix_sum = [0] * n\\n        min_len_starting_at = [float(\"inf\")] * n\\n        q = []\\n        for i in range(n-1, -1, -1):\\n            suffix_sum[i] = suffix_sum[(i+1) % n] + arr[i]\\n            if suffix_sum[i] == target:\\n                min_len_starting_at[i] = n - i\\n            else:\\n                while len(q) > 0 and suffix_sum[i] - suffix_sum[q[0]] > target:\\n                    q.pop(0)\\n                if len(q) > 0 and suffix_sum[i] - suffix_sum[q[0]] == target:\\n                    min_len_starting_at[i] = q[0] - i\\n            q.append(i)\\n        \\n        # STEP 3: For each possible index, determine the minimum length of any subarray starting at or after\\n        # this index, which sums to our desired target\\n        suffix_min_len_after = [float(inf)] * n\\n        for i in range(n-1, -1, -1):\\n            suffix_min_len_after[i] = min(suffix_min_len_after[(i+1) % n], min_len_starting_at[i])\\n        \\n        # STEP 4: For each possible end index, determine the sum of the:\\n        # - length of the subarray ending at the index which sums to target (infinity if no such subarray exists)\\n        # - length of shortest subarray starting AFTER this end index, which also sums to our target\\n        # and compare to current smallest such sum of interval lengths.\\n        res = float(\"inf\")\\n        for i in range(n-1):\\n            res = min(res, min_len_ending_at[i] + suffix_min_len_after[i+1])\\n        \\n        if res == float(\"inf\"):\\n            return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411902,
                "title": "easy-c-sol",
                "content": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int start=0;\\n        int len=INT_MAX;\\n        \\n        int n=arr.size();\\n        \\n        int sum=0;\\n        int res=INT_MAX;\\n        \\n        vector<int> dp(n,INT_MAX);\\n        \\n        for(int end=0;end<n;end++)\\n        {\\n            sum+=arr[end];\\n            \\n            while(sum>target)\\n            {\\n                sum-=arr[start];\\n                start++;\\n            }\\n            \\n            if(sum==target)\\n            {\\n                int curlen=end-start+1;\\n                \\n                if(start>0  &&   dp[start-1]!=INT_MAX)\\n                {\\n                    res=min(curlen+dp[start-1],res);\\n                }\\n                \\n                len=min(curlen,len);\\n            }\\n            \\n            dp[end]=len;\\n            \\n        }\\n        \\n        if(res==INT_MAX)\\n            return -1;\\n        \\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int start=0;\\n        int len=INT_MAX;\\n        \\n        int n=arr.size();\\n        \\n        int sum=0;\\n        int res=INT_MAX;\\n        \\n        vector<int> dp(n,INT_MAX);\\n        \\n        for(int end=0;end<n;end++)\\n        {\\n            sum+=arr[end];\\n            \\n            while(sum>target)\\n            {\\n                sum-=arr[start];\\n                start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1117315,
                "title": "o-n-one-pass-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    from collections import defaultdict\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefixSum = defaultdict(int) # prefix sum dictionary \\n        currSum = 0\\n        prefixSum[0] = -1 \\n        n = len(arr)\\n        res = float(\\'inf\\') # results\\n        dp = [float(\\'inf\\')] * n # dp[i] the length of longest subarray whose sum is target and ends at or before i \\n        for i in range(n):\\n            currSum += arr[i]\\n            restSum = currSum - target\\n            if i - 1 >= 0: dp[i] = dp[i-1] \\n            if restSum in prefixSum:\\n                right,left = i,prefixSum[restSum]+1\\n                if left - 1 >= 0:\\n                    res = min(res,right - left + 1 + dp[left - 1])\\n                dp[i] = min(dp[i],right - left + 1)\\n            prefixSum[currSum] = i # update prefix sum dictionary\\n        return res if res != float(\\'inf\\') else -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    from collections import defaultdict\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefixSum = defaultdict(int) # prefix sum dictionary \\n        currSum = 0\\n        prefixSum[0] = -1 \\n        n = len(arr)\\n        res = float(\\'inf\\') # results\\n        dp = [float(\\'inf\\')] * n # dp[i] the length of longest subarray whose sum is target and ends at or before i \\n        for i in range(n):\\n            currSum += arr[i]\\n            restSum = currSum - target\\n            if i - 1 >= 0: dp[i] = dp[i-1] \\n            if restSum in prefixSum:\\n                right,left = i,prefixSum[restSum]+1\\n                if left - 1 >= 0:\\n                    res = min(res,right - left + 1 + dp[left - 1])\\n                dp[i] = min(dp[i],right - left + 1)\\n            prefixSum[currSum] = i # update prefix sum dictionary\\n        return res if res != float(\\'inf\\') else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025778,
                "title": "python3-sliding-window-one-pass-o-n",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        res, cur, i, p = inf, 0, 0, [inf]\\n        for j, a in enumerate(arr):\\n            cur += a\\n            while cur > target:\\n                cur -= arr[i]\\n                i += 1\\n            if cur == target:\\n                res = min(res, j-i+1+p[i])\\n                p += min(p[-1], j-i+1),\\n            else:\\n                p += p[-1],\\n        return res if res < inf else -1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        res, cur, i, p = inf, 0, 0, [inf]\\n        for j, a in enumerate(arr):\\n            cur += a\\n            while cur > target:\\n                cur -= arr[i]\\n                i += 1\\n            if cur == target:\\n                res = min(res, j-i+1+p[i])\\n                p += min(p[-1], j-i+1),\\n            else:\\n                p += p[-1],\\n        return res if res < inf else -1",
                "codeTag": "Java"
            },
            {
                "id": 796649,
                "title": "prefix-sum-sliding-window-python-code-with-comments-beat-99",
                "content": "```\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        # prefix sum + sliding window method O(n)\\n        \\n        n = len(arr)\\n        Max = 2**31-1\\n        minlens = [Max] * n # every position, has a min-length subarray ends/or before it, with a sum-up = target\\n        minlen = Max # currently (global) min-length subarray and whose sum-up = target\\n        ans = Max # final answer\\n        \\n        left = 0\\n        presum = 0  # store prefix-sum\\n        \\n        for right in range(n):\\n            presum += arr[right]\\n            \\n            while presum > target: # sliding window method to enlarge left so that presum <= target\\n                presum -= arr[left]\\n                left += 1\\n            \\n            if presum == target: # update values when we find presum==target\\n                curlen = right - left + 1 # the length of current subarray from left to right, both inclusive [left, right]\\n                if left > 0 and minlens[left-1] < Max: \\n\\t\\t\\t\\t    # since left is included in current subarray, we have to find a subarray with sum=target before left\\n\\t\\t\\t\\t    # and the best is recorded in minles[left-1]:\\n                    ans = min(ans, curlen + minlens[left-1]) \\n\\t\\t\\t\\t\\t# update ans, a former subarray with length minlens[left-1] and current length\\n                minlen = min(minlen, curlen) # update the global min-length of subarray whose sum-up = target\\n            minlens[right] = minlen # update right-position\\'s best minlen(before or ends at \\'right\\')\\n        return -1 if ans == Max else ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        # prefix sum + sliding window method O(n)\\n        \\n        n = len(arr)\\n        Max = 2**31-1\\n        minlens = [Max] * n # every position, has a min-length subarray ends/or before it, with a sum-up = target\\n        minlen = Max # currently (global) min-length subarray and whose sum-up = target\\n        ans = Max # final answer\\n        \\n        left = 0\\n        presum = 0  # store prefix-sum\\n        \\n        for right in range(n):\\n            presum += arr[right]\\n            \\n            while presum > target: # sliding window method to enlarge left so that presum <= target\\n                presum -= arr[left]\\n                left += 1\\n            \\n            if presum == target: # update values when we find presum==target\\n                curlen = right - left + 1 # the length of current subarray from left to right, both inclusive [left, right]\\n                if left > 0 and minlens[left-1] < Max: \\n\\t\\t\\t\\t    # since left is included in current subarray, we have to find a subarray with sum=target before left\\n\\t\\t\\t\\t    # and the best is recorded in minles[left-1]:\\n                    ans = min(ans, curlen + minlens[left-1]) \\n\\t\\t\\t\\t\\t# update ans, a former subarray with length minlens[left-1] and current length\\n                minlen = min(minlen, curlen) # update the global min-length of subarray whose sum-up = target\\n            minlens[right] = minlen # update right-position\\'s best minlen(before or ends at \\'right\\')\\n        return -1 if ans == Max else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793994,
                "title": "best-explain",
                "content": "1.brute approach\\n```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        if(arr==null||arr.length==0||target<1){\\n            return -1;\\n        }\\n        int[] dp=new int[arr.length];\\n        List<Pair<Integer,Integer>> subarr=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<=i;j++){\\n                dp[j]=((i==j)?arr[i]:dp[j]+arr[i]);\\n                if(dp[j]==target){\\n                    subarr.add(new Pair(j,i));\\n                }\\n            }\\n        }\\n        int minSum=Integer.MAX_VALUE;\\n        for(int i=0;i<subarr.size();i++){\\n            Pair<Integer,Integer> pairI=subarr.get(i);\\n            int start=pairI.getKey();\\n            int end=pairI.getValue();\\n            for(int j=i+1;j<subarr.size();j++){\\n                Pair<Integer,Integer> pairJ=subarr.get(j);\\n                int start1=pairJ.getKey();\\n                int end1=pairJ.getValue();\\n                if(end<start1||start>end1){\\n                    minSum=Math.min(minSum,end-start+end1-start1+2);\\n                }\\n            }\\n        }\\n        return minSum==Integer.MAX_VALUE?-1:minSum;\\n    }\\n```\\n\\n2.opt\\n    1.brute approach:\\n       a:find the list for all of the  subarr which equals target.\\n       b:then compute the sum of two subarr in the list,which need be uncrossed.\\n       time complexity O(n^2)\\n    2.how can we opt the brute approach?we can not opt it by caculating the two process separately.because  it has been optimum.in the case,we need merge the two process \\n      into one process.\\n    3.how to merge the two process?\\n     c:for the subarr of start at i and sum equals target, we need find the min one subarr of start at (0,i-1) and sum equals target,the time complexity is O(n)\\n     d:two subarr need be uncrossed.so for the subarr of start at i, we just need compare the subarr of  end at (0,i-1)\\n     e:we can find it will be many duplicate computing  the sum of subarr in the process d.we can opt it by saving the sum of subarr,which use sum+=arr[i],dp[i]=sum.\\n\\n    ```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        if(arr==null||arr.length==0||target<1){\\n            return -1;\\n        }\\n        Map<Integer,Integer> dp = new HashMap<>();\\n        dp.put(0,-1);\\n        int sum=0;\\n        int lsize=Integer.MAX_VALUE;\\n        int result=Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            dp.put(sum,i);\\n        }\\n        sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            Integer left=dp.get(sum-target);\\n            Integer right=dp.get(sum+target);\\n            if(left!=null){\\n                lsize=Math.min(lsize,i-left);\\n            }\\n            if(right!=null&&lsize!=Integer.MAX_VALUE){\\n                result=Math.min(result,right-i+lsize);\\n            }\\n        }\\n        return result==Integer.MAX_VALUE?-1:result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        if(arr==null||arr.length==0||target<1){\\n            return -1;\\n        }\\n        int[] dp=new int[arr.length];\\n        List<Pair<Integer,Integer>> subarr=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<=i;j++){\\n                dp[j]=((i==j)?arr[i]:dp[j]+arr[i]);\\n                if(dp[j]==target){\\n                    subarr.add(new Pair(j,i));\\n                }\\n            }\\n        }\\n        int minSum=Integer.MAX_VALUE;\\n        for(int i=0;i<subarr.size();i++){\\n            Pair<Integer,Integer> pairI=subarr.get(i);\\n            int start=pairI.getKey();\\n            int end=pairI.getValue();\\n            for(int j=i+1;j<subarr.size();j++){\\n                Pair<Integer,Integer> pairJ=subarr.get(j);\\n                int start1=pairJ.getKey();\\n                int end1=pairJ.getValue();\\n                if(end<start1||start>end1){\\n                    minSum=Math.min(minSum,end-start+end1-start1+2);\\n                }\\n            }\\n        }\\n        return minSum==Integer.MAX_VALUE?-1:minSum;\\n    }\\n```\n```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        if(arr==null||arr.length==0||target<1){\\n            return -1;\\n        }\\n        Map<Integer,Integer> dp = new HashMap<>();\\n        dp.put(0,-1);\\n        int sum=0;\\n        int lsize=Integer.MAX_VALUE;\\n        int result=Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            dp.put(sum,i);\\n        }\\n        sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            Integer left=dp.get(sum-target);\\n            Integer right=dp.get(sum+target);\\n            if(left!=null){\\n                lsize=Math.min(lsize,i-left);\\n            }\\n            if(right!=null&&lsize!=Integer.MAX_VALUE){\\n                result=Math.min(result,right-i+lsize);\\n            }\\n        }\\n        return result==Integer.MAX_VALUE?-1:result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 746091,
                "title": "python3-o-n-using-prefix-sum-strategy",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        hashTable = defaultdict(int)\\n        hashTable[0] = -1\\n        summation = 0\\n        for i in range(len(arr)):\\n            summation = summation + arr[i]\\n            hashTable[summation] = i\\n        \\n        summation = 0\\n        minimumLeft = float(\\'inf\\')\\n        result = float(\\'inf\\')\\n        for i in range(len(arr)):\\n            summation = summation + arr[i]\\n            if summation - target in hashTable:\\n                leftLength = i-hashTable[summation-target]\\n                minimumLeft = min(minimumLeft,leftLength)\\n            if summation + target in hashTable and minimumLeft < float(\\'inf\\'):\\n                rightLength = hashTable[summation+target]-i\\n                result = min(result,hashTable[summation+target]-i+minimumLeft)\\n        \\n        if result == float(\\'inf\\'):\\n            return -1\\n        return result\\n\\t```\\n\\t\\n\\t\\n\\tInspired from @pramitb Java Solution",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        hashTable = defaultdict(int)\\n        hashTable[0] = -1\\n        summation = 0\\n        for i in range(len(arr)):\\n            summation = summation + arr[i]\\n            hashTable[summation] = i\\n        \\n        summation = 0\\n        minimumLeft = float(\\'inf\\')\\n        result = float(\\'inf\\')\\n        for i in range(len(arr)):\\n            summation = summation + arr[i]\\n            if summation - target in hashTable:\\n                leftLength = i-hashTable[summation-target]\\n                minimumLeft = min(minimumLeft,leftLength)\\n            if summation + target in hashTable and minimumLeft < float(\\'inf\\'):\\n                rightLength = hashTable[summation+target]-i\\n                result = min(result,hashTable[summation+target]-i+minimumLeft)\\n        \\n        if result == float(\\'inf\\'):\\n            return -1\\n        return result\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 694223,
                "title": "javascript-prefix-suffix-array",
                "content": "For better understanding, Please visit:\\nhttps://youtu.be/2PG3b067ogM?t=2\\nif you like it. Please like and subscribe\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} target [64,5,20,9,1,39]\\n * @return {number}\\n */\\nvar minSumOfLengths = function(nums, target) {\\n        let prefix = [],suffix=[],start=0,sum=0,min=0\\n        for(let i=0;i<nums.length;i++){\\n             sum += nums[i]\\n                while(sum > target){\\n                    sum -= nums[start++]\\n                }\\n            if(target == sum){\\n                prefix[i] = min?Math.min(i-start+1,min):i-start+1\\n                min = prefix[i]\\n            }else{\\n                prefix[i] = min\\n            }\\n        }\\n        min = 0,sum = 0,start=nums.length-1\\n        for(let i=nums.length-1;i>=0;i--){\\n            while(sum > target){\\n                    sum -= nums[start--]\\n                }\\n            if(target == sum){\\n                suffix[i] = min?Math.min(start-i,min):start-i\\n                min = suffix[i]\\n            }else{\\n                suffix[i] = min\\n            }\\n            sum += nums[i]\\n        }\\n    let ans = Number.MAX_VALUE\\n    for(let i=0;i<nums.length;i++){\\n        if(!prefix[i] || !suffix[i])continue\\n        ans = Math.min(prefix[i]+suffix[i],ans)\\n    }\\n    return ans == Number.MAX_VALUE?-1:ans\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} target [64,5,20,9,1,39]\\n * @return {number}\\n */\\nvar minSumOfLengths = function(nums, target) {\\n        let prefix = [],suffix=[],start=0,sum=0,min=0\\n        for(let i=0;i<nums.length;i++){\\n             sum += nums[i]\\n                while(sum > target){\\n                    sum -= nums[start++]\\n                }\\n            if(target == sum){\\n                prefix[i] = min?Math.min(i-start+1,min):i-start+1\\n                min = prefix[i]\\n            }else{\\n                prefix[i] = min\\n            }\\n        }\\n        min = 0,sum = 0,start=nums.length-1\\n        for(let i=nums.length-1;i>=0;i--){\\n            while(sum > target){\\n                    sum -= nums[start--]\\n                }\\n            if(target == sum){\\n                suffix[i] = min?Math.min(start-i,min):start-i\\n                min = suffix[i]\\n            }else{\\n                suffix[i] = min\\n            }\\n            sum += nums[i]\\n        }\\n    let ans = Number.MAX_VALUE\\n    for(let i=0;i<nums.length;i++){\\n        if(!prefix[i] || !suffix[i])continue\\n        ans = Math.min(prefix[i]+suffix[i],ans)\\n    }\\n    return ans == Number.MAX_VALUE?-1:ans\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688920,
                "title": "c-sliding-window-comments-warning-test-cases-missing",
                "content": "**Idea**: \\nFind two sub-arrays to meet the following two conditions:\\n1) sum(sub_array1) == target && sum(sub_array2) == target\\n2) min_of_all_possible_comibantion(len1 + len2), where len1= length(sub_array1), len2= length(sub_array2), len1 and len2 are the smallest two subarrays meet the condition 1.\\nNote:\\nmin_of_all_possible(len1 + len2)  =/= min_of_all_possible(len1) + min_of_all_possible(len2)\\n\\n\\n\\n\\n\\n\\nVersion 1: Sliding Window Time/Space: O(N) / O(N)\\n```\\nclass Solution { // Sliding window; Original author: huahua[1]\\npublic: // Time/Space: O(N); O(N)\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        const int n = arr.size(), kInf = INT_MAX/2;\\n        int ans = kInf;\\n        vector<int> memo(n, kInf); //memo[i] := min length of a valid subarray ends or before i.\\n        for(int i = 0, sum = 0, s=0, min_len = kInf; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target) sum -= arr[s++]; //shrink from left, \\'s\\'\\n            if(sum == target){                \\n                int cur_len = i - s + 1;\\n                if( s > 0 && memo[s-1] != kInf)\\n                    ans = min(ans, cur_len + memo[s-1]);\\n                min_len = min(min_len, cur_len);\\n            }\\n            memo[i]=min_len;\\n        }        \\n        return ans < kInf ? ans : -1;\\n    }\\n};\\n```\\nReference:\\n[1] https://zxi.mytechroad.com/blog/sliding-window/leetcode-1477-find-two-non-overlapping-sub-arrays-each-with-target-sum/\\n\\nOkay, I keep thinking for hours that do we really need keep memo, or the information for the minimal  length of the desired subarray (length and ending index) good enough? It turns out by far I still need memo to track all possible comibination. \\n\\nThen I provided the 2nd version, which is surpisingly but not that surpsingly wrong. @Chernik provided an good example where this solution might fail:\\n\\nWhy? This is not a greedy question.\\n```\\nmin_of_all_possible(len1 + len2)  != min_of_all_possible(len1) + min_of_all_possible(len2)\\n```\\n len1 is from the past, len2 is from the current sub-array when you scan from left to right.\\n\\nVersion 2: Sliding Window Time/Space: O(N) / O(1)  (This version is wrong.)\\n```\\nclass Solution { // Sliding window: Wrong Solution. \\npublic: // Time/Space: O(N); O(1)\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        const int n = arr.size(), kInf = INT_MAX/2;\\n        int ans = kInf;        \\n        for(int i = 0, sum = 0, s=0, min_len = kInf, last_end = 0; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target) sum -= arr[s++]; //shrink from left, \\'s\\'\\n            if(sum == target){                \\n                int cur_len = i - s + 1;                \\n                if( min_len < kInf && last_end < s)//already seen one slidwing window with min_len in the past, which dose not overlap with current one\\n                    ans = min(ans, cur_len + min_len);                \\n                if(cur_len < min_len){\\n                    last_end = i; // ending index of the minimum length window by far\\n                    min_len = cur_len;\\n                }            \\n            }            \\n        }        \\n        return ans < kInf ? ans : -1;\\n    }\\n};\\n```\\n[1,1,1,2,1,1]\\n3\\n```\\n\\nP.S.:\\nIf you like the idea here, please help upvote since it takes hours to optmize.\\nIf you do not like the idea here, please let me know so that I can optimize myself to provide better solution in future.",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution { // Sliding window; Original author: huahua[1]\\npublic: // Time/Space: O(N); O(N)\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        const int n = arr.size(), kInf = INT_MAX/2;\\n        int ans = kInf;\\n        vector<int> memo(n, kInf); //memo[i] := min length of a valid subarray ends or before i.\\n        for(int i = 0, sum = 0, s=0, min_len = kInf; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target) sum -= arr[s++]; //shrink from left, \\'s\\'\\n            if(sum == target){                \\n                int cur_len = i - s + 1;\\n                if( s > 0 && memo[s-1] != kInf)\\n                    ans = min(ans, cur_len + memo[s-1]);\\n                min_len = min(min_len, cur_len);\\n            }\\n            memo[i]=min_len;\\n        }        \\n        return ans < kInf ? ans : -1;\\n    }\\n};\\n```\n```\\nmin_of_all_possible(len1 + len2)  != min_of_all_possible(len1) + min_of_all_possible(len2)\\n```\n```\\nclass Solution { // Sliding window: Wrong Solution. \\npublic: // Time/Space: O(N); O(1)\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        const int n = arr.size(), kInf = INT_MAX/2;\\n        int ans = kInf;        \\n        for(int i = 0, sum = 0, s=0, min_len = kInf, last_end = 0; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target) sum -= arr[s++]; //shrink from left, \\'s\\'\\n            if(sum == target){                \\n                int cur_len = i - s + 1;                \\n                if( min_len < kInf && last_end < s)//already seen one slidwing window with min_len in the past, which dose not overlap with current one\\n                    ans = min(ans, cur_len + min_len);                \\n                if(cur_len < min_len){\\n                    last_end = i; // ending index of the minimum length window by far\\n                    min_len = cur_len;\\n                }            \\n            }            \\n        }        \\n        return ans < kInf ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687456,
                "title": "java-2sum-on-prefix-sum",
                "content": "1, acc[i] is sum of prefix array ending at i - 1;\\n2, using dp[i] to remember min length of valid subarrays ending at i - 1;\\n3, using map to remember all prefix sum\\'s index; (see 2 Sum);\\nacc[i] - target == acc[j] then: acc[i] - acc[j] == target \\n4, compare everytime we find a new subarray, which will cover all cases.\\n```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length, acc[] = new int[n + 1], dp[] = new int[n + 1], minLen = Integer.MAX_VALUE, res = minLen;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < acc.length; i++) {\\n            if (i > 0) acc[i] = acc[i - 1] + arr[i - 1];\\n            if (map.containsKey(acc[i] - target)){\\n                int preIdx = map.get(acc[i] - target);\\n                minLen = Math.min(minLen, i - preIdx);\\n                if (dp[preIdx] < Integer.MAX_VALUE) res = Math.min(res, i - preIdx + dp[preIdx]);\\n            }\\n            map.put(acc[i], i); // empty array\\n            dp[i] = minLen;\\n        }\\n        return res < Integer.MAX_VALUE ? res : -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length, acc[] = new int[n + 1], dp[] = new int[n + 1], minLen = Integer.MAX_VALUE, res = minLen;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < acc.length; i++) {\\n            if (i > 0) acc[i] = acc[i - 1] + arr[i - 1];\\n            if (map.containsKey(acc[i] - target)){\\n                int preIdx = map.get(acc[i] - target);\\n                minLen = Math.min(minLen, i - preIdx);\\n                if (dp[preIdx] < Integer.MAX_VALUE) res = Math.min(res, i - preIdx + dp[preIdx]);\\n            }\\n            map.put(acc[i], i); // empty array\\n            dp[i] = minLen;\\n        }\\n        return res < Integer.MAX_VALUE ? res : -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685761,
                "title": "c-o-n-simple-solution",
                "content": "```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n\\tint ans = INT_MAX, prev_min = INT_MAX, left = 0, right = 0, curr = 0;\\n\\tqueue<pair<int, int>> q;\\n\\twhile(right < arr.size()) {\\n\\t\\tcurr += arr[right++];\\n\\t\\twhile(curr > target && left < right) \\n\\t\\t\\tcurr -= arr[left++];\\n\\t\\t\\n\\t\\twhile(!q.empty() && q.front().second <= left) {\\n\\t\\t\\tprev_min = min(prev_min, q.front().second - q.front().first);\\n\\t\\t\\tq.pop();\\n\\t\\t}\\n\\t\\tif(curr == target) {\\n\\t\\t\\tif(prev_min != INT_MAX)\\n\\t\\t\\t\\tans = min(ans, prev_min + right - left);\\n\\t\\t\\tq.emplace(left, right);\\n\\t\\t}\\n\\t}\\n\\treturn ans == INT_MAX ? -1 : ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n\\tint ans = INT_MAX, prev_min = INT_MAX, left = 0, right = 0, curr = 0;\\n\\tqueue<pair<int, int>> q;\\n\\twhile(right < arr.size()) {\\n\\t\\tcurr += arr[right++];\\n\\t\\twhile(curr > target && left < right) \\n\\t\\t\\tcurr -= arr[left++];\\n\\t\\t\\n\\t\\twhile(!q.empty() && q.front().second <= left) {\\n\\t\\t\\tprev_min = min(prev_min, q.front().second - q.front().first);\\n\\t\\t\\tq.pop();\\n\\t\\t}\\n\\t\\tif(curr == target) {\\n\\t\\t\\tif(prev_min != INT_MAX)\\n\\t\\t\\t\\tans = min(ans, prev_min + right - left);\\n\\t\\t\\tq.emplace(left, right);\\n\\t\\t}\\n\\t}\\n\\treturn ans == INT_MAX ? -1 : ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685466,
                "title": "java-using-treemap-to-find-the-minimum-interval",
                "content": "I\\'ve noticed people are placing solutions to avoid TLE taking only the first interval. It usually fails on the next counter case:\\n```\\n[1,2,3,3,3]\\n6\\n```\\n\\nI\\'ve used a `TreeMap` to calculate the minimum interval prior to the current point.\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int i = 0;\\n        int j = 0;\\n        int sum = 0;\\n        int N = arr.length;\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        int best = -1;\\n        while (i < N) {\\n            if (j < N && sum < target) sum += arr[j++];\\n            if (sum == target) {\\n                m.put(j, i);\\n\\t\\t\\t\\t// if we have another interval prior to this point, use it \\n                Integer k = m.floorKey(i);\\n                if (k != null) {\\n                    int l = j - i + k - m.get(k);\\n                    best = best == -1 ? l : Math.min(l, best);\\n                }\\n\\t\\t\\t\\t// put the best interval distance back, we check the best interval prior to this point, and if it has shorted distance - use it instead, so maintain the shortest distance for the left interval\\n                Integer b = m.floorKey(j - 1);\\n                int bl = b == null ? j - i : Math.min(j - i, b - m.get(b));\\n                m.put(j, j - bl);\\n            }\\n            if (sum >= target) {\\n                sum -= arr[i++];\\n            }\\n            \\n            if (sum < target && j >= N) break;\\n        }\\n        return best;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[1,2,3,3,3]\\n6\\n```\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int i = 0;\\n        int j = 0;\\n        int sum = 0;\\n        int N = arr.length;\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        int best = -1;\\n        while (i < N) {\\n            if (j < N && sum < target) sum += arr[j++];\\n            if (sum == target) {\\n                m.put(j, i);\\n\\t\\t\\t\\t// if we have another interval prior to this point, use it \\n                Integer k = m.floorKey(i);\\n                if (k != null) {\\n                    int l = j - i + k - m.get(k);\\n                    best = best == -1 ? l : Math.min(l, best);\\n                }\\n\\t\\t\\t\\t// put the best interval distance back, we check the best interval prior to this point, and if it has shorted distance - use it instead, so maintain the shortest distance for the left interval\\n                Integer b = m.floorKey(j - 1);\\n                int bl = b == null ? j - i : Math.min(j - i, b - m.get(b));\\n                m.put(j, j - bl);\\n            }\\n            if (sum >= target) {\\n                sum -= arr[i++];\\n            }\\n            \\n            if (sum < target && j >= N) break;\\n        }\\n        return best;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685384,
                "title": "tle-c-solution-hope-it-helps-at-all-first-time-trying-to-give-back-to-the-community",
                "content": "Hi, I hope this helps anyone trying to start this problem. I\\'m a weak programmer and didn\\'t quite figure out a good solution yet. But I just want to post my naive TLE solution here. First time trying to give back to this community. XD\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        if(arr.size() < 2)\\n            return -1;\\n        unordered_map<int, int> m;\\n        vector<pair<int, int> > subs;\\n        m[0] = -1;\\n        int sum = 0;\\n        for(int i=0; i<arr.size(); i++){\\n            sum+=arr[i];\\n            if(m.count(sum-target)){\\n                subs.push_back(make_pair(m[sum-target], i));\\n            }\\n            m[sum] = i;\\n        }\\n        auto comp = [](pair<int, int>& a, pair<int, int>& b){return (a.second-a.first) < (b.second-b.first); };\\n        sort(subs.begin(), subs.end(), comp);\\n        \\n        // for(auto& a:subs){\\n        //     cout << a.first << \" \" << a.second << endl;\\n        // }\\n        for(int i=0; i<subs.size(); i++){\\n            for(int j=i+1; j<subs.size(); j++){\\n                if(noOver(subs[i], subs[j]))\\n                    return (subs[i].second-subs[i].first + subs[j].second - subs[j].first);\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool noOver(pair<int, int>& a, pair<int, int>& b){\\n        if( (a.first <= b.first && a.second > b.first)\\n            || (a.first >= b.first && a.first < b.second) )\\n            return false;\\n        return true;\\n            \\n    }\\n\\n};\\n```\\n\\nupdate:\\nIf anyone is interested, I actually figured out how to solve this. I don\\'t quite need to sort the vector, but rather I could keep the shortest subarray while I go over the array.\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        if(arr.size() < 2)\\n            return -1;\\n        unordered_map<int, int> m;\\n        vector<pair<int, int> > subs;\\n        m[0] = -1;\\n        int sum = 0;\\n        int shortest_len = INT_MAX;\\n        pair<int, int> shortest = {-1, -1};\\n        for(int i=0; i<arr.size(); i++){\\n            sum+=arr[i];\\n            if(m.count(sum-target)){\\n                subs.push_back(make_pair(m[sum-target], i));\\n                if(i-m[sum-target] < shortest_len){\\n                    shortest_len = i-m[sum-target];\\n                    shortest = make_pair(m[sum-target], i);\\n                }\\n            }\\n            m[sum] = i;\\n        }\\n        if(shortest_len == INT_MAX)\\n            return -1;\\n        int second_shortest_len = INT_MAX;\\n        pair<int, int> second_shortest = {-1, -1};\\n        for(int i=0; i<subs.size(); i++){\\n            if(noOver(subs[i], shortest)){\\n                if((subs[i].second - subs[i].first ) < second_shortest_len){\\n                    second_shortest_len = subs[i].second - subs[i].first;\\n                    second_shortest = subs[i];\\n                }\\n            }\\n        }\\n         if(second_shortest_len == INT_MAX)\\n            return -1;\\n        return (shortest.second-shortest.first + second_shortest.second - second_shortest.first);\\n    }\\n    \\n    bool noOver(pair<int, int>& a, pair<int, int>& b){\\n        if( (a.first <= b.first && a.second > b.first)\\n            || (a.first >= b.first && a.first < b.second) )\\n            return false;\\n        return true;\\n    }\\n};\\n```\\nOnly beats 20%. But still being proud of it.\\n\\n2nd update:\\nI don\\'t think there\\'s really a way to solve this with my intuition. (Not confident at all).\\nMy second solution couldn\\'t pass testcases for [1,2,3,3,2,1] because it assumes [3,3] is a part of the final answer. My first solution could solve the problem, which makes it O(n^2) though. Sad face.\\n\\n(and [1,2,3,3,2,1] is not part of the test cases given.)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        if(arr.size() < 2)\\n            return -1;\\n        unordered_map<int, int> m;\\n        vector<pair<int, int> > subs;\\n        m[0] = -1;\\n        int sum = 0;\\n        for(int i=0; i<arr.size(); i++){\\n            sum+=arr[i];\\n            if(m.count(sum-target)){\\n                subs.push_back(make_pair(m[sum-target], i));\\n            }\\n            m[sum] = i;\\n        }\\n        auto comp = [](pair<int, int>& a, pair<int, int>& b){return (a.second-a.first) < (b.second-b.first); };\\n        sort(subs.begin(), subs.end(), comp);\\n        \\n        // for(auto& a:subs){\\n        //     cout << a.first << \" \" << a.second << endl;\\n        // }\\n        for(int i=0; i<subs.size(); i++){\\n            for(int j=i+1; j<subs.size(); j++){\\n                if(noOver(subs[i], subs[j]))\\n                    return (subs[i].second-subs[i].first + subs[j].second - subs[j].first);\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool noOver(pair<int, int>& a, pair<int, int>& b){\\n        if( (a.first <= b.first && a.second > b.first)\\n            || (a.first >= b.first && a.first < b.second) )\\n            return false;\\n        return true;\\n            \\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        if(arr.size() < 2)\\n            return -1;\\n        unordered_map<int, int> m;\\n        vector<pair<int, int> > subs;\\n        m[0] = -1;\\n        int sum = 0;\\n        int shortest_len = INT_MAX;\\n        pair<int, int> shortest = {-1, -1};\\n        for(int i=0; i<arr.size(); i++){\\n            sum+=arr[i];\\n            if(m.count(sum-target)){\\n                subs.push_back(make_pair(m[sum-target], i));\\n                if(i-m[sum-target] < shortest_len){\\n                    shortest_len = i-m[sum-target];\\n                    shortest = make_pair(m[sum-target], i);\\n                }\\n            }\\n            m[sum] = i;\\n        }\\n        if(shortest_len == INT_MAX)\\n            return -1;\\n        int second_shortest_len = INT_MAX;\\n        pair<int, int> second_shortest = {-1, -1};\\n        for(int i=0; i<subs.size(); i++){\\n            if(noOver(subs[i], shortest)){\\n                if((subs[i].second - subs[i].first ) < second_shortest_len){\\n                    second_shortest_len = subs[i].second - subs[i].first;\\n                    second_shortest = subs[i];\\n                }\\n            }\\n        }\\n         if(second_shortest_len == INT_MAX)\\n            return -1;\\n        return (shortest.second-shortest.first + second_shortest.second - second_shortest.first);\\n    }\\n    \\n    bool noOver(pair<int, int>& a, pair<int, int>& b){\\n        if( (a.first <= b.first && a.second > b.first)\\n            || (a.first >= b.first && a.first < b.second) )\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3747124,
                "title": "clean-and-easy-to-understand-implementation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size(), i = 0, sum = 0;\\n\\n        vector<int>left(n) , right(n);\\n        int len = INT_MAX;\\n        for(int j=0; j<n; j++){\\n            sum += arr[j];\\n            while(sum > target){\\n                sum -= arr[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                len = min(len,j-i+1);\\n            }\\n            left[j] = len;\\n        }\\n\\n        i = n-1; sum = 0; len = INT_MAX;\\n\\n        for(int j=n-1; j>=0; j--){\\n            sum += arr[j];\\n            while(sum > target){\\n                sum -= arr[i];\\n                i--;\\n            }\\n            if(sum == target){\\n                len = min(len,i-j+1);\\n            }\\n            right[j] = len;\\n        }\\n\\n        int ans = INT_MAX;\\n        for(int j=1; j<n; j++){\\n            if(left[j-1] != INT_MAX && right[j] != INT_MAX) ans = min(ans,left[j-1] + right[j]);\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size(), i = 0, sum = 0;\\n\\n        vector<int>left(n) , right(n);\\n        int len = INT_MAX;\\n        for(int j=0; j<n; j++){\\n            sum += arr[j];\\n            while(sum > target){\\n                sum -= arr[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                len = min(len,j-i+1);\\n            }\\n            left[j] = len;\\n        }\\n\\n        i = n-1; sum = 0; len = INT_MAX;\\n\\n        for(int j=n-1; j>=0; j--){\\n            sum += arr[j];\\n            while(sum > target){\\n                sum -= arr[i];\\n                i--;\\n            }\\n            if(sum == target){\\n                len = min(len,i-j+1);\\n            }\\n            right[j] = len;\\n        }\\n\\n        int ans = INT_MAX;\\n        for(int j=1; j<n; j++){\\n            if(left[j-1] != INT_MAX && right[j] != INT_MAX) ans = min(ans,left[j-1] + right[j]);\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171241,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) \\n    {      \\n        map<int,int>mp,mp2;\\n        int n=arr.size();\\n        int sum=0;\\n        mp[0]=-1;\\n        int mn=INT_MAX;\\n        vector<int>pre(n),suff(n);\\n        for (int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            int temp=INT_MAX;\\n            if (mp.find(sum-target)!=mp.end())\\n            {\\n               int ind=mp[sum-target];\\n               temp=i-ind;\\n            }\\n            mn=min(mn,temp);\\n            pre[i]=mn;\\n            mp[sum]=i;\\n        }\\n        sum=0;\\n        mp2[0]=n;\\n        mn=INT_MAX;\\n        for (int i=n-1;i>=0;i--)\\n        {\\n            int temp=INT_MAX;\\n            if (mp2.find(sum-target)!=mp2.end())\\n            {\\n                int ind=mp2[sum-target];\\n                temp=ind-i-1;\\n            }\\n            mn=min(mn,temp);\\n            suff[i]=mn;\\n            sum+=arr[i];\\n           mp2[sum]=i;\\n        }\\n        int ans=INT_MAX;\\n        for (int i=0;i<n;i++)\\n        {\\n         //cout<<pre[i]<<\" \"<<suff[i]<<endl;\\n        if (suff[i]==INT_MAX || pre[i]==INT_MAX) continue;\\n\\n        ans=min(ans,suff[i]+pre[i]);\\n        }\\n        if (ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) \\n    {      \\n        map<int,int>mp,mp2;\\n        int n=arr.size();\\n        int sum=0;\\n        mp[0]=-1;\\n        int mn=INT_MAX;\\n        vector<int>pre(n),suff(n);\\n        for (int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            int temp=INT_MAX;\\n            if (mp.find(sum-target)!=mp.end())\\n            {\\n               int ind=mp[sum-target];\\n               temp=i-ind;\\n            }\\n            mn=min(mn,temp);\\n            pre[i]=mn;\\n            mp[sum]=i;\\n        }\\n        sum=0;\\n        mp2[0]=n;\\n        mn=INT_MAX;\\n        for (int i=n-1;i>=0;i--)\\n        {\\n            int temp=INT_MAX;\\n            if (mp2.find(sum-target)!=mp2.end())\\n            {\\n                int ind=mp2[sum-target];\\n                temp=ind-i-1;\\n            }\\n            mn=min(mn,temp);\\n            suff[i]=mn;\\n            sum+=arr[i];\\n           mp2[sum]=i;\\n        }\\n        int ans=INT_MAX;\\n        for (int i=0;i<n;i++)\\n        {\\n         //cout<<pre[i]<<\" \"<<suff[i]<<endl;\\n        if (suff[i]==INT_MAX || pre[i]==INT_MAX) continue;\\n\\n        ans=min(ans,suff[i]+pre[i]);\\n        }\\n        if (ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2640023,
                "title": "c-perfect-solution-o-n-tc-dp",
                "content": "TC: O(3 * N)\\nSC: O(N)\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n\\t// Approach : Contraction and expansion of subarray to find the subaaray equals to target\\n\\t// if at any index i , sum > target --> start contracting the subarray by remove the element from front from subarray unless sum<=target\\t\\n\\t// else continue the expansion of subarray\\n        int n=arr.size();\\n        vector<int>prefix(n);\\n        vector<int>suffix(n);\\n        int sum=0;\\n        int sz=1e9,j=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            while(sum>target){\\n                j++;\\n                sum-=arr[j];\\n            }\\n            if(sum==target){\\n                sz=min(sz,i-j);\\n            }\\n            prefix[i]= (sz>=1e9 ? -1 : sz);\\n        }\\n        sum=0;\\n        sz=1e9;\\n        j=n;\\n        for(int i=n-1;i>=0;i--){\\n            sum+=arr[i];\\n            while(sum>target){\\n                j--;\\n                sum-=arr[j];\\n            }\\n            if(sum==target){\\n                sz=min(sz,j-i);\\n            }\\n            suffix[i]= (sz>=1e9 ? -1 : sz);            \\n        }\\n        \\n        int size=1e9;\\n        for(int i=0;i<n;i++){\\n            int left=prefix[i];\\n            int right = (i+1>=n ? -1 : suffix[i+1]);\\n             \\n            if(left!=-1 && right !=-1)\\n                size = min(size, left+right);\\n        }\\n        return size>=1e9 ? -1 : size;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n\\t// Approach : Contraction and expansion of subarray to find the subaaray equals to target\\n\\t// if at any index i , sum > target --> start contracting the subarray by remove the element from front from subarray unless sum<=target\\t\\n\\t// else continue the expansion of subarray\\n        int n=arr.size();\\n        vector<int>prefix(n);\\n        vector<int>suffix(n);\\n        int sum=0;\\n        int sz=1e9,j=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            while(sum>target){\\n                j++;\\n                sum-=arr[j];\\n            }\\n            if(sum==target){\\n                sz=min(sz,i-j);\\n            }\\n            prefix[i]= (sz>=1e9 ? -1 : sz);\\n        }\\n        sum=0;\\n        sz=1e9;\\n        j=n;\\n        for(int i=n-1;i>=0;i--){\\n            sum+=arr[i];\\n            while(sum>target){\\n                j--;\\n                sum-=arr[j];\\n            }\\n            if(sum==target){\\n                sz=min(sz,j-i);\\n            }\\n            suffix[i]= (sz>=1e9 ? -1 : sz);            \\n        }\\n        \\n        int size=1e9;\\n        for(int i=0;i<n;i++){\\n            int left=prefix[i];\\n            int right = (i+1>=n ? -1 : suffix[i+1]);\\n             \\n            if(left!=-1 && right !=-1)\\n                size = min(size, left+right);\\n        }\\n        return size>=1e9 ? -1 : size;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936799,
                "title": "java-sliding-window-beat-90-solutions-o-n",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] min_len = new int[arr.length];\\n        Arrays.fill(min_len, Integer.MAX_VALUE);\\n        \\n        int sum = 0;\\n        int start = 0;\\n        int res = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int end = 0; end < arr.length; end++){\\n            sum += arr[end];\\n            \\n            while(sum > target){\\n                sum -= arr[start++];\\n            }\\n            \\n            if(sum == target){\\n                int cur_len = end-start+1;\\n                if(start > 0 && min_len[start-1] != Integer.MAX_VALUE){\\n                    res = Math.min(res, cur_len + min_len[start-1]);\\n                }\\n                min = Math.min(min, cur_len);\\n            }\\n            min_len[end] = min;\\n        }\\n        \\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] min_len = new int[arr.length];\\n        Arrays.fill(min_len, Integer.MAX_VALUE);\\n        \\n        int sum = 0;\\n        int start = 0;\\n        int res = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int end = 0; end < arr.length; end++){\\n            sum += arr[end];\\n            \\n            while(sum > target){\\n                sum -= arr[start++];\\n            }\\n            \\n            if(sum == target){\\n                int cur_len = end-start+1;\\n                if(start > 0 && min_len[start-1] != Integer.MAX_VALUE){\\n                    res = Math.min(res, cur_len + min_len[start-1]);\\n                }\\n                min = Math.min(min, cur_len);\\n            }\\n            min_len[end] = min;\\n        }\\n        \\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916200,
                "title": "sliding-window-dp",
                "content": "```\\n/*\\n\\n    dp[i] : the length of the shortest subarray which lies in the range [0...i], having a sum = target\\n    we can use sliding window to solve this problem\\n\\n    as soon as [i...j] has a sum = target, the second subarray will be i...j, and we will take the first subarray\\n    given by dp[i - 1]\\n\\n*/\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1e7);\\n        int ans = INT_MAX;\\n\\n\\n        int i = 0, j = -1;\\n        int sum = 0;\\n        int res = 1e7;\\n\\n        while (j < n - 1) {\\n            sum += arr[++j];\\n            while (i <= j && sum > target) {\\n                sum -= arr[i++];\\n            }\\n\\n            if (sum == target) {\\n                dp[j] = min(dp[j], j - i + 1);\\n\\n                if (i > 0) ans = min(ans, j - i + 1 + dp[i - 1]);\\n            }\\n            if (j > 0) dp[j] = min(dp[j], dp[j - 1]);\\n        }\\n\\n\\n        return ans > 1e5 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\n/*\\n\\n    dp[i] : the length of the shortest subarray which lies in the range [0...i], having a sum = target\\n    we can use sliding window to solve this problem\\n\\n    as soon as [i...j] has a sum = target, the second subarray will be i...j, and we will take the first subarray\\n    given by dp[i - 1]\\n\\n*/\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1e7);\\n        int ans = INT_MAX;\\n\\n\\n        int i = 0, j = -1;\\n        int sum = 0;\\n        int res = 1e7;\\n\\n        while (j < n - 1) {\\n            sum += arr[++j];\\n            while (i <= j && sum > target) {\\n                sum -= arr[i++];\\n            }\\n\\n            if (sum == target) {\\n                dp[j] = min(dp[j], j - i + 1);\\n\\n                if (i > 0) ans = min(ans, j - i + 1 + dp[i - 1]);\\n            }\\n            if (j > 0) dp[j] = min(dp[j], dp[j - 1]);\\n        }\\n\\n\\n        return ans > 1e5 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668949,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        unordered_map<int,int>m;\\n        \\n        // \\'sum\\' will store the current sum of the elements\\n        int sum=0,n=arr.size();\\n        \\n        // \\'ans\\' will be the ans\\n        long long ans=INT_MAX;\\n        \\n        // We\\'ll build two arrays prefix and suffix\\n        // prefix[i] = minimum length of subarray ending on or before index i with sum = target\\n        // suffix[i] = minimum length of subarray starting from or after index i with sum = target\\n        vector<int>prefix(n,INT_MAX),suffix(n,INT_MAX);\\n        \\n        // Now populate the prefix array\\n\\t\\t// Logic to populate the array is similar to finding the smallest subarray with a target sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            if(sum==target)\\n            {\\n                prefix[i]=min(prefix[i],i+1);\\n            }\\n            if(m.find(sum-target)!=m.end())\\n            {\\n                prefix[i]=min(prefix[i],i-m[sum-target]);\\n            }\\n            prefix[i]=i>0?min(prefix[i],prefix[i-1]):prefix[i];\\n            m[sum]=i;\\n        }\\n        m.clear();\\n        sum=0;\\n        \\n        // Populate the suffix array\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            sum+=arr[i];\\n            if(sum==target)\\n            {\\n                suffix[i]=min(suffix[i],n-i);\\n            }\\n            if(m.find(sum-target)!=m.end())\\n            {\\n                suffix[i]=min(suffix[i],m[sum-target]-i);\\n            }\\n            suffix[i]=i+1<n?min(suffix[i],suffix[i+1]):suffix[i];\\n            m[sum]=i;\\n        }\\n        \\n        // Now once we\\'ve got the prefix and suffix array we will traverse from 1 to n-1 and compute the answer\\n        for(int i=1;i<n-1;i++)\\n        {\\n            // first find left subarray ending on or before index \\'i\\' and right subarray starting from or after index \\'i+1\\'\\n            long long first=(long long)prefix[i]+(long long)suffix[i+1];\\n            \\n            // second find left subarray ending on or before index \\'i-1\\' and right subarray starting from or after index \\'i\\'\\n            long long second=(long long)prefix[i-1]+(long long)suffix[i];\\n            \\n            // take whichever gives the min aggregate length\\n            ans=min({ans,first,second});\\n        }\\n        \\n        // if at the end the ans is INT_MAX or greater that means there were no 2 subarrys with sum = target so return -1. otherwise return the actual ans\\n        return ans>=INT_MAX?-1:ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        unordered_map<int,int>m;\\n        \\n        // \\'sum\\' will store the current sum of the elements\\n        int sum=0,n=arr.size();\\n        \\n        // \\'ans\\' will be the ans\\n        long long ans=INT_MAX;\\n        \\n        // We\\'ll build two arrays prefix and suffix\\n        // prefix[i] = minimum length of subarray ending on or before index i with sum = target\\n        // suffix[i] = minimum length of subarray starting from or after index i with sum = target\\n        vector<int>prefix(n,INT_MAX),suffix(n,INT_MAX);\\n        \\n        // Now populate the prefix array\\n\\t\\t// Logic to populate the array is similar to finding the smallest subarray with a target sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            if(sum==target)\\n            {\\n                prefix[i]=min(prefix[i],i+1);\\n            }\\n            if(m.find(sum-target)!=m.end())\\n            {\\n                prefix[i]=min(prefix[i],i-m[sum-target]);\\n            }\\n            prefix[i]=i>0?min(prefix[i],prefix[i-1]):prefix[i];\\n            m[sum]=i;\\n        }\\n        m.clear();\\n        sum=0;\\n        \\n        // Populate the suffix array\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            sum+=arr[i];\\n            if(sum==target)\\n            {\\n                suffix[i]=min(suffix[i],n-i);\\n            }\\n            if(m.find(sum-target)!=m.end())\\n            {\\n                suffix[i]=min(suffix[i],m[sum-target]-i);\\n            }\\n            suffix[i]=i+1<n?min(suffix[i],suffix[i+1]):suffix[i];\\n            m[sum]=i;\\n        }\\n        \\n        // Now once we\\'ve got the prefix and suffix array we will traverse from 1 to n-1 and compute the answer\\n        for(int i=1;i<n-1;i++)\\n        {\\n            // first find left subarray ending on or before index \\'i\\' and right subarray starting from or after index \\'i+1\\'\\n            long long first=(long long)prefix[i]+(long long)suffix[i+1];\\n            \\n            // second find left subarray ending on or before index \\'i-1\\' and right subarray starting from or after index \\'i\\'\\n            long long second=(long long)prefix[i-1]+(long long)suffix[i];\\n            \\n            // take whichever gives the min aggregate length\\n            ans=min({ans,first,second});\\n        }\\n        \\n        // if at the end the ans is INT_MAX or greater that means there were no 2 subarrys with sum = target so return -1. otherwise return the actual ans\\n        return ans>=INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371713,
                "title": "java-two-pointer-o-n",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length,res = Integer.MAX_VALUE;\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp,n);\\n        int i = -1,j = -1,sum = 0;\\n        while(j < n){\\n            if(j < n-1 && sum < target) sum += arr[++j];\\n            else if(i < n-1 && sum > target) sum -= arr[++i];\\n            else if(sum == target){\\n                if(dp[i+1] < n)\\n                    res = Math.min(res,dp[i+1]+j-i);\\n                dp[j+1] = j-i; \\n                sum -= arr[++i];\\n            }\\n            else break;\\n            dp[j+1] = Math.min(dp[j],dp[j+1]);\\n        }\\n        return res == Integer.MAX_VALUE?-1:res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length,res = Integer.MAX_VALUE;\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp,n);\\n        int i = -1,j = -1,sum = 0;\\n        while(j < n){\\n            if(j < n-1 && sum < target) sum += arr[++j];\\n            else if(i < n-1 && sum > target) sum -= arr[++i];\\n            else if(sum == target){\\n                if(dp[i+1] < n)\\n                    res = Math.min(res,dp[i+1]+j-i);\\n                dp[j+1] = j-i; \\n                sum -= arr[++i];\\n            }\\n            else break;\\n            dp[j+1] = Math.min(dp[j],dp[j+1]);\\n        }\\n        return res == Integer.MAX_VALUE?-1:res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201389,
                "title": "5ms-98-faster-o-n-dp-sliding-window-solution",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int sum=0,i=0,n=arr.length,res=Integer.MAX_VALUE,length=1000000;\\n        int dp[]=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int j=0;j<n;j++){\\n            sum+=arr[j];\\n            while(sum>target) {sum-=arr[i];\\n                               if(dp[i]!=-1)length=Math.min(length,i-dp[i]+1);\\n                               i++;    \\n            }\\n            if(sum==target){ \\n                dp[j]=i;\\n                if(length!=1000000)res=Math.min(res,length+j-i+1);\\n            }\\n        }\\n        return res==Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```\\n**Time:** O(n)\\n**Space:** O(n)\\n***Please,Upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int sum=0,i=0,n=arr.length,res=Integer.MAX_VALUE,length=1000000;\\n        int dp[]=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int j=0;j<n;j++){\\n            sum+=arr[j];\\n            while(sum>target) {sum-=arr[i];\\n                               if(dp[i]!=-1)length=Math.min(length,i-dp[i]+1);\\n                               i++;    \\n            }\\n            if(sum==target){ \\n                dp[j]=i;\\n                if(length!=1000000)res=Math.min(res,length+j-i+1);\\n            }\\n        }\\n        return res==Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102531,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n   // left[i] is the size of the min size subarray in arr[0, i] that sums up to target. Is Integer.MAX_VALUE if there is no subarray that sums up to target.\\n// right[i] is the size of the min size subarray in arr[i, arr.length - 1] that sums up to target.\\n// for (int i = 1; i < arr.length; ++i) result = Math.min(result, left[i - 1] + right[i]);\\npublic int minSumOfLengths(int[] arr, int target) {          \\n    int[] left = new int[arr.length];\\n    int sum = 0, best = Integer.MAX_VALUE;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    map.put(0, -1);   \\n    for (int i = 0; i < arr.length; ++i) {\\n        sum += arr[i];\\n        if (map.containsKey(sum - target)) {\\n            best = Math.min(best, i - map.get(sum - target));  \\n        }\\n        left[i] = best;\\n        map.put(sum, i);    \\n    }\\n    \\n    int[] right = new int[arr.length];\\n    sum = 0; best = Integer.MAX_VALUE;\\n    map = new HashMap<>();\\n    map.put(0, arr.length);    \\n    for (int i = arr.length - 1; i >= 0; --i) {\\n        sum += arr[i];\\n        if (map.containsKey(sum - target)) {\\n            best = Math.min(best, map.get(sum - target) - i); \\n        }\\n        right[i] = best;\\n        map.put(sum, i);  \\n    }\\n    \\n    int result = Integer.MAX_VALUE;\\n    for (int i = 1; i < arr.length; ++i) {\\n        if (left[i - 1] != Integer.MAX_VALUE && right[i] != Integer.MAX_VALUE) {\\n            result = Math.min(result, left[i - 1] + right[i]);  \\n        }\\n    }\\n    return result == Integer.MAX_VALUE ? -1 : result;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   // left[i] is the size of the min size subarray in arr[0, i] that sums up to target. Is Integer.MAX_VALUE if there is no subarray that sums up to target.\\n// right[i] is the size of the min size subarray in arr[i, arr.length - 1] that sums up to target.\\n// for (int i = 1; i < arr.length; ++i) result = Math.min(result, left[i - 1] + right[i]);\\npublic int minSumOfLengths(int[] arr, int target) {          \\n    int[] left = new int[arr.length];\\n    int sum = 0, best = Integer.MAX_VALUE;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    map.put(0, -1);   \\n    for (int i = 0; i < arr.length; ++i) {\\n        sum += arr[i];\\n        if (map.containsKey(sum - target)) {\\n            best = Math.min(best, i - map.get(sum - target));  \\n        }\\n        left[i] = best;\\n        map.put(sum, i);    \\n    }\\n    \\n    int[] right = new int[arr.length];\\n    sum = 0; best = Integer.MAX_VALUE;\\n    map = new HashMap<>();\\n    map.put(0, arr.length);    \\n    for (int i = arr.length - 1; i >= 0; --i) {\\n        sum += arr[i];\\n        if (map.containsKey(sum - target)) {\\n            best = Math.min(best, map.get(sum - target) - i); \\n        }\\n        right[i] = best;\\n        map.put(sum, i);  \\n    }\\n    \\n    int result = Integer.MAX_VALUE;\\n    for (int i = 1; i < arr.length; ++i) {\\n        if (left[i - 1] != Integer.MAX_VALUE && right[i] != Integer.MAX_VALUE) {\\n            result = Math.min(result, left[i - 1] + right[i]);  \\n        }\\n    }\\n    return result == Integer.MAX_VALUE ? -1 : result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894090,
                "title": "documented-o-n-solution",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = [float(\\'inf\\')]*len(arr) # this array stores the minimum length of the subarray that ends at i or before that\\n        suffix = [float(\\'inf\\')]*len(arr) # this array stores the minimum length of the subarray that starts at i or after that\\n        \\n        start = 0\\n        currSum = 0\\n        for index in range(len(arr)):\\n            currSum += arr[index]\\n            \\n            while currSum > target:\\n                currSum -= arr[start]\\n                start += 1\\n            \\n            if currSum == target:\\n                # populate prefix and suffix array.\\n                # at this point we are simply storing the values for respective index not minimum\\n                length = index-start+1\\n                prefix[index] = length \\n                suffix[start] = length\\n        \\n        # correcting prefix array\\n        for index in range(1, len(arr)):\\n            prefix[index] = min(prefix[index], prefix[index-1])\\n        \\n        # correcting suffix array\\n        for index in range(len(arr)-2, -1, -1):\\n            suffix[index] = min(suffix[index], suffix[index+1])\\n        \\n        \\n\\t\\t# Working with the idea that a non overlapping subarray lies to right and left of an index, \\n\\t\\t# so we select minimum subarray from the two halves of the array.  \\n        minComb = float(\\'inf\\')\\n        for index in range(1, len(arr)):\\n            minComb = min(minComb, prefix[index-1]+suffix[index])\\n        return minComb if minComb < float(\\'inf\\') else -1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = [float(\\'inf\\')]*len(arr) # this array stores the minimum length of the subarray that ends at i or before that\\n        suffix = [float(\\'inf\\')]*len(arr) # this array stores the minimum length of the subarray that starts at i or after that\\n        \\n        start = 0\\n        currSum = 0\\n        for index in range(len(arr)):\\n            currSum += arr[index]\\n            \\n            while currSum > target:\\n                currSum -= arr[start]\\n                start += 1\\n            \\n            if currSum == target:\\n                # populate prefix and suffix array.\\n                # at this point we are simply storing the values for respective index not minimum\\n                length = index-start+1\\n                prefix[index] = length \\n                suffix[start] = length\\n        \\n        # correcting prefix array\\n        for index in range(1, len(arr)):\\n            prefix[index] = min(prefix[index], prefix[index-1])\\n        \\n        # correcting suffix array\\n        for index in range(len(arr)-2, -1, -1):\\n            suffix[index] = min(suffix[index], suffix[index+1])\\n        \\n        \\n\\t\\t# Working with the idea that a non overlapping subarray lies to right and left of an index, \\n\\t\\t# so we select minimum subarray from the two halves of the array.  \\n        minComb = float(\\'inf\\')\\n        for index in range(1, len(arr)):\\n            minComb = min(minComb, prefix[index-1]+suffix[index])\\n        return minComb if minComb < float(\\'inf\\') else -1",
                "codeTag": "Java"
            },
            {
                "id": 833215,
                "title": "java-o-n-solution-using-prefixsum-and-hashmap",
                "content": "I create a prefixSum array and store the indices of prefixSum with the corresponding index. Then start a search for prefixSum[i] - target and prefixSum[i] + target for each index in prefixSum to find the minimum left and right ranges respectively.\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n\\t\\tint[] prefixSum = new int[arr.length + 1];\\n\\t\\tMap<Integer, Integer> indexMap = new HashMap<>();\\n\\t\\tindexMap.put(0, -1);\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tprefixSum[i + 1] = prefixSum[i] + arr[i];\\n\\t\\t\\tindexMap.put(prefixSum[i + 1], i);\\n\\t\\t}\\n\\n\\t\\tint left = Integer.MAX_VALUE;\\n\\t\\tint right = 0;\\n\\t\\tint result = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < prefixSum.length; i++) {\\n\\t\\t\\tif (indexMap.containsKey(prefixSum[i] - target)) {\\n\\t\\t\\t\\tint prevIdx = indexMap.get(prefixSum[i] - target);\\n\\t\\t\\t\\tleft = Math.min(left, i - prevIdx);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (indexMap.containsKey(prefixSum[i] + target)) {\\n\\t\\t\\t\\tint nextIdx = indexMap.get(prefixSum[i] + target);\\n\\t\\t\\t\\tright = nextIdx - i;\\n\\t\\t\\t\\tif (left != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tresult = Math.min(result, right + left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (result == Integer.MAX_VALUE)\\n\\t\\t\\treturn -1;\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n\\t\\tint[] prefixSum = new int[arr.length + 1];\\n\\t\\tMap<Integer, Integer> indexMap = new HashMap<>();\\n\\t\\tindexMap.put(0, -1);\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tprefixSum[i + 1] = prefixSum[i] + arr[i];\\n\\t\\t\\tindexMap.put(prefixSum[i + 1], i);\\n\\t\\t}\\n\\n\\t\\tint left = Integer.MAX_VALUE;\\n\\t\\tint right = 0;\\n\\t\\tint result = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < prefixSum.length; i++) {\\n\\t\\t\\tif (indexMap.containsKey(prefixSum[i] - target)) {\\n\\t\\t\\t\\tint prevIdx = indexMap.get(prefixSum[i] - target);\\n\\t\\t\\t\\tleft = Math.min(left, i - prevIdx);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (indexMap.containsKey(prefixSum[i] + target)) {\\n\\t\\t\\t\\tint nextIdx = indexMap.get(prefixSum[i] + target);\\n\\t\\t\\t\\tright = nextIdx - i;\\n\\t\\t\\t\\tif (left != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tresult = Math.min(result, right + left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (result == Integer.MAX_VALUE)\\n\\t\\t\\treturn -1;\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790734,
                "title": "python-this-is-what-interviewer-is-expecting-prefix-suffix-array-clean-code",
                "content": "Hint made the solution quite clear, you can get 2 lists that contain prefix shortest lengths and suffix shortest lengths, the result is just simply minimal of sum(prefix[i], suffix[i+1]) for i in [0, n-2]. I don\\'t like those dirty tricks that trying to avoid hashmap, most of those implementations are hard to understand and maintain, I don\\'t expect to see those in my everyday work.\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n\\t    # prefix shortest length read from left to right [3,1,5,2,1]3 -> [1, 1, 1, 1, 1]\\n        leftmin = self.getMinArr(arr, target, True)\\n\\t\\t# suffix shortest length read from right to left [3,1,5,2,1]3 -> [1, 2, 2, 2, max]\\n        rightmin = self.getMinArr(arr, target, False)\\n        res = sys.maxsize\\n        for i in range(0, len(arr) - 1):\\n            if max(leftmin[i], rightmin[i + 1]) != sys.maxsize: # no overlap for i and i + 1\\n                res = min(leftmin[i] + rightmin[i + 1], res)\\n        return res if res < sys.maxsize else -1\\n    \\n    def getMinArr(self, arr: list, target: int, right: bool) -> None:\\n        res = [sys.maxsize] * len(arr)\\n        cursum = 0\\n        nummap = {0: 0}\\n        # if it\\'s reading from right to left, then reverse input array\\n        nums = arr if right else arr[::-1]\\n        for i, num in enumerate(nums):\\n            if i > 0: # min length is the same with previous one before calculation\\n                res[i] = res[i - 1]\\n            cursum += num\\n            if cursum - target in nummap: # get target, calculate minimal length\\n                curlen = i - nummap[cursum - target] + 1\\n                res[i] = min(res[i], curlen)\\n            nummap[cursum] = i + 1\\n        if not right: # reverse result array if it was reading from right to left\\n            res.reverse()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n\\t    # prefix shortest length read from left to right [3,1,5,2,1]3 -> [1, 1, 1, 1, 1]\\n        leftmin = self.getMinArr(arr, target, True)\\n\\t\\t# suffix shortest length read from right to left [3,1,5,2,1]3 -> [1, 2, 2, 2, max]\\n        rightmin = self.getMinArr(arr, target, False)\\n        res = sys.maxsize\\n        for i in range(0, len(arr) - 1):\\n            if max(leftmin[i], rightmin[i + 1]) != sys.maxsize: # no overlap for i and i + 1\\n                res = min(leftmin[i] + rightmin[i + 1], res)\\n        return res if res < sys.maxsize else -1\\n    \\n    def getMinArr(self, arr: list, target: int, right: bool) -> None:\\n        res = [sys.maxsize] * len(arr)\\n        cursum = 0\\n        nummap = {0: 0}\\n        # if it\\'s reading from right to left, then reverse input array\\n        nums = arr if right else arr[::-1]\\n        for i, num in enumerate(nums):\\n            if i > 0: # min length is the same with previous one before calculation\\n                res[i] = res[i - 1]\\n            cursum += num\\n            if cursum - target in nummap: # get target, calculate minimal length\\n                curlen = i - nummap[cursum - target] + 1\\n                res[i] = min(res[i], curlen)\\n            nummap[cursum] = i + 1\\n        if not right: # reverse result array if it was reading from right to left\\n            res.reverse()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740070,
                "title": "c-easy-understand-intuitive-o-n-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int target) {\\n        int n = a.size();\\n        vector<int> s(n+1);\\n        for (int i = 1; i <= n; ++i) s[i] = s[i-1]+a[i-1];\\n        \\n        unordered_map<int, int> m; // map[x,y] that holds sum \\'x\\' is available at index \\'y\\'\\n        m[0] = 0; \\n        const int INF = 1e9;\\n        vector<int> x(n+1, INF), y(n+1, INF);\\n        for (int i = 1; i <= n; ++i)\\n        {\\n            if (m.count(s[i]-target))\\n            {\\n                int tmp = m[s[i]-target]+1;\\n                x[i] = i-tmp+1; // i is ending index\\n                y[tmp] = i-tmp+1; // tmp is starting index\\n            }\\n            m[s[i]] = i;\\n        }\\n        \\n        int ans = INF;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            x[i] = min(x[i], x[i-1]); // min length subarray ending in index i\\n            ans = min(ans, x[i]+y[i+1]); // y[i+1] represents subarray starting from i+1 so that there is no overlap\\n        }\\n        if (ans == INF) ans = -1;\\n        return ans;\\n    }\\n};\\n```\\nUpvote only if it helped, thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int target) {\\n        int n = a.size();\\n        vector<int> s(n+1);\\n        for (int i = 1; i <= n; ++i) s[i] = s[i-1]+a[i-1];\\n        \\n        unordered_map<int, int> m; // map[x,y] that holds sum \\'x\\' is available at index \\'y\\'\\n        m[0] = 0; \\n        const int INF = 1e9;\\n        vector<int> x(n+1, INF), y(n+1, INF);\\n        for (int i = 1; i <= n; ++i)\\n        {\\n            if (m.count(s[i]-target))\\n            {\\n                int tmp = m[s[i]-target]+1;\\n                x[i] = i-tmp+1; // i is ending index\\n                y[tmp] = i-tmp+1; // tmp is starting index\\n            }\\n            m[s[i]] = i;\\n        }\\n        \\n        int ans = INF;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            x[i] = min(x[i], x[i-1]); // min length subarray ending in index i\\n            ans = min(ans, x[i]+y[i+1]); // y[i+1] represents subarray starting from i+1 so that there is no overlap\\n        }\\n        if (ans == INF) ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723145,
                "title": "python-one-pass-using-defaultdict-instead-of-sliding-window",
                "content": "Like most solutions, I basically do this:\\n(1) Maintain a prefix sum and store the last index for the current prefix sum (\"lastSeen\").\\n(2) Use defaultdict (\"minSize\") to store the minimum size of the qualifying subarray up to that point.\\n(3) Update these as well as the result in the loop. Others use the sliding window approach to avoid maintaining the \"lastSeen\" data structure but I find that harder to understand.\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        inf = float(\\'inf\\')\\n        prefix = 0\\n        minSize = defaultdict(lambda: inf)\\n        lastSeen = {0: -1}\\n        result = inf\\n        for i, n in enumerate(arr):\\n            prefix += n\\n            if prefix-target in lastSeen:\\n                j = lastSeen[prefix-target]\\n                result = min(result, i-j + minSize[j])\\n                minSize[i] = min(minSize[i-1], i-j)\\n            else:\\n                minSize[i] = minSize[i-1]\\n            \\n            lastSeen[prefix] = i\\n\\n        return -1 if result == inf else result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        inf = float(\\'inf\\')\\n        prefix = 0\\n        minSize = defaultdict(lambda: inf)\\n        lastSeen = {0: -1}\\n        result = inf\\n        for i, n in enumerate(arr):\\n            prefix += n\\n            if prefix-target in lastSeen:\\n                j = lastSeen[prefix-target]\\n                result = min(result, i-j + minSize[j])\\n                minSize[i] = min(minSize[i-1], i-j)\\n            else:\\n                minSize[i] = minSize[i-1]\\n            \\n            lastSeen[prefix] = i\\n\\n        return -1 if result == inf else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685689,
                "title": "python-3-very-short-o-n",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, a: List[int], targ: int) -> int:\\n        \\n        n = len(a)\\n        d1 = defaultdict(lambda: inf)\\n        ret2 = inf\\n        tot = 0\\n        j = 0\\n        \\n        for i,x in enumerate(a):\\n            \\n            tot += x\\n            \\n            while tot > targ:\\n                tot -= a[j]\\n                j += 1\\n            \\n            sz = i-j+1\\n            \\n            if tot == targ:\\n                d1[i] = sz\\n                ret2 = min(ret2, d1[j-1] + sz)\\n            \\n            d1[i] = min(d1[i], d1[i-1])\\n        \\n        return -1 if ret2 == inf else ret2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, a: List[int], targ: int) -> int:\\n        \\n        n = len(a)\\n        d1 = defaultdict(lambda: inf)\\n        ret2 = inf\\n        tot = 0\\n        j = 0\\n        \\n        for i,x in enumerate(a):\\n            \\n            tot += x\\n            \\n            while tot > targ:\\n                tot -= a[j]\\n                j += 1\\n            \\n            sz = i-j+1\\n            \\n            if tot == targ:\\n                d1[i] = sz\\n                ret2 = min(ret2, d1[j-1] + sz)\\n            \\n            d1[i] = min(d1[i], d1[i-1])\\n        \\n        return -1 if ret2 == inf else ret2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685687,
                "title": "c-o-n-solution-with-helper-arrays-and-explanation",
                "content": "The problem could be splitted in two subproblems:\\n- find all subarrays which sum is equal to target\\n- between the valid subarrays, find the two smalles not overlapping\\n\\nFor the first problem we can easily solve it using the standard approach of prefix sum + helper HashMap with the ending index of previous sums (approach 4 of https://leetcode.com/problems/subarray-sum-equals-k/solution/ )\\nEvery time we have a match we can track that we found a matching array of size X starting at the index L and ending at index R. In the index L and R we can directly store the size. We can then linearly calculate what is the smallest array which ends before or which start after a specific index.\\n\\nFinally we can go over all pair of indexes \\'i\\' and \\'i+1\\', checking the sum of the smallest array which ends before \\'i\\' and which start after \\'i+1\\'. We can do this because we know that they don\\'t overlap\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        unordered_map<int, int> prev;\\n        prev[0] = -1;\\n        int prevVal = 0;\\n        \\n        vector<int> matchLeft(n, n + 1), matchRight(n, n + 1);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // calculate cumulative sum\\n            arr[i] += prevVal;\\n            prevVal = arr[i];\\n            \\n            if (prev.count(arr[i] - target)) {\\n                // subarray sum matches the target\\n                int secondIndex = prev[arr[i] - target];\\n                \\n                // store the shortest matching array ending in \\'i\\'\\n                if (matchLeft[i] > i - secondIndex)\\n                    matchLeft[i] = i - secondIndex;\\n                \\n                // store the shortest matching array starting in \\'secondIndex + 1\\'\\n                if (matchRight[secondIndex + 1] > i - secondIndex)\\n                    matchRight[secondIndex + 1] = i - secondIndex;\\n            }\\n            prev[arr[i]] = i;\\n        }\\n        \\n        // store the shortest matching array after index \\'i\\'\\n        for (int i = n - 2; i >= 0; --i)\\n            matchRight[i] = min(matchRight[i], matchRight[i+1]);\\n        \\n        int ans = n + 1;\\n        int minLeft = matchLeft[0];\\n        \\n        // for each \\'i\\' and \\'i+1\\', calculate the shortest matching array\\n        // which ends before \\'i\\' and the shortest which start after \\'i+1\\'\\n        for (int i = 0; i < n - 1; ++i) {\\n            minLeft = min(minLeft, matchLeft[i]);\\n            ans = min(ans, minLeft + matchRight[i+1]);\\n        }\\n        \\n        if (ans == n + 1)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        unordered_map<int, int> prev;\\n        prev[0] = -1;\\n        int prevVal = 0;\\n        \\n        vector<int> matchLeft(n, n + 1), matchRight(n, n + 1);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // calculate cumulative sum\\n            arr[i] += prevVal;\\n            prevVal = arr[i];\\n            \\n            if (prev.count(arr[i] - target)) {\\n                // subarray sum matches the target\\n                int secondIndex = prev[arr[i] - target];\\n                \\n                // store the shortest matching array ending in \\'i\\'\\n                if (matchLeft[i] > i - secondIndex)\\n                    matchLeft[i] = i - secondIndex;\\n                \\n                // store the shortest matching array starting in \\'secondIndex + 1\\'\\n                if (matchRight[secondIndex + 1] > i - secondIndex)\\n                    matchRight[secondIndex + 1] = i - secondIndex;\\n            }\\n            prev[arr[i]] = i;\\n        }\\n        \\n        // store the shortest matching array after index \\'i\\'\\n        for (int i = n - 2; i >= 0; --i)\\n            matchRight[i] = min(matchRight[i], matchRight[i+1]);\\n        \\n        int ans = n + 1;\\n        int minLeft = matchLeft[0];\\n        \\n        // for each \\'i\\' and \\'i+1\\', calculate the shortest matching array\\n        // which ends before \\'i\\' and the shortest which start after \\'i+1\\'\\n        for (int i = 0; i < n - 1; ++i) {\\n            minLeft = min(minLeft, matchLeft[i]);\\n            ans = min(ans, minLeft + matchRight[i+1]);\\n        }\\n        \\n        if (ans == n + 1)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685682,
                "title": "c-easy-2-pointer-o-n-constant-space-solution-explained",
                "content": "m1 = length of smallest subarray\\nm2= length of 2nd smallest\\nl= length of subarray\\nstart=starting index of current subarray\\nend = ending index of prev subarray +1\\nI am subtracting the current index value from sum which was equal to target. As soon as sum becomes negative I add the initial value of the subarray and decrease the counter l till sum is negative. When sum = 0 if the length of the new subarray is less than m1, I update m1 with l, m2 with m1 and ending of this new subarray with current index i, but if the length of current subarray is greater than m1 but less than m2 I check if the subarrays are overlapping, if not then I update m2.\\nI check for sum =0 condition again outside the loop in case if the last index of array makes the sum =0.\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int target) {\\n        if(a.size()<=1)return -1;\\n        int m1=INT_MAX,m2=INT_MAX,l=0,sum=target,start=0,end=-1;\\n        for(int i=0;i<a.size();i++){\\n            if(sum==0){\\n                if(l<m1){if(start>=end)m2=m1;m1=l;end=i;}\\n                else if(l<m2 && start>=end){m2=l;end=i;}\\n                l--;\\n                sum+=a[start++];\\n            }\\n           sum-=a[i];\\n            l++;\\n            if(sum<0){\\n                while(sum<0){sum+=a[start++];l--;}\\n            }\\n\\n        }\\n         \\n        if(sum==0){\\n                if(l<m1 ){if(start>=end)m2=m1;m1=l;}\\n                else if(l<m2 && start>=end){m2=l;}\\n        }\\n        if(m1==INT_MAX || m2==INT_MAX )return -1;\\n        else return m1+m2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int target) {\\n        if(a.size()<=1)return -1;\\n        int m1=INT_MAX,m2=INT_MAX,l=0,sum=target,start=0,end=-1;\\n        for(int i=0;i<a.size();i++){\\n            if(sum==0){\\n                if(l<m1){if(start>=end)m2=m1;m1=l;end=i;}\\n                else if(l<m2 && start>=end){m2=l;end=i;}\\n                l--;\\n                sum+=a[start++];\\n            }\\n           sum-=a[i];\\n            l++;\\n            if(sum<0){\\n                while(sum<0){sum+=a[start++];l--;}\\n            }\\n\\n        }\\n         \\n        if(sum==0){\\n                if(l<m1 ){if(start>=end)m2=m1;m1=l;}\\n                else if(l<m2 && start>=end){m2=l;}\\n        }\\n        if(m1==INT_MAX || m2==INT_MAX )return -1;\\n        else return m1+m2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685630,
                "title": "java-dp-and-window-sliding-one-pass-o-n-time-easy-to-understand",
                "content": "Borrow the idea from the TreeMap solution. dp[i] stores the length of shortest interval with sum equals to target from index 0 to i. Using slide window to calculate sum of subarray, whenever target is met, use dp to find the min interval not overlapping. At the end of each loop, update dp[i] = min(dp[i], dp[i-1]).\\n\\n```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        int sum = 0;\\n        int i = 0;\\n        int j = 0;\\n        int res = Integer.MAX_VALUE;\\n        while(j < arr.length)\\n        {\\n            sum += arr[j];\\n            while(sum > target)\\n            {\\n                sum -= arr[i];\\n                i++;\\n            }\\n            if(sum == target)\\n            {\\n                if(i-1 >= 0 && dp[i-1] != Integer.MAX_VALUE)\\n                {\\n                    res = Math.min(res, j-i+1 + dp[i-1]); //find non overlap interval before i\\n                }\\n                dp[j] = j-i+1;\\n            }\\n            if(j > 0)\\n                dp[j] = Math.min(dp[j], dp[j-1]); //the min interval until j\\n            j++;\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "Borrow the idea from the TreeMap solution. dp[i] stores the length of shortest interval with sum equals to target from index 0 to i. Using slide window to calculate sum of subarray, whenever target is met, use dp to find the min interval not overlapping. At the end of each loop, update dp[i] = min(dp[i], dp[i-1]).\\n\\n```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        int sum = 0;\\n        int i = 0;\\n        int j = 0;\\n        int res = Integer.MAX_VALUE;\\n        while(j < arr.length)\\n        {\\n            sum += arr[j];\\n            while(sum > target)\\n            {\\n                sum -= arr[i];\\n                i++;\\n            }\\n            if(sum == target)\\n            {\\n                if(i-1 >= 0 && dp[i-1] != Integer.MAX_VALUE)\\n                {\\n                    res = Math.min(res, j-i+1 + dp[i-1]); //find non overlap interval before i\\n                }\\n                dp[j] = j-i+1;\\n            }\\n            if(j > 0)\\n                dp[j] = Math.min(dp[j], dp[j-1]); //the min interval until j\\n            j++;\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 685611,
                "title": "c-concept-and-easy-solution-with-dp",
                "content": "Although I could solve this during contest due to one edge case but I think is the shortest understandable approach.\\n\\nApproach is this:\\n- Keep track of minimum length subarray at each index of the nums\\n- Whenever you find next subarray with sum=target just check if this subarry length plus any previous subarray length can be are our desired result(less than any two subarray sum untill this)\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();        \\n        int res=INT_MAX;       \\n        int i=0,j=0,sum=0;\\n        vector<int> dp(n+1,INT_MAX);  // Just to keep track of minimum subarray untill current index\\n        sum+=arr[0];\\n        j=1;\\n        while(j<=n){         \\n            \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0while(i<j && sum>target){  // Check current windows if sum is greater than target\\n                sum -= arr[i];   //shrink sliding windows\\n                i++;\\n            }\\n            \\n            if(target==sum){    // If current windows sum is target\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(dp[i]!=INT_MAX){ \\xA0  // If  this is atleast 2nd subarray(we already found one subarray with target before)\\n                    int curr = j-i+dp[i]; // length of this windows + length of previous minimum window \\n                    res = min(res, curr);   // Check if these two subarrays are minimum length\\n                }                       \\n                dp[j] = min(j-i, dp[j-1]);  // check minimum subarray length with target at this index               \\n            } else{            \\n                dp[j] = dp[j-1];   // If current windows sum is not target and minimum subarray untill now is just like previous index\\n            }        \\n            \\n            if(j==n) break;\\n            \\n            sum+=arr[j];\\n            j++;\\n        }       \\n        if(res<=100000)   \\n            return res;\\n        return -1;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();        \\n        int res=INT_MAX;       \\n        int i=0,j=0,sum=0;\\n        vector<int> dp(n+1,INT_MAX);  // Just to keep track of minimum subarray untill current index\\n        sum+=arr[0];\\n        j=1;\\n        while(j<=n){         \\n            \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0while(i<j && sum>target){  // Check current windows if sum is greater than target\\n                sum -= arr[i];   //shrink sliding windows\\n                i++;\\n            }\\n            \\n            if(target==sum){    // If current windows sum is target\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(dp[i]!=INT_MAX){ \\xA0  // If  this is atleast 2nd subarray(we already found one subarray with target before)\\n                    int curr = j-i+dp[i]; // length of this windows + length of previous minimum window \\n                    res = min(res, curr);   // Check if these two subarrays are minimum length\\n                }                       \\n                dp[j] = min(j-i, dp[j-1]);  // check minimum subarray length with target at this index               \\n            } else{            \\n                dp[j] = dp[j-1];   // If current windows sum is not target and minimum subarray untill now is just like previous index\\n            }        \\n            \\n            if(j==n) break;\\n            \\n            sum+=arr[j];\\n            j++;\\n        }       \\n        if(res<=100000)   \\n            return res;\\n        return -1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685538,
                "title": "c-o-n-dp-and-prefix-sum-solution-one-pass",
                "content": "For each element ``` arr[i] ```, use prefix-sum to find if a valid subarray exists ending at ```i```. If yes, it will start at ```j = index[sum-target]```, where ```sum``` is the running total. Simply find the length of the shortest valid subarray before the start of this subarray, ```minDP[j]``` and add it to the length of the current valid array, ``` dp[i] = i-j ```. Keep track of the minimum sum of these two lengths.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n); // dp[i]: length of valid subarray ending at i\\n        vector<int> minDP(n); // minDP[i]: length of shortest valid subarray till i\\n        unordered_map<int,int> index;  // maps running total to index\\n        int mindp = INT_MAX,ans = INT_MAX,sum = 0;\\n        index[sum] = -1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(index.find(sum-target)!=index.end()){ // valid subarray\\n\\t\\t\\t\\tint j = index[sum-target];\\n                dp[i] = i-j; // length of current subarray\\n                if(j>=0 && minDP[j]!=INT_MAX) \\n                    ans = min(ans, dp[i]+minDP[j]);\\n            }\\n            else dp[i] = INT_MAX; // invalid subarray\\n            mindp = min(mindp,dp[i]);\\n            minDP[i] = mindp;\\n            index[sum] = i;\\n        }\\n        return ans==INT_MAX? -1:ans;\\n    }\\n};\\n```\\n\\nTime - ```O(n)```\\nSpace - ```O(n)```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "``` arr[i] ```\n```i```\n```j = index[sum-target]```\n```sum```\n```minDP[j]```\n``` dp[i] = i-j ```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n); // dp[i]: length of valid subarray ending at i\\n        vector<int> minDP(n); // minDP[i]: length of shortest valid subarray till i\\n        unordered_map<int,int> index;  // maps running total to index\\n        int mindp = INT_MAX,ans = INT_MAX,sum = 0;\\n        index[sum] = -1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(index.find(sum-target)!=index.end()){ // valid subarray\\n\\t\\t\\t\\tint j = index[sum-target];\\n                dp[i] = i-j; // length of current subarray\\n                if(j>=0 && minDP[j]!=INT_MAX) \\n                    ans = min(ans, dp[i]+minDP[j]);\\n            }\\n            else dp[i] = INT_MAX; // invalid subarray\\n            mindp = min(mindp,dp[i]);\\n            minDP[i] = mindp;\\n            index[sum] = i;\\n        }\\n        return ans==INT_MAX? -1:ans;\\n    }\\n};\\n```\n```O(n)```\n```O(n)```",
                "codeTag": "Java"
            },
            {
                "id": 685418,
                "title": "java-heap-correct-for-given-cases-feel-free-to-modify-to-run-all-test-case",
                "content": "\\nfind all subarrays with given sum. and add it to heap ( sorted according to the length of subarray).\\ntake 2 subarrays out. if they overlap. insert min one and continue till u get result.\\n\\n**doesnt work for test cases where u need to not put min back inside the heap.**\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n       \\n        Queue<int[]> q = new PriorityQueue<>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] x, int[] y)\\n            {\\n                return x[0]-y[0];\\n            }\\n        });\\n        int sum =0;\\n        m.put(0,-1);\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            sum +=arr[i];\\n            if(m.containsKey(sum-target))\\n            {\\n                \\n                q.add(new int[]{i-m.get(sum-target) , i});\\n            }\\n            m.put(sum, i);\\n        }\\n        while(q.size()>1)\\n        {\\n            int x[] = q.poll();\\n            int y[] = q.poll();\\n            if(overlap(x,y))\\n                q.add(x);\\n            else\\n                return x[0]+y[0];\\n        }\\n        return -1;\\n    }\\n    boolean overlap(int x[], int[] y)\\n    {\\n        if(x[1]<=y[1]-y[0])\\n            return false;\\n        if(y[1]<=x[1]-x[0])\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n       \\n        Queue<int[]> q = new PriorityQueue<>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] x, int[] y)\\n            {\\n                return x[0]-y[0];\\n            }\\n        });\\n        int sum =0;\\n        m.put(0,-1);\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            sum +=arr[i];\\n            if(m.containsKey(sum-target))\\n            {\\n                \\n                q.add(new int[]{i-m.get(sum-target) , i});\\n            }\\n            m.put(sum, i);\\n        }\\n        while(q.size()>1)\\n        {\\n            int x[] = q.poll();\\n            int y[] = q.poll();\\n            if(overlap(x,y))\\n                q.add(x);\\n            else\\n                return x[0]+y[0];\\n        }\\n        return -1;\\n    }\\n    boolean overlap(int x[], int[] y)\\n    {\\n        if(x[1]<=y[1]-y[0])\\n            return false;\\n        if(y[1]<=x[1]-x[0])\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685380,
                "title": "java-sliding-window-and-check-overlap-interval",
                "content": "**Modify the code to handle failed cases**\\n\\n\\nBasica idea is using sliding window and check for the intervals sum to target.\\nBut we may face some interval are overlapped. \\nSo we could matain the heap to check for overlapped intervals and select two non-overlapped interval that has least range.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int left = 0;\\n        int sum = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        for (int right = 0; right < arr.length; right++) {\\n            sum += arr[right];         \\n            while (sum > target) {\\n                sum -= arr[left];\\n                left++;\\n            }\\n            if (sum == target) {\\n                int[] interval = {left, right, right - left + 1};\\n                pq.offer(interval);\\n            }\\n        }\\n        \\n        if (pq.size() < 2) {\\n            return -1;\\n        }\\n \\n\\n        int res = Integer.MAX_VALUE;\\n        int[] first = pq.poll();\\n        PriorityQueue<int[]> conflictedPq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        \\n        while (!pq.isEmpty()) {\\n            int s = first[2];\\n            int[] cur = pq.poll();\\n\\n            //check overlap, non overlap, possible solution;\\n            boolean find = false;\\n            if (cur[0] > first[1] || cur[1] < first[0]) {\\n                s += cur[2];\\n                res = Math.min(res, s);\\n                find = true;\\n            }\\n            else {\\n                // overlapped, those overlapped conflict with the selected smaller range, could also form possible solutions\\n                conflictedPq.offer(cur);\\n            }\\n            \\n            if (find || pq.isEmpty()) {\\n                pq = conflictedPq;\\n                conflictedPq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n                first = pq.poll();\\n            }\\n\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int left = 0;\\n        int sum = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        for (int right = 0; right < arr.length; right++) {\\n            sum += arr[right];         \\n            while (sum > target) {\\n                sum -= arr[left];\\n                left++;\\n            }\\n            if (sum == target) {\\n                int[] interval = {left, right, right - left + 1};\\n                pq.offer(interval);\\n            }\\n        }\\n        \\n        if (pq.size() < 2) {\\n            return -1;\\n        }\\n \\n\\n        int res = Integer.MAX_VALUE;\\n        int[] first = pq.poll();\\n        PriorityQueue<int[]> conflictedPq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        \\n        while (!pq.isEmpty()) {\\n            int s = first[2];\\n            int[] cur = pq.poll();\\n\\n            //check overlap, non overlap, possible solution;\\n            boolean find = false;\\n            if (cur[0] > first[1] || cur[1] < first[0]) {\\n                s += cur[2];\\n                res = Math.min(res, s);\\n                find = true;\\n            }\\n            else {\\n                // overlapped, those overlapped conflict with the selected smaller range, could also form possible solutions\\n                conflictedPq.offer(cur);\\n            }\\n            \\n            if (find || pq.isEmpty()) {\\n                pq = conflictedPq;\\n                conflictedPq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n                first = pq.poll();\\n            }\\n\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685324,
                "title": "python-prefix-sums-heap-passes-given-test-cases-feel-free-to-modify-to-run-all-test-cases",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        heap = []\\n        prefix_sum = {}\\n        prefix_sum[0] = -1\\n        curr_sum = 0\\n        for i in range(n): \\n            curr_sum += arr[i]\\n            if prefix_sum.get(curr_sum - target):\\n                heapq.heappush(heap,(i - prefix_sum.get(curr_sum - target), i))\\n            prefix_sum[curr_sum] = i\\n                \\n        while len(heap) > 1:\\n            len1, end1 = heapq.heappop(heap)\\n            len2, end2 = heapq.heappop(heap)\\n            if end1 <= end2 - len2 or end2 <= end1 - len1:    \\n                return len1 + len2\\n            else:    # overlap\\n                heapq.heappush(heap, (len1, end1))\\n                \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        heap = []\\n        prefix_sum = {}",
                "codeTag": "Java"
            },
            {
                "id": 3915250,
                "title": "prefix-sum-application",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int t) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        mp[0] = -1;\\n        int sum = 0;\\n        int lsz = INT_MAX;\\n        int res = INT_MAX;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=a[i];\\n            mp[sum] = i; \\n        }\\n        \\n        sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=a[i];\\n            if(mp.find(sum-t)!=mp.end())\\n            {\\n                lsz = min(lsz,i-mp[sum-t]);\\n            }\\n            \\n            \\n            if(mp.find(sum+t)!=mp.end() && lsz !=INT_MAX)\\n            {\\n                res = min(res,mp[sum+t]-i + lsz );\\n            }\\n        }\\n        \\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int t) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        mp[0] = -1;\\n        int sum = 0;\\n        int lsz = INT_MAX;\\n        int res = INT_MAX;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=a[i];\\n            mp[sum] = i; \\n        }\\n        \\n        sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=a[i];\\n            if(mp.find(sum-t)!=mp.end())\\n            {\\n                lsz = min(lsz,i-mp[sum-t]);\\n            }\\n            \\n            \\n            if(mp.find(sum+t)!=mp.end() && lsz !=INT_MAX)\\n            {\\n                res = min(res,mp[sum+t]-i + lsz );\\n            }\\n        }\\n        \\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555848,
                "title": "c-python-prefix-sum-dynamic-programming-solution-with-explanation",
                "content": "First, we can use prefix sum to find left side of array whose right side is at current number and sum is equal to ```target```.\\nThe problem is how to find another array is not overlapped with this array and sum of two array length is the shortest.\\n```dp[i]``` is length of shortest array whose sum is equal to ```target``` before location ```i```.\\nSo, if we find a array whose sum is equal to ```target```, ```dp[i] = min(dp[i-1], length)``` else ```dp[i] = dp[i-1]```\\n\\nThe key is ```dp```, if current number is right side of array whose sum is equal to ```target```, one array length is ``` current index - prefix[cur sum - target]```, another array should be before location ```prefix[cur sum - target] + 1```, so its length is ```dp[prefix[cur sum - target]]```, so two array length is ```current index - prefix[cur sum - target] + dp[prefix[cur sum - target]]```, and track the shortest length is the answer.\\n\\ne.g. ```[1,1,1,2,1,1,1], target = 3```\\n```\\nprefix is a mapping from current sum to index.\\nidx     -1 0 1 2 3 4 5 6\\n         x 1 1 2 1 1 1 3\\nsum      0 1 2 4 5 6 7 10\\ndp[idx]  m m m 2 2 2 2 1\\nans      m m m m m m 5 3\\n\\nAt arr[5] = 1, current sum is 7, 7 - 3 = 4 in prefix, prefix[4] is 2 which means arr[3~5] is one of both array\\nlength of array whose right side at nums[5] is 5 - prefix[4](=index 2) = 3,\\nanother array should be before index 3, so length of another array is dp[2] = dp[prefix[4]] = dp[prefix[current sum - target]].\\n\\n```\\ntc is O(n), sc is O(n)\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int ans = 2 * arr.size(), cur = 0;\\n        vector<int> dp (arr.size() + 1, 2 * arr.size());  // because of dp[i-1], add a trivail value be index -1\\n        unordered_map<int, int> prefix;\\n        prefix[0] = -1;\\n        for (int i = 0, leng; i < arr.size(); i+=1) {\\n            cur += arr[i];\\n            if (prefix.count(cur - target) != 0) {\\n                leng = i - prefix[cur - target];\\n                dp[i+1] = min(dp[i], leng);\\n                ans = min(ans, leng + dp[prefix[cur - target] + 1]);\\n                \\n            } else dp[i+1] = dp[i];\\n            prefix[cur] = i;\\n        }\\n        return ans != 2 * arr.size()? ans :-1;\\n    }\\n};\\n\\n```\\n### python\\n```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = {0: -1}\\n        ans = 2 * len(arr)\\n        cur = 0 # current sum\\n        dp = [2 * len(arr)] * (len(arr) + 1) # because of dp[i-1], add a trivail value be index -1\\n        for idx, n in enumerate(arr):\\n            cur += n\\n            if cur - target in prefix:\\n                leng = idx - prefix[cur - target]\\n                dp[idx+1] = min(dp[idx], leng)\\n                ans = min(ans, leng + dp[prefix[cur - target] + 1])\\n            else: dp[idx+1] = dp[idx]\\n            prefix[cur] = idx\\n        return ans if ans != 2 * len(arr) else -1\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```target```\n```dp[i]```\n```target```\n```i```\n```target```\n```dp[i] = min(dp[i-1], length)```\n```dp[i] = dp[i-1]```\n```dp```\n```target```\n``` current index - prefix[cur sum - target]```\n```prefix[cur sum - target] + 1```\n```dp[prefix[cur sum - target]]```\n```current index - prefix[cur sum - target] + dp[prefix[cur sum - target]]```\n```[1,1,1,2,1,1,1], target = 3```\n```\\nprefix is a mapping from current sum to index.\\nidx     -1 0 1 2 3 4 5 6\\n         x 1 1 2 1 1 1 3\\nsum      0 1 2 4 5 6 7 10\\ndp[idx]  m m m 2 2 2 2 1\\nans      m m m m m m 5 3\\n\\nAt arr[5] = 1, current sum is 7, 7 - 3 = 4 in prefix, prefix[4] is 2 which means arr[3~5] is one of both array\\nlength of array whose right side at nums[5] is 5 - prefix[4](=index 2) = 3,\\nanother array should be before index 3, so length of another array is dp[2] = dp[prefix[4]] = dp[prefix[current sum - target]].\\n\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int ans = 2 * arr.size(), cur = 0;\\n        vector<int> dp (arr.size() + 1, 2 * arr.size());  // because of dp[i-1], add a trivail value be index -1\\n        unordered_map<int, int> prefix;\\n        prefix[0] = -1;\\n        for (int i = 0, leng; i < arr.size(); i+=1) {\\n            cur += arr[i];\\n            if (prefix.count(cur - target) != 0) {\\n                leng = i - prefix[cur - target];\\n                dp[i+1] = min(dp[i], leng);\\n                ans = min(ans, leng + dp[prefix[cur - target] + 1]);\\n                \\n            } else dp[i+1] = dp[i];\\n            prefix[cur] = i;\\n        }\\n        return ans != 2 * arr.size()? ans :-1;\\n    }\\n};\\n\\n```\n```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = {0: -1}\\n        ans = 2 * len(arr)\\n        cur = 0 # current sum\\n        dp = [2 * len(arr)] * (len(arr) + 1) # because of dp[i-1], add a trivail value be index -1\\n        for idx, n in enumerate(arr):\\n            cur += n\\n            if cur - target in prefix:\\n                leng = idx - prefix[cur - target]\\n                dp[idx+1] = min(dp[idx], leng)\\n                ans = min(ans, leng + dp[prefix[cur - target] + 1])\\n            else: dp[idx+1] = dp[idx]\\n            prefix[cur] = idx\\n        return ans if ans != 2 * len(arr) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392189,
                "title": "hashmap-with-o-n-time",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n\\n        int sum = 0;\\n\\n        // first mapping all the prefix sum indices\\n        for(int i=0;i<n;i++) {\\n            sum += arr[i];\\n            mp[sum] = i;\\n        }\\n\\n        int len1 = INT_MAX, res = INT_MAX;\\n        sum = 0;\\n        // the basic idea is to get the target sum with minimum length subarray from current index to left and right\\n        for(int i=0;i<n;i++) {\\n            sum += arr[i];\\n\\n            if(mp.find(sum-target) != mp.end()) {       // to the left\\n                len1 = min(len1,i-mp[sum-target]);\\n            }\\n\\n            if(mp.find(sum+target) != mp.end() && len1 != INT_MAX) {     // to the right\\n                int len2 = mp[sum+target]-i;\\n                res = min(res, len1+len2);       // also need to check whether len != INT_MAX bcz, we haven\\'t even got the target sum on the left and we are looking for right(we have to find two subarrays so left would be the first priority) \\n            }\\n\\n        }\\n        return (res == INT_MAX?-1:res);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n\\n        int sum = 0;\\n\\n        // first mapping all the prefix sum indices\\n        for(int i=0;i<n;i++) {\\n            sum += arr[i];\\n            mp[sum] = i;\\n        }\\n\\n        int len1 = INT_MAX, res = INT_MAX;\\n        sum = 0;\\n        // the basic idea is to get the target sum with minimum length subarray from current index to left and right\\n        for(int i=0;i<n;i++) {\\n            sum += arr[i];\\n\\n            if(mp.find(sum-target) != mp.end()) {       // to the left\\n                len1 = min(len1,i-mp[sum-target]);\\n            }\\n\\n            if(mp.find(sum+target) != mp.end() && len1 != INT_MAX) {     // to the right\\n                int len2 = mp[sum+target]-i;\\n                res = min(res, len1+len2);       // also need to check whether len != INT_MAX bcz, we haven\\'t even got the target sum on the left and we are looking for right(we have to find two subarrays so left would be the first priority) \\n            }\\n\\n        }\\n        return (res == INT_MAX?-1:res);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250804,
                "title": "easy-c-solution-in-o-n-using-dp-and-prefix-sum",
                "content": "# Intuition\\nThe prefix-sum is used to calculate the valid subarays. The `dp[i]` stores the minimum length valid subarray till index `i`. \\n\\n# Approach\\nOn every iteration, find the running sum (`prefix sum`). If there exists `s-target` already, means that the subarray between `m[s-target] + 1` and till `i` has a sum of `target`. We\\'ll then mark this as a valid subarray. Now, for this valid subarray, let `j` be the starting index. If there exists any valid subarray till `j-1`, we may have a result. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n- Space complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size(), s = 0,result = INT_MAX;;\\n        vector<int> dp(n, INT_MAX);     //len of smallest valid subarray ending at i\\n        \\n        unordered_map<int,int> m;\\n        m[0] = -1;\\n        for(int i=0;i<n;i++){\\n            s += arr[i];\\n            if(m.find(s-target) != m.end()){\\n                int j = m[s-target] + 1;\\n                dp[i] = i - (j) + 1;\\n\\n                //we also have a previous array\\n                if(j> 0 && dp[j - 1] != INT_MAX){\\n                    result = min(result, dp[j-1] + dp[i]);\\n                }\\n            }\\n\\n            if(i > 0){dp[i] = min(dp[i], dp[i-1]);}\\n            m[s] = i;\\n        }        \\n        \\n        return result == INT_MAX ? -1 : result;\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size(), s = 0,result = INT_MAX;;\\n        vector<int> dp(n, INT_MAX);     //len of smallest valid subarray ending at i\\n        \\n        unordered_map<int,int> m;\\n        m[0] = -1;\\n        for(int i=0;i<n;i++){\\n            s += arr[i];\\n            if(m.find(s-target) != m.end()){\\n                int j = m[s-target] + 1;\\n                dp[i] = i - (j) + 1;\\n\\n                //we also have a previous array\\n                if(j> 0 && dp[j - 1] != INT_MAX){\\n                    result = min(result, dp[j-1] + dp[i]);\\n                }\\n            }\\n\\n            if(i > 0){dp[i] = min(dp[i], dp[i-1]);}\\n            m[s] = i;\\n        }        \\n        \\n        return result == INT_MAX ? -1 : result;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697518,
                "title": "python-prefix-sum-solution-min-heap-leetcode-2054",
                "content": "```\\ndef minSumOfLengths(self, arr: List[int], t: int) -> int:\\n\\tpsum = list(accumulate(arr))\\n\\tmp, cans = {0:-1}, []\\n\\tfor i in range(len(psum)):\\n\\t\\tx = psum[i]-t\\n\\t\\tif x in mp:\\n\\t\\t\\tcans.append([mp[x], i])\\n\\t\\tmp[psum[i]] = i\\n\\n\\tq, cur, ans = [], len(arr)+10, len(arr)+10\\n\\tfor s, e in cans:\\n\\t\\twhile(q and q[0][0]<=s):\\n\\t\\t\\tcur = min(cur, heappop(q)[1])\\n\\t\\tans = min(ans, cur+(e-s))\\n\\t\\theappush(q, (e, e-s))\\n\\treturn ans if ans<=len(arr) else -1\\n```\\nSimilar problem:\\n[2054. Two Best Non-Overlapping Events](https://leetcode.com/problems/two-best-non-overlapping-events/discuss/2693097/Python-solution-or-sort-%2B-minheap)",
                "solutionTags": [],
                "code": "```\\ndef minSumOfLengths(self, arr: List[int], t: int) -> int:\\n\\tpsum = list(accumulate(arr))\\n\\tmp, cans = {0:-1}, []\\n\\tfor i in range(len(psum)):\\n\\t\\tx = psum[i]-t\\n\\t\\tif x in mp:\\n\\t\\t\\tcans.append([mp[x], i])\\n\\t\\tmp[psum[i]] = i\\n\\n\\tq, cur, ans = [], len(arr)+10, len(arr)+10\\n\\tfor s, e in cans:\\n\\t\\twhile(q and q[0][0]<=s):\\n\\t\\t\\tcur = min(cur, heappop(q)[1])\\n\\t\\tans = min(ans, cur+(e-s))\\n\\t\\theappush(q, (e, e-s))\\n\\treturn ans if ans<=len(arr) else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2531231,
                "title": "c-memoization-dp-binary-search-prefix-sum",
                "content": "```\\n#define ll long long int\\n    int t[100005][3] ;\\n    ll compute(vector<ll>&presum , ll target , int id  , ll k , int n){\\n        if(k == 0){\\n            return 0 ;\\n        }\\n        if(id >= n){\\n            return INT_MAX ;\\n        }\\n        if(t[id][k] != -1){\\n            return t[id][k] ;\\n        }\\n        ll ans = compute(presum , target , id+1 , k , n) ;\\n        auto lb = lower_bound(presum.begin() , presum.end() , presum[id-1] + target) ;\\n        if(lb != presum.end() && *lb == presum[id-1] + target){\\n            int pos = lb - presum.begin() ;\\n            ans = min(ans , pos-id+1 + compute(presum , target , pos+1 , k-1 , n)) ;\\n        }\\n        return t[id][k] = ans ;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n= arr.size() ;\\n        \\n        memset(t , -1 , sizeof(t)) ;\\n        vector<ll>presum(n+1,0) ;\\n        for(int i = 1 ; i<=n; i++){\\n            presum[i] = presum[i-1] + arr[i-1] ;\\n        }\\n        ll ans = compute(presum , target , 1 , 2 , n+1) ;\\n        if(ans >= INT_MAX){\\n            return -1 ;\\n        }\\n        return ans ;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long int\\n    int t[100005][3] ;\\n    ll compute(vector<ll>&presum , ll target , int id  , ll k , int n){\\n        if(k == 0){\\n            return 0 ;\\n        }\\n        if(id >= n){\\n            return INT_MAX ;\\n        }\\n        if(t[id][k] != -1){\\n            return t[id][k] ;\\n        }\\n        ll ans = compute(presum , target , id+1 , k , n) ;\\n        auto lb = lower_bound(presum.begin() , presum.end() , presum[id-1] + target) ;\\n        if(lb != presum.end() && *lb == presum[id-1] + target){\\n            int pos = lb - presum.begin() ;\\n            ans = min(ans , pos-id+1 + compute(presum , target , pos+1 , k-1 , n)) ;\\n        }\\n        return t[id][k] = ans ;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n= arr.size() ;\\n        \\n        memset(t , -1 , sizeof(t)) ;\\n        vector<ll>presum(n+1,0) ;\\n        for(int i = 1 ; i<=n; i++){\\n            presum[i] = presum[i-1] + arr[i-1] ;\\n        }\\n        ll ans = compute(presum , target , 1 , 2 , n+1) ;\\n        if(ans >= INT_MAX){\\n            return -1 ;\\n        }\\n        return ans ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369685,
                "title": "beats-100-percent-cpp-solutions-very-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int target) {\\n        int pre =0;\\n        int n=nums.size();\\n        vector<pair<int,int>>st;\\n        unordered_map<int,int>m;\\n      \\n        for(int i=0;i<n;i++){\\n            pre+=nums[i];\\n            if(pre==target){\\n                 st.push_back({0,i});\\n            }\\n            if(m.find(pre-target)!=m.end()){\\n                st.push_back({m[pre-target]+1,i});\\n            }\\n            m[pre]=i;\\n        }\\n        if(st.size()==0)return -1;\\n        int res=1e9;\\n        sort(st.begin(),st.end());\\n        vector<int>mini(st.size(),-1);\\n        mini[st.size()-1]=abs(st[st.size()-1].first-st[st.size()-1].second)+1;\\n        for(int i=st.size()-2;i>=0;i--)\\n        {\\n            mini[i]=min(mini[i+1],abs(st[i].first-st[i].second)+1);\\n        }\\n       \\n        for(int i =0;i<st.size()-1;i++){\\n            int l=i+1;\\n            int h =st.size()-1;\\n            int pos =-1;\\n            while(h>=l)\\n            {\\n                int mid=(l+h)/2;\\n                if(st[mid].first>st[i].second){\\n                    pos=mid;\\n                    h=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            if(pos!=-1){\\n                res=min(res,mini[pos]+abs(st[i].first-st[i].second)+1);\\n            }\\n        }\\n        if(res==1e9)return -1;\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int target) {\\n        int pre =0;\\n        int n=nums.size();\\n        vector<pair<int,int>>st;\\n        unordered_map<int,int>m;\\n      \\n        for(int i=0;i<n;i++){\\n            pre+=nums[i];\\n            if(pre==target){\\n                 st.push_back({0,i}",
                "codeTag": "Java"
            },
            {
                "id": 2345696,
                "title": "c-sliding-window-binary-search-preprocessing",
                "content": "* Solution consists mainly of 3 parts.\\n\\n* **Part-1** Using sliding window, get all intervals where `sum == tagret` . `iv` stores `[s,e]` , where interval `summation [s,e]` `== target`.\\n\\n* **Part-2** Get Minimum length of each interval starting from right hand side and store the current minimum length at each index. This vector helps in choosing the optimal second subarray in **part 3**\\n\\n* **Part-3** Pick index `i` as first subarray. To find other subarray length, Find upper bound of ending point of first interval, which is done by `upper_bound` function. At that index `idx`, every subarray after `idx` is good to pick for second subarry. But we want the one with min length. **minLen is pre calculated** which gets us our second subarray in O(1) time.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int target) {\\n\\t//This part of code inserts every interval which sums up to target\\n        vector<array<int,2>> iv ;\\n        for(int s = 0, e = 0 , sum = 0 ; e < nums.size() ; ++e){\\n            sum += nums[e] ;\\n            while(sum > target) sum -= nums[s++];\\n            if(sum == target) iv.push_back({s,e}) ;\\n        }\\n        \\n\\t\\t// In interval , Store minimum upto index say i, from right to left\\n        vector<int> minLen ;\\n        for(int i = iv.size() - 1 ; i >= 0 ; --i ){\\n            if(minLen.empty()) minLen.push_back(iv[i][1] - iv[i][0] + 1) ;\\n            else minLen.push_back(min(minLen.back(),iv[i][1]-iv[i][0] + 1));\\n        }\\n        \\n        reverse(begin(minLen),end(minLen)) ;\\n        \\n\\t\\t//choose index i as first subarray and search for other subarray using binary search and take minimum.\\n        int mini = INT_MAX ;\\n        for(int i = 0 ; i < iv.size() ; ++i ){\\n            int l = iv[i][1] ;\\n            int idx = upper_bound(begin(iv) + i + 1,end(iv),array<int,2>{l,INT_MAX}) - begin(iv) ;\\n            if(idx < iv.size()) mini = min(mini,iv[i][1] - iv[i][0] + 1 + minLen[idx]) ;\\n        }\\n        return mini == INT_MAX ? -1 : mini ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int target) {\\n\\t//This part of code inserts every interval which sums up to target\\n        vector<array<int,2>> iv ;\\n        for(int s = 0, e = 0 , sum = 0 ; e < nums.size() ; ++e){\\n            sum += nums[e] ;\\n            while(sum > target) sum -= nums[s++];\\n            if(sum == target) iv.push_back({s,e}) ;\\n        }\\n        \\n\\t\\t// In interval , Store minimum upto index say i, from right to left\\n        vector<int> minLen ;\\n        for(int i = iv.size() - 1 ; i >= 0 ; --i ){\\n            if(minLen.empty()) minLen.push_back(iv[i][1] - iv[i][0] + 1) ;\\n            else minLen.push_back(min(minLen.back(),iv[i][1]-iv[i][0] + 1));\\n        }\\n        \\n        reverse(begin(minLen),end(minLen)) ;\\n        \\n\\t\\t//choose index i as first subarray and search for other subarray using binary search and take minimum.\\n        int mini = INT_MAX ;\\n        for(int i = 0 ; i < iv.size() ; ++i ){\\n            int l = iv[i][1] ;\\n            int idx = upper_bound(begin(iv) + i + 1,end(iv),array<int,2>{l,INT_MAX}) - begin(iv) ;\\n            if(idx < iv.size()) mini = min(mini,iv[i][1] - iv[i][0] + 1 + minLen[idx]) ;\\n        }\\n        return mini == INT_MAX ? -1 : mini ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214284,
                "title": "o-n-time-o-n-space-a-little-more-intuitive",
                "content": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        running_sum = 0\\n        h = {}\\n        h[0] = -1\\n        min_at_index = [float(inf)]*len(arr)\\n        global_min = inf\\n        for i,v in enumerate(arr):\\n            \\n            running_sum += v\\n            \\n            if running_sum - target in h.keys():\\n                #inclusive start_index\\n                start_index = h[running_sum - target] + 1\\n                curr_length = i - start_index + 1\\n                \\n                global_min = min(curr_length + min_at_index[start_index-1],global_min)\\n                min_at_index[i] = min(min_at_index[i-1],curr_length)\\n            else:\\n                min_at_index[i] = min_at_index[i - 1]\\n                \\n            h[running_sum] = i\\n            \\n        if global_min == inf:\\n            return -1\\n        \\n        return global_min",
                "solutionTags": [],
                "code": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        running_sum = 0\\n        h = {}",
                "codeTag": "Java"
            },
            {
                "id": 2183623,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int left[n], right[n];\\n        unordered_map<int, int> lft;\\n        unordered_map<int, int> rht;\\n        int mod = 1e8+1;\\n        lft[0] = -1;\\n        rht[0] = n;\\n        int prfx = arr[0];\\n        lft[prfx] = 0;\\n        if(prfx == target)\\n            left[0] = 1;\\n        else\\n            left[0] = mod;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prfx += arr[i];\\n            if(lft.count(prfx-target))\\n            {\\n                left[i] = min(left[i-1],i-lft[prfx-target]);\\n            }\\n            else\\n            {\\n                left[i] = left[i-1];\\n            }\\n            lft[prfx] = i;\\n        }\\n        prfx = arr[n-1];\\n        rht[prfx] = n-1;\\n        if(prfx == target)\\n            right[n-1] = 1;\\n        else\\n            right[n-1] = mod;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            prfx += arr[i];\\n            if(rht.count(prfx-target))\\n            {\\n                right[i] = min(right[i+1],rht[prfx-target]-i);\\n            }\\n            else\\n            {\\n                right[i] = right[i+1];\\n            }\\n            rht[prfx] = i;\\n        }\\n        // for(int i = 0; i < n; i++)\\n        // {\\n        //     cout << left[i] << \" \";\\n        // }\\n        int ans = mod;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int v;\\n            if(left[i-1] == mod || right[i] == mod)\\n                v = mod;\\n            else\\n            {\\n                v = left[i-1]+right[i];\\n            }\\n            //cout << v << \" \";\\n            ans = min(v, ans);\\n        }\\n        if(ans == mod) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int left[n], right[n];\\n        unordered_map<int, int> lft;\\n        unordered_map<int, int> rht;\\n        int mod = 1e8+1;\\n        lft[0] = -1;\\n        rht[0] = n;\\n        int prfx = arr[0];\\n        lft[prfx] = 0;\\n        if(prfx == target)\\n            left[0] = 1;\\n        else\\n            left[0] = mod;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prfx += arr[i];\\n            if(lft.count(prfx-target))\\n            {\\n                left[i] = min(left[i-1],i-lft[prfx-target]);\\n            }\\n            else\\n            {\\n                left[i] = left[i-1];\\n            }\\n            lft[prfx] = i;\\n        }\\n        prfx = arr[n-1];\\n        rht[prfx] = n-1;\\n        if(prfx == target)\\n            right[n-1] = 1;\\n        else\\n            right[n-1] = mod;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            prfx += arr[i];\\n            if(rht.count(prfx-target))\\n            {\\n                right[i] = min(right[i+1],rht[prfx-target]-i);\\n            }\\n            else\\n            {\\n                right[i] = right[i+1];\\n            }\\n            rht[prfx] = i;\\n        }\\n        // for(int i = 0; i < n; i++)\\n        // {\\n        //     cout << left[i] << \" \";\\n        // }\\n        int ans = mod;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int v;\\n            if(left[i-1] == mod || right[i] == mod)\\n                v = mod;\\n            else\\n            {\\n                v = left[i-1]+right[i];\\n            }\\n            //cout << v << \" \";\\n            ans = min(v, ans);\\n        }\\n        if(ans == mod) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2111188,
                "title": "python3-sliding-window-based-solution",
                "content": "```\\n\"\"\"https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/\"\"\"\\n\\n\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        left, partial_sum, min_len = 0, 0, float(\\'inf\\')\\n        # records the smallest length of subarry with target sum until index i\\n        min_so_far = [float(\\'inf\\')] * len(arr)\\n        for right, num in enumerate(arr):\\n            partial_sum += num\\n            while partial_sum > target:\\n                partial_sum -= arr[left]\\n                left += 1\\n            if partial_sum == target:\\n                curr_len = right - left + 1\\n                min_len = min(min_len, curr_len + min_so_far[left - 1])\\n                min_so_far[right] = min(curr_len, min_so_far[right - 1])\\n            else:\\n                min_so_far[right] = min_so_far[right - 1]\\n        return min_len if min_len < float(\\'inf\\') else -1\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/\"\"\"\\n\\n\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        left, partial_sum, min_len = 0, 0, float(\\'inf\\')\\n        # records the smallest length of subarry with target sum until index i\\n        min_so_far = [float(\\'inf\\')] * len(arr)\\n        for right, num in enumerate(arr):\\n            partial_sum += num\\n            while partial_sum > target:\\n                partial_sum -= arr[left]\\n                left += 1\\n            if partial_sum == target:\\n                curr_len = right - left + 1\\n                min_len = min(min_len, curr_len + min_so_far[left - 1])\\n                min_so_far[right] = min(curr_len, min_so_far[right - 1])\\n            else:\\n                min_so_far[right] = min_so_far[right - 1]\\n        return min_len if min_len < float(\\'inf\\') else -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2074925,
                "title": "python3-dp",
                "content": "```class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        def getDP(a):\\n            dp = [math.inf for _ in range(len(a))]\\n            store = defaultdict(int)\\n            for i, val in enumerate(itertools.accumulate(a)):\\n                if val == target:\\n                    dp[i] = i - 0 + 1\\n                elif val - target in store:\\n                    dp[i] = i - store[val-target]\\n                dp[i] = min(dp[i],dp[i-1])\\n                store[val] = i\\n            return dp\\n        left = getDP(arr)\\n        right = getDP(arr[::-1])[::-1]\\n        ret = math.inf\\n        for i in range(1, len(arr)):\\n            ret = min(ret, left[i-1] + right[i])\\n        return ret if ret != math.inf else -1\\n        \\n",
                "solutionTags": [],
                "code": "```class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        def getDP(a):\\n            dp = [math.inf for _ in range(len(a))]\\n            store = defaultdict(int)\\n            for i, val in enumerate(itertools.accumulate(a)):\\n                if val == target:\\n                    dp[i] = i - 0 + 1\\n                elif val - target in store:\\n                    dp[i] = i - store[val-target]\\n                dp[i] = min(dp[i],dp[i-1])\\n                store[val] = i\\n            return dp\\n        left = getDP(arr)\\n        right = getDP(arr[::-1])[::-1]\\n        ret = math.inf\\n        for i in range(1, len(arr)):\\n            ret = min(ret, left[i-1] + right[i])\\n        return ret if ret != math.inf else -1\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2012654,
                "title": "c-cumulative-property",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        [1   8]\\n        \\n        list of segment pairs which make target values[{1 3} {2 2} {6, 7} {6, 8}]\\n        \\n        [0] = inf                          = 1\\n        [1] = 3 {1, 3} = 1                 = 1\\n        [2] = 1 {2, 2}                     = 1\\n        [3] = inf                          = 2\\n        [4] = inf                          = 2\\n        [5] = inf                          = 2\\n        [6] = min(3 {6, 8} , 2 {6, 7}) = 2 = 2\\n        [7] = inf                          = inf\\n        [8] = inf                          = inf\\n        \\n    */\\n    #define inf 0x3f3f3f3f\\n    \\n    int non_overlapping_min_sub_array_len_from_index[100001];\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        memset(non_overlapping_min_sub_array_len_from_index, inf, sizeof non_overlapping_min_sub_array_len_from_index);\\n        vector <pair<int, int>> targetMakingPairs;\\n        int lf = 0, sum = 0;\\n        for (int rt = 0; rt < arr.size(); rt++) {\\n            sum += arr[rt];\\n            while(sum > target) {\\n                sum -= arr[lf++];\\n            }\\n            if (sum == target) {\\n                targetMakingPairs.push_back({lf, rt});\\n                non_overlapping_min_sub_array_len_from_index[lf] = min(non_overlapping_min_sub_array_len_from_index[lf], rt - lf + 1);\\n            }\\n        }\\n        \\n        if (targetMakingPairs.size() < 2) return -1;\\n        \\n        for (int index = arr.size() - 1; index >= 0; index--) {\\n            non_overlapping_min_sub_array_len_from_index[index] = min(non_overlapping_min_sub_array_len_from_index[index], non_overlapping_min_sub_array_len_from_index[index + 1]);\\n        }\\n\\n        \\n        int result = inf;\\n        for (int pair_id = 0; pair_id < targetMakingPairs.size(); pair_id++) {\\n            result = min(result, targetMakingPairs[pair_id].second - targetMakingPairs[pair_id].first + 1 + non_overlapping_min_sub_array_len_from_index[ targetMakingPairs[pair_id].second + 1 ]);\\n        }\\n        \\n        return result == inf ? -1 : result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        [1   8]\\n        \\n        list of segment pairs which make target values[{1 3} {2 2} {6, 7} {6, 8}]\\n        \\n        [0] = inf                          = 1\\n        [1] = 3 {1, 3} = 1                 = 1\\n        [2] = 1 {2, 2}                     = 1\\n        [3] = inf                          = 2\\n        [4] = inf                          = 2\\n        [5] = inf                          = 2\\n        [6] = min(3 {6, 8} , 2 {6, 7}) = 2 = 2\\n        [7] = inf                          = inf\\n        [8] = inf                          = inf\\n        \\n    */\\n    #define inf 0x3f3f3f3f\\n    \\n    int non_overlapping_min_sub_array_len_from_index[100001];\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        memset(non_overlapping_min_sub_array_len_from_index, inf, sizeof non_overlapping_min_sub_array_len_from_index);\\n        vector <pair<int, int>> targetMakingPairs;\\n        int lf = 0, sum = 0;\\n        for (int rt = 0; rt < arr.size(); rt++) {\\n            sum += arr[rt];\\n            while(sum > target) {\\n                sum -= arr[lf++];\\n            }\\n            if (sum == target) {\\n                targetMakingPairs.push_back({lf, rt});\\n                non_overlapping_min_sub_array_len_from_index[lf] = min(non_overlapping_min_sub_array_len_from_index[lf], rt - lf + 1);\\n            }\\n        }\\n        \\n        if (targetMakingPairs.size() < 2) return -1;\\n        \\n        for (int index = arr.size() - 1; index >= 0; index--) {\\n            non_overlapping_min_sub_array_len_from_index[index] = min(non_overlapping_min_sub_array_len_from_index[index], non_overlapping_min_sub_array_len_from_index[index + 1]);\\n        }\\n\\n        \\n        int result = inf;\\n        for (int pair_id = 0; pair_id < targetMakingPairs.size(); pair_id++) {\\n            result = min(result, targetMakingPairs[pair_id].second - targetMakingPairs[pair_id].first + 1 + non_overlapping_min_sub_array_len_from_index[ targetMakingPairs[pair_id].second + 1 ]);\\n        }\\n        \\n        return result == inf ? -1 : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966883,
                "title": "c-detailed-explanation-dp-clean-concise",
                "content": "# ****Intuition:\\n\\n## We are taking the res variable for storing the min sum of the possibility of  the size of the window .\\n\\n## In the dp array we will store the min length of the possibility of the window .\\n## \\tIF dp[start-1]==INT_MAX , this is the 1st one window which is found , previously there does not exist any window of target . \\n\\n## we storing in the dp[end]=len , to check there exist the any window previously of value target .\\n\\n# ****IF FIND THIS SOLUTION HELPFUL , PLEASE UPVOTE !!!\\n\\n```\\n int minSumOfLengths(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        \\n        int start=0;\\n        \\n        int  res=INT_MAX;\\n        vector<int> dp(n , INT_MAX);\\n        \\n        int len=INT_MAX , curr_len;\\n        \\n        int sum=0;\\n        \\n        for(int end=0;end<n;end++)\\n        {\\n            sum+=nums[end];\\n            \\n            while(sum>target)\\n            {\\n                sum-=nums[start];\\n                start++;\\n            }\\n            \\n            if(sum==target)\\n            {\\n                curr_len=(end-start+1);\\n                \\n                if(start>0 && dp[start-1]!=INT_MAX) // checking  for  the pair existent of 2 \\n                {\\n                    res=min(res , dp[start-1] + curr_len);\\n                }\\n                \\n                len=min(len , curr_len);\\n                \\n                // update the minlength and store in dp array s.t at least one target exist \\n                \\n                \\n                    \\n            }\\n            \\n            dp[end]=len;\\n            \\n        }\\n        \\n        if(res==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        \\n        return res;\\n            \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int minSumOfLengths(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        \\n        int start=0;\\n        \\n        int  res=INT_MAX;\\n        vector<int> dp(n , INT_MAX);\\n        \\n        int len=INT_MAX , curr_len;\\n        \\n        int sum=0;\\n        \\n        for(int end=0;end<n;end++)\\n        {\\n            sum+=nums[end];\\n            \\n            while(sum>target)\\n            {\\n                sum-=nums[start];\\n                start++;\\n            }\\n            \\n            if(sum==target)\\n            {\\n                curr_len=(end-start+1);\\n                \\n                if(start>0 && dp[start-1]!=INT_MAX) // checking  for  the pair existent of 2 \\n                {\\n                    res=min(res , dp[start-1] + curr_len);\\n                }\\n                \\n                len=min(len , curr_len);\\n                \\n                // update the minlength and store in dp array s.t at least one target exist \\n                \\n                \\n                    \\n            }\\n            \\n            dp[end]=len;\\n            \\n        }\\n        \\n        if(res==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        \\n        return res;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1950171,
                "title": "java-two-pointer-one-iteration-one-temporary-array",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {       \\n        int[] left = new int[arr.length+2];\\n        Arrays.fill(left, Integer.MAX_VALUE/2);\\n        \\n        int start = 0;\\n        int end = 0;\\n        int sum = 0;\\n        int result = Integer.MAX_VALUE/2;\\n        while(end < arr.length || sum > target){\\n            if(sum < target){\\n                sum+=arr[end++];\\n            } else {\\n                sum-=arr[start++];\\n            }\\n            if(sum == target){\\n                int len = end - start;\\n                left[end+1] = len;\\n                result = Math.min(result, len + left[start+1]);\\n            }\\n            left[end+1] = Math.min(left[end],left[end+1]);\\n        }\\n        return result == Integer.MAX_VALUE/2 ? -1 : result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {       \\n        int[] left = new int[arr.length+2];\\n        Arrays.fill(left, Integer.MAX_VALUE/2);\\n        \\n        int start = 0;\\n        int end = 0;\\n        int sum = 0;\\n        int result = Integer.MAX_VALUE/2;\\n        while(end < arr.length || sum > target){\\n            if(sum < target){\\n                sum+=arr[end++];\\n            } else {\\n                sum-=arr[start++];\\n            }\\n            if(sum == target){\\n                int len = end - start;\\n                left[end+1] = len;\\n                result = Math.min(result, len + left[start+1]);\\n            }\\n            left[end+1] = Math.min(left[end],left[end+1]);\\n        }\\n        return result == Integer.MAX_VALUE/2 ? -1 : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861330,
                "title": "prefix-sum-and-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        vector<int> pref(n,INT_MAX),suff(n,INT_MAX);\\n        int j=0,s=0;\\n        for(int i=0;i<n;i++){\\n            s+=arr[i];\\n            while(j<=i && s>target){\\n                s-=arr[j];\\n                j++;\\n            }\\n            if(s==target){\\n                if(i==0){\\n                    pref[i]=(i-j+1);\\n                    continue;\\n                }\\n                pref[i]=min(pref[i-1],i-j+1);\\n            }else{\\n                if(i!=0)\\n                pref[i]=pref[i-1];\\n            }\\n        }\\n        j=n-1,s=0;\\n        for(int i=n-2;i>=0;i--){\\n            s+=arr[i+1];\\n            while(j>i && s>target){\\n                s-=arr[j];\\n                j--;\\n            }\\n            if(s==target){\\n                suff[i]=min(suff[i+1],j-i);\\n            }else{\\n                suff[i]=suff[i+1];\\n            }\\n        }\\n        int minl=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(pref[i]!=INT_MAX && suff[i]!=INT_MAX)\\n             minl=min(minl,pref[i]+suff[i]);\\n        }\\n        return minl==INT_MAX?-1:minl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        vector<int> pref(n,INT_MAX),suff(n,INT_MAX);\\n        int j=0,s=0;\\n        for(int i=0;i<n;i++){\\n            s+=arr[i];\\n            while(j<=i && s>target){\\n                s-=arr[j];\\n                j++;\\n            }\\n            if(s==target){\\n                if(i==0){\\n                    pref[i]=(i-j+1);\\n                    continue;\\n                }\\n                pref[i]=min(pref[i-1],i-j+1);\\n            }else{\\n                if(i!=0)\\n                pref[i]=pref[i-1];\\n            }\\n        }\\n        j=n-1,s=0;\\n        for(int i=n-2;i>=0;i--){\\n            s+=arr[i+1];\\n            while(j>i && s>target){\\n                s-=arr[j];\\n                j--;\\n            }\\n            if(s==target){\\n                suff[i]=min(suff[i+1],j-i);\\n            }else{\\n                suff[i]=suff[i+1];\\n            }\\n        }\\n        int minl=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(pref[i]!=INT_MAX && suff[i]!=INT_MAX)\\n             minl=min(minl,pref[i]+suff[i]);\\n        }\\n        return minl==INT_MAX?-1:minl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777583,
                "title": "concise-java-solution",
                "content": "```\\nclass Solution {\\n   public int minSumOfLengths(int[] arr, int target) {\\n       int n = arr.length;\\n       \\n       //best is used to store the length of shortest sub-array with total sum of target up to i inclusively\\n       int best[] = new int[n];\\n       \\n       //initialize the best array\\n       Arrays.fill(best, Integer.MAX_VALUE);\\n       \\n       //for prefix sum\\n       int sum = 0;\\n       \\n       //the starting index of the sliding window\\n       int start = 0;\\n       \\n       //ans is to stored the result\\n       int ans = Integer.MAX_VALUE;\\n       \\n       //bestSoFar is the length of shortest sub-array with total sum of target across arr\\n       int bestSoFar = Integer.MAX_VALUE;\\n       \\n       //i is the ending index of the sliding window\\n       for(int i = 0; i < n; i++){\\n           //calculate the prefix sum up to i\\n           sum += arr[i];\\n           \\n           //move the start to the left while sum > target\\n           while(sum > target){\\n               sum -= arr[start];\\n               start++;\\n           }\\n           if(sum == target){\\n               //the current sliding window is not the first window with the sum of target\\n               if(start > 0 && best[start - 1] != Integer.MAX_VALUE){\\n                    //current sliding window has the length of i - start + 1\\n                    //previous shortest sliding window has the length of best[start - 1]\\n                   ans = Math.min(ans, best[start - 1] + i - start + 1);\\n               }\\n               //to get the shortest length up to i\\n               bestSoFar = Math.min(bestSoFar, i - start + 1);\\n           }\\n           best[i] = bestSoFar;\\n       }\\n       return ans == Integer.MAX_VALUE ? -1 : ans;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n   public int minSumOfLengths(int[] arr, int target) {\\n       int n = arr.length;\\n       \\n       //best is used to store the length of shortest sub-array with total sum of target up to i inclusively\\n       int best[] = new int[n];\\n       \\n       //initialize the best array\\n       Arrays.fill(best, Integer.MAX_VALUE);\\n       \\n       //for prefix sum\\n       int sum = 0;\\n       \\n       //the starting index of the sliding window\\n       int start = 0;\\n       \\n       //ans is to stored the result\\n       int ans = Integer.MAX_VALUE;\\n       \\n       //bestSoFar is the length of shortest sub-array with total sum of target across arr\\n       int bestSoFar = Integer.MAX_VALUE;\\n       \\n       //i is the ending index of the sliding window\\n       for(int i = 0; i < n; i++){\\n           //calculate the prefix sum up to i\\n           sum += arr[i];\\n           \\n           //move the start to the left while sum > target\\n           while(sum > target){\\n               sum -= arr[start];\\n               start++;\\n           }\\n           if(sum == target){\\n               //the current sliding window is not the first window with the sum of target\\n               if(start > 0 && best[start - 1] != Integer.MAX_VALUE){\\n                    //current sliding window has the length of i - start + 1\\n                    //previous shortest sliding window has the length of best[start - 1]\\n                   ans = Math.min(ans, best[start - 1] + i - start + 1);\\n               }\\n               //to get the shortest length up to i\\n               bestSoFar = Math.min(bestSoFar, i - start + 1);\\n           }\\n           best[i] = bestSoFar;\\n       }\\n       return ans == Integer.MAX_VALUE ? -1 : ans;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763686,
                "title": "c-two-methods-prefix-and-suffix-arrays-and-prefix-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MAX;\\n        int best_so_far = INT_MAX;\\n        vector<int> left(n + 1, INT_MAX), right(n, INT_MAX);\\n        int i = 0, pref = 0;\\n        for(int j=0; j<n; j++) {\\n            pref += nums[j];\\n            while(pref > k) {\\n                pref -= nums[i++];\\n            }\\n            if(pref == k) {\\n                best_so_far = min(best_so_far, j - i + 1);\\n            }\\n            left[j+1] = best_so_far;\\n        }\\n        i = n-1; best_so_far = INT_MAX;\\n        int suff = 0;\\n        for(int j=n-1; j>=0; j--) {\\n            suff += nums[j];\\n            while(suff > k) {\\n                suff -= nums[i--];\\n            }\\n            if(suff == k) {\\n                best_so_far = min(best_so_far, i - j + 1);\\n            }\\n            right[j] = best_so_far;\\n        }\\n        for(int i=0; i<n; i++) {\\n            res = min((long)res, (long)left[i] + right[i]);\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```\\nDP and prefix\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MAX;\\n        int pref = 0, best_so_far = INT_MAX;\\n        vector<int> dp(n, INT_MAX);\\n        int i = 0;\\n        for(int j=0; j<n; j++) {\\n            pref += nums[j];\\n            while(pref > k) {\\n                pref -= nums[i++];\\n            }\\n            if(pref == k) {\\n                if(i > 0 && dp[i-1] != INT_MAX)\\n                    res = min(res, dp[i-1] + j-i+1);\\n                best_so_far = min(best_so_far, j - i + 1);\\n            }\\n            dp[j] = best_so_far;\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MAX;\\n        int best_so_far = INT_MAX;\\n        vector<int> left(n + 1, INT_MAX), right(n, INT_MAX);\\n        int i = 0, pref = 0;\\n        for(int j=0; j<n; j++) {\\n            pref += nums[j];\\n            while(pref > k) {\\n                pref -= nums[i++];\\n            }\\n            if(pref == k) {\\n                best_so_far = min(best_so_far, j - i + 1);\\n            }\\n            left[j+1] = best_so_far;\\n        }\\n        i = n-1; best_so_far = INT_MAX;\\n        int suff = 0;\\n        for(int j=n-1; j>=0; j--) {\\n            suff += nums[j];\\n            while(suff > k) {\\n                suff -= nums[i--];\\n            }\\n            if(suff == k) {\\n                best_so_far = min(best_so_far, i - j + 1);\\n            }\\n            right[j] = best_so_far;\\n        }\\n        for(int i=0; i<n; i++) {\\n            res = min((long)res, (long)left[i] + right[i]);\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MAX;\\n        int pref = 0, best_so_far = INT_MAX;\\n        vector<int> dp(n, INT_MAX);\\n        int i = 0;\\n        for(int j=0; j<n; j++) {\\n            pref += nums[j];\\n            while(pref > k) {\\n                pref -= nums[i++];\\n            }\\n            if(pref == k) {\\n                if(i > 0 && dp[i-1] != INT_MAX)\\n                    res = min(res, dp[i-1] + j-i+1);\\n                best_so_far = min(best_so_far, j - i + 1);\\n            }\\n            dp[j] = best_so_far;\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739654,
                "title": "prefix-minimum-array-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self,a,k):\\n        d=[]\\n        s=0\\n        a1={}\\n        for i in range(len(a)):\\n            s+=a[i]\\n            if s==k:\\n                d.append([0,i])\\n            elif s-k in a1:\\n                d.append([a1[s-k]+1,i])\\n            a1[s]=i\\n        if len(d)==0:\\n            return -1\\n        e=[]\\n        for i in range(len(d)):\\n            e.append(d[i][1]-d[i][0]+1)\\n        f=[]\\n        h=e[0]\\n        for i in range(len(e)):\\n            h=min(h,e[i])\\n            f.append(h)\\n        o=-1\\n        for i in range(1,len(d)):\\n            i1=0\\n            j1=i-1\\n            p=-1\\n            while(i1<=j1):\\n                mid=(i1+j1)//2\\n                if d[mid][1]>=d[i][0]:\\n                    j1=mid-1\\n                else:\\n                    p=mid\\n                    i1=mid+1\\n            if p!=-1:\\n                if o==-1:\\n                    o=e[i]+f[p]\\n                else:\\n                    o=min(o,e[i]+f[p])\\n        return o",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n    def minSumOfLengths(self,a,k):\\n        d=[]\\n        s=0\\n        a1={}",
                "codeTag": "Java"
            },
            {
                "id": 1673372,
                "title": "combination-of-sliding-window-suffix-sum-and-binary-search",
                "content": "```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n        vector<vector<int>> indices;\\n        int si=0,ei=0,count=0;\\n\\t\\t//using count to store the current sum of values b/w si and ei (both inclusive)\\n        for(;ei < arr.size();ei++){\\n            count+=arr[ei];\\n            while(si <= ei && count > target){\\n                count-=arr[si++];\\n            }\\n            if(count == target){\\n\\t\\t\\t//found a match, so save the indices\\n                indices.push_back({si,ei});\\n                count-=arr[si++];\\n            }\\n        }\\n\\t\\t//storing the length of the minimum subarray so far from the right side in the suffix array\\n        vector<int> suffix(indices.size(),1e9);\\n        int mins=1e9;\\n        for(int i=indices.size()-1;i>-1;i--){\\n            suffix[i] = min(mins,indices[i][1]-indices[i][0]+1);\\n            mins = suffix[i];\\n        }\\n        int ans=1e9;\\n        if(indices.size() == 0)return -1;\\n        for(int i=0;i<indices.size()-1;i++){\\n\\t\\t//for every subarray look for the minimum length subarray towards its right side. \\n\\t\\t//Binary search the subarray with the minimum starting index but not overlapping with the current subarray. \\n\\t\\t//Use the value corresponding to that subarray in the suffix sum as it will be the minimum value.\\n\\t\\t//Keep updating the answer.\\n            int a = binary(indices, i+1,indices.size()-1,indices[i][1],suffix);\\n            if(a!=-1){\\n                ans = min(ans, a + indices[i][1]-indices[i][0]+1 );\\n            }\\n        }\\n        if(ans!=1e9)return ans;\\n        return -1;\\n    }\\n    \\n    int binary(vector<vector<int>>& indices, int si,int ei,int target,vector<int>& suffix){\\n        int ans=-1;\\n        while(si <= ei){\\n            int mid = si + (ei - si)/2;\\n            if(indices[mid][0] > target){\\n                ans = suffix[mid];\\n                ei = mid-1;\\n            }else{\\n                si = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n        vector<vector<int>> indices;\\n        int si=0,ei=0,count=0;\\n\\t\\t//using count to store the current sum of values b/w si and ei (both inclusive)\\n        for(;ei < arr.size();ei++){\\n            count+=arr[ei];\\n            while(si <= ei && count > target){\\n                count-=arr[si++];\\n            }\\n            if(count == target){\\n\\t\\t\\t//found a match, so save the indices\\n                indices.push_back({si,ei});\\n                count-=arr[si++];\\n            }\\n        }\\n\\t\\t//storing the length of the minimum subarray so far from the right side in the suffix array\\n        vector<int> suffix(indices.size(),1e9);\\n        int mins=1e9;\\n        for(int i=indices.size()-1;i>-1;i--){\\n            suffix[i] = min(mins,indices[i][1]-indices[i][0]+1);\\n            mins = suffix[i];\\n        }\\n        int ans=1e9;\\n        if(indices.size() == 0)return -1;\\n        for(int i=0;i<indices.size()-1;i++){\\n\\t\\t//for every subarray look for the minimum length subarray towards its right side. \\n\\t\\t//Binary search the subarray with the minimum starting index but not overlapping with the current subarray. \\n\\t\\t//Use the value corresponding to that subarray in the suffix sum as it will be the minimum value.\\n\\t\\t//Keep updating the answer.\\n            int a = binary(indices, i+1,indices.size()-1,indices[i][1],suffix);\\n            if(a!=-1){\\n                ans = min(ans, a + indices[i][1]-indices[i][0]+1 );\\n            }\\n        }\\n        if(ans!=1e9)return ans;\\n        return -1;\\n    }\\n    \\n    int binary(vector<vector<int>>& indices, int si,int ei,int target,vector<int>& suffix){\\n        int ans=-1;\\n        while(si <= ei){\\n            int mid = si + (ei - si)/2;\\n            if(indices[mid][0] > target){\\n                ans = suffix[mid];\\n                ei = mid-1;\\n            }else{\\n                si = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1493242,
                "title": "javascript-clean-elegant-o-n-solution-with-comments-faster-than-86",
                "content": "Sliding window solution. `start` is the index of the first element of window. `end` is the index of the last element of window.\\n\\n```\\nconst minSumOfLengths = (arr, target) => {\\n    const minLenSoFar = [];\\n    let start = 0,\\n        sum = 0,\\n        minLen = Infinity,\\n        output = Infinity;\\n    \\n    // Find best solution for each end of window. Save best solution to minLenSoFar[end].\\n    for (let end = 0; end < arr.length; end++) {\\n        sum += arr[end];\\n        \\n        // Keep increasing window start index as long as we are above target\\n        while (sum > target) {\\n            sum -= arr[start];\\n            start++;\\n        }\\n        \\n        if (sum === target) {\\n            const len = end - start + 1;\\n            minLen = Math.min(len, minLen);\\n            if (start > 0) {\\n                const minSumForThisIndex = minLenSoFar[start - 1] + len;\\n                output = Math.min(output, minSumForThisIndex);\\n            }\\n        }\\n\\n        minLenSoFar[end] = minLen;\\n    }\\n\\n    return output === Infinity ? -1 : output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst minSumOfLengths = (arr, target) => {\\n    const minLenSoFar = [];\\n    let start = 0,\\n        sum = 0,\\n        minLen = Infinity,\\n        output = Infinity;\\n    \\n    // Find best solution for each end of window. Save best solution to minLenSoFar[end].\\n    for (let end = 0; end < arr.length; end++) {\\n        sum += arr[end];\\n        \\n        // Keep increasing window start index as long as we are above target\\n        while (sum > target) {\\n            sum -= arr[start];\\n            start++;\\n        }\\n        \\n        if (sum === target) {\\n            const len = end - start + 1;\\n            minLen = Math.min(len, minLen);\\n            if (start > 0) {\\n                const minSumForThisIndex = minLenSoFar[start - 1] + len;\\n                output = Math.min(output, minSumForThisIndex);\\n            }\\n        }\\n\\n        minLenSoFar[end] = minLen;\\n    }\\n\\n    return output === Infinity ? -1 : output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419143,
                "title": "o-1-space-double-sliding-window",
                "content": "```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        i1, j1, i2, sum1, sum2, min1, min12 = 0, 0, 0, 0, 0, math.inf, math.inf\\n        for j2 in range(n):\\n            sum2 += arr[j2]\\n            while sum2 > target:\\n                sum2 -= arr[i2]\\n                i2 += 1\\n            if sum2 == target:\\n                while j1 < i2:\\n                    sum1 += arr[j1]\\n                    while sum1 > target:\\n                        sum1 -= arr[i1]\\n                        i1 += 1\\n                    if sum1 == target:\\n                        min1 = min(min1, j1 - i1 + 1)\\n                    j1 += 1\\n                min12 = min(min12, min1 + j2 - i2 + 1)\\n        return min12 if min12 < math.inf else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        i1, j1, i2, sum1, sum2, min1, min12 = 0, 0, 0, 0, 0, math.inf, math.inf\\n        for j2 in range(n):\\n            sum2 += arr[j2]\\n            while sum2 > target:\\n                sum2 -= arr[i2]\\n                i2 += 1\\n            if sum2 == target:\\n                while j1 < i2:\\n                    sum1 += arr[j1]\\n                    while sum1 > target:\\n                        sum1 -= arr[i1]\\n                        i1 += 1\\n                    if sum1 == target:\\n                        min1 = min(min1, j1 - i1 + 1)\\n                    j1 += 1\\n                min12 = min(min12, min1 + j2 - i2 + 1)\\n        return min12 if min12 < math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367462,
                "title": "python3-sliding-window",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        best_at_idx = defaultdict(lambda:float(\\'inf\\'))\\n        n = len(arr)\\n        i,j = 0, 0\\n        curr_sum = 0\\n        curr_best = float(\\'inf\\')\\n        ans = float(\\'inf\\')\\n        while j < n:\\n            curr_sum += arr[j]\\n            \\n            while curr_sum > target:\\n                curr_sum -= arr[i]\\n                i += 1\\n                \\n            if curr_sum == target:\\n                ans = min(ans,best_at_idx[i - 1] + j - i + 1)\\n                curr_best = min(curr_best,j - i + 1)\\n            \\n            best_at_idx[j] = curr_best\\n            j += 1\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        best_at_idx = defaultdict(lambda:float(\\'inf\\'))\\n        n = len(arr)\\n        i,j = 0, 0\\n        curr_sum = 0\\n        curr_best = float(\\'inf\\')\\n        ans = float(\\'inf\\')\\n        while j < n:\\n            curr_sum += arr[j]\\n            \\n            while curr_sum > target:\\n                curr_sum -= arr[i]\\n                i += 1\\n                \\n            if curr_sum == target:\\n                ans = min(ans,best_at_idx[i - 1] + j - i + 1)\\n                curr_best = min(curr_best,j - i + 1)\\n            \\n            best_at_idx[j] = curr_best\\n            j += 1\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237544,
                "title": "c-prefix-and-suffix-arrays-sliding-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<int>prefix(n+1,INT_MAX);\\n        vector<int>suffix(n,INT_MAX);\\n        int i=0,j=0,sum=0;\\n        while(j<n)\\n        {\\n            sum+=arr[j++];\\n            while(sum>k)\\n            {\\n                sum-=arr[i++];\\n            }\\n            if(sum==k)\\n            {\\n                prefix[j]=min(prefix[j],j-i);\\n            }\\n        }\\n        j=n-1,i=n-1,sum=0;\\n        while(j>=0)\\n        {\\n            sum+=arr[j--];\\n            while(sum>k)\\n            {\\n                sum-=arr[i--];\\n            }\\n            if(sum==k)\\n            {\\n                suffix[j+1]=min(suffix[j+1],i-j);\\n            }\\n        }\\n        int res=INT_MAX;\\n        for(int i=1;i<=n;i++)\\n            prefix[i]=min(prefix[i],prefix[i-1]);\\n        for(int j=n-2;j>=0;j--)\\n            suffix[j]=min(suffix[j+1],suffix[j]);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prefix[i]!=INT_MAX && suffix[i]!=INT_MAX)\\n            {\\n                res=min(res,prefix[i]+suffix[i]);\\n            }\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<int>prefix(n+1,INT_MAX);\\n        vector<int>suffix(n,INT_MAX);\\n        int i=0,j=0,sum=0;\\n        while(j<n)\\n        {\\n            sum+=arr[j++];\\n            while(sum>k)\\n            {\\n                sum-=arr[i++];\\n            }\\n            if(sum==k)\\n            {\\n                prefix[j]=min(prefix[j],j-i);\\n            }\\n        }\\n        j=n-1,i=n-1,sum=0;\\n        while(j>=0)\\n        {\\n            sum+=arr[j--];\\n            while(sum>k)\\n            {\\n                sum-=arr[i--];\\n            }\\n            if(sum==k)\\n            {\\n                suffix[j+1]=min(suffix[j+1],i-j);\\n            }\\n        }\\n        int res=INT_MAX;\\n        for(int i=1;i<=n;i++)\\n            prefix[i]=min(prefix[i],prefix[i-1]);\\n        for(int j=n-2;j>=0;j--)\\n            suffix[j]=min(suffix[j+1],suffix[j]);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prefix[i]!=INT_MAX && suffix[i]!=INT_MAX)\\n            {\\n                res=min(res,prefix[i]+suffix[i]);\\n            }\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207937,
                "title": "c-solution-dynammic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> prefix(n, INF);\\n        int sum = 0;\\n        unordered_map<int, int> m;\\n        m[0] = -1;\\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            if(m.find(sum - target) != m.end()) {\\n                prefix[i] = i - m[sum - target];\\n            }\\n            prefix[i] = min((i == 0 ? INF : prefix[i - 1]), prefix[i]);\\n            m[sum] = i;\\n        }\\n        sum = 0;\\n        m.clear();\\n        m[0] = n;\\n        vector<int> suffix(n, INF);\\n        for(int i = n - 1; i >= 0; i--) {\\n            sum += arr[i];\\n            if(m.find(sum - target) != m.end()) {\\n                suffix[i] = m[sum - target] - i;\\n            }\\n            suffix[i] = min((i == n - 1 ? INF : suffix[i + 1]), suffix[i]);\\n            m[sum] = i;\\n        }\\n        int ans = INF;\\n        for(int i = 0; i < n - 1; i++) {\\n            if(prefix[i] != INF && suffix[i + 1] != INF)\\n                ans = min(ans, prefix[i] + suffix[i + 1]);\\n        }\\n        return ans == INF ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> prefix(n, INF);\\n        int sum = 0;\\n        unordered_map<int, int> m;\\n        m[0] = -1;\\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            if(m.find(sum - target) != m.end()) {\\n                prefix[i] = i - m[sum - target];\\n            }\\n            prefix[i] = min((i == 0 ? INF : prefix[i - 1]), prefix[i]);\\n            m[sum] = i;\\n        }\\n        sum = 0;\\n        m.clear();\\n        m[0] = n;\\n        vector<int> suffix(n, INF);\\n        for(int i = n - 1; i >= 0; i--) {\\n            sum += arr[i];\\n            if(m.find(sum - target) != m.end()) {\\n                suffix[i] = m[sum - target] - i;\\n            }\\n            suffix[i] = min((i == n - 1 ? INF : suffix[i + 1]), suffix[i]);\\n            m[sum] = i;\\n        }\\n        int ans = INF;\\n        for(int i = 0; i < n - 1; i++) {\\n            if(prefix[i] != INF && suffix[i + 1] != INF)\\n                ans = min(ans, prefix[i] + suffix[i + 1]);\\n        }\\n        return ans == INF ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196566,
                "title": "python-dp-one-loop",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        prefix_sum = [0 for i in range(len(arr) + 1)]\\n        # the smallest interval that sum to target before position i\\n        shortest_interval = [len(arr) + 1 for i in range(len(arr) + 1)] \\n        sum_map = {0:0} # corresponding indices for prefix sum\\n        shortest = len(arr) + 1\\n        for i in range(len(arr)):\\n            prefix_sum[i + 1] = arr[i] if i == 0 else arr[i] + prefix_sum[i]\\n            sum_map[prefix_sum[i + 1]] = (i + 1)\\n            shortest_interval[i + 1] = shortest_interval[i]\\n            if (prefix_sum[i + 1] - target) in sum_map:\\n\\t\\t\\t\\t# only subarray indexed before sum_map[prefix_sum[i + 1] - target] cannot overlap\\n                last = sum_map[prefix_sum[i + 1] - target]\\n                shortest = min(shortest, shortest_interval[last] + (i + 1 - last))\\n                shortest_interval[i + 1] = min(shortest_interval[i + 1], (i + 1 - last))\\n                    \\n        return (shortest if shortest <= len(arr) else -1)",
                "solutionTags": [],
                "code": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        prefix_sum = [0 for i in range(len(arr) + 1)]\\n        # the smallest interval that sum to target before position i\\n        shortest_interval = [len(arr) + 1 for i in range(len(arr) + 1)] \\n        sum_map = {0:0}",
                "codeTag": "Java"
            },
            {
                "id": 1176973,
                "title": "java-o-n-using-hashmap-short-concise-prefix-and-suffix-based-on-hints",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] reverseArr(int arr[]){\\n        int n=arr.length;\\n        int reverse[] = new int[n];\\n        for(int i=0;i<n;++i) reverse[i]=arr[n-i-1];\\n        return reverse;\\n    }\\n    public int[] minLengthArrayforEachIndexWithTargetSum(int[] arr, int target){\\n        int n=arr.length;\\n        int ans[] = new int[n];\\n        int prefixSum[] = new int[n]; \\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        for(int i=0;i<n;++i){\\n            prefixSum[i] = (i==0) ? arr[i] : prefixSum[i-1]+arr[i];\\n            int currentLength=n+1;\\n            if(map.containsKey(prefixSum[i]-target)) currentLength=i-map.get(prefixSum[i]-target);\\n            map.put(prefixSum[i], i);\\n            ans[i] = (i==0) ? currentLength : Math.min(currentLength, ans[i-1]);\\n        }\\n        return ans;\\n    }\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n=arr.length, ans=n+1;\\n        int []prefix = minLengthArrayforEachIndexWithTargetSum(arr, target);\\n        arr = reverseArr(arr);\\n        int []suffix = minLengthArrayforEachIndexWithTargetSum(arr, target);\\n        for(int i=0;i<n-1;i++) ans=Math.min(ans, prefix[i]+suffix[n-1-i-1]);\\n        return ans==n+1 ? -1 : ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] reverseArr(int arr[]){\\n        int n=arr.length;\\n        int reverse[] = new int[n];\\n        for(int i=0;i<n;++i) reverse[i]=arr[n-i-1];\\n        return reverse;\\n    }\\n    public int[] minLengthArrayforEachIndexWithTargetSum(int[] arr, int target){\\n        int n=arr.length;\\n        int ans[] = new int[n];\\n        int prefixSum[] = new int[n]; \\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        for(int i=0;i<n;++i){\\n            prefixSum[i] = (i==0) ? arr[i] : prefixSum[i-1]+arr[i];\\n            int currentLength=n+1;\\n            if(map.containsKey(prefixSum[i]-target)) currentLength=i-map.get(prefixSum[i]-target);\\n            map.put(prefixSum[i], i);\\n            ans[i] = (i==0) ? currentLength : Math.min(currentLength, ans[i-1]);\\n        }\\n        return ans;\\n    }\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n=arr.length, ans=n+1;\\n        int []prefix = minLengthArrayforEachIndexWithTargetSum(arr, target);\\n        arr = reverseArr(arr);\\n        int []suffix = minLengthArrayforEachIndexWithTargetSum(arr, target);\\n        for(int i=0;i<n-1;i++) ans=Math.min(ans, prefix[i]+suffix[n-1-i-1]);\\n        return ans==n+1 ? -1 : ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138652,
                "title": "c-sliding-window-no-hash-map-o-n",
                "content": "The idea is to keep 2 indices i and j as the starting point and end point of sliding window.\\nAlso we maintain an array which contain Min size of sliding window that is to left of index.\\n\\nFor indices i and j where the sum of the range == target\\nThe leftMin for index j is minimum of leftMin of j - 1 and current.\\nOur ans will be minimum of leftMin[i] + current.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) \\n    {\\n        vector<long long> leftMin(arr.size() + 1, numeric_limits<int>::max());\\n        int i = 0;\\n        int j = 0;\\n        \\n        long long sum = arr[0];\\n        long long ans = numeric_limits<int>::max();\\n        \\n        while (j < arr.size() )\\n        {\\n            if (sum == target)\\n            {\\n                long long current = j - i + 1;\\n                \\n                leftMin[j + 1] = min(leftMin[j], current);\\n                ans = min(ans, current + leftMin[i]);\\n                \\n                sum -= arr[i];\\n                ++i;\\n                if (++j < arr.size())\\n                    sum += arr[j];\\n            }\\n            else if (sum < target)\\n            {\\n                leftMin[j + 1] = min(leftMin[j], leftMin[j + 1]) ;\\n                if (++j < arr.size())\\n                    sum += arr[j];\\n            }\\n            else\\n            {\\n                sum -= arr[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (ans >= numeric_limits<int>::max())\\n            return -1;\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) \\n    {\\n        vector<long long> leftMin(arr.size() + 1, numeric_limits<int>::max());\\n        int i = 0;\\n        int j = 0;\\n        \\n        long long sum = arr[0];\\n        long long ans = numeric_limits<int>::max();\\n        \\n        while (j < arr.size() )\\n        {\\n            if (sum == target)\\n            {\\n                long long current = j - i + 1;\\n                \\n                leftMin[j + 1] = min(leftMin[j], current);\\n                ans = min(ans, current + leftMin[i]);\\n                \\n                sum -= arr[i];\\n                ++i;\\n                if (++j < arr.size())\\n                    sum += arr[j];\\n            }\\n            else if (sum < target)\\n            {\\n                leftMin[j + 1] = min(leftMin[j], leftMin[j + 1]) ;\\n                if (++j < arr.size())\\n                    sum += arr[j];\\n            }\\n            else\\n            {\\n                sum -= arr[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (ans >= numeric_limits<int>::max())\\n            return -1;\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111388,
                "title": "python3-prefix-sum",
                "content": "\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ans = inf \\n        best = [inf]*len(arr) # shortest subarray ending at i\\n        prefix = 0\\n        latest = {0: -1}\\n        for i, x in enumerate(arr): \\n            prefix += x\\n            if prefix - target in latest: \\n                ii = latest[prefix - target]\\n                if ii >= 0: \\n                    ans = min(ans, i - ii + best[ii])\\n                best[i] = i - ii\\n            if i: best[i] = min(best[i-1], best[i])\\n            latest[prefix] = i \\n        return ans if ans < inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ans = inf \\n        best = [inf]*len(arr) # shortest subarray ending at i\\n        prefix = 0\\n        latest = {0: -1}\\n        for i, x in enumerate(arr): \\n            prefix += x\\n            if prefix - target in latest: \\n                ii = latest[prefix - target]\\n                if ii >= 0: \\n                    ans = min(ans, i - ii + best[ii])\\n                best[i] = i - ii\\n            if i: best[i] = min(best[i-1], best[i])\\n            latest[prefix] = i \\n        return ans if ans < inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100124,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int i = 0;\\n        int sum = 0;\\n        int ans = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int j = 0;\\n        int[] dp = new int[arr.length];\\n        \\n        while(j < arr.length){\\n            sum += arr[j];\\n            \\n            while(sum > target) sum -= arr[i++];\\n            \\n            if(sum == target){\\n                min = Math.min(min,j-i+1);\\n                if(i > 0 && dp[i-1] != Integer.MAX_VALUE) ans = Math.min(ans, dp[i-1]+(j-i+1));\\n            }\\n            dp[j] = min;\\n            j++;\\n        }\\n        return (ans == Integer.MAX_VALUE)? -1: ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int i = 0;\\n        int sum = 0;\\n        int ans = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int j = 0;\\n        int[] dp = new int[arr.length];\\n        \\n        while(j < arr.length){\\n            sum += arr[j];\\n            \\n            while(sum > target) sum -= arr[i++];\\n            \\n            if(sum == target){\\n                min = Math.min(min,j-i+1);\\n                if(i > 0 && dp[i-1] != Integer.MAX_VALUE) ans = Math.min(ans, dp[i-1]+(j-i+1));\\n            }\\n            dp[j] = min;\\n            j++;\\n        }\\n        return (ans == Integer.MAX_VALUE)? -1: ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090534,
                "title": "javascript-dp-with-sliding-window-o-n-time",
                "content": "```javascript\\nvar minSumOfLengths = function(arr, target) {\\n    const dp = []\\n    let i = 0, j = 0, sum = 0;\\n    let minLen = Infinity;\\n    let output = Infinity;\\n    \\n    while(j < arr.length) {\\n        sum += arr[j];\\n        \\n        while(sum > target) sum -= arr[i++];\\n        \\n        if(sum === target) {\\n            const len = j - i + 1;\\n            minLen = Math.min(len, minLen);\\n            if(i > 0) output = Math.min(output, dp[i-1] + len)\\n        }\\n        dp[j] = minLen;\\n        j++\\n    }\\n    return output === Infinity ? -1 : output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```javascript\\nvar minSumOfLengths = function(arr, target) {\\n    const dp = []\\n    let i = 0, j = 0, sum = 0;\\n    let minLen = Infinity;\\n    let output = Infinity;\\n    \\n    while(j < arr.length) {\\n        sum += arr[j];\\n        \\n        while(sum > target) sum -= arr[i++];\\n        \\n        if(sum === target) {\\n            const len = j - i + 1;\\n            minLen = Math.min(len, minLen);\\n            if(i > 0) output = Math.min(output, dp[i-1] + len)\\n        }\\n        dp[j] = minLen;\\n        j++\\n    }\\n    return output === Infinity ? -1 : output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963611,
                "title": "c-hashmap-dp-version",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n\\n        unordered_map<int, int> prefixsum_index; // prefixsum_index: key, prefixsum,  value: index\\n        vector<int> smallest_length;  // smallest_length: smallest_length[i] means, from 0 to i, current smallest length of subarray that sum == target, not find, == INT_MAX\\n        int res = INT_MAX; // sum of Two Non-overlapping Sub-arrays lengths (sum == target)\\n        \\n        smallest_length.push_back(INT_MAX);\\n        arr.insert(arr.begin(), 0); // handle edge case: subarray == target start from the first element\\n        \\n\\t\\t// start scan arr, \\n        // save current prefix sum and current index to map, prefixsum_index[curr_sum] = i;\\n        // set current smallest subarray length equal previous value first, smallest_length[i] = smallest_length[i -1]\\n        //      if curr sum - target exist in map, fins a subarray sum == target\\n        //      left_index = prefixsum_index[sum - target]\\n        //      new_length = i - left_index\\n        //      smallest_length[i] should be min(smallest_length[i], new_length)\\n        //      if smallest_length[left_index] not INT_MAX, which mean find target subarray before, update res\\n        //          new_res = smallest_length[left_index] + new_length;\\n        //          res = min(new_res, res)\\n        \\n        int curr_sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            curr_sum += arr[i];\\n            prefixsum_index[curr_sum] = i;\\n            if (i != 0) smallest_length.push_back(smallest_length[i-1]);\\n            int sum_target = curr_sum - target;\\n            \\n            if (prefixsum_index.find(sum_target) != prefixsum_index.end()) {\\n                int left_idx = prefixsum_index[sum_target];\\n                int new_len = i - left_idx;\\n                smallest_length[i] = min(smallest_length[i], new_len);\\n                \\n                if (smallest_length[left_idx] != INT_MAX) {\\n                    int new_res = new_len + smallest_length[left_idx];\\n                    res = min(res, new_res);\\n                }\\n                \\n            }  \\n        }\\n        if (res == INT_MAX) return -1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n\\n        unordered_map<int, int> prefixsum_index; // prefixsum_index: key, prefixsum,  value: index\\n        vector<int> smallest_length;  // smallest_length: smallest_length[i] means, from 0 to i, current smallest length of subarray that sum == target, not find, == INT_MAX\\n        int res = INT_MAX; // sum of Two Non-overlapping Sub-arrays lengths (sum == target)\\n        \\n        smallest_length.push_back(INT_MAX);\\n        arr.insert(arr.begin(), 0); // handle edge case: subarray == target start from the first element\\n        \\n\\t\\t// start scan arr, \\n        // save current prefix sum and current index to map, prefixsum_index[curr_sum] = i;\\n        // set current smallest subarray length equal previous value first, smallest_length[i] = smallest_length[i -1]\\n        //      if curr sum - target exist in map, fins a subarray sum == target\\n        //      left_index = prefixsum_index[sum - target]\\n        //      new_length = i - left_index\\n        //      smallest_length[i] should be min(smallest_length[i], new_length)\\n        //      if smallest_length[left_index] not INT_MAX, which mean find target subarray before, update res\\n        //          new_res = smallest_length[left_index] + new_length;\\n        //          res = min(new_res, res)\\n        \\n        int curr_sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            curr_sum += arr[i];\\n            prefixsum_index[curr_sum] = i;\\n            if (i != 0) smallest_length.push_back(smallest_length[i-1]);\\n            int sum_target = curr_sum - target;\\n            \\n            if (prefixsum_index.find(sum_target) != prefixsum_index.end()) {\\n                int left_idx = prefixsum_index[sum_target];\\n                int new_len = i - left_idx;\\n                smallest_length[i] = min(smallest_length[i], new_len);\\n                \\n                if (smallest_length[left_idx] != INT_MAX) {\\n                    int new_res = new_len + smallest_length[left_idx];\\n                    res = min(res, new_res);\\n                }\\n                \\n            }  \\n        }\\n        if (res == INT_MAX) return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957983,
                "title": "java-solution-prefixsum-and-hashmap-two-passes",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int[] leftSum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            leftSum[i] = leftSum[i - 1] + arr[i - 1];\\n        }\\n        int[] rightSum = new int[n + 1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightSum[i] = rightSum[i + 1] + arr[i];\\n        }\\n        int[] leftMins = new int[n + 1];\\n        int[] rightMins = new int[n + 1];\\n        int leftMin = Integer.MAX_VALUE / 2;\\n        int rightMin = Integer.MAX_VALUE / 2;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // populate leftMins\\n        for (int i = 0; i <= n; i++) {\\n            if (map.containsKey(leftSum[i] - target)) {\\n                int len = i - map.get(leftSum[i] - target);\\n                if (len < leftMin) {\\n                    leftMin = len;\\n                }\\n            }\\n            leftMins[i] = leftMin;\\n            map.put(leftSum[i], i);\\n        }\\n        map.clear();\\n        // populate rightMins\\n        for (int i = n; i >= 0; i--) {\\n            if (map.containsKey(rightSum[i] - target)) {\\n                int len = map.get(rightSum[i] - target) - i;\\n                if (len < rightMin) {\\n                    rightMin = len;\\n                }\\n            }\\n            rightMins[i] = rightMin;\\n            map.put(rightSum[i], i);\\n        }\\n        // find answer\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i <= n; i++) {\\n            ans = Math.min(ans, leftMins[i] + rightMins[i]);\\n        }\\n        return ans > n ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int[] leftSum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            leftSum[i] = leftSum[i - 1] + arr[i - 1];\\n        }\\n        int[] rightSum = new int[n + 1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightSum[i] = rightSum[i + 1] + arr[i];\\n        }\\n        int[] leftMins = new int[n + 1];\\n        int[] rightMins = new int[n + 1];\\n        int leftMin = Integer.MAX_VALUE / 2;\\n        int rightMin = Integer.MAX_VALUE / 2;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // populate leftMins\\n        for (int i = 0; i <= n; i++) {\\n            if (map.containsKey(leftSum[i] - target)) {\\n                int len = i - map.get(leftSum[i] - target);\\n                if (len < leftMin) {\\n                    leftMin = len;\\n                }\\n            }\\n            leftMins[i] = leftMin;\\n            map.put(leftSum[i], i);\\n        }\\n        map.clear();\\n        // populate rightMins\\n        for (int i = n; i >= 0; i--) {\\n            if (map.containsKey(rightSum[i] - target)) {\\n                int len = map.get(rightSum[i] - target) - i;\\n                if (len < rightMin) {\\n                    rightMin = len;\\n                }\\n            }\\n            rightMins[i] = rightMin;\\n            map.put(rightSum[i], i);\\n        }\\n        // find answer\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i <= n; i++) {\\n            ans = Math.min(ans, leftMins[i] + rightMins[i]);\\n        }\\n        return ans > n ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954275,
                "title": "sliding-window-and-array-in-python",
                "content": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        if not arr: return 0\\n        n = len(arr)\\n        \\n        min_lens = [float(\\'inf\\')] * n\\n        \\n        ans = float(\\'inf\\')\\n        sum = 0\\n        s = 0\\n        min_len = float(\\'inf\\')\\n        \\n        for e in range(n):\\n            sum += arr[e]\\n            \\n            while sum > target:\\n                sum -= arr[s]\\n                s += 1\\n            if sum == target:\\n                cur_len = e - s + 1\\n                if s > 0 and min_lens[s-1] != float(\\'-inf\\'):\\n                    ans = min(ans, cur_len+min_lens[s-1])\\n                min_len = min(min_len, cur_len)\\n            min_lens[e] = min_len\\n            \\n        return -1 if ans >= float(\\'inf\\') else ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        if not arr: return 0\\n        n = len(arr)\\n        \\n        min_lens = [float(\\'inf\\')] * n\\n        \\n        ans = float(\\'inf\\')\\n        sum = 0\\n        s = 0\\n        min_len = float(\\'inf\\')\\n        \\n        for e in range(n):\\n            sum += arr[e]\\n            \\n            while sum > target:\\n                sum -= arr[s]\\n                s += 1\\n            if sum == target:\\n                cur_len = e - s + 1\\n                if s > 0 and min_lens[s-1] != float(\\'-inf\\'):\\n                    ans = min(ans, cur_len+min_lens[s-1])\\n                min_len = min(min_len, cur_len)\\n            min_lens[e] = min_len\\n            \\n        return -1 if ans >= float(\\'inf\\') else ans",
                "codeTag": "Java"
            },
            {
                "id": 934816,
                "title": "java-priorityqueue-solution-80ms-can-answer-tough-follow-up-of-printing-the-result-subarrays",
                "content": "When the question mentioned the shorted 2, I immediately thought about Priority queue :)\\nThis is not as fast as the sliding window solution, but if you want to know which 2 subarrays are in the result, this is the algorithm to pick.\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        PriorityQueue<SubArray> queue = new PriorityQueue<>();\\n        int lst = -2;\\n        int sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1); // Preparing work, the index here is the position one step before the starting subarray\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i]; // get the sum so far\\n            if(map.containsKey(sum-target) && map.get(sum-target)>lst){  \\n                // sum - (sum-target) = target, lst is the last matching starting index, if the result we get is less than lst, the resulting subarray will enclose that subarray, this for sure is not a optimal subarray\\n                int st = map.get(sum-target);\\n                int len = i-map.get(sum-target);\\n                queue.add(new SubArray(st+1, i, len));\\n                lst=st;\\n            }\\n            map.put(sum, i); // put the new sum into the map\\n        }\\n        if(queue.size()<2) return -1; // we need at least 2 subarray to have a solution\\n        List<SubArray> polled = new ArrayList<>(); // the first item in the queue is not necessarily in the result, we poll one at a time and find a valid combination\\n        while(!queue.isEmpty()){\\n            SubArray ano = queue.poll();\\n            for(int i=0; i<polled.size(); i++) {  // this for loop will only kick in starting from the second iteration of the outer while loop\\n                SubArray selected = polled.get(i); // the polled subarrayList is in ascending order, the first match we get will be the solution\\n                if(!selected.overlap(ano)){\\n                    return ano.len+selected.len;\\n                }\\n            }\\n            polled.add(ano);\\n        }\\n        return -1;\\n    }\\n    \\n    public class SubArray implements Comparable<SubArray>{\\n        int st;\\n        int en;\\n        int len;\\n        \\n        public SubArray(int st, int en, int len){\\n            this.st=st;\\n            this.en=en;\\n            this.len=len;\\n        }\\n        \\n        public int compareTo(SubArray ano) {\\n            return this.len - ano.len;\\n        }\\n        \\n        public boolean overlap(SubArray ano) {\\n            if(ano.st>this.en || ano.en<this.st) return false;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        PriorityQueue<SubArray> queue = new PriorityQueue<>();\\n        int lst = -2;\\n        int sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1); // Preparing work, the index here is the position one step before the starting subarray\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i]; // get the sum so far\\n            if(map.containsKey(sum-target) && map.get(sum-target)>lst){  \\n                // sum - (sum-target) = target, lst is the last matching starting index, if the result we get is less than lst, the resulting subarray will enclose that subarray, this for sure is not a optimal subarray\\n                int st = map.get(sum-target);\\n                int len = i-map.get(sum-target);\\n                queue.add(new SubArray(st+1, i, len));\\n                lst=st;\\n            }\\n            map.put(sum, i); // put the new sum into the map\\n        }\\n        if(queue.size()<2) return -1; // we need at least 2 subarray to have a solution\\n        List<SubArray> polled = new ArrayList<>(); // the first item in the queue is not necessarily in the result, we poll one at a time and find a valid combination\\n        while(!queue.isEmpty()){\\n            SubArray ano = queue.poll();\\n            for(int i=0; i<polled.size(); i++) {  // this for loop will only kick in starting from the second iteration of the outer while loop\\n                SubArray selected = polled.get(i); // the polled subarrayList is in ascending order, the first match we get will be the solution\\n                if(!selected.overlap(ano)){\\n                    return ano.len+selected.len;\\n                }\\n            }\\n            polled.add(ano);\\n        }\\n        return -1;\\n    }\\n    \\n    public class SubArray implements Comparable<SubArray>{\\n        int st;\\n        int en;\\n        int len;\\n        \\n        public SubArray(int st, int en, int len){\\n            this.st=st;\\n            this.en=en;\\n            this.len=len;\\n        }\\n        \\n        public int compareTo(SubArray ano) {\\n            return this.len - ano.len;\\n        }\\n        \\n        public boolean overlap(SubArray ano) {\\n            if(ano.st>this.en || ano.en<this.st) return false;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934525,
                "title": "dp-sliding-window-using-one-array-and-one-pass-98",
                "content": "Inspired by this [brilliant solution](https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/discuss/686105/JAVA-or-Sliding-window-with-only-one-array-or-No-HasMap). Beat 98% in time.\\n\\nNote that we only need to initialize the first result `dp[0]` as `Integer.MAX_VALUE`. Because every subsequent `dp[k]` is updated by the previous `dp[k-1]` and when new valid subarray is found.\\n\\n```java\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int len = arr.length;\\n        if (len < 2) {\\n            return -1;\\n        }\\n        int[] dp = new int[len];\\n        dp[0] = Integer.MAX_VALUE;\\n        int minLen = Integer.MAX_VALUE;\\n        for (int i = 0, j = 0, sum = 0; j < len; j++) {\\n            if (j > 0) {\\n                dp[j] = dp[j - 1];\\n            }\\n            sum += arr[j];\\n            while (sum > target) {\\n                sum -= arr[i++];\\n            }\\n            if (sum == target) {\\n                dp[j] = Math.min(j - i + 1, dp[j]);\\n                if (i > 0 && dp[i - 1] != Integer.MAX_VALUE) {\\n                    minLen = Math.min(j - i + 1 + dp[i - 1], minLen);\\n                }\\n                sum -= arr[i++];\\n            }\\n        }\\n        return minLen == Integer.MAX_VALUE ? -1 : minLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int len = arr.length;\\n        if (len < 2) {\\n            return -1;\\n        }\\n        int[] dp = new int[len];\\n        dp[0] = Integer.MAX_VALUE;\\n        int minLen = Integer.MAX_VALUE;\\n        for (int i = 0, j = 0, sum = 0; j < len; j++) {\\n            if (j > 0) {\\n                dp[j] = dp[j - 1];\\n            }\\n            sum += arr[j];\\n            while (sum > target) {\\n                sum -= arr[i++];\\n            }\\n            if (sum == target) {\\n                dp[j] = Math.min(j - i + 1, dp[j]);\\n                if (i > 0 && dp[i - 1] != Integer.MAX_VALUE) {\\n                    minLen = Math.min(j - i + 1 + dp[i - 1], minLen);\\n                }\\n                sum -= arr[i++];\\n            }\\n        }\\n        return minLen == Integer.MAX_VALUE ? -1 : minLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897189,
                "title": "java-o-n-with-one-dp-array-explained",
                "content": "```\\nclass Solution {\\n    /*\\n     * Idea: Use sliding window to figure out subarrays that add up to target.\\n     *       As we go, we want to store in \"dp\" the length of the shortest \\n     *       subarray we\\'ve seen up to the current \"right\" index. Every time \\n     *       we find a new subarray, we add its length to the length of the\\n     *       shortest non-overlapping subarray to its left (i.e. dp[left - 1]. \\n     *       We will try to minimize this computation as we go (variable\\n     *       \"result\").\\n     */\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int left = 0;\\n        int sum = 0;\\n        int dp[] = new int[arr.length];\\n        int result = Integer.MAX_VALUE;\\n        \\n        for (int right = 0; right < arr.length; right++) {\\n            sum += arr[right];\\n            while (sum > target) {\\n                sum -= arr[left++];\\n            }\\n            \\n            if (sum == target) {\\n                int currentLength = right - left + 1;\\n                if (left > 0 && dp[left - 1] != Integer.MAX_VALUE) {\\n                    // If we found an subarray to the left that does not overlap\\n                    // with the current subarray\\n                    result = Math.min(\\n                            result,\\n                            currentLength + dp[left - 1]);\\n                }\\n                \\n                // store in dp[right] the smallest length we have seen so far\\n                dp[right] = Math.min(currentLength, \\n                        right == 0 ? Integer.MAX_VALUE : dp[right - 1]);\\n            } else {\\n                // copy value from previous index if current subarray does not\\n                // add up to target\\n                dp[right] = right == 0 ? Integer.MAX_VALUE : dp[right - 1];\\n            }\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? -1 : result;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n     * Idea: Use sliding window to figure out subarrays that add up to target.\\n     *       As we go, we want to store in \"dp\" the length of the shortest \\n     *       subarray we\\'ve seen up to the current \"right\" index. Every time \\n     *       we find a new subarray, we add its length to the length of the\\n     *       shortest non-overlapping subarray to its left (i.e. dp[left - 1]. \\n     *       We will try to minimize this computation as we go (variable\\n     *       \"result\").\\n     */\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int left = 0;\\n        int sum = 0;\\n        int dp[] = new int[arr.length];\\n        int result = Integer.MAX_VALUE;\\n        \\n        for (int right = 0; right < arr.length; right++) {\\n            sum += arr[right];\\n            while (sum > target) {\\n                sum -= arr[left++];\\n            }\\n            \\n            if (sum == target) {\\n                int currentLength = right - left + 1;\\n                if (left > 0 && dp[left - 1] != Integer.MAX_VALUE) {\\n                    // If we found an subarray to the left that does not overlap\\n                    // with the current subarray\\n                    result = Math.min(\\n                            result,\\n                            currentLength + dp[left - 1]);\\n                }\\n                \\n                // store in dp[right] the smallest length we have seen so far\\n                dp[right] = Math.min(currentLength, \\n                        right == 0 ? Integer.MAX_VALUE : dp[right - 1]);\\n            } else {\\n                // copy value from previous index if current subarray does not\\n                // add up to target\\n                dp[right] = right == 0 ? Integer.MAX_VALUE : dp[right - 1];\\n            }\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? -1 : result;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858789,
                "title": "c-one-pass-window-scan-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int ans = 100001, currSum = 0, preIndex = 0; \\n        vector<int> f(arr.size() + 1, 100001);\\n        for (int i = 0; i < arr.size(); i++) {\\n            for (currSum += arr[i]; currSum > target; currSum -= arr[preIndex++]);\\n            if (currSum == target) {\\n                f[i + 1] = min(i + 1 - preIndex, f[i]);\\n                ans = min(ans, f[preIndex] + i + 1 - preIndex);\\n            } else {\\n                f[i + 1] = f[i];\\n            }\\n        }\\n        return ans >= 100001 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int ans = 100001, currSum = 0, preIndex = 0; \\n        vector<int> f(arr.size() + 1, 100001);\\n        for (int i = 0; i < arr.size(); i++) {\\n            for (currSum += arr[i]; currSum > target; currSum -= arr[preIndex++]);\\n            if (currSum == target) {\\n                f[i + 1] = min(i + 1 - preIndex, f[i]);\\n                ans = min(ans, f[preIndex] + i + 1 - preIndex);\\n            } else {\\n                f[i + 1] = f[i];\\n            }\\n        }\\n        return ans >= 100001 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846565,
                "title": "python-prefix-sum-dp",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not arr:\\n            return 0\\n\\n        sum_map = {0:-1}      \\n        min_arr_till = [len(arr) + 1]* len(arr)       \\n        min_subarr_found = len(arr) + 1\\n        cur_sum = 0\\n        min_sum = len(arr) + 1\\n        \\n        for idx, val in enumerate(arr):\\n            cur_sum += val\\n            \\n            if cur_sum - target in sum_map:                \\n                s, e = sum_map[cur_sum - target] , idx\\n                \\n                min_sum = min(min_sum, e-s + min_arr_till[s])\\n                \\n                # Find min_subarr till idx \\n                min_subarr_found = min(min_subarr_found, e-s )\\n                \\n            min_arr_till[idx] = min_subarr_found\\n                \\n            sum_map[cur_sum] = idx\\n        return min_sum if min_sum <= len(arr) else -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not arr:\\n            return 0\\n\\n        sum_map = {0:-1}      \\n        min_arr_till = [len(arr) + 1]* len(arr)       \\n        min_subarr_found = len(arr) + 1\\n        cur_sum = 0\\n        min_sum = len(arr) + 1\\n        \\n        for idx, val in enumerate(arr):\\n            cur_sum += val\\n            \\n            if cur_sum - target in sum_map:                \\n                s, e = sum_map[cur_sum - target] , idx\\n                \\n                min_sum = min(min_sum, e-s + min_arr_till[s])\\n                \\n                # Find min_subarr till idx \\n                min_subarr_found = min(min_subarr_found, e-s )\\n                \\n            min_arr_till[idx] = min_subarr_found\\n                \\n            sum_map[cur_sum] = idx\\n        return min_sum if min_sum <= len(arr) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808185,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ans = float(\\'inf\\')\\n        start = 0\\n        subsum = 0\\n        shortest_before = [float(\\'inf\\') for _ in range(len(arr)+1)]\\n        for end in range(len(arr)):\\n            shortest_before[end+1] = shortest_before[end]\\n            subsum += arr[end]\\n            while subsum > target and start < end:\\n                subsum -= arr[start]\\n                start += 1\\n            if subsum == target:\\n                sublen = end - start + 1\\n                ans = min(ans, shortest_before[start] + sublen)    \\n                shortest_before[end+1] = min(shortest_before[end+1], sublen)\\n        if ans == float(\\'inf\\'):\\n            ans = -1\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ans = float(\\'inf\\')\\n        start = 0\\n        subsum = 0\\n        shortest_before = [float(\\'inf\\') for _ in range(len(arr)+1)]\\n        for end in range(len(arr)):\\n            shortest_before[end+1] = shortest_before[end]\\n            subsum += arr[end]\\n            while subsum > target and start < end:\\n                subsum -= arr[start]\\n                start += 1\\n            if subsum == target:\\n                sublen = end - start + 1\\n                ans = min(ans, shortest_before[start] + sublen)    \\n                shortest_before[end+1] = min(shortest_before[end+1], sublen)\\n        if ans == float(\\'inf\\'):\\n            ans = -1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 786581,
                "title": "java-o-n-sliding-window-approach",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        \\n        if(arr == null || arr.length == 0);\\n        \\n        int len = arr.length;\\n        int[] endDp = new int[len];\\n        int[] startDp = new int[len];\\n        int start = 0, end = 0, sum = 0;\\n        int minEnd = len+1;\\n        int result = len+1;\\n        \\n        Arrays.fill(endDp, len+1);\\n        Arrays.fill(startDp, len+1);\\n        \\n       while(end < len) {\\n           sum += arr[end];\\n           \\n           while(sum >= target) {\\n               if(sum == target) {\\n                    int size = end-start+1;\\n                    startDp[start] = Math.min(size, startDp[start]);\\n                    endDp[end] = Math.min(size, endDp[end]); \\n               }\\n               \\n               sum -= arr[start];\\n               start++;\\n           }\\n           end++;\\n       }\\n        \\n        \\n        for(int i=0; i<len; i++) {\\n            if(startDp[i] != len+1 && minEnd != len+1)\\n                result = Math.min(result, minEnd + startDp[i]);\\n            if(endDp[i] != len+1) minEnd = Math.min(minEnd, endDp[i]);\\n        }\\n        \\n        return result==len+1 ? -1 : result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        \\n        if(arr == null || arr.length == 0);\\n        \\n        int len = arr.length;\\n        int[] endDp = new int[len];\\n        int[] startDp = new int[len];\\n        int start = 0, end = 0, sum = 0;\\n        int minEnd = len+1;\\n        int result = len+1;\\n        \\n        Arrays.fill(endDp, len+1);\\n        Arrays.fill(startDp, len+1);\\n        \\n       while(end < len) {\\n           sum += arr[end];\\n           \\n           while(sum >= target) {\\n               if(sum == target) {\\n                    int size = end-start+1;\\n                    startDp[start] = Math.min(size, startDp[start]);\\n                    endDp[end] = Math.min(size, endDp[end]); \\n               }\\n               \\n               sum -= arr[start];\\n               start++;\\n           }\\n           end++;\\n       }\\n        \\n        \\n        for(int i=0; i<len; i++) {\\n            if(startDp[i] != len+1 && minEnd != len+1)\\n                result = Math.min(result, minEnd + startDp[i]);\\n            if(endDp[i] != len+1) minEnd = Math.min(minEnd, endDp[i]);\\n        }\\n        \\n        return result==len+1 ? -1 : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785243,
                "title": "c-intuitive-solution-in-o-n",
                "content": "CONCEPTS USED:\\nPREFIX SUM\\nMAP TO FIND INDEX\\nMINIMUM LENGTH UPDATE \\nFORWARD AND BACKWARD TRAVERSAL OF ARRAYS\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> help(vector<int>&v,int target)\\n    {\\n        int n=v.size();\\n        map<int,int>mp;\\n        mp[0]=-1;\\n        vector<int>ans(n,n+1);\\n        vector<int>prefix(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=n+1;\\n            prefix[i]=(i==0?0:prefix[i-1])+v[i];\\n            int req=prefix[i]-target;\\n            if(mp.find(req)!=mp.end())\\n                l=i-mp[req];\\n            \\n            mp[prefix[i]]=i;\\n            ans[i]=min(l,(i==0?l:ans[i-1]));\\n        }\\n        return ans;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        vector<int>rev=arr;\\n        reverse(rev.begin(),rev.end());\\n        vector<int>left=help(arr,target);\\n        vector<int>right=help(rev,target);\\n        reverse(right.begin(),right.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans=min(ans,left[i]+right[i+1]);\\n        }\\n        return ans<=n?ans:-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> help(vector<int>&v,int target)\\n    {\\n        int n=v.size();\\n        map<int,int>mp;\\n        mp[0]=-1;\\n        vector<int>ans(n,n+1);\\n        vector<int>prefix(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=n+1;\\n            prefix[i]=(i==0?0:prefix[i-1])+v[i];\\n            int req=prefix[i]-target;\\n            if(mp.find(req)!=mp.end())\\n                l=i-mp[req];\\n            \\n            mp[prefix[i]]=i;\\n            ans[i]=min(l,(i==0?l:ans[i-1]));\\n        }\\n        return ans;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        vector<int>rev=arr;\\n        reverse(rev.begin(),rev.end());\\n        vector<int>left=help(arr,target);\\n        vector<int>right=help(rev,target);\\n        reverse(right.begin(),right.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans=min(ans,left[i]+right[i+1]);\\n        }\\n        return ans<=n?ans:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771934,
                "title": "c-o-n-solution-two-sliding-windows",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int size = arr.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        \\n        // Slide the window left to right and keep track of the minimum window length where the sum == target at each index\\n        vector<int> fwd (size, INT_MAX);\\n        int start = 0, end = 0, sum = arr[0];\\n        int minLen = INT_MAX;\\n        while (true) {\\n            if (sum == target) {\\n                minLen = min(minLen, end-start+1);\\n                fwd[end] = minLen;\\n                if (end == size-1) {break;}\\n                sum += arr[++end];\\n                continue;\\n            }\\n            \\n            if (sum > target) {\\n                sum -= arr[start++];\\n            } else {\\n                fwd[end] = minLen;\\n                if (end == size-1) {break;}\\n                sum += arr[++end];\\n            }\\n        }\\n        \\n        // Slide the window right to left and keep track of the minimum window length where the sum == target at each index\\n        vector<int> bwd (size, INT_MAX);\\n        start = size-1, end = size-1, sum = arr[size-1];\\n        minLen = INT_MAX;\\n        while (true) {\\n            if (sum == target) {\\n                minLen = min(minLen, end-start+1);\\n                bwd[start] = minLen;\\n                if (start == 0) {break;}\\n                sum += arr[--start];\\n                continue;\\n            }\\n            \\n            if (sum > target) {\\n                sum -= arr[end--];\\n            } else {\\n                bwd[start] = minLen;\\n                if (start == 0) {break;}\\n                sum += arr[--start];\\n            }\\n        }\\n\\n        int result = INT_MAX;\\n        for (int i = 0 ; i < size-1; ++i) {\\n            if (fwd[i] != INT_MAX && bwd[i+1] != INT_MAX) {\\n                result = min(result, fwd[i] + bwd[i+1]);\\n            }\\n        }\\n        \\n        return result == INT_MAX ? -1 : result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int size = arr.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        \\n        // Slide the window left to right and keep track of the minimum window length where the sum == target at each index\\n        vector<int> fwd (size, INT_MAX);\\n        int start = 0, end = 0, sum = arr[0];\\n        int minLen = INT_MAX;\\n        while (true) {\\n            if (sum == target) {\\n                minLen = min(minLen, end-start+1);\\n                fwd[end] = minLen;\\n                if (end == size-1) {break;}\\n                sum += arr[++end];\\n                continue;\\n            }\\n            \\n            if (sum > target) {\\n                sum -= arr[start++];\\n            } else {\\n                fwd[end] = minLen;\\n                if (end == size-1) {break;}\\n                sum += arr[++end];\\n            }\\n        }\\n        \\n        // Slide the window right to left and keep track of the minimum window length where the sum == target at each index\\n        vector<int> bwd (size, INT_MAX);\\n        start = size-1, end = size-1, sum = arr[size-1];\\n        minLen = INT_MAX;\\n        while (true) {\\n            if (sum == target) {\\n                minLen = min(minLen, end-start+1);\\n                bwd[start] = minLen;\\n                if (start == 0) {break;}\\n                sum += arr[--start];\\n                continue;\\n            }\\n            \\n            if (sum > target) {\\n                sum -= arr[end--];\\n            } else {\\n                bwd[start] = minLen;\\n                if (start == 0) {break;}\\n                sum += arr[--start];\\n            }\\n        }\\n\\n        int result = INT_MAX;\\n        for (int i = 0 ; i < size-1; ++i) {\\n            if (fwd[i] != INT_MAX && bwd[i+1] != INT_MAX) {\\n                result = min(result, fwd[i] + bwd[i+1]);\\n            }\\n        }\\n        \\n        return result == INT_MAX ? -1 : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758310,
                "title": "o-n-time-and-o-1-space-solution",
                "content": "```\\n\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int sum = 0, start = 0, end =0;\\n        int[] min1=null, min2=null;\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            sum = sum + arr[i];\\n            while(sum>target && start<i){\\n                sum = sum - arr[start];\\n                start++;\\n            }\\n            \\n            if(sum==target){\\n                end=i;\\n                int len = end-start+1;\\n                \\n                if(min1==null){\\n                    min1 = new int[]{start, end, len};\\n                }else if(min2==null){\\n                    min2 = new int[]{start, end, len};\\n                    res = checkAndUpdate(res, min1, min2);\\n                }else{\\n                    \\n                    res = checkAndUpdate(res, min1, new int[]{start, end, len});\\n                    res = checkAndUpdate(res, min2, new int[]{start, end, len});\\n                    \\n                    if(len < min1[2] && len < min2[2]){\\n                        if(min1[2] > min2[2]){\\n                            min1 = min2;\\n                            min2 = new int[]{start, end, len};\\n                        }else{\\n                            min2 = new int[]{start, end, len};\\n                        }\\n                    }else if(len <min2[2]) {\\n                        min2 = new int[]{start, end, len};\\n                    }else if(len < min1[2]){\\n                        min1 = new int[]{start, end, len};\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return res == Integer.MAX_VALUE ?-1:res;\\n    }\\n    \\n    int checkAndUpdate(int res, int[] min1, int[] min2){\\n        if(min1 != null && min2 != null){\\n                    //is min1 and min2 overlapping\\n                    if((min1[0] <= min2[0] && min1[1]>=min2[0]) || (min1[0] <= min2[1] && min1[1]>=min2[1])){\\n\\n                    }else{\\n                        res = Math.min(res, min1[2]+min2[2]);\\n                    }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int sum = 0, start = 0, end =0;\\n        int[] min1=null, min2=null;\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            sum = sum + arr[i];\\n            while(sum>target && start<i){\\n                sum = sum - arr[start];\\n                start++;\\n            }\\n            \\n            if(sum==target){\\n                end=i;\\n                int len = end-start+1;\\n                \\n                if(min1==null){\\n                    min1 = new int[]{start, end, len};\\n                }else if(min2==null){\\n                    min2 = new int[]{start, end, len};\\n                    res = checkAndUpdate(res, min1, min2);\\n                }else{\\n                    \\n                    res = checkAndUpdate(res, min1, new int[]{start, end, len});\\n                    res = checkAndUpdate(res, min2, new int[]{start, end, len});\\n                    \\n                    if(len < min1[2] && len < min2[2]){\\n                        if(min1[2] > min2[2]){\\n                            min1 = min2;\\n                            min2 = new int[]{start, end, len};\\n                        }else{\\n                            min2 = new int[]{start, end, len};\\n                        }\\n                    }else if(len <min2[2]) {\\n                        min2 = new int[]{start, end, len};\\n                    }else if(len < min1[2]){\\n                        min1 = new int[]{start, end, len};\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return res == Integer.MAX_VALUE ?-1:res;\\n    }\\n    \\n    int checkAndUpdate(int res, int[] min1, int[] min2){\\n        if(min1 != null && min2 != null){\\n                    //is min1 and min2 overlapping\\n                    if((min1[0] <= min2[0] && min1[1]>=min2[0]) || (min1[0] <= min2[1] && min1[1]>=min2[1])){\\n\\n                    }else{\\n                        res = Math.min(res, min1[2]+min2[2]);\\n                    }\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 751038,
                "title": "java-sliding-window-o-n",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        long[] left=new long[arr.length];\\n        long[] right=new long[arr.length];\\n        long leftlen=Integer.MAX_VALUE;\\n        int sum=0;\\n        int start=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            while(sum>target){\\n               sum-=arr[start++];\\n            }\\n            if(sum==target){\\n                leftlen=Math.min(leftlen,i-start+1);\\n            }\\n                left[i]=leftlen;\\n        }\\n        sum=0;\\n        start=arr.length-1;\\n        long rightlen=Integer.MAX_VALUE;\\n        for(int i=arr.length-1;i>=0;i--){\\n            sum+=arr[i];\\n            while(sum>target){\\n               sum-=arr[start--];\\n            }\\n            if(sum==target){\\n                rightlen=Math.min(rightlen,start-i+1);\\n            }\\n           \\n                right[i]=rightlen;\\n        }\\n        // for(int i=0;i<arr.length;i++){\\n        //     System.out.println(left[i]+\" \"+right[i]);\\n        // }\\n       \\n        long max=Integer.MAX_VALUE;\\n        for(int i=1;i<arr.length;i++){\\n            //System.out.println(left[i-1]+right[i]);\\n            max=Math.min(left[i-1]+right[i],max);\\n        }\\n       return (int)(max>=Integer.MAX_VALUE?-1:max);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        long[] left=new long[arr.length];\\n        long[] right=new long[arr.length];\\n        long leftlen=Integer.MAX_VALUE;\\n        int sum=0;\\n        int start=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            while(sum>target){\\n               sum-=arr[start++];\\n            }\\n            if(sum==target){\\n                leftlen=Math.min(leftlen,i-start+1);\\n            }\\n                left[i]=leftlen;\\n        }\\n        sum=0;\\n        start=arr.length-1;\\n        long rightlen=Integer.MAX_VALUE;\\n        for(int i=arr.length-1;i>=0;i--){\\n            sum+=arr[i];\\n            while(sum>target){\\n               sum-=arr[start--];\\n            }\\n            if(sum==target){\\n                rightlen=Math.min(rightlen,start-i+1);\\n            }\\n           \\n                right[i]=rightlen;\\n        }\\n        // for(int i=0;i<arr.length;i++){\\n        //     System.out.println(left[i]+\" \"+right[i]);\\n        // }\\n       \\n        long max=Integer.MAX_VALUE;\\n        for(int i=1;i<arr.length;i++){\\n            //System.out.println(left[i-1]+right[i]);\\n            max=Math.min(left[i-1]+right[i],max);\\n        }\\n       return (int)(max>=Integer.MAX_VALUE?-1:max);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727893,
                "title": "python-80-speed-pure-o-n-solution-scheduled-delivery",
                "content": "**Python [80% Speed] - Pure O(n) Solution - Scheduled Delivery**\\n\\nThe code below is a pure O(n) solution for the problem. It tracks the shortest length with sum=target before a given arr[i] value.\\n\\nCuriously enough, Leetcode rated the second code attached as being slightly faster. It uses a O(n) linear scanning pass , followed by a O(r^2) loop searching for the shortest compatible sub-arrays. The good run-times are probably due to the pre-sorting step for the valid ranges, plus all the early exit conditions.\\n\\n```\\n# Solution A: Pure O(n) solution; tracking the best ranges found so far.\\nposInf = float(\\'inf\\')\\nfmin = lambda x,y: x if x<y else y # High Speed min function (33% faster than standard)\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        S = [0]\\n        for x in arr:\\n            S.append( S[-1]+x )\\n        dictS = dict(zip(S,range(len(S))))\\n        #\\n        result,best = posInf, posInf # best is the shortest range before arr[i]\\n        schedule = {} # Schedule of ranges to inject into \"best\"\\n        for i in range(len(arr)):\\n            s = S[i] # sum before adding arr[i]\\n            if (s+target) in dictS:\\n                j = dictS[s+target] - 1 # S-indexes are shifted by one\\n                schedule[j] = j-i+1     # latest is always the best (shortest i for the same j)\\n                result = fmin(result,best+j-i+1)\\n            if i in schedule:\\n                best = fmin(best,schedule[i]) # improve best prev. length\\n        return result if result<posInf else -1\\n```\\n\\n```\\n# Solution B: O(n) Linear Scanning Pass, followed by O(r^2) search among valid ranges\\n#                  (pre-sorting + solid exit conditions for the O(r^2) loop achieve a high Leetcode rating)\\nposInf = float(\\'inf\\')\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        s, seen = 0, {}\\n        found   = []\\n        seen[0] = -1 # (theoretical adjustment) (sum = 0 seen at i = -1)\\n        for i,x in enumerate(arr):\\n            s += x\\n            if s-target in seen:\\n                found.append( [seen[s-target]+1,i] )\\n            seen[s] = i\\n        #\\n        found.sort(key = lambda x: [x[1]-x[0],x]) # sort first by length, then by index\\n        if len(found)<2:\\n            return -1\\n        Lf = len(found)\\n        result = a2 = posInf\\n        for i in range(Lf-1):\\n            i1,j1 = found[i]\\n            a1 = j1-i1+1\\n            if (not i<Lf) or (a1>=a2): # We can\\'t seach for a range bigger than before. If we\\'re using a range of equal length, just exit\\n                break\\n            a2 = posInf\\n            for j in range(i+1,Lf):\\n                i2,j2 = found[j]\\n                if not ( i1<=i2<=j1 or i1<=j2<=j1 ):\\n                    a2 = j2-i2+1 # valid range found\\n                    Lf = j       # make sure you never explore any further than this \\n                    break\\n            if (a1+a2)<result:\\n                result = a1+a2\\n        return result if result<posInf else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Solution A: Pure O(n) solution; tracking the best ranges found so far.\\nposInf = float(\\'inf\\')\\nfmin = lambda x,y: x if x<y else y # High Speed min function (33% faster than standard)\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        S = [0]\\n        for x in arr:\\n            S.append( S[-1]+x )\\n        dictS = dict(zip(S,range(len(S))))\\n        #\\n        result,best = posInf, posInf # best is the shortest range before arr[i]\\n        schedule = {} # Schedule of ranges to inject into \"best\"\\n        for i in range(len(arr)):\\n            s = S[i] # sum before adding arr[i]\\n            if (s+target) in dictS:\\n                j = dictS[s+target] - 1 # S-indexes are shifted by one\\n                schedule[j] = j-i+1     # latest is always the best (shortest i for the same j)\\n                result = fmin(result,best+j-i+1)\\n            if i in schedule:\\n                best = fmin(best,schedule[i]) # improve best prev. length\\n        return result if result<posInf else -1\\n```\n```\\n# Solution B: O(n) Linear Scanning Pass, followed by O(r^2) search among valid ranges\\n#                  (pre-sorting + solid exit conditions for the O(r^2) loop achieve a high Leetcode rating)\\nposInf = float(\\'inf\\')\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        s, seen = 0, {}\\n        found   = []\\n        seen[0] = -1 # (theoretical adjustment) (sum = 0 seen at i = -1)\\n        for i,x in enumerate(arr):\\n            s += x\\n            if s-target in seen:\\n                found.append( [seen[s-target]+1,i] )\\n            seen[s] = i\\n        #\\n        found.sort(key = lambda x: [x[1]-x[0],x]) # sort first by length, then by index\\n        if len(found)<2:\\n            return -1\\n        Lf = len(found)\\n        result = a2 = posInf\\n        for i in range(Lf-1):\\n            i1,j1 = found[i]\\n            a1 = j1-i1+1\\n            if (not i<Lf) or (a1>=a2): # We can\\'t seach for a range bigger than before. If we\\'re using a range of equal length, just exit\\n                break\\n            a2 = posInf\\n            for j in range(i+1,Lf):\\n                i2,j2 = found[j]\\n                if not ( i1<=i2<=j1 or i1<=j2<=j1 ):\\n                    a2 = j2-i2+1 # valid range found\\n                    Lf = j       # make sure you never explore any further than this \\n                    break\\n            if (a1+a2)<result:\\n                result = a1+a2\\n        return result if result<posInf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725446,
                "title": "c-clean-2-pass-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size(), sum = 0, minLen = INT_MAX, result = INT_MAX;\\n        vector<int> leftScan(n);\\n        unordered_map<int, int> lookup1, lookup2;\\n        \\n        lookup1[0] = -1, lookup2[0] = n;        \\n        \\n        // left scan\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            int diff = sum - target;\\n            \\n            if (lookup1.count(diff))\\n                minLen = min(minLen, i - lookup1[diff]);\\n            \\n            lookup1[sum] = i;\\n            leftScan[i] = minLen;         \\n        }\\n        \\n        sum = 0, minLen = INT_MAX;\\n        \\n        // rightScan\\n        for (int i = n-1; i > 0; i--) {\\n            sum += arr[i];\\n            int diff = sum - target;            \\n            \\n            if (lookup2.count(diff))\\n                minLen = min(minLen, lookup2[diff] - i);\\n                    \\n            lookup2[sum] = i;\\n            \\n            if (leftScan[i-1] != INT_MAX and minLen != INT_MAX)\\n                result = min(result, leftScan[i-1] + minLen);\\n        }\\n        \\n        return result == INT_MAX ? -1 : result;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size(), sum = 0, minLen = INT_MAX, result = INT_MAX;\\n        vector<int> leftScan(n);\\n        unordered_map<int, int> lookup1, lookup2;\\n        \\n        lookup1[0] = -1, lookup2[0] = n;        \\n        \\n        // left scan\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            int diff = sum - target;\\n            \\n            if (lookup1.count(diff))\\n                minLen = min(minLen, i - lookup1[diff]);\\n            \\n            lookup1[sum] = i;\\n            leftScan[i] = minLen;         \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 722871,
                "title": "solution-using-prefix-sums-and-binary-search",
                "content": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>&a, int t) {int n=a.size(),i,mini=n+1;\\n        int pref_l[n],pref_r[n],l[n],r[n];\\n        for(i=0;i<n;i++)\\n            l[i]=r[i]=n;\\n        for(i=0;i<n;i++)\\n        {\\n            pref_l[i]=a[i];\\n            if(i)\\n                pref_l[i]+=pref_l[i-1];\\n            if(pref_l[i]==t)\\n                l[i]=i+1;\\n            else if(pref_l[i]>t)\\n            {\\n                int index=upper_bound(pref_l,pref_l+i,pref_l[i]-t)-pref_l;\\n                if(index&&pref_l[index-1]==(pref_l[i]-t))\\n                    l[i]=i-index+1;\\n            }\\n            if(i)\\n                l[i]=min(l[i],l[i-1]);\\n        }\\n        for(i=n-1;i>=0;i--)\\n        {\\n            pref_r[i]=a[i];\\n            if(i<n-1)\\n                pref_r[i]+=pref_r[i+1];\\n            if(pref_r[i]==t)\\n                r[i]=n-i;\\n            else if(pref_r[i]>t)\\n            {\\n                int index=lower_bound(pref_r+i,pref_r+n,pref_r[i]-t,greater<int>())-pref_r;\\n                if(index<n&&pref_r[index]==pref_r[i]-t)\\n                    r[i]=index-i;\\n            }\\n            if(i<n-1)\\n                r[i]=min(r[i],r[i+1]);\\n        }\\n        for(i=0;i<n-1;i++)\\n        {\\n            if(l[i]!=n&&r[i+1]!=n)\\n                mini=min(mini,l[i]+r[i+1]);\\n        }\\n        if(mini!=n+1)\\n            return mini;\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>&a, int t) {int n=a.size(),i,mini=n+1;\\n        int pref_l[n],pref_r[n],l[n],r[n];\\n        for(i=0;i<n;i++)\\n            l[i]=r[i]=n;\\n        for(i=0;i<n;i++)\\n        {\\n            pref_l[i]=a[i];\\n            if(i)\\n                pref_l[i]+=pref_l[i-1];\\n            if(pref_l[i]==t)\\n                l[i]=i+1;\\n            else if(pref_l[i]>t)\\n            {\\n                int index=upper_bound(pref_l,pref_l+i,pref_l[i]-t)-pref_l;\\n                if(index&&pref_l[index-1]==(pref_l[i]-t))\\n                    l[i]=i-index+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 716525,
                "title": "javascript-math-solution",
                "content": "Array building shenanigans didn\\'t cut it this time, so I used math instead.\\n\\n_Runtime: 116 ms, faster than 95.60% of JavaScript online submissions_\\n_Memory Usage: 45.5 MB, less than 100.00% of JavaScript online submissions_\\n\\n```javascript\\n/**\\n * Slide in a sub-array from the left and a sub-array from the right\\n * Slide whichever has seen the longest sub-array with the target sum\\u2020\\u2021\\n * Stop when they touch\\n *\\n * \\u2020 When they\\'re equal, slide the right sub-array\\n * \\u2021 In order to give that side a chance to find a shorter matching sub-array\\n *\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nconst minSumOfLengths = (arr, target) => {\\n  // Indices for the heads & tails of the left & right sub-arrays\\n  let [lt, lh, rh, rt] = [0, 0, arr.length - 1, arr.length - 1];\\n  // Sums for the left & right sub-arrays\\n  let [lSum, rSum] = [arr[lh], arr[rh]];\\n  // Lengths of of the shortest left & right sub-arrays with the target sum\\n  let [lMinLen, rMinLen] = [Infinity, Infinity];\\n  // While the left & right sub-arrays (heads) aren\\'t overlapping\\n  while (lh < rh) {\\n    // If the left sub-array sum is too big, contract the left tail\\n    /* \\uD83C\\uDF2E */ while (target < lSum) lSum -= arr[lt++];\\n    // If the right sub-array sum is too big, contract the right tail\\n    /* \\uD83C\\uDF2E */ while (target < rSum) rSum -= arr[rt--];\\n    // If the left sub-array sum is correct, remember its length if shorter\\n    if (lSum === target) lMinLen = Math.min(lMinLen, lh - lt + 1);\\n    // If the right sub-array sum is correct, remember its length if shorter\\n    if (rSum === target) rMinLen = Math.min(rMinLen, rt - rh + 1);\\n    // If the the right sub-array is bigger, extend the right window head\\n    if (lMinLen <= rMinLen) rSum += arr[--rh];\\n    // Else, if the the left sub-array is bigger, extend the left window head\\n    else lSum += arr[++lh];\\n    // Go back to the lines with tacos (\\uD83C\\uDF2E\\uD83C\\uDF2E), they will make more sense now\\n  }\\n  // Return -1 if either sub-array did not find the target sum else the answer\\n  return Infinity === lMinLen + rMinLen ? -1 : lMinLen + rMinLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```javascript\\n/**\\n * Slide in a sub-array from the left and a sub-array from the right\\n * Slide whichever has seen the longest sub-array with the target sum\\u2020\\u2021\\n * Stop when they touch\\n *\\n * \\u2020 When they\\'re equal, slide the right sub-array\\n * \\u2021 In order to give that side a chance to find a shorter matching sub-array\\n *\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nconst minSumOfLengths = (arr, target) => {\\n  // Indices for the heads & tails of the left & right sub-arrays\\n  let [lt, lh, rh, rt] = [0, 0, arr.length - 1, arr.length - 1];\\n  // Sums for the left & right sub-arrays\\n  let [lSum, rSum] = [arr[lh], arr[rh]];\\n  // Lengths of of the shortest left & right sub-arrays with the target sum\\n  let [lMinLen, rMinLen] = [Infinity, Infinity];\\n  // While the left & right sub-arrays (heads) aren\\'t overlapping\\n  while (lh < rh) {\\n    // If the left sub-array sum is too big, contract the left tail\\n    /* \\uD83C\\uDF2E */ while (target < lSum) lSum -= arr[lt++];\\n    // If the right sub-array sum is too big, contract the right tail\\n    /* \\uD83C\\uDF2E */ while (target < rSum) rSum -= arr[rt--];\\n    // If the left sub-array sum is correct, remember its length if shorter\\n    if (lSum === target) lMinLen = Math.min(lMinLen, lh - lt + 1);\\n    // If the right sub-array sum is correct, remember its length if shorter\\n    if (rSum === target) rMinLen = Math.min(rMinLen, rt - rh + 1);\\n    // If the the right sub-array is bigger, extend the right window head\\n    if (lMinLen <= rMinLen) rSum += arr[--rh];\\n    // Else, if the the left sub-array is bigger, extend the left window head\\n    else lSum += arr[++lh];\\n    // Go back to the lines with tacos (\\uD83C\\uDF2E\\uD83C\\uDF2E), they will make more sense now\\n  }\\n  // Return -1 if either sub-array did not find the target sum else the answer\\n  return Infinity === lMinLen + rMinLen ? -1 : lMinLen + rMinLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699937,
                "title": "dp-sliding-window",
                "content": "import java.util.Arrays;\\n\\nclass Solution {\\n\\n    public int minSumOfLengths(int[] arr, int target) {\\n\\t\\n        int n=arr.length, i=0, cur_sum=0;\\n        int[] dp=new int[n];\\n        int inf=Integer.MAX_VALUE;\\n        int min_len=inf;\\n        Arrays.fill(dp,inf);\\n\\n        for (int j=0;j<n;j++){\\n            cur_sum+=arr[j];\\n\\n            if (i<n && cur_sum>target){//if current sum greater thn sum need to reduce subarray from left side\\n\\t\\t\\t\\n                while (cur_sum>target){\\n\\t\\t\\t\\t\\n                    cur_sum-=arr[i++];\\n\\t\\t\\t\\t\\t\\n                }\\n\\n            }\\n\\n            if (cur_sum==target){// subarray sum equal to target found\\n                dp[j]=(j-i)+1;//getting up length of target subarray\\n\\n                if (i-1>=0 && dp[i-1]!=Integer.MAX_VALUE){// geeting up minimum length of two non overlapping sub array\\n                    min_len=Math.min(dp[j]+dp[i-1],min_len);\\n                }\\n            }\\n\\n\\n            if (j-1>=0){// getting up minimum length of target sum subaray so that if in future we get subarray thn we always get minimum sum of two\\n                dp[j]=Math.min(dp[j],dp[j-1]);\\n            }\\n\\n        }\\n        return min_len==inf?-1:min_len;\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int minSumOfLengths(int[] arr, int target) {\\n\\t\\n        int n=arr.length, i=0, cur_sum=0;\\n        int[] dp=new int[n];\\n        int inf=Integer.MAX_VALUE;\\n        int min_len=inf;\\n        Arrays.fill(dp,inf);\\n\\n        for (int j=0;j<n;j++){\\n            cur_sum+=arr[j];\\n\\n            if (i<n && cur_sum>target){//if current sum greater thn sum need to reduce subarray from left side\\n\\t\\t\\t\\n                while (cur_sum>target){\\n\\t\\t\\t\\t\\n                    cur_sum-=arr[i++];\\n\\t\\t\\t\\t\\t\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 690810,
                "title": "c-solution-with-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minn(long a, long b) {\\n        if(a > b)\\n            return b;\\n        return a;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<long> v(n);\\n        int sum = 0;\\n        long result = INT_MAX;\\n        int i = 0, j = 0;\\n        for(int i = 0; i < n; i++)\\n            v[i] = INT_MAX;\\n        while(i < n) {\\n            if(i != 0)\\n                v[i] = v[i - 1];\\n            sum = sum + arr[i];\\n            while(sum > target) {\\n                sum = sum - arr[j];\\n                j++;\\n            }\\n            if(sum == target) {\\n                int len = i - j + 1;\\n                if(i == 0) { \\n                    v[i] = len; \\n                } else {\\n                    v[i] = minn(v[i], len);\\n                }\\n                if(j > 0)\\n                    result = minn(result, v[j - 1] + len);\\n            }\\n            i++;\\n        }\\n        if(result >= INT_MAX)\\n            return -1;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minn(long a, long b) {\\n        if(a > b)\\n            return b;\\n        return a;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<long> v(n);\\n        int sum = 0;\\n        long result = INT_MAX;\\n        int i = 0, j = 0;\\n        for(int i = 0; i < n; i++)\\n            v[i] = INT_MAX;\\n        while(i < n) {\\n            if(i != 0)\\n                v[i] = v[i - 1];\\n            sum = sum + arr[i];\\n            while(sum > target) {\\n                sum = sum - arr[j];\\n                j++;\\n            }\\n            if(sum == target) {\\n                int len = i - j + 1;\\n                if(i == 0) { \\n                    v[i] = len; \\n                } else {\\n                    v[i] = minn(v[i], len);\\n                }\\n                if(j > 0)\\n                    result = minn(result, v[j - 1] + len);\\n            }\\n            i++;\\n        }\\n        if(result >= INT_MAX)\\n            return -1;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688624,
                "title": "c-easy-o-n-dp-sliding-combo",
                "content": "The basic idea is to use sliding window approach in order to detect all continiuous subarrays which are equal to target. \\nIn our DP array we store a length of the shortest subarray which we found on interval [0, index]. So if we have found new interval, we can check the length of the shortest prev one on dp[start - 1].\\n\\n```\\nint minSumOfLengths(vector<int>& arr, int target) \\n{\\n\\tvector<int> dp(arr.size() + 1, INT_MAX);\\n\\tint result = INT_MAX;\\n\\n\\tfor (int start = 1, index = 1, sum = 0; index <= arr.size(); ++index)\\n\\t{\\n\\t\\tsum += arr[index - 1];\\n\\t\\tdp[index] = dp[index - 1];\\n\\n\\t\\twhile (start < index && sum > target)\\n\\t\\t\\tsum -= arr[start++ - 1];\\n\\n\\t\\tif (sum == target)\\n\\t\\t{\\n\\t\\t\\tif (dp[start - 1] != INT_MAX)\\n\\t\\t\\t\\tresult = min(result, dp[start - 1] + index - start + 1);\\n\\n\\t\\t\\tdp[index] = min(dp[index], index - start + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result == INT_MAX ? -1 : result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minSumOfLengths(vector<int>& arr, int target) \\n{\\n\\tvector<int> dp(arr.size() + 1, INT_MAX);\\n\\tint result = INT_MAX;\\n\\n\\tfor (int start = 1, index = 1, sum = 0; index <= arr.size(); ++index)\\n\\t{\\n\\t\\tsum += arr[index - 1];\\n\\t\\tdp[index] = dp[index - 1];\\n\\n\\t\\twhile (start < index && sum > target)\\n\\t\\t\\tsum -= arr[start++ - 1];\\n\\n\\t\\tif (sum == target)\\n\\t\\t{\\n\\t\\t\\tif (dp[start - 1] != INT_MAX)\\n\\t\\t\\t\\tresult = min(result, dp[start - 1] + index - start + 1);\\n\\n\\t\\t\\tdp[index] = min(dp[index], index - start + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result == INT_MAX ? -1 : result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688106,
                "title": "swift-o-n",
                "content": "First: we need to create a dictionary with sums up to index `dict[sumTillIndex] = index`\\nSecond: for each index we find the lengths of the subarray with sum = `target` on the left and subarray with sum `target` on the right. If two lengths combined are shorted then previous result - rememeber it as intermediate result.\\n```\\nfinal class Solution {\\n    func minSumOfLengths(_ arr: [Int], _ target: Int) -> Int {\\n        var sum = 0\\n        var dict = [0: -1]\\n        for i in arr.indices {\\n            sum += arr[i]\\n            dict[sum] = i\\n        }\\n\\n        sum = 0\\n        var result = Int.max\\n        var leftLength = Int.max\\n        for i in arr.indices {\\n            sum += arr[i]\\n\\n            if let leftIndex = dict[sum - target] {\\n                leftLength = min(leftLength, i - leftIndex)\\n            }\\n\\n            if let rightIndex = dict[sum + target], leftLength < Int.max {\\n                result = min(result, rightIndex - i + leftLength)\\n            }\\n        }\\n\\n        return result == Int.max ? -1 : result\\n    }\\n}\\n```\\nor if you want to achieve the same with only one run:\\n```\\nfinal class Solution {\\n    func minSumOfLengths(_ arr: [Int], _ target: Int) -> Int {\\n        var result = Int.max\\n        var sum = 0\\n        var dict = [0: -1]\\n        var bestTill = Array(repeating: Int.max, count: arr.count)\\n        var best = Int.max\\n        for i in arr.indices {\\n            sum += arr[i]\\n            if let value = dict[sum - target] {\\n                if value > -1 && bestTill[value] != .max {\\n                    result = min(result, i - value + bestTill[value])\\n                }\\n                best = min(best, i - value)\\n            }\\n\\n            bestTill[i] = best\\n            dict[sum] = i\\n        }\\n\\n        return result == Int.max ? -1 : result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfinal class Solution {\\n    func minSumOfLengths(_ arr: [Int], _ target: Int) -> Int {\\n        var sum = 0\\n        var dict = [0: -1]\\n        for i in arr.indices {\\n            sum += arr[i]\\n            dict[sum] = i\\n        }\\n\\n        sum = 0\\n        var result = Int.max\\n        var leftLength = Int.max\\n        for i in arr.indices {\\n            sum += arr[i]\\n\\n            if let leftIndex = dict[sum - target] {\\n                leftLength = min(leftLength, i - leftIndex)\\n            }\\n\\n            if let rightIndex = dict[sum + target], leftLength < Int.max {\\n                result = min(result, rightIndex - i + leftLength)\\n            }\\n        }\\n\\n        return result == Int.max ? -1 : result\\n    }\\n}\\n```\n```\\nfinal class Solution {\\n    func minSumOfLengths(_ arr: [Int], _ target: Int) -> Int {\\n        var result = Int.max\\n        var sum = 0\\n        var dict = [0: -1]\\n        var bestTill = Array(repeating: Int.max, count: arr.count)\\n        var best = Int.max\\n        for i in arr.indices {\\n            sum += arr[i]\\n            if let value = dict[sum - target] {\\n                if value > -1 && bestTill[value] != .max {\\n                    result = min(result, i - value + bestTill[value])\\n                }\\n                best = min(best, i - value)\\n            }\\n\\n            bestTill[i] = best\\n            dict[sum] = i\\n        }\\n\\n        return result == Int.max ? -1 : result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687852,
                "title": "java-prefix",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] A, int T) {\\n        Map<Integer,Integer>map1=new HashMap<>();\\n        int sum1=0;\\n        int front[]=new int[A.length];\\n        Arrays.fill(front,Integer.MAX_VALUE);\\n        for(int i=0;i<A.length;i++){\\n            sum1+=A[i];\\n            if(map1.containsKey(sum1-T)){\\n                front[i]=i-map1.get(sum1-T);\\n            }\\n            if(sum1==T){\\n                front[i]=Math.min(front[i],i+1);\\n            }\\n            if(i-1>=0)front[i]=Math.min(front[i-1],front[i]);\\n            map1.put(sum1,i);\\n        }\\n        \\n        Map<Integer,Integer>map2=new HashMap<>();\\n        int sum2=0;\\n        int back[]=new int[A.length];\\n        Arrays.fill(back,Integer.MAX_VALUE);\\n        for(int i=A.length-1;i>=0;i--){\\n            sum2+=A[i];\\n            if(map2.containsKey(sum2-T)){\\n                back[i]=map2.get(sum2-T)-i;\\n            }\\n            if(sum2==T){\\n                back[i]=Math.min(back[i],back.length-i);\\n            }\\n            if(i+1<back.length)back[i]=Math.min(back[i+1],back[i]);\\n            map2.put(sum2,i);\\n        }\\n        \\n        \\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<A.length-1;i++){\\n            if(front[i]!=Integer.MAX_VALUE&&back[i+1]!=Integer.MAX_VALUE){\\n                res=Math.min(res,front[i]+back[i+1]);\\n            }\\n        }\\n        if(res==Integer.MAX_VALUE)return -1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] A, int T) {\\n        Map<Integer,Integer>map1=new HashMap<>();\\n        int sum1=0;\\n        int front[]=new int[A.length];\\n        Arrays.fill(front,Integer.MAX_VALUE);\\n        for(int i=0;i<A.length;i++){\\n            sum1+=A[i];\\n            if(map1.containsKey(sum1-T)){\\n                front[i]=i-map1.get(sum1-T);\\n            }\\n            if(sum1==T){\\n                front[i]=Math.min(front[i],i+1);\\n            }\\n            if(i-1>=0)front[i]=Math.min(front[i-1],front[i]);\\n            map1.put(sum1,i);\\n        }\\n        \\n        Map<Integer,Integer>map2=new HashMap<>();\\n        int sum2=0;\\n        int back[]=new int[A.length];\\n        Arrays.fill(back,Integer.MAX_VALUE);\\n        for(int i=A.length-1;i>=0;i--){\\n            sum2+=A[i];\\n            if(map2.containsKey(sum2-T)){\\n                back[i]=map2.get(sum2-T)-i;\\n            }\\n            if(sum2==T){\\n                back[i]=Math.min(back[i],back.length-i);\\n            }\\n            if(i+1<back.length)back[i]=Math.min(back[i+1],back[i]);\\n            map2.put(sum2,i);\\n        }\\n        \\n        \\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<A.length-1;i++){\\n            if(front[i]!=Integer.MAX_VALUE&&back[i+1]!=Integer.MAX_VALUE){\\n                res=Math.min(res,front[i]+back[i+1]);\\n            }\\n        }\\n        if(res==Integer.MAX_VALUE)return -1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687491,
                "title": "c-well-commented-o-n-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        \\n        //The i-th index of two vectors below will store the minlength of subarray having sum equal to target and ending and starting at i respectively, if there is no such subarray fill it with INT_MAX\\n        vector<int> subarrayEndingAt(n,INT_MAX);\\n        vector<int> subarrayStartingAt(n,INT_MAX);\\n        \\n        \\n        //The classical way of finding the min lenght of subarray ending at index i and having sum equal to target :\\n        //We store the sum of prefixes in a map along with the index the prefix is upto\\n        unordered_map<int,int> mp;\\n        mp[0]=-1;           //to handel cases when prefix is equal to target itself\\n        \\n        //the accumulator of the prefix sums\\n        int curr_prefix_sum=0;\\n        \\n        for(int i=0;i<n;i++){\\n            curr_prefix_sum+=arr[i];\\n            \\n            //check if any such prefix is there in the map which when subtracted from the current prefix results in the target value i.e target + prefix == curr_prefix_sum\\n            //if it is there then it simply means there is a subarray ending at i that has sum equal to target so ve store the length of this subarray at this index\\n            if(mp.count(curr_prefix_sum-target)) subarrayEndingAt[i]=i-mp[curr_prefix_sum-target];\\n            \\n            //we insert the curr_prefix_sum in the map for the further use\\n            mp[curr_prefix_sum]=i;\\n        }\\n        \\n        \\n        //We do the same thing above in the reverse manner / to make it even more effective we can make this second vector from the first vector itself but just to keep it simple we do use the same method int \\n        //reverse direction now using suffixes instead of prefixes\\n        unordered_map<int,int> mp2;\\n        mp2[0]=n;\\n        \\n        int curr_suffix_sum=0;\\n        for(int i=n-1;i>=0;i--){\\n            curr_suffix_sum+=arr[i];\\n            if(mp2.count(curr_suffix_sum-target)) subarrayStartingAt[i]=mp2[curr_suffix_sum-target]-i;\\n            mp2[curr_suffix_sum]=i;\\n        }\\n        \\n        \\n        \\n        \\n        long long ans=INT_MAX;\\n        \\n        //this will store the min length of subarray that has already appeared before the current index\\n        int minEndingBefore=INT_MAX;\\n        \\n        for(int i=0;i<n;i++){\\n            //we take the length of subarray starting at current index and add length of subarray that has already ended and has minimum length and ,update the ans as the minimum of this value or previous answer\\n            ans=min(ans,(long long)subarrayStartingAt[i]+minEndingBefore);\\n            \\n            //updating minEndingBefore for further use\\n            minEndingBefore=min(minEndingBefore,subarrayEndingAt[i]);\\n        }\\n        \\n        \\n        //if there was not any answer and we were just having INT_MAX in array / or just 1 subarray or overlapping subarrays the ans would be greater than INT_MAX so return -1\\n        if(ans>=INT_MAX){\\n            return -1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        \\n        //The i-th index of two vectors below will store the minlength of subarray having sum equal to target and ending and starting at i respectively, if there is no such subarray fill it with INT_MAX\\n        vector<int> subarrayEndingAt(n,INT_MAX);\\n        vector<int> subarrayStartingAt(n,INT_MAX);\\n        \\n        \\n        //The classical way of finding the min lenght of subarray ending at index i and having sum equal to target :\\n        //We store the sum of prefixes in a map along with the index the prefix is upto\\n        unordered_map<int,int> mp;\\n        mp[0]=-1;           //to handel cases when prefix is equal to target itself\\n        \\n        //the accumulator of the prefix sums\\n        int curr_prefix_sum=0;\\n        \\n        for(int i=0;i<n;i++){\\n            curr_prefix_sum+=arr[i];\\n            \\n            //check if any such prefix is there in the map which when subtracted from the current prefix results in the target value i.e target + prefix == curr_prefix_sum\\n            //if it is there then it simply means there is a subarray ending at i that has sum equal to target so ve store the length of this subarray at this index\\n            if(mp.count(curr_prefix_sum-target)) subarrayEndingAt[i]=i-mp[curr_prefix_sum-target];\\n            \\n            //we insert the curr_prefix_sum in the map for the further use\\n            mp[curr_prefix_sum]=i;\\n        }\\n        \\n        \\n        //We do the same thing above in the reverse manner / to make it even more effective we can make this second vector from the first vector itself but just to keep it simple we do use the same method int \\n        //reverse direction now using suffixes instead of prefixes\\n        unordered_map<int,int> mp2;\\n        mp2[0]=n;\\n        \\n        int curr_suffix_sum=0;\\n        for(int i=n-1;i>=0;i--){\\n            curr_suffix_sum+=arr[i];\\n            if(mp2.count(curr_suffix_sum-target)) subarrayStartingAt[i]=mp2[curr_suffix_sum-target]-i;\\n            mp2[curr_suffix_sum]=i;\\n        }\\n        \\n        \\n        \\n        \\n        long long ans=INT_MAX;\\n        \\n        //this will store the min length of subarray that has already appeared before the current index\\n        int minEndingBefore=INT_MAX;\\n        \\n        for(int i=0;i<n;i++){\\n            //we take the length of subarray starting at current index and add length of subarray that has already ended and has minimum length and ,update the ans as the minimum of this value or previous answer\\n            ans=min(ans,(long long)subarrayStartingAt[i]+minEndingBefore);\\n            \\n            //updating minEndingBefore for further use\\n            minEndingBefore=min(minEndingBefore,subarrayEndingAt[i]);\\n        }\\n        \\n        \\n        //if there was not any answer and we were just having INT_MAX in array / or just 1 subarray or overlapping subarrays the ans would be greater than INT_MAX so return -1\\n        if(ans>=INT_MAX){\\n            return -1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687232,
                "title": "javascript-a-little-slow-comments-welcome",
                "content": "```\\nvar minSumOfLengths = function(arr, target) {\\n    let allSubs = [] // [length:[start,end]]\\n    \\n    let result = Infinity\\n    let currentSum = 0\\n    let left = 0\\n    let right = 0\\n    while (right < arr.length){\\n        currentSum += arr[right]\\n        while (currentSum > target) {\\n            currentSum -= arr[left]\\n            left++\\n        }\\n        if (currentSum === target){\\n            let entry = [right-left+1,[left,right]]\\n            allSubs.push(entry)\\n        }\\n        right++\\n    }\\n    allSubs.sort((a,b) => a[0]-b[0]) \\n    if (allSubs.length < 2) return -1\\n\\n    // shortest 2 intervals not overlapping\\n    for (let i = 0; i < allSubs.length-1; i++){\\n        let first = allSubs[i]\\n        let firstStart = first[1][0]\\n        let firstEnd = first[1][1]\\n        for (let j = i+1; j< allSubs.length; j++){\\n            let second = allSubs[j]\\n            let secondStart = second[1][0]\\n            let secondEnd = second[1][1]\\n            if ((firstEnd < secondStart && firstStart < secondStart) || (secondEnd < firstStart && secondStart < firstStart)){\\n                let currLength = first[0]+second[0]\\n                result = Math.min(result, currLength)\\n                break\\n            } \\n        }\\n    }\\n    return result === Infinity ? -1 : result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minSumOfLengths = function(arr, target) {\\n    let allSubs = [] // [length:[start,end]]\\n    \\n    let result = Infinity\\n    let currentSum = 0\\n    let left = 0\\n    let right = 0\\n    while (right < arr.length){\\n        currentSum += arr[right]\\n        while (currentSum > target) {\\n            currentSum -= arr[left]\\n            left++\\n        }\\n        if (currentSum === target){\\n            let entry = [right-left+1,[left,right]]\\n            allSubs.push(entry)\\n        }\\n        right++\\n    }\\n    allSubs.sort((a,b) => a[0]-b[0]) \\n    if (allSubs.length < 2) return -1\\n\\n    // shortest 2 intervals not overlapping\\n    for (let i = 0; i < allSubs.length-1; i++){\\n        let first = allSubs[i]\\n        let firstStart = first[1][0]\\n        let firstEnd = first[1][1]\\n        for (let j = i+1; j< allSubs.length; j++){\\n            let second = allSubs[j]\\n            let secondStart = second[1][0]\\n            let secondEnd = second[1][1]\\n            if ((firstEnd < secondStart && firstStart < secondStart) || (secondEnd < firstStart && secondStart < firstStart)){\\n                let currLength = first[0]+second[0]\\n                result = Math.min(result, currLength)\\n                break\\n            } \\n        }\\n    }\\n    return result === Infinity ? -1 : result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 687061,
                "title": "java-10-ms-o-n-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int start = arr.length - 1, end = arr.length - 1, sum = 0, minLenSoFar = Integer.MAX_VALUE;\\n\\n\\t\\t// The i\\'th element of this array will hold the minimum length of all subarray\\'s on it\\'s right\\n\\t\\t// whose sum = target.\\n\\t\\tint[] minLen = new int[arr.length];\\n\\n\\t\\t// Start from the end. Keep track of min length of subarray whose sum is equal to target.\\n        for (start = arr.length - 1; start >= 0; start--) {\\n            sum = sum + arr[start];\\n            if (sum != target) {\\n                minLen[start] = minLenSoFar == Integer.MAX_VALUE ? -1 : minLenSoFar;\\n            }\\n            while (sum >= target) {\\n                if (sum == target) {\\n                    minLenSoFar = Math.min(minLenSoFar, end-start+1);\\n                    minLen[start] = minLenSoFar;\\n                }\\n                sum = sum - arr[end];\\n                end--;\\n            }\\n        }\\n        \\n        \\n        int ans = Integer.MAX_VALUE;\\n        start = 0;  sum = 0;\\n\\t\\t// Start from the beginning. For every subarray, whose sum = target, \\n\\t\\t// add the min length of valid subarray from right and update ans.\\n        for (end = 0; end < arr.length-1; end++) {\\n            if (minLen[end+1] == -1) {\\n                break;\\n            }\\n            sum = sum + arr[end];\\n            while (sum >= target) {\\n                if (sum == target) {\\n                    ans = Math.min(ans, (end-start+1) + minLen[end+1]);\\n                }\\n                sum = sum - arr[start];\\n                start++;\\n            }\\n        }\\n        return (ans == Integer.MAX_VALUE) ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int start = arr.length - 1, end = arr.length - 1, sum = 0, minLenSoFar = Integer.MAX_VALUE;\\n\\n\\t\\t// The i\\'th element of this array will hold the minimum length of all subarray\\'s on it\\'s right\\n\\t\\t// whose sum = target.\\n\\t\\tint[] minLen = new int[arr.length];\\n\\n\\t\\t// Start from the end. Keep track of min length of subarray whose sum is equal to target.\\n        for (start = arr.length - 1; start >= 0; start--) {\\n            sum = sum + arr[start];\\n            if (sum != target) {\\n                minLen[start] = minLenSoFar == Integer.MAX_VALUE ? -1 : minLenSoFar;\\n            }\\n            while (sum >= target) {\\n                if (sum == target) {\\n                    minLenSoFar = Math.min(minLenSoFar, end-start+1);\\n                    minLen[start] = minLenSoFar;\\n                }\\n                sum = sum - arr[end];\\n                end--;\\n            }\\n        }\\n        \\n        \\n        int ans = Integer.MAX_VALUE;\\n        start = 0;  sum = 0;\\n\\t\\t// Start from the beginning. For every subarray, whose sum = target, \\n\\t\\t// add the min length of valid subarray from right and update ans.\\n        for (end = 0; end < arr.length-1; end++) {\\n            if (minLen[end+1] == -1) {\\n                break;\\n            }\\n            sum = sum + arr[end];\\n            while (sum >= target) {\\n                if (sum == target) {\\n                    ans = Math.min(ans, (end-start+1) + minLen[end+1]);\\n                }\\n                sum = sum - arr[start];\\n                start++;\\n            }\\n        }\\n        return (ans == Integer.MAX_VALUE) ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686904,
                "title": "java-super-short-solution",
                "content": "```\\n    public int minSumOfLengths(int[] a, int t) {\\n        int[] map = new int[a.length];\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0, j = 0, sum = 0; i < a.length; i++) {\\n            if(i > 0) map[i] = map[i-1];\\n            sum += a[i];\\n            while(sum > t) sum -= a[j++];\\n            if(sum == t) {\\n                int len = i-j + 1;\\n                if(j > 0 && map[j-1] != 0) res = Math.min(res, len + map[j-1]);\\n                map[i] = len;\\n            }\\n            if(i > 0 && map[i-1] != 0) map[i] = Math.min(map[i], map[i-1]);\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSumOfLengths(int[] a, int t) {\\n        int[] map = new int[a.length];\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0, j = 0, sum = 0; i < a.length; i++) {\\n            if(i > 0) map[i] = map[i-1];\\n            sum += a[i];\\n            while(sum > t) sum -= a[j++];\\n            if(sum == t) {\\n                int len = i-j + 1;\\n                if(j > 0 && map[j-1] != 0) res = Math.min(res, len + map[j-1]);\\n                map[i] = len;\\n            }\\n            if(i > 0 && map[i-1] != 0) map[i] = Math.min(map[i], map[i-1]);\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686113,
                "title": "another-javascript-solution",
                "content": "I can only find one solution for JavaScript, so I decided to share mine.\\n```\\nvar minSumOfLengths = function(arr, target) {\\n  let n = arr.length;\\n  let a = [];\\n  let i = 0;\\n  let j = 0;\\n  let sum = 0;\\n  while(i < n) {\\n    sum += arr[i];\\n    while (sum > target) {\\n      sum -= arr[j];\\n      j++;\\n    }\\n    if (sum === target) {\\n      a.push([i-j+1,j,i]);\\n    }\\n    \\n    i++;\\n  }\\n\\n  if (a.length >= 2) {\\n    a.sort((x,y) => x[0] - y[0]);\\n    for(let i = 0; i < a.length-1; i++) {\\n      for(let j = i+1; j < a.length; j++) {\\n        let [v1,j1,i1] = a[i];\\n        let [v2,j2,i2] = a[j];\\n        if (i1 < j2 || j1 > i2) {\\n          return v1 + v2;\\n        }\\n      }\\n    } \\n  }\\n  return -1;\\n};",
                "solutionTags": [],
                "code": "I can only find one solution for JavaScript, so I decided to share mine.\\n```\\nvar minSumOfLengths = function(arr, target) {\\n  let n = arr.length;\\n  let a = [];\\n  let i = 0;\\n  let j = 0;\\n  let sum = 0;\\n  while(i < n) {\\n    sum += arr[i];\\n    while (sum > target) {\\n      sum -= arr[j];\\n      j++;\\n    }\\n    if (sum === target) {\\n      a.push([i-j+1,j,i]);\\n    }\\n    \\n    i++;\\n  }\\n\\n  if (a.length >= 2) {\\n    a.sort((x,y) => x[0] - y[0]);\\n    for(let i = 0; i < a.length-1; i++) {\\n      for(let j = i+1; j < a.length; j++) {\\n        let [v1,j1,i1] = a[i];\\n        let [v2,j2,i2] = a[j];\\n        if (i1 < j2 || j1 > i2) {\\n          return v1 + v2;\\n        }\\n      }\\n    } \\n  }\\n  return -1;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 686079,
                "title": "python-prefix-sum-and-heap",
                "content": "- Collect all potential sub-arrays using prefix sums hash map\\n- Filter out the overlaps, only keep the minimum sub-array among the overlaps\\n- Use max heap with size 2 to find out the minimum two sums\\n- Return the sum of the 2 sums in the heap, if heap doesn\\'t have 2 sums, return -1 as it cannot find 2 sub-arrays\\n\\n```python\\ndef minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        pre_sums = {0: 0}\\n        curr_sum = 0\\n        candidates = [] \\n        \\n        # Collect all potential candidates\\n        for i in range(len(arr)):\\n            curr_sum += arr[i]    \\n            if curr_sum - target in pre_sums:\\n                candidates.append([pre_sums[curr_sum-target], i])\\n            pre_sums[curr_sum] = i + 1\\n            \\n        # Filter out overlaps, keep the minimum among the overlaps\\n        non_overlaps = [] \\n        for start, end in candidates: \\n            if non_overlaps and start <= non_overlaps[-1][1]:\\n                if non_overlaps[-1][1] - non_overlaps[-1][0] + 1 > end - start + 1:\\n                    non_overlaps.pop()\\n                else:\\n                    continue    \\n            non_overlaps.append([start, end])        \\n            \\n        heap = []\\n        for start, end in non_overlaps:\\n            heapq.heappush(heap, -(end-start+1))\\n            if len(heap) > 2:\\n                heapq.heappop(heap)\\n\\t\\t\\t\\t\\n        return -sum(heap) if len(heap) >= 2 else -1\\n```\\n\\nTime: 100%\\nSpace: 25%",
                "solutionTags": [],
                "code": "```python\\ndef minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        pre_sums = {0: 0}\\n        curr_sum = 0\\n        candidates = [] \\n        \\n        # Collect all potential candidates\\n        for i in range(len(arr)):\\n            curr_sum += arr[i]    \\n            if curr_sum - target in pre_sums:\\n                candidates.append([pre_sums[curr_sum-target], i])\\n            pre_sums[curr_sum] = i + 1\\n            \\n        # Filter out overlaps, keep the minimum among the overlaps\\n        non_overlaps = [] \\n        for start, end in candidates: \\n            if non_overlaps and start <= non_overlaps[-1][1]:\\n                if non_overlaps[-1][1] - non_overlaps[-1][0] + 1 > end - start + 1:\\n                    non_overlaps.pop()\\n                else:\\n                    continue    \\n            non_overlaps.append([start, end])        \\n            \\n        heap = []\\n        for start, end in non_overlaps:\\n            heapq.heappush(heap, -(end-start+1))\\n            if len(heap) > 2:\\n                heapq.heappop(heap)\\n\\t\\t\\t\\t\\n        return -sum(heap) if len(heap) >= 2 else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 685858,
                "title": "python-sliding-window",
                "content": "\\tclass Solution:\\n\\t\\tfrom collections import defaultdict\\n\\t\\tdef minSumOfLengths(self, arr: List[int], target: int) -> int:\\n\\t\\t\\td = defaultdict(lambda : float(\\'inf\\'))\\n\\t\\t\\tleft = 0\\n\\t\\t\\ttotal = 0\\n\\t\\t\\tres = float(\\'inf\\')\\n\\t\\t\\tfor right in range(len(arr)):\\n\\t\\t\\t\\ttotal += arr[right]\\n\\t\\t\\t\\twhile total > target:\\n\\t\\t\\t\\t\\ttotal -= arr[left]\\n\\t\\t\\t\\t\\tleft+=1\\n\\n\\t\\t\\t\\tif total == target:\\n\\t\\t\\t\\t\\td[right] = right-left+1\\n\\t\\t\\t\\t\\tres = min(res,d[left-1]+right-left+1)\\n\\t\\t\\t\\td[right] = min(d[right],d[right-1])\\n\\t\\t\\treturn -1 if res == float(\\'inf\\') else res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tfrom collections import defaultdict\\n\\t\\tdef minSumOfLengths(self, arr: List[int], target: int) -> int:\\n\\t\\t\\td = defaultdict(lambda : float(\\'inf\\'))\\n\\t\\t\\tleft = 0\\n\\t\\t\\ttotal = 0\\n\\t\\t\\tres = float(\\'inf\\')\\n\\t\\t\\tfor right in range(len(arr)):\\n\\t\\t\\t\\ttotal += arr[right]\\n\\t\\t\\t\\twhile total > target:\\n\\t\\t\\t\\t\\ttotal -= arr[left]\\n\\t\\t\\t\\t\\tleft+=1\\n\\n\\t\\t\\t\\tif total == target:\\n\\t\\t\\t\\t\\td[right] = right-left+1\\n\\t\\t\\t\\t\\tres = min(res,d[left-1]+right-left+1)\\n\\t\\t\\t\\td[right] = min(d[right],d[right-1])\\n\\t\\t\\treturn -1 if res == float(\\'inf\\') else res",
                "codeTag": "Java"
            },
            {
                "id": 685812,
                "title": "python-two-time-two-pointers-interval-array-no-hashmap-o-n",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        m = len(arr)\\n\\t\\t# find all intervals with sum == target\\n        intervals = []\\n        i,j =0,0\\n        summ = 0\\n        while j < m:\\n            summ += arr[j]\\n            j += 1\\n            while i<j and summ >= target:\\n                if summ == target:\\n                    intervals.append((i,j-1))\\n                summ -= arr[i]\\n                i += 1   \\n        if len(intervals) <= 1:\\n            return -1\\n\\t\\t\\n\\t\\t# building mins array. mins[i] = length of minimum length interval \\n\\t\\t# among intervals[i], intervals[i+1], intervals[i+2] ...... intervals[n-1]\\n        n = len(intervals)\\n        mins = [0]*n\\n        mins[n-1] = intervals[n-1][1] - intervals[n-1][0] + 1\\n        for i in range(n-2,-1,-1):\\n            mins[i] = min(intervals[i][1]-intervals[i][0] + 1, mins[i+1])\\n         \\n\\t\\t # sliding window over intervals to find first non overlapping interval j for current interval i \\n\\t\\t # and updating ans if current interval i contributes to ans\\n        ans = 999999999\\n        i,j = 0,1\\n        while j < n:\\n            while j < n and intervals[i][1] >= intervals[j][0]:\\n                j += 1\\n            if j == n:\\n                if ans == 999999999:\\n                    return -1\\n                return ans\\n\\t\\t\\t# ans update\\n            ans = min(intervals[i][1]-intervals[i][0]+1+mins[j],ans)\\n            i += 1\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        m = len(arr)\\n\\t\\t# find all intervals with sum == target\\n        intervals = []\\n        i,j =0,0\\n        summ = 0\\n        while j < m:\\n            summ += arr[j]\\n            j += 1\\n            while i<j and summ >= target:\\n                if summ == target:\\n                    intervals.append((i,j-1))\\n                summ -= arr[i]\\n                i += 1   \\n        if len(intervals) <= 1:\\n            return -1\\n\\t\\t\\n\\t\\t# building mins array. mins[i] = length of minimum length interval \\n\\t\\t# among intervals[i], intervals[i+1], intervals[i+2] ...... intervals[n-1]\\n        n = len(intervals)\\n        mins = [0]*n\\n        mins[n-1] = intervals[n-1][1] - intervals[n-1][0] + 1\\n        for i in range(n-2,-1,-1):\\n            mins[i] = min(intervals[i][1]-intervals[i][0] + 1, mins[i+1])\\n         \\n\\t\\t # sliding window over intervals to find first non overlapping interval j for current interval i \\n\\t\\t # and updating ans if current interval i contributes to ans\\n        ans = 999999999\\n        i,j = 0,1\\n        while j < n:\\n            while j < n and intervals[i][1] >= intervals[j][0]:\\n                j += 1\\n            if j == n:\\n                if ans == 999999999:\\n                    return -1\\n                return ans\\n\\t\\t\\t# ans update\\n            ans = min(intervals[i][1]-intervals[i][0]+1+mins[j],ans)\\n            i += 1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 685675,
                "title": "cpp-prefix-sum-hash-map-naive-solution-easy-to-understand",
                "content": "The following solution is a very easy and naive solution. Though I could not do it in the biweekly contest due to time constraint. I soon understood that prefix sum is to be used.\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        for(int i = 1;i<n;i++)  //Prefix Sum\\n            arr[i]+=arr[i-1];\\n        vector<pair<int,pair<int,int> > > interval;\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(arr[i] == target)    interval.push_back({i+1,{0,i}});\\n            if(mp.find(arr[i]-target)!=mp.end())    interval.push_back({i-mp[arr[i]-target],{mp[arr[i]-target]+1,i}});\\n\\t\\t\\t\\tmp[arr[i]] = i;\\n        }\\n        int ans = 0;\\n        if(interval.size()<2)   return -1;\\n        sort(interval.begin(),interval.end());\\n\\t\\tans += interval[0].first;\\n        int st = interval[0].second.first;  int en = interval[0].second.second;\\n        for(int i = 1;i<interval.size();i++)   {\\n            int st1 = interval[i].second.first; int en1 = interval[i].second.second;\\n            if(st>st1 and st>en1)\\n                return (ans+interval[i].first);\\n            else if(st1>st and st1>en)\\n                return (ans+interval[i].first);\\n           \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        for(int i = 1;i<n;i++)  //Prefix Sum\\n            arr[i]+=arr[i-1];\\n        vector<pair<int,pair<int,int> > > interval;\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(arr[i] == target)    interval.push_back({i+1,{0,i}});\\n            if(mp.find(arr[i]-target)!=mp.end())    interval.push_back({i-mp[arr[i]-target],{mp[arr[i]-target]+1,i}});\\n\\t\\t\\t\\tmp[arr[i]] = i;\\n        }\\n        int ans = 0;\\n        if(interval.size()<2)   return -1;\\n        sort(interval.begin(),interval.end());\\n\\t\\tans += interval[0].first;\\n        int st = interval[0].second.first;  int en = interval[0].second.second;\\n        for(int i = 1;i<interval.size();i++)   {\\n            int st1 = interval[i].second.first; int en1 = interval[i].second.second;\\n            if(st>st1 and st>en1)\\n                return (ans+interval[i].first);\\n            else if(st1>st and st1>en)\\n                return (ans+interval[i].first);\\n           \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685641,
                "title": "prefix-sum-with-hashmap-in-java-o-n-time-and-space",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n       int n = arr.length;\\n       int []pre = new int[n];\\n       Arrays.fill(pre,n+1);\\n        HashMap<Integer,Integer>prefix = new HashMap<>();\\n        prefix.put(0,-1);\\n        int pref_sum = 0;\\n        int res = n+1;\\n        for(int i=0;i<n;i++){\\n            pref_sum+=arr[i];\\n            if(i>0) pre[i] =pre[i-1];\\n            if(prefix.containsKey(pref_sum - target)){\\n                int val = prefix.get(pref_sum - target);\\n                pre[i] = Math.min(pre[i],i - val);\\n                if(val!=-1 && pre[val]!= n+1){\\n                    res = Math.min(res, pre[val] + i - val);\\n                }\\n            }\\n            prefix.put(pref_sum,i);\\n        }\\n        if(res == n+1) return -1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n       int n = arr.length;\\n       int []pre = new int[n];\\n       Arrays.fill(pre,n+1);\\n        HashMap<Integer,Integer>prefix = new HashMap<>();\\n        prefix.put(0,-1);\\n        int pref_sum = 0;\\n        int res = n+1;\\n        for(int i=0;i<n;i++){\\n            pref_sum+=arr[i];\\n            if(i>0) pre[i] =pre[i-1];\\n            if(prefix.containsKey(pref_sum - target)){\\n                int val = prefix.get(pref_sum - target);\\n                pre[i] = Math.min(pre[i],i - val);\\n                if(val!=-1 && pre[val]!= n+1){\\n                    res = Math.min(res, pre[val] + i - val);\\n                }\\n            }\\n            prefix.put(pref_sum,i);\\n        }\\n        if(res == n+1) return -1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685563,
                "title": "golang-sliding-window-solution-with-runnable-tests-on-playground",
                "content": "https://play.golang.org/p/wPd7GMfSrAh\\n\\n```go\\npackage solution\\n\\nimport \"sort\"\\n\\nfunc minSumOfLengths(arr []int, target int) int {\\n\\tsum := 0\\n\\tj := 0\\n\\n\\trr := [][2]int{}\\n\\t// use sliding window, to get list of\\n\\t// subarrays with the target sum\\n\\tfor i, v := range arr {\\n\\t\\tsum += v\\n\\n\\t\\tfor ; sum > target; j++ {\\n\\t\\t\\tsum -= arr[j]\\n\\t\\t}\\n\\n\\t\\tif sum == target {\\n\\t\\t\\trr = append(rr, [2]int{j, i})\\n\\t\\t}\\n\\t}\\n\\n\\tif len(rr) < 2 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\t// helper func to get size of\\n\\t// subarray\\n\\tsize := func(v [2]int) int {\\n\\t\\treturn v[1] - v[0] + 1\\n\\t}\\n\\n\\t// sort list subarrays by their length\\n\\tsort.Slice(rr, func(i, j int) bool {\\n\\t\\tf, s := rr[i], rr[j]\\n\\t\\tfs, ss := size(f), size(s)\\n\\n\\t\\tif fs == ss {\\n\\t\\t\\treturn f[0] < s[0]\\n\\t\\t}\\n\\n\\t\\treturn fs < ss\\n\\t})\\n\\n\\tmin := -1\\n\\t// look for two shortest subarrays that\\n\\t// do not intersect\\n\\tfor i := 0; i < len(rr); i++ {\\n\\t\\tf := rr[i]\\n\\t\\tfs := size(f)\\n\\n\\t\\tfor j := i + 1; j < len(rr); j++ {\\n\\t\\t\\ts := rr[j]\\n\\t\\t\\tss := size(s)\\n\\t\\t\\tl := fs + ss\\n\\n\\t\\t\\t// optimization, not to compute the items\\n\\t\\t\\t// that are already bigger then minimum we found\\n\\t\\t\\t// before\\n\\t\\t\\tif min != -1 && l >= min {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if two subarrays are intersecting\\n\\t\\t\\tif (s[0] > f[1] && f[0] <= f[1]) || (f[0] > s[1] && s[0] <= s[1]) {\\n\\n\\t\\t\\t\\t// save lenghts of subarrays if it is smaller theen minimum\\n\\t\\t\\t\\tif l < min || min == -1 {\\n\\t\\t\\t\\t\\tmin = l\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\npackage solution\\n\\nimport \"sort\"\\n\\nfunc minSumOfLengths(arr []int, target int) int {\\n\\tsum := 0\\n\\tj := 0\\n\\n\\trr := [][2]int{}\\n\\t// use sliding window, to get list of\\n\\t// subarrays with the target sum\\n\\tfor i, v := range arr {\\n\\t\\tsum += v\\n\\n\\t\\tfor ; sum > target; j++ {\\n\\t\\t\\tsum -= arr[j]\\n\\t\\t}\\n\\n\\t\\tif sum == target {\\n\\t\\t\\trr = append(rr, [2]int{j, i})\\n\\t\\t}\\n\\t}\\n\\n\\tif len(rr) < 2 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\t// helper func to get size of\\n\\t// subarray\\n\\tsize := func(v [2]int) int {\\n\\t\\treturn v[1] - v[0] + 1\\n\\t}\\n\\n\\t// sort list subarrays by their length\\n\\tsort.Slice(rr, func(i, j int) bool {\\n\\t\\tf, s := rr[i], rr[j]\\n\\t\\tfs, ss := size(f), size(s)\\n\\n\\t\\tif fs == ss {\\n\\t\\t\\treturn f[0] < s[0]\\n\\t\\t}\\n\\n\\t\\treturn fs < ss\\n\\t})\\n\\n\\tmin := -1\\n\\t// look for two shortest subarrays that\\n\\t// do not intersect\\n\\tfor i := 0; i < len(rr); i++ {\\n\\t\\tf := rr[i]\\n\\t\\tfs := size(f)\\n\\n\\t\\tfor j := i + 1; j < len(rr); j++ {\\n\\t\\t\\ts := rr[j]\\n\\t\\t\\tss := size(s)\\n\\t\\t\\tl := fs + ss\\n\\n\\t\\t\\t// optimization, not to compute the items\\n\\t\\t\\t// that are already bigger then minimum we found\\n\\t\\t\\t// before\\n\\t\\t\\tif min != -1 && l >= min {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if two subarrays are intersecting\\n\\t\\t\\tif (s[0] > f[1] && f[0] <= f[1]) || (f[0] > s[1] && s[0] <= s[1]) {\\n\\n\\t\\t\\t\\t// save lenghts of subarrays if it is smaller theen minimum\\n\\t\\t\\t\\tif l < min || min == -1 {\\n\\t\\t\\t\\t\\tmin = l\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 685533,
                "title": "python3-faster-than-100-00-prefix-sum-hashmap",
                "content": "```\\nclass Solution:            \\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        # Part 1: find all subarrays with target sum using prefix-sum approach\\n        subarrays = []\\n        prefix_sum = 0\\n        sum2idx = {}\\n        for i in range(len(arr)):\\n            prefix_sum += arr[i]\\n            # check if prefix subarray sums to target\\n            if prefix_sum == target:\\n                length, borders = i + 1, [0, i]\\n                subarrays.append((length, borders))\\n            # check if some subarray with target sum ends at current idx\\n            if prefix_sum - target in sum2idx:\\n                length = i - sum2idx[prefix_sum - target]\\n                borders = (sum2idx[prefix_sum - target] + 1, i)\\n                subarrays.append((length, borders))\\n            # remember index of current prefix sum\\n            sum2idx[prefix_sum] = i\\n\\t\\t# ==============================================================\\n        # Part2: find minimal common length of non-overlapping subarrays\\n        if len(subarrays) < 2:\\n            return -1\\n        subarrays.sort(key=lambda x: x[0])\\n        for i in range(len(subarrays) - 1):\\n            len1, borders1 = subarrays[i]\\n            for j in range(i + 1, len(subarrays)):\\n                len2, borders2 = subarrays[j]\\n                if borders1[1] < borders2[0] or borders1[0] > borders2[1]:\\n                    return len1 + len2\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:            \\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        # Part 1: find all subarrays with target sum using prefix-sum approach\\n        subarrays = []\\n        prefix_sum = 0\\n        sum2idx = {}\\n        for i in range(len(arr)):\\n            prefix_sum += arr[i]\\n            # check if prefix subarray sums to target\\n            if prefix_sum == target:\\n                length, borders = i + 1, [0, i]\\n                subarrays.append((length, borders))\\n            # check if some subarray with target sum ends at current idx\\n            if prefix_sum - target in sum2idx:\\n                length = i - sum2idx[prefix_sum - target]\\n                borders = (sum2idx[prefix_sum - target] + 1, i)\\n                subarrays.append((length, borders))\\n            # remember index of current prefix sum\\n            sum2idx[prefix_sum] = i\\n\\t\\t# ==============================================================\\n        # Part2: find minimal common length of non-overlapping subarrays\\n        if len(subarrays) < 2:\\n            return -1\\n        subarrays.sort(key=lambda x: x[0])\\n        for i in range(len(subarrays) - 1):\\n            len1, borders1 = subarrays[i]\\n            for j in range(i + 1, len(subarrays)):\\n                len2, borders2 = subarrays[j]\\n                if borders1[1] < borders2[0] or borders1[0] > borders2[1]:\\n                    return len1 + len2\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685501,
                "title": "c-o-n-prefix-sum",
                "content": "Do prefix sum from left to right and right to left.\\n\\nright array can be eliminated.\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        \\n        vector<int> left(n);\\n        unordered_map<int, int> preSums;\\n        preSums[0] = -1;\\n        for (int i = 0, preSum = 0, m = INT_MAX; i < n; i++) {\\n            preSum += arr[i];\\n            if (preSums.find(preSum - target) != preSums.end()) {\\n                m = min(m, i - preSums[preSum - target]);\\n            }\\n            left[i] = m;\\n            preSums[preSum] = i;\\n        }\\n        \\n        vector<int> right(n);\\n        unordered_map<int, int> postSums;\\n        postSums[0] = n;\\n        for (int i = n - 1, postSum = 0, m = INT_MAX; i >= 0; i--) {\\n            postSum += arr[i];\\n            if (postSums.find(postSum - target) != postSums.end()) {\\n                m = min(m, postSums[postSum - target] - i);\\n            }\\n            right[i] = m;\\n            postSums[postSum] = i;\\n        }\\n        \\n        int result = INT_MAX;\\n        for (int i = 0; i + 1 < n; i++) {\\n            if (left[i] < INT_MAX && right[i + 1] < INT_MAX) {\\n                result = min(result, left[i] + right[i + 1]);\\n            }\\n        }\\n        if (result == INT_MAX) {\\n            return -1;\\n        } else {\\n            return result;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        \\n        vector<int> left(n);\\n        unordered_map<int, int> preSums;\\n        preSums[0] = -1;\\n        for (int i = 0, preSum = 0, m = INT_MAX; i < n; i++) {\\n            preSum += arr[i];\\n            if (preSums.find(preSum - target) != preSums.end()) {\\n                m = min(m, i - preSums[preSum - target]);\\n            }\\n            left[i] = m;\\n            preSums[preSum] = i;\\n        }\\n        \\n        vector<int> right(n);\\n        unordered_map<int, int> postSums;\\n        postSums[0] = n;\\n        for (int i = n - 1, postSum = 0, m = INT_MAX; i >= 0; i--) {\\n            postSum += arr[i];\\n            if (postSums.find(postSum - target) != postSums.end()) {\\n                m = min(m, postSums[postSum - target] - i);\\n            }\\n            right[i] = m;\\n            postSums[postSum] = i;\\n        }\\n        \\n        int result = INT_MAX;\\n        for (int i = 0; i + 1 < n; i++) {\\n            if (left[i] < INT_MAX && right[i + 1] < INT_MAX) {\\n                result = min(result, left[i] + right[i + 1]);\\n            }\\n        }\\n        if (result == INT_MAX) {\\n            return -1;\\n        } else {\\n            return result;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685479,
                "title": "c-sliding-window-binary-search",
                "content": "First find the Intervals having sum equal to target which can be done using sliding window.\\nIncrease the slide on right side till sum is less than target .then again decrease the window till sum exceeds the target and keep checking if sum is equal to target or not. If it is equal store this interval.\\nthen we should also store what is the minium interval length till i\\'th interval which can be easily calculated if we traverse from right side.\\nThis is required because for an interval we can select other interval if and only if other interval is not overlapping with the current interval. So we can select any interval after getting first non-overlapping interval there fore we need to store the min length till here so that we can get min length in O(1)\\n\\nNow all we need is to find non-overlapping interval for ith interval using Binary Search as start will be in increasing order.\\n\\nDo comment any improvements. :-)\\n\\n```\\n#define F first\\n#define S second\\ntypedef pair<int, int> pr;\\ntypedef vector<int> VI;\\ntypedef vector<pr> VP;\\n#define EB emplace_back\\n#define PB push_back\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& v, int target) {\\n        int n = v.size();\\n        int i = 0,j = 0,sum = 0;\\n        VP interval; // stores start and end of an interval\\n        while(true){\\n            int pi = i,pj = j;\\n            if(j < n && sum < target){\\n                sum += v[j];\\n                j++;\\n            }else if(i < n && sum > target){\\n                sum -= v[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                interval.EB(i,j-1); //insert this interval to the interval vector\\n                sum-=v[i];\\n                i++;\\n            }\\n            if(pi==i && pj==j){\\n                break;\\n            }\\n        }\\n        int req=INT_MAX; \\n        int mp[interval.size()]; // stores min till i\\'th interval from right side\\n        for(int i=interval.size()-1;i>=0;i--){\\n            if(i==interval.size()-1){\\n                mp[i]=interval[i].S-interval[i].F+1;\\n            }else{\\n                mp[i]=min(mp[i+1],interval[i].S-interval[i].F+1);\\n            }\\n        }\\n        \\n        for(int i=0;i<interval.size();i++){\\n            int low =i+1,high=interval.size()-1; // for ith interval find first non overlaping interval on right side of it\\n            int reqin=INT_MAX;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(interval[mid].F>interval[i].S){ //means non-overlaping with i\\'th interval\\n                    reqin=min(reqin,mid);\\n                    high=mid-1;\\n                }else{\\n                    low=mid+1;\\n                }\\n            }\\n            if(reqin<interval.size()){ // if we got a a non-overlapping interval\\n                req=min(req,interval[i].S-interval[i].F+1+mp[reqin]); //total length is length of current interval and min length \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//interval on right side of first non-overlapping interval which is stored in mp\\n            }\\n        }\\n        if(req==INT_MAX)req=-1;\\n        return req;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define F first\\n#define S second\\ntypedef pair<int, int> pr;\\ntypedef vector<int> VI;\\ntypedef vector<pr> VP;\\n#define EB emplace_back\\n#define PB push_back\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& v, int target) {\\n        int n = v.size();\\n        int i = 0,j = 0,sum = 0;\\n        VP interval; // stores start and end of an interval\\n        while(true){\\n            int pi = i,pj = j;\\n            if(j < n && sum < target){\\n                sum += v[j];\\n                j++;\\n            }else if(i < n && sum > target){\\n                sum -= v[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                interval.EB(i,j-1); //insert this interval to the interval vector\\n                sum-=v[i];\\n                i++;\\n            }\\n            if(pi==i && pj==j){\\n                break;\\n            }\\n        }\\n        int req=INT_MAX; \\n        int mp[interval.size()]; // stores min till i\\'th interval from right side\\n        for(int i=interval.size()-1;i>=0;i--){\\n            if(i==interval.size()-1){\\n                mp[i]=interval[i].S-interval[i].F+1;\\n            }else{\\n                mp[i]=min(mp[i+1],interval[i].S-interval[i].F+1);\\n            }\\n        }\\n        \\n        for(int i=0;i<interval.size();i++){\\n            int low =i+1,high=interval.size()-1; // for ith interval find first non overlaping interval on right side of it\\n            int reqin=INT_MAX;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(interval[mid].F>interval[i].S){ //means non-overlaping with i\\'th interval\\n                    reqin=min(reqin,mid);\\n                    high=mid-1;\\n                }else{\\n                    low=mid+1;\\n                }\\n            }\\n            if(reqin<interval.size()){ // if we got a a non-overlapping interval\\n                req=min(req,interval[i].S-interval[i].F+1+mp[reqin]); //total length is length of current interval and min length \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//interval on right side of first non-overlapping interval which is stored in mp\\n            }\\n        }\\n        if(req==INT_MAX)req=-1;\\n        return req;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685456,
                "title": "java-sliding-window-one-pass-o-n",
                "content": "Idea is similar to subarry sums equals \\'K\\', you need to find window where sum is \\'target\\' and suppose that window is from A[ind+1...i], then what is the smallest with sum equals \\'target\\' in A[0..ind]. We will be using an array where \\'dp[i]\\' to store the smallest subarray size whose sum equals target upto index \\'i\\'. \\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length - 1;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int result = Integer.MAX_VALUE;\\n        int[] dp = new int[arr.length];  // dp[i] stores the size of the smallest subarray sum equals \\'k\\' in A[0...i]\\n        int min = Integer.MAX_VALUE;\\n        int sum = 0;\\n        for(int i = 0; i <= n; i++){\\n            sum += arr[i];\\n            if(map.containsKey(sum-target)){\\n                int ind = map.get(sum-target);\\n                int windowSize = i - ind; // Current Size of Window of sum equals Target\\n                \\n                if(ind != -1 && dp[ind] <= arr.length){\\n\\t\\t\\t\\t\\t// If current window is from [ind + 1 ... i], check if there exist a window in A[0..ind]\\n\\t\\t\\t\\t\\t// And we know dp[ind] will store the smallest window upto index = ind;\\n                    result = Math.min(res,windowSize+dp[ind]);\\n                }\\n\\t\\t\\t\\tmin = Math.min(min,windowSize); // Update if this window is smaller than previous smallest window\\n            }\\n            dp[i] = min; // Update dp[i]\\n            map.put(sum,i);\\n        }\\n        if(result > n+1) return -1;\\n        else return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length - 1;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int result = Integer.MAX_VALUE;\\n        int[] dp = new int[arr.length];  // dp[i] stores the size of the smallest subarray sum equals \\'k\\' in A[0...i]\\n        int min = Integer.MAX_VALUE;\\n        int sum = 0;\\n        for(int i = 0; i <= n; i++){\\n            sum += arr[i];\\n            if(map.containsKey(sum-target)){\\n                int ind = map.get(sum-target);\\n                int windowSize = i - ind; // Current Size of Window of sum equals Target\\n                \\n                if(ind != -1 && dp[ind] <= arr.length){\\n\\t\\t\\t\\t\\t// If current window is from [ind + 1 ... i], check if there exist a window in A[0..ind]\\n\\t\\t\\t\\t\\t// And we know dp[ind] will store the smallest window upto index = ind;\\n                    result = Math.min(res,windowSize+dp[ind]);\\n                }\\n\\t\\t\\t\\tmin = Math.min(min,windowSize); // Update if this window is smaller than previous smallest window\\n            }\\n            dp[i] = min; // Update dp[i]\\n            map.put(sum,i);\\n        }\\n        if(result > n+1) return -1;\\n        else return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685447,
                "title": "python-presum-hashmap-dp-with-explanation",
                "content": "For example, arr = [3,1,1,1,5,1,2,1]\\n\\n**Step 1**. Calculate presum, we get\\ncumsum = [0,3,4,5,6,11,12,14,15],\\nHere we add a \"0\" in front of the array.\\n\\n**Step 2**. create a dict D, which consists of indices of all the elements appeared in cumsum except for the first element 0.\\nD = {\\n\\t3: [1],\\n\\t4: [2],\\n\\t5: [3],\\n\\t6: [4],\\n\\t11: [5],\\n\\t12: [6],\\n\\t14: [7],\\n\\t15: [8]\\n}\\n\\n**Step 3**. Use array \"res\" to restore the minimum distance of all elements in cumsum plus \"target\", use \"inf\" to denote that for index i of cumsum, there exists no way such that cumsum[i] + target in {i+1, i+2, ... , n-1}\\nindex of res: [0,1,2,3,4,5,6,7]\\nres = [1,3,inf,inf,inf,2,2,inf]\\n\\n**Step 4**. create dp array, where dp[i] denotes the minimum distance of res[i:]\\n\\n**Step 5**. for all i in range(n), find minimum res[i] + dp[i+res[i]]\\n\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: list, target: int) -> int:\\n        n = len(arr)\\n        inf = sys.maxsize\\n\\t\\t# calculate presum\\n        cumsum = [0] + list(itertools.accumulate(arr))\\n\\t\\t# D consists of all the indices that appeared in cumsum\\n        D = collections.defaultdict(list)\\n        for i in range(1, n + 1):\\n            D[cumsum[i]].append(i)\\n        res = []\\n        for i in range(n):\\n            if cumsum[i] + target in D:\\n                ind = bisect.bisect_left(D[cumsum[i] + target], i)\\n                res.append(D[cumsum[i] + target][ind] - i)\\n            else:\\n                res.append(inf)\\n        dp = [inf] * n\\n        dp[-1] = res[-1]\\n        for i in range(n - 1)[::-1]:\\n            if dp[i + 1] == inf:\\n                dp[i] = res[i]\\n            else:\\n                if res[i] == inf:\\n                    dp[i] = dp[i + 1]\\n                else:\\n                    dp[i] = min(dp[i + 1], res[i])\\n        ret = inf\\n        for i in range(n):\\n            if res[i] == inf or i + res[i] >= len(dp): continue\\n            ret = min(ret, res[i] + dp[i + res[i]])\\n        if ret == inf: ret = -1\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: list, target: int) -> int:\\n        n = len(arr)\\n        inf = sys.maxsize\\n\\t\\t# calculate presum\\n        cumsum = [0] + list(itertools.accumulate(arr))\\n\\t\\t# D consists of all the indices that appeared in cumsum\\n        D = collections.defaultdict(list)\\n        for i in range(1, n + 1):\\n            D[cumsum[i]].append(i)\\n        res = []\\n        for i in range(n):\\n            if cumsum[i] + target in D:\\n                ind = bisect.bisect_left(D[cumsum[i] + target], i)\\n                res.append(D[cumsum[i] + target][ind] - i)\\n            else:\\n                res.append(inf)\\n        dp = [inf] * n\\n        dp[-1] = res[-1]\\n        for i in range(n - 1)[::-1]:\\n            if dp[i + 1] == inf:\\n                dp[i] = res[i]\\n            else:\\n                if res[i] == inf:\\n                    dp[i] = dp[i + 1]\\n                else:\\n                    dp[i] = min(dp[i + 1], res[i])\\n        ret = inf\\n        for i in range(n):\\n            if res[i] == inf or i + res[i] >= len(dp): continue\\n            ret = min(ret, res[i] + dp[i + res[i]])\\n        if ret == inf: ret = -1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685437,
                "title": "python-3-sub-array-sum-and-heap",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        d={0:-1}\\n        ls=[]\\n        su=0\\n        for i in range(len(arr)):\\n            su+=arr[i]\\n            if(su-target in d):\\n                heapq.heappush(ls,[i-d[su-target],d[su-target]+1,i])\\n            d[su]=i\\n        if(len(ls)<2):\\n            return -1\\n        else:\\n            tmp=[heapq.heappop(ls)]\\n            while(ls):\\n                x=heapq.heappop(ls)\\n                for i in tmp:\\n                    if(i[2]<x[1] or x[2]<i[1] ):\\n                        return i[0]+x[0]\\n                if(x[0]==tmp[-1][0]):\\n                    tmp[-1][1]=max(tmp[-1][1],x[1])\\n                    tmp[-1][2]=min(tmp[-1][2],x[2])\\n                else:\\n                    tmp.append(x)\\n            return -1",
                "solutionTags": [],
                "code": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        d={0:-1}",
                "codeTag": "Java"
            },
            {
                "id": 685396,
                "title": "c-prefix-array-using-vector-pair-for-all-possible-subarrays",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int i=1,j=1,n=arr.size(),sum=0,mini=100000000,Startindi=-1;\\n        vector<int> pre(n+1,0);\\n        pre[0]=0;\\n        for(int i=0;i<n;i++){\\n            pre[i+1]=pre[i]+arr[i];\\n        }\\n        vector<pair<int,int>> vp;\\n        pair<int,int> stInd;\\n        while(j<=n && i<=n){\\n            if(pre[j]-pre[i-1]==target){\\n                vp.push_back({i,j});\\n                mini=min(mini,j-i+1);\\n                if(mini==j-i+1)\\n                    stInd = {i,j};\\n                i++;j++;\\n            }else if(pre[j]-pre[i-1]<target){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        if(vp.size()==0){\\n            return -1;\\n        }\\n        int c=100000000;\\n        for(int i=0;i<vp.size();i++){\\n            if((stInd.first <= vp[i].first &&  stInd.second >= vp[i].first)||(stInd.first <= vp[i].second &&  stInd.second >= vp[i].second)){\\n                \\n            }else{\\n                c=min(c,vp[i].second-vp[i].first+1);\\n            }\\n        }\\n        if(c==100000000){\\n            return -1;\\n        }    \\n        return mini+c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int i=1,j=1,n=arr.size(),sum=0,mini=100000000,Startindi=-1;\\n        vector<int> pre(n+1,0);\\n        pre[0]=0;\\n        for(int i=0;i<n;i++){\\n            pre[i+1]=pre[i]+arr[i];\\n        }\\n        vector<pair<int,int>> vp;\\n        pair<int,int> stInd;\\n        while(j<=n && i<=n){\\n            if(pre[j]-pre[i-1]==target){\\n                vp.push_back({i,j});\\n                mini=min(mini,j-i+1);\\n                if(mini==j-i+1)\\n                    stInd = {i,j};\\n                i++;j++;\\n            }else if(pre[j]-pre[i-1]<target){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        if(vp.size()==0){\\n            return -1;\\n        }\\n        int c=100000000;\\n        for(int i=0;i<vp.size();i++){\\n            if((stInd.first <= vp[i].first &&  stInd.second >= vp[i].first)||(stInd.first <= vp[i].second &&  stInd.second >= vp[i].second)){\\n                \\n            }else{\\n                c=min(c,vp[i].second-vp[i].first+1);\\n            }\\n        }\\n        if(c==100000000){\\n            return -1;\\n        }    \\n        return mini+c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685348,
                "title": "c-subarray-with-sum-equals-target-twice",
                "content": "In this approach I first find the smallest subarray of sum as target and then remove that, then from the updated array I again find the subarray of sum as target. Finally return the sum of both subarray lengths.\\n```\\nclass Solution {\\npublic:\\n    vector<int> f(vector<int>&A, int s)\\n    {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1;\\n        int sum = 0, len = INT_MAX, si = -1, sj = -1;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            sum += A[i];\\n            if(mp.find(sum - s) != mp.end())\\n            {\\n                int id = mp[sum - s];\\n                int l = i - id;\\n                if(l < len)\\n                {\\n                    len = l;\\n                    si = id + 1;\\n                    sj = i;\\n                }\\n            }\\n            mp[sum] = i;\\n        }\\n        return {si, sj};\\n    }\\n    int minSumOfLengths(vector<int>& A, int target) {        \\n        vector<int> v = f(A, target);\\n        if(v[0] == -1 && v[1] == -1)\\n            return -1;\\n        vector<int> B;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            if(i >= v[0] && i <= v[1])\\n                continue;\\n            B.push_back(A[i]);\\n        }\\n        vector<int> v1 = f(B, target);\\n        if(v1[0] == -1 && v1[1] == -1)\\n            return -1;\\n        return (v[1] - v[0] + 1) + (v1[1] - v1[0] + 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> f(vector<int>&A, int s)\\n    {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1;\\n        int sum = 0, len = INT_MAX, si = -1, sj = -1;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            sum += A[i];\\n            if(mp.find(sum - s) != mp.end())\\n            {\\n                int id = mp[sum - s];\\n                int l = i - id;\\n                if(l < len)\\n                {\\n                    len = l;\\n                    si = id + 1;\\n                    sj = i;\\n                }\\n            }\\n            mp[sum] = i;\\n        }\\n        return {si, sj};\\n    }\\n    int minSumOfLengths(vector<int>& A, int target) {        \\n        vector<int> v = f(A, target);\\n        if(v[0] == -1 && v[1] == -1)\\n            return -1;\\n        vector<int> B;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            if(i >= v[0] && i <= v[1])\\n                continue;\\n            B.push_back(A[i]);\\n        }\\n        vector<int> v1 = f(B, target);\\n        if(v1[0] == -1 && v1[1] == -1)\\n            return -1;\\n        return (v[1] - v[0] + 1) + (v1[1] - v1[0] + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685339,
                "title": "two-sliding-windows",
                "content": "**1. Find the first smallest subarray whose sum equals target by sliding window approach.\\n2. Then mark this subarray as visited, and now run a sliding window again to find the second smallest subarray.**\\n\\n***UPDATE : \\nThis solution got accepted during contest. But seems like this solution won\\'t pass some corner cases.***\\n```\\nclass Solution \\n{\\n    public int minSumOfLengths(int[] arr, int target) \\n    {\\n        //------------------------------------------------FIRST SLIDING WINDOW------------------------------------\\n        int start = 0;\\n        int end = 0;\\n        int min = Integer.MAX_VALUE;\\n        int s = -1;\\n        int e = -1;\\n        int sum = 0;\\n        while(end < arr.length)\\n        {\\n            sum += arr[end];\\n            \\n            while(sum > target)\\n                sum -= arr[start++];\\n            \\n            if(sum == target)\\n            {\\n                if(end - start + 1 <= min)\\n                {\\n                    min = end - start + 1;\\n                    s = start;\\n                    e = end;\\n                }\\n            }\\n            \\n            end++;\\n        }\\n        \\n        //if couldn\\'t find a subarray, return -1\\n        if(s == -1 || e == -1)\\n            return -1;\\n        \\n        int ans = min;\\n        //------------------------------------------------MARK THEM AS VISITED------------------------------------\\n        boolean[] vis = new boolean[arr.length];\\n        for(int i=s;i<=e;i++)\\n            vis[i] = true;\\n        \\n        //------------------------------------------------SECOND SLIDING WINDOW------------------------------------\\n        start = 0;\\n        end = 0;\\n        min = Integer.MAX_VALUE;\\n        sum = 0;\\n        while(end < arr.length)\\n        {\\n            //skip the first window\\n            while(vis[end])\\n            {\\n                end++;\\n                start = end;\\n                sum = 0;\\n                \\n                if(end >= arr.length)\\n                    break;\\n            }\\n            \\n            if(end >= arr.length)\\n                break;\\n            \\n            sum += arr[end];\\n            \\n            while(sum > target)\\n                sum -= arr[start++];\\n            \\n            if(sum == target)\\n                min = Math.min(min, end-start+1);\\n             \\n            end++;\\n        }\\n        \\n        if(min == Integer.MAX_VALUE)\\n            return -1;\\n        \\n        ans += min;\\n        return ans;\\n    }\\n}\\n```\\n\\n***Please UpVote if you find this useful***",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minSumOfLengths(int[] arr, int target) \\n    {\\n        //------------------------------------------------FIRST SLIDING WINDOW------------------------------------\\n        int start = 0;\\n        int end = 0;\\n        int min = Integer.MAX_VALUE;\\n        int s = -1;\\n        int e = -1;\\n        int sum = 0;\\n        while(end < arr.length)\\n        {\\n            sum += arr[end];\\n            \\n            while(sum > target)\\n                sum -= arr[start++];\\n            \\n            if(sum == target)\\n            {\\n                if(end - start + 1 <= min)\\n                {\\n                    min = end - start + 1;\\n                    s = start;\\n                    e = end;\\n                }\\n            }\\n            \\n            end++;\\n        }\\n        \\n        //if couldn\\'t find a subarray, return -1\\n        if(s == -1 || e == -1)\\n            return -1;\\n        \\n        int ans = min;\\n        //------------------------------------------------MARK THEM AS VISITED------------------------------------\\n        boolean[] vis = new boolean[arr.length];\\n        for(int i=s;i<=e;i++)\\n            vis[i] = true;\\n        \\n        //------------------------------------------------SECOND SLIDING WINDOW------------------------------------\\n        start = 0;\\n        end = 0;\\n        min = Integer.MAX_VALUE;\\n        sum = 0;\\n        while(end < arr.length)\\n        {\\n            //skip the first window\\n            while(vis[end])\\n            {\\n                end++;\\n                start = end;\\n                sum = 0;\\n                \\n                if(end >= arr.length)\\n                    break;\\n            }\\n            \\n            if(end >= arr.length)\\n                break;\\n            \\n            sum += arr[end];\\n            \\n            while(sum > target)\\n                sum -= arr[start++];\\n            \\n            if(sum == target)\\n                min = Math.min(min, end-start+1);\\n             \\n            end++;\\n        }\\n        \\n        if(min == Integer.MAX_VALUE)\\n            return -1;\\n        \\n        ans += min;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079805,
                "title": "python3-top-down-dp-prefix-sum",
                "content": "can be shortened but wtv\\n# Code\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        forward = list(itertools.accumulate(arr)) \\n        rev = reversed(arr)\\n        backward = list(itertools.accumulate(rev))\\n        backward.reverse()\\n\\n\\n        fHm = defaultdict(int)\\n        for index, element in enumerate(forward):\\n            fHm[element] = index\\n\\n        @cache\\n        def minFromFront(i): #arr[0], arr[1],...,arr[i]  # min sub from this that sum to target\\n            if i < 0:\\n                return float(\\'inf\\')\\n            if forward[i] == target:\\n                return i + 1\\n            \\n            curr = float(\\'inf\\')\\n            compl = forward[i] - target\\n            if compl in fHm and fHm[compl] < i:\\n                curr = (i - fHm[compl])\\n            curr = min(curr, minFromFront(i-1))\\n            return curr\\n\\n        bHm = defaultdict(int)\\n        for index in range(len(backward)-1,-1,-1):\\n            element = backward[index]\\n            bHm[element] = index\\n\\n        @cache\\n        def minFromBack(i): #arr[i], arr[i+1], ...\\n            if i >= len(bHm):\\n                return float(\\'inf\\')\\n            if backward[i] == target:\\n                return len(backward) - i\\n            curr = float(\\'inf\\')\\n            compl = backward[i] - target\\n            if compl in bHm and bHm[compl] > i:\\n                curr = (bHm[compl] - i)\\n            curr = min(curr, minFromBack(i+1))\\n            return curr\\n\\n\\n        res = float(\\'inf\\')\\n        for i in range(len(arr)):\\n            f = minFromFront(i)\\n            b = minFromBack(i+1)\\n            if f != float(\\'inf\\') and b != float(\\'inf\\'):\\n                res = min(res, f + b)\\n\\n        if res == float(\\'inf\\'): return -1\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        forward = list(itertools.accumulate(arr)) \\n        rev = reversed(arr)\\n        backward = list(itertools.accumulate(rev))\\n        backward.reverse()\\n\\n\\n        fHm = defaultdict(int)\\n        for index, element in enumerate(forward):\\n            fHm[element] = index\\n\\n        @cache\\n        def minFromFront(i): #arr[0], arr[1],...,arr[i]  # min sub from this that sum to target\\n            if i < 0:\\n                return float(\\'inf\\')\\n            if forward[i] == target:\\n                return i + 1\\n            \\n            curr = float(\\'inf\\')\\n            compl = forward[i] - target\\n            if compl in fHm and fHm[compl] < i:\\n                curr = (i - fHm[compl])\\n            curr = min(curr, minFromFront(i-1))\\n            return curr\\n\\n        bHm = defaultdict(int)\\n        for index in range(len(backward)-1,-1,-1):\\n            element = backward[index]\\n            bHm[element] = index\\n\\n        @cache\\n        def minFromBack(i): #arr[i], arr[i+1], ...\\n            if i >= len(bHm):\\n                return float(\\'inf\\')\\n            if backward[i] == target:\\n                return len(backward) - i\\n            curr = float(\\'inf\\')\\n            compl = backward[i] - target\\n            if compl in bHm and bHm[compl] > i:\\n                curr = (bHm[compl] - i)\\n            curr = min(curr, minFromBack(i+1))\\n            return curr\\n\\n\\n        res = float(\\'inf\\')\\n        for i in range(len(arr)):\\n            f = minFromFront(i)\\n            b = minFromBack(i+1)\\n            if f != float(\\'inf\\') and b != float(\\'inf\\'):\\n                res = min(res, f + b)\\n\\n        if res == float(\\'inf\\'): return -1\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063742,
                "title": "sliding-window-suffix-array-explained-intution-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intution behind this solution comes from the fact that , \"we have to find two non overlaping subarrays \". so we have to start finding the next subarray from the point where our first target is reached.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have two objectives here : \\n(1) how to find the minimum lenth of target subarray from the remaining subarray\\n(2) how we will calculate the answer\\n\\nFor Objective 1 \\n-we will precompute the suffix array using sliding window and maintaining a minimum value (target subarray), we will start iterating from the end of the array\\n\\nFor Objective 2\\n-we will start finding a target subarray from the start, while maintaining the minimum length(from all the previous target subarrays). And once we reach a target subarray we will try to calulate the ans asvnow we know the minimum length of the remaining array( where our current subarray ends) using the suffix array.\\n\\nlook out for the edge cases in the code.\\n\\nWe have our ans here folkes !!!\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n;\\n    vector<int> suffix;\\n    // making a sufix array\\n    void suffer(vector<int>& arr, int k){\\n        int j = n-1, i = n-1;\\n        int mini = INT_MAX;\\n        int sum = 0;\\n        while(j>=0){\\n            sum+= arr[j];\\n            while(sum>k){\\n                sum-=arr[i];\\n                i--;\\n            }\\n            if(sum == k){\\n                mini = min(mini,i - j+ 1);\\n            }\\n            suffix[j] = mini;\\n            j--;\\n        }\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        n = arr.size();\\n        suffix.resize(n,INT_MAX);\\n\\n        suffer(arr, target);\\n        // we will do sliding window and when a window becomes equal to target we will check for the minimum for index j+1;\\n\\n        int i = 0, j = 0;\\n        int mini = INT_MAX;\\n        int sum = 0, ans = INT_MAX;\\n        \\n        while(j<n){\\n            sum += arr[j];\\n\\n            while(sum> target){\\n                sum-= arr[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                mini = min(mini, j - i+1);\\n                if(j+1<n && suffix[j+1]!= INT_MAX){\\n                ans = min(ans, mini + suffix[j+1]);\\n                }\\n            }\\n            j++;\\n        }\\n        return ans == INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n;\\n    vector<int> suffix;\\n    // making a sufix array\\n    void suffer(vector<int>& arr, int k){\\n        int j = n-1, i = n-1;\\n        int mini = INT_MAX;\\n        int sum = 0;\\n        while(j>=0){\\n            sum+= arr[j];\\n            while(sum>k){\\n                sum-=arr[i];\\n                i--;\\n            }\\n            if(sum == k){\\n                mini = min(mini,i - j+ 1);\\n            }\\n            suffix[j] = mini;\\n            j--;\\n        }\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        n = arr.size();\\n        suffix.resize(n,INT_MAX);\\n\\n        suffer(arr, target);\\n        // we will do sliding window and when a window becomes equal to target we will check for the minimum for index j+1;\\n\\n        int i = 0, j = 0;\\n        int mini = INT_MAX;\\n        int sum = 0, ans = INT_MAX;\\n        \\n        while(j<n){\\n            sum += arr[j];\\n\\n            while(sum> target){\\n                sum-= arr[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                mini = min(mini, j - i+1);\\n                if(j+1<n && suffix[j+1]!= INT_MAX){\\n                ans = min(ans, mini + suffix[j+1]);\\n                }\\n            }\\n            j++;\\n        }\\n        return ans == INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049809,
                "title": "beats-100-00-of-users-with-javascript-well-explained",
                "content": "# Intuition\\nUse Sliding window and prefix array which keep last best result\\n1) We use sliding window in order to find ALL sub arrays with the sum  equals to target\\n2) In order to find non intersected sub-arrays we keep track of LAST INDEX OF SHORTEST sub array index\\n\\n# Approach\\nImage shows intersected sub array\\nAnd how does \"bestEndWnd\" looks like\\nEvery time we found sub-array we look at the \"bestEndWnd\" to find LAST BEST NON INTERSECTED ARRAY\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/4e8d611f-88e4-4d7c-855e-46abdac4d6f1_1694835064.5654464.png)\\n\\nIn the image once we finished last sub array we can find in O(1) time best non intersected sub array by simply looking at bestEndWnd[11] which is equal to 3\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar minSumOfLengths = function(arr, target) {\\n   let runSum=0, bestEndWnd=Array(arr.length).fill(), ans=Number.MAX_SAFE_INTEGER;\\n   for(let i=0,j=i;j<arr.length;j++){\\n       runSum+=arr[j];\\n       while(i<=j && runSum>target){\\n           runSum-=arr[i++];\\n       }\\n       \\n       if(runSum===target){\\n           bestEndWnd[j]=Math.min(j-1<0?Number.MAX_SAFE_INTEGER:bestEndWnd[j-1], j-i);\\n           if(i-1>=0 && bestEndWnd[i-1]!=Number.MAX_SAFE_INTEGER){\\n               ans=Math.min(ans,bestEndWnd[i-1]+(j-i)+2);\\n           }\\n           runSum-=arr[i];\\n           i++;\\n       }else{\\n           bestEndWnd[j]=j-1>=0?bestEndWnd[j-1]:Number.MAX_SAFE_INTEGER;\\n       }\\n       \\n   }\\n  return ans===Number.MAX_SAFE_INTEGER?-1:ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSumOfLengths = function(arr, target) {\\n   let runSum=0, bestEndWnd=Array(arr.length).fill(), ans=Number.MAX_SAFE_INTEGER;\\n   for(let i=0,j=i;j<arr.length;j++){\\n       runSum+=arr[j];\\n       while(i<=j && runSum>target){\\n           runSum-=arr[i++];\\n       }\\n       \\n       if(runSum===target){\\n           bestEndWnd[j]=Math.min(j-1<0?Number.MAX_SAFE_INTEGER:bestEndWnd[j-1], j-i);\\n           if(i-1>=0 && bestEndWnd[i-1]!=Number.MAX_SAFE_INTEGER){\\n               ans=Math.min(ans,bestEndWnd[i-1]+(j-i)+2);\\n           }\\n           runSum-=arr[i];\\n           i++;\\n       }else{\\n           bestEndWnd[j]=j-1>=0?bestEndWnd[j-1]:Number.MAX_SAFE_INTEGER;\\n       }\\n       \\n   }\\n  return ans===Number.MAX_SAFE_INTEGER?-1:ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046218,
                "title": "hashmap-using-prifixsum-approch-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        \\n        int sum=0, x=0;\\n        for(int i:arr){\\n            sum+=i;\\n            map.put(sum, x);\\n            x++;\\n        }\\n\\n        int size = Integer.MAX_VALUE;\\n        int res = Integer.MAX_VALUE;\\n        sum=0;\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i];\\n            if(map.get(sum-target)!=null){\\n                size= Math.min(size, i-map.get(sum-target));\\n            }\\n\\n            if(map.get(sum+target)!=null && size<Integer.MAX_VALUE){\\n                res = Math.min(res, map.get(sum+target)-i+size);\\n            }\\n        }\\n\\n        return res==Integer.MAX_VALUE? -1:res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        \\n        int sum=0, x=0;\\n        for(int i:arr){\\n            sum+=i;\\n            map.put(sum, x);\\n            x++;\\n        }\\n\\n        int size = Integer.MAX_VALUE;\\n        int res = Integer.MAX_VALUE;\\n        sum=0;\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i];\\n            if(map.get(sum-target)!=null){\\n                size= Math.min(size, i-map.get(sum-target));\\n            }\\n\\n            if(map.get(sum+target)!=null && size<Integer.MAX_VALUE){\\n                res = Math.min(res, map.get(sum+target)-i+size);\\n            }\\n        }\\n\\n        return res==Integer.MAX_VALUE? -1:res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976310,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minSumOfLengths(vector<int>& arr, int target) {\\n    int ans = INT_MAX;\\n    int leftLength = INT_MAX;\\n    int prefix = 0;\\n    unordered_map<int, int> prefixToIndex{{0, -1}};\\n\\n    for (int i = 0; i < arr.size(); ++i) {\\n      prefix += arr[i];\\n      prefixToIndex[prefix] = i;\\n    }\\n\\n    prefix = 0;\\n\\n    for (int i = 0; i < arr.size(); ++i) {\\n      prefix += arr[i];\\n      if (const auto it = prefixToIndex.find(prefix - target);\\n          it != prefixToIndex.cend())\\n        leftLength = min(leftLength, i - it->second);\\n      if (leftLength < INT_MAX)\\n        if (const auto it = prefixToIndex.find(prefix + target);\\n            it != prefixToIndex.cend())\\n          ans = min(ans, leftLength + it->second - i);\\n    }\\n\\n    return ans == INT_MAX ? -1 : ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minSumOfLengths(vector<int>& arr, int target) {\\n    int ans = INT_MAX;\\n    int leftLength = INT_MAX;\\n    int prefix = 0;\\n    unordered_map<int, int> prefixToIndex{{0, -1}};\\n\\n    for (int i = 0; i < arr.size(); ++i) {\\n      prefix += arr[i];\\n      prefixToIndex[prefix] = i;\\n    }\\n\\n    prefix = 0;\\n\\n    for (int i = 0; i < arr.size(); ++i) {\\n      prefix += arr[i];\\n      if (const auto it = prefixToIndex.find(prefix - target);\\n          it != prefixToIndex.cend())\\n        leftLength = min(leftLength, i - it->second);\\n      if (leftLength < INT_MAX)\\n        if (const auto it = prefixToIndex.find(prefix + target);\\n            it != prefixToIndex.cend())\\n          ans = min(ans, leftLength + it->second - i);\\n    }\\n\\n    return ans == INT_MAX ? -1 : ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883966,
                "title": "c-avoid-overlapping-solution",
                "content": "# Intuition\\nFor avoiding the overlapping we take each index, find the possible value in the range less than index i and the value in greater equal than i.\\n\\n# Approach\\ntake index i, the minimum subarry with value target in [0,i) plus the minimum in [i, n-1], we compare this addition for each i from [1, n-1]\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinSumOfLengths(int[] arr, int target)\\n    {\\n        int n = arr.Length;\\n        int ans = Int32.MaxValue;\\n        int[] ltr = new int[n];\\n        int[] rtl = new int[n];\\n        int leftMin = Int32.MaxValue, rightMin = Int32.MaxValue;\\n\\n        int pt1 = 0, pt2 = 0;\\n        int sum = 0;\\n        for (pt2 = 0; pt2 < n - 1; ++pt2)\\n        {\\n            sum += arr[pt2];\\n            while (sum >= target)\\n            {\\n                if (sum == target)\\n                {\\n                    leftMin = Math.Min(leftMin, pt2 - pt1 + 1);\\n                    break;\\n                }\\n\\n                sum -= arr[pt1++];\\n            }\\n\\n            ltr[pt2] = leftMin;\\n        }\\n\\n        pt1 = n - 1;\\n        pt2 = n - 1;\\n        sum = 0;\\n        for (pt2 = n - 1; pt2 >= 1; --pt2)\\n        {\\n            sum += arr[pt2];\\n            while (sum >= target)\\n            {\\n                if (sum == target)\\n                {\\n                    rightMin = Math.Min(rightMin, pt1 - pt2 + 1);\\n                    break;\\n                }\\n\\n                sum -= arr[pt1--];\\n            }\\n\\n            rtl[pt2] = rightMin;\\n        }\\n\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (ltr[i - 1] != Int32.MaxValue && rtl[i] != Int32.MaxValue)\\n            {\\n                ans = Math.Min(ltr[i - 1] + rtl[i], ans);\\n            }\\n        }\\n\\n        return ans == int.MaxValue ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSumOfLengths(int[] arr, int target)\\n    {\\n        int n = arr.Length;\\n        int ans = Int32.MaxValue;\\n        int[] ltr = new int[n];\\n        int[] rtl = new int[n];\\n        int leftMin = Int32.MaxValue, rightMin = Int32.MaxValue;\\n\\n        int pt1 = 0, pt2 = 0;\\n        int sum = 0;\\n        for (pt2 = 0; pt2 < n - 1; ++pt2)\\n        {\\n            sum += arr[pt2];\\n            while (sum >= target)\\n            {\\n                if (sum == target)\\n                {\\n                    leftMin = Math.Min(leftMin, pt2 - pt1 + 1);\\n                    break;\\n                }\\n\\n                sum -= arr[pt1++];\\n            }\\n\\n            ltr[pt2] = leftMin;\\n        }\\n\\n        pt1 = n - 1;\\n        pt2 = n - 1;\\n        sum = 0;\\n        for (pt2 = n - 1; pt2 >= 1; --pt2)\\n        {\\n            sum += arr[pt2];\\n            while (sum >= target)\\n            {\\n                if (sum == target)\\n                {\\n                    rightMin = Math.Min(rightMin, pt1 - pt2 + 1);\\n                    break;\\n                }\\n\\n                sum -= arr[pt1--];\\n            }\\n\\n            rtl[pt2] = rightMin;\\n        }\\n\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (ltr[i - 1] != Int32.MaxValue && rtl[i] != Int32.MaxValue)\\n            {\\n                ans = Math.Min(ltr[i - 1] + rtl[i], ans);\\n            }\\n        }\\n\\n        return ans == int.MaxValue ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873316,
                "title": "c-o-n-time-o-1-space-no-dp-no-hashmap",
                "content": "`(i..j)`is the window to find first minimum length sub-array.\\n`k`marks the end of (possibly) next sub-array, but, starting at`(j + 1)`.\\n\\nIdea is - \\nif you have any other best subarray to minimize the sum of 2 lengths, you are going to see that next 2nd subarray in future as`j`progresses one step at a time.. and you will find`(j+1..k)`. Also by that time, you will have any sub-array, not just`(0..i)`but`(0..j)`to find first minimum length sub-array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int j = 0, i = -1, k = 0, end = arr.size();\\n        int curr_sum = 0, next_sum = 0;\\n        int len1 = INT_MAX, ans = INT_MAX;\\n        while (j < end) {\\n            curr_sum += arr[j];\\n            next_sum -= arr[j];\\n            while (curr_sum > target)\\n                curr_sum -= arr[++i];\\n            if (curr_sum == target)\\n                len1 = min(len1, j - i);\\n\\n            if (len1 != INT_MAX) {\\n                 while (k < end && next_sum < target)\\n                     next_sum += arr[k++];\\n                 if (next_sum == target)\\n                     ans = min(ans, k - 1 - j + len1);\\n            }\\n            ++j;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int j = 0, i = -1, k = 0, end = arr.size();\\n        int curr_sum = 0, next_sum = 0;\\n        int len1 = INT_MAX, ans = INT_MAX;\\n        while (j < end) {\\n            curr_sum += arr[j];\\n            next_sum -= arr[j];\\n            while (curr_sum > target)\\n                curr_sum -= arr[++i];\\n            if (curr_sum == target)\\n                len1 = min(len1, j - i);\\n\\n            if (len1 != INT_MAX) {\\n                 while (k < end && next_sum < target)\\n                     next_sum += arr[k++];\\n                 if (next_sum == target)\\n                     ans = min(ans, k - 1 - j + len1);\\n            }\\n            ++j;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854038,
                "title": "c-solution-o-nlogn-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        vector<int>psum(arr.size(), 0);\\n        psum[0] = 0;\\n        for(int i=1; i<arr.size(); i++){\\n            psum[i] = arr[i]+psum[i-1];\\n        }\\n        map<int, int> vis;\\n        map<int,vector<pair<int,int>>> subarr;\\n        //a-b=t -> \\n        for(int i=0; i<arr.size(); i++){\\n            vis[target+psum[i]-arr[i]] = i;\\n        }\\n        //subarr[0].push_back({1,2});\\n        for(int i=0; i<arr.size(); i++){\\n            if(vis.find(psum[i])!=vis.end()){\\n                subarr[abs(i - vis[psum[i]])+1].push_back({i,vis[psum[i]]});\\n\\n            }\\n        }\\n        int mini = INT_MAX;\\n        for(auto i : subarr){\\n            cout<<i.first<<\"->\"<<endl;\\n            for(int j=0; j<i.second.size(); j++){\\n                cout<<i.second[j].first<<\" \"<<i.second[j].second<<endl;\\n            }\\n        }\\n        \\n        \\n        \\n        //a+b=t => a = t-b\\n    \\n    return mini;\\n    }\\n};\\n//a,b,c,d,e,f,g,h,i,j\\n//  |___|     |__|\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        vector<int>psum(arr.size(), 0);\\n        psum[0] = 0;\\n        for(int i=1; i<arr.size(); i++){\\n            psum[i] = arr[i]+psum[i-1];\\n        }\\n        map<int, int> vis;\\n        map<int,vector<pair<int,int>>> subarr;\\n        //a-b=t -> \\n        for(int i=0; i<arr.size(); i++){\\n            vis[target+psum[i]-arr[i]] = i;\\n        }\\n        //subarr[0].push_back({1,2});\\n        for(int i=0; i<arr.size(); i++){\\n            if(vis.find(psum[i])!=vis.end()){\\n                subarr[abs(i - vis[psum[i]])+1].push_back({i,vis[psum[i]]});\\n\\n            }\\n        }\\n        int mini = INT_MAX;\\n        for(auto i : subarr){\\n            cout<<i.first<<\"->\"<<endl;\\n            for(int j=0; j<i.second.size(); j++){\\n                cout<<i.second[j].first<<\" \"<<i.second[j].second<<endl;\\n            }\\n        }\\n        \\n        \\n        \\n        //a+b=t => a = t-b\\n    \\n    return mini;\\n    }\\n};\\n//a,b,c,d,e,f,g,h,i,j\\n//  |___|     |__|\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3854029,
                "title": "o-n-solution-using-smallest-subarray-length-with-sum-target-in-prefix-and-suffix",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        vector<int>prefix(arr.size(),0);\\n        int sum = 0;\\n        int mini = 100001;\\n        int start = 0;\\n\\n        for(int i=0; i<arr.size();i++){\\n            sum+=arr[i];\\n            if(sum>=target){\\n                if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n                while(sum>target && start <= i){\\n                   \\n                    sum-=arr[start];\\n                    start++;\\n                     if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n\\n                }\\n            }\\n            prefix[i]=mini;\\n\\n        }\\n\\n        vector<int>suffix(arr.size(),0);\\n        mini = 100001;\\n        sum = 0;\\n        start = 0;\\n        reverse(arr.begin(),arr.end());\\n        for(int i=0; i<arr.size();i++){\\n            sum+=arr[i];\\n            if(sum>=target){\\n                if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n                while(sum>target && start <= i){\\n                   \\n                    sum-=arr[start];\\n                    start++;\\n                     if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n\\n                }\\n            }\\n            suffix[i]=mini;\\n\\n        }\\n        reverse(suffix.begin(),suffix.end());\\n        mini = 100001;\\n\\n        for(int i=1; i<prefix.size(); i++){\\n            mini = min(prefix[i-1]+suffix[i],mini);\\n        }\\n\\n        if(mini == 100001) return -1;\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        vector<int>prefix(arr.size(),0);\\n        int sum = 0;\\n        int mini = 100001;\\n        int start = 0;\\n\\n        for(int i=0; i<arr.size();i++){\\n            sum+=arr[i];\\n            if(sum>=target){\\n                if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n                while(sum>target && start <= i){\\n                   \\n                    sum-=arr[start];\\n                    start++;\\n                     if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n\\n                }\\n            }\\n            prefix[i]=mini;\\n\\n        }\\n\\n        vector<int>suffix(arr.size(),0);\\n        mini = 100001;\\n        sum = 0;\\n        start = 0;\\n        reverse(arr.begin(),arr.end());\\n        for(int i=0; i<arr.size();i++){\\n            sum+=arr[i];\\n            if(sum>=target){\\n                if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n                while(sum>target && start <= i){\\n                   \\n                    sum-=arr[start];\\n                    start++;\\n                     if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n\\n                }\\n            }\\n            suffix[i]=mini;\\n\\n        }\\n        reverse(suffix.begin(),suffix.end());\\n        mini = 100001;\\n\\n        for(int i=1; i<prefix.size(); i++){\\n            mini = min(prefix[i-1]+suffix[i],mini);\\n        }\\n\\n        if(mini == 100001) return -1;\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564904,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1574908,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1753080,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1574355,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1573926,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1573925,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 2049690,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1784855,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Frequency of the Most Frequent Element",
        "question_content": "<p>The <strong>frequency</strong> of an element is the number of times it occurs in an array.</p>\n\n<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. In one operation, you can choose an index of <code>nums</code> and increment the element at that index by <code>1</code>.</p>\n\n<p>Return <em>the <strong>maximum possible frequency</strong> of an element after performing <strong>at most</strong> </em><code>k</code><em> operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,4], k = 5\n<strong>Output:</strong> 3<strong>\nExplanation:</strong> Increment the first element three times and the second element two times to make nums = [4,4,4].\n4 has a frequency of 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,4,8,13], k = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are multiple optimal solutions:\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,9,6], k = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1175088,
                "title": "c-maximum-sliding-window-cheatsheet-template",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n### Problems Solvable using this template\\n\\n* [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1499836/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet))\\n* [159. Longest Substring with At Most Two Distinct Characters (Medium)](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/1499839/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet))\\n* [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/1499842/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet))\\n* [424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/discuss/1499834/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet))\\n* [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1499844/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet))\\n* [713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/discuss/1501834/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet))\\n* [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1504260/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet))\\n* [1208. Get Equal Substrings Within Budget (Medium)](https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/1529234/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet))\\n* [1493. Longest Subarray of 1\\'s After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/1504267/C%2B%2B-Sliding-Window-(%2B-Cheat-Sheet))\\n* [1695. Maximum Erasure Value](https://leetcode.com/problems/maximum-erasure-value/discuss/1504271/C%2B%2B-Sliding-Window-(%2BCheat-Sheet))\\n* [1838. Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\\n* [2009. Minimum Number of Operations to Make Array Continuous](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/discuss/1470857/C%2B%2B-Sliding-Window)\\n* [2024. Maximize the Confusion of an Exam](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/discuss/1499033/c-sliding-window-cheat-sheet)\\n\\nThe following problems are also solvable using the shrinkable template with the [\"At Most to Equal\" trick](https://leetcode.com/problems/count-vowel-substrings-of-a-string/discuss/1563765/c-on-time-sliding-window/1141941)\\n\\n* [930. Binary Subarrays With Sum (Medium)](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/1513935/C%2B%2B-Prefix-State-Map-or-Sliding-Window)\\n* [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/1499830/C%2B%2B-Sliding-Window)\\n* [1248. Count Number of Nice Subarrays (Medium)](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/1515501/C%2B%2B-Prefix-State-Map-Two-Pointers-Sliding-Window)\\n* [2062. Count Vowel Substrings of a String (Easy)](https://leetcode.com/problems/count-vowel-substrings-of-a-string/discuss/1563765/c-on-time-sliding-window/1141941)\\n\\n### Template 1: Sliding Window (Shrinkable)\\n\\nThe best template I\\'ve found so far:\\n\\n```cpp\\nint i = 0, j = 0, ans = 0;\\nfor (; j < N; ++j) {\\n    // CODE: use A[j] to update state which might make the window invalid\\n    for (; invalid(); ++i) { // when invalid, keep shrinking the left edge until it\\'s valid again\\n        // CODE: update state using A[i]\\n    }\\n    ans = max(ans, j - i + 1); // the window [i, j] is the maximum window we\\'ve found thus far\\n}\\nreturn ans;\\n```\\n\\nEssentially, we want to **keep the window valid** at the end of each outer `for` loop.\\n\\n**Solution for this question:**\\n\\n1. What should we use as the `state`? It should be the sum of numbers in the window\\n2. How to determine `invalid`? The window is invalid if `(j - i + 1) * A[j] - sum > k`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/frequency-of-the-most-frequent-element/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& A, int k) {\\n        sort(begin(A), end(A));\\n        long i = 0, N = A.size(), ans = 1, sum = 0;\\n        for (int j = 0; j < N; ++j) {\\n            sum += A[j];\\n            while ((j - i + 1) * A[j] - sum > k) sum -= A[i++];\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**FAQ**:\\n\\n* Why is the time complexity `O(NlogN)`?  \\nThe sorting takes `O(NlogN)`. The two pointer part only takes `O(N)` because both the pointers `i` and `j` traverse the array ONLY ONCE.\\n\\n* Why is `(j - i + 1) * A[j] - sum <= k` valid?  \\n`(j - i + 1)` is the length of the window `[i, j]`. We want to increase all the numbers in the window to equal `A[j]`, the number of operations needed is `(j - i + 1) * A[j] - sum` which should be `<= k`. For example, assume the window is `[1,2,3]`, increasing all the numbers to `3` will take `3 * 3 - (1 + 2 + 3)` operations.\\n\\n### Template 2: Sliding Window (Non-shrinkable)\\n\\n```cpp\\nint i = 0, j = 0;\\nfor (; j < N; ++j) {\\n    // CODE: use A[j] to update state which might make the window invalid\\n    if (invalid()) { // Increment the left edge ONLY when the window is invalid. In this way, the window GROWs when it\\'s valid, and SHIFTs when it\\'s invalid\\n        // CODE: update state using A[i]\\n        ++i;\\n    }\\n    // after `++j` in the for loop, this window `[i, j)` of length `j - i` MIGHT be valid.\\n}\\nreturn j - i; // There must be a maximum window of size `j - i`.\\n```\\n\\nEssentially, we GROW the window when it\\'s valid, and SHIFT the window when it\\'s invalid.\\n\\nNote that there is only a SINGLE `for` loop now!\\n\\n**Solution for this question:**\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/frequency-of-the-most-frequent-element/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& A, int k) {\\n        sort(begin(A), end(A));\\n        long i = 0, j = 0, N = A.size(), sum = 0;\\n        for (; j < N; ++j) {\\n            sum += A[j];\\n            if ((j - i + 1) * A[j] - sum > k) sum -= A[i++];\\n        }\\n        return j - i;\\n    }\\n};\\n```\\n\\n### Apply these templates to other problems\\n\\n\\n#### [1493. Longest Subarray of 1\\'s After Deleting One Element (Medium)](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)\\n\\n##### Sliding Window (Shrinkable)\\n\\n1. What\\'s `state`? `cnt` as the number of `0`s in the window.\\n2. What\\'s `invalid`? `cnt > 1` is invalid.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& A) {\\n        int i = 0, j = 0, N = A.size(), cnt = 0, ans = 0;\\n        for (; j < N; ++j) {\\n            cnt += A[j] == 0;\\n            while (cnt > 1) cnt -= A[i++] == 0;\\n            ans = max(ans, j - i); // note that the window is of size `j - i + 1`. We use `j - i` here because we need to delete a number.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n##### Sliding Window (Non-shrinkable)\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& A) {\\n        int i = 0, j = 0, N = A.size(), cnt = 0;\\n        for (; j < N; ++j) {\\n            cnt += A[j] == 0;\\n            if (cnt > 1) cnt -= A[i++] == 0;\\n        }\\n        return j - i - 1;\\n    }\\n};\\n```\\n\\n#### [3. Longest Substring Without Repeating Characters (Medium)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\\n\\n##### Sliding Window (Shrinkable)\\n\\n1. `state`: `cnt[ch]` is the number of occurrence of character `ch` in window.\\n2. `invalid`: `cnt[s[j]] > 1` is invalid.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/longest-substring-without-repeating-characters/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n        int i = 0, j = 0, N = s.size(), ans = 0, cnt[128] = {};\\n        for (; j < N; ++j) {\\n            cnt[s[j]]++;\\n            while (cnt[s[j]] > 1) cnt[s[i++]]--;\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n##### Sliding Window (Non-shrinkable)\\n\\nNote that since the non-shrinkable window might include multiple duplicates, we need to add a variable to our state.\\n\\n1. `state`: `dup` is the number of different kinds of characters that has duplicate in the window. For example, if window contains `aabbc`, then `dup = 2` because `a` and `b` has duplicates.\\n2. `invalid`: `dup > 0` is invalid\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/longest-substring-without-repeating-characters/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n        int i = 0, j = 0, N = s.size(), cnt[128] = {}, dup = 0;\\n        for (; j < N; ++j) {\\n            dup += ++cnt[s[j]] == 2;\\n            if (dup) dup -= --cnt[s[i++]] == 1;\\n        }\\n        return j - i;\\n    }\\n};\\n```\\n\\n#### [713. Subarray Product Less Than K (Medium)](https://leetcode.com/problems/subarray-product-less-than-k/)\\n\\n##### Sliding Window (Shrinkable)\\n\\n* `state`: `prod` is the product of the numbers in window\\n* `invalid`: `prod >= k` is invalid. \\n\\nNote that since we want to make sure the window `[i, j]` is valid at the end of the `for` loop, we need `i <= j` check for the inner `for` loop. `i == j + 1` means this window is empty.\\n\\nEach maximum window `[i, j]` can generate `j - i + 1` valid subarrays, so we need to add `j - i + 1` to the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/subarray-product-less-than-k/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numSubarrayProductLessThanK(vector<int>& A, int k) {\\n        if (k == 0) return 0;\\n        long i = 0, j = 0, N = A.size(), prod = 1, ans = 0;\\n        for (; j < N; ++j) {\\n            prod *= A[j];\\n            while (i <= j && prod >= k) prod /= A[i++];\\n            ans += j - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**The non-shrinkable template is not applicable here since we need to the length of each maximum window ending at each position**\\n\\n\\n\\n----\\n\\nBelow is my original answer during contest. As you can see, if I don\\'t use this template, the solution could be a bit complex.\\n## Solution 1. Sliding Window\\n\\nLet two pointers `i, j` form a window `[i, j]`. The window is valid if `(j - i + 1) * A[j] - sum <= k`.\\n\\nWe keep increasing `j` to expand the window as much as possible. When the window becomes invalid, we increment `i`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/frequency-of-the-most-frequent-element/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& A, int k) {\\n        sort(begin(A), end(A));\\n        long i = 0, j = 0, N = A.size(), ans = 1, sum = A[0];\\n        for (; i < N; ++i) {\\n            while (j < N && (j - i + 1) * A[j] - sum <= k) {\\n                ans = max(ans, j - i + 1);\\n                ++j;\\n                if (j < N) sum += A[j];\\n            }\\n            sum -= A[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nint i = 0, j = 0, ans = 0;\\nfor (; j < N; ++j) {\\n    // CODE: use A[j] to update state which might make the window invalid\\n    for (; invalid(); ++i) { // when invalid, keep shrinking the left edge until it\\'s valid again\\n        // CODE: update state using A[i]\\n    }\\n    ans = max(ans, j - i + 1); // the window [i, j] is the maximum window we\\'ve found thus far\\n}\\nreturn ans;\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/frequency-of-the-most-frequent-element/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& A, int k) {\\n        sort(begin(A), end(A));\\n        long i = 0, N = A.size(), ans = 1, sum = 0;\\n        for (int j = 0; j < N; ++j) {\\n            sum += A[j];\\n            while ((j - i + 1) * A[j] - sum > k) sum -= A[i++];\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nint i = 0, j = 0;\\nfor (; j < N; ++j) {\\n    // CODE: use A[j] to update state which might make the window invalid\\n    if (invalid()) { // Increment the left edge ONLY when the window is invalid. In this way, the window GROWs when it\\'s valid, and SHIFTs when it\\'s invalid\\n        // CODE: update state using A[i]\\n        ++i;\\n    }\\n    // after `++j` in the for loop, this window `[i, j)` of length `j - i` MIGHT be valid.\\n}\\nreturn j - i; // There must be a maximum window of size `j - i`.\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/frequency-of-the-most-frequent-element/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& A, int k) {\\n        sort(begin(A), end(A));\\n        long i = 0, j = 0, N = A.size(), sum = 0;\\n        for (; j < N; ++j) {\\n            sum += A[j];\\n            if ((j - i + 1) * A[j] - sum > k) sum -= A[i++];\\n        }\\n        return j - i;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& A) {\\n        int i = 0, j = 0, N = A.size(), cnt = 0, ans = 0;\\n        for (; j < N; ++j) {\\n            cnt += A[j] == 0;\\n            while (cnt > 1) cnt -= A[i++] == 0;\\n            ans = max(ans, j - i); // note that the window is of size `j - i + 1`. We use `j - i` here because we need to delete a number.\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& A) {\\n        int i = 0, j = 0, N = A.size(), cnt = 0;\\n        for (; j < N; ++j) {\\n            cnt += A[j] == 0;\\n            if (cnt > 1) cnt -= A[i++] == 0;\\n        }\\n        return j - i - 1;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/longest-substring-without-repeating-characters/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n        int i = 0, j = 0, N = s.size(), ans = 0, cnt[128] = {};\\n        for (; j < N; ++j) {\\n            cnt[s[j]]++;\\n            while (cnt[s[j]] > 1) cnt[s[i++]]--;\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/longest-substring-without-repeating-characters/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n        int i = 0, j = 0, N = s.size(), cnt[128] = {}, dup = 0;\\n        for (; j < N; ++j) {\\n            dup += ++cnt[s[j]] == 2;\\n            if (dup) dup -= --cnt[s[i++]] == 1;\\n        }\\n        return j - i;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/subarray-product-less-than-k/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numSubarrayProductLessThanK(vector<int>& A, int k) {\\n        if (k == 0) return 0;\\n        long i = 0, j = 0, N = A.size(), prod = 1, ans = 0;\\n        for (; j < N; ++j) {\\n            prod *= A[j];\\n            while (i <= j && prod >= k) prod /= A[i++];\\n            ans += j - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/frequency-of-the-most-frequent-element/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& A, int k) {\\n        sort(begin(A), end(A));\\n        long i = 0, j = 0, N = A.size(), ans = 1, sum = A[0];\\n        for (; i < N; ++i) {\\n            while (j < N && (j - i + 1) * A[j] - sum <= k) {\\n                ans = max(ans, j - i + 1);\\n                ++j;\\n                if (j < N) sum += A[j];\\n            }\\n            sum -= A[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175090,
                "title": "java-c-python-sliding-window",
                "content": "# **Intuition**\\nSort the input array `A`\\nSliding window prolem actually,\\nthe key is to find out the valid condition:\\n`k + sum >= size * max`\\nwhich is\\n`k + sum >= (j - i + 1) * A[j]`\\n<br>\\n\\n# **Explanation**\\nFor every new element A[j] to the sliding window,\\nAdd it to the sum by `sum += A[j]`.\\nCheck if it\\'a valid window by\\n`sum + k < (long)A[j] * (j - i + 1)`\\n\\nIf not, removing `A[i]` from the window by\\n`sum -= A[i]` and `i += 1`.\\n\\nThen update the `res` by `res = max(res, j - i + 1)`.\\n\\nI added solution 1 for clearly expain the process above.\\nDon\\'t forget to handle the overflow cases by using `long`.\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n\\n# Solution 1: Use `while` loop\\n**Java**\\n```java\\n    public int maxFrequency(int[] A, int k) {\\n        int res = 1, i = 0, j;\\n        long sum = 0;\\n        Arrays.sort(A);\\n        for (j = 0; j < A.length; ++j) {\\n            sum += A[j];\\n            while (sum + k < (long)A[j] * (j - i + 1)) {\\n                sum -= A[i];\\n                i += 1;\\n            }\\n            res = Math.max(res, j - i + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n# Solution 2: Use `if` clause\\nJust save some lines and improve a little time.\\n**Java**\\n```java\\n    public int maxFrequency(int[] A, long k) {\\n        int i = 0, j;\\n        Arrays.sort(A);\\n        for (j = 0; j < A.length; ++j) {\\n            k += A[j];\\n            if (k < (long)A[j] * (j - i + 1))\\n                k -= A[i++];\\n        }\\n        return j - i;\\n    }\\n```\\n**C++**\\n```cpp\\n    int maxFrequency(vector<int>& A, long k) {\\n        int i = 0, j;\\n        sort(A.begin(), A.end());\\n        for (j = 0; j < A.size(); ++j) {\\n            k += A[j];\\n            if (k < (long)A[j] * (j - i + 1))\\n                k -= A[i++];\\n        }\\n        return j - i;\\n    }\\n```\\n**Python**\\n```py\\n    def maxFrequency(self, A, k):\\n        i = 0\\n        A.sort()\\n        for j in xrange(len(A)):\\n            k += A[j]\\n            if k < A[j] * (j - i + 1):\\n                k -= A[i]\\n                i += 1\\n        return j - i + 1\\n```\\n<br>\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nPlease pick whichever one,\\nfind more explanations and discussion,\\nand understand at least once,\\nthen you can easily ramp up all my solution on sliding windows.\\n\\nGood luck and have fun.\\n\\n- 1838. [Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175090/JavaC%2B%2BPython-Sliding-Window)\\n- 1493. [Longest Subarray of 1\\'s After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/708112/JavaC%2B%2BPython-Sliding-Window-at-most-one-0)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/JavaC%2B%2BPython-Sliding-Window)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int maxFrequency(int[] A, int k) {\\n        int res = 1, i = 0, j;\\n        long sum = 0;\\n        Arrays.sort(A);\\n        for (j = 0; j < A.length; ++j) {\\n            sum += A[j];\\n            while (sum + k < (long)A[j] * (j - i + 1)) {\\n                sum -= A[i];\\n                i += 1;\\n            }\\n            res = Math.max(res, j - i + 1);\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int maxFrequency(int[] A, long k) {\\n        int i = 0, j;\\n        Arrays.sort(A);\\n        for (j = 0; j < A.length; ++j) {\\n            k += A[j];\\n            if (k < (long)A[j] * (j - i + 1))\\n                k -= A[i++];\\n        }\\n        return j - i;\\n    }\\n```\n```cpp\\n    int maxFrequency(vector<int>& A, long k) {\\n        int i = 0, j;\\n        sort(A.begin(), A.end());\\n        for (j = 0; j < A.size(); ++j) {\\n            k += A[j];\\n            if (k < (long)A[j] * (j - i + 1))\\n                k -= A[i++];\\n        }\\n        return j - i;\\n    }\\n```\n```py\\n    def maxFrequency(self, A, k):\\n        i = 0\\n        A.sort()\\n        for j in xrange(len(A)):\\n            k += A[j]\\n            if k < A[j] * (j - i + 1):\\n                k -= A[i]\\n                i += 1\\n        return j - i + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1533899,
                "title": "sliding-window-visualisation",
                "content": "Hi Friends\\n\\nThis is my very first attempt to create visual solutions. Please let me know your suggestions and feedback.\\n\\n![image](https://assets.leetcode.com/users/images/71a4a28c-271d-4142-bcd9-04260b633479_1634866118.5069532.gif)\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "Hi Friends\\n\\nThis is my very first attempt to create visual solutions. Please let me know your suggestions and feedback.\\n\\n![image](https://assets.leetcode.com/users/images/71a4a28c-271d-4142-bcd9-04260b633479_1634866118.5069532.gif)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1175181,
                "title": "java-python-prefix-sum-binary-search-o-nlogn",
                "content": "**Idea**\\n![image](https://assets.leetcode.com/users/images/2f709d8a-aea8-4f6f-90f8-4a0dd962ba71_1619326239.2927225.png)\\n \\n- For `index` in range `[0..n-1]` of array `nums`:\\n\\t- We `count` maximum frequency of `nums[index]` if we make other elements equal to `nums[index]` by performing at most `k` operations.\\n- In `count` function, we do binary search to find smallest `mid` in range `[0..index]`, which sum of `(nums[mid], nums[mid+1]..., nums[index-1])` + `k` >= `(index-mid) * nums[index]`.\\n\\n**Complexity:**\\n- Time: `O(NlogN)`\\n- Space: `O(N)`\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        preSum = [0] * (n + 1)\\n        for i in range(n):\\n            preSum[i + 1] = preSum[i] + nums[i]\\n\\n        def getSum(left, right):  # left, right inclusive\\n            return preSum[right + 1] - preSum[left]\\n\\n        def count(index): # Count frequency of `nums[index]` if we make other elements equal to `nums[index]`\\n            left = 0\\n            right = index\\n            res = index\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                s = getSum(mid, index - 1) # get sum of (nums[mid], nums[mid+1]...nums[index-1])\\n                if s + k >= (index - mid) * nums[index]: # Found an answer -> Try to find a better answer in the left side\\n                    res = mid  # save best answer so far\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            return index - res + 1\\n\\n        ans = 0\\n        for i in range(n):\\n            ans = max(ans, count(i))\\n        return ans\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    long[] preSum;\\n    public int maxFrequency(int[] nums, int k) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        preSum = new long[n+1];\\n        for (int i = 0; i < n; i++)\\n            preSum[i + 1] = preSum[i] + nums[i];\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n            ans = Math.max(ans, count(nums, k, i));\\n        return ans;\\n    }\\n    long getSum(int left, int right) {  // left, right inclusive\\n        return preSum[right + 1] - preSum[left];\\n    }\\n    // Count frequency of `nums[index]` if we make other elements equal to `nums[index]`\\n    int count(int[] nums, int k, int index) {\\n        int left = 0, right = index, res = index;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            long s = getSum(mid, index - 1); // get sum of(nums[mid], nums[mid + 1]...nums[index - 1])\\n            if (s + k >= (long)(index - mid) * nums[index]) { // Found an answer -> Try to find a better answer in the left side\\n                res = mid; // save best answer so far\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return index - res + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        preSum = [0] * (n + 1)\\n        for i in range(n):\\n            preSum[i + 1] = preSum[i] + nums[i]\\n\\n        def getSum(left, right):  # left, right inclusive\\n            return preSum[right + 1] - preSum[left]\\n\\n        def count(index): # Count frequency of `nums[index]` if we make other elements equal to `nums[index]`\\n            left = 0\\n            right = index\\n            res = index\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                s = getSum(mid, index - 1) # get sum of (nums[mid], nums[mid+1]...nums[index-1])\\n                if s + k >= (index - mid) * nums[index]: # Found an answer -> Try to find a better answer in the left side\\n                    res = mid  # save best answer so far\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            return index - res + 1\\n\\n        ans = 0\\n        for i in range(n):\\n            ans = max(ans, count(i))\\n        return ans\\n```\n```java\\nclass Solution {\\n    long[] preSum;\\n    public int maxFrequency(int[] nums, int k) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        preSum = new long[n+1];\\n        for (int i = 0; i < n; i++)\\n            preSum[i + 1] = preSum[i] + nums[i];\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n            ans = Math.max(ans, count(nums, k, i));\\n        return ans;\\n    }\\n    long getSum(int left, int right) {  // left, right inclusive\\n        return preSum[right + 1] - preSum[left];\\n    }\\n    // Count frequency of `nums[index]` if we make other elements equal to `nums[index]`\\n    int count(int[] nums, int k, int index) {\\n        int left = 0, right = index, res = index;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            long s = getSum(mid, index - 1); // get sum of(nums[mid], nums[mid + 1]...nums[index - 1])\\n            if (s + k >= (long)(index - mid) * nums[index]) { // Found an answer -> Try to find a better answer in the left side\\n                res = mid; // save best answer so far\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return index - res + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175123,
                "title": "java-sliding-window-o-n-logn-solution",
                "content": "Here we see that in order to calculate the maximum frequency of a number, we can increment some numbers less than it. Lets say we increment k numbers less than x to make them all x. Then operations required will be equal to\\n\\n`Ops = k * x-sum`\\n\\nwhere sum is the sum of all the numbers less than x which were incremented.\\n\\nWe can utilize this property to create a sliding window approach. So, we first sort the array. Lets say we have a window (i, j), then that window can be made to have all elements equal to the maximum (which is a[j]). So, we check if\\n\\n`a[j] * (j-i+1)  - sum[i:j] <=k`\\n\\nIf it, then we can increase j, else we need to increase i.\\n\\n\\n```\\nclass Solution {\\n    public int maxFrequency(int[] a, int k) {\\n        int n = a.length;\\n        \\n        Arrays.sort(a);\\n        \\n        int ans = 0;\\n        int left = 0;\\n        \\n        long sum = 0;\\n        \\n        for(int right=0; right<n; right++) {\\n            sum += a[right];\\n            \\n            while(a[right]*1L*(right-left+1)-sum>k) {\\n                sum -= a[left];\\n                left++;\\n            }\\n            \\n            ans = Math.max(ans, right-left+1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n\\n\\nTime Complexity => O(n * logn), since we are sorting\\nSpace Complexity => O(1) (Constant Space)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] a, int k) {\\n        int n = a.length;\\n        \\n        Arrays.sort(a);\\n        \\n        int ans = 0;\\n        int left = 0;\\n        \\n        long sum = 0;\\n        \\n        for(int right=0; right<n; right++) {\\n            sum += a[right];\\n            \\n            while(a[right]*1L*(right-left+1)-sum>k) {\\n                sum -= a[left];\\n                left++;\\n            }\\n            \\n            ans = Math.max(ans, right-left+1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175042,
                "title": "c-two-pointers",
                "content": "I got WA (hidden) for this exact solution, and wasted some time figuring it out. I finially gave up, tried after the contest, and the same solution got accepted.\\n\\n> Update: the hidden test case was `[100000] 100000`, and I did change `int res = 0` to `int res = 1` but did not submit till after the contest.\\n\\n#### Solution\\nFirst, we sort our numbers. Starting from the highest number (first pointer - `i`) , we check how many numbers can we level to that numbers before we run out of operations (second pointer - `j`).\\n\\nAfter that, we decrement `i` and adjust the number of operations to compensate.\\n\\n**C++**\\n```cpp\\nint maxFrequency(vector<int>& nums, int k) {\\n    int res = 1;\\n    sort(begin(nums), end(nums));\\n    for (int i = nums.size() - 1, j = i; i > 0; --i) {\\n        for (; j >= 0 && k >= nums[i] - nums[j]; --j)\\n            k -= nums[i] - nums[j];\\n        res = max(res, i - j);\\n        k += (nums[i] - nums[i - 1]) * (i - j - 1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxFrequency(vector<int>& nums, int k) {\\n    int res = 1;\\n    sort(begin(nums), end(nums));\\n    for (int i = nums.size() - 1, j = i; i > 0; --i) {\\n        for (; j >= 0 && k >= nums[i] - nums[j]; --j)\\n            k -= nums[i] - nums[j];\\n        res = max(res, i - j);\\n        k += (nums[i] - nums[i - 1]) * (i - j - 1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1182164,
                "title": "c-sort-and-binary-search-detailed-explanation-with-pictures-t-o-nlogn-s-o-n",
                "content": "### Intuition\\nConsidering a number `x` from the given array.\\n1. Only the numbers smaller than `x` can be incremented to increase the frequency of `x`\\n2. To maximize the frequency, numbers closest to `x` should be incremented as they require less additions to reach the value `x`.\\n\\n\\t.\\n\\t\\nSo our rough algo would be sorting the array and finding the max window for each element `x` in which its each elements can be incremented to the value equal to `x`  with given steps `K`.\\n\\nFurther, deducing the condition for a valid window with `K` steps:\\n\\nLet the size of window be `s` for an element `x` and sum of the window be `sum` , so if we increment each value of this window to x, the following should hold: \\n**`s * x <= sum + K`.**\\n\\n\\n#### Final Algorithm\\n1. Sort the array.\\n2. Maintain a prefix sum array to find the window `sum`.\\n3. Find the maximum window for each element.\\n4. Return the overall max of all windows.\\n5. **Follow Up**: For the `3rd` step we can apply `Binary Search` to find the maximum possible window size. (Furhter expained with comments in Code below)\\n![image](https://assets.leetcode.com/users/images/496f6743-24b0-49d7-8edf-436f32ed14e7_1619700786.2636223.png)\\n\\n\\t\\tTime: `O(NLogN)`\\n\\t\\tSpace: `O(N)`\\n\\n### **C++**\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &nums, vector<long long> &sum, int k, int i)      // Return Maximum Window for i(th) element\\n    {\\n        long long low = 0, high = i, m,ans;              // m is the starting index of window  \\n        while(low <= high)\\n        {\\n            m = (high - low)/2 + low;\\n            long long lhs = (i-m+1)*nums[i], rhs;        // i - m + 1 = s (size of the window)\\n            if(m == 0)                                   // corner case when window starts from index 0\\n                rhs = sum[i]+k;\\n            else\\n                rhs = sum[i] - sum[m-1] + k;            // sum[i] - sum[m-1] = sum of the window\\n            if(lhs <= rhs)                              // comparing LHS and RHS of forementioned equation above.\\n            {\\n                ans = i - m + 1;\\n                high = m - 1;                          // increasing the window size\\n            }else\\n                low = m + 1;                           // decreasing the window size \\n        }\\n        return ans;\\n    }\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<long long> sum(n,0);\\n        sum[0] = nums[0];\\n        for(int i = 1; i < n; i++)                 //  prefix sum array\\n            sum[i] = sum[i - 1] + nums[i];\\n        int res = 1;\\n        for(int i = 0; i < n; i++)                // checking each element for largest window\\n            res = max(res, helper(nums,sum,k,i));\\n        return res;\\n    }\\n};\\n```\\n\\n**Follow Up:** Last for loop takes `NlogN` time to find the max of all windows. But it can be done in `N` time complexity by implementing the `Sliding Window` with the forementioned equation, though the overall complexity remians the same because of the sorting.\\n\\nFor `Sliding Window` solution: [https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175090/JavaC%2B%2BPython-Sliding-Window](http://)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &nums, vector<long long> &sum, int k, int i)      // Return Maximum Window for i(th) element\\n    {\\n        long long low = 0, high = i, m,ans;              // m is the starting index of window  \\n        while(low <= high)\\n        {\\n            m = (high - low)/2 + low;\\n            long long lhs = (i-m+1)*nums[i], rhs;        // i - m + 1 = s (size of the window)\\n            if(m == 0)                                   // corner case when window starts from index 0\\n                rhs = sum[i]+k;\\n            else\\n                rhs = sum[i] - sum[m-1] + k;            // sum[i] - sum[m-1] = sum of the window\\n            if(lhs <= rhs)                              // comparing LHS and RHS of forementioned equation above.\\n            {\\n                ans = i - m + 1;\\n                high = m - 1;                          // increasing the window size\\n            }else\\n                low = m + 1;                           // decreasing the window size \\n        }\\n        return ans;\\n    }\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<long long> sum(n,0);\\n        sum[0] = nums[0];\\n        for(int i = 1; i < n; i++)                 //  prefix sum array\\n            sum[i] = sum[i - 1] + nums[i];\\n        int res = 1;\\n        for(int i = 0; i < n; i++)                // checking each element for largest window\\n            res = max(res, helper(nums,sum,k,i));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626574,
                "title": "python-sliding-window-explained",
                "content": "The most difficult part in this problem, or in all sliding window problems in general, is to come up with some way to find if a particular window is valid or not because if we know that, then any sliding window problem is a piece of cake. Sometimes we are directly given in the problem statement but most of the times we have to figure out some sort of check for a valid subarray. \\n\\nThis particular problem is like that. Yes, we are given the number of moves/increments we can do in a window but how to know if a particular window is valid or not?\\n\\nJust think about it. We want to make all the numbers the same in any window by doing at most k increments. So we want to efficiently use our moves and for any element, we want to use the least amount of moves possible to turn it into another element.\\n\\nThis means, the element that we want to increment and the element that we want others to turn into, should be as close as possible. In short, the array needs to be sorted. \\n\\n\\t\\t\\tnums = [3,9,6]\\n\\t\\t\\t\\nConsider this example. We know that we can increment any number to turn it into any other number. That means, We can only take smaller elements and turn them into bigger elements. So for any random window in this array, we want a way to quickly get the biggest number so that we can then try turning all the elements into that number using the moves. And again, that\\'s what sorting allows us to do. Because if we sort the array - \\n\\n\\t\\t\\tnums = [3,6,9]\\n\\nNow, no matter how big the window size is, the last element of the window will always be the biggest element so we can try to turn all the elements of that window to that last element by incrementing. \\n\\nAnd now comes the interesting part. How to expand or shrink the window? What\\'s the condition?\\n\\nWhat we want is the window should have all the elements the same as the biggest element after doing at most K increments.\\n\\nThis also means that, the sum of the window after making all elements same as biggest should be => \\n\\n\\t\\t\\t(biggest element * number of elements in window)\\n\\t\\t\\t\\t\\n\\t\\t\\te.g. take the window [3,6] \\n\\t\\t\\tIf we turn all the elements into 6. Total sum will be 6 + 6  = 12 or (\\n\\t\\t\\t6 * number of elements in window)\\n\\t\\t\\t\\nBut ofcourse it is not always possible to turn all elements of window into biggest element since we are restricted by the moves k. \\n\\nSince we can use at most k moves, lets say we use all our moves to increment elements in a window. That basically means, whatever sum of the window was earlier, we added k to it. \\n\\n\\t\\tIf we used all the k moves in a window\\n\\t\\tNew Sum = (sum before using k moves + k)\\n\\nAnd now, for a valid window, we want to use at most k moves to convert all elements into biggest element. This means, we can combine the above two conditions together -\\n\\n\\tFor a valid window - \\n\\t\\n\\tTotal Sum of window after converting all elements to biggest element should be <= total sum of window after k increments\\n\\t\\n\\tThat is,\\n\\t\\n\\t\\n\\t(biggest element * number of elements in window) <= (sum of window + k)\\n\\t\\n\\t\\nAnd that\\'s the condition we have to use for checking for a valid window. \\n\\n\\n```\\ndef maxFrequency(self, nums: List[int], k: int) -> int:\\n        maxFreq = 0\\n        \\n        # Sort the numbers first\\n        nums.sort()\\n        \\n        i,j = 0,0\\n        currSum = 0\\n        while j < len(nums):\\n            currSum += nums[j]\\n\\t\\t\\t# Since the array is sorted\\n            # The largest number for any window at any time is the current/jth element\\n            # So we want to know how many moves will it take to make all elements of this window = j\\n            # If each element becomes j, that means total sum will be nums[j] * number of elements in window\\n            # And we want that to be either less than or equal to sum of this window + moves we have\\n\\t\\t\\t# Because number of moves means how many we can add to a window so that each element is the same\\n            while nums[j] * (j - i + 1) > currSum + k: \\n                currSum -= nums[i]\\n                i += 1\\n            \\n            # If we are here, that means, this is a valid window\\n            maxFreq = max(maxFreq, j - i + 1)\\n            j += 1\\n            \\n        return maxFreq\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxFrequency(self, nums: List[int], k: int) -> int:\\n        maxFreq = 0\\n        \\n        # Sort the numbers first\\n        nums.sort()\\n        \\n        i,j = 0,0\\n        currSum = 0\\n        while j < len(nums):\\n            currSum += nums[j]\\n\\t\\t\\t# Since the array is sorted\\n            # The largest number for any window at any time is the current/jth element\\n            # So we want to know how many moves will it take to make all elements of this window = j\\n            # If each element becomes j, that means total sum will be nums[j] * number of elements in window\\n            # And we want that to be either less than or equal to sum of this window + moves we have\\n\\t\\t\\t# Because number of moves means how many we can add to a window so that each element is the same\\n            while nums[j] * (j - i + 1) > currSum + k: \\n                currSum -= nums[i]\\n                i += 1\\n            \\n            # If we are here, that means, this is a valid window\\n            maxFreq = max(maxFreq, j - i + 1)\\n            j += 1\\n            \\n        return maxFreq\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1179374,
                "title": "python-3-sliding-window-explanation-with-code",
                "content": "**For Code click <a href=\"#81523\">Frequenct of Most Frequent Element</a>**\\n\\n*Took a long route to explain*\\n\\nSliding Window concept never came to my mind when i was trying the question on my own using dp and tabulation. But i was always getting time limit error. Then after trying for some time on some other methods i had to look at discussions and there it is; a simple logic with some slight intuition (Sliding Window). First I\\'ll explain the logic and intuition behind Sliding Window, then we can look at the code.\\n\\nFor example lets take our nums as: \\n<table><tr><td>1</td><td>9</td><td>3</td><td>4</td><td>1</td></tr></table>\\n\\nLet **K** be a very large number. Think for a moment what you would do in this situation. \\n\\n**Case 1.1:** If we randomly pick number 4 from **nums** list then we can only increment numbers that are less than 4. So to maximize the numbers that can be incremented we need to pick large number of that list.\\n\\n**Case 1.2:** So  we can take 9 then we can increment other numbers to match with number 9 so that our maximum frequency count would be 5.\\n\\n**Case 2**\\n**Step 1:** Now let\\'s take **K** as 4, now of course we can\\'t do the same as above because now our **K** is a very small number and we can\\'t increment all the numbers to match with 9.\\nHere\\n```\\nsum(nums)+k < 9*len(window_of_nums)\\n```\\n\\n**Step 2:** But we can remove the number which is very far away from 9 on the number line and that would be 1. Even after removing 1 from nums our mfc(9) is still at 1 with **k=4**\\n<table><tr><td>9</td><td>3</td><td>4</td><td>1</td></tr></table>\\n\\n**Step 3:** We can repeat step 2 till we get to use our full **K** increments to match with number 9. In this case we still have another 1 in our nums list we have to remove that. Then we have to remove 3 then 4 and finally we will be left with only one element and that would be 9.\\n<table><tr><td>9</td><td>3</td><td>4</td></tr></table>\\n\\n<table><tr><td>9</td><td>4</td></tr></table>\\n\\n<table><tr><td>9</td></tr></table>\\n\\nOur mfc(9) will be 1. \\n\\nWe need to keep on removing the least elements in the list till we get\\n```\\nsum(nums)+k>=9*len(sliding_window)\\n```\\n**Step 3:** Then we can repeat **Step 1 and Step 2** with the next largest number other than 9 and that would be 4. \\n\\n**Step 4:** Repeat **Steps 1 to 3** till we have only one element left. Then we can take the max(mfc(all_elements))\\n\\n**Step 5:** We can clearly see that for implementing the above logic in best way first we need to sort our nums list so that we can access our large numbers in a window very easily.\\n\\nFrom intuition we can see that the time complexity for the above logic would be O(n*\\\\n). But we can do better than that if we had known the following logic:\\n\\nLet\\'s sort our nums list:\\n\\n<table><tr><td>1</td><td>1</td><td>3</td><td>4</td><td>9</td></tr></table>\\n\\nAnd let\\'s say that instead of taking the largest number 9 at first;\\nlet\\'s start calculating from the left to right.\\n\\nWe can calculate mfc(1) with sorted_nums[0:1] window.\\nWe can calculate mfc(1) with sorted_nums[0:2] window. (As there are two 1\\'s in list)\\nWe can calculate mfc(3) with sorted_nums[0:3] window.\\nWe can calculate mfc(4) with sorted_nums[0:4] window.\\n\\nAnd while calculating mfc(9) what if we had some previous info about the numbers sorted_nums[0:4] all we need to do is access just one element of our list.\\n\\nAnd while calculating mfc(4):\\n```\\nsum(sorted_nums[0:4])+k<4*4  ##eq=>1\\n```\\nand for this reason we have to remove the first element from sorted_nums[0:4]\\n```\\nsum(sorted_nums[1:4])+k>=4*3 ##eq=>2\\n```\\nand when we are calculating mfc(9) it doesn\\'t make sense to use the first element of sorted_nums again because even if we include it in our window anyway in the future we have to remove it.\\n```\\n# from eq=>1\\nsum(sorted_nums[0:4])+k+9 < 4*4 + 9 # eq=>3\\n# to satisfy our mfc condition\\nsum(list)+k>=num*len(list)\\n# in our situation it should be\\nsum(sorted_nums[0:])+k >= 9*5 #eq=>4\\n# when we observe eq->3 and eq->4 we can clearly see that they are contradicting each other\\n# that means when we include the first element of sorted_nums the mfc condition won\\'t be satisfied\\n# and we have got this information from the previous number 4 itself so now we don\\'t need to again include this number into our window we can just make use of the whatever elements the previous number has used.\\n# like this we can use the same sliding window as of the previous number and just add the new number to it and follow the steps mentioned to get mfc value\\n```\\n\\n\\n<div id=81523></div>\\n\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        sum_s_w = nums[0]\\n        fin = 1\\n        i=0\\n        for j in range(1,n):\\n            sum_s_w+=nums[j]\\n            mx = nums[j]\\n            while sum_s_w+k<mx*(j-i+1):\\n                sum_s_w -= nums[i]\\n                i += 1\\n            fin = max(fin,j-i+1)\\n        return fin\\n```\\n\\nDo comment if anything needs to be added or if there are any doubts ::)\\n",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nsum(nums)+k < 9*len(window_of_nums)\\n```\n```\\nsum(nums)+k>=9*len(sliding_window)\\n```\n```\\nsum(sorted_nums[0:4])+k<4*4  ##eq=>1\\n```\n```\\nsum(sorted_nums[1:4])+k>=4*3 ##eq=>2\\n```\n```\\n# from eq=>1\\nsum(sorted_nums[0:4])+k+9 < 4*4 + 9 # eq=>3\\n# to satisfy our mfc condition\\nsum(list)+k>=num*len(list)\\n# in our situation it should be\\nsum(sorted_nums[0:])+k >= 9*5 #eq=>4\\n# when we observe eq->3 and eq->4 we can clearly see that they are contradicting each other\\n# that means when we include the first element of sorted_nums the mfc condition won\\'t be satisfied\\n# and we have got this information from the previous number 4 itself so now we don\\'t need to again include this number into our window we can just make use of the whatever elements the previous number has used.\\n# like this we can use the same sliding window as of the previous number and just add the new number to it and follow the steps mentioned to get mfc value\\n```\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        sum_s_w = nums[0]\\n        fin = 1\\n        i=0\\n        for j in range(1,n):\\n            sum_s_w+=nums[j]\\n            mx = nums[j]\\n            while sum_s_w+k<mx*(j-i+1):\\n                sum_s_w -= nums[i]\\n                i += 1\\n            fin = max(fin,j-i+1)\\n        return fin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175081,
                "title": "java-python-3-sort-then-slide-window",
                "content": "Sort and then maintain a sliding window.\\n1. Sort and traverse the array starting from the 2nd element;\\n2. For each upper bound of the sliding window, compute how many operations needed to make all the elements within the sliding window equal, and deduct it from `k`;\\n3. If `k` is not big enough to finish the operations, increase lower bound and change `k` accordingly.\\n4.  After all iterations, the windown width is the solution.\\n```java\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int lo = 0, hi = 1; // lower and upper bounds of the sliding window.\\n        while (hi < nums.length) {\\n            k -= (nums[hi] - nums[hi - 1]) * (hi - lo); // deduct the # of operations needed make all elements in the window equal.\\n            if (k < 0) {\\n                k += nums[hi] - nums[lo++];\\n            }\\n            ++hi;\\n        }\\n        return hi - lo;\\n    }\\n```\\n```python\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        lo, hi = 0, 1\\n        while hi < len(nums):\\n            k -= (nums[hi] - nums[hi - 1]) * (hi - lo)\\n            if k < 0:\\n                k += nums[hi] - nums[lo]\\n                lo += 1\\n            hi += 1\\n        return hi - lo\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: the space used during sorting.",
                "solutionTags": [],
                "code": "```java\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int lo = 0, hi = 1; // lower and upper bounds of the sliding window.\\n        while (hi < nums.length) {\\n            k -= (nums[hi] - nums[hi - 1]) * (hi - lo); // deduct the # of operations needed make all elements in the window equal.\\n            if (k < 0) {\\n                k += nums[hi] - nums[lo++];\\n            }\\n            ++hi;\\n        }\\n        return hi - lo;\\n    }\\n```\n```python\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        lo, hi = 0, 1\\n        while hi < len(nums):\\n            k -= (nums[hi] - nums[hi - 1]) * (hi - lo)\\n            if k < 0:\\n                k += nums[hi] - nums[lo]\\n                lo += 1\\n            hi += 1\\n        return hi - lo\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1175292,
                "title": "c-o-n-log-n-binary-search-slid-window-explain-solution",
                "content": "First thing is that if you have sub set of numbers and want to make them the same number it\\'s clear that you will make all the numbers as the largest one because the opearation only increases the number. \\n\\nyou can see that if you can make x numbers have the same frequancy so you can make x-1 numbers have the same frequancy too, so you can binary search on the answer.\\n\\nlet\\'s sort the numbers and try to make m numbers have the same frequancy \\nfor each m number in the array the summtion should equal to = maxnumber * m \\nbecause all the numbers must be equal to the maxnumber which is the last number in the current window, and the number of opearation needded is the difference between this sum and the summtion of the current window.\\n```\\nclass Solution {\\npublic:\\n    bool can(vector<int>& nums, int len, int k)\\n    { \\n      long long sum = 0;\\n      for (int i = 0; i < len - 1; i++)\\n      {\\n        sum += nums[i]; \\n      }\\n      for (int i = 0, j = len-1; j < nums.size(); j++, i++)\\n      {\\n        sum += nums[j]; \\n        long long need = 1LL * nums[j] * len; \\n        if (need - sum <= k)return 1; \\n        sum -= nums[i];\\n      }\\n      return 0;\\n    }\\n    int maxFrequency(vector<int>& nums, int k) {\\n      int l = 1, r = nums.size(), m, ans = 0;\\n      sort(nums.begin(), nums.end());\\n      while(l <= r)\\n      {\\n        m = (l+r) >> 1;\\n        if(can(nums, m, k))\\n          ans = m, l = m+1; \\n        else \\n          r = m-1;\\n      }\\n      return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool can(vector<int>& nums, int len, int k)\\n    { \\n      long long sum = 0;\\n      for (int i = 0; i < len - 1; i++)\\n      {\\n        sum += nums[i]; \\n      }\\n      for (int i = 0, j = len-1; j < nums.size(); j++, i++)\\n      {\\n        sum += nums[j]; \\n        long long need = 1LL * nums[j] * len; \\n        if (need - sum <= k)return 1; \\n        sum -= nums[i];\\n      }\\n      return 0;\\n    }\\n    int maxFrequency(vector<int>& nums, int k) {\\n      int l = 1, r = nums.size(), m, ans = 0;\\n      sort(nums.begin(), nums.end());\\n      while(l <= r)\\n      {\\n        m = (l+r) >> 1;\\n        if(can(nums, m, k))\\n          ans = m, l = m+1; \\n        else \\n          r = m-1;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489948,
                "title": "java-easy-solution-95-faster",
                "content": "**GIVEN:: nums=[1,4,8,13], k = 5**\\nIf for example the windowSize is \"3\", and one end **L** of window is pointing at index \"0\" and\\nother **R** at index \"2\" **(R-L+1=3)** , then the array would look like this : [1,4,8] now the totalSum=13(1+4+8).\\n\\nFor the frequency to be \"windowSize\" or \"3\" all the values should be equal to the \"R/end/last\" index.\\nsimple way to check is to multiply the \"windowSize\" with nums[end]/nums[R], and if the value of\\n\"totalSum+k < nums[R]*(R-L+1) then decrease the totalSum till \"totalSum is >= nums[R]\"\\n\\ncurrent Array = [1,4,8]\\ntotalSum=13;\\nvar-1:(R-L+1)*(nums[R])=(3)*(8)=24;\\nvar-2:(totalSum+k)=(13+5)=18;\\n\\nHere, (13+k)<24: thus decrease the totalSum:\\n\\ncurrent Array=[4,8]\\ntotalSum=13-nums[L] => 13-1=12.\\nvar-1:(R-L+1)*(nums[R])=(2)*(8)=16:\\nvar-2:(totalSum+k)=12+5=17:\\n\\nvar-2>=var-1 (YES)\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        //Step-1: Sorting->\\n        Arrays.sort(nums);\\n        //Step-2: Two-Pointers->\\n        int L=0,R=0;\\n        long totalSum=0;\\n        int res=1;\\n        //Iterating over the array:\\n        while(R<nums.length)\\n        {\\n            totalSum+=nums[R];\\n            //The value of \"totalSum+k\" should be \">=\" \"windowSize*nums[R]\"\\n            //then only the window is possible else decrease the \"totalSum\" \\n            //till the value \"totalSum+k\" is \">=\" \"windowSize*nums[R]\"\\n            while(! ((totalSum+k) >= ((R-L+1)*nums[R])) )\\n            {\\n                totalSum-=nums[L];\\n                L++;\\n            }\\n            res=Math.max(res,(R-L+1));\\n            R++;\\n        }\\n        return res;\\n    }\\n}\\n```\\nTimeComplexity: O(nlogn).\\nSpaceComplexity: O(1).\\nUpvote if usefull.",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        //Step-1: Sorting->\\n        Arrays.sort(nums);\\n        //Step-2: Two-Pointers->\\n        int L=0,R=0;\\n        long totalSum=0;\\n        int res=1;\\n        //Iterating over the array:\\n        while(R<nums.length)\\n        {\\n            totalSum+=nums[R];\\n            //The value of \"totalSum+k\" should be \">=\" \"windowSize*nums[R]\"\\n            //then only the window is possible else decrease the \"totalSum\" \\n            //till the value \"totalSum+k\" is \">=\" \"windowSize*nums[R]\"\\n            while(! ((totalSum+k) >= ((R-L+1)*nums[R])) )\\n            {\\n                totalSum-=nums[L];\\n                L++;\\n            }\\n            res=Math.max(res,(R-L+1));\\n            R++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370353,
                "title": "easy-to-understand-for-beginners-as-well-approach-explained",
                "content": "We are basically trying the convert all the elements within the windowSize into a similar elements\\nEg: nums = [1,2,4], k = 5;\\nWe initially begin with winSize as 1 and try to convert everything within that to the same el which we are currently at but within K and sum upto that winSize.If it goes beyond then decrease the winSize.\\n\\nNow lets say leftPtr is at 1 and rightPtr at 2. So here we are basically seeing if both the el could be converted to 2. If we convert both el to 2, then the total sum would be 4 (2 as 1st el(converted)  and 2 as 2nd el). We initally had a total of 3(1 as 1st el(before converting) and 2 as 2nd el). So if 4(currTotal) < 3(prevTotal) + k( you can think this K as an extra power or chances to convert), then we can keep on  increasing the winSize by incrementing rightPtr. But once the value exceeds the prevTotal(3) + k, then start to decrease the winSize by incrementing leftPtr.\\n\\n```\\nvar maxFrequency = function(nums, k) {\\n// We sorted because as we are allowed only to increment the value & we try to increase the smaller el to some larger el\\n    nums.sort((a,b)=>a-b);\\n    \\n    let left=0;\\n    let max=Math.max(); // without any args, Math.max() is -Infinity\\n    let curr=0;\\n\\t// I have used \\'for loop\\' so rightPtr is \\'i\\' here\\n    for(let i=0;i<nums.length;i++){\\n        curr+=nums[i];\\n\\t\\t// decrement the winSize once the value required to convert could not be achieved even after utilizing K\\n\\t\\t// (i-left+1) * nums[i] because we are converting every el upto that winSize by current el\\n        while((i-left+1) * nums[i] > curr+k){\\n            curr-=nums[left++]\\n        }        \\n        max = Math.max(max,i-left+1);\\n    }\\n    return max;\\n};\\n```\\nRuntime: 224 ms, faster than 92.59% of JavaScript online submissions for Frequency of the Most Frequent Element.\\nMemory Usage: 54.7 MB, less than 51.85% of JavaScript online submissions for Frequency of the Most Frequent Element.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxFrequency = function(nums, k) {\\n// We sorted because as we are allowed only to increment the value & we try to increase the smaller el to some larger el\\n    nums.sort((a,b)=>a-b);\\n    \\n    let left=0;\\n    let max=Math.max(); // without any args, Math.max() is -Infinity\\n    let curr=0;\\n\\t// I have used \\'for loop\\' so rightPtr is \\'i\\' here\\n    for(let i=0;i<nums.length;i++){\\n        curr+=nums[i];\\n\\t\\t// decrement the winSize once the value required to convert could not be achieved even after utilizing K\\n\\t\\t// (i-left+1) * nums[i] because we are converting every el upto that winSize by current el\\n        while((i-left+1) * nums[i] > curr+k){\\n            curr-=nums[left++]\\n        }        \\n        max = Math.max(max,i-left+1);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213963,
                "title": "c-sliding-window-two-pointers",
                "content": "The size of the sliding window will store the maximum number of elements made equal hence,increasing that particular element\\'s frequency.\\nFirst of all we will keep on increasing the sliding windows\\'s size by adding the forward elements and making sure to store the number of changes to be made to make all the elements in this current sliding window to be equal to the last elemnt of the window.\\nBasically speaking,add an element to the sliding window and keep track of the number of changes to be made to make all elements in the sliding window equal to this last added element.\\n\\nIf this number of changes exceeds k,throw the last element out of the sliding window including its contribution to the changes,and increment the left pointer.\\n\\nstore the best result i.e right-left and return it.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n       long long int left=0,right=0,n=nums.size(),dist=0,best=0;\\n        sort(nums.begin(),nums.end());\\n        while(right<n){\\n            if(right>0 and nums[right]!=nums[right-1]){\\n                dist+=(right-left)*(nums[right]-nums[right-1]);\\n            }\\n            right++;\\n            while(dist>k){\\n                dist-=(nums[right-1]-nums[left]);\\n                left++;\\n            }\\n            best=max(best,right-left);\\n        }\\n        return best;\\n    }\\n};\\n\\n```\\nIf u find it helpful do upvote and motivate me~\\nKeep coding!!!!!!!!!!!!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n       long long int left=0,right=0,n=nums.size(),dist=0,best=0;\\n        sort(nums.begin(),nums.end());\\n        while(right<n){\\n            if(right>0 and nums[right]!=nums[right-1]){\\n                dist+=(right-left)*(nums[right]-nums[right-1]);\\n            }\\n            right++;\\n            while(dist>k){\\n                dist-=(nums[right-1]-nums[left]);\\n                left++;\\n            }\\n            best=max(best,right-left);\\n        }\\n        return best;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605056,
                "title": "c-prefix-sum-sliding-window",
                "content": "# Intuition\\n###### Our goal is to identify a window in which we can adjust all its elements to the highest value present in that window. The objective is to select a window where the number of operations required to make all elements equal to the maximum value is less than the threshold k.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the vector in ascending order.\\n- Keep a variable to track the cumulative sum of all elements within the window, along with maintaining the size of the window and the largest window size encountered so far (which will be the final answer).\\n- The window_size in incremented at each iteration. \\n- In order to make all elements within the window the largest, the required number of operations can be calculated as follows:\\nnumber_of_operations = largest_in_window * window_size - window_sum.\\n- If the calculated number of operations exceeds the threshold value \\'k\\', then it is necessary to reduce the window size.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, long k) \\n    {\\n        sort(nums.begin(),nums.end());\\n\\n        int pos = 0;\\n        long result = 0;\\n        long window_size = 0;\\n        long window_sum = 0;\\n\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            window_sum+=nums[i];\\n            window_size = i-pos+1;\\n            \\n            while(( nums[i]*window_size - window_sum ) > k)\\n            {\\n                window_sum-=nums[pos++];\\n                window_size--;\\n            }\\n\\n            result = max(result,window_size);\\n        }\\n        return result;   \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, long k) \\n    {\\n        sort(nums.begin(),nums.end());\\n\\n        int pos = 0;\\n        long result = 0;\\n        long window_size = 0;\\n        long window_sum = 0;\\n\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            window_sum+=nums[i];\\n            window_size = i-pos+1;\\n            \\n            while(( nums[i]*window_size - window_sum ) > k)\\n            {\\n                window_sum-=nums[pos++];\\n                window_size--;\\n            }\\n\\n            result = max(result,window_size);\\n        }\\n        return result;   \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579702,
                "title": "python-further-break-down-sliding-window-template",
                "content": "Based on previous [summary](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!), I found that sliding window questions can be further categorized by certain pattern.\\n\\n### 1. Find the longest substring/subarray that can satisfy certain frequency condition\\n\\n3. Longest Substring Without Repeating Characters\\n\\n```py\\ndef lengthOfLongestSubstring(self, s: str) -> int:\\n    l = 0\\n    c = Counter()\\n    for r, ch in enumerate(s):\\n        c[ch] += 1\\n        if r - l + 1 - len(c) > 0:\\n            c[s[l]] -= 1\\n            if c[s[l]] == 0:\\n                del c[s[l]]\\n            l += 1\\n    return len(s) - l\\n```\\n\\n\\n159. Longest Substring with At Most Two Distinct Characters (Medium)\\n340. Longest Substring with At Most K Distinct Characters\\n\\n```py\\ndef lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:\\n    l = 0\\n    c = Counter()\\n    for r, ch in enumerate(s):\\n        c[ch] += 1\\n        if len(c) > 2:\\n            c[s[l]] -= 1\\n            if not c[s[l]]:\\n                del c[s[l]]\\n            l += 1\\n    return len(s) - l\\n\\ndef lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:\\n    c = Counter()\\n    l = 0\\n    for r, ch in enumerate(s):\\n        c[ch] += 1\\n        if len(c) > k:\\n            c[s[l]] -= 1\\n            if not c[s[l]]:\\n                del c[s[l]]\\n            l += 1\\n    return len(s) - l\\n```\\n424. Longest Repeating Character Replacement\\n\\n```py\\ndef characterReplacement(self, s: str, k: int) -> int:\\n    c = Counter()\\n    l = 0\\n    for r, ch in enumerate(s):\\n        c[ch] += 1\\n        if len(c) > 1 and r - l + 1 - max(c.values()) > k:\\n            c[s[l]] -= 1\\n            if c[s[l]] == 0:\\n                del c[s[l]]\\n            l += 1\\n    return len(s) - l\\n```\\n\\n487. Max Consecutive Ones II\\n\\n```py\\ndef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n    c = Counter()\\n    l = 0\\n    for r, num in enumerate(nums):\\n        c[num] += 1\\n        if r - l + 1 - c[1] > 1:\\n            c[nums[l]] -= 1\\n            l += 1\\n    return len(nums) - l\\n```\\n1004. Max Consecutive Ones III\\n\\n```py\\ndef longestOnes(self, nums: List[int], k: int) -> int:\\n    c = Counter()\\n    l = 0\\n    count_one = 0\\n    for r, num in enumerate(nums):\\n        c[num] += 1\\n        count_one = max(count_one, c[1])\\n        if r - l + 1 - count_one > k:\\n            c[nums[l]] -= 1\\n            l += 1\\n    return len(nums) - l\\n```\\n2024. Maximize the Confusion of an Exam\\n\\n```py\\ndef maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n    c = Counter()\\n    l = max_c = 0\\n    for r, ch in enumerate(answerKey):\\n        c[ch] += 1\\n        max_c = max(max_c, c[ch])\\n        if r - l + 1 > max_c + k:\\n            c[answerKey[l]] -= 1\\n            l += 1\\n    return len(answerKey) - l\\n```\\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element\\n\\n```py\\ndef longestSubarray(self, nums: List[int]) -> int:\\n    c = Counter()\\n    l = 0\\n    for r, num in enumerate(nums):\\n        c[num] += 1\\n        if r - l + 1 - c[1] > 1:\\n            c[nums[l]] -= 1\\n            l += 1\\n    return len(nums) - l - 1\\n```\\n\\nSome questions may also allow you to flip certain items with max K times. They all can be solved using the same control logic\\n\\n- initialize a Counter and the left point\\n- iterate the array/string\\n- Update the Counter\\n- If the state is no longer valid (by comparing current length with the condition), update Counter and left pointer\\n- return total length minus left pointer\\n\\n\\n### 2. Longest substring/subarray with unique property\\n\\n3. Longest Substring Without Repeating Characters\\n\\n```py\\ndef lengthOfLongestSubstring(self, s: str) -> int:\\n    d = {}\\n    l = 0\\n    res = 0\\n    for r, ch in enumerate(s):\\n        if ch in d:\\n            l = max(l, d[ch] + 1)\\n        res = max(res, r - l + 1)\\n        d[ch] = r\\n    return res\\n```\\n\\n1695. Maximum Erasure Value\\n\\n```py\\ndef maximumUniqueSubarray(self, nums: List[int]) -> int:\\n    nums = [0] + nums\\n    acc = list(accumulate(nums))\\n    res = 0\\n    c = {}\\n    l = 0\\n    for r, num in enumerate(nums):\\n        if num in c:\\n            l = max(l, c[num])\\n        res = max(res, acc[r] - acc[l])\\n        c[num] = r\\n    return res\\n```\\n\\nCertain type of questions require a unique property of an element. In this case we can use the following logic\\n\\n- check whether a new item we already saw.\\n- If yes, we update the left pointer to its position (or plus one)\\n- update the result\\n- add current item\\'s postion to the state\\n\\n\\n### 3. Find substring/subarray that can satisfy certain condition using while\\n\\n\\n713. Subarray Product Less Than K\\n\\n```py\\ndef numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\\n    if k == 0:\\n        return 0\\n    res = 0\\n    prod = 1\\n    l = 0\\n    for r, num in enumerate(nums):\\n        prod *= num\\n        while l < r and prod >= k:\\n            prod //= nums[l]\\n            l += 1\\n        if prod < k:\\n            res += r - l + 1\\n    return res\\n```\\n\\n1208. Get Equal Substrings Within Budget (Medium)\\n\\n```py\\ndef equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n    cost = l = 0\\n    res = 0\\n    for r, ch in enumerate(s):\\n        cost += abs(ord(ch) - ord(t[r]))\\n        while l < r and cost > maxCost:\\n            cost -= abs(ord(t[l]) - ord(s[l]))\\n            l += 1\\n        if cost <= maxCost:\\n            res = max(res, r - l + 1)\\n    return res\\n```\\n\\n\\nIn some scenario when you break the condition you have to move left pointer several steps where you can use a while loop. After that, do another check before updating the result.",
                "solutionTags": [],
                "code": "```py\\ndef lengthOfLongestSubstring(self, s: str) -> int:\\n    l = 0\\n    c = Counter()\\n    for r, ch in enumerate(s):\\n        c[ch] += 1\\n        if r - l + 1 - len(c) > 0:\\n            c[s[l]] -= 1\\n            if c[s[l]] == 0:\\n                del c[s[l]]\\n            l += 1\\n    return len(s) - l\\n```\n```py\\ndef lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:\\n    l = 0\\n    c = Counter()\\n    for r, ch in enumerate(s):\\n        c[ch] += 1\\n        if len(c) > 2:\\n            c[s[l]] -= 1\\n            if not c[s[l]]:\\n                del c[s[l]]\\n            l += 1\\n    return len(s) - l\\n\\ndef lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:\\n    c = Counter()\\n    l = 0\\n    for r, ch in enumerate(s):\\n        c[ch] += 1\\n        if len(c) > k:\\n            c[s[l]] -= 1\\n            if not c[s[l]]:\\n                del c[s[l]]\\n            l += 1\\n    return len(s) - l\\n```\n```py\\ndef characterReplacement(self, s: str, k: int) -> int:\\n    c = Counter()\\n    l = 0\\n    for r, ch in enumerate(s):\\n        c[ch] += 1\\n        if len(c) > 1 and r - l + 1 - max(c.values()) > k:\\n            c[s[l]] -= 1\\n            if c[s[l]] == 0:\\n                del c[s[l]]\\n            l += 1\\n    return len(s) - l\\n```\n```py\\ndef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n    c = Counter()\\n    l = 0\\n    for r, num in enumerate(nums):\\n        c[num] += 1\\n        if r - l + 1 - c[1] > 1:\\n            c[nums[l]] -= 1\\n            l += 1\\n    return len(nums) - l\\n```\n```py\\ndef longestOnes(self, nums: List[int], k: int) -> int:\\n    c = Counter()\\n    l = 0\\n    count_one = 0\\n    for r, num in enumerate(nums):\\n        c[num] += 1\\n        count_one = max(count_one, c[1])\\n        if r - l + 1 - count_one > k:\\n            c[nums[l]] -= 1\\n            l += 1\\n    return len(nums) - l\\n```\n```py\\ndef maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n    c = Counter()\\n    l = max_c = 0\\n    for r, ch in enumerate(answerKey):\\n        c[ch] += 1\\n        max_c = max(max_c, c[ch])\\n        if r - l + 1 > max_c + k:\\n            c[answerKey[l]] -= 1\\n            l += 1\\n    return len(answerKey) - l\\n```\n```py\\ndef longestSubarray(self, nums: List[int]) -> int:\\n    c = Counter()\\n    l = 0\\n    for r, num in enumerate(nums):\\n        c[num] += 1\\n        if r - l + 1 - c[1] > 1:\\n            c[nums[l]] -= 1\\n            l += 1\\n    return len(nums) - l - 1\\n```\n```py\\ndef lengthOfLongestSubstring(self, s: str) -> int:\\n    d = {}\\n    l = 0\\n    res = 0\\n    for r, ch in enumerate(s):\\n        if ch in d:\\n            l = max(l, d[ch] + 1)\\n        res = max(res, r - l + 1)\\n        d[ch] = r\\n    return res\\n```\n```py\\ndef maximumUniqueSubarray(self, nums: List[int]) -> int:\\n    nums = [0] + nums\\n    acc = list(accumulate(nums))\\n    res = 0\\n    c = {}\\n    l = 0\\n    for r, num in enumerate(nums):\\n        if num in c:\\n            l = max(l, c[num])\\n        res = max(res, acc[r] - acc[l])\\n        c[num] = r\\n    return res\\n```\n```py\\ndef numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\\n    if k == 0:\\n        return 0\\n    res = 0\\n    prod = 1\\n    l = 0\\n    for r, num in enumerate(nums):\\n        prod *= num\\n        while l < r and prod >= k:\\n            prod //= nums[l]\\n            l += 1\\n        if prod < k:\\n            res += r - l + 1\\n    return res\\n```\n```py\\ndef equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n    cost = l = 0\\n    res = 0\\n    for r, ch in enumerate(s):\\n        cost += abs(ord(ch) - ord(t[r]))\\n        while l < r and cost > maxCost:\\n            cost -= abs(ord(t[l]) - ord(s[l]))\\n            l += 1\\n        if cost <= maxCost:\\n            res = max(res, r - l + 1)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1177569,
                "title": "java-simple-sliding-window-clear-explanation",
                "content": "**Please Upvote if u find useful !!**\\nCredits - @keyvank1\\n\\nFirst understand that we have to distribute the value of k among arr ele.  so that max. no of ele becomes equal. if u understood this then move to further step.\\nsuppose we have ```a[] = {1,2,4,6,7,8}``` and let us take 2 pointers i and j representing respective index of the window \\nnow let i=1 and j=3  so the window is 2,4,6 .\\nif we make all the 3 ele. in win. equal noOfOper=6\\nAssume we now move the j pointer to next index j++ \\nso j=4. \\nnew window is 2,4,6,7 . so to make all the elements =7 \\nthe noOfOper = 6 + (len. of prev. window)* (a[j]-a[j-1]) = 9\\nthis is main thing . if you understand this then u understand the whole Problem.\\n\\nFor this problem, we can use two-pointer solution. However, we should sort the array first.\\n\\nSort the array.\\n* Initialize the left and right pointers to be at index 0.\\n* Define the sum variable to be the \"sum of the differences\"(i.e. \\u03A3(nums[right]-nums[i]) of the elements for i=left to right).\\n* Increment the left pointer in case the sum variable is greater than k. Update sum based on its definition.\\n* Increment the right pointer in case the sum variable is less thank. Update sum based on its definition.\\n* Output the mmax, which is the longest sequence that can be made by adding to its elements to have the same number as its nums[right], i.e. the \"Most Frequent Element\".\\n\\nCode:\\n```\\n public int maxFrequency(int[] a, int k) {\\n\\t\\tif(a.length==1) return 1;\\n        \\n        Arrays.sort(a);\\n\\t\\t int i=0,j=1;\\n\\t\\t int noOp=a[j]-a[i];\\n\\t\\t int mx_freq=1;\\n        \\n\\t   while(j<a.length && i<a.length) {\\n\\t\\t\\t while(noOp<=k && j<a.length-1) {\\n\\t\\t\\t\\t noOp=noOp + (j-i+1)*(a[j+1]-a[j]);\\n\\t\\t\\t\\t j++;\\n\\t\\t\\t\\tif(noOp<=k)\\n                 mx_freq=Math.max(mx_freq, j-i+1);\\n\\t\\t\\t }\\n\\t\\t\\tif(noOp<=k)\\n                 mx_freq=Math.max(mx_freq, j-i+1);\\n           \\n\\t\\t\\t noOp=noOp-(a[j]-a[i]);\\n\\t\\t\\t i++;\\n\\t\\t}\\n\\t\\treturn mx_freq;\\n\\t }\\n```\\n\\n**Time Complexity => O(n * logn), since we are sorting\\nSpace Complexity => O(1) (Constant Space)**\\n\\n**Please Upvote if u find useful !!**\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```a[] = {1,2,4,6,7,8}```\n```\\n public int maxFrequency(int[] a, int k) {\\n\\t\\tif(a.length==1) return 1;\\n        \\n        Arrays.sort(a);\\n\\t\\t int i=0,j=1;\\n\\t\\t int noOp=a[j]-a[i];\\n\\t\\t int mx_freq=1;\\n        \\n\\t   while(j<a.length && i<a.length) {\\n\\t\\t\\t while(noOp<=k && j<a.length-1) {\\n\\t\\t\\t\\t noOp=noOp + (j-i+1)*(a[j+1]-a[j]);\\n\\t\\t\\t\\t j++;\\n\\t\\t\\t\\tif(noOp<=k)\\n                 mx_freq=Math.max(mx_freq, j-i+1);\\n\\t\\t\\t }\\n\\t\\t\\tif(noOp<=k)\\n                 mx_freq=Math.max(mx_freq, j-i+1);\\n           \\n\\t\\t\\t noOp=noOp-(a[j]-a[i]);\\n\\t\\t\\t i++;\\n\\t\\t}\\n\\t\\treturn mx_freq;\\n\\t }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874325,
                "title": "c-explained",
                "content": "**APPROACH :**\\nThe question is basically asking from the current sliding window e.g. [1, 2,  4], how much do we need to convert it in [4, ,4 ,4], we would need ```4 ``` i.e. ```(nums[right])``` times the window length ```(right - left + 1)``` - ```the sum of the current window```. So ```nums[right]*(right-left+1) - total``` , if this is affordable with budget ```k``` ```(nums[right]*(right-left+1) - total <= k)``` then a frequency can be achieved with an amount equal to the window length. (e.g. 1 + 2 + 4 = 7, 4 + 4 + 4 = 12, we need 5 to convert it, which is within budget).\\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(begin(nums),end(nums));\\n        long long left=0,right=0;\\n        long long total=0,maxlen=0;\\n        while(right<n){\\n            total += nums[right];\\n            if(nums[right]*(right-left+1)-total <= k){\\n                maxlen = max(maxlen,right-left+1);\\n            }\\n            else{\\n                total -= nums[left];\\n                left++;\\n            }\\n            right++;\\n        }\\n        return maxlen;\\n    }\\n};\\n```\\n\\nThank You!",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```4 ```\n```(nums[right])```\n```(right - left + 1)```\n```the sum of the current window```\n```nums[right]*(right-left+1) - total```\n```k```\n```(nums[right]*(right-left+1) - total <= k)```\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(begin(nums),end(nums));\\n        long long left=0,right=0;\\n        long long total=0,maxlen=0;\\n        while(right<n){\\n            total += nums[right];\\n            if(nums[right]*(right-left+1)-total <= k){\\n                maxlen = max(maxlen,right-left+1);\\n            }\\n            else{\\n                total -= nums[left];\\n                left++;\\n            }\\n            right++;\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175053,
                "title": "java-binary-search-time-o-nlogn-space-o-1",
                "content": "\\tThe result should be in [1, n] so we can use binary search to find the answer\\n\\tAnd basically for each frequency, we want to find what is the number of operations\\n\\tso that the number with this frequency is nums[i]\\n\\tSince we can not decrease number, we need to look at the numbers that less not greater than this number\\n\\twe just need to look at last frequency - 1 number to see how many operations so that these numbers\\n\\tcan be changed to this number\\n\\n\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        //the range should be in [1, n]\\n        //so we can use binary search to find the answer\\n        //so basically for each frequency, we want to find what is the number of operations\\n        //so that the number with this frequency is nums[i]\\n        //since we can not decrease number, we need to look at the numbers that less not greater than \\n        //this number\\n        //we just need to look at last frequency - 1 number to see how many operations so that these numbers\\n        //can be changed to this number\\n        int n = nums.length;\\n        if (n == 1) return 1;\\n        Arrays.sort(nums);\\n        long preSum = 0;\\n        int left = 1, right = n;\\n        int res = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (isValid(mid, nums, k)) {\\n                res = mid;\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int len, int[] nums, int k) {\\n        long preSum = 0, total = 0;\\n        for (int i = 1; i < len; i++) {\\n            preSum += (long)(nums[i] - nums[i-1]);\\n            total += (long)i * (nums[i] - nums[i-1]);\\n        }\\n        if (total <= k) return true;\\n        int n = nums.length;\\n        for (int i = len; i < n; i++) {\\n            total += (long)(len-1) * (long)(nums[i] - nums[i-1]);\\n            total -= preSum;\\n            preSum += (long)(nums[i] - nums[i-1]);\\n            preSum -= (long)(nums[i-len+1] - nums[i-len]);\\n            if (total <= k) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        //the range should be in [1, n]\\n        //so we can use binary search to find the answer\\n        //so basically for each frequency, we want to find what is the number of operations\\n        //so that the number with this frequency is nums[i]\\n        //since we can not decrease number, we need to look at the numbers that less not greater than \\n        //this number\\n        //we just need to look at last frequency - 1 number to see how many operations so that these numbers\\n        //can be changed to this number\\n        int n = nums.length;\\n        if (n == 1) return 1;\\n        Arrays.sort(nums);\\n        long preSum = 0;\\n        int left = 1, right = n;\\n        int res = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (isValid(mid, nums, k)) {\\n                res = mid;\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int len, int[] nums, int k) {\\n        long preSum = 0, total = 0;\\n        for (int i = 1; i < len; i++) {\\n            preSum += (long)(nums[i] - nums[i-1]);\\n            total += (long)i * (nums[i] - nums[i-1]);\\n        }\\n        if (total <= k) return true;\\n        int n = nums.length;\\n        for (int i = len; i < n; i++) {\\n            total += (long)(len-1) * (long)(nums[i] - nums[i-1]);\\n            total -= preSum;\\n            preSum += (long)(nums[i] - nums[i-1]);\\n            preSum -= (long)(nums[i-len+1] - nums[i-len]);\\n            if (total <= k) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175037,
                "title": "python3-binary-search",
                "content": "\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = 0 \\n        for i in reversed(range(len(nums))): \\n            lo, hi = 0, i\\n            while lo < hi: \\n                mid = lo + hi >> 1\\n                if nums[i] * (i - mid) + prefix[mid] - prefix[i] <= k: hi = mid\\n                else: lo = mid + 1\\n            ans = max(ans, i - lo + 1)\\n        return ans \\n```\\n\\nAdding sliding window approach \\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = ii = sm = 0 \\n        for i in range(len(nums)): \\n            sm += nums[i]\\n            while k < nums[i]*(i-ii+1) - sm: \\n                sm -= nums[ii]\\n                ii += 1\\n            ans = max(ans, i - ii + 1)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = 0 \\n        for i in reversed(range(len(nums))): \\n            lo, hi = 0, i\\n            while lo < hi: \\n                mid = lo + hi >> 1\\n                if nums[i] * (i - mid) + prefix[mid] - prefix[i] <= k: hi = mid\\n                else: lo = mid + 1\\n            ans = max(ans, i - lo + 1)\\n        return ans \\n```\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = ii = sm = 0 \\n        for i in range(len(nums)): \\n            sm += nums[i]\\n            while k < nums[i]*(i-ii+1) - sm: \\n                sm -= nums[ii]\\n                ii += 1\\n            ans = max(ans, i - ii + 1)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919087,
                "title": "why-j-i-1-a-j-sum-k-sliding-window-explained-c",
                "content": "```Why Sort ??```\\n\\nSince we are limited with the number of increments we can perform, that is K\\nlet us say the array is 3 4 5 2 1 6\\nand we want to create maximum number of 4 which we can create\\nIt is very obvious to do so we need to increment values which are smaller than 4, and those values will be lying on the left side of the array, so we will check left side only, we won\\'t be looking on the right side. This is why we sort the array.\\n 3 4 5 2 1 6 ---> 1 2 3 4 5 6\\n \\n```Why (j - i + 1) * A[j] - sum <= K  is valid ??```\\n![image](https://assets.leetcode.com/users/images/8edc0217-35ea-481a-b291-4378529361be_1692206642.805012.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int left = 0, maxFreq = 0;\\n        long long sum = 0;\\n        \\n        for(int right = 0; right < nums.size(); right++){\\n            sum += nums[right];\\n            \\n            while(1LL*(right - left + 1)*nums[right] - sum > k){\\n                sum -= nums[left];\\n                left++;\\n            }\\n            \\n            maxFreq = max(maxFreq, right - left + 1);\\n        }\\n        \\n        return maxFreq;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```Why Sort ??```\n```Why (j - i + 1) * A[j] - sum <= K  is valid ??```",
                "codeTag": "Unknown"
            },
            {
                "id": 2596103,
                "title": "most-simple-sliding-window-binary-search-detailed-explanation",
                "content": "**Logic**:\\n\\nNumber of operations needed for all elements in the window [startIndex, endIndex] to hit A[endIndex]\\n\\n```     Example:\\n     Consider arr with [1, 2, 3, 4] with startIndex = 0; endIndex = 3: i.e If 1, 2, 3 wants to become 4.\\n     Number of operations needed\\n     = (4-1)+(4-2)+(4-3)+(4-4) = 6.\\n     =  4 + 4 + 4 + 4 - (1 + 2 + 3+ 4)\\n     = 4 * 4 - (1 + 2 + 3 + 4)\\n     = (number of elements) * rightMostElement - sum of elements in the window\\n\\n```\\n\\nWe have sorted because to maximize the frequency, numbers closest to x should be incremented as they require less additions to reach the value x. Basically, at each step, we are trying to make all the elements from A[i] to A[j] equal to A[j]. If the sum of all elements from A[i] to A[j] plus the value of k is enough to do so then the window is valid. Otherwise, the value of i needs to be incremented as at the very beginning we are sorting the input, so the difference of values of A[i] and A[j] is maximum, so A[i] takes the maximum part of k to become equal to A[j], that\\'s why it needs to be removed from current window.\\n\\nonce you reach a valid window size of a certain length you are not interested into checking smaller valid window sizes as those can\\'t improve the best solution and if there exists a longer window size that happens later the invariants will hold and the algorithm will find it. \\n```\\npublic int maxFrequency(int[] nums, int k) {\\n        int res = 1, i = 0, j;\\n        long sum = 0;\\n        Arrays.sort(nums);\\n        for (j = 0; j < nums.length; ++j) {\\n            sumOfElementsInWindow += nums[j];\\n            while (nums[j] * (j - i + 1) - sum > k) { // check for a valid window \\n                sumOfElementsInWindow -= nums[i]; // not a valid window, removing nums[i] from the window\\n                i += 1;\\n            }\\n            res = Math.max(res, j - i + 1); // the window size only increase when it\\'s valid, it doesn\\'t decrease when invalid, because we only care about max valid window size.\\n\\n\\n        }\\n        return res;\\n    }\\n```\\n\\nComplexity -\\n\\nTime O(sort)\\nSpace O(sort)\\n\\nBinary Search\\n\\n1. Sort the array.\\n2. Maintain a prefix sum array to find the window sum.\\n3. Find the maximum window for each element.\\n4. Return the overall max of all windows.\\n\\n```\\nclass Solution {\\n    long[] preSum;\\n    public int maxFrequency(int[] nums, int k) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        preSum = new long[n+1];\\n        for (int i = 0; i < n; i++)\\n            preSum[i + 1] = preSum[i] + nums[i];\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n            ans = Math.max(ans, count(nums, k, i)); //checking each element for largest window\\n        return ans;\\n    }\\n    long getSum(int left, int right) {  // left, right inclusive\\n        return preSum[right + 1] - preSum[left];\\n    }\\n    // Count frequency of `nums[index]` if we make other elements equal to `nums[index]`\\n    int count(int[] nums, int k, int index) {\\n        int left = 0, right = index, res = index;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            long s = getSum(mid, index - 1); // get sum of(nums[mid], nums[mid + 1]...nums[index - 1])\\n            if (s + k >= (long)(index - mid) * nums[index]) { // Found an answer -> Try to find a better answer in the left side\\n                res = mid; // save best answer so far\\n                right = mid - 1; // increasing the window size\\n            } else {\\n                left = mid + 1; // decreasing the window size  \\n            }\\n        }\\n        return index - res + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```     Example:\\n     Consider arr with [1, 2, 3, 4] with startIndex = 0; endIndex = 3: i.e If 1, 2, 3 wants to become 4.\\n     Number of operations needed\\n     = (4-1)+(4-2)+(4-3)+(4-4) = 6.\\n     =  4 + 4 + 4 + 4 - (1 + 2 + 3+ 4)\\n     = 4 * 4 - (1 + 2 + 3 + 4)\\n     = (number of elements) * rightMostElement - sum of elements in the window\\n\\n```\n```\\npublic int maxFrequency(int[] nums, int k) {\\n        int res = 1, i = 0, j;\\n        long sum = 0;\\n        Arrays.sort(nums);\\n        for (j = 0; j < nums.length; ++j) {\\n            sumOfElementsInWindow += nums[j];\\n            while (nums[j] * (j - i + 1) - sum > k) { // check for a valid window \\n                sumOfElementsInWindow -= nums[i]; // not a valid window, removing nums[i] from the window\\n                i += 1;\\n            }\\n            res = Math.max(res, j - i + 1); // the window size only increase when it\\'s valid, it doesn\\'t decrease when invalid, because we only care about max valid window size.\\n\\n\\n        }\\n        return res;\\n    }\\n```\n```\\nclass Solution {\\n    long[] preSum;\\n    public int maxFrequency(int[] nums, int k) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        preSum = new long[n+1];\\n        for (int i = 0; i < n; i++)\\n            preSum[i + 1] = preSum[i] + nums[i];\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n            ans = Math.max(ans, count(nums, k, i)); //checking each element for largest window\\n        return ans;\\n    }\\n    long getSum(int left, int right) {  // left, right inclusive\\n        return preSum[right + 1] - preSum[left];\\n    }\\n    // Count frequency of `nums[index]` if we make other elements equal to `nums[index]`\\n    int count(int[] nums, int k, int index) {\\n        int left = 0, right = index, res = index;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            long s = getSum(mid, index - 1); // get sum of(nums[mid], nums[mid + 1]...nums[index - 1])\\n            if (s + k >= (long)(index - mid) * nums[index]) { // Found an answer -> Try to find a better answer in the left side\\n                res = mid; // save best answer so far\\n                right = mid - 1; // increasing the window size\\n            } else {\\n                left = mid + 1; // decreasing the window size  \\n            }\\n        }\\n        return index - res + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175029,
                "title": "python-3-min-heap-with-picture-explanation",
                "content": "**Min heap is not necessary**, since we have already sort the array, thus using binary search or two pointers will do, thanks to @giri1gb for letting me know. \\nPlease refer to solutions posted by others, but I hope the picture can help you more or less.\\n\\n![image](https://assets.leetcode.com/users/images/4a262308-6d64-49cf-86c5-91bffa0b8639_1619323935.6220663.png)\\n\\nCalculate how many moves we need, in order to make every number in the heap having the same value as the maximum number.\\n\\nEvery time we add a new number N in the heap, we have to make moves on every number in the heap to let it be N. If our current k cant suppose these moves, meaning we have to discard the smallest number, because discarding the smallest number will \\'release\\' maximum number of moves.\\n\\nTake the picture as an example, suppose we have [1, 1], if we add 3 in the heap, we want to make as many 3 as we can, so we just try making every number equal to 3 firstly, it will take 4 moves to make [1, 1, 3] turn into [3, 3, 3], however we only have 3 moves up to most, meaning we have to reduce the numbers to be changed, so keep popping the smallest number from the heap, until k >= 0.\\n\\n```\\ndef maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        cnt, ans, pre, hp = 1, 1, nums[0], [nums[0]]\\n        for num in nums[1:]:\\n            heapq.heappush(hp, num)\\n            k -= cnt * (num - pre)\\n            cnt += 1\\n            pre = num\\n            while k < 0:\\n                cur = heapq.heappop(hp)\\n                k += pre - cur\\n                cnt -= 1\\n            ans = max(ans, cnt)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        cnt, ans, pre, hp = 1, 1, nums[0], [nums[0]]\\n        for num in nums[1:]:\\n            heapq.heappush(hp, num)\\n            k -= cnt * (num - pre)\\n            cnt += 1\\n            pre = num\\n            while k < 0:\\n                cur = heapq.heappop(hp)\\n                k += pre - cur\\n                cnt -= 1\\n            ans = max(ans, cnt)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3010305,
                "title": "with-some-explanation-and-a-tip",
                "content": "# Intuition\\nWe can code a linear timr complexity solution for any particular size, we also know the range in which in ans might fall, therefore we use binary seach for seaching the max ans \\n\\n# Complexity\\n- Time complexity:\\nO(Nlog(N))\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPos(vector<int>& a, int l, int k){\\n        long long sum = 0;\\n        for(int i=0;i<a.size();i++){\\n            sum+=a[i];\\n            if(i >= l-1){\\n                if(k >= (long long)a[i]*l - sum) return true;\\n                sum-=a[i-l+1];\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int l = 1, h = nums.size(), mid;\\n        int ans = 1;\\n        while(l <= h){\\n            mid = l + (h-l)/2;\\n            if(isPos(nums, mid, k)){\\n                ans = max(ans, mid);\\n                l = mid + 1;\\n            } else {\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<h2><b>Tip:</b> I have came accross many such problems like this where I can think of O(N^2) solution,  some of them might be optimized to O(Nlog(N)) just by applying binary seach in place of one for loop (not always a for loop)</h2>\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPos(vector<int>& a, int l, int k){\\n        long long sum = 0;\\n        for(int i=0;i<a.size();i++){\\n            sum+=a[i];\\n            if(i >= l-1){\\n                if(k >= (long long)a[i]*l - sum) return true;\\n                sum-=a[i-l+1];\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int l = 1, h = nums.size(), mid;\\n        int ans = 1;\\n        while(l <= h){\\n            mid = l + (h-l)/2;\\n            if(isPos(nums, mid, k)){\\n                ans = max(ans, mid);\\n                l = mid + 1;\\n            } else {\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942906,
                "title": "c-sliding-window-easy-100",
                "content": "Best we can do is O(nlogn), and the position of element does not matter therefore we can sort the array. Then we will use sliding window technique by using two pointers and we will store the maximum length of valid windows. Rest is explained in the code.\\n\\n```\\n\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        // sorting so that can easily find the optimal window\\n        sort(nums.begin(), nums.end());\\n        \\n        // left - left pointer of window\\n        // right - right pointer of window\\n        int left = 0, right = 0, ans = 1;\\n        ll total = 0, n = nums.size();\\n        while(right < n){\\n            // total - total sum of elements in the window\\n            total += nums[right];\\n            \\n            // Checking if the we can achieve elements in this window\\n            // If it exceeds k then shrinking the window by moving left pointer\\n            // For optimal we will make all elements in the array equal to\\n            // the maximum value element\\n            while((1ll)*(right - left + 1)*nums[right] - total > k){\\n                total -= nums[left];\\n                left++;\\n            }\\n            \\n            ans = max(ans, right - left + 1);\\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\nUpvote if you found my solution helpful :-)",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        // sorting so that can easily find the optimal window\\n        sort(nums.begin(), nums.end());\\n        \\n        // left - left pointer of window\\n        // right - right pointer of window\\n        int left = 0, right = 0, ans = 1;\\n        ll total = 0, n = nums.size();\\n        while(right < n){\\n            // total - total sum of elements in the window\\n            total += nums[right];\\n            \\n            // Checking if the we can achieve elements in this window\\n            // If it exceeds k then shrinking the window by moving left pointer\\n            // For optimal we will make all elements in the array equal to\\n            // the maximum value element\\n            while((1ll)*(right - left + 1)*nums[right] - total > k){\\n                total -= nums[left];\\n                left++;\\n            }\\n            \\n            ans = max(ans, right - left + 1);\\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454840,
                "title": "simple-python-o-nlogn-sort-sliding-window-solution",
                "content": "Intuitions:\\n1. We need sorting becuase we can increment numbers smaller than the current number to increase the frequency of the current number. Furthermore, we prefer to increment larger numbers among numbers that are smaller than the current number since they don\\'t need many incrementations to reach the current number.\\n2. We maintain the invariant that k is always enough to change all elements between left and right inclusively to nums[right]. We can check this using nums[right]* window_size - window_sum > k. If this doesn\\'t hold, we shrink the sliding window by incrementing the left pointer.\\n```Python\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        left = right = ret = 0\\n        window_sum = 0\\n        while right < len(nums):\\n            # maintain the invariant that k is enough to\\n            # change all elements between left and right\\n            # inclusively to nums[right]\\n            window_sum += nums[right]\\n            while nums[right]*(right-left+1)-window_sum > k:\\n                window_sum -= nums[left]\\n                left += 1\\n            ret = max(ret, right-left+1)\\n            right += 1\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```Python\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        left = right = ret = 0\\n        window_sum = 0\\n        while right < len(nums):\\n            # maintain the invariant that k is enough to\\n            # change all elements between left and right\\n            # inclusively to nums[right]\\n            window_sum += nums[right]\\n            while nums[right]*(right-left+1)-window_sum > k:\\n                window_sum -= nums[left]\\n                left += 1\\n            ret = max(ret, right-left+1)\\n            right += 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176219,
                "title": "c-sliding-window-examples-of-the-same-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        long res = 0, sum = 0, j = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            while (j < i && sum + k < nums[i] * (i - j + 1)) {\\n                sum -= nums[j++];\\n            }\\n            res = max(res, i - j + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nHere is example of one probleme that can be solved with almost the same approach:\\nhttps://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int i = 0, j = 0;\\n        int res = 0;\\n        int cnt = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            cnt += nums[i] == 0;\\n            while (cnt > 1) {\\n                cnt -= nums[j++] == 0;\\n            }\\n            res = max(res, i - j);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\n\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int i = 0, j = 0;\\n        int res = INT_MAX;\\n        for (i = 0; i < nums.size(); i++) {\\n            target -= nums[i];\\n            while (target <= 0) {\\n                res = min(res, i - j + 1);\\n                target += nums[j++];\\n            }\\n        }\\n        return res == INT_MAX ? 0 : res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        long res = 0, sum = 0, j = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            while (j < i && sum + k < nums[i] * (i - j + 1)) {\\n                sum -= nums[j++];\\n            }\\n            res = max(res, i - j + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int i = 0, j = 0;\\n        int res = 0;\\n        int cnt = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            cnt += nums[i] == 0;\\n            while (cnt > 1) {\\n                cnt -= nums[j++] == 0;\\n            }\\n            res = max(res, i - j);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int i = 0, j = 0;\\n        int res = INT_MAX;\\n        for (i = 0; i < nums.size(); i++) {\\n            target -= nums[i];\\n            while (target <= 0) {\\n                res = min(res, i - j + 1);\\n                target += nums[j++];\\n            }\\n        }\\n        return res == INT_MAX ? 0 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510222,
                "title": "java-sliding-window-solution-with-easy-explanation",
                "content": "**Sliding Window Solution for Frequency of Most Frequent Element**\\n\\nAs per the problem statement, we need to increament the values in the array so as to make it equal to some element in the array by K times and then return the frequency of the element with the maximum frequency.\\n\\nSo, the first thing that we can notice here is that we can only increament the value by k times and not allowed to decreament it. This gives us the intuition that we might not want to increament the elements greater than the element which we are trying to make equal to. For example : If in the array we intend to make other elements equal to 4 as per allowed k additions so it is obvious that we would not be performing the operations on elements greater than 4.\\n\\nSo, we can sort the given array to reach the optimum solution. Now, sorting the array would take O(logn) as the time complexity.\\n\\nNow, we need to figure out a valid window which will give us the maximum frequency. For this, we will maintain two pointers- left pointer and right pointer , initially pointing to first element of the array.\\n\\nThe main solution of the problem lies in the condition in which we will iterate a while loop till  `nums[right]*windowLength > Total + k`\\n\\nLets consider an example array - nums [1,1,1,2,2,4] and k =2. For understanding the intuition behind the above condition, lets suppose the right pointer is at 3rd position  (0-indexing). So, we need to make all the elements prior to this index equal to nums[right] which is 2.\\n\\nIf all the elements in the selected window are equal to 2, then their total sum  is equal to 8. Now, their actual sum is 5 and after increamenting it with allowed k , 5+2 = 7. So, logically it is incorrect and hence it is not a valid window, so we increament the left pointer in this scenario and update the window.\\n\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int maxFrequency = 0;\\n        int leftPointer = 0, rightPointer = 0;\\n        long total = 0;\\n        while(rightPointer < nums.length){\\n            total += nums[rightPointer];\\n             while((long)nums[rightPointer]*(rightPointer - leftPointer + 1) > (total + k)){\\n                 total -= nums[leftPointer];\\n                 leftPointer++;\\n             }\\n            //now we have a valid window\\n            maxFrequency = Math.max(maxFrequency, (rightPointer - leftPointer + 1));\\n            rightPointer++;\\n        }\\n        return maxFrequency;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int maxFrequency = 0;\\n        int leftPointer = 0, rightPointer = 0;\\n        long total = 0;\\n        while(rightPointer < nums.length){\\n            total += nums[rightPointer];\\n             while((long)nums[rightPointer]*(rightPointer - leftPointer + 1) > (total + k)){\\n                 total -= nums[leftPointer];\\n                 leftPointer++;\\n             }\\n            //now we have a valid window\\n            maxFrequency = Math.max(maxFrequency, (rightPointer - leftPointer + 1));\\n            rightPointer++;\\n        }\\n        return maxFrequency;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373481,
                "title": "java-easy-explanation-with-example",
                "content": "Consider this example nums[] = [1,1,1,2,2,4] and k=2\\nIntially left and right pointer are at index 0, i.e at nums[0], and windowLen is 1\\nWe want every value in the window to be nums[0] i.e equal to 1\\nTotalSum = 1 , this variable is going to keep track of sum of elements in our window\\n```expand while(nums[R] * windowLen <= totalSum + k)```\\n**This means that, we are trying to make every elment in window equal to nums[R], if we could make this, then sum of window elements will be nums[R] times widowLen (Basic Math)**\\nand we will check whether this sum is possible in totalSum+k operations.\\nIf possible then expand the window further else just shrink the window by removing the nums[L]\\n```\\n        \\n            TotalSum = 1     [1,1,1,2,2,4]    windowLen = 1    (1*1<=1+2) - expand window\\n                              LR\\n\\t\\t\\tTotalSum = 2      [1,1,1,2,2,4]    windowLen = 2   (1*2<=2+2) - expand window\\n                               L R\\n\\t\\t\\tTotalSum = 3      [1,1,1,2,2,4]    windowLen = 3   (1*3<=3+2) - expand window\\n                               L   R\\n\\t\\t\\tTotalSum = 5      [1,1,1,2,2,4]    windowLen = 4   (2*4<=5+2) - shrink window\\n                               L     R\\n\\t\\t\\tTotalSum = 4      [1,1,1,2,2,4]    windowLen = 3   (2*3<=4+2) - expand window\\n                                 L   R\\n\\t\\t    TotalSum = 6     [1,1,1,2,2,4]     windowLen = 4    (2*4<=6+2) - expand window\\n                                L     R\\n\\t\\t\\tTotalSum = 10     [1,1,1,2,2,4]     windowLen = 5   (4*5<=10+2) - shrink window\\n                                 L       R\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t \\nNow in all the next iteration, the window will keep getting smaller beacuse the condition is going to be false everytime.\\n```\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        \\n       Arrays.sort(nums);\\n       int L = 0;\\n       int R = 0;\\n       long totalSum = 0;\\n       int ans = 0;\\n        \\n        for(R = 0; R < nums.length; R++){\\n            totalSum += nums[R];\\n            while(nums[R] * (R-L+1) > totalSum + k){\\n                //sum can\\'t be achieved in K moves, hence shrink the window\\n                totalSum -= nums[L];\\n                L++;\\n             }\\n            //expand the window\\n            ans = Math.max(ans,R-L+1);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```expand while(nums[R] * windowLen <= totalSum + k)```\n```\\n        \\n            TotalSum = 1     [1,1,1,2,2,4]    windowLen = 1    (1*1<=1+2) - expand window\\n                              LR\\n\\t\\t\\tTotalSum = 2      [1,1,1,2,2,4]    windowLen = 2   (1*2<=2+2) - expand window\\n                               L R\\n\\t\\t\\tTotalSum = 3      [1,1,1,2,2,4]    windowLen = 3   (1*3<=3+2) - expand window\\n                               L   R\\n\\t\\t\\tTotalSum = 5      [1,1,1,2,2,4]    windowLen = 4   (2*4<=5+2) - shrink window\\n                               L     R\\n\\t\\t\\tTotalSum = 4      [1,1,1,2,2,4]    windowLen = 3   (2*3<=4+2) - expand window\\n                                 L   R\\n\\t\\t    TotalSum = 6     [1,1,1,2,2,4]     windowLen = 4    (2*4<=6+2) - expand window\\n                                L     R\\n\\t\\t\\tTotalSum = 10     [1,1,1,2,2,4]     windowLen = 5   (4*5<=10+2) - shrink window\\n                                 L       R\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t \\nNow in all the next iteration, the window will keep getting smaller beacuse the condition is going to be false everytime.\\n```\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        \\n       Arrays.sort(nums);\\n       int L = 0;\\n       int R = 0;\\n       long totalSum = 0;\\n       int ans = 0;\\n        \\n        for(R = 0; R < nums.length; R++){\\n            totalSum += nums[R];\\n            while(nums[R] * (R-L+1) > totalSum + k){\\n                //sum can\\'t be achieved in K moves, hence shrink the window\\n                totalSum -= nums[L];\\n                L++;\\n             }\\n            //expand the window\\n            ans = Math.max(ans,R-L+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061308,
                "title": "c-solution-with-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n\\n        int n = nums.size(), ans = 0, i, j = -1;\\n\\n        for (i = 0; i < n; i++)\\n        {\\n            j = max(j, i);\\n\\n            while (j < n && (nums[i] - nums[j]) <= k)\\n            {\\n                k -= (nums[i] - nums[j]);\\n                j++;\\n            }\\n            \\n            ans = max(ans, j - i);\\n            if (j >= n)\\n                break;\\n            \\n            if (j > i && i + 1 != n)\\n            {\\n                k += (j - i - 1) * (nums[i] - nums[i + 1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n\\n        int n = nums.size(), ans = 0, i, j = -1;\\n\\n        for (i = 0; i < n; i++)\\n        {\\n            j = max(j, i);\\n\\n            while (j < n && (nums[i] - nums[j]) <= k)\\n            {\\n                k -= (nums[i] - nums[j]);\\n                j++;\\n            }\\n            \\n            ans = max(ans, j - i);\\n            if (j >= n)\\n                break;\\n            \\n            if (j > i && i + 1 != n)\\n            {\\n                k += (j - i - 1) * (nums[i] - nums[i + 1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175039,
                "title": "c-sort-two-pointers",
                "content": "For this problem, we can use two-pointer solution. However, we should sort the array first.\\n1) Sort the array.\\n2) Initialize the ```left``` and ```right``` pointers to be at index 0.\\n3) Define the ```sum``` variable to be the \"sum of the differences\"(i.e. ```\\u03A3(nums[right]-nums[i])``` of the elements for i=```left``` to ```right```).\\n4) Increment the ```left``` pointer in case the ```sum``` variable is greater than ```k```. Update ```sum``` based on its definition.\\n5) Increment the ```right``` pointer in case the ```sum``` variable is less than``` k```. Update ```sum``` based on its definition.\\n6) Output the ```mmax```, which is the longest sequence that can be made by adding to its elements to have the same number as its ```nums[right]```, i.e. the \"Most Frequent Element\".\\n\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int left = 0;\\n        int right = 0;\\n        long sum = 0;\\n        int mmax = 0;\\n        while(right<nums.size()){\\n            if (sum > k){\\n                sum -= nums[right] - nums[left];\\n                left++;\\n                continue;\\n            }\\n            if (sum <= k){\\n                mmax = max(right-left+1,mmax);\\n                right++;\\n                if (right<nums.size()){\\n                    sum += (long)(right-left)*(nums[right]-nums[right-1]);\\n                }\\n            }\\n        }\\n        return mmax;\\n    }\\n};",
                "solutionTags": [],
                "code": "```left```\n```right```\n```sum```\n```\\u03A3(nums[right]-nums[i])```\n```left```\n```right```\n```left```\n```sum```\n```k```\n```sum```\n```right```\n```sum```\n``` k```\n```sum```\n```mmax```\n```nums[right]```",
                "codeTag": "Unknown"
            },
            {
                "id": 2914726,
                "title": "c-solution-sliding-window-beats-97",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Cpp Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, long k) {\\n        sort(nums.begin(), nums.end());\\n        const int n = nums.size();\\n        int j = 0;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            k += nums[i];\\n\\n            while(k < (long) nums[i] * (i - j + 1)) {\\n                k -= nums[j];\\n                j++;\\n            }\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, long k) {\\n        sort(nums.begin(), nums.end());\\n        const int n = nums.size();\\n        int j = 0;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            k += nums[i];\\n\\n            while(k < (long) nums[i] * (i - j + 1)) {\\n                k -= nums[j];\\n                j++;\\n            }\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673746,
                "title": "binary-search-easy-sol-mid-value-check-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&nums,int mid, int k)\\n    {\\n        int n=nums.size();\\n        long long sum=0; \\n        long long window_sum=0;\\n        for(int i=0;i<mid;i++)\\n        {\\n            window_sum+=nums[i];\\n        }\\n        sum=mid*(long)nums[mid-1];\\n        if(sum-window_sum<=k)\\n            return true;\\n        int j=0;\\n        for(int i=mid;i<n;i++)\\n        {\\n            window_sum-=nums[j];\\n            window_sum+=nums[i];\\n            sum=mid*(long)nums[i];\\n            if(sum-window_sum<=k)\\n                return true;\\n            j++;\\n        }\\n        return false;\\n    }\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int s=1;\\n        int e=n;\\n        int ans=1;\\n        int mid=s+(e-s)/2;\\n        while(s<=e)\\n        {\\n            if(isValid(nums,mid,k))\\n               {\\n                   ans=mid;\\n                   s=mid+1;\\n               }\\n            else\\n                e=mid-1;\\n            \\n            mid=s+(e-s)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&nums,int mid, int k)\\n    {\\n        int n=nums.size();\\n        long long sum=0; \\n        long long window_sum=0;\\n        for(int i=0;i<mid;i++)\\n        {\\n            window_sum+=nums[i];\\n        }\\n        sum=mid*(long)nums[mid-1];\\n        if(sum-window_sum<=k)\\n            return true;\\n        int j=0;\\n        for(int i=mid;i<n;i++)\\n        {\\n            window_sum-=nums[j];\\n            window_sum+=nums[i];\\n            sum=mid*(long)nums[i];\\n            if(sum-window_sum<=k)\\n                return true;\\n            j++;\\n        }\\n        return false;\\n    }\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int s=1;\\n        int e=n;\\n        int ans=1;\\n        int mid=s+(e-s)/2;\\n        while(s<=e)\\n        {\\n            if(isValid(nums,mid,k))\\n               {\\n                   ans=mid;\\n                   s=mid+1;\\n               }\\n            else\\n                e=mid-1;\\n            \\n            mid=s+(e-s)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610842,
                "title": "7-lines-of-code-java-sliding-window",
                "content": "Hi Coder,\\n\\n```\\n\\tpublic int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int R = 0, L = 0, sum = 0, max_val = 0;\\n        for (R=0;R<nums.length;R++){\\n            sum += nums[R];\\n            while (nums[R] * (R - L + 1) - sum > k){ sum -= nums[L++];}\\n            max_val = Math.max(max_val,R-L+1);\\n        }\\n        return max_val;\\n    }\\n```\\n\\nThanks!!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int R = 0, L = 0, sum = 0, max_val = 0;\\n        for (R=0;R<nums.length;R++){\\n            sum += nums[R];\\n            while (nums[R] * (R - L + 1) - sum > k){ sum -= nums[L++];}\\n            max_val = Math.max(max_val,R-L+1);\\n        }\\n        return max_val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528063,
                "title": "c-easy-solution-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n\\t\\tlong long ans = 1;\\n\\t\\tlong long i = 0, sum = 0;\\n\\t\\tfor (int j = 0; j < nums.size(); ++j) {\\n\\t\\t\\tsum += nums[j];\\n\\t\\t\\twhile ((j - i + 1) * nums[j] - sum > k) sum -= nums[i++];\\n\\t\\t\\tans = max(ans, j - i + 1);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n\\t\\tlong long ans = 1;\\n\\t\\tlong long i = 0, sum = 0;\\n\\t\\tfor (int j = 0; j < nums.size(); ++j) {\\n\\t\\t\\tsum += nums[j];\\n\\t\\t\\twhile ((j - i + 1) * nums[j] - sum > k) sum -= nums[i++];\\n\\t\\t\\tans = max(ans, j - i + 1);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474923,
                "title": "java-solution-sliding-window-with-explanation-source",
                "content": "#### Kindly Upvote :D\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = 0, r = 0, res = 0;\\n        long total = 0;\\n\\n        while (r < nums.length) {\\n            total += nums[r];\\n\\n            while ((long) nums[r] * (r - l + 1) > total + k) {\\n                total -= nums[l];\\n                l++;\\n            }\\n\\n            res = Math.max(res, r - l + 1);\\n            r++;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n// TC: O(nlogn) + O(n), SC: O(1)\\n```\\n[Link to explanation video](https://www.youtube.com/watch?v=vgBrQ0NM5vE)",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = 0, r = 0, res = 0;\\n        long total = 0;\\n\\n        while (r < nums.length) {\\n            total += nums[r];\\n\\n            while ((long) nums[r] * (r - l + 1) > total + k) {\\n                total -= nums[l];\\n                l++;\\n            }\\n\\n            res = Math.max(res, r - l + 1);\\n            r++;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n// TC: O(nlogn) + O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336027,
                "title": "c-slinding-window-and-binary-search-simple-and-easy",
                "content": "We do binary search on length.\\nSort given array and fix one element as our max frequent element and then for a particular length we try to make all elements to the left of our fixed element equal to it.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    bool valid(int len,vector<int>&nums,int k){\\n        int n = nums.size();\\n        vector<long long>pref(n + 1,0);\\n        \\n        \\n        for(int i = 0;i<n;i++){\\n            pref[i + 1] = pref[i] + nums[i];\\n        }\\n        \\n        \\n        //fix one element and then make all len - 1 elements to its left equal to it\\n        //example \\n        //1 2 3 4 5 \\n        // suppose we are at last index\\n        \\n        // we want to make it 5 5 5 5 5\\n        \\n        \\n        // we will do (5 - 5) + (5 - 4) + (5 - 3) + (5 - 2) + (5 - 1)\\n        \\n        //i.e. prefix sum of that window minus the length*cur_element;\\n        long long min_req = 1e10 + 1;\\n        for(int i = len - 1;i<n;i++){\\n            min_req = min(min_req,(long long)(len)*nums[i] - (pref[i + 1] - pref[i + 1 - len]) );\\n        }\\n        \\n        return min_req <= k;\\n    }\\n    \\n    \\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int low = 1,high = nums.size();\\n        int ans = 0;\\n        \\n        //binary search on answer\\n        while(low<=high){\\n            int mid = (low + high) / 2;\\n            \\n            if(valid(mid,nums,k)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    bool valid(int len,vector<int>&nums,int k){\\n        int n = nums.size();\\n        vector<long long>pref(n + 1,0);\\n        \\n        \\n        for(int i = 0;i<n;i++){\\n            pref[i + 1] = pref[i] + nums[i];\\n        }\\n        \\n        \\n        //fix one element and then make all len - 1 elements to its left equal to it\\n        //example \\n        //1 2 3 4 5 \\n        // suppose we are at last index\\n        \\n        // we want to make it 5 5 5 5 5\\n        \\n        \\n        // we will do (5 - 5) + (5 - 4) + (5 - 3) + (5 - 2) + (5 - 1)\\n        \\n        //i.e. prefix sum of that window minus the length*cur_element;\\n        long long min_req = 1e10 + 1;\\n        for(int i = len - 1;i<n;i++){\\n            min_req = min(min_req,(long long)(len)*nums[i] - (pref[i + 1] - pref[i + 1 - len]) );\\n        }\\n        \\n        return min_req <= k;\\n    }\\n    \\n    \\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int low = 1,high = nums.size();\\n        int ans = 0;\\n        \\n        //binary search on answer\\n        while(low<=high){\\n            int mid = (low + high) / 2;\\n            \\n            if(valid(mid,nums,k)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280813,
                "title": "how-does-one-come-up-with-the-sliding-window-relation-nums-r-r-l-1-sum-nums-l-r-1-k",
                "content": "When I looked up the solution to this problem, I saw that everybody was using the sliding window solution and the relation `nums[r]*(r-l+1)<=sum(nums[l:r+1])+k `to keep decide whether to move the right pointer or the left pointer. \\nUpon looking at the relation, it made sense, but how would one come up with this in an interview setting? Are there any other questions that work along these lines?",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "When I looked up the solution to this problem, I saw that everybody was using the sliding window solution and the relation `nums[r]*(r-l+1)<=sum(nums[l:r+1])+k `to keep decide whether to move the right pointer or the left pointer. \\nUpon looking at the relation, it made sense, but how would one come up with this in an interview setting? Are there any other questions that work along these lines?",
                "codeTag": "Unknown"
            },
            {
                "id": 1881875,
                "title": "java-sliding-window-easy-understanding-approach",
                "content": "/*\\nDifferent from other sliding window problem, we should sort given array first.\\nThen we have this observation:\\nwhen the right border of window move forward to include the next number, each of the other numbers in this new window should increase n times. n = nums[right] - nums[right -1]\\n\\ne.g.\\n **\\uFF3B**1\\uFF0C 2\\uFF0C 4**\\uFF3D**\\uFF0C8\\uFF0C10 \\n 1 -> 4 increase 3 times\\n 2 -> 4 increase 2 times\\n totally increase 5 times to get [4, 4, 4], 8, 10\\n \\n*right border move...*\\n \\n **\\uFF3B**1\\uFF0C 2\\uFF0C 4\\uFF0C 8**\\uFF3D**\\uFF0C10 \\n 1 -> 8 increase 3+**4** times\\n 2 -> 8 increase 2+**4** times\\n 4 -> 8 increase **4** times\\n \\n totally increase 5+**3*4** times\\n\\ngenerally, we can have:\\n**totally increase times +=  how many numbers in old window * (nums[right] - nums[right - 1])**\\n*/\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        if (nums.length < 2) return nums.length;\\n        \\n        Arrays.sort(nums);\\n        int left = 0;\\n        int count = 0;\\n        int max = 0;\\n        for (int right = 1; right < nums.length; right++) {\\n            \\n            // get the difference of last two numbers in the window\\n            int diff = nums[right] - nums[right - 1];\\n            \\n            // how many times the numbers in this window should be increased \\n            count = count + (right - left) * diff;\\n            \\n            // when the left pointer is lower than the right and count number is larger than target k\\n            while (count > k && left < right) {\\n                count -= nums[right] - nums[left];\\n                left++;\\n            }\\n            if (count <= k) max = Math.max(max, right - left + 1);    \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        if (nums.length < 2) return nums.length;\\n        \\n        Arrays.sort(nums);\\n        int left = 0;\\n        int count = 0;\\n        int max = 0;\\n        for (int right = 1; right < nums.length; right++) {\\n            \\n            // get the difference of last two numbers in the window\\n            int diff = nums[right] - nums[right - 1];\\n            \\n            // how many times the numbers in this window should be increased \\n            count = count + (right - left) * diff;\\n            \\n            // when the left pointer is lower than the right and count number is larger than target k\\n            while (count > k && left < right) {\\n                count -= nums[right] - nums[left];\\n                left++;\\n            }\\n            if (count <= k) max = Math.max(max, right - left + 1);    \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854508,
                "title": "c-sliding-window-explained-for-beginners-and-example",
                "content": "Logic: If we have a sorted array, and if we find the window for the index i, then we can use that for i-1.\\nExample: \\nnums = {1,4,7,8,13}\\nk = 5\\n\\nk = k - nums[i] - nums[currBack] (to check, how many k\\'s are needed to be increased on nums[currBack] to make it equal to nums[k])\\n\\n![image](https://assets.leetcode.com/users/images/d9f85267-31b7-42d2-91c5-dc82fc1b3388_1647426257.0811794.png)\\n\\n\\nWhy the following condition?:\\n```\\n\\t\\t\\tif(i < nums.size()-1){\\n                k += (nums[i+1] - nums[i]) * (i - currBack);\\n            }\\n```\\nAs, the current number we are looking for is nums[i], and we have already checked how many k\\'s we need to increase to reach nums[i+1], so with that we can easily identify the number of k\\'s needed to increase to reach nums[i], for the given currBack.\\n\\n**Final Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int currBack = nums.size()-1;\\n        int maxFreq = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            if(i < nums.size()-1){\\n                k += (nums[i+1] - nums[i]) * (i - currBack);\\n            }\\n            while(currBack >= 0 && nums[i] - nums[currBack] <= k){\\n                k -= nums[i] - nums[currBack];\\n                currBack--;\\n            }\\n            maxFreq = max(maxFreq, i - currBack);\\n            if(currBack < 0)\\n                return maxFreq;\\n        }\\n        return maxFreq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\t\\tif(i < nums.size()-1){\\n                k += (nums[i+1] - nums[i]) * (i - currBack);\\n            }\\n```\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int currBack = nums.size()-1;\\n        int maxFreq = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            if(i < nums.size()-1){\\n                k += (nums[i+1] - nums[i]) * (i - currBack);\\n            }\\n            while(currBack >= 0 && nums[i] - nums[currBack] <= k){\\n                k -= nums[i] - nums[currBack];\\n                currBack--;\\n            }\\n            maxFreq = max(maxFreq, i - currBack);\\n            if(currBack < 0)\\n                return maxFreq;\\n        }\\n        return maxFreq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833162,
                "title": "python-easy-to-read-and-understand-sliding-window",
                "content": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        sums, i, ans = 0, 0, 0\\n        for j in range(len(nums)):\\n            sums += nums[j]\\n            while nums[j]*(j-i+1) > sums+k:\\n                sums -= nums[i]\\n                i = i+1\\n            ans = max(ans, j-i+1)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        sums, i, ans = 0, 0, 0\\n        for j in range(len(nums)):\\n            sums += nums[j]\\n            while nums[j]*(j-i+1) > sums+k:\\n                sums -= nums[i]\\n                i = i+1\\n            ans = max(ans, j-i+1)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1366321,
                "title": "easy-c-sliding-window-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long l=0; \\n        long long r=0;\\n        long long sum=0;\\n        long long ans=0;\\n        while(r<nums.size()) {\\n            sum+=nums[r];\\n            while(nums[r]*(r-l+1) > sum+k) {\\n                sum-=nums[l];\\n                l++;\\n            }\\n            ans = max(ans,r-l+1);\\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long l=0; \\n        long long r=0;\\n        long long sum=0;\\n        long long ans=0;\\n        while(r<nums.size()) {\\n            sum+=nums[r];\\n            while(nums[r]*(r-l+1) > sum+k) {\\n                sum-=nums[l];\\n                l++;\\n            }\\n            ans = max(ans,r-l+1);\\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175065,
                "title": "a-few-solutions",
                "content": "Sort the input array `A` and use a sliding window `i..j` to track the cost difference `diff` total `t` of each candidate subarray from `i` to `j` inclusive.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxFrequency(A: IntArray, K: Int): Int {\\n        var best = 0\\n        var i = 0\\n        var j = 0\\n        var t = 0\\n        A.sort()\\n        while (++j < A.size) {\\n            var diff = A[j] - A[j - 1]\\n            var cost = diff * (j - i)      // \\uD83D\\uDCB0 all elements in the window are incremented by diff\\n            t += cost\\n            while (K < t) {                // \\u2705 maintain window invariant (total cost t cannot exceed K capacity)\\n                t -= (A[j] - A[i]); ++i\\n            }\\n            best = Math.max(best, j - i)   // \\uD83C\\uDFAF max window size\\n        }\\n        return 1 + best                    // +1 for i..j inclusive\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxFrequency = (A, K, t = 0, best = 0) => {\\n    let i = 0,\\n        j = 0;\\n    A.sort((a, b) => a - b);\\n    while (++j < A.length) {\\n        let diff = A[j] - A[j - 1];\\n        let cost = diff * (j - i);     // \\uD83D\\uDCB0 all elements in the window are incremented by diff\\n        t += cost;\\n        while (K < t)                  // \\u2705 maintain window invariant (total cost t cannot exceed K capacity)\\n            t -= (A[j] - A[i]), ++i;\\n        best = Math.max(best, j - i);  // \\uD83C\\uDFAF max window size\\n    }\\n    return 1 + best;                   // +1 for i..j inclusive\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxFrequency(self, A: List[int], K: int, t = 0, best = 0) -> int:\\n        i = 0\\n        j = 0\\n        A.sort()\\n        while j + 1 < len(A):\\n            j += 1\\n            diff = A[j] - A[j - 1]\\n            cost = diff * (j - i)           # \\uD83D\\uDCB0 all elements in the window are incremented by diff\\n            t += cost\\n            while K < t:\\n                t -= (A[j] - A[i]); i += 1  # \\u2705 maintain window invariant (total cost t cannot exceed K capacity)\\n            best = max(best, j - i)         # \\uD83C\\uDFAF max window size\\n        return 1 + best                     # +1 for i..j inclusive\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    int maxFrequency(VI& A, int K, LL t = 0, int best = 0) {\\n        auto i = 0,\\n             j = 0;\\n        sort(A.begin(), A.end());\\n        while (++j < A.size()) {\\n            LL diff = A[j] - A[j - 1];\\n            LL cost = diff * (j - i);     // \\uD83D\\uDCB0 all elements in the window are incremented by diff\\n            t += cost;\\n            while (K < t)                 // \\u2705 maintain window invariant (total cost t cannot exceed K capacity)\\n                t -= (A[j] - A[i]), ++i;\\n            best = max(best, j - i);      // \\uD83C\\uDFAF max window size\\n        }\\n        return 1 + best;                  // +1 for i..j inclusive\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxFrequency(A: IntArray, K: Int): Int {\\n        var best = 0\\n        var i = 0\\n        var j = 0\\n        var t = 0\\n        A.sort()\\n        while (++j < A.size) {\\n            var diff = A[j] - A[j - 1]\\n            var cost = diff * (j - i)      // \\uD83D\\uDCB0 all elements in the window are incremented by diff\\n            t += cost\\n            while (K < t) {                // \\u2705 maintain window invariant (total cost t cannot exceed K capacity)\\n                t -= (A[j] - A[i]); ++i\\n            }\\n            best = Math.max(best, j - i)   // \\uD83C\\uDFAF max window size\\n        }\\n        return 1 + best                    // +1 for i..j inclusive\\n    }\\n}\\n```\n```\\nlet maxFrequency = (A, K, t = 0, best = 0) => {\\n    let i = 0,\\n        j = 0;\\n    A.sort((a, b) => a - b);\\n    while (++j < A.length) {\\n        let diff = A[j] - A[j - 1];\\n        let cost = diff * (j - i);     // \\uD83D\\uDCB0 all elements in the window are incremented by diff\\n        t += cost;\\n        while (K < t)                  // \\u2705 maintain window invariant (total cost t cannot exceed K capacity)\\n            t -= (A[j] - A[i]), ++i;\\n        best = Math.max(best, j - i);  // \\uD83C\\uDFAF max window size\\n    }\\n    return 1 + best;                   // +1 for i..j inclusive\\n};\\n```\n```\\nclass Solution:\\n    def maxFrequency(self, A: List[int], K: int, t = 0, best = 0) -> int:\\n        i = 0\\n        j = 0\\n        A.sort()\\n        while j + 1 < len(A):\\n            j += 1\\n            diff = A[j] - A[j - 1]\\n            cost = diff * (j - i)           # \\uD83D\\uDCB0 all elements in the window are incremented by diff\\n            t += cost\\n            while K < t:\\n                t -= (A[j] - A[i]); i += 1  # \\u2705 maintain window invariant (total cost t cannot exceed K capacity)\\n            best = max(best, j - i)         # \\uD83C\\uDFAF max window size\\n        return 1 + best                     # +1 for i..j inclusive\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    int maxFrequency(VI& A, int K, LL t = 0, int best = 0) {\\n        auto i = 0,\\n             j = 0;\\n        sort(A.begin(), A.end());\\n        while (++j < A.size()) {\\n            LL diff = A[j] - A[j - 1];\\n            LL cost = diff * (j - i);     // \\uD83D\\uDCB0 all elements in the window are incremented by diff\\n            t += cost;\\n            while (K < t)                 // \\u2705 maintain window invariant (total cost t cannot exceed K capacity)\\n                t -= (A[j] - A[i]), ++i;\\n            best = max(best, j - i);      // \\uD83C\\uDFAF max window size\\n        }\\n        return 1 + best;                  // +1 for i..j inclusive\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175024,
                "title": "java-sort",
                "content": "```\\npublic int maxFrequency(int[] nums, int k) {\\n\\tArrays.sort(nums);\\n\\tint result = 1, currentItems = 1;\\n\\tfor(int i=1;i<nums.length;i++) {\\n\\t\\tint currentSum = 0 ;\\n\\t\\tif(nums[i] == nums[i-1]) currentItems++;\\n\\t\\telse {\\n\\t\\t\\tcurrentItems = 1;\\n\\t\\t\\tfor(int j=i-1;j>=0;j--) {\\n\\t\\t\\t\\tcurrentSum += (nums[i] - nums[j]);\\n\\t\\t\\t\\tif (currentSum > k) break;\\n\\t\\t\\t\\tcurrentItems ++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = Math.max(result, currentItems);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxFrequency(int[] nums, int k) {\\n\\tArrays.sort(nums);\\n\\tint result = 1, currentItems = 1;\\n\\tfor(int i=1;i<nums.length;i++) {\\n\\t\\tint currentSum = 0 ;\\n\\t\\tif(nums[i] == nums[i-1]) currentItems++;\\n\\t\\telse {\\n\\t\\t\\tcurrentItems = 1;\\n\\t\\t\\tfor(int j=i-1;j>=0;j--) {\\n\\t\\t\\t\\tcurrentSum += (nums[i] - nums[j]);\\n\\t\\t\\t\\tif (currentSum > k) break;\\n\\t\\t\\t\\tcurrentItems ++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = Math.max(result, currentItems);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914669,
                "title": "c-sorting-based-solution-o-n-logn",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n         int n = nums.size();\\n         sort(nums.begin() , nums.end());\\n         int number = k;\\n         int high = n - 1;\\n         int low = n - 1;\\n         int result = 0;\\n         while(low >= 0){\\n             while(low>=0 && high>=0 && (number >= (nums[high] - nums[low]))){\\n                 number -= (nums[high] - nums[low]);\\n                 low--;\\n             }\\n             result = max(result , high - low);\\n             int count = high - low - 1;\\n             if(high>0)number+=(count * (nums[high]-nums[high-1]));\\n             high--;\\n         }\\n         return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n         int n = nums.size();\\n         sort(nums.begin() , nums.end());\\n         int number = k;\\n         int high = n - 1;\\n         int low = n - 1;\\n         int result = 0;\\n         while(low >= 0){\\n             while(low>=0 && high>=0 && (number >= (nums[high] - nums[low]))){\\n                 number -= (nums[high] - nums[low]);\\n                 low--;\\n             }\\n             result = max(result , high - low);\\n             int count = high - low - 1;\\n             if(high>0)number+=(count * (nums[high]-nums[high-1]));\\n             high--;\\n         }\\n         return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886943,
                "title": "c-with-recurrence-solutions-easy-to-understand",
                "content": "# thought \\nFirst of all, there are some questions that are difficult to answer and this type of topic is one of them, so try not to lose motivation when you encounter this issue. \\n\\n# Approach\\n   If we consider this topic carefully, we can argue that it can be answered using the sliding window approach. The primary logic of the code is while(nums[j]*(j-i+1) > total + k) If we use any example, followed by vlaue, we can quickly see why this recurrence is necessary to resolve the issue at hand. Here, nums[j] represents the window\\'s final element, while j-i+1 denotes the window\\'s size, total is the window sum , and k is the supplied.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long i=0,j=0;\\n        long long result=0,total=0;\\n\\n        while(j<nums.size()){\\n            total+=nums[j];\\n            while(nums[j]*(j-i+1) > total + k){\\n                total-=nums[i];\\n                i++;\\n            }\\n            result = max(result,j-i+1);\\n            j++;\\n        }\\n            return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long i=0,j=0;\\n        long long result=0,total=0;\\n\\n        while(j<nums.size()){\\n            total+=nums[j];\\n            while(nums[j]*(j-i+1) > total + k){\\n                total-=nums[i];\\n                i++;\\n            }\\n            result = max(result,j-i+1);\\n            j++;\\n        }\\n            return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819192,
                "title": "two-pointers-and-sliding-window-good-concept-test-maths-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long s=0;\\n        int i=0,j=0,ans=0;\\n        while(i<nums.size())\\n        {\\n            s+=nums[i];\\n            if(nums[i]*1ll*(i-j+1)-s<=k)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                while(nums[i]*1ll*(i-j+1)-s>k)\\n                {\\n                    s-=nums[j];\\n                    j++;\\n                }\\n                i++;\\n            }\\n            ans=max(ans,i-j);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long s=0;\\n        int i=0,j=0,ans=0;\\n        while(i<nums.size())\\n        {\\n            s+=nums[i];\\n            if(nums[i]*1ll*(i-j+1)-s<=k)\\n            {\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3790748,
                "title": "c-using-sorting-sliding-window-t-c-o-nlogn-s-c-o-1",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(NlogN) + O(N)\\n        Space Complexity : O(1)\\n    */\\n    \\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(begin(nums), end(nums));\\n        \\n        long long currSum = 0;\\n        int res = 0, start = 0, end = 0;\\n        \\n        while(end < nums.size()){\\n            currSum += nums[end];\\n            \\n            // nums[end]*len > currSum+k, if this condition is true then we cannot make all the elements as the element at nums[end], hence we shrink the window\\n            while(nums[end] > (currSum+k)/(end-start+1)){\\n                currSum -= nums[start];\\n                start++;\\n            }\\n            \\n            res = max(res, end-start+1);\\n            end++;\\n        }\\n        \\n        return (int) res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(NlogN) + O(N)\\n        Space Complexity : O(1)\\n    */\\n    \\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(begin(nums), end(nums));\\n        \\n        long long currSum = 0;\\n        int res = 0, start = 0, end = 0;\\n        \\n        while(end < nums.size()){\\n            currSum += nums[end];\\n            \\n            // nums[end]*len > currSum+k, if this condition is true then we cannot make all the elements as the element at nums[end], hence we shrink the window\\n            while(nums[end] > (currSum+k)/(end-start+1)){\\n                currSum -= nums[start];\\n                start++;\\n            }\\n            \\n            res = max(res, end-start+1);\\n            end++;\\n        }\\n        \\n        return (int) res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768983,
                "title": "c-sliding-window-shrinkable-easiest-solution-must-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        long n=nums.size();\\n        long i=0,ans=1,sum=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            sum+=nums[j];\\n            while((j-i+1)*nums[j]-sum>k)\\n            {\\n                sum-=nums[i++];\\n            }\\n            ans=max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        long n=nums.size();\\n        long i=0,ans=1,sum=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            sum+=nums[j];\\n            while((j-i+1)*nums[j]-sum>k)\\n            {\\n                sum-=nums[i++];\\n            }\\n            ans=max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338803,
                "title": "c-two-pointer-easy-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        long long int ind=0,ans=1,cnt=0,s=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            s++;\\n            cnt+=(s*(nums[i]-nums[i-1]));\\n            while(cnt>k)\\n            {\\n                cnt-=(nums[i]-nums[ind]);\\n                ind++;\\n                s--;\\n            }\\n            ans=max(ans,i-ind+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        long long int ind=0,ans=1,cnt=0,s=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            s++;\\n            cnt+=(s*(nums[i]-nums[i-1]));\\n            while(cnt>k)\\n            {\\n                cnt-=(nums[i]-nums[ind]);\\n                ind++;\\n                s--;\\n            }\\n            ans=max(ans,i-ind+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200589,
                "title": "easy-c-solution-using-sliding-window",
                "content": "# Approach\\nFirst of all , we sorted the array , and then we tried to find the length of longest window where the cost of Changing each element to the right most element is less than k. That is the reason we sorted the array as we were told that we can only add to an element, therefore rightmost element will be the greatest in that window.\\nNow the task is of calculating the cost.\\n![WhatsApp Image 2023-02-18 at 14.27.38.jpeg](https://assets.leetcode.com/users/images/f552224f-e290-44e8-90ab-ab61f9cd2cb3_1676710702.8600008.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        long long cost = 0, n = nums.size();\\n    sort(nums.begin(), nums.end());\\n    long long j = 0, sm = 0;\\n    long long ans = 1;\\n    for (int i = 0; i < n; ++i)\\n    {\\n        sm += nums[i];\\n        if ((i - j + 1) * nums[i] - sm <= k)\\n        {\\n            ans = max(ans, i-j + 1);\\n        }\\n        else\\n        {\\n            while ((i - j + 1) * nums[i] - sm > k)\\n            {\\n                sm -= nums[j];\\n                j++;\\n            }\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        long long cost = 0, n = nums.size();\\n    sort(nums.begin(), nums.end());\\n    long long j = 0, sm = 0;\\n    long long ans = 1;\\n    for (int i = 0; i < n; ++i)\\n    {\\n        sm += nums[i];\\n        if ((i - j + 1) * nums[i] - sm <= k)\\n        {\\n            ans = max(ans, i-j + 1);\\n        }\\n        else\\n        {\\n            while ((i - j + 1) * nums[i] - sm > k)\\n            {\\n                sm -= nums[j];\\n                j++;\\n            }\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137695,
                "title": "java-solution-11-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        countingSort(nums);\\n        int start = 0;\\n        int preSum = 0;\\n        int total = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int length = i - start + 1;\\n            int product = nums[i] * length;\\n            preSum += nums[i];            \\n            while (product - preSum > k) {\\n                preSum -= nums[start++];\\n                length--;\\n                product = nums[i] * length;\\n            }\\n            total = Math.max(total, length);\\n        }\\n      \\n        return total;\\n    }\\n    private void countingSort(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int num: nums) {\\n            max = Math.max(max, num);\\n        }\\n        int[] map = new int[max + 1];\\n        for(int num: nums) {\\n            map[num]++;\\n        }\\n        int i = 0;\\n        int j = 0;\\n        while(i <= max) {\\n            if (map[i]-- > 0) {\\n                nums[j++] = i;\\n            } else {\\n                i++;\\n            }\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        countingSort(nums);\\n        int start = 0;\\n        int preSum = 0;\\n        int total = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int length = i - start + 1;\\n            int product = nums[i] * length;\\n            preSum += nums[i];            \\n            while (product - preSum > k) {\\n                preSum -= nums[start++];\\n                length--;\\n                product = nums[i] * length;\\n            }\\n            total = Math.max(total, length);\\n        }\\n      \\n        return total;\\n    }\\n    private void countingSort(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int num: nums) {\\n            max = Math.max(max, num);\\n        }\\n        int[] map = new int[max + 1];\\n        for(int num: nums) {\\n            map[num]++;\\n        }\\n        int i = 0;\\n        int j = 0;\\n        while(i <= max) {\\n            if (map[i]-- > 0) {\\n                nums[j++] = i;\\n            } else {\\n                i++;\\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715550,
                "title": "c-solution-with-images-and-explanation-2-approach",
                "content": "**Here i have explained the approach to this problem later i will provide more optimized solution but check this as it will help you understand the problem easily \\uD83D\\uDE00\\uD83D\\uDE00**\\n\\n![image](https://assets.leetcode.com/users/images/0383e603-ed2d-4245-9892-5fed259ca088_1666032585.8739402.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    // SLIDING WINDOW\\n    bool check(int mid, vector<int>& nums, int k)\\n    { \\n        long long int windowsum=0,totalsum=0;\\n        for(int i=0;i<mid;++i)\\n            windowsum+=nums[i];\\n \\n        totalsum=1LL*nums[mid-1]*mid;\\n \\n        if(totalsum-windowsum<=k)\\n            return 1;\\n \\n        int j=0;\\n        for(int i=mid;i<nums.size();++i)\\n        {\\n            windowsum-=nums[j];\\n            windowsum+=nums[i];\\n            totalsum=totalsum=1LL*nums[i]*mid;\\n \\n            if(totalsum-windowsum<=k)\\n                return 1;\\n            j++;\\n        }\\n \\n        return 0;\\n    }\\n    // BINARY SEARCH\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int lo = 1, hi = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int ans;\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(mid, nums, k)){\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n            else{\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**But this solution is little bit long also its TC is O(N log N) i got a simpler approach**\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int left = 0, right = 0, ans = 1;\\n        long long total = 0, n = nums.size();\\n        \\n        while(right < n){\\n            total += nums[right];\\n            \\n            while((1ll) * (right - left + 1) * nums[right] - total > k){\\n                total -= nums[left];\\n                left++;\\n            }\\n            \\n            ans = max(ans, right -left + 1);\\n            right++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Please upvote if u like the solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // SLIDING WINDOW\\n    bool check(int mid, vector<int>& nums, int k)\\n    { \\n        long long int windowsum=0,totalsum=0;\\n        for(int i=0;i<mid;++i)\\n            windowsum+=nums[i];\\n \\n        totalsum=1LL*nums[mid-1]*mid;\\n \\n        if(totalsum-windowsum<=k)\\n            return 1;\\n \\n        int j=0;\\n        for(int i=mid;i<nums.size();++i)\\n        {\\n            windowsum-=nums[j];\\n            windowsum+=nums[i];\\n            totalsum=totalsum=1LL*nums[i]*mid;\\n \\n            if(totalsum-windowsum<=k)\\n                return 1;\\n            j++;\\n        }\\n \\n        return 0;\\n    }\\n    // BINARY SEARCH\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int lo = 1, hi = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int ans;\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(mid, nums, k)){\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n            else{\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int left = 0, right = 0, ans = 1;\\n        long long total = 0, n = nums.size();\\n        \\n        while(right < n){\\n            total += nums[right];\\n            \\n            while((1ll) * (right - left + 1) * nums[right] - total > k){\\n                total -= nums[left];\\n                left++;\\n            }\\n            \\n            ans = max(ans, right -left + 1);\\n            right++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587868,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n       long long int left = 0; //\\n        long long int right = 0; //\\n        long long int res = 0;\\n        long long int total = 0;\\n        int n = nums.size();\\n        \\n        while(right < n){\\n            total += nums[right];\\n            \\n            //(right-left+1) -> window size\\n            while((nums[right] * (right - left + 1)) > total + k){\\n               total -= nums[left]; \\n                left += 1;\\n            }\\n            res = max(res, right-left+1);\\n            right += 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n       long long int left = 0; //\\n        long long int right = 0; //\\n        long long int res = 0;\\n        long long int total = 0;\\n        int n = nums.size();\\n        \\n        while(right < n){\\n            total += nums[right];\\n            \\n            //(right-left+1) -> window size\\n            while((nums[right] * (right - left + 1)) > total + k){\\n               total -= nums[left]; \\n                left += 1;\\n            }\\n            res = max(res, right-left+1);\\n            right += 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513956,
                "title": "java-brute-force-and-100-optimal-solution-sliding-window-solution",
                "content": "**Brute force solution:** \\n* it will work for small size of arrays\\n* it will not work for large size of array, so you can go for the optimal solution given below.\\n\\n```\\npublic int maxFrequency(int[] nums, int k) {\\n        int initialK=k;\\n        int ans=0,count=1;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]>nums[j]){\\n                    int temp=nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j]=temp;\\n                }\\n            }\\n        }\\n        int num=0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(num!=nums[i]){\\n                num=nums[i];\\n                for(int j=i-1;j>=0;j--){\\n                    if((nums[i]-nums[j])<=k){\\n                        k= k - (nums[i]-nums[j]);\\n                        count++;\\n                    }\\n                }\\n                if(ans<count){\\n                    ans=count;\\n                    count=1;\\n                }\\n                count=1;\\n            }\\n            k=initialK;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Optimal solution:**\\n\\n```\\npublic int maxFrequency(int[] nums, int k) {      \\n        Arrays.sort(nums);\\n        \\n        int left=0,right=0;\\n        long res=0,sum=0;\\n        \\n        while(right<nums.length){\\n            sum+=nums[right];\\n            \\n            while((long)nums[right]*(right-left+1) > sum+k){\\n                sum-=nums[left];\\n                left++;\\n            }\\n            res=Math.max(res, right-left+1);\\n            right++;\\n        }\\n        return (int)res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\npublic int maxFrequency(int[] nums, int k) {\\n        int initialK=k;\\n        int ans=0,count=1;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]>nums[j]){\\n                    int temp=nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j]=temp;\\n                }\\n            }\\n        }\\n        int num=0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(num!=nums[i]){\\n                num=nums[i];\\n                for(int j=i-1;j>=0;j--){\\n                    if((nums[i]-nums[j])<=k){\\n                        k= k - (nums[i]-nums[j]);\\n                        count++;\\n                    }\\n                }\\n                if(ans<count){\\n                    ans=count;\\n                    count=1;\\n                }\\n                count=1;\\n            }\\n            k=initialK;\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic int maxFrequency(int[] nums, int k) {      \\n        Arrays.sort(nums);\\n        \\n        int left=0,right=0;\\n        long res=0,sum=0;\\n        \\n        while(right<nums.length){\\n            sum+=nums[right];\\n            \\n            while((long)nums[right]*(right-left+1) > sum+k){\\n                sum-=nums[left];\\n                left++;\\n            }\\n            res=Math.max(res, right-left+1);\\n            right++;\\n        }\\n        return (int)res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2477051,
                "title": "c-fast-and-easy-to-understand-solution-sliding-window",
                "content": "**If you really found my solution helpful please upvote it\\nClick this same icon \\u25B2 on left side pannel of display to upvote**\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end(),greater<int>()); // sort element \\n        int i=0;\\n        int j=0;\\n        unsigned long long sum=0;\\n        int cnt=0,cnt1=0,K1=k;\\n        while(j<nums.size()){\\n            sum+=nums[j];  // sum of element front i to j;\\n            int dis=j-i+1; // distance b/w i to j\\n            unsigned long long maxSum=1ULL*dis*nums[i]; //memory overflow so use ull \\n            if(maxSum-sum>K1){  if diff is greater than k so i++ and distance --;\\n                sum-=nums[i];\\n                i++;\\n                dis--;\\n            }\\n                cnt=max(dis,cnt);\\n            j++;\\n                \\n        \\n           \\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end(),greater<int>()); // sort element \\n        int i=0;\\n        int j=0;\\n        unsigned long long sum=0;\\n        int cnt=0,cnt1=0,K1=k;\\n        while(j<nums.size()){\\n            sum+=nums[j];  // sum of element front i to j;\\n            int dis=j-i+1; // distance b/w i to j\\n            unsigned long long maxSum=1ULL*dis*nums[i]; //memory overflow so use ull \\n            if(maxSum-sum>K1){  if diff is greater than k so i++ and distance --;\\n                sum-=nums[i];\\n                i++;\\n                dis--;\\n            }\\n                cnt=max(dis,cnt);\\n            j++;\\n                \\n        \\n           \\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180698,
                "title": "c-faster-then-100-sliding-window-prefix-sum",
                "content": "```\\n **upvote if you understand**\\nint maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long int sum=nums[0];\\n        int ans=1;\\n        int i=0,j=1;\\n        while(j<nums.size())\\n        {\\n            sum+=nums[j];\\n            \\n            while(i<j && (long long)nums[j]*(j-i+1)-sum>k)\\n                sum-=nums[i++];\\n            \\n            ans=max(ans,j-i+1);\\n            \\n            j++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n **upvote if you understand**\\nint maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long int sum=nums[0];\\n        int ans=1;\\n        int i=0,j=1;\\n        while(j<nums.size())\\n        {\\n            sum+=nums[j];\\n            \\n            while(i<j && (long long)nums[j]*(j-i+1)-sum>k)\\n                sum-=nums[i++];\\n            \\n            ans=max(ans,j-i+1);\\n            \\n            j++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1970104,
                "title": "java-o-n-sliding-window-20ms-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/1f43bcc2-5aaf-4653-b93b-678bb35548c7_1650558552.9032807.png)\\n\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        /*\\n        0 ... i ... j, j + 1 ... n - 1\\n        |---window--|\\n        PreSum = sum(0, j)\\n        Expected = nums[j] * windowLength\\n        Expected - PreSum <= k\\n        */\\n        countingSort(nums);\\n        int start = 0;\\n        int preSum = 0;\\n        int total = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int length = i - start + 1;\\n            int product = nums[i] * length;\\n            preSum += nums[i];            \\n            while (product - preSum > k) {\\n                preSum -= nums[start++];\\n                length--;\\n                product = nums[i] * length;\\n            }\\n            total = Math.max(total, length);\\n        }\\n      \\n        return total;\\n    }\\n    // Counting Sort: O(n)\\n    private void countingSort(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int num: nums) {\\n            max = Math.max(max, num);\\n        }\\n        int[] map = new int[max + 1];\\n        for(int num: nums) {\\n            map[num]++;\\n        }\\n        int i = 0;\\n        int j = 0;\\n        while(i <= max) {\\n            if (map[i]-- > 0) {\\n                nums[j++] = i;\\n            } else {\\n                i++;\\n            }\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        /*\\n        0 ... i ... j, j + 1 ... n - 1\\n        |---window--|\\n        PreSum = sum(0, j)\\n        Expected = nums[j] * windowLength\\n        Expected - PreSum <= k\\n        */\\n        countingSort(nums);\\n        int start = 0;\\n        int preSum = 0;\\n        int total = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int length = i - start + 1;\\n            int product = nums[i] * length;\\n            preSum += nums[i];            \\n            while (product - preSum > k) {\\n                preSum -= nums[start++];\\n                length--;\\n                product = nums[i] * length;\\n            }\\n            total = Math.max(total, length);\\n        }\\n      \\n        return total;\\n    }\\n    // Counting Sort: O(n)\\n    private void countingSort(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int num: nums) {\\n            max = Math.max(max, num);\\n        }\\n        int[] map = new int[max + 1];\\n        for(int num: nums) {\\n            map[num]++;\\n        }\\n        int i = 0;\\n        int j = 0;\\n        while(i <= max) {\\n            if (map[i]-- > 0) {\\n                nums[j++] = i;\\n            } else {\\n                i++;\\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713959,
                "title": "c-easy-to-understand-sliding-window-method",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n     long long int ans=0;\\n     long long int right=0,left=0;\\n     long long int n=nums.size();\\n     long long int total=0;\\n     sort(nums.begin(),nums.end());\\n     while(right<n)\\n     {\\n         total+=nums[right];\\n         while(nums[right]*(right-left+1)>total+k)\\n         {\\n             total-=nums[left];\\n             left++;\\n         }\\n         ans=max(ans,right-left+1);\\n         right++;\\n     }\\n    return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n     long long int ans=0;\\n     long long int right=0,left=0;\\n     long long int n=nums.size();\\n     long long int total=0;\\n     sort(nums.begin(),nums.end());\\n     while(right<n)\\n     {\\n         total+=nums[right];\\n         while(nums[right]*(right-left+1)>total+k)\\n         {\\n             total-=nums[left];\\n             left++;\\n         }\\n         ans=max(ans,right-left+1);\\n         right++;\\n     }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681349,
                "title": "java-sorting-sliding-window-beats-90",
                "content": "Please upvote if you find it useful! Or leave comments and suggestions below!\\nI will try my best to answer them. Thank you!\\n\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        int maxFreq = 0, left = 0, right = 0, lastNum = nums[0], numOfOptLeft = k;\\n        \\n        while (right < nums.length) {\\n            int rightNum = nums[right++];\\n            int optRequired = (right - left - 1) * (rightNum - lastNum);\\n            \\n            while (left < right && optRequired > numOfOptLeft) {\\n                int leftNum = nums[left++];\\n                numOfOptLeft += (lastNum - leftNum);\\n                optRequired = (right - left - 1) * (rightNum - lastNum);\\n            }\\n            \\n            numOfOptLeft -= optRequired;\\n            lastNum = rightNum;\\n            maxFreq = Math.max(maxFreq, right - left);\\n        }\\n        \\n        return maxFreq;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        int maxFreq = 0, left = 0, right = 0, lastNum = nums[0], numOfOptLeft = k;\\n        \\n        while (right < nums.length) {\\n            int rightNum = nums[right++];\\n            int optRequired = (right - left - 1) * (rightNum - lastNum);\\n            \\n            while (left < right && optRequired > numOfOptLeft) {\\n                int leftNum = nums[left++];\\n                numOfOptLeft += (lastNum - leftNum);\\n                optRequired = (right - left - 1) * (rightNum - lastNum);\\n            }\\n            \\n            numOfOptLeft -= optRequired;\\n            lastNum = rightNum;\\n            maxFreq = Math.max(maxFreq, right - left);\\n        }\\n        \\n        return maxFreq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408998,
                "title": "c-slinding-window-sorting",
                "content": "```\\n\\n```public:\\n    int maxFrequency(vector<int>& nums, int k) {\\n    long long int i,j=0,res=0;\\n        sort(nums.begin(),nums.end());\\n        vector<long long int>preffix(nums.size());\\n        preffix[0]=nums[0];\\n        for(i=1;i<nums.size();i++)\\n        {\\n            preffix[i]=preffix[i-1]+nums[i];\\n        }\\n       for(i=0;i<nums.size();i++)\\n        {\\n            while(((nums[i]*(i-j+1))-preffix[i]+(j>0?preffix[j-1]:0))>k)\\n            {\\n                j++;\\n            }\\n            res=max(res,(i-j+1));\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1263507,
                "title": "java-greedy-sliding-window-sort-slide-algo-clean-short-code",
                "content": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        int ans=0;\\n        long sum=0;\\n        int l=0,r=0;\\n        \\n        while(r<nums.length){\\n            sum+=nums[r];\\n            \\n            while(nums[r]*(r-l+1)>sum+k){\\n                sum-=nums[l];\\n                l++;\\n            }\\n            ans=Math.max(ans,r-l+1);\\n            r++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        int ans=0;\\n        long sum=0;\\n        int l=0,r=0;\\n        \\n        while(r<nums.length){\\n            sum+=nums[r];\\n            \\n            while(nums[r]*(r-l+1)>sum+k){\\n                sum-=nums[l];\\n                l++;\\n            }\\n            ans=Math.max(ans,r-l+1);\\n            r++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182139,
                "title": "python-3-sliding-window-explained",
                "content": "```\\nclass Solution:\\n    def maxFrequency(self, nums, k: int) -> int:\\n        \"\"\"\\n        Given an array of integers (nums) and a maximum number\\n        of operations allowed (k), this program uses a sliding\\n        window to determine the maximum possible frequency of\\n        an element in the array.\\n\\n        :param nums: array of positive integers\\n        :type nums: list[int]\\n        :param k: number of operations allowed\\n        :type k: int\\n        :return: maximum frequency after up to k operations\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize:\\n        - len_nums stores the length of nums\\n        - Sort nums\\n        - Frequency of 1 is always possible since it requires\\n          no operations.\\n          - max_freq stores the maximum possible frequency.\\n          - freq stores the frequency of the current sliding\\n            window.\\n        - The sliding window within nums will be defined by left\\n          and right pointers. The left pointer (left) is initialized\\n          to 0.\\n        - ops is the number of available operations that can\\n          be used to expand the sliding window and thus, freq.\\n        \"\"\"\\n        len_nums = len(nums)\\n        nums.sort()\\n        max_freq = 1\\n        freq = 1\\n        left = 0\\n        ops = k\\n\\n        \"\"\"\\n        Sliding Window:\\n        - The right pointer (right) is used to expand the sliding\\n          window.\\n        - The number of operations available (ops) is reduced\\n          whenever the sliding window is expanded.\\n        - If ops falls below zero, the sliding window is reduced\\n          using the left pointer until ops becomes positive.\\n        \"\"\"\\n        for right in range(1, len_nums):\\n            ops -= (nums[right] - nums[right - 1]) * freq\\n            freq += 1\\n            if ops >= 0:\\n                max_freq = max(max_freq, freq)\\n            else:\\n                while ops < 0:\\n                    ops += nums[right] - nums[left]\\n                    left += 1\\n                    freq -= 1\\n        return max_freq\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums, k: int) -> int:\\n        \"\"\"\\n        Given an array of integers (nums) and a maximum number\\n        of operations allowed (k), this program uses a sliding\\n        window to determine the maximum possible frequency of\\n        an element in the array.\\n\\n        :param nums: array of positive integers\\n        :type nums: list[int]\\n        :param k: number of operations allowed\\n        :type k: int\\n        :return: maximum frequency after up to k operations\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize:\\n        - len_nums stores the length of nums\\n        - Sort nums\\n        - Frequency of 1 is always possible since it requires\\n          no operations.\\n          - max_freq stores the maximum possible frequency.\\n          - freq stores the frequency of the current sliding\\n            window.\\n        - The sliding window within nums will be defined by left\\n          and right pointers. The left pointer (left) is initialized\\n          to 0.\\n        - ops is the number of available operations that can\\n          be used to expand the sliding window and thus, freq.\\n        \"\"\"\\n        len_nums = len(nums)\\n        nums.sort()\\n        max_freq = 1\\n        freq = 1\\n        left = 0\\n        ops = k\\n\\n        \"\"\"\\n        Sliding Window:\\n        - The right pointer (right) is used to expand the sliding\\n          window.\\n        - The number of operations available (ops) is reduced\\n          whenever the sliding window is expanded.\\n        - If ops falls below zero, the sliding window is reduced\\n          using the left pointer until ops becomes positive.\\n        \"\"\"\\n        for right in range(1, len_nums):\\n            ops -= (nums[right] - nums[right - 1]) * freq\\n            freq += 1\\n            if ops >= 0:\\n                max_freq = max(max_freq, freq)\\n            else:\\n                while ops < 0:\\n                    ops += nums[right] - nums[left]\\n                    left += 1\\n                    freq -= 1\\n        return max_freq\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181881,
                "title": "java-sliding-window",
                "content": "```\\n\\npublic int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = 0;\\n        int r = 0;\\n        long rollingSum = 0;\\n        int maxFrequency = 1;\\n        while (r < nums.length - 1) {\\n            rollingSum = rollingSum + nums[r++];\\n            if (rollingSum + k + nums[r] >= (r - l + 1) * nums[r]) {\\n                maxFrequency = Math.max(maxFrequency, (r - l + 1));\\n            } else {\\n                rollingSum = rollingSum - nums[l++];\\n            }\\n        }\\n        return maxFrequency;\\n    }\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = 0;\\n        int r = 0;\\n        long rollingSum = 0;\\n        int maxFrequency = 1;\\n        while (r < nums.length - 1) {\\n            rollingSum = rollingSum + nums[r++];\\n            if (rollingSum + k + nums[r] >= (r - l + 1) * nums[r]) {\\n                maxFrequency = Math.max(maxFrequency, (r - l + 1));\\n            } else {\\n                rollingSum = rollingSum - nums[l++];\\n            }\\n        }\\n        return maxFrequency;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1176118,
                "title": "help-needed-please-debug",
                "content": "Please tell me what is the mistake in my logic. \\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int answer = 1;\\n        \\n        for(int i = 0 ; i < nums.size() ; i++) {\\n            int back = i-1;\\n            int ahead = i+1;\\n            \\n            int ops = k;\\n            int curr = 1;\\n            while(ops >= 0) {\\n                int backDiff = INT_MAX;\\n                int aheadDiff = INT_MAX;\\n                \\n                if(back >= 0) {\\n                    backDiff = nums[i] - nums[back]; \\n                }    \\n                \\n                if(ahead < nums.size()) {\\n                    aheadDiff = nums[ahead] - nums[i];\\n                }\\n                \\n                if(backDiff == INT_MAX && aheadDiff == INT_MAX) {\\n                    answer = max(answer, curr);\\n                    break;\\n                }\\n                \\n                if(backDiff < aheadDiff) {\\n                    if(backDiff <= ops) {\\n                        curr++;\\n                        ops -= backDiff;\\n                        back--;\\n                    } else {\\n                        ops  = -1;\\n                    }\\n                } else {\\n                    if(aheadDiff <= ops) {\\n                        curr++;\\n                        ops -= backDiff;\\n                        ahead++;\\n                    } else {\\n                        ops  = -1;\\n                    }\\n                }\\n                \\n            }\\n            \\n            answer = max(answer, curr);\\n            \\n\\n            \\n        }\\n        \\n        return answer;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int answer = 1;\\n        \\n        for(int i = 0 ; i < nums.size() ; i++) {\\n            int back = i-1;\\n            int ahead = i+1;\\n            \\n            int ops = k;\\n            int curr = 1;\\n            while(ops >= 0) {\\n                int backDiff = INT_MAX;\\n                int aheadDiff = INT_MAX;\\n                \\n                if(back >= 0) {\\n                    backDiff = nums[i] - nums[back]; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1175975,
                "title": "c-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>pref(n);\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+nums[i];\\n        }\\n        int ans=1;\\n        for(int i=n-1;i>0;i--){\\n            int l=0;\\n            int r=i;\\n            int mid;\\n            while(l<=r){\\n                mid=l+(r-l)/2;\\n                \\n                long long req_k=0;\\n                req_k+=((long long)(i-mid)*(long long)nums[i]);\\n                if(mid-1>=0)\\n                    req_k-=(pref[i-1]-pref[mid-1]);\\n                else\\n                    req_k-=pref[i-1];\\n                \\n                if(req_k <= k){\\n                    ans=max(ans,i-mid+1);\\n                    r=mid-1;\\n                }\\n                    \\n                else\\n                    l=mid+1;\\n                \\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>pref(n);\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+nums[i];\\n        }\\n        int ans=1;\\n        for(int i=n-1;i>0;i--){\\n            int l=0;\\n            int r=i;\\n            int mid;\\n            while(l<=r){\\n                mid=l+(r-l)/2;\\n                \\n                long long req_k=0;\\n                req_k+=((long long)(i-mid)*(long long)nums[i]);\\n                if(mid-1>=0)\\n                    req_k-=(pref[i-1]-pref[mid-1]);\\n                else\\n                    req_k-=pref[i-1];\\n                \\n                if(req_k <= k){\\n                    ans=max(ans,i-mid+1);\\n                    r=mid-1;\\n                }\\n                    \\n                else\\n                    l=mid+1;\\n                \\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175270,
                "title": "python-python3-solution-with-explanation",
                "content": "**Code:**\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        j = 0\\n        nums.sort() #sort the numbers\\n        for i in range(len(nums)): #traverse the numbers\\n            k += nums[i] #add the num[i] to k\\n            if k < nums[i] * (i-j+1): #if k < the computed value (nums[i] * (i-j+1))\\n                k -= nums[j] #decrease the value of nums[j] to k\\n                j += 1#and increment the j +1\\n        return i - j + 1\\n```\\nIt is a simple sliding window concept.\\nExplained the example below:\\nExample 1:\\nnums = [1,2,4] k = 5\\nassign j = 0\\nSort the number\\nEnters the loop\\nk +=1(nums[0])=>k = 6 => 6<(1*(0-0+1)) => False\\nk +=2(nums[1])=>k = 8 => 8<(2*(1-0+1)) => False\\nk +=4(nums[2])=>k = 12 => 12<(4*(2-0+1)) => False\\nLoop ends\\nreturn the value i - j +1 => 2 - 0 + 1 = 3\\nVisualization Output is attached below\\n![image](https://assets.leetcode.com/users/images/4be079bd-ba03-482c-b9b7-dca021f27189_1619327551.104353.png)\\n\\n\\nIf you need to visualize the code how it runs use this [visualizer](http://pythontutor.com/visualize.html#mode=edit) which I use very often for python.\\n\\n***We rise by lifting others***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        j = 0\\n        nums.sort() #sort the numbers\\n        for i in range(len(nums)): #traverse the numbers\\n            k += nums[i] #add the num[i] to k\\n            if k < nums[i] * (i-j+1): #if k < the computed value (nums[i] * (i-j+1))\\n                k -= nums[j] #decrease the value of nums[j] to k\\n                j += 1#and increment the j +1\\n        return i - j + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175240,
                "title": "javascript-sliding-window",
                "content": "Referenced solution: good to know the sliding window solution:\\nhttps://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175123/Java-or-Sliding-Window-or-O(n*logn)-Solution\\n\\nJavaScript code:\\n```js\\nvar maxFrequency = function(nums, k) {\\n    nums.sort((a,b)=>a-b);\\n    var sum = 0;\\n    var start = 0;\\n    var res = 0;\\n    for(var i= 0; i<nums.length; i++)\\n    {\\n        sum += nums[i];\\n        while(nums[i] * (i-start+1) - sum > k)\\n        {\\n            sum -= nums[start];\\n            start++;\\n        }\\n        res = Math.max(res, i-start+1);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar maxFrequency = function(nums, k) {\\n    nums.sort((a,b)=>a-b);\\n    var sum = 0;\\n    var start = 0;\\n    var res = 0;\\n    for(var i= 0; i<nums.length; i++)\\n    {\\n        sum += nums[i];\\n        while(nums[i] * (i-start+1) - sum > k)\\n        {\\n            sum -= nums[start];\\n            start++;\\n        }\\n        res = Math.max(res, i-start+1);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175151,
                "title": "c-binary-search-solution-little-bit-different",
                "content": "```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    \\n    bool check(int k,int mid,vector<int> &nums,vector<ll> &pref){\\n        int n = nums.size();\\n        for(int i=0;i+mid-1<=n-1;i++){\\n            ll sum = (ll)((ll)nums[i+mid-1]*(ll)mid) - pref[i+mid-1];\\n            if(i>=1) sum+=pref[i-1];\\n            //cout << i << \" \" << sum << endl;\\n            if(sum<=k) return 1;\\n        }\\n        return false;\\n    }\\n    \\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<ll> pref(n,0);\\n        pref[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            pref[i] = pref[i-1] + (ll)nums[i];\\n        }\\n        int ans = 0;\\n        int l = 1,r = n;\\n        int lprev = 1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(check(k,mid,nums,pref)){\\n                l = mid;\\n                if(l==lprev){\\n                    l = l+1;\\n                }\\n                lprev = l;\\n                ans = max(ans,mid);\\n                //cout << mid << endl;\\n            }\\n            else r= mid-1;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    \\n    bool check(int k,int mid,vector<int> &nums,vector<ll> &pref){\\n        int n = nums.size();\\n        for(int i=0;i+mid-1<=n-1;i++){\\n            ll sum = (ll)((ll)nums[i+mid-1]*(ll)mid) - pref[i+mid-1];\\n            if(i>=1) sum+=pref[i-1];\\n            //cout << i << \" \" << sum << endl;\\n            if(sum<=k) return 1;\\n        }\\n        return false;\\n    }\\n    \\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<ll> pref(n,0);\\n        pref[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            pref[i] = pref[i-1] + (ll)nums[i];\\n        }\\n        int ans = 0;\\n        int l = 1,r = n;\\n        int lprev = 1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(check(k,mid,nums,pref)){\\n                l = mid;\\n                if(l==lprev){\\n                    l = l+1;\\n                }\\n                lprev = l;\\n                ans = max(ans,mid);\\n                //cout << mid << endl;\\n            }\\n            else r= mid-1;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1175028,
                "title": "python-binary-search-prefix-sums",
                "content": "After sorting nums, consider i-th element. We store the prefix sums all the way up to index i in the array `prefix`. Now over the prefix sums we can do a search for the index j such that all the elements in `nums[j..i]` can be incremented to `nums[i]`. As `nums` is sorted we can find `j` using binary search.\\n\\nTime: `O(N logN)`\\nSpace: `O(N)` \\n\\n```python\\nclass Solution:\\n    def bisect(self, v, prefix, k):\\n        lo, hi = 0, len(prefix)-1\\n        while lo < hi:\\n            mi = lo + hi >> 1\\n            sum1 = v * (len(prefix) - 1 - mi)\\n            sum2 = prefix[-1] - prefix[mi]\\n            if sum1 - sum2 <= k:\\n                hi = mi\\n            else:\\n                lo = mi + 1\\n        return lo\\n                \\n    \\n    def maxFrequency(self, nums, k):\\n        ans = 0\\n        nums.sort()\\n        prefix = [0]\\n        for i in range(len(nums)):\\n            j = self.bisect(nums[i], prefix, k)\\n            ans = max(ans, i - j + 1)\\n            prefix.append(prefix[-1] + nums[i])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def bisect(self, v, prefix, k):\\n        lo, hi = 0, len(prefix)-1\\n        while lo < hi:\\n            mi = lo + hi >> 1\\n            sum1 = v * (len(prefix) - 1 - mi)\\n            sum2 = prefix[-1] - prefix[mi]\\n            if sum1 - sum2 <= k:\\n                hi = mi\\n            else:\\n                lo = mi + 1\\n        return lo\\n                \\n    \\n    def maxFrequency(self, nums, k):\\n        ans = 0\\n        nums.sort()\\n        prefix = [0]\\n        for i in range(len(nums)):\\n            j = self.bisect(nums[i], prefix, k)\\n            ans = max(ans, i - j + 1)\\n            prefix.append(prefix[-1] + nums[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970349,
                "title": "tc-nlogn-sc-o-1-beginner-friendly-easy-to-think-understand-sw-closest-to-brute-force",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every `l` find the farthest `r` which satisfies given condition.\\n\\n# Complexity\\n- Time complexity: O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int r = 0;\\n        int ans = 0;\\n        for(int l = 0; l < nums.size(); l++)\\n        {\\n            while(r < nums.size() && nums[l]-nums[r] <= k)\\n            {\\n                k -= (nums[l]-nums[r]);\\n                r++;\\n            }\\n            // r moves to r+1, the number of elements if l needs to shift is (r-l-1) as currently rth element is not included in the window.\\n            if(l < nums.size()-1) \\n                k += (nums[l]-nums[l+1]) * (r-l-1);\\n            ans = max(ans, r-l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int r = 0;\\n        int ans = 0;\\n        for(int l = 0; l < nums.size(); l++)\\n        {\\n            while(r < nums.size() && nums[l]-nums[r] <= k)\\n            {\\n                k -= (nums[l]-nums[r]);\\n                r++;\\n            }\\n            // r moves to r+1, the number of elements if l needs to shift is (r-l-1) as currently rth element is not included in the window.\\n            if(l < nums.size()-1) \\n                k += (nums[l]-nums[l+1]) * (r-l-1);\\n            ans = max(ans, r-l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895708,
                "title": "easy-to-understand-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int j=0;\\n        long long int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res+= nums[i];\\n            long long x=(i+1);\\n            long long temp=nums[i]*(x);\\n\\n            if((temp-res)<=k){\\n\\n            }else{\\n                while(res>k && j<i){\\n                    long long y=(i-j+1);\\n                    long long t=nums[i]*y;\\n                    if(t-res<=k) break;\\n                    res-= nums[j];\\n                    j++;\\n                }\\n            }\\n            ans=max(ans,(i-j+1));   \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int j=0;\\n        long long int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res+= nums[i];\\n            long long x=(i+1);\\n            long long temp=nums[i]*(x);\\n\\n            if((temp-res)<=k){\\n\\n            }else{\\n                while(res>k && j<i){\\n                    long long y=(i-j+1);\\n                    long long t=nums[i]*y;\\n                    if(t-res<=k) break;\\n                    res-= nums[j];\\n                    j++;\\n                }\\n            }\\n            ans=max(ans,(i-j+1));   \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846988,
                "title": "c-prefix-sum-sliding-window-easytounderstand",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int start=0; \\n        int maxx_length=0;\\n        int end =0;\\n        sort(nums.begin(),nums.end());\\n        long long  prefix_sum=nums[0];\\n        while(end <nums.size()){\\n           if((long)nums[end]*(end-start+1)<= k+ prefix_sum){\\n               maxx_length=max(maxx_length,end-start+1);\\n               end++;\\n               if(end<nums.size()) prefix_sum += nums[end];\\n           }\\n           else {\\n               prefix_sum -= nums[start];\\n               start++;\\n           }\\n        }\\n        return maxx_length;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int start=0; \\n        int maxx_length=0;\\n        int end =0;\\n        sort(nums.begin(),nums.end());\\n        long long  prefix_sum=nums[0];\\n        while(end <nums.size()){\\n           if((long)nums[end]*(end-start+1)<= k+ prefix_sum){\\n               maxx_length=max(maxx_length,end-start+1);\\n               end++;\\n               if(end<nums.size()) prefix_sum += nums[end];\\n           }\\n           else {\\n               prefix_sum -= nums[start];\\n               start++;\\n           }\\n        }\\n        return maxx_length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769114,
                "title": "c-non-shrinkable-window-easiest-of-the-solution-only-4-lines-of-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        long n=nums.size();\\n        long i=0,sum=0,j;\\n        for(j=0;j<n;j++)\\n        {\\n            sum+=nums[j];\\n            if((j-i+1)*nums[j]-sum>k)\\n            {\\n                sum-=nums[i++];\\n            }\\n        }\\n        return j-i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        long n=nums.size();\\n        long i=0,sum=0,j;\\n        for(j=0;j<n;j++)\\n        {\\n            sum+=nums[j];\\n            if((j-i+1)*nums[j]-sum>k)\\n            {\\n                sum-=nums[i++];\\n            }\\n        }\\n        return j-i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720384,
                "title": "sort-and-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        l,r = 0,0\\n        res,total = 0,0\\n\\n        while r < len(nums):\\n            total += nums[r]\\n\\n            while nums[r] * (r-l+1) > total + k:\\n                total -= nums[l]\\n                l+=1\\n            \\n            res = max(res,r-l+1)\\n            r+=1\\n\\n        return res\\n\\n# O(nlogn)\\n# O(1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        l,r = 0,0\\n        res,total = 0,0\\n\\n        while r < len(nums):\\n            total += nums[r]\\n\\n            while nums[r] * (r-l+1) > total + k:\\n                total -= nums[l]\\n                l+=1\\n            \\n            res = max(res,r-l+1)\\n            r+=1\\n\\n        return res\\n\\n# O(nlogn)\\n# O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561231,
                "title": "java-sliding-window-with-explanation",
                "content": "```\\n// It is simple sliding window problem but the main condition is little tricky!\\n\\n// sum + k < nums[j] * (j - i + 1)\\n//  i     j\\n// [1, 2, 4] ,k = 4\\n// sum = 7 , sum + k = 11 , nums[j] = 4, j-i+1 = 3\\n// 11 < 4 * 3 --> 11 < 12\\n// what does it mean ?\\n// A valid window look like this --> [4, 4, 4] means all elements are same here we are doing sum + k to find the sum if we completely distributed\\n// our k among the elements in any order like one of them is [1 + 2, 2 + 1 , 4 + 1] --> [3,3,5] the sum is 11.\\n// and the right part is about the sum of valid window we are trying to find [4 , 4, 4] so 4 * 3 --> 4+4+4 is 12 \\n// for making that window valid we need some value of k but we found that even if we completely distributed our k the sum is smaller than the expected sum\\n// we want so we will try to reduce this window by removing ith element \\n\\n\\n\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        int maxFreq = 0;\\n        long sum = 0;\\n        int i = 0;\\n        Arrays.sort(nums);\\n        for(int j = 0; j < nums.length; j++){\\n            sum += nums[j];\\n            while(sum + k < (long)nums[j] * (j - i + 1)){\\n                sum = sum - nums[i];\\n                i++;\\n            }\\n            maxFreq = Math.max(maxFreq , j - i + 1);\\n        }\\n  \\n        return maxFreq;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// It is simple sliding window problem but the main condition is little tricky!\\n\\n// sum + k < nums[j] * (j - i + 1)\\n//  i     j\\n// [1, 2, 4] ,k = 4\\n// sum = 7 , sum + k = 11 , nums[j] = 4, j-i+1 = 3\\n// 11 < 4 * 3 --> 11 < 12\\n// what does it mean ?\\n// A valid window look like this --> [4, 4, 4] means all elements are same here we are doing sum + k to find the sum if we completely distributed\\n// our k among the elements in any order like one of them is [1 + 2, 2 + 1 , 4 + 1] --> [3,3,5] the sum is 11.\\n// and the right part is about the sum of valid window we are trying to find [4 , 4, 4] so 4 * 3 --> 4+4+4 is 12 \\n// for making that window valid we need some value of k but we found that even if we completely distributed our k the sum is smaller than the expected sum\\n// we want so we will try to reduce this window by removing ith element \\n\\n\\n\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        int maxFreq = 0;\\n        long sum = 0;\\n        int i = 0;\\n        Arrays.sort(nums);\\n        for(int j = 0; j < nums.length; j++){\\n            sum += nums[j];\\n            while(sum + k < (long)nums[j] * (j - i + 1)){\\n                sum = sum - nums[i];\\n                i++;\\n            }\\n            maxFreq = Math.max(maxFreq , j - i + 1);\\n        }\\n  \\n        return maxFreq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424312,
                "title": "java-solution-easy-to-understand-beats-100-o-nlogn",
                "content": "# Complexity\\n- Time complexity: $O(Nlogn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{    \\n    public int maxFrequency(int[] A, long k) {\\n        int i = 0, j;\\n        Arrays.sort(A);\\n        for (j = 0; j < A.length; ++j) {\\n            k += A[j];\\n            if (k < (long)A[j] * (j - i + 1))\\n                k -= A[i++];\\n        }\\n        return j - i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution{    \\n    public int maxFrequency(int[] A, long k) {\\n        int i = 0, j;\\n        Arrays.sort(A);\\n        for (j = 0; j < A.length; ++j) {\\n            k += A[j];\\n            if (k < (long)A[j] * (j - i + 1))\\n                k -= A[i++];\\n        }\\n        return j - i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189777,
                "title": "c-solution-using-binary-search-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int i, int k,vector<long long> &pre, vector<int>& nums){\\n        int ind=i;\\n        int j= pre.size()-1;\\n        int ans= i;\\n        while(i<=j){\\n            int mid= i+((j-i)/2);\\n            \\n            if(((1LL*nums[ind]*(mid-ind+1)) - (pre[mid]- (ind==0?0:pre[ind-1]))) > k ) j= mid-1;\\n            \\n            else{\\n                ans= mid;\\n                i= mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        vector<long long> pre= {nums[0]};\\n        for(int i=1;i<nums.size();i++) pre.push_back(nums[i]+pre.back());\\n        \\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int j= find(i,k,pre,nums);\\n            ans= max(ans, j-i+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i, int k,vector<long long> &pre, vector<int>& nums){\\n        int ind=i;\\n        int j= pre.size()-1;\\n        int ans= i;\\n        while(i<=j){\\n            int mid= i+((j-i)/2);\\n            \\n            if(((1LL*nums[ind]*(mid-ind+1)) - (pre[mid]- (ind==0?0:pre[ind-1]))) > k ) j= mid-1;\\n            \\n            else{\\n                ans= mid;\\n                i= mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        vector<long long> pre= {nums[0]};\\n        for(int i=1;i<nums.size();i++) pre.push_back(nums[i]+pre.back());\\n        \\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int j= find(i,k,pre,nums);\\n            ans= max(ans, j-i+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172153,
                "title": "kotlin-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    fun maxFrequency(nums: IntArray, k: Int): Int {\\n        nums.sort()\\n        \\n        var max = 0\\n        var total = 0\\n        var l = 0\\n\\n        for (r in 0 until nums.size) {\\n            total += nums[r]\\n            while (nums[r] * (r - l + 1) - total > k) total -= nums[l++]\\n            max = maxOf(r - l + 1, max)\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sort",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    fun maxFrequency(nums: IntArray, k: Int): Int {\\n        nums.sort()\\n        \\n        var max = 0\\n        var total = 0\\n        var l = 0\\n\\n        for (r in 0 until nums.size) {\\n            total += nums[r]\\n            while (nums[r] * (r - l + 1) - total > k) total -= nums[l++]\\n            max = maxOf(r - l + 1, max)\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841594,
                "title": "simple-and-easy-soln-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxFrequency = function(nums, k) {\\n    nums.sort((a,b)=>a-b);  //O(log N)\\n    let left =0;\\n    let right =0;\\n    let total =0;\\n    let res =0;\\n    while(right<nums.length){\\n        total+= nums[right];\\n\\n        while(nums[right]*(right-left+1) > total+k){\\n            total-=nums[left];\\n            left+=1;\\n        }\\n        res = Math.max(res,right-left+1);\\n        right+=1;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxFrequency = function(nums, k) {\\n    nums.sort((a,b)=>a-b);  //O(log N)\\n    let left =0;\\n    let right =0;\\n    let total =0;\\n    let res =0;\\n    while(right<nums.length){\\n        total+= nums[right];\\n\\n        while(nums[right]*(right-left+1) > total+k){\\n            total-=nums[left];\\n            left+=1;\\n        }\\n        res = Math.max(res,right-left+1);\\n        right+=1;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2705302,
                "title": "go-sliding-window",
                "content": "![image](https://assets.leetcode.com/users/images/a42d2ce9-7dd7-405f-bf81-962f1cf3808d_1665824725.9258885.png)\\n\\n```\\nfunc maxFrequency(nums []int, k int) int {\\n    sort.Ints(nums)\\n    \\n    windowStart := 0\\n    result, sum := 1,0 \\n    for windowEnd := 0; windowEnd < len(nums); windowEnd++ {\\n        sum  += nums[windowEnd]\\n\\t\\t\\n        // do we have enough K to fill in the square?\\n        if nums[windowEnd] * (windowEnd-windowStart+1)  > sum + k {\\n\\t\\t\\t// no we don\\'t and we move the left side\\n            sum -= nums[windowStart]\\n            windowStart++ \\n        }  \\n        \\n        result = max(result, windowEnd-windowStart+1)         \\n    }\\n    return result\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/a42d2ce9-7dd7-405f-bf81-962f1cf3808d_1665824725.9258885.png)\\n\\n```\\nfunc maxFrequency(nums []int, k int) int {\\n    sort.Ints(nums)\\n    \\n    windowStart := 0\\n    result, sum := 1,0 \\n    for windowEnd := 0; windowEnd < len(nums); windowEnd++ {\\n        sum  += nums[windowEnd]\\n\\t\\t\\n        // do we have enough K to fill in the square?\\n        if nums[windowEnd] * (windowEnd-windowStart+1)  > sum + k {\\n\\t\\t\\t// no we don\\'t and we move the left side\\n            sum -= nums[windowStart]\\n            windowStart++ \\n        }  \\n        \\n        result = max(result, windowEnd-windowStart+1)         \\n    }\\n    return result\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2605809,
                "title": "java-clean-beginner-friendly",
                "content": "Clean Java \\nSliding Window + Sorting\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        long[] prefixSum = new long[nums.length];\\n        Arrays.sort(nums);\\n        prefixSum[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; ++i) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        int p1 = 0;\\n        int p2 = 1;\\n        int len = 1;\\n        while (p1 < nums.length && p2 < nums.length) {\\n            long requiredSum = nums[p2] * (p2 - p1 + 1);\\n            long sumWeHave = prefixSum[p2] - (p1 == 0 ? 0 : prefixSum[p1 - 1]);\\n            if (sumWeHave + k  >= requiredSum) {\\n                len = Math.max(len, p2 - p1 + 1);\\n                p2++;\\n            } else {\\n                p1++;\\n            }\\n            \\n        }\\n        return len;\\n    }\\n}\\n```\\nComplexity Time -> NLog(N) (Sorting) + N(prefixSum) + N(two-pointer)\\n\\t\\t\\t\\t\\t\\t\\t->O(NLog(N))\\n\\t\\t\\t\\t Space -> N + N(if we use merge-sort)\\n\\t\\t\\t\\t\\t\\t\\t->O(N)",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        long[] prefixSum = new long[nums.length];\\n        Arrays.sort(nums);\\n        prefixSum[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; ++i) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        int p1 = 0;\\n        int p2 = 1;\\n        int len = 1;\\n        while (p1 < nums.length && p2 < nums.length) {\\n            long requiredSum = nums[p2] * (p2 - p1 + 1);\\n            long sumWeHave = prefixSum[p2] - (p1 == 0 ? 0 : prefixSum[p1 - 1]);\\n            if (sumWeHave + k  >= requiredSum) {\\n                len = Math.max(len, p2 - p1 + 1);\\n                p2++;\\n            } else {\\n                p1++;\\n            }\\n            \\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517889,
                "title": "java-clean-approach-binary-search-sliding-window",
                "content": "1.First we identify the min frequency which means the value can only be present at once.\\n2.The max frequency is the value can be present at all places in the array. which length of the array.\\n3.find the mid value of both the min and max frequency .(using binary search)\\n4.sliding window approach, consider the mid as the window size.\\nEx:- nums = [1,2,4], k = 5 , minFreq=1 and maxFreq=3\\nwindow size is 2, which means [1,2] and [2,4]\\nthe steps required for 1 to be 2 is 1. to determine programmatically\\ntotalSum-windowSum=>(mid*arr[mid-1])-(1+2)=>4-3=1 step\\n\\nnow, increment the mid and window size is 3\\n[1,2,4] =>(3*4)-(1+2+4)=12-7=5 which is <=k. so the max steps is 3.\\n\\nthe above formula is determined by \\n[1,2,4] =>(4-1)+(4-2)+(4-4)\\n=>(4+4+4)-(1+2+4)=>4*3-(1+2+4)\\n=>lastValueindex-(sumOfValues)\\n\\n\\n\\n```\\n public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        //to perform the binary search -- sort the array\\n        //binary search is performed on the minFrequency and maxFrequency\\n        int minFreq=1;\\n        int maxFreq=nums.length;\\n        int ans=0;\\n        while(minFreq<=maxFreq){\\n            int mid =minFreq+(maxFreq-minFreq)/2;//mid is the size of the window\\n            //for [1,4,8,13] the mid is (1+4)/2= 2\\n            if(isPossible(nums,k,mid)){\\n                ans=mid;// this may be the potential answer\\n                minFreq=mid+1;// since we are trying to find the maximum frequency\\n            }else{\\n                maxFreq=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[] nums, int k, int mid){\\n        //sliding window technique\\n        //so the array is formed as [1,4] [4,8] [8,13]\\n        long totalSum=0,windowSum=0;\\n        for(int i=0;i<mid;i++){\\n            windowSum+=nums[i]; //1+4=5\\n        }\\n        totalSum=mid*(long)nums[mid-1]; //2*4=8 \\n        \\n        if(totalSum-windowSum<=k){//8-5=3 so 3 times the 1 has to be incremented to make 4\\n            return true;\\n        }\\n        \\n        int j=0;\\n        //check for the other windows as well\\n        for(int i=mid;i<nums.length;++i){\\n            windowSum-=nums[j];//remove the first value of previous window\\n            windowSum+=nums[i];//add the second value of current window\\n            totalSum=mid* (long)nums[i];\\n            if(totalSum-windowSum<=k)// if can be done in <=K steps \\n                return true;\\n            j++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\n public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        //to perform the binary search -- sort the array\\n        //binary search is performed on the minFrequency and maxFrequency\\n        int minFreq=1;\\n        int maxFreq=nums.length;\\n        int ans=0;\\n        while(minFreq<=maxFreq){\\n            int mid =minFreq+(maxFreq-minFreq)/2;//mid is the size of the window\\n            //for [1,4,8,13] the mid is (1+4)/2= 2\\n            if(isPossible(nums,k,mid)){\\n                ans=mid;// this may be the potential answer\\n                minFreq=mid+1;// since we are trying to find the maximum frequency\\n            }else{\\n                maxFreq=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[] nums, int k, int mid){\\n        //sliding window technique\\n        //so the array is formed as [1,4] [4,8] [8,13]\\n        long totalSum=0,windowSum=0;\\n        for(int i=0;i<mid;i++){\\n            windowSum+=nums[i]; //1+4=5\\n        }\\n        totalSum=mid*(long)nums[mid-1]; //2*4=8 \\n        \\n        if(totalSum-windowSum<=k){//8-5=3 so 3 times the 1 has to be incremented to make 4\\n            return true;\\n        }\\n        \\n        int j=0;\\n        //check for the other windows as well\\n        for(int i=mid;i<nums.length;++i){\\n            windowSum-=nums[j];//remove the first value of previous window\\n            windowSum+=nums[i];//add the second value of current window\\n            totalSum=mid* (long)nums[i];\\n            if(totalSum-windowSum<=k)// if can be done in <=K steps \\n                return true;\\n            j++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488597,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maxFrequency(int[] arr, int k) {\\n        if(arr.length==1) return 1;\\n        Arrays.sort(arr);\\n        int sum=arr[0];                          \\n        int res=Integer.MIN_VALUE;\\n        int j=0;\\n        int i=0;\\n           while(j<=i&&i<arr.length){\\n            \\n                if(arr[i]*(i-j+1)-sum<=k){\\n                res=Math.max(i-j+1,res);\\n                i++;\\n                if(i<arr.length){\\n                sum+=arr[i];\\n                 }\\n            }\\n            else{\\n                  sum-=arr[j];\\n                  j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] arr, int k) {\\n        if(arr.length==1) return 1;\\n        Arrays.sort(arr);\\n        int sum=arr[0];                          \\n        int res=Integer.MIN_VALUE;\\n        int j=0;\\n        int i=0;\\n           while(j<=i&&i<arr.length){\\n            \\n                if(arr[i]*(i-j+1)-sum<=k){\\n                res=Math.max(i-j+1,res);\\n                i++;\\n                if(i<arr.length){\\n                sum+=arr[i];\\n                 }\\n            }\\n            else{\\n                  sum-=arr[j];\\n                  j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423929,
                "title": "binary-seaxrh-2-pointer",
                "content": "```\\n// i have to find a maximun size window in that i can make all my element in that window equal to an selected element or similar\\n// so basically i can perform opertion on random items\\n// i can\\'t perform operation on element which is bigger then my selected element\\n// so i have to sort it\\n// and start from last element\\n// and apply opertions on items before my last element\\n// ab jo window bnegi wo last se mid ki rhegi\\n// mid se start hogi or last m end\\nint maxFrequency(vector<int> &nums, int k)\\n{\\n    sort(nums.begin(), nums.end());\\n    vector<long long> preSum = {nums[0]};\\n    for (int i = 1; i < nums.size(); i++) // prefixSum is needed to check how many operation already have\\n        preSum.push_back(preSum[i - 1] + nums[i]);\\n\\n    int frequentElement = 1;\\n    for (long long i = nums.size() - 1; i >= 1; i--)\\n    {\\n        int start = 0, end = i;\\n        while (start < end)\\n        {\\n            int mid = start + (end - start) / 2;\\n            int len = i - mid; // window length\\n            long long neededUnit = len * 1LL * nums[i]; // hume kitne operation ki unit chahiye\\n            long long unitWeHave = preSum[i - 1] - (mid - 1 >= 0 ? preSum[mid - 1] : 0); // of kitni operation unit apne pass h\\n            int needed = neededUnit - unitWeHave;       // dono ko minus krne pe pta chlega ki kitni operation hum perform kr skte h\\n            if (needed <= k)   // agr operation is less then given operation that means that this can be our answer\\n            {\\n                end = mid; // ab hum window ki size ko bda rhe h\\n            }\\n            else\\n            {\\n                start = mid + 1; // agr needed operation jada h to window ki size ko kam kro\\n            }\\n        }\\n        frequentElement = max(frequentElement, (int)(i - start + 1)); // yaha pe hum freq element nikl rhe h by window length\\n    }\\n    return frequentElement;\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\n// i have to find a maximun size window in that i can make all my element in that window equal to an selected element or similar\\n// so basically i can perform opertion on random items\\n// i can\\'t perform operation on element which is bigger then my selected element\\n// so i have to sort it\\n// and start from last element\\n// and apply opertions on items before my last element\\n// ab jo window bnegi wo last se mid ki rhegi\\n// mid se start hogi or last m end\\nint maxFrequency(vector<int> &nums, int k)\\n{\\n    sort(nums.begin(), nums.end());\\n    vector<long long> preSum = {nums[0]};\\n    for (int i = 1; i < nums.size(); i++) // prefixSum is needed to check how many operation already have\\n        preSum.push_back(preSum[i - 1] + nums[i]);\\n\\n    int frequentElement = 1;\\n    for (long long i = nums.size() - 1; i >= 1; i--)\\n    {\\n        int start = 0, end = i;\\n        while (start < end)\\n        {\\n            int mid = start + (end - start) / 2;\\n            int len = i - mid; // window length\\n            long long neededUnit = len * 1LL * nums[i]; // hume kitne operation ki unit chahiye\\n            long long unitWeHave = preSum[i - 1] - (mid - 1 >= 0 ? preSum[mid - 1] : 0); // of kitni operation unit apne pass h\\n            int needed = neededUnit - unitWeHave;       // dono ko minus krne pe pta chlega ki kitni operation hum perform kr skte h\\n            if (needed <= k)   // agr operation is less then given operation that means that this can be our answer\\n            {\\n                end = mid; // ab hum window ki size ko bda rhe h\\n            }\\n            else\\n            {\\n                start = mid + 1; // agr needed operation jada h to window ki size ko kam kro\\n            }\\n        }\\n        frequentElement = max(frequentElement, (int)(i - start + 1)); // yaha pe hum freq element nikl rhe h by window length\\n    }\\n    return frequentElement;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366259,
                "title": "c-sliding-window-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxFrequency(vector<int>& nums, int k) {\\n\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\n\\t\\t\\tlong  n = nums.size();\\n\\t\\t\\tlong  i = 0;\\n\\t\\t\\tlong  j = 0; \\n\\n\\t\\t\\tlong  ans = 1;\\n\\t\\t\\tlong  sum = 0;\\n\\n\\t\\t\\twhile(j < n) {\\n\\n\\t\\t\\t\\tsum += nums[j];\\n\\n\\t\\t\\t\\twhile((j-i+1)*nums[j]- sum > k and i <= j) {\\n\\n\\t\\t\\t\\t\\tsum -= nums[i];\\n\\t\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans = max(ans, j-i+1);\\n\\t\\t\\t\\t++j;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};\\n\\t//upvote if helps.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxFrequency(vector<int>& nums, int k) {\\n\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\n\\t\\t\\tlong  n = nums.size();\\n\\t\\t\\tlong  i = 0;\\n\\t\\t\\tlong  j = 0; \\n\\n\\t\\t\\tlong  ans = 1;\\n\\t\\t\\tlong  sum = 0;\\n\\n\\t\\t\\twhile(j < n) {\\n\\n\\t\\t\\t\\tsum += nums[j];\\n\\n\\t\\t\\t\\twhile((j-i+1)*nums[j]- sum > k and i <= j) {\\n\\n\\t\\t\\t\\t\\tsum -= nums[i];\\n\\t\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2201355,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution \\n{\\n    public int maxFrequency(int[] nums, int s) \\n    {\\n        long k = s;\\n        Arrays.sort(nums);\\n        int i = 0;\\n        int j = 1;\\n        long sum = nums[0];\\n        int max = 1;\\n        while(j < nums.length)\\n        {\\n            int val = nums[j];\\n            \\n            if(sum+k >= val*(j-i))\\n            {\\n                max = Math.max(max,j-i+1);\\n                sum+=val;\\n                j++;\\n            }\\n            else\\n            {\\n                while(sum+k < val*(j-i))\\n                {\\n                    sum-=nums[i];\\n                    i++;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maxFrequency(int[] nums, int s) \\n    {\\n        long k = s;\\n        Arrays.sort(nums);\\n        int i = 0;\\n        int j = 1;\\n        long sum = nums[0];\\n        int max = 1;\\n        while(j < nums.length)\\n        {\\n            int val = nums[j];\\n            \\n            if(sum+k >= val*(j-i))\\n            {\\n                max = Math.max(max,j-i+1);\\n                sum+=val;\\n                j++;\\n            }\\n            else\\n            {\\n                while(sum+k < val*(j-i))\\n                {\\n                    sum-=nums[i];\\n                    i++;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198479,
                "title": "javascript-clean-and-concise-code-sliding-window-with-explanation",
                "content": "**`\\tPlease UPVOTE if it helped`**\\n\\t\\n\\tnums=nums.sort((a,b)=>a-b)\\n    \\n    let sum=nums[0]\\n    let i=0\\n    let res=1;\\n    for (let j=1 ;j<nums.length;j++){\\n        \\n        //using 2 pointers and sliding window approach.The key concept is to create sliding windows using i and j\\n        //pointers and checking the answer(max frequency of max element) for each window by the \\n        //condition sum+k<max1*(j-i+1) .  It states that the sum of the window elements +k should be equal or \\n        // greater than the product of maxElement of window and the length of the window for a window to have\\n        // all maxElements in k operations.If the condition fails,then we try to reduce the window size by\\n        //incrementing the left pointer(removing the smallest element of thw window) .\\n        \\n        sum+=nums[j];\\n        let max1=nums[j];\\n        while(sum+k<max1*(j-i+1)){\\n            sum-=nums[i];\\n            i=i+1;\\n            \\n        }\\n         res=Math.max(res,j-i+1)\\n        \\n    }\\n    return res\\n}",
                "solutionTags": [],
                "code": "**`\\tPlease UPVOTE if it helped`**\\n\\t\\n\\tnums=nums.sort((a,b)=>a-b)\\n    \\n    let sum=nums[0]\\n    let i=0\\n    let res=1;\\n    for (let j=1 ;j<nums.length;j++){\\n        \\n        //using 2 pointers and sliding window approach.The key concept is to create sliding windows using i and j\\n        //pointers and checking the answer(max frequency of max element) for each window by the \\n        //condition sum+k<max1*(j-i+1) .  It states that the sum of the window elements +k should be equal or \\n        // greater than the product of maxElement of window and the length of the window for a window to have\\n        // all maxElements in k operations.If the condition fails,then we try to reduce the window size by\\n        //incrementing the left pointer(removing the smallest element of thw window) .\\n        \\n        sum+=nums[j];\\n        let max1=nums[j];\\n        while(sum+k<max1*(j-i+1)){\\n            sum-=nums[i];\\n            i=i+1;\\n            \\n        }\\n         res=Math.max(res,j-i+1)\\n        \\n    }\\n    return res\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2123848,
                "title": "c-step-by-step-sliding-window-o-n-logn",
                "content": "```\\nint maxFrequency(vector<int>& nums, int k) {\\n        /*\\n        Time: O(N*logN) - sorting input array\\n        Space: O(1)\\n        \\n        Sliding Window\\n        Goal: Maximize the window length where all the values in that window is the same.\\n        -This requirement, required sum, can be computed using the largest value of the window multiplied by the length of the window. \\n        -How do we know if our window is valid? Have the current sum added with k be equal to or greater than required sum.\\n        \\n        STEP 1: Sort input array. Why? So we know that the largest value of the window is always to the right\\n        \\n        STEP 2: Like common sliding window technique, have 2 pointers: left and right starting at the beginning. \\n        Shift right pointer and increment sum. Check if sum meet requirement (length of window multiplied by rightmost (since largest on the right of sorted))\\n        \\n        STEP 3: If window is invalid, decrement window length. This also changes required sum and current sum.\\n        Required sum is decremented by max value because reqSum is now max_value multiplied by old_window_length-1.\\n        Decrement current sum by leftmost value and also increment left pointer because it has shifted.\\n        \\n        STEP: Update maximum window length after finding a valid window\\n        */    \\n        \\n        int N=nums.size();          // size of input array\\n        int l=0, r=0;               // left and right pointers\\n        long winLen=0;              // length of current window\\n        long curSum=k, reqSum=0;    // current sum - always include k, and required sum\\n        int output=0;               // length of longest valid window\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        while( r<N)\\n        {\\n            winLen = r-l+1;\\n            reqSum = nums[r] * winLen; // max element in current window multiplied by window length\\n            curSum += nums[r];       \\n            \\n            // if current sum is too small (reduce required sum by reducing window length)\\n            while(curSum < reqSum)\\n            {\\n                --winLen;\\n                reqSum -= nums[r];  // reduce required sum\\n                curSum -= nums[l];  // also reduce current sum because window has been shrunk\\n                ++l;\\n            }\\n            if( output < winLen)\\n                output = winLen;\\n            ++r;\\n        }\\n        return output;\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nint maxFrequency(vector<int>& nums, int k) {\\n        /*\\n        Time: O(N*logN) - sorting input array\\n        Space: O(1)\\n        \\n        Sliding Window\\n        Goal: Maximize the window length where all the values in that window is the same.\\n        -This requirement, required sum, can be computed using the largest value of the window multiplied by the length of the window. \\n        -How do we know if our window is valid? Have the current sum added with k be equal to or greater than required sum.\\n        \\n        STEP 1: Sort input array. Why? So we know that the largest value of the window is always to the right\\n        \\n        STEP 2: Like common sliding window technique, have 2 pointers: left and right starting at the beginning. \\n        Shift right pointer and increment sum. Check if sum meet requirement (length of window multiplied by rightmost (since largest on the right of sorted))\\n        \\n        STEP 3: If window is invalid, decrement window length. This also changes required sum and current sum.\\n        Required sum is decremented by max value because reqSum is now max_value multiplied by old_window_length-1.\\n        Decrement current sum by leftmost value and also increment left pointer because it has shifted.\\n        \\n        STEP: Update maximum window length after finding a valid window\\n        */    \\n        \\n        int N=nums.size();          // size of input array\\n        int l=0, r=0;               // left and right pointers\\n        long winLen=0;              // length of current window\\n        long curSum=k, reqSum=0;    // current sum - always include k, and required sum\\n        int output=0;               // length of longest valid window\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        while( r<N)\\n        {\\n            winLen = r-l+1;\\n            reqSum = nums[r] * winLen; // max element in current window multiplied by window length\\n            curSum += nums[r];       \\n            \\n            // if current sum is too small (reduce required sum by reducing window length)\\n            while(curSum < reqSum)\\n            {\\n                --winLen;\\n                reqSum -= nums[r];  // reduce required sum\\n                curSum -= nums[l];  // also reduce current sum because window has been shrunk\\n                ++l;\\n            }\\n            if( output < winLen)\\n                output = winLen;\\n            ++r;\\n        }\\n        return output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084151,
                "title": "c-o-n-logn-very-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int> &nums, int k) {\\n        int result = 1, subArrStart = 0;\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        for (int i = 0; i < nums.size(); ++i) {\\n            k -= nums[subArrStart] - nums[i];\\n\\n            while (k < 0)\\n                k += (nums[subArrStart] - nums[subArrStart + 1]) * (i - subArrStart++);\\n\\n            result = max(result, i - subArrStart + 1);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int> &nums, int k) {\\n        int result = 1, subArrStart = 0;\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        for (int i = 0; i < nums.size(); ++i) {\\n            k -= nums[subArrStart] - nums[i];\\n\\n            while (k < 0)\\n                k += (nums[subArrStart] - nums[subArrStart + 1]) * (i - subArrStart++);\\n\\n            result = max(result, i - subArrStart + 1);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029615,
                "title": "easy-explanation-using-binary-search-c",
                "content": "Since, 1<= **nums**[t] <= 100000\\n\\nSo, to find the maximum frequency count after doing at most k operations can be shown as:-\\n\\n**val**= (maximum frequency of element  **i** after doing at most **k** operations) \\n\\nTo get the answer we can take the maximum of **val** at every element **i**\\n\\nTo find **val** for every element **i** are  the following steps :-\\n\\n* Sort the **nums** array \\n* make a prefix sum array of arrays **nums**\\n* Now, for evey element **i** we need to find location of element equal to **i** or just less than **i** in the  **nums** array ( can be found using upper bound on sorted array **nums**), let say it come out to be **e**\\nNow, we need to find **j** such that it satisfy the below eqation:-\\n\\n  **(element)(length)-Sum of elements in nums from index j to e<=k** <br>\\n\\t\\t\\t\\t\\t\\t   ``i * (e - j + 1)- (sum[e] - sum[j - 1]) <= k``<br>\\n\\t\\t\\t\\t\\t\\t   ``` sum[j - 1] - i * j <= i * (e + 1) + sum[e]```\\t\\n\\t\\t\\t\\t\\t\\t  \\nWe know the  RHS, now we need to find **lowest j** such that it satisfy the above equation....\\nthis can be easily done in** log(N)** using binary search.<br>\\n``ans = max( ans, e - j + 1)``\\n\\n\\n\\n\\n```\\n#define fitr(i,a,b) for(auto i=a;i<b;i++)\\n#define ll long long int \\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        ll pref[n];\\n        pref[0]=nums[0];\\n        fitr(i,1,n){\\n            pref[i]=nums[i]+pref[i-1];\\n        }\\n        int ans=0;\\n        fitr(i,1,100001){\\n             auto itr=upper_bound(nums.begin(),nums.end(),i);\\n             if(itr==nums.begin()) continue;\\n             itr--;\\n             int f;\\n             int e=itr-nums.begin();\\n             f=e;\\n             int s=0;\\n             ll cmp=k+pref[e]-1ll*i*(e+1);\\n             while(s<e){\\n                  int mid=(s+e)/2;\\n                  ll val=0;\\n                  if(mid!=0) val=pref[mid-1]-1ll*mid*i;\\n                  if(val<=cmp) e=mid;\\n                  else s=mid+1;\\n             }\\n             ans=max(ans,f-s+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "``` sum[j - 1] - i * j <= i * (e + 1) + sum[e]```\n```\\n#define fitr(i,a,b) for(auto i=a;i<b;i++)\\n#define ll long long int \\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        ll pref[n];\\n        pref[0]=nums[0];\\n        fitr(i,1,n){\\n            pref[i]=nums[i]+pref[i-1];\\n        }\\n        int ans=0;\\n        fitr(i,1,100001){\\n             auto itr=upper_bound(nums.begin(),nums.end(),i);\\n             if(itr==nums.begin()) continue;\\n             itr--;\\n             int f;\\n             int e=itr-nums.begin();\\n             f=e;\\n             int s=0;\\n             ll cmp=k+pref[e]-1ll*i*(e+1);\\n             while(s<e){\\n                  int mid=(s+e)/2;\\n                  ll val=0;\\n                  if(mid!=0) val=pref[mid-1]-1ll*mid*i;\\n                  if(val<=cmp) e=mid;\\n                  else s=mid+1;\\n             }\\n             ans=max(ans,f-s+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012533,
                "title": "python-intuitive-binary-search",
                "content": "## it\\'s obviouse that if we treat increment conservatively, we\\'ll also get same maximum possible frequency\\n        e.g. when we have nums [5,6,100], k = 5, we stay on [6,6,100] to get freq 2, we don\\'t spend all increment to [8,8,100], it\\'s a useless waste\\n\\n## the maximum possible frequency number exist in nums\\n        if all occurrence of maximum possible frequency number is increased by other number\\n        then it can also by reached by decreasing every member by 1, it\\'s not conservative enough\\n        so if we follow the previous rule, our most frequenced number is in original nums, and increased only from lower nums\\n\\n        So, for each N, we are searching for AMAP nums lower than it, and could increase to N within k increments, and find out who can get greatest freq\\n\\n        For each N, it\\'s intuitive to sort nums. and find from right the left to check out how much member we can absorb by greedy, since the closer to N, the less cost we need to cut from k\\n\\n## opt one:\\n        rather think of how to distribute your increments, we can think of finding max range to the left of N that sums + k over N * len\\n\\n## opt two:\\n        if you\\'re keeping suming subarray, you can accumulate once and substract from accumalated array\\n\\n## opt three:\\n        search from right to the left, and memorize the same value and skip it,\\n        becouse it can not be better than the same value on the right\\n## code \\n---\\n```python\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    def maxFrequency(self, nums, k):\\n        nums.sort()\\n        acc_sums = list(accumulate(nums))\\n\\n        max_freq, visit = 1, set()\\n\\n        for j in range(len(nums) - 1, 0, -1):\\n            # skip same value on the left\\n            if nums[j] not in visit:\\n                visit.add(nums[j])\\n\\n                l, r = 0, j\\n                while l < r:\\n                    m = l + r >> 1\\n\\n                    if acc_sums[j] - acc_sums[m] + nums[m] + k < (j - m + 1) * nums[j]:\\n                        l = m + 1\\n                    else:\\n                        r = m\\n\\n                freq = j - l + 1\\n\\n                max_freq = max(max_freq, freq)\\n\\n        return max_freq\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```python\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    def maxFrequency(self, nums, k):\\n        nums.sort()\\n        acc_sums = list(accumulate(nums))\\n\\n        max_freq, visit = 1, set()\\n\\n        for j in range(len(nums) - 1, 0, -1):\\n            # skip same value on the left\\n            if nums[j] not in visit:\\n                visit.add(nums[j])\\n\\n                l, r = 0, j\\n                while l < r:\\n                    m = l + r >> 1\\n\\n                    if acc_sums[j] - acc_sums[m] + nums[m] + k < (j - m + 1) * nums[j]:\\n                        l = m + 1\\n                    else:\\n                        r = m\\n\\n                freq = j - l + 1\\n\\n                max_freq = max(max_freq, freq)\\n\\n        return max_freq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978678,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        long long left = 0, sum = 0, maxLen = 0;\\n        for(int right=0;right<n;right++){\\n            \\n            sum += nums[right];\\n            \\n            while(left < right && nums[right] * (right-left+1) > sum + k){\\n                sum -= nums[left];\\n                left++;\\n            }\\n            \\n            maxLen = max(maxLen,right-left+1);\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        long long left = 0, sum = 0, maxLen = 0;\\n        for(int right=0;right<n;right++){\\n            \\n            sum += nums[right];\\n            \\n            while(left < right && nums[right] * (right-left+1) > sum + k){\\n                sum -= nums[left];\\n                left++;\\n            }\\n            \\n            maxLen = max(maxLen,right-left+1);\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891324,
                "title": "python3-sliding-window-2-pointers-o-nlogn",
                "content": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        i=cur=res=0\\n        for j in range(len(nums)):\\n            cur+=nums[j]\\n            while nums[j]*(j-i+1)-cur>k:\\n                cur-=nums[i]\\n                i+=1\\n            res=max(res,j-i+1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        i=cur=res=0\\n        for j in range(len(nums)):\\n            cur+=nums[j]\\n            while nums[j]*(j-i+1)-cur>k:\\n                cur-=nums[i]\\n                i+=1\\n            res=max(res,j-i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837089,
                "title": "very-simple-sliding-window-technique-in-c",
                "content": "```\\nint maxFrequency(vector<int>& nums, int k) {\\n        \\n        long i=0,ans=-1,sum=0;\\n        sort(nums.begin(),nums.end());\\n\\t\\t\\n        for(int j=0;j<nums.size();j++){    \\n            sum=sum+nums[j];\\n            \\n            while((j-i+1) * nums[j] - sum > k){        //  Why is (j - i + 1) * nums[j] - sum <= k valid?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //(j - i + 1) is the length of the window [i, j]. We want to increase all the\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //numbers in the window to equal nums[j], the number of operations \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //needed is (j - i + 1) * nums[j] - sum which should be <= k. For example, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //assume the window is [1,2,3], increasing all the numbers to 3 will take \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //3 * 3 - (1 + 2 + 3) operations.\\n                sum=sum-nums[i];\\n                i++;\\n            }\\n            ans = max(ans,j-i+1);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint maxFrequency(vector<int>& nums, int k) {\\n        \\n        long i=0,ans=-1,sum=0;\\n        sort(nums.begin(),nums.end());\\n\\t\\t\\n        for(int j=0;j<nums.size();j++){    \\n            sum=sum+nums[j];\\n            \\n            while((j-i+1) * nums[j] - sum > k){        //  Why is (j - i + 1) * nums[j] - sum <= k valid?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //(j - i + 1) is the length of the window [i, j]. We want to increase all the\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //numbers in the window to equal nums[j], the number of operations \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //needed is (j - i + 1) * nums[j] - sum which should be <= k. For example, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //assume the window is [1,2,3], increasing all the numbers to 3 will take \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //3 * 3 - (1 + 2 + 3) operations.\\n                sum=sum-nums[i];\\n                i++;\\n            }\\n            ans = max(ans,j-i+1);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1796790,
                "title": "easy-solution-intuition-vizualization-easy-to-understand-o-nlogn",
                "content": "I am posting it in the hope it helps someone else. I struggled with this for a couple of hours before looking at the solution. And even then, it took me some time to understand.\\n\\nThe basic idea is represented in this picture:\\n* You have to pre-sort the array\\n\\n\\n![image](https://assets.leetcode.com/users/images/d1e67f14-282e-49e1-8f24-5131c4399aa9_1645723680.542154.png)\\n\\n\\nSo here\\'s my explained code if you struggle. Code is made longer to add as much info\\n\\n```\\n    def maxFrequency(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        # This can be visually understood as a game of blocks\\n        #    Each num is a block of width 1, and height = num value \\n        #    You have k extra blocks, \\n        #    The field has blocks that you can\\'t change sorted from low (left) to high (right)\\n\\n        # You role is to use your extra blocks to make the widest rectangle you can build\\n        # You will start placing your extra blocks on the left\\n        extra_blocks = k\\n        field_blocks = sorted(nums) # sorted ascending small to big\\n        \\n        \\n        field_area_used = 0 # This depends on many elements of the field you want to use to build your rectangle\\n        left_pos = 0\\n        max_width = 0 # The widest rectange we have built so far\\n        \\n        # Make sure we explore all possibilities\\n        for right_pos in range(len(field_blocks)):\\n            \\n            \\n            \\n            # This is a function of how many field blocks we are using. \\n            # Sum the blocks from each num height between left and right pos (the area of the field used) \\n            field_area_used = field_area_used + field_blocks[right_pos] \\n            \\n            # params for the rectangle we can potentially build\\n            #    We precompute the width of the rectangle that start at left_pos and end at the last block added\\n            required_width = right_pos - left_pos + 1 \\n            #    This is how many blocks we would need to fill this rectangle (the area)\\n            required_blocks = field_blocks[right_pos] * required_width\\n            \\n            \\n            \\n            \\n            # If the current amount of blocks available plus the extra cannot fill the rectangle, shrink it\\n            while left_pos <= right_pos and field_area_used + extra_blocks < required_blocks:\\n                # We won\\'t be able to complete enough new rows to match required blocks, so we shrink our field area\\n                #    Remove the most left block\\n                field_area_used = field_area_used - field_blocks[left_pos]\\n                #    Adjust computing params\\n                left_pos = left_pos + 1\\n                required_width = right_pos - left_pos + 1 \\n                #    this is the amount of blocks for the new rectangle\\n                required_blocks = field_blocks[right_pos] * required_width\\n            \\n            \\n            \\n            # keep track of largest block width we have had\\n            # if we are here we have been able to successfully build a rectangle.\\n            # but it might not be the largest. But if it is, record it\\n            max_width = max_width if max_width > required_width else required_width\\n                \\n                \\n        return max_width\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n    def maxFrequency(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        # This can be visually understood as a game of blocks\\n        #    Each num is a block of width 1, and height = num value \\n        #    You have k extra blocks, \\n        #    The field has blocks that you can\\'t change sorted from low (left) to high (right)\\n\\n        # You role is to use your extra blocks to make the widest rectangle you can build\\n        # You will start placing your extra blocks on the left\\n        extra_blocks = k\\n        field_blocks = sorted(nums) # sorted ascending small to big\\n        \\n        \\n        field_area_used = 0 # This depends on many elements of the field you want to use to build your rectangle\\n        left_pos = 0\\n        max_width = 0 # The widest rectange we have built so far\\n        \\n        # Make sure we explore all possibilities\\n        for right_pos in range(len(field_blocks)):\\n            \\n            \\n            \\n            # This is a function of how many field blocks we are using. \\n            # Sum the blocks from each num height between left and right pos (the area of the field used) \\n            field_area_used = field_area_used + field_blocks[right_pos] \\n            \\n            # params for the rectangle we can potentially build\\n            #    We precompute the width of the rectangle that start at left_pos and end at the last block added\\n            required_width = right_pos - left_pos + 1 \\n            #    This is how many blocks we would need to fill this rectangle (the area)\\n            required_blocks = field_blocks[right_pos] * required_width\\n            \\n            \\n            \\n            \\n            # If the current amount of blocks available plus the extra cannot fill the rectangle, shrink it\\n            while left_pos <= right_pos and field_area_used + extra_blocks < required_blocks:\\n                # We won\\'t be able to complete enough new rows to match required blocks, so we shrink our field area\\n                #    Remove the most left block\\n                field_area_used = field_area_used - field_blocks[left_pos]\\n                #    Adjust computing params\\n                left_pos = left_pos + 1\\n                required_width = right_pos - left_pos + 1 \\n                #    this is the amount of blocks for the new rectangle\\n                required_blocks = field_blocks[right_pos] * required_width\\n            \\n            \\n            \\n            # keep track of largest block width we have had\\n            # if we are here we have been able to successfully build a rectangle.\\n            # but it might not be the largest. But if it is, record it\\n            max_width = max_width if max_width > required_width else required_width\\n                \\n                \\n        return max_width\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1743087,
                "title": "java-sorting-and-sliding-window-solution-99-5-faster",
                "content": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length, ans = 1, cost = 0, sum = 0;\\n        for (int l = 0, r = 0; r<n; r++) {\\n            cost = (r-l) * nums[r] - sum;\\n            sum += nums[r];\\n            while (cost>k) {\\n                sum-=nums[l];\\n                cost-=(nums[r]-nums[l]);\\n                l++;\\n            }\\n            ans = Math.max(ans, r-l+1);\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length, ans = 1, cost = 0, sum = 0;\\n        for (int l = 0, r = 0; r<n; r++) {\\n            cost = (r-l) * nums[r] - sum;\\n            sum += nums[r];\\n            while (cost>k) {\\n                sum-=nums[l];\\n                cost-=(nums[r]-nums[l]);\\n                l++;\\n            }\\n            ans = Math.max(ans, r-l+1);\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739896,
                "title": "binary-search-and-nlogn-complexity",
                "content": "so basically the whole problem reduces to binary search as we will check if we can make elements equal to the ith element or not and then we will apply binary search. the main observation here also is that we have to check also that if a certain element is less than our required value and the element next to it is more than the required value then we have to break our loop at that time.\\n\\nint maxFrequency(vector<int>& nums, int k) {\\n        \\n     long long int i;\\n       long long int n=nums.size(),ans=0;\\n       long long int low,high,mid,c,d;\\n        sort(nums.begin(),nums.end());\\n      vector<long long> dp(n);\\n        int sum=0;\\n        dp[0]=nums[0];\\n        for(i=1;i<n;i++){\\n            dp[i]=dp[i-1]+(long long int)nums[i];\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        \\n        for(i=n-1;i>=1;i--){\\n            low=0;\\n        high=i-1;\\n              \\n            while(low<=high){\\n                mid=(high+low)/2;\\n                c=(i-mid)*(long long int)(nums[i])-(dp[i]-dp[mid]);\\n                if(c==k){\\n                    ans=max(ans,i-mid);\\n                    break;\\n                }\\n                if(c<k){\\n                    ans=max(ans,i-mid);\\n                    high=mid-1;\\n                }\\n                if(c>k){\\n                    low=mid+1;\\n                } \\n                if(mid!=0){\\n                    \\n                     d=(i-mid+1)*(long long int)(nums[i])-(dp[i]-dp[mid-1]);\\n                    if(c<k&&d>k){\\n                        break;\\n                    }\\n                   \\n                }     \\n            }\\n           \\n            if(((i+1)*(long long int)nums[i]-dp[i])<=k){\\n                ans=max(ans,i+1);\\n            }\\n              \\n        }\\n        \\n        return ans;\\n        \\n    }\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "so basically the whole problem reduces to binary search as we will check if we can make elements equal to the ith element or not and then we will apply binary search. the main observation here also is that we have to check also that if a certain element is less than our required value and the element next to it is more than the required value then we have to break our loop at that time.\\n\\nint maxFrequency(vector<int>& nums, int k) {\\n        \\n     long long int i;\\n       long long int n=nums.size(),ans=0;\\n       long long int low,high,mid,c,d;\\n        sort(nums.begin(),nums.end());\\n      vector<long long> dp(n);\\n        int sum=0;\\n        dp[0]=nums[0];\\n        for(i=1;i<n;i++){\\n            dp[i]=dp[i-1]+(long long int)nums[i];\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        \\n        for(i=n-1;i>=1;i--){\\n            low=0;\\n        high=i-1;\\n              \\n            while(low<=high){\\n                mid=(high+low)/2;\\n                c=(i-mid)*(long long int)(nums[i])-(dp[i]-dp[mid]);\\n                if(c==k){\\n                    ans=max(ans,i-mid);\\n                    break;\\n                }\\n                if(c<k){\\n                    ans=max(ans,i-mid);\\n                    high=mid-1;\\n                }\\n                if(c>k){\\n                    low=mid+1;\\n                } \\n                if(mid!=0){\\n                    \\n                     d=(i-mid+1)*(long long int)(nums[i])-(dp[i]-dp[mid-1]);\\n                    if(c<k&&d>k){\\n                        break;\\n                    }\\n                   \\n                }     \\n            }\\n           \\n            if(((i+1)*(long long int)nums[i]-dp[i])<=k){\\n                ans=max(ans,i+1);\\n            }\\n              \\n        }\\n        \\n        return ans;\\n        \\n    }\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1727671,
                "title": "java-sorting-sliding-window",
                "content": "class Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n    int l=0;\\n        int r=0;\\n        long total=0;\\n        int len=1;\\n        Arrays.sort(nums);\\n        while(r<nums.length){\\n           total+=nums[r];\\n            while((total+k)<(r-l+1)*(long)nums[r]){\\n             total-=nums[l++];\\n          }\\n      \\n            len=Math.max(len,r-l+1);\\n            r++;\\n        }\\n        return len;\\n        }\\n}",
                "solutionTags": [
                    "String",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n    int l=0;\\n        int r=0;\\n        long total=0;\\n        int len=1;\\n        Arrays.sort(nums);\\n        while(r<nums.length){\\n           total+=nums[r];\\n            while((total+k)<(r-l+1)*(long)nums[r]){\\n             total-=nums[l++];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1579530,
                "title": "c-sliding-window",
                "content": "\\n\\n```\\n int maxFrequency(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        sort(nums.begin(), nums.end());\\n        long sum = 0;\\n        int res = 0;\\n        while(j < nums.size()) {\\n            while((long)nums[j]*(j-i) - sum > k) {\\n                sum -= nums[i];\\n                i++;\\n            }\\n            \\n            res = max(res, j-i+1);\\n            \\n            sum += nums[j];\\n            j++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n```\\n int maxFrequency(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        sort(nums.begin(), nums.end());\\n        long sum = 0;\\n        int res = 0;\\n        while(j < nums.size()) {\\n            while((long)nums[j]*(j-i) - sum > k) {\\n                sum -= nums[i];\\n                i++;\\n            }\\n            \\n            res = max(res, j-i+1);\\n            \\n            sum += nums[j];\\n            j++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1501638,
                "title": "c-sliding-window",
                "content": "```\\nint maxFrequency(vector<int> A, int k) {\\n\\tint res = 1, i = 0, j;\\n\\tlong sum = 0;\\n\\tsort(A.begin(), A.end());\\n\\tfor (j = 0; j < A.size(); ++j) {\\n\\t\\tsum += A[j];\\n\\t\\twhile (sum + k < (long)A[j] * (j - i + 1)) {\\n\\t\\t\\tsum -= A[i];\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tres = max(res, j - i + 1);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint maxFrequency(vector<int> A, int k) {\\n\\tint res = 1, i = 0, j;\\n\\tlong sum = 0;\\n\\tsort(A.begin(), A.end());\\n\\tfor (j = 0; j < A.size(); ++j) {\\n\\t\\tsum += A[j];\\n\\t\\twhile (sum + k < (long)A[j] * (j - i + 1)) {\\n\\t\\t\\tsum -= A[i];\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tres = max(res, j - i + 1);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390906,
                "title": "c-simple-solution-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        long long int i = 0, j = 1, res = 1;\\n        \\n        while(j < n) {\\n            k -= (j-i)*(nums[j]-nums[j-1]);\\n            \\n            while(i < j && k < 0)\\n                k += nums[j]-nums[i], i++;\\n            \\n            res = max(res, j-i+1);\\n            j++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        long long int i = 0, j = 1, res = 1;\\n        \\n        while(j < n) {\\n            k -= (j-i)*(nums[j]-nums[j-1]);\\n            \\n            while(i < j && k < 0)\\n                k += nums[j]-nums[i], i++;\\n            \\n            res = max(res, j-i+1);\\n            j++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327578,
                "title": "c-sliding-window-solution-o-nlogn",
                "content": "Runtime: 196 ms, faster than 83.88% of C++ online submissions for Frequency of the Most Frequent Element.\\nMemory Usage: 99 MB, less than 86.63% of C++ online submissions for Frequency of the Most Frequent Element.\\n\\nIntuition for solving this problem is to consider a window with all numbers less than the current number.\\nInorder to solve the problem we have to take a number x and check if total sum of numbers (<=x) + K >=\\nnumber count * x. So, to get all numbers <= x for every number we need to sort the array first.\\nTo check Sum + K >= Size * x for every number x of given array we can now use Sliding Window approach from left\\nto right. As long as condition is meet we expand window and for invalid case we shrink window cause for\\ncurrent number x the min value of the window does not satisfy the validity condition, shrinking window\\nwill result decrement of Size and Sum which later may satisfy the validity condition.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(n==1) return 1;\\n        \\n        // sort array for performing sliding window\\n        sort(nums.begin(),nums.end());\\n        \\n        // first and last pointer \\n        int first = 0;\\n        int last = 0;\\n        \\n        // sum of elements from first to last pointer of cuurent window\\n        long long int sum = nums[last];\\n        \\n        // result of max freq number and base value 1\\n        int result = 1;\\n        \\n        // loop through array and check valid condition over diff sliding windows\\n        while(first < n && last < n)\\n        {\\n            // expand current window if follows the condition :  Sum + K >= Size * Max\\n            while((sum+k) >= (long long int)(last-first+1)*nums[last])\\n            {\\n                // update result of max freq\\n                result = max(result,last-first+1);\\n                \\n                // update sum and increment last pointer\\n                if(last<n-1)\\n                    sum+=nums[++last];\\n                else break;\\n            }\\n            \\n            // for invalid condition shrink window by increment first and update sum\\n            sum-=nums[first++];\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(n==1) return 1;\\n        \\n        // sort array for performing sliding window\\n        sort(nums.begin(),nums.end());\\n        \\n        // first and last pointer \\n        int first = 0;\\n        int last = 0;\\n        \\n        // sum of elements from first to last pointer of cuurent window\\n        long long int sum = nums[last];\\n        \\n        // result of max freq number and base value 1\\n        int result = 1;\\n        \\n        // loop through array and check valid condition over diff sliding windows\\n        while(first < n && last < n)\\n        {\\n            // expand current window if follows the condition :  Sum + K >= Size * Max\\n            while((sum+k) >= (long long int)(last-first+1)*nums[last])\\n            {\\n                // update result of max freq\\n                result = max(result,last-first+1);\\n                \\n                // update sum and increment last pointer\\n                if(last<n-1)\\n                    sum+=nums[++last];\\n                else break;\\n            }\\n            \\n            // for invalid condition shrink window by increment first and update sum\\n            sum-=nums[first++];\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266052,
                "title": "javascript-short-and-easy-to-understand-solution",
                "content": "Runtime: 248 ms, faster than 49.56% of JavaScript online submissions for Frequency of the Most Frequent Element.\\nMemory Usage: 54.6 MB, less than 46.02% of JavaScript online submissions for Frequency of the Most Frequent Element.\\n```\\nvar maxFrequency = function(nums, k) {\\n     nums.sort((a,b)=>a-b);\\n    let res = 1;\\n    let sum = nums[1]-nums[0];\\n    if(sum<=k) res = 2;\\n    for(let i = 2, j = 0; i < nums.length; i++){\\n        sum+=(nums[i]-nums[i-1])*(i-j);\\n        while(sum>k) sum-=(nums[i]-nums[j]), j++;\\n        res = Math.max(i-j+1,res);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxFrequency = function(nums, k) {\\n     nums.sort((a,b)=>a-b);\\n    let res = 1;\\n    let sum = nums[1]-nums[0];\\n    if(sum<=k) res = 2;\\n    for(let i = 2, j = 0; i < nums.length; i++){\\n        sum+=(nums[i]-nums[i-1])*(i-j);\\n        while(sum>k) sum-=(nums[i]-nums[j]), j++;\\n        res = Math.max(i-j+1,res);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261021,
                "title": "easy-nlogn-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 1, n = nums.size();\\n        long long pref[n];\\n        pref[0] = nums[0];\\n        for(int i = 1; i < n; i++) pref[i] = pref[i - 1] + nums[i];\\n        \\n        for(int i = 1; i < n; i++) {\\n            int low = 0, high = i;\\n            while(low <= high) {\\n                int mid = low + (high - low) / 2;\\n                long long required_sum = (long long)(i - mid + 1) * nums[i];\\n                long long curr_sum = (mid == 0) ? pref[i] : pref[i] - pref[mid - 1];\\n                long long diff = required_sum - curr_sum;\\n                if(diff <= k) {\\n                    ans = max(ans, i - mid + 1);\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 1, n = nums.size();\\n        long long pref[n];\\n        pref[0] = nums[0];\\n        for(int i = 1; i < n; i++) pref[i] = pref[i - 1] + nums[i];\\n        \\n        for(int i = 1; i < n; i++) {\\n            int low = 0, high = i;\\n            while(low <= high) {\\n                int mid = low + (high - low) / 2;\\n                long long required_sum = (long long)(i - mid + 1) * nums[i];\\n                long long curr_sum = (mid == 0) ? pref[i] : pref[i] - pref[mid - 1];\\n                long long diff = required_sum - curr_sum;\\n                if(diff <= k) {\\n                    ans = max(ans, i - mid + 1);\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243495,
                "title": "java-sorting-sliding-window-with-running-k-early-exit",
                "content": "```\\npublic int maxFrequency(int[] nums, int k) {\\n        int maxFreq = 1;\\n        Arrays.sort(nums);\\n        // i is always the end of the window\\n        // keep on pushing wS (window start) towards the left for every i\\n        // then start wS with i again for next iteration\\n\\t\\t// maintain a runningK for every iteration\\n        int i = nums.length -1;\\n        while(i>=0){\\n            int runningK = k;\\n            int currNum = nums[i];\\n            int wS = i;\\n            while(wS>=0 && currNum - nums[wS] <= runningK){\\n                runningK = runningK - (currNum - nums[wS]);\\n                maxFreq = Math.max(maxFreq, i - wS + 1);\\n                wS--;\\n            }\\n\\n            while(i>=0 && nums[i] == currNum){\\n                i--;\\n            }\\n\\t\\t\\t// early exit\\n            if(maxFreq > i+1){\\n                break;\\n            }\\n        }\\n        return maxFreq;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxFrequency(int[] nums, int k) {\\n        int maxFreq = 1;\\n        Arrays.sort(nums);\\n        // i is always the end of the window\\n        // keep on pushing wS (window start) towards the left for every i\\n        // then start wS with i again for next iteration\\n\\t\\t// maintain a runningK for every iteration\\n        int i = nums.length -1;\\n        while(i>=0){\\n            int runningK = k;\\n            int currNum = nums[i];\\n            int wS = i;\\n            while(wS>=0 && currNum - nums[wS] <= runningK){\\n                runningK = runningK - (currNum - nums[wS]);\\n                maxFreq = Math.max(maxFreq, i - wS + 1);\\n                wS--;\\n            }\\n\\n            while(i>=0 && nums[i] == currNum){\\n                i--;\\n            }\\n\\t\\t\\t// early exit\\n            if(maxFreq > i+1){\\n                break;\\n            }\\n        }\\n        return maxFreq;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1243373,
                "title": "c-sort-sliding-window-with-explanation",
                "content": "The sliding window here works as follows: say we have a subarray [1,2,3]. We need to check whether it\\'s possible to \\'drag\\' 1 and 2 up to 3 using k to get [3,3,3] and thus increase the frequency of 3. So the condition is k >= (3 + 3 + 3) - (1 + 2 + 3) as we need (3 - 1) + (3 - 2) + (3 - 3) points to do this. Otherwise, we shrink the array from the left until the condition is satistied.\\n```\\nclass Solution {\\npublic:    \\n    int maxFrequency(vector<int>& nums, int k)\\n    {\\n        sort(nums.begin(),nums.end());\\n        \\n        size_t l{ 0 };\\n        size_t r{ 0 };\\n        size_t max{ 0 };\\n        int64_t sum{ 0 };\\n        \\n        while (r < nums.size())\\n        {\\n            sum += nums[r];\\n            size_t len{ r - l + 1 };\\n            \\n            // len * nums[r] == sum([3,3,3])\\n            // sum + k == sum[1,2,3] + k\\n            while (len * nums[r] > sum + k)\\n            {\\n                sum -= nums[l];\\n                --len;\\n                ++l;\\n            }\\n            \\n            max = std::max(max, len);\\n            ++r;           \\n        }\\n        \\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    int maxFrequency(vector<int>& nums, int k)\\n    {\\n        sort(nums.begin(),nums.end());\\n        \\n        size_t l{ 0 };\\n        size_t r{ 0 };\\n        size_t max{ 0 };\\n        int64_t sum{ 0 };\\n        \\n        while (r < nums.size())\\n        {\\n            sum += nums[r];\\n            size_t len{ r - l + 1 };\\n            \\n            // len * nums[r] == sum([3,3,3])\\n            // sum + k == sum[1,2,3] + k\\n            while (len * nums[r] > sum + k)\\n            {\\n                sum -= nums[l];\\n                --len;\\n                ++l;\\n            }\\n            \\n            max = std::max(max, len);\\n            ++r;           \\n        }\\n        \\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226588,
                "title": "java-solution-sort-then-sliding-window-with-comments",
                "content": "\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums); //sort the given array\\n        int ans=1; //default is one since min answer could be one\\n        int j=1; \\n        int i=0; //j is the head and i is the tail\\n       while(j>=i&&j<nums.length){ \\n           int dif=nums[j]-nums[j-1]; // difference of j and j-1\\n           \\n           // we will keep all the values in the sliding window same\\n           // by adding (or subtracting from k) to get it to the latest value.\\n           // Here, we check if we have enough to add the difference to\\n           //all the values in the sliding window. if we do, we subtract it from k,\\n           // incremnet j(head) and update the answer. If not, we remove the i th value\\n           // from the sliding window. Since all the values in the sliding window\\n           // is the latest value (j-1 th), therefore k+=nums[j-1]-nums[i]. \\n           \\n           if(k>=dif*(j-i)){ \\n               k=k-dif*(j-i); \\n               ans=Math.max(ans, j-i+1);\\n               j++;\\n               \\n           }else{\\n               k+=nums[j-1]-nums[i];\\n               i++;\\n               \\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums); //sort the given array\\n        int ans=1; //default is one since min answer could be one\\n        int j=1; \\n        int i=0; //j is the head and i is the tail\\n       while(j>=i&&j<nums.length){ \\n           int dif=nums[j]-nums[j-1]; // difference of j and j-1\\n           \\n           // we will keep all the values in the sliding window same\\n           // by adding (or subtracting from k) to get it to the latest value.\\n           // Here, we check if we have enough to add the difference to\\n           //all the values in the sliding window. if we do, we subtract it from k,\\n           // incremnet j(head) and update the answer. If not, we remove the i th value\\n           // from the sliding window. Since all the values in the sliding window\\n           // is the latest value (j-1 th), therefore k+=nums[j-1]-nums[i]. \\n           \\n           if(k>=dif*(j-i)){ \\n               k=k-dif*(j-i); \\n               ans=Math.max(ans, j-i+1);\\n               j++;\\n               \\n           }else{\\n               k+=nums[j-1]-nums[i];\\n               i++;\\n               \\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214053,
                "title": "java-easy-sort-two-pointers-commented",
                "content": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n\\t\\n\\t\\t//sort array\\n        Arrays.sort(nums);\\n        int maxFreq = 0;\\n\\t\\t\\n\\t\\t//start from end of array and see how many elements can be made equal to it and update maxfreq if required\\n        for(int i=nums.length-1 ; i>=0 ;i--){\\n          int curr = k;\\n          int freq= 1;\\n          for(int j = i-1 ; j>=0 ; j--){\\n            if(nums[i] - nums[j] <= curr){\\n              freq++;\\n              curr -= nums[i] - nums[j];\\n            }\\n            else\\n              break;\\n          }\\n          maxFreq = Math.max(maxFreq, freq);\\n\\t\\t  \\n\\t\\t  //if current maxfreq is greater or equal to remaining elements in array, we can never get a better maxFreq, so return maxFreq\\n          if(maxFreq >= i+1)\\n            return maxFreq;\\n        }\\n      return maxFreq;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n\\t\\n\\t\\t//sort array\\n        Arrays.sort(nums);\\n        int maxFreq = 0;\\n\\t\\t\\n\\t\\t//start from end of array and see how many elements can be made equal to it and update maxfreq if required\\n        for(int i=nums.length-1 ; i>=0 ;i--){\\n          int curr = k;\\n          int freq= 1;\\n          for(int j = i-1 ; j>=0 ; j--){\\n            if(nums[i] - nums[j] <= curr){\\n              freq++;\\n              curr -= nums[i] - nums[j];\\n            }\\n            else\\n              break;\\n          }\\n          maxFreq = Math.max(maxFreq, freq);\\n\\t\\t  \\n\\t\\t  //if current maxfreq is greater or equal to remaining elements in array, we can never get a better maxFreq, so return maxFreq\\n          if(maxFreq >= i+1)\\n            return maxFreq;\\n        }\\n      return maxFreq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208548,
                "title": "java-o-nlogn-time-o-n-space-2-pointers-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i = 0;\\n        int j = 0;\\n        int max = 1;\\n        int n = nums.length;\\n        long sum[] = new long[n];\\n        sum[0] = nums[0];\\n        \\n        for(int q=1;q<n;q++)\\n            sum[q] = sum[q-1] + nums[q];\\n        \\n        while(i<n){\\n            long req = (long)nums[j]*(j-i+1) - (sum[j] - sum[i] + nums[i]);\\n            // System.out.println(i + \" \" + j + \" \" + req + \" \" + k);\\n            if((long)k >= req){\\n                long rem = (k - req)%(j-i+1);\\n                // if(rem != 0){\\n                //     if(j-i+1 != n)\\n                //         max = Math.max(max , j-i+1);\\n                //     else\\n                //         max = Math.max(max , j-i);\\n                // }\\n                // else\\n                // All the above conditions are not used because we can we atmost k operations\\n                // i.e we can skip some of the operations as per our requirement\\n                    max = Math.max(max , j-i+1);\\n                if(j == n-1)\\n                    break;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i = 0;\\n        int j = 0;\\n        int max = 1;\\n        int n = nums.length;\\n        long sum[] = new long[n];\\n        sum[0] = nums[0];\\n        \\n        for(int q=1;q<n;q++)\\n            sum[q] = sum[q-1] + nums[q];\\n        \\n        while(i<n){\\n            long req = (long)nums[j]*(j-i+1) - (sum[j] - sum[i] + nums[i]);\\n            // System.out.println(i + \" \" + j + \" \" + req + \" \" + k);\\n            if((long)k >= req){\\n                long rem = (k - req)%(j-i+1);\\n                // if(rem != 0){\\n                //     if(j-i+1 != n)\\n                //         max = Math.max(max , j-i+1);\\n                //     else\\n                //         max = Math.max(max , j-i);\\n                // }\\n                // else\\n                // All the above conditions are not used because we can we atmost k operations\\n                // i.e we can skip some of the operations as per our requirement\\n                    max = Math.max(max , j-i+1);\\n                if(j == n-1)\\n                    break;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202004,
                "title": "java-sort-two-pointers",
                "content": "Use two pointers i and j to find the max number of elements (j-i+1) with the maximum sum of element differences of k.\\n1. sort all elements O( NlogN )\\n2. expand/contract (i,j) window by keeping a total sum of value differences vs. element j <=k\\n\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        int n= nums.length;\\n        Arrays.sort(nums);\\n        int i=0, j=0, sumDiff= 0, maxDist= 1;\\n        while(true){\\n            if(i==j || sumDiff<=k){// expand\\n                if(++j==n) break;\\n                sumDiff+= (j-i)*(nums[j]-nums[j-1]);\\n                if(sumDiff<=k) maxDist= Math.max(maxDist, j-i+1);\\n            }else{                 //contract\\n                sumDiff-= nums[j]-nums[i++];\\n                if(sumDiff<=k) maxDist= Math.max(maxDist, j-i+1);\\n            }\\n        }\\n        return maxDist;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        int n= nums.length;\\n        Arrays.sort(nums);\\n        int i=0, j=0, sumDiff= 0, maxDist= 1;\\n        while(true){\\n            if(i==j || sumDiff<=k){// expand\\n                if(++j==n) break;\\n                sumDiff+= (j-i)*(nums[j]-nums[j-1]);\\n                if(sumDiff<=k) maxDist= Math.max(maxDist, j-i+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1178219,
                "title": "java-deque-sliding-window-o-nlogn",
                "content": "Idea is the same as others. Just provide another approach, implemented by Deque. It\\'s easier to understand.\\n\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Deque<Integer> dq = new LinkedList<>();\\n        dq.add(nums[0]);\\n        int diff = 0;\\n        int res = 1;\\n        for(int i=1;i<nums.length;i++){\\n            diff+=(nums[i]-dq.peekLast())*dq.size();// We have to fill gap, as we have new standard: nums[i]\\n            while(diff>k){// If so, we need to shrink window by polling smallest number\\n                diff-=nums[i]-dq.pollFirst();;\\n            }\\n            dq.add(nums[i]);\\n            res=Math.max(res,dq.size());\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Deque<Integer> dq = new LinkedList<>();\\n        dq.add(nums[0]);\\n        int diff = 0;\\n        int res = 1;\\n        for(int i=1;i<nums.length;i++){\\n            diff+=(nums[i]-dq.peekLast())*dq.size();// We have to fill gap, as we have new standard: nums[i]\\n            while(diff>k){// If so, we need to shrink window by polling smallest number\\n                diff-=nums[i]-dq.pollFirst();;\\n            }\\n            dq.add(nums[i]);\\n            res=Math.max(res,dq.size());\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178105,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int index, vector<int>& nums, vector<long long>& sum, int k) {\\n        if (index == 0) return 1;\\n\\n        int length = (int) nums.size();\\n        int required = nums[index];\\n        int answer = 0;\\n\\n        int lo = 0, hi = index - 1, mid;\\n        while (lo <= hi) {\\n            mid = lo + (hi - lo) / 2;\\n\\n            long long csum = sum[index - 1] - (mid - 1 >= 0 ? sum[mid - 1] : 0);\\n            long long total = ((long long) (index - mid) * (long long) required) - csum;\\n\\n            if (total <= k) {\\n                hi = mid - 1;\\n                answer = (index - mid + 1);\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int length = (int) nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        vector<long long> sum(length, 0);\\n        for (int i = 0; i < length; i++) {\\n            sum[i] = nums[i];\\n            if (i) sum[i] += sum[i - 1];\\n        }\\n\\n        int answer = 0;\\n        for (int i = 0; i < length; i++) {\\n            answer = max(answer, solve(i, nums, sum, k));\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int index, vector<int>& nums, vector<long long>& sum, int k) {\\n        if (index == 0) return 1;\\n\\n        int length = (int) nums.size();\\n        int required = nums[index];\\n        int answer = 0;\\n\\n        int lo = 0, hi = index - 1, mid;\\n        while (lo <= hi) {\\n            mid = lo + (hi - lo) / 2;\\n\\n            long long csum = sum[index - 1] - (mid - 1 >= 0 ? sum[mid - 1] : 0);\\n            long long total = ((long long) (index - mid) * (long long) required) - csum;\\n\\n            if (total <= k) {\\n                hi = mid - 1;\\n                answer = (index - mid + 1);\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int length = (int) nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        vector<long long> sum(length, 0);\\n        for (int i = 0; i < length; i++) {\\n            sum[i] = nums[i];\\n            if (i) sum[i] += sum[i - 1];\\n        }\\n\\n        int answer = 0;\\n        for (int i = 0; i < length; i++) {\\n            answer = max(answer, solve(i, nums, sum, k));\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176728,
                "title": "java-python-c-sliding-window-with-2-pointers",
                "content": "Approach 1: Sliding window with 2 pointers [C++]  [1]\\nTime/Space: O(NlogN); O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int ans = 1;\\n        sort(nums.begin(), nums.end());\\n        long sums = 0;\\n        for(int r, l = 0; r < nums.size(); r++){\\n            sums += nums[r];\\n            while(l < r && sums + k < long(nums[r]) * (r - l + 1))  sums -= nums[l++];\\n            ans = max(ans, r - l + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2: Sliding window with 2 pointers [python] \\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        ans = 1\\n        nums=sorted(nums)\\n        sums = 0\\n        l = 0\\n        for r in range(len(nums)):\\n            sums += nums[r]\\n            while l < r and sums + k <  nums[r] * (r - l + 1):\\n                sums -= nums[l]\\n                l += 1\\n            ans = max(ans, r - l + 1)\\n        return ans;\\n```\\n\\nApproach 3: Java version\\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        int res = 1, l = 0, r;\\n        long sum = 0;\\n        Arrays.sort(nums);\\n        for (r = 0; r < nums.length; ++r) {\\n            sum += nums[r];\\n            while (sum + k < (long)nums[r] * (r - l + 1)) {\\n                sum -= nums[l];\\n                l += 1;\\n            }\\n            res = Math.max(res, r - l + 1);\\n        }\\n        return res;\\n    }\\n}\\n```\\nReference:\\n[1] https://zxi.mytechroad.com/blog/sliding-window/leetcode-1838-frequency-of-the-most-frequent-element/",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int ans = 1;\\n        sort(nums.begin(), nums.end());\\n        long sums = 0;\\n        for(int r, l = 0; r < nums.size(); r++){\\n            sums += nums[r];\\n            while(l < r && sums + k < long(nums[r]) * (r - l + 1))  sums -= nums[l++];\\n            ans = max(ans, r - l + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        ans = 1\\n        nums=sorted(nums)\\n        sums = 0\\n        l = 0\\n        for r in range(len(nums)):\\n            sums += nums[r]\\n            while l < r and sums + k <  nums[r] * (r - l + 1):\\n                sums -= nums[l]\\n                l += 1\\n            ans = max(ans, r - l + 1)\\n        return ans;\\n```\n```\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        int res = 1, l = 0, r;\\n        long sum = 0;\\n        Arrays.sort(nums);\\n        for (r = 0; r < nums.length; ++r) {\\n            sum += nums[r];\\n            while (sum + k < (long)nums[r] * (r - l + 1)) {\\n                sum -= nums[l];\\n                l += 1;\\n            }\\n            res = Math.max(res, r - l + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176359,
                "title": "c-sort-sliding-window-o-nlogn",
                "content": "We use 2 variables i and j to denote the starting and ending point of the window. Also, we need 3rd variable ops to denote the increment operations we have taken. \\n\\nStarting from the last element, each time we extend i by 1 to the left, and add the operations which is nums[j] - nums[i]. If the oprations <= k, we compare the length j - i + 1 with maximum length and update the result if needed.\\n\\nIf the ops > k, we need to shrink the window by decreasing j (aka moving to the left). Ignore the duplicate elements and find the previous different element. Then we will reduce our operations by the # of (nums[j + 1] - nums[j]) * (j - i + 1). If the ops still > k, do it again, until the ops <= k, and update the max length by j - i + 1 if needed.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int res = 0, size = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for (int i = size - 1, j = size - 1, ops = 0; i >= 0; --i)\\n        {\\n            ops += nums[j] - nums[i];\\n            while (ops > k)\\n            {\\n                --j;\\n                while (nums[j] == nums[j + 1])\\n                {\\n                    --j;\\n                }\\n                \\n                ops -= (j - i + 1) * (nums[j + 1] - nums[j]);\\n            }\\n            \\n            res = max(res, j - i + 1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int res = 0, size = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for (int i = size - 1, j = size - 1, ops = 0; i >= 0; --i)\\n        {\\n            ops += nums[j] - nums[i];\\n            while (ops > k)\\n            {\\n                --j;\\n                while (nums[j] == nums[j + 1])\\n                {\\n                    --j;\\n                }\\n                \\n                ops -= (j - i + 1) * (nums[j + 1] - nums[j]);\\n            }\\n            \\n            res = max(res, j - i + 1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175931,
                "title": "sliding-window-o-nlogn-with-simple-detailed-explaination-c",
                "content": "using sliding window approach\\n   1. Sort the array so that element which have min difference are next to each other\\n   2. left and right represent two end of window, we increase window size by increasing right and decrease\\n       window size by increasing left\\n   3. at any point right most element will tell us how many increase are required so that whole window is of same size (same frequency). Right most element is max element in window as items are sorted. Total increase required is equal to window size * max element in window i.e. A[right] * (right - left + 1). If this number is less that sum (sum of elements in window) + k then it\\'s possible\\n   4. if required sum of window is more than sum + k then we remove element by increasing left\\n   5. We do step 3 and 4 from start to end of array and keep track of max frequency \\n\\n```\\npublic class Solution { \\n    \\n    public int MaxFrequency(int[] nums, int k) {\\n        \\n        Array.Sort(nums);\\n        int res = 1, left = 0, right;\\n        long sum = 0;        \\n        \\n        for (right = 0; right < nums.Length; ++right)\\n        {\\n            sum += nums[right];\\n            while (sum + k < (long)nums[right] * (right - left + 1))\\n            {\\n                sum -= nums[left];\\n                left += 1;\\n            }\\n            res = Math.Max(res, right - left + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution { \\n    \\n    public int MaxFrequency(int[] nums, int k) {\\n        \\n        Array.Sort(nums);\\n        int res = 1, left = 0, right;\\n        long sum = 0;        \\n        \\n        for (right = 0; right < nums.Length; ++right)\\n        {\\n            sum += nums[right];\\n            while (sum + k < (long)nums[right] * (right - left + 1))\\n            {\\n                sum -= nums[left];\\n                left += 1;\\n            }\\n            res = Math.Max(res, right - left + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175728,
                "title": "java-explanation-sliding-window",
                "content": "<B>Explanation:</B>\\n\\nFor understanding of the explanation, let\\'s take this test case given,\\n<B>nums = [1,4,8,13], k = 5</B>\\n\\nStep 1:  The input array is sorted.\\n\\nStep 2: The variables i, res and sum are declared and initialized with values 0, 1 and 0 respectively. i is an iterator variable used in inner for loop since the res is updated outside the scope of the loop i is declared globally, res is the variable to store the final result to be returned and the sum variable is used in the logic for operations.\\n\\nStep 3: The input array is given to iteration, the sum value gets updated to 1 (sum = 1), then in the condition sum+k will be 6 nums[j] * (j-i+1) will be 1 the condition becomes false and the loop terminates.\\n\\nStep 4: The res variable is updated with the maximum value of its current value and j-i+1.(res = 1)\\n\\nStep 5: In the next iteration, sum values is updated to 5 (sum = 5), then in the condition sum+k will be 10 nums[j] * (j-i+1) will be 8 the condition becomes false and the loop terminates.\\n\\nStep 6: The res variable is updated with the maximum value of its current value and j-i+1.(res = 2)\\n\\nStep 7: In the next iteration, sum values is updated to 13 (sum = 13), then in the condition sum+k will be 18 and nums[j] * (j-i+1) will be 24 the condition becomes true and inside the loop the iterator is incremented (i = 1) and sum value is decremented with the i indexed array value.\\n\\nStep 8: Then in the condition sum+k will be 12 and nums[j] * (j-i+1) will be 8 the condition becomes false and the loop terminates.\\n\\nStep 9: The res variable is updated with the maximum value of its current value and j-i+1.(res = 2)\\n\\nStep 10: In the next iteration, sum values is updated to 25 (sum = 25), then in the condition sum+k will be 30 and nums[j] * (j-i+1) will be 13 the condition becomes false and loop gets terminated.\\n\\nStep 11: The res variable is updated with the maximum value of its current value and j-i+1.(res = 2)\\n\\n<B>Actually the core logic behind this is the sliding window which had indefinite length and the variable i plays the part of length (as it increments the current i indexed value is reduced).</B>\\n\\n<B>Solution:</B>\\n\\n```\\nclass Solution \\n{\\n    public int maxFrequency(int[] nums, int k) \\n    {\\n        int res = 1;\\n        int i = 0;\\n        long sum = 0;\\n        Arrays.sort(nums);\\n        for (int j = 0; j < nums.length; j++) \\n        {\\n            sum += nums[j];\\n            while (sum + k < (long)nums[j] * (j - i + 1)) \\n            {\\n                sum -= nums[i];\\n                i += 1;\\n            }\\n            res = Math.max(res, j - i + 1);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n<B>Thanks & Regards\\nHariprasath N</B>",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maxFrequency(int[] nums, int k) \\n    {\\n        int res = 1;\\n        int i = 0;\\n        long sum = 0;\\n        Arrays.sort(nums);\\n        for (int j = 0; j < nums.length; j++) \\n        {\\n            sum += nums[j];\\n            while (sum + k < (long)nums[j] * (j - i + 1)) \\n            {\\n                sum -= nums[i];\\n                i += 1;\\n            }\\n            res = Math.max(res, j - i + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175460,
                "title": "c-prefix-sum-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long cnt=1;\\n        long long pref[nums.size()];\\n        int n=nums.size();\\n        pref[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)pref[i]=pref[i-1]+nums[i];\\n        for(int i=n-1;i>=1;i--)\\n        {\\n            int lo=0, hi=i;\\n            int idx=i;\\n            while(lo<=hi)\\n            {\\n                int mid=(lo+hi)/2;\\n                long long to=pref[i-1]-(mid-1>=0?pref[mid-1]:0);\\n                long long mult=(i-mid)*1LL*nums[i];\\n                long long val=mult-to;\\n                if(val<=k)\\n                {\\n                    idx=mid;\\n                    hi=mid-1;\\n                }\\n                else\\n                {\\n                    lo=mid+1;\\n                }\\n                \\n            }\\n            cnt=max(cnt, (long long)i-idx+1);\\n            \\n            \\n            \\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long cnt=1;\\n        long long pref[nums.size()];\\n        int n=nums.size();\\n        pref[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)pref[i]=pref[i-1]+nums[i];\\n        for(int i=n-1;i>=1;i--)\\n        {\\n            int lo=0, hi=i;\\n            int idx=i;\\n            while(lo<=hi)\\n            {\\n                int mid=(lo+hi)/2;\\n                long long to=pref[i-1]-(mid-1>=0?pref[mid-1]:0);\\n                long long mult=(i-mid)*1LL*nums[i];\\n                long long val=mult-to;\\n                if(val<=k)\\n                {\\n                    idx=mid;\\n                    hi=mid-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1175373,
                "title": "javascript-sliding-window-216ms",
                "content": "```\\nconst mx = Math.max;\\nconst stin = (a) => a.sort((x, y) => x - y);\\nconst maxFrequency = (a, k) => {\\n    stin(a);\\n    let n = a.length;\\n    let m = used = res = 0; // m: left pointer\\n    for (let i = 0; i < n; i++) { // handle [m, i] window\\n        if (i > 0) {\\n            used += (i - m) * (a[i] - a[i - 1]);\\n        }\\n        while (used > k) {\\n            used -= a[i] - a[m];\\n            m++;\\n        }\\n        res = mx(res, i - m + 1);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nconst mx = Math.max;\\nconst stin = (a) => a.sort((x, y) => x - y);\\nconst maxFrequency = (a, k) => {\\n    stin(a);\\n    let n = a.length;\\n    let m = used = res = 0; // m: left pointer\\n    for (let i = 0; i < n; i++) { // handle [m, i] window\\n        if (i > 0) {\\n            used += (i - m) * (a[i] - a[i - 1]);\\n        }\\n        while (used > k) {\\n            used -= a[i] - a[m];\\n            m++;\\n        }\\n        res = mx(res, i - m + 1);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175363,
                "title": "c-sliding-window",
                "content": "```\\n        public int MaxFrequency(int[] nums, int k)\\n        {\\n            Array.Sort(nums);\\n\\n            int output = 0;\\n            int left = 0;\\n            int sum = 0; //Sum of the current window\\n\\n            for (int right = 0; right < nums.Length; right++)\\n            {\\n                sum += nums[right];\\n\\n                // nums[right] * (right - left + 1) - sum\\n                // diff to make the window equal whatever the number is in nums[right]\\n                // For example, if you have  \\n                // 1, 4, 8, 13\\n                // l     r\\n                // 7  4  0 = 11 needed to make array 8 , 8 , 8, 13\\n                while (nums[right] * (right - left + 1) - sum > k)\\n                {\\n                    sum -= nums[left];\\n                    left++;\\n                }\\n\\n                output = Math.Max(output, right - left + 1);\\n            }\\n\\n            return output;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public int MaxFrequency(int[] nums, int k)\\n        {\\n            Array.Sort(nums);\\n\\n            int output = 0;\\n            int left = 0;\\n            int sum = 0; //Sum of the current window\\n\\n            for (int right = 0; right < nums.Length; right++)\\n            {\\n                sum += nums[right];\\n\\n                // nums[right] * (right - left + 1) - sum\\n                // diff to make the window equal whatever the number is in nums[right]\\n                // For example, if you have  \\n                // 1, 4, 8, 13\\n                // l     r\\n                // 7  4  0 = 11 needed to make array 8 , 8 , 8, 13\\n                while (nums[right] * (right - left + 1) - sum > k)\\n                {\\n                    sum -= nums[left];\\n                    left++;\\n                }\\n\\n                output = Math.Max(output, right - left + 1);\\n            }\\n\\n            return output;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175213,
                "title": "binary-search-and-prefix-sum-c-explanation-easy-to-understand",
                "content": "First we sort the given array.\\nThe idea is to apply Binary Search from `s`=2 to e=n where mid= `s`+(`e`-`s`)/2 denotes the maximum possible frequency of an element in the array.\\n\\nTo calculate how many operations will be required to convert an `mid` number of elements equal to `nums[i]`.\\nIf we have an array nums=[1,4,8,13] and suppose mid=3 and we want 3 elements to be 13 then,\\noperations = (13-8)+(13-4)= (13 * 2) -(8+4)= `nums[i]`* (mid-1) -(`prefix[i-1]`- `prefix[i-mid]`). \\nWe iterate through the nums array and find a possibility of getting operations<=k just once.\\nIf we get operations<=k once , we increment `s`=`mid`+1 else `e`=`mid`-1.\\n\\t\\n**Code**\\n\\t\\n```\\n\\tint maxFrequency(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long int>prefix;\\n        long long int sum=0;\\n        unordered_map<int,int>ump;\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            prefix.push_back(sum);\\n            ump[nums[i]]++;\\n            ans=max(ans,ump[nums[i]]);\\n        }\\n        int s=2;\\n        int e=n;\\n        int mid;\\n        while(s<=e){\\n            mid= s+(e-s)/2;\\n            bool flag=false;\\n            for(int i=n-1;i>=mid-1;i--){\\n                long long int s1;\\n                long long int s2;\\n                if(i-mid<0)\\n                    s1=0;\\n                else\\n                    s1= prefix[i-mid];\\n                s2= prefix[i-1];\\n                long long int ops= ((long long int)nums[i]*(mid-1))- (s2-s1);\\n                if(ops<=k){\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag==true){\\n                s=mid+1;\\n                ans= max(ans,mid);\\n            }   \\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n            \\n    }",
                "solutionTags": [],
                "code": "First we sort the given array.\\nThe idea is to apply Binary Search from `s`=2 to e=n where mid= `s`+(`e`-`s`)/2 denotes the maximum possible frequency of an element in the array.\\n\\nTo calculate how many operations will be required to convert an `mid` number of elements equal to `nums[i]`.\\nIf we have an array nums=[1,4,8,13] and suppose mid=3 and we want 3 elements to be 13 then,\\noperations = (13-8)+(13-4)= (13 * 2) -(8+4)= `nums[i]`* (mid-1) -(`prefix[i-1]`- `prefix[i-mid]`). \\nWe iterate through the nums array and find a possibility of getting operations<=k just once.\\nIf we get operations<=k once , we increment `s`=`mid`+1 else `e`=`mid`-1.\\n\\t\\n**Code**\\n\\t\\n```\\n\\tint maxFrequency(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long int>prefix;\\n        long long int sum=0;\\n        unordered_map<int,int>ump;\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            prefix.push_back(sum);\\n            ump[nums[i]]++;\\n            ans=max(ans,ump[nums[i]]);\\n        }\\n        int s=2;\\n        int e=n;\\n        int mid;\\n        while(s<=e){\\n            mid= s+(e-s)/2;\\n            bool flag=false;\\n            for(int i=n-1;i>=mid-1;i--){\\n                long long int s1;\\n                long long int s2;\\n                if(i-mid<0)\\n                    s1=0;\\n                else\\n                    s1= prefix[i-mid];\\n                s2= prefix[i-1];\\n                long long int ops= ((long long int)nums[i]*(mid-1))- (s2-s1);\\n                if(ops<=k){\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag==true){\\n                s=mid+1;\\n                ans= max(ans,mid);\\n            }   \\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n            \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1175206,
                "title": "c-brute-force-with-some-optimizations",
                "content": "Counted the frequencies of all the elements and then did the brute force ```i.e```. tried to make current element as the maximum frequency element.\\n\\n```\\nclass Solution {\\npublic:    \\n    int maxFrequency(vector<int>& nums, int k) {\\n        if((int)nums.size() < 2) return nums.size();\\n        unordered_map<int, int> mp;\\n        for (int num: nums) {\\n            ++mp[num];\\n        }\\n        vector<pair<int, int> > r;\\n        for (pair<int, int> pp: mp) {\\n            r.push_back(pp);\\n        }\\n        sort(r.begin(), r.end());\\n        ans = r[0].second;\\n        //try all the possibilities\\n        for (int i = 1; i < (int)r.size(); ++i) {\\n            int curCost = k, prev = i - 1, cur = r[i].second;\\n            while(curCost > 0 && prev >= 0) {\\n                //this much needed to transform one element\\n                int cost = r[i].first - r[prev].first;\\n                int possible = curCost/cost;\\n\\t\\t\\t\\t//if we can\\'t take this element at all.\\n                if(possible <= 0) break;\\n                cur += min(possible, r[prev].second);\\n                curCost = curCost - cost * min(possible, r[prev].second);\\n                --prev;\\n            }\\n            ans = max(cur, ans);\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "```i.e```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175174,
                "title": "my-sliding-window-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxFrequency(int[] nums, int k) {\\n        if (nums.Length == 1) return 1;\\n        var max = 1;\\n\\t\\t\\n\\t\\t// first sort the numbers\\n        Array.Sort(nums);\\n\\t\\t// generate a diff array such that, nums:[1,4,8,13] -> diffArr:[3,4,5]\\n        var diffArr = new int[nums.Length - 1];\\n        for (int a = 0; a < diffArr.Length; a++)\\n        {\\n            diffArr[a] = nums[a+1] - nums[a];\\n        }\\n        \\n\\t\\t// perform sliding window operation on the diffArr\\n\\t\\t// start from the end of the diffArr\\n        var i = diffArr.Length - 1;\\n        var j = i;\\n\\t\\t// cumulativeDiff is the key of the problem, say for nums:[1,2,4], diffArr:[1,2]\\n\\t\\t// when we expand the sliding window from right to left, we cannot just account the diff between that 2 numbers, \\n\\t\\t// but should include all the diff starting from the target number\\n        var cumulativeDiff = diffArr[diffArr.Length-1];\\n        k -= diffArr[diffArr.Length-1];\\n        for (; j >= 0; j--)\\n        {\\n            while (k >= 0 && i > 0)  // while k >= 0, we have valid result, and can continue expanding window\\n            {\\n                max = Math.Max(max, j-i+2); // +2 because diffArr is one less element than nums array\\n                i--;  // expand the window to the left\\n                k -= diffArr[i] + cumulativeDiff;  // deduct from k (i cell diff + cumulativeDiff)\\n                cumulativeDiff += diffArr[i];  // include the i cell diff into cumulativeDiff\\n            }\\n            \\n\\t\\t\\tif (k >= 0 && i == 0)  // handle case of i==0, no need to continue the loop\\n\\t\\t\\t{\\n                max = Math.Max(max, j-i+2);\\n                break;\\n            }\\n            \\n            k += diffArr[j] * (j-i+1);  // free up j cell diff * number of elements, because it is in the cumulativeDiff subtracted from k in each step\\n            cumulativeDiff -= diffArr[j]; // deduct j cell diff from the cumulativeDiff\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxFrequency(int[] nums, int k) {\\n        if (nums.Length == 1) return 1;\\n        var max = 1;\\n\\t\\t\\n\\t\\t// first sort the numbers\\n        Array.Sort(nums);\\n\\t\\t// generate a diff array such that, nums:[1,4,8,13] -> diffArr:[3,4,5]\\n        var diffArr = new int[nums.Length - 1];\\n        for (int a = 0; a < diffArr.Length; a++)\\n        {\\n            diffArr[a] = nums[a+1] - nums[a];\\n        }\\n        \\n\\t\\t// perform sliding window operation on the diffArr\\n\\t\\t// start from the end of the diffArr\\n        var i = diffArr.Length - 1;\\n        var j = i;\\n\\t\\t// cumulativeDiff is the key of the problem, say for nums:[1,2,4], diffArr:[1,2]\\n\\t\\t// when we expand the sliding window from right to left, we cannot just account the diff between that 2 numbers, \\n\\t\\t// but should include all the diff starting from the target number\\n        var cumulativeDiff = diffArr[diffArr.Length-1];\\n        k -= diffArr[diffArr.Length-1];\\n        for (; j >= 0; j--)\\n        {\\n            while (k >= 0 && i > 0)  // while k >= 0, we have valid result, and can continue expanding window\\n            {\\n                max = Math.Max(max, j-i+2); // +2 because diffArr is one less element than nums array\\n                i--;  // expand the window to the left\\n                k -= diffArr[i] + cumulativeDiff;  // deduct from k (i cell diff + cumulativeDiff)\\n                cumulativeDiff += diffArr[i];  // include the i cell diff into cumulativeDiff\\n            }\\n            \\n\\t\\t\\tif (k >= 0 && i == 0)  // handle case of i==0, no need to continue the loop\\n\\t\\t\\t{\\n                max = Math.Max(max, j-i+2);\\n                break;\\n            }\\n            \\n            k += diffArr[j] * (j-i+1);  // free up j cell diff * number of elements, because it is in the cumulativeDiff subtracted from k in each step\\n            cumulativeDiff -= diffArr[j]; // deduct j cell diff from the cumulativeDiff\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175154,
                "title": "java-solution",
                "content": "```\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int i : nums) {\\n            sum += i;\\n        }\\n        int len = nums.length;\\n        int res = -1;\\n        for (int i = len - 1; i>= 0; i--) {\\n            if (nums[i] * (i + 1) > sum + k) {\\n                sum -= nums[i];\\n                continue;\\n            } else {\\n                res = i + 1;\\n                break;\\n            }\\n        }\\n        return res;        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int i : nums) {\\n            sum += i;\\n        }\\n        int len = nums.length;\\n        int res = -1;\\n        for (int i = len - 1; i>= 0; i--) {\\n            if (nums[i] * (i + 1) > sum + k) {\\n                sum -= nums[i];\\n                continue;\\n            } else {\\n                res = i + 1;\\n                break;\\n            }\\n        }\\n        return res;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175075,
                "title": "python-3-two-pointers-o-sort-solution-with-explanation-beats-100",
                "content": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        #find the longest subarray with (end element of the subarray) * (length of subarray) - (sum of current subarray) <= k\\n        l = 0\\n        s = 0\\n        res = 1\\n        n = len(nums)\\n        for r in range(n):\\n            s += nums[r]\\n            \\n            while l < r and nums[r] * (r - l + 1) - s > k:\\n                s -= nums[l]\\n                l += 1\\n            \\n            res = max(res, r - l + 1)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        #find the longest subarray with (end element of the subarray) * (length of subarray) - (sum of current subarray) <= k\\n        l = 0\\n        s = 0\\n        res = 1\\n        n = len(nums)\\n        for r in range(n):\\n            s += nums[r]\\n            \\n            while l < r and nums[r] * (r - l + 1) - s > k:\\n                s -= nums[l]\\n                l += 1\\n            \\n            res = max(res, r - l + 1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094898,
                "title": "python-nlogn-hindi-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        max_freq = 0\\n        # Sort the Array\\n        nums.sort()\\n        curr_sum = 0\\n        maximum_freq = 0\\n        left = 0\\n        for right in range(len(nums)):\\n            curr_sum += nums[right]\\n            while nums[right] * (right - left + 1) > curr_sum + k:\\n                # Ideal case all the elements if same then the sum is the max_number_in array which is right as array is sorted * size of window\\n                # Check karo abhi kitna sum hai.\\n                # K hai hamare pass extra masala==> Agar hum abhi add krde curr_sum+k kya yeh kam hai fir bhi ideal sum se?\\n                # If yes to yeh window bahut badi hai and hum nahi bana sakte sabko equal to the window_max\\n                # Window Shrink Kardo and aage badh jao.\\n                curr_sum -= nums[left]\\n                left += 1\\n            maximum_freq = max(maximum_freq, right - left + 1)\\n        return maximum_freq\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```python\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        max_freq = 0\\n        # Sort the Array\\n        nums.sort()\\n        curr_sum = 0\\n        maximum_freq = 0\\n        left = 0\\n        for right in range(len(nums)):\\n            curr_sum += nums[right]\\n            while nums[right] * (right - left + 1) > curr_sum + k:\\n                # Ideal case all the elements if same then the sum is the max_number_in array which is right as array is sorted * size of window\\n                # Check karo abhi kitna sum hai.\\n                # K hai hamare pass extra masala==> Agar hum abhi add krde curr_sum+k kya yeh kam hai fir bhi ideal sum se?\\n                # If yes to yeh window bahut badi hai and hum nahi bana sakte sabko equal to the window_max\\n                # Window Shrink Kardo and aage badh jao.\\n                curr_sum -= nums[left]\\n                left += 1\\n            maximum_freq = max(maximum_freq, right - left + 1)\\n        return maximum_freq\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084253,
                "title": "easy-c-variable-sliding-window-sorting-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long maxLen=1;\\n        long long i=0;\\n        long long j=1;\\n        long long sum=nums[0];\\n        while(j<nums.size()){\\n            int maxValue=nums[j];\\n            if((long long)(maxValue*((j-i)+1))-(long long)(sum+nums[j]) <=(long long)k){\\n                cout<<sum<<\" \"<<(j-i)+1<<endl;\\n                maxLen=max(maxLen,(j-i)+1);\\n                sum+=nums[j];\\n                j++;\\n            }\\n            else{\\n                sum-=nums[i];\\n                i++;\\n            }\\n        }\\n\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        long long maxLen=1;\\n        long long i=0;\\n        long long j=1;\\n        long long sum=nums[0];\\n        while(j<nums.size()){\\n            int maxValue=nums[j];\\n            if((long long)(maxValue*((j-i)+1))-(long long)(sum+nums[j]) <=(long long)k){\\n                cout<<sum<<\" \"<<(j-i)+1<<endl;\\n                maxLen=max(maxLen,(j-i)+1);\\n                sum+=nums[j];\\n                j++;\\n            }\\n            else{\\n                sum-=nums[i];\\n                i++;\\n            }\\n        }\\n\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4079127,
                "title": "dynamic-sliding-window-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to add some elements to make it till the largest and that operation should be less than equal to k times, so this thing, we need to do in all the smallest element from largest elements. And we need to find the maximum number which can be made as equal to the largest element. i.e frequency of a number which is repeating some number of time after k operations.\\n\\nFor instance:\\n\\nIf I have [1,4,8] , k=3\\n\\nFirstly, I\\'ll try to make all the elements as 1, but for elements larger than 1, I can\\'t do that, as only incremental operation is allowed. My answer would be 1(frequency) if I just have 1 in the array, i.e I don\\'t need to do any operation to make 1 as 1 as it is already there. So in this case k=0(no operation required) which is less than equal to 3 (Atmost 3 given in problem), so this can be our potential answer with frequency of 1 as 1.\\n\\nNext we need to try to make all the elements as 4:\\nWe can do this by increasing 1 by 3, which is it will make it 4. Now we can do this in 3 operation, i.e 3<=k , so its allowed. Therefore, we can make the elements as [4,4,8] in 3 operation, it is allowed.\\n\\nNext we see for 8, we need to increase 1 by 7 and 4 by 4 i.e require 11 operations which is more than 3, so we would not proceed. \\n\\nNow the point here is, we are trying to make all the smaller elements as equal to the largest element within that subarray. So the summ for all the elements after k operation would be LargestElementValue*(number of elements), now this value should always be less than or equal to (number of operation)+sum(of alements in that range prior to modification). This is the main equation that we require. Based upon this condition, we can move pointers, i and j.\\n\\n\\nFor getting this condition, consider 2 examples:\\n\\n[4,5] -> with k=1, we can do this and make both of them as [5,5]\\n         i.e large*number <= k+sum(old)\\n\\n[5,5] -> we don\\'t need to do, so here large * number == 0+10\\n\\nWe see that, we want to make left side all the elements same till k operation, i.e desired state from [4,5] after k operations is [5,5] so it will be 5*2 - Left side should be clear, And right side would be original sum of element which is 9 + k operations.\\n\\nI took some time to figure this out, but this is good question. Obviously read some discussions to come up on this. My thought process was on similar lines, but I was having difficulty in understanding the condition.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n- Time complexity: For sorting it is O(nlogn) else we are processing each element once, so it is O(n) for subsequent steps of sliding window.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums = sorted(nums)\\n        n=len(nums)\\n        i=0\\n        j=0\\n        ans=-10**9\\n        summ=0\\n        while j<n:\\n            summ+=nums[j]\\n            if nums[j]*(j-i+1)<=k+summ:\\n                ans = max(ans,j-i+1)\\n                j+=1\\n            else:\\n                while(nums[j]*(j-i+1)>k+summ):\\n                    summ-=nums[i]\\n                    i+=1\\n                j+=1\\n        return ans\\n\\n```\\n\\nThis solution I have written for my understanding purpose, might help someone else as well.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums = sorted(nums)\\n        n=len(nums)\\n        i=0\\n        j=0\\n        ans=-10**9\\n        summ=0\\n        while j<n:\\n            summ+=nums[j]\\n            if nums[j]*(j-i+1)<=k+summ:\\n                ans = max(ans,j-i+1)\\n                j+=1\\n            else:\\n                while(nums[j]*(j-i+1)>k+summ):\\n                    summ-=nums[i]\\n                    i+=1\\n                j+=1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064280,
                "title": "neetcode-soultion-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**I took help from Neetcode.**\\n# https://www.youtube.com/watch?v=vgBrQ0NM5vE\\n\\nThe problem asks us to find the maximum frequency of an element in the given array such that we can perform at most k operations to increase any element\\'s value to any desired value. The intuition behind this solution is to use a sliding window technique to efficiently find the maximum frequency. The sliding window will help keep track of a subarray where all elements can be increased to a common value using at most k operations\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize two pointers, l and r, both starting at index 0, a total variable to keep track of the sum of elements in the current window, and a res variable to store the maximum frequency found so far.\\n\\nIterate r from 0 to n-1, where n is the length of the nums array:\\n\\n1. Add the current element nums[r] to the total.\\n\\n2. Check if the cost of making all elements in the window equal to nums[r] is greater than k. If it is, increment l to shrink the window and reduce the cost.\\n\\n3. Update the res variable with the maximum frequency found in the current window.\\n\\nContinue this process until r reaches the end of the array.\\n\\nThe res variable will store the maximum frequency, which is the answer to the problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The solution uses a sliding window technique, and both l and r traverse the array once. Therefore, the time complexity is O(n), where n is the length of the nums array.\\n\\nSpace Complexity: \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses a constant amount of extra space, so the space complexity is O(1).\\n\\nOverall, this solution efficiently finds the maximum frequency of an element within the given constraints by maintaining a sliding window and has a linear time complexity.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        \\n        #using sliding window technique\\n        # https://www.youtube.com/watch?v=vgBrQ0NM5vE\\n\\n        nums = sorted(nums)\\n\\n        l, r = 0, 0\\n        total, res = 0, 0\\n\\n        n = len(nums)\\n\\n        while r < n:\\n\\n            total += nums[r]\\n\\n            # while it is not affordalble decrease the window size\\n            # (r-l-1) is window size and nums[r] is the rightmost element of the array\\n\\n            while nums[r] * (r - l + 1) > total + k:\\n                total -= nums[l]\\n                l += 1\\n\\n            res = max(res, r-l+1)\\n            r += 1 \\n\\n        return res    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        \\n        #using sliding window technique\\n        # https://www.youtube.com/watch?v=vgBrQ0NM5vE\\n\\n        nums = sorted(nums)\\n\\n        l, r = 0, 0\\n        total, res = 0, 0\\n\\n        n = len(nums)\\n\\n        while r < n:\\n\\n            total += nums[r]\\n\\n            # while it is not affordalble decrease the window size\\n            # (r-l-1) is window size and nums[r] is the rightmost element of the array\\n\\n            while nums[r] * (r - l + 1) > total + k:\\n                total -= nums[l]\\n                l += 1\\n\\n            res = max(res, r-l+1)\\n            r += 1 \\n\\n        return res    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044879,
                "title": "simple-javascript-solution-with-o-n-time-complexity-using-sliding-window-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Sliding Window Technique of Variable Size - \\nThe goal of this function is to find the maximum length of a subarray in nums such that you can make all the elements in the subarray equal by performing at most k operations, where each operation allows you to increment an element by 1.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window Technique with Variable Size:\\n1. If the length of the nums array is 1, return 1 because a single-element array can always be made into a subarray of length 1 with at most 0 operations.\\n\\n2. Sort the nums array in ascending order. Sorting is essential for optimizing the algorithm.\\n\\n3. Initialize variables: maxLength to keep track of the maximum length of a valid subarray, left and right pointers to define the current subarray, and sum to store the sum of elements in the current subarray.\\n\\n4. Use a sliding window approach with the left and right pointers to find the maximum length of a subarray that can be made equal by performing at most k operations.\\n\\n5. While moving the right pointer, update the sum by adding the element at nums[right] to it.\\n  - If the product of the element at nums[right] and the length of the subarray (right - left + 1) is greater than the current sum + k, it means that the subarray cannot be made equal with at most k operations. In this case, subtract the element at nums[left] from the sum and move the left pointer to the right until the condition is satisfied.\\n\\n  - Keep track of the maximum length of valid subarrays in the maxLength variable as you iterate through the array.\\n\\n6. Finally, return maxLength, which represents the maximum length of a subarray that can be made equal with at most k operations.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe most time-consuming operation in this algorithm is sorting the nums array, which has a time complexity of O(n log n), where n is the length of the nums array. The sliding window approach afterward takes O(n) time, so the overall time complexity is O(n log n).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe algorithm uses a constant amount of extra space for variables, so the space complexity is O(1).\\n\\n# Code\\n```\\n/*\\n1838. Frequency of the Most Frequent Element\\nhttps://leetcode.com/problems/frequency-of-the-most-frequent-element/\\n\\nProblem:\\n  input: Array of integers, nums and Integer, k\\n  output: Integer to represent the frequency of the most frequent element. \\n\\n  rules:\\n  Explicit Requirements:\\n  1. For each operation, we can choose an index of nums and increment the element at index by 1.\\n  i.e, number of operations in an index must be less than or equal to k.\\n\\n  2. Must return the maximum possible frequency of an element after performing at most k operations.\\n\\n  Implicit Requirements:\\n  1. If the length of the nums array is 1, return 1 to the calling function.\\n\\nExample / Test Cases:\\n\\nExample 1:\\n\\nInput: nums = [1,2,4], k = 5\\nOutput: 3\\nExplanation: Increment the first element three times (<= k) and the second element two times (<= k) to make nums = [4,4,4].\\n4 has a frequency of 3.\\n\\nExample 2:\\n\\nInput: nums = [1,4,8,13], k = 5\\nOutput: 2\\nExplanation: There are multiple optimal solutions:\\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\\n\\nExample 3:\\n\\nInput: nums = [3,9,6], k = 2\\nOutput: 1\\n\\nData Structures:\\ninput: Array of integers, nums and Integer, k\\noutput: Integer representing the frequency of the most frequent element. \\n\\nThe goal of this function is to find the maximum length of a subarray in nums such that you can make all the elements in the subarray equal by performing at most k operations, where each operation allows you to increment or decrement an element by 1.\\n\\nAlgorithm:\\nSliding Window Technique with Variable Size:\\n1. If the length of the nums array is 1, return 1 because a single-element array can always be made into a subarray of length 1 with at most 0 operations.\\n\\n2. Sort the nums array in ascending order. Sorting is essential for optimizing the algorithm.\\n\\n3. Initialize variables: maxLength to keep track of the maximum length of a valid subarray, left and right pointers to define the current subarray, and sum to store the sum of elements in the current subarray.\\n\\n4. Use a sliding window approach with the left and right pointers to find the maximum length of a subarray that can be made equal by performing at most k operations.\\n\\n5. While moving the right pointer, update the sum by adding the element at nums[right] to it.\\n  - If the product of the element at nums[right] and the length of the subarray (right - left + 1) is greater than the current sum + k, it means that the subarray cannot be made equal with at most k operations. In this case, subtract the element at nums[left] from the sum and move the left pointer to the right until the condition is satisfied.\\n\\n  - Keep track of the maximum length of valid subarrays in the maxLength variable as you iterate through the array.\\n\\n6. Finally, return maxLength, which represents the maximum length of a subarray that can be made equal with at most k operations.\\n\\nComplexity Analysis:\\n1. Time Complexity: The most time-consuming operation in this algorithm is sorting the nums array, which has a time complexity of O(n log n), where n is the length of the nums array. The sliding window approach afterward takes O(n) time, so the overall time complexity is O(n log n).\\n\\n2. Space Complexity: The algorithm uses a constant amount of extra space for variables, so the space complexity is O(1).\\n\\nIn summary, the code efficiently finds the maximum length of a subarray that can be made equal with at most k operations using a sliding window approach after sorting the input array.\\n\\n\\n*/\\n\\n// Code for Optimized Method\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxFrequency = function(nums, k) {\\n    if (nums.length === 1) {\\n    return 1;\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n\\n  let maxLength = 0;\\n  let left = 0, right = 0, sum = 0;\\n\\n  while (right < nums.length) {\\n    sum += nums[right];\\n    while (nums[right] * (right - left + 1) > sum + k) {\\n      sum -= nums[left];\\n      left += 1;\\n    }\\n    maxLength = Math.max(maxLength, right - left + 1);\\n    right += 1;\\n  }\\n\\n  return maxLength;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n1838. Frequency of the Most Frequent Element\\nhttps://leetcode.com/problems/frequency-of-the-most-frequent-element/\\n\\nProblem:\\n  input: Array of integers, nums and Integer, k\\n  output: Integer to represent the frequency of the most frequent element. \\n\\n  rules:\\n  Explicit Requirements:\\n  1. For each operation, we can choose an index of nums and increment the element at index by 1.\\n  i.e, number of operations in an index must be less than or equal to k.\\n\\n  2. Must return the maximum possible frequency of an element after performing at most k operations.\\n\\n  Implicit Requirements:\\n  1. If the length of the nums array is 1, return 1 to the calling function.\\n\\nExample / Test Cases:\\n\\nExample 1:\\n\\nInput: nums = [1,2,4], k = 5\\nOutput: 3\\nExplanation: Increment the first element three times (<= k) and the second element two times (<= k) to make nums = [4,4,4].\\n4 has a frequency of 3.\\n\\nExample 2:\\n\\nInput: nums = [1,4,8,13], k = 5\\nOutput: 2\\nExplanation: There are multiple optimal solutions:\\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\\n\\nExample 3:\\n\\nInput: nums = [3,9,6], k = 2\\nOutput: 1\\n\\nData Structures:\\ninput: Array of integers, nums and Integer, k\\noutput: Integer representing the frequency of the most frequent element. \\n\\nThe goal of this function is to find the maximum length of a subarray in nums such that you can make all the elements in the subarray equal by performing at most k operations, where each operation allows you to increment or decrement an element by 1.\\n\\nAlgorithm:\\nSliding Window Technique with Variable Size:\\n1. If the length of the nums array is 1, return 1 because a single-element array can always be made into a subarray of length 1 with at most 0 operations.\\n\\n2. Sort the nums array in ascending order. Sorting is essential for optimizing the algorithm.\\n\\n3. Initialize variables: maxLength to keep track of the maximum length of a valid subarray, left and right pointers to define the current subarray, and sum to store the sum of elements in the current subarray.\\n\\n4. Use a sliding window approach with the left and right pointers to find the maximum length of a subarray that can be made equal by performing at most k operations.\\n\\n5. While moving the right pointer, update the sum by adding the element at nums[right] to it.\\n  - If the product of the element at nums[right] and the length of the subarray (right - left + 1) is greater than the current sum + k, it means that the subarray cannot be made equal with at most k operations. In this case, subtract the element at nums[left] from the sum and move the left pointer to the right until the condition is satisfied.\\n\\n  - Keep track of the maximum length of valid subarrays in the maxLength variable as you iterate through the array.\\n\\n6. Finally, return maxLength, which represents the maximum length of a subarray that can be made equal with at most k operations.\\n\\nComplexity Analysis:\\n1. Time Complexity: The most time-consuming operation in this algorithm is sorting the nums array, which has a time complexity of O(n log n), where n is the length of the nums array. The sliding window approach afterward takes O(n) time, so the overall time complexity is O(n log n).\\n\\n2. Space Complexity: The algorithm uses a constant amount of extra space for variables, so the space complexity is O(1).\\n\\nIn summary, the code efficiently finds the maximum length of a subarray that can be made equal with at most k operations using a sliding window approach after sorting the input array.\\n\\n\\n*/\\n\\n// Code for Optimized Method\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxFrequency = function(nums, k) {\\n    if (nums.length === 1) {\\n    return 1;\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n\\n  let maxLength = 0;\\n  let left = 0, right = 0, sum = 0;\\n\\n  while (right < nums.length) {\\n    sum += nums[right];\\n    while (nums[right] * (right - left + 1) > sum + k) {\\n      sum -= nums[left];\\n      left += 1;\\n    }\\n    maxLength = Math.max(maxLength, right - left + 1);\\n    right += 1;\\n  }\\n\\n  return maxLength;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044601,
                "title": "binary-search-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsliding window problem \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nl=0;r=0\\nwhile(r<nums.size()){\\nwindow size=r-l+1;\\nif(window_size*nums[r]<=k+sum)\\nwindow size is possible\\nupdate your ans;\\nincrease window size r++;\\nupdate sum+=nums[r];\\nelse\\nif window size is not possible\\nupdate sum-=nums[l];\\nl++;\\n}\\nreturn ans\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n99 mb\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n      sort(nums.begin(),nums.end());\\n    long long l=0,r=0,ans=1;\\n      long long sum=nums[0];\\n      while(r<nums.size()){\\n          if((r-l+1)*nums[r]<=k+sum){\\n              ans=max(ans,r-l+1);\\n              r++;\\n              if(r<nums.size()){\\n                  sum+=nums[r];\\n              }\\n          }\\n          else{\\n              sum-=nums[l];\\n              l++;\\n\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n      sort(nums.begin(),nums.end());\\n    long long l=0,r=0,ans=1;\\n      long long sum=nums[0];\\n      while(r<nums.size()){\\n          if((r-l+1)*nums[r]<=k+sum){\\n              ans=max(ans,r-l+1);\\n              r++;\\n              if(r<nums.size()){\\n                  sum+=nums[r];\\n              }\\n          }\\n          else{\\n              sum-=nums[l];\\n              l++;\\n\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044110,
                "title": "sliding-wind-nums-right-right-left-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```go \\nfunc maxFrequency(nums []int, k int) int {\\n\\tsort.Slice(nums, func(i, j int) bool {\\n\\t\\treturn nums[i] < nums[j]\\n\\t})\\n\\tout, total := 0, 0\\n\\tleft, right := 0, 0\\n\\tfor right < len(nums) {\\n\\t\\ttotal += nums[right]\\n\\t\\tfor nums[right]*(right-left+1) > total+k {\\n\\t\\t\\ttotal -= nums[left]\\n\\t\\t\\tleft++\\n\\t\\t}\\n\\t\\tif right-left+1 > out {\\n\\t\\t\\tout = right - left + 1\\n\\t\\t}\\n\\t\\tright++\\n\\t}\\n\\treturn out\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go \\nfunc maxFrequency(nums []int, k int) int {\\n\\tsort.Slice(nums, func(i, j int) bool {\\n\\t\\treturn nums[i] < nums[j]\\n\\t})\\n\\tout, total := 0, 0\\n\\tleft, right := 0, 0\\n\\tfor right < len(nums) {\\n\\t\\ttotal += nums[right]\\n\\t\\tfor nums[right]*(right-left+1) > total+k {\\n\\t\\t\\ttotal -= nums[left]\\n\\t\\t\\tleft++\\n\\t\\t}\\n\\t\\tif right-left+1 > out {\\n\\t\\t\\tout = right - left + 1\\n\\t\\t}\\n\\t\\tright++\\n\\t}\\n\\treturn out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042571,
                "title": "python3-prefix-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        nums.sort()\\n        prefix = [0]*N\\n        prefix[0] = nums[0]\\n        for i in range(1, N):\\n            prefix[i] = prefix[i-1]+nums[i]\\n\\n        def getSegmentSum(prefix, i, j):\\n            return prefix[j] - (prefix[i-1] if i-1>=0 else 0)\\n        \\n        lo = 1\\n        hi = 100000\\n        ans = lo\\n\\n        def check(mid):\\n            for i in range(mid-1, N):\\n                curNum = nums[i]\\n                target = curNum * mid\\n                segSum = getSegmentSum(prefix, i-mid+1, i)\\n                if target <= segSum + k:\\n                    return True\\n            return False\\n\\n        while lo<=hi:\\n            mid = (lo+hi)//2\\n            if check(mid):\\n                lo = mid+1\\n                ans = max(ans, mid)\\n            else:\\n                hi = mid-1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        nums.sort()\\n        prefix = [0]*N\\n        prefix[0] = nums[0]\\n        for i in range(1, N):\\n            prefix[i] = prefix[i-1]+nums[i]\\n\\n        def getSegmentSum(prefix, i, j):\\n            return prefix[j] - (prefix[i-1] if i-1>=0 else 0)\\n        \\n        lo = 1\\n        hi = 100000\\n        ans = lo\\n\\n        def check(mid):\\n            for i in range(mid-1, N):\\n                curNum = nums[i]\\n                target = curNum * mid\\n                segSum = getSegmentSum(prefix, i-mid+1, i)\\n                if target <= segSum + k:\\n                    return True\\n            return False\\n\\n        while lo<=hi:\\n            mid = (lo+hi)//2\\n            if check(mid):\\n                lo = mid+1\\n                ans = max(ans, mid)\\n            else:\\n                hi = mid-1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027970,
                "title": "o-n-logn-o-c-typescript",
                "content": "# Intuition\\nSliding window problem?\\n\\n# Approach\\nThe key is to recognize if you sort the array then you calculate the number of ops requires by subtract the sum up to i from nums[i] * (windowSize). Ie you can use a sliding window to easily check every element to get the one(s) that maximize the size of the window.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*logn)$$ -> dominated by the sort\\n- Space complexity:\\n$$O(c)$$ - just a couple variables to track things\\n\\n# Code\\n```\\nfunction maxFrequency(nums: number[], k: number): number {\\n  // sort the nums so it\\'s easy to confirm we\\'re < k as we move a sliding window\\n\\n  nums.sort((a, b) => a - b);\\n\\n  let sum = 0;\\n  let maxFreq = 0;\\n  let start = 0;\\n  let end = 0;\\n\\n  while (end < nums.length) {\\n    sum += nums[end];\\n    // too many ops required, move start forward\\n    while (nums[end] * (end - start + 1) - sum > k) {\\n      sum -= nums[start]\\n      start++;\\n    }\\n    maxFreq = Math.max(maxFreq, end - start + 1);\\n    end++;\\n  }\\n\\n  return maxFreq;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxFrequency(nums: number[], k: number): number {\\n  // sort the nums so it\\'s easy to confirm we\\'re < k as we move a sliding window\\n\\n  nums.sort((a, b) => a - b);\\n\\n  let sum = 0;\\n  let maxFreq = 0;\\n  let start = 0;\\n  let end = 0;\\n\\n  while (end < nums.length) {\\n    sum += nums[end];\\n    // too many ops required, move start forward\\n    while (nums[end] * (end - start + 1) - sum > k) {\\n      sum -= nums[start]\\n      start++;\\n    }\\n    maxFreq = Math.max(maxFreq, end - start + 1);\\n    end++;\\n  }\\n\\n  return maxFreq;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015465,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, long k) {\\n        int i = 0;\\n        int j;\\n        sort(nums.begin(), nums.end());\\n\\n        for (j = 0; j < nums.size(); ++j) {\\n            k += nums[j];\\n            if(k < (long)nums[j] * (j - i + 1))\\n                k -= nums[i++];\\n        }\\n        return j - i;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/6da4009a-d646-49da-84af-21640afbb5fd_1694111107.074254.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, long k) {\\n        int i = 0;\\n        int j;\\n        sort(nums.begin(), nums.end());\\n\\n        for (j = 0; j < nums.size(); ++j) {\\n            k += nums[j];\\n            if(k < (long)nums[j] * (j - i + 1))\\n                k -= nums[i++];\\n        }\\n        return j - i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003101,
                "title": "python-sliding-window-time-o-nlogn-n-space-o-1-brute-force-and-optimal-both",
                "content": "# Brute Force\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums_sorted=sorted(nums)\\n        max_freq=0\\n        for i in range(1,len(nums_sorted)):\\n            j=i-1\\n            ops=k\\n            freq=1\\n# For each element, calculate the difference between the current element and the #previous one (\\'nums_sorted[i] - nums_sorted[j]\\'). Check if there are enough #remaining operations (\\'k\\') to make these adjacent elements equal.\\n            while j>=0 and ops-(nums_sorted[i]-nums_sorted[j])>=0:\\n                ops=ops-(nums_sorted[i]-nums_sorted[j])\\n                freq+=1\\n                j-=1\\n            max_freq=max(max_freq,freq)\\n        return max_freq\\n\\n```\\n# Intuition\\n\\nThe intuition behind solving this problem is to first sort the input list in ascending order, as this allows us to efficiently calculate the differences between adjacent elements. We can then iterate through the sorted list, comparing each element with the previous one. While doing this, we keep track of the remaining operations (k) and increment the frequency of elements when it\\'s possible to make adjacent elements equal by using these operations. By maximizing the frequency during this process, we can find the maximum frequency of any element in the original list.\\n\\n# Approach\\n\\n1. Sort the input list \\'nums\\' in ascending order and store it in \\'nums_sorted\\'.\\n\\n2. Initialize a variable \\'max_freq\\' to 0. This variable will keep track of the maximum frequency of any element.\\n\\n3. Iterate through the sorted list \\'nums_sorted\\' from the second element (index 1) to the end.\\n\\n4. For each element, calculate the difference between the current element and the previous one (\\'nums_sorted[i] - nums_sorted[j]\\'). Check if there are enough remaining operations (\\'k\\') to make these adjacent elements equal.\\n\\n5. If there are enough operations, update the remaining operations (\\'k\\') by subtracting the difference, and increment the frequency (\\'freq\\') by 1.\\n\\n6. Continue this process while there are remaining operations and it\\'s possible to make adjacent elements equal.\\n\\n7. After processing all elements, update \\'max_freq\\' to the maximum value between its current value and \\'freq\\' to ensure it holds the maximum frequency encountered.\\n\\n8. Return \\'max_freq\\' as the maximum frequency of any element in the original list \\'nums\\' after using the allowed operations.\\n\\n# Complexity\\n- Time complexity:\\n\\nThe time complexity of this algorithm is O(n log n + $$N^2$$) due to the initial sorting step, where \\'n\\' is the number of elements in the \\'nums\\' list. The subsequent loop through the sorted list has n squared time because for each element we are moving back until we reach to 0 index or the number of operations are still remaining enought to convert to the right most current element.\\n\\n\\n- Space complexity:\\n\\nThe space complexity is O(n) as we create a sorted copy of the \\'nums\\' list (\\'nums_sorted\\') to facilitate efficient element comparison. \\n\\n\\n\\n# Optimal Approach (Sliding Window)\\n\\n\\n# Approach\\n1. Sort the `nums` list in ascending order to make it easier to track adjacent elements.\\n2. Initialize two pointers, `l` and `r`, to mark the left and right boundaries of the current window. Initialize `count` to keep track of the cost of converting elements within the window.\\n3. Initialize `res` to 1, which will store the maximum frequency found so far.\\n4. Iterate through the list from left to right (from `r = 1` to `r = len(nums) - 1`).\\n   - Calculate the cost `count` of converting elements within the window to be equal to `nums[r]`. This cost is updated as the window expands.\\n   - Check if `count` exceeds the given limit `k`. If it does, reduce the window size by moving the left boundary `l` to the right while maintaining the sum within the limit.\\n   - Update `res` with the maximum window size seen so far, representing the maximum frequency of an element achievable with at most `k` operations.\\n5. Return the final value of `res`.\\n\\nThe key idea is to efficiently slide the window while considering the cost of converting elements, and whenever the cost exceeds the limit, adjust the window by moving the left boundary.\\n\\n# Complexity\\n- Time complexity: The time complexity of this algorithm is O(n * log(n)), where n is the length of the `nums` list. This is due to the initial sorting step. The subsequent loop through the list takes linear time O(n). Therefore, the overall time complexity is dominated by the sorting step.\\n\\n- Space complexity: The space complexity is O(1) as the algorithm uses a constant amount of extra space for variables `l`, `r`, `count`, `res`, and the loop variables. The sorting operation does not consume additional space in the complexity analysis since it\\'s part of the algorithm\\'s operation.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        l=0\\n        count=0\\n        res=1\\n        for r in range(1,len(nums)):\\n            count=count+((nums[r]-nums[r-1])*(r-l))\\n            while count > k:\\n                count=count-(nums[r]-nums[l])\\n                l+=1\\n            #one here is added to include the rth element to window size\\n            res=max(res,r-l+1)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums_sorted=sorted(nums)\\n        max_freq=0\\n        for i in range(1,len(nums_sorted)):\\n            j=i-1\\n            ops=k\\n            freq=1\\n# For each element, calculate the difference between the current element and the #previous one (\\'nums_sorted[i] - nums_sorted[j]\\'). Check if there are enough #remaining operations (\\'k\\') to make these adjacent elements equal.\\n            while j>=0 and ops-(nums_sorted[i]-nums_sorted[j])>=0:\\n                ops=ops-(nums_sorted[i]-nums_sorted[j])\\n                freq+=1\\n                j-=1\\n            max_freq=max(max_freq,freq)\\n        return max_freq\\n\\n```\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        l=0\\n        count=0\\n        res=1\\n        for r in range(1,len(nums)):\\n            count=count+((nums[r]-nums[r-1])*(r-l))\\n            while count > k:\\n                count=count-(nums[r]-nums[l])\\n                l+=1\\n            #one here is added to include the rth element to window size\\n            res=max(res,r-l+1)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001210,
                "title": "python3-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding window \\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        total = 0\\n        res = 0\\n        l,r=0,0\\n        while r < len(nums):\\n            total+=nums[r]\\n            while nums[r]*(r-l+1) > k + total:\\n                total-=nums[l]\\n                l+=1\\n            res=max(res,r-l+1)\\n            r+=1\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        total = 0\\n        res = 0\\n        l,r=0,0\\n        while r < len(nums):\\n            total+=nums[r]\\n            while nums[r]*(r-l+1) > k + total:\\n                total-=nums[l]\\n                l+=1\\n            res=max(res,r-l+1)\\n            r+=1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988962,
                "title": "easiest-python-solution-sliding-window",
                "content": "Runtime: 1145 ms, faster than 80.13% of Python3 online submissions for Frequency of the Most Frequent Element.\\nMemory Usage: 29.6 MB, less than 100.00% of Python3 online submissions for Frequency of the Most Frequent Element.\\n\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int\\n\\t\\n        out = res = i = sums = 0\\n\\t\\tnums.sort()\\n        \\n        for j in range(len(nums)):\\n            sums+=nums[j]\\n            \\n            while nums[j]*(j-i+1) > sums+k:\\n                sums-=nums[i]\\n                i+=1\\n                \\n            res=j-i+1\\n            out=max(out,res)\\n            \\n        return out",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Runtime: 1145 ms, faster than 80.13% of Python3 online submissions for Frequency of the Most Frequent Element.\\nMemory Usage: 29.6 MB, less than 100.00% of Python3 online submissions for Frequency of the Most Frequent Element.\\n\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int\\n\\t\\n        out = res = i = sums = 0\\n\\t\\tnums.sort()\\n        \\n        for j in range(len(nums)):\\n            sums+=nums[j]\\n            \\n            while nums[j]*(j-i+1) > sums+k:\\n                sums-=nums[i]\\n                i+=1\\n                \\n            res=j-i+1\\n            out=max(out,res)\\n            \\n        return out",
                "codeTag": "Java"
            },
            {
                "id": 3982349,
                "title": "two-python-solutions-prefix-sum-binary-search-sliding-window-detailed-intuition-explained",
                "content": "# Intuition for 1st method\\n- In a given window of array = `e_1,e_2,e_3,e_4...e_(n-1),e_n`, the minimum frequency of an element is `1` and the `maximum frequency is the window size == n` which is when all elements are equal to each other.\\n- The idea is that given a `window size with elements e_1 to e_n`, we want to make all `elements e_1 ~ e_n-1` equal to `e_n`. If we can make all elements in this window equal to the largest value in `<= k operations` (`e_n` because we\\u2019ve sorted the `nums` array) then we can try a larger window. A larger window would be a larger maximum frequency.\\n- So we use binary search to determine whether we want to use a smaller or a larger window.\\n- In a particular window size chosen by binary search, we slide the window across the entire array to see if it\\u2019s possible.\\n\\nEx: For window size 2 in array [3,4,9,10], one such window is [3,4]. Can we turn [3,4] into [4,4]? If so we know a maximum frequency of 2 is possible. \\nprefixSum = [3,7,16,26]\\nTo figure out if this window can be changed, we use prefixSum. `prefixSum[1] - prefixSum[-1] == 7 - 0 = 7` (prefixSum[-1] would just be 0 since it doesn\\'t exist) is the sum of window [3,4]\\n[4,4] has a sum of 8. Now we ask, `8 - 7 <= k?`\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) for sorting\\n\\n# Code\\n```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n\\n        prefixSum = [0] * len(nums)\\n        prefixSum[0] = nums[0]\\n        \\n        for i in range(1, n):\\n            prefixSum[i] += nums[i] + prefixSum[i-1]\\n        print(nums)\\n        def canMaximize(wSize):\\n            # fix this window size and slide\\n            # see if we can maximize last element in window using <= k operations\\n            \\n            # [3,4,9,10] wSize=2\\n            # sliding windows:\\n            # [3,4], [4,9], [9,10]\\n\\n            for i in range(wSize-1, n):\\n                tot = nums[i] * wSize\\n                wSum = prefixSum[i] - (prefixSum[i-wSize] if i-wSize >= 0 else 0)\\n                if tot - wSum <= k: return True\\n            return False\\n\\n\\n        left = 1\\n        right = n\\n\\n        while left < right:\\n            cand = left + (right - left) // 2\\n            if canMaximize(cand):\\n                left = cand + 1\\n            else:\\n                right = cand\\n\\n        if canMaximize(left): return left\\n        else: return left-1\\n```\\n\\n## Using same intuition we can get rid of binary search + prefixSum by just using sliding window\\n```Python\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n\\n        left = 0\\n        right = 0\\n        cSum = 0\\n        \"\"\"\\n        [1,4,8,10]\\n        let\\'s say window size = 3\\n        [1,4,8]\\n        maximum freq of 3 works if \\n        we can turn this into\\n        [8,8,8]\\n        nums[right] * (right - left + 1) - cSum <= k is condition that is OK\\n        so the opposite of this is when we have to move our left pointer\\n        \"\"\"\\n        ans = 0\\n        while right < n:\\n            cSum += nums[right]\\n\\n            while nums[right] * (right-left+1) - cSum > k:\\n                cSum -= nums[left]\\n                left += 1\\n\\n            ans = max(ans, right-left+1)\\n            right += 1\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n\\n        prefixSum = [0] * len(nums)\\n        prefixSum[0] = nums[0]\\n        \\n        for i in range(1, n):\\n            prefixSum[i] += nums[i] + prefixSum[i-1]\\n        print(nums)\\n        def canMaximize(wSize):\\n            # fix this window size and slide\\n            # see if we can maximize last element in window using <= k operations\\n            \\n            # [3,4,9,10] wSize=2\\n            # sliding windows:\\n            # [3,4], [4,9], [9,10]\\n\\n            for i in range(wSize-1, n):\\n                tot = nums[i] * wSize\\n                wSum = prefixSum[i] - (prefixSum[i-wSize] if i-wSize >= 0 else 0)\\n                if tot - wSum <= k: return True\\n            return False\\n\\n\\n        left = 1\\n        right = n\\n\\n        while left < right:\\n            cand = left + (right - left) // 2\\n            if canMaximize(cand):\\n                left = cand + 1\\n            else:\\n                right = cand\\n\\n        if canMaximize(left): return left\\n        else: return left-1\\n```\n```Python\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n\\n        left = 0\\n        right = 0\\n        cSum = 0\\n        \"\"\"\\n        [1,4,8,10]\\n        let\\'s say window size = 3\\n        [1,4,8]\\n        maximum freq of 3 works if \\n        we can turn this into\\n        [8,8,8]\\n        nums[right] * (right - left + 1) - cSum <= k is condition that is OK\\n        so the opposite of this is when we have to move our left pointer\\n        \"\"\"\\n        ans = 0\\n        while right < n:\\n            cSum += nums[right]\\n\\n            while nums[right] * (right-left+1) - cSum > k:\\n                cSum -= nums[left]\\n                left += 1\\n\\n            ans = max(ans, right-left+1)\\n            right += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965627,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, long k) {\\n        \\n        int i=0, j;\\n        sort(nums.begin(),nums.end());\\n        for( j=0; j<nums.size(); j++){\\n            k += nums[j];\\n            if( k < (long)nums[j] * ( j - i + 1))\\n             k -= nums[i++];\\n        }\\n        return j - i;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, long k) {\\n        \\n        int i=0, j;\\n        sort(nums.begin(),nums.end());\\n        for( j=0; j<nums.size(); j++){\\n            k += nums[j];\\n            if( k < (long)nums[j] * ( j - i + 1))\\n             k -= nums[i++];\\n        }\\n        return j - i;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953401,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int j=0;\\n        long long int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res+= nums[i];\\n            long long x=(i+1);\\n            long long temp=nums[i]*(x);\\n\\n            if((temp-res)<=k){\\n\\n            }else{\\n                while(res>k && j<i){\\n                    long long y=(i-j+1);\\n                    long long t=nums[i]*y;\\n                    if(t-res<=k) break;\\n                    res-= nums[j];\\n                    j++;\\n                }\\n            }\\n            ans=max(ans,(i-j+1));   \\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int j=0;\\n        long long int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res+= nums[i];\\n            long long x=(i+1);\\n            long long temp=nums[i]*(x);\\n\\n            if((temp-res)<=k){\\n\\n            }else{\\n                while(res>k && j<i){\\n                    long long y=(i-j+1);\\n                    long long t=nums[i]*y;\\n                    if(t-res<=k) break;\\n                    res-= nums[j];\\n                    j++;\\n                }\\n            }\\n            ans=max(ans,(i-j+1));   \\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949660,
                "title": "intuitive-solution-js",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxFrequency = function(nums, k) {\\n    nums.sort((a,b) => a - b) // sort in descending order - nlogn\\n\\n    console.log(\"nums  \", nums)\\n    let l = 0;\\n    let r = 0;\\n    let total = 0\\n    let res = 0\\n\\n    // sliding window but start from the Oth index\\n\\n    while(r < nums.length) {\\n        total += nums[r]\\n\\n        while(nums[r] * (r - l + 1) > (total + k)) {\\n            total -= nums[l]\\n            l++\\n        }\\n\\n        res = Math.max(res, r - l + 1)\\n        r++\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxFrequency = function(nums, k) {\\n    nums.sort((a,b) => a - b) // sort in descending order - nlogn\\n\\n    console.log(\"nums  \", nums)\\n    let l = 0;\\n    let r = 0;\\n    let total = 0\\n    let res = 0\\n\\n    // sliding window but start from the Oth index\\n\\n    while(r < nums.length) {\\n        total += nums[r]\\n\\n        while(nums[r] * (r - l + 1) > (total + k)) {\\n            total -= nums[l]\\n            l++\\n        }\\n\\n        res = Math.max(res, r - l + 1)\\n        r++\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937803,
                "title": "sliding-window-approach-easy-to-understand-c-solution-dynamic-window-size",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMain formula check is: operations + k < (long)nums[right] * window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort vector then use sliding window of variable size\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n       int left = 0, right=0;\\n        sort(nums.begin(), nums.end());\\n        long int operations=0;  //initial operations performed=0\\n        int window=0;   //variable window size\\n        for (right = 0; right < nums.size(); right++) {\\n            operations += nums[right];  //operations that can be performed = operations + nums[right]\\n            window=right-left+1;    //update window size\\n            if (operations + k< (long)nums[right] * window) \\n            //check condition (operations performed < maximum element* window)\\n                operations -= nums[left++];\\n                //check for whole nums vector\\n        }\\n        return right - left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Brainteaser",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n       int left = 0, right=0;\\n        sort(nums.begin(), nums.end());\\n        long int operations=0;  //initial operations performed=0\\n        int window=0;   //variable window size\\n        for (right = 0; right < nums.size(); right++) {\\n            operations += nums[right];  //operations that can be performed = operations + nums[right]\\n            window=right-left+1;    //update window size\\n            if (operations + k< (long)nums[right] * window) \\n            //check condition (operations performed < maximum element* window)\\n                operations -= nums[left++];\\n                //check for whole nums vector\\n        }\\n        return right - left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935875,
                "title": "c-approach-via-sort-and-sliding-window",
                "content": "# Intuition\\nThe problem wants us to find max occurences of a number in given array where we have a buffer which can be appended to previous/next value to make it the same number. Sort helps as you will need to go through the all the elements atleast once and by sorting you will know that next element is always >= previous. So the numbers are always together after sorting which allows us to use sliding window.\\n\\n# Approach\\nSliding Window after sorting the given array.\\nnums[right]*(right-left+1) > sum + k -> This condition allows us to check if we are exceeding the k operations.\\n\\n# Complexity\\n- Time complexity:\\nSort is logn then iteration: O(nlogn)\\n\\n- Space complexity:\\nConstant space: o(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxFrequency(int[] nums, int k) {\\n        Array.Sort(nums);\\n        int lastind = nums.Length - 1;\\n        int left = 0,right = 0;        \\n        long sum = 0;\\n        int ans = 0;\\n        while(right<lastind+1)\\n        {\\n            sum += nums[right];\\n            while(nums[right]*(right-left+1) > sum + k)\\n            {\\n                sum -= nums[left];\\n                left++;\\n            }\\n            ans = Math.Max(ans, right-left+1);\\n            right++;\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxFrequency(int[] nums, int k) {\\n        Array.Sort(nums);\\n        int lastind = nums.Length - 1;\\n        int left = 0,right = 0;        \\n        long sum = 0;\\n        int ans = 0;\\n        while(right<lastind+1)\\n        {\\n            sum += nums[right];\\n            while(nums[right]*(right-left+1) > sum + k)\\n            {\\n                sum -= nums[left];\\n                left++;\\n            }\\n            ans = Math.Max(ans, right-left+1);\\n            right++;\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933355,
                "title": "easy-approach-using-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int start = 0;\\n        int maxFreq = 1;\\n        long long currFreq = 0;\\n        for(int end = 1; end<nums.size(); end++){\\n            currFreq += (long long)(end - start) * (nums[end] - nums[end - 1]);\\n\\n            while(currFreq > k){\\n                currFreq -= nums[end] - nums[start];\\n                start++;\\n            }\\n            maxFreq = max(maxFreq, end - start + 1);\\n        }\\n        return maxFreq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int start = 0;\\n        int maxFreq = 1;\\n        long long currFreq = 0;\\n        for(int end = 1; end<nums.size(); end++){\\n            currFreq += (long long)(end - start) * (nums[end] - nums[end - 1]);\\n\\n            while(currFreq > k){\\n                currFreq -= nums[end] - nums[start];\\n                start++;\\n            }\\n            maxFreq = max(maxFreq, end - start + 1);\\n        }\\n        return maxFreq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931398,
                "title": "easy-to-understand-python-c-c",
                "content": "### Upvote if the solution is helpful, thank you :)\\n# Code\\n```c []\\nint comapreints(const void *a, const void *b){\\n    return (*(int*)a - *(int*)b );\\n}\\n\\nint maxFrequency(int* nums, int numsSize, int k){\\n    int l =0, r = 0, res = 0;\\n    long long tot = 0;\\n\\n    qsort(nums, numsSize, sizeof(int), comapreints);\\n    \\n    while(r < numsSize){\\n        tot += nums[r];\\n\\n        while((long long)nums[r]*(r-l+1) > tot + k){\\n            tot -= nums[l];\\n            l++;\\n        }\\n        res = fmax(res, (r-l+1));\\n        r++;\\n    }\\n    return res;\\n}\\n```\\n```python []\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        \\n        l,r = 0,0\\n        tot = 0\\n        res = 0\\n        nums.sort()\\n        while r < len(nums):\\n            tot += nums[r]\\n\\n            while nums[r]*(r-l+1) > tot + k:\\n                tot -= nums[l]\\n                l += 1\\n            res = max(res, (r-l+1))\\n            r += 1\\n        return res\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n    \\n    sort(nums.begin(), nums.end());\\n\\n    int l =0, r = 0, res = 0;\\n    long long tot = 0;\\n    \\n    while(r < nums.size()){\\n        tot += nums[r];\\n\\n        while((long long)nums[r]*(r-l+1) > tot + k){\\n            tot -= nums[l];\\n            l++;\\n        }\\n        res = max(res, (r-l+1));\\n        r++;\\n    }\\n    return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Sliding Window"
                ],
                "code": "```c []\\nint comapreints(const void *a, const void *b){\\n    return (*(int*)a - *(int*)b );\\n}\\n\\nint maxFrequency(int* nums, int numsSize, int k){\\n    int l =0, r = 0, res = 0;\\n    long long tot = 0;\\n\\n    qsort(nums, numsSize, sizeof(int), comapreints);\\n    \\n    while(r < numsSize){\\n        tot += nums[r];\\n\\n        while((long long)nums[r]*(r-l+1) > tot + k){\\n            tot -= nums[l];\\n            l++;\\n        }\\n        res = fmax(res, (r-l+1));\\n        r++;\\n    }\\n    return res;\\n}\\n```\n```python []\\nclass Solution:\\n    def maxFrequency(self, nums: List[int], k: int) -> int:\\n        \\n        l,r = 0,0\\n        tot = 0\\n        res = 0\\n        nums.sort()\\n        while r < len(nums):\\n            tot += nums[r]\\n\\n            while nums[r]*(r-l+1) > tot + k:\\n                tot -= nums[l]\\n                l += 1\\n            res = max(res, (r-l+1))\\n            r += 1\\n        return res\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n    \\n    sort(nums.begin(), nums.end());\\n\\n    int l =0, r = 0, res = 0;\\n    long long tot = 0;\\n    \\n    while(r < nums.size()){\\n        tot += nums[r];\\n\\n        while((long long)nums[r]*(r-l+1) > tot + k){\\n            tot -= nums[l];\\n            l++;\\n        }\\n        res = max(res, (r-l+1));\\n        r++;\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927335,
                "title": "using-non-decreasing-sliding-window",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        long long sum=0;\\n        int left=0;\\n        int ans=1;\\n        for(int right=1;right<n;right++){\\n            sum+=(long long)nums[right-1];\\n            if(left<right&&(long long)(right-left)*nums[right]-sum>k){\\n                sum-=nums[left];\\n                left++;\\n            }\\n            ans=right-left+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        long long sum=0;\\n        int left=0;\\n        int ans=1;\\n        for(int right=1;right<n;right++){\\n            sum+=(long long)nums[right-1];\\n            if(left<right&&(long long)(right-left)*nums[right]-sum>k){\\n                sum-=nums[left];\\n                left++;\\n            }\\n            ans=right-left+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923272,
                "title": "sliding-window-solution-in-java",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```Java\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        int l = 0, r = 0, ans = 1, n = nums.length;  // Pointers and answer variables\\n        \\n        Arrays.sort(nums);  // Sort the array in ascending order\\n        \\n        long sum = 0;  // Initialize a variable to keep track of the sum of elements\\n        for (; r < n; r++) {\\n            sum += nums[r];  // Add the current element to the sum\\n            \\n            // Adjust the left pointer to maintain the frequency constraint\\n            for (; nums[r] * (r - l + 1) > sum + k; l++) {\\n                sum -= nums[l];  // Subtract the leftmost element from the sum\\n            }\\n            \\n            ans = Math.max(ans, r - l + 1);  // Update the maximum frequency\\n        }\\n        \\n        System.out.println(sum);  // Print the final sum of elements within the frequency constraint\\n        \\n        return ans;  // Return the maximum frequency achievable\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        int l = 0, r = 0, ans = 1, n = nums.length;  // Pointers and answer variables\\n        \\n        Arrays.sort(nums);  // Sort the array in ascending order\\n        \\n        long sum = 0;  // Initialize a variable to keep track of the sum of elements\\n        for (; r < n; r++) {\\n            sum += nums[r];  // Add the current element to the sum\\n            \\n            // Adjust the left pointer to maintain the frequency constraint\\n            for (; nums[r] * (r - l + 1) > sum + k; l++) {\\n                sum -= nums[l];  // Subtract the leftmost element from the sum\\n            }\\n            \\n            ans = Math.max(ans, r - l + 1);  // Update the maximum frequency\\n        }\\n        \\n        System.out.println(sum);  // Print the final sum of elements within the frequency constraint\\n        \\n        return ans;  // Return the maximum frequency achievable\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921291,
                "title": "easy-c-code-sum-logic",
                "content": "# Intuition\\nwe can distribute k to the different elements so that some elements can equal. how can we calculate the no. of elements that can take the value of k to be equal?\\n\\n# Approach\\nk can be used by elements if nums[r]* (r-l+1)- sum <= k.\\nwhere nums[r]* (r-l+1) should be the sum after using k and sum is actual sum of sunaaray.\\ntherefore, invalid condition is nums[r]* (r-l+1)- sum(total) >k. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) { \\n        int n= nums.size();\\n        long l=0, r=0, ans=0;\\n        sort(nums.begin(), nums.end());\\n        long long sum=0;\\n        for(; r<n; r++){\\n            sum+= nums[r];\\n            for(; nums[r]*(r-l+1)- sum> k; l++){ // nums[r]*(r-l+1) this is the main condition of the subarray, jaha pe condition invalid hogi. if invalid then remove that element.  \\n                sum= sum-nums[l]; // removing element.\\n\\n            }\\n            ans= max(ans, r-l+1); // max sub array freq\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) { \\n        int n= nums.size();\\n        long l=0, r=0, ans=0;\\n        sort(nums.begin(), nums.end());\\n        long long sum=0;\\n        for(; r<n; r++){\\n            sum+= nums[r];\\n            for(; nums[r]*(r-l+1)- sum> k; l++){ // nums[r]*(r-l+1) this is the main condition of the subarray, jaha pe condition invalid hogi. if invalid then remove that element.  \\n                sum= sum-nums[l]; // removing element.\\n\\n            }\\n            ans= max(ans, r-l+1); // max sub array freq\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919649,
                "title": "binary-search-sliding-window",
                "content": "# Intuition and approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWatch : https://www.youtube.com/watch?v=nveGJc_oYAI\\n\\nThe approach is that our answer of frequency lies in the range 1 to N.\\nFor a particular number in nums, if we want to do operations such that nums[i] has maximum frequency in array, we have to pick elements lesser than nums[i] as we are incrementing the number in operations...and we have to pick those numbers which have least difference with nums[i] and they have to be consecutive (in a window).\\n\\nIn possible function, for every window of size windowSize, we see that if we can make all the numbers in the window equal to last number of window and we calculate number of operations required to do that and store it in \\'remainder\\' and then we check if its less than or equal to number of operations.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    bool possible(vector<unsigned long long int>& prefixSum,vector<int>& nums,int windowSize,int ops)\\n    {\\n        if(windowSize == 1)\\n        return true;\\n        cout<<\"windowSize \"<<windowSize<<endl;\\n        int prev = 0;\\n        for(int i=0;i<=nums.size()-windowSize;i++)\\n        {\\n            int remainder = prefixSum[i+windowSize-1]-nums[i+windowSize-1]-prev;\\n            unsigned long long int n1 = nums[i+windowSize-1];\\n            unsigned long long int n2 = windowSize-1;\\n            remainder = n1*n2-remainder;\\n            if(remainder<=ops)\\n            {\\n                cout<<i<<endl;\\n                return true;\\n            }\\n            prev = prefixSum[i];\\n        }\\n        return false;\\n    }\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        vector<unsigned long long int> prefixSum(nums.size());\\n        unsigned long long int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            prefixSum[i]=sum;\\n        }\\n        int st = 1;\\n        int en = nums.size();\\n        //cout<<possible(prefixSum,nums,nums.size(),k);\\n        while(st<=en)\\n        {\\n            int mid = st+(en-st)/2;\\n            if(possible(prefixSum,nums,mid,k))\\n            {\\n                if(mid == nums.size())\\n                {\\n                    return mid;\\n                }\\n                else if(!possible(prefixSum,nums,mid+1,k))\\n                return mid;\\n                else\\n                {\\n                    st=mid+1;\\n                }\\n            }\\n            else\\n            {\\n                en=mid-1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool possible(vector<unsigned long long int>& prefixSum,vector<int>& nums,int windowSize,int ops)\\n    {\\n        if(windowSize == 1)\\n        return true;\\n        cout<<\"windowSize \"<<windowSize<<endl;\\n        int prev = 0;\\n        for(int i=0;i<=nums.size()-windowSize;i++)\\n        {\\n            int remainder = prefixSum[i+windowSize-1]-nums[i+windowSize-1]-prev;\\n            unsigned long long int n1 = nums[i+windowSize-1];\\n            unsigned long long int n2 = windowSize-1;\\n            remainder = n1*n2-remainder;\\n            if(remainder<=ops)\\n            {\\n                cout<<i<<endl;\\n                return true;\\n            }\\n            prev = prefixSum[i];\\n        }\\n        return false;\\n    }\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        vector<unsigned long long int> prefixSum(nums.size());\\n        unsigned long long int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            prefixSum[i]=sum;\\n        }\\n        int st = 1;\\n        int en = nums.size();\\n        //cout<<possible(prefixSum,nums,nums.size(),k);\\n        while(st<=en)\\n        {\\n            int mid = st+(en-st)/2;\\n            if(possible(prefixSum,nums,mid,k))\\n            {\\n                if(mid == nums.size())\\n                {\\n                    return mid;\\n                }\\n                else if(!possible(prefixSum,nums,mid+1,k))\\n                return mid;\\n                else\\n                {\\n                    st=mid+1;\\n                }\\n            }\\n            else\\n            {\\n                en=mid-1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1926414,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1567076,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1928195,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1917100,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1575385,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1986352,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 2025657,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 2020655,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 2011052,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1998728,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1926414,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1567076,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1928195,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1917100,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1575385,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1986352,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 2025657,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 2020655,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 2011052,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            },
            {
                "id": 1998728,
                "content": [
                    {
                        "username": "fatcat22able",
                        "content": "NOTE: If you\\'re failing the final test case:\\n\\n`nums =\\n[100000,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99...`\\n\\n`k =\\n100000`\\n\\nOutput\\n`21475`\\n\\nExpected\\n`100000`\\n\\nIt\\'s not because there\\'s something wrong with your solution, it\\'s because of integer overflow bullsh*t. You will have to use `long` instead of `int` for your sum calculation.\\n\\nFor the record, I absolutely HATE when Leetcode problems do crap like this, because it\\'s just throwing in a useless test failure that has nothing to do with the spirit of the problem. Unless the problem specifically relates to adding numbers in a unique way, throwing in a test case that causes integer overflow teaches you NOTHING about the specific algorithmic approach or pattern. It just makes you second guess yourself and waste your time for no good reason. The final test case should really be removed imo. Whoever added it wasn\\'t thinking clearly."
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "i agree leet Code have this annoyance."
                    },
                    {
                        "username": "JParks1982",
                        "content": "I couldn\\'t agree with you more!!! I hate it when Leetcode does crap like this."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Posts that helped me:\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code\\n* https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1182164/C++-Sort-and-Binary-Search-(Detailed-Explanation-with-pictures)-T-:-O(NlogN)-S:-O(N)\\n\\n* **Problem solving:** Sorting doesn\\'t harm this problem. So sort (maybe not required, but kets keep it for last to be removed or not)\\n* sorting helped to get duplicates adjacent to each other. Helps to count frequency for every unique number (ignore k for now) via sliding window.\\n* **Problem solving**: Element contribution to answer, check if each element is answer, is hardcoded k provided and if yes then mostly its greedy, analyse worst and best answer, lookout all possible decision in the search space, are subarrays involved and if yes what are the possible start-middle-end indices and whats best of them, etc are my normal problem solving starting thoughts. Other approaches:\\n \\xA01. utilizing or comparing wrt first index element in an array, cache repeated values/operations\\n \\xA02. draw test cases to see patterns like: greediness for recursive intiitive approaches, fifo, lifo, deque, pq, monotonic incr/decr (nge) etc\\n  3. compare with actual elements that should be in place of existing elements\\n* **Problem solving - Analyse worst and best answer**: Here, worst answer is 1 and best answer is length of input array. Analyse:\\n \\xA0* When 1?: when input is all unique elements and there is not enough k for any element to be uplifted to the adjacent higher number. \\n \\xA0* When length of i/p: when all elements are same OR there is enough k to uplift all smaller elements to the largest element\\n* **Problem solving - Subarray involved**: From above its obvious the **problem requirement** is to find the best subarray length between 1 to i/p array length. Sliding window, binary search, prefix sum and dp are the most common tools for solving subarray problems. Aso smaller numbers are uplifted to larger numbers, not vice versa. \\n* **Problem solving - What are the possible starts of subarrays here?**: all indices. Now pick one index, a[0]. Whats the min answer it can give, 1. Whats the next best answer it can give, 2 if there\\'s atleast a[1] - a[0] k (ie, k >= a[1] - a[0]) (index 1 becomes end of subarray then). Whats the next best answer with a[0] as start of subarray, 3 if there\\'s atleast (a[2] - a[0]) + (a[2] - a[1]) k (index 2 becomes end of subarray then). The possibility of finding a better length subarray with start = 0th index and end index towards right of it continues till the validity remains (ie, **there\\'s enough k to uplift all the previous smaller elements towards the left of end index of current subarray OR we can say, sum of elements in the growing window plus k <= length of window * k**). This is the crux of the **problem solving**. What if validity fails at some point of finding a better end for the same start?: since now you have directly computed on the subarray [start, end) and indirectly computed/touched on all possible subarrays inside [start, end), and its subarray [start, end] is inavlid, the next best subarray is [start + 1, end]. Check for validity. If again invalid, check [start + 2, end]. **This movement of start and the above mentioned movement on end is the so called sliding window pattern and you take the best window length as answer**. This is how I would like to **transit between different states of a problem: problem description - > problem solving -> problem requirement -> specific implementaion pattern**. One important thing to observe here is k cannot be randomly distributed to any elements in the subarray. In a subarray, 1. for k to be used at i + 1, it should also be used at i for frequency at both places to be same. If visualized, its like k is a stream of water pouring at i which has no obstacled below it, and when it reaches height of obstacle at i + 1, water at both indices increases together maintaining same height and continues for i +3 etc like a left to right movement of water. This is where sorting at first seems beneficial - to maintain the subarrayness. 2. And for k to be used at any index i in the first place, i and i + 1 should be different numbers, else there\\'s no use (eg, i/p = [1,1,1], k = any number). \\n* **Another problem solving approach - element contribution**: What are the possible ends of valid subarrays: all indices. So for each index as end (O(N) traversal), get the best start for it (O(logN) search) with the above validity as the search criteria. This is the **implementation pattern - Binary Search**."
                    },
                    {
                        "username": "ross8888",
                        "content": "This Problem was asked in interview and further follow up was given to optimize to o(n)"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "How does one optimize the solution to O(n)? This would imply no sorting is used."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Does anybody know why it is a BS problem?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Me after spending hours trying to solve it : \"Yes it is clearly a BS problem.\" \\uD83D\\uDE16\\uD83D\\uDE16"
                    },
                    {
                        "username": "Abdur-Rahim-Sheikh",
                        "content": "If you cannot think of a solution less complexity than O(nlogn)\\nThink about <b>\"sliding window method\"</b> it will be solved in <strong>O(n)</strong> complexity."
                    },
                    {
                        "username": "aniroh",
                        "content": "Thank you for clarifying in the comments under this discussion \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bah",
                        "content": "this comment is misleading, consider removing it please"
                    },
                    {
                        "username": "tydaljames",
                        "content": "Sliding window would be O(nlogn) in this case, because of the required sort."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why when nums = [9930,9923,9983,9997,9934,9952,9945,9914,9985,9982,9970,9932,9985,9902,9975,9990,9922,9990,9994,9937,9996,9964,9943,9963,9911,9925,9935,9945,9933,9916,9930,9938,10000,9916,9911,9959,9957,9907,9913,9916,9993,9930,9975,9924,9988,9923,9910,9925,9977,9981,9927,9930,9927,9925,9923,9904,9928,9928,9986,9903,9985,9954,9938,9911,9952,9974,9926,9920,9972,9983,9973,9917,9995,9973,9977,9947,9936,9975,9954,9932,9964,9972,9935,9946,9966] and k = 3056, expected output is 73 instead of 85 (the length of the entire array)?"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "[@alighraibeh87](/alighraibeh87) im getting 72 here idk why\\uD83D\\uDE44"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "same as you, but moved to the next situation that wants to decrement the k in order to reach the threshold ! dont compare whether \\nnums[i] -nums[j] <=k , its false assumpation"
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "Can anyone suggest what is wrong with the code\\nar maxFrequency = function(nums, k) {\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        let count=0;\\n        for (let j=0;j<nums.length;j++){\\n                if(nums[j]>nums[i]){\\n                    continue\\n                }\\n                if((nums[j]+k)>=nums[i]){\\n                count++\\n            }\\n            \\n           \\n             max= Math.max(max,count)\\n        }\\n    }\\n    return max;\\n};"
                    },
                    {
                        "username": "gyash9878",
                        "content": "please tell the logical error in this code \\nas it fails on 9th test case.\\nclass Solution {\\npublic:\\n    int maxFrequency(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ind=nums.size()-1;\\n        int l=nums[ind];\\n        int sl=nums[ind-1];\\n        int d=l-sl;\\n        if(k<d)\\n        return 1;\\n        else{\\n            int cnt=1;\\n            for(int i=ind-1;i>=0;i--){\\n                int f=l-nums[i];\\n                k-=f;\\n                if(k>=0)\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Please anyone tell why it is not working for specific test case \nshowing 74 instead of 75.\n\nclass Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        int ans = 0,temp,count;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i>0;i--)\n        {\n            temp = k;\n            count = 1;\n            if( i!=nums.size()-1 && nums[i]==nums[i-1])\n                continue;\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]+temp >= nums[i])\n                {\n                    count++;\n                    temp = temp + (nums[j] - nums[i]);\n                }\n                else\n                    break;\n            }\n            ans = max(ans,count);\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "nums  = [4,2,7,8,2,4]\\nk = 5"
                    },
                    {
                        "username": "aiabhishek",
                        "content": "What if we can decrement as well and array contains negative elements"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont give them ideas !!"
                    }
                ]
            }
        ]
    }
]