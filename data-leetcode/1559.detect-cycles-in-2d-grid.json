[
    {
        "title": "Lexicographically Smallest Equivalent String",
        "question_content": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\n\tFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\n\tReflexivity: 'a' == 'a'.\n\tSymmetry: 'a' == 'b' implies 'b' == 'a'.\n\tTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.\n&nbsp;\nExample 1:\n\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\nOutput: \"makkek\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\nThe characters in each group are equivalent and sorted in lexicographical order.\nSo the answer is \"makkek\".\n\nExample 2:\n\nInput: s1 = \"hello\", s2 = \"world\", baseStr = \"hold\"\nOutput: \"hdld\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r].\nSo only the second letter 'o' in baseStr is changed to 'd', the answer is \"hdld\".\n\nExample 3:\n\nInput: s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\"\nOutput: \"aauaaaaada\"\nExplanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except 'u' and 'd' are transformed to 'a', the answer is \"aauaaaaada\".\n\n&nbsp;\nConstraints:\n\n\t1 <= s1.length, s2.length, baseStr <= 1000\n\ts1.length == s2.length\n\ts1, s2, and baseStr consist of lowercase English letters.",
        "solutions": [
            {
                "id": 3047517,
                "title": "python3-union-find-template-explanations",
                "content": "**Intuition**\\n - The rules for the \"equivalent characters\" introduced in the problem simply means **the two characters belong to the same group**.\\n - And our job is that for each character in ```baseStr```, we need to find its belonging group and find the smallest character from that group.\\n - So we have two tasks:\\n \\t- Create all the groups with equivalent characters from ```s1``` and ```s2```.\\n \\t- Find the group for each character in ```baseStr```, and find the smallest character in that group\\n\\n Grouping connected elements can be done using DFS/BFS/Union-find, I personally like Union-find because it makes the most sense, and very easy to implement using a template. If you don\\'t know about union-find or don\\'t have a good template, I put the best one I know below which I used a lot.\\n\\n**Basic Union-find template**\\n\\n```python\\n# UF is a hash map where you can find the root of a group of elements giving an element.\\n# A key in UF is a element, UF[x] is x\\'s parent.\\n# If UF[x] == x meaning x is the root of its group.\\nUF = {}\\n\\n# Given an element, find the root of the group to which this element belongs.\\ndef find(x):\\n    # this may be the first time we see x, so set itself as the root.\\n    if x not in UF:\\n        UF[x] = x\\n    # If x == UF[x], meaning x is the root of this group.\\n    # If x != UF[x], we use the find function again on x\\'s parent UF[x] \\n    # until we find the root and set it as the parent (value) of x in UF.\\n    if x != UF[x]:\\n        UF[x] = find(UF[x])\\n    return UF[x]\\n\\n# Given two elements x and y, we know that x and y should be in the same group, \\n# this means the group that contains x and the group that contains y \\n# should be merged together if they are currently separate groups.\\n# So we first find the root of x and the root of y using the find function.\\n# We then set the root of y (rootY) as the root of the root of x (rootX).\\ndef union(x, y):\\n\\n    rootX = find(x)\\n    rootY = find(y)\\n    # set the root of y (rootY) as the root of the root of x (rootX)\\n    UF[rootX] = rootY\\n```\\n\\nThe tricky part in this problem using Union-find template is to set the smallest element in a group as root of that group. Please see the changes below. \\n\\n**Union-find Solution**\\n```python\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        \\n        UF = {}\\n        def find(x):\\n            UF.setdefault(x,x)\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        def union(x,y):\\n            rootX = find(x)\\n            rootY = find(y)\\n            # The main issue we need to take care of in this problem is\\n            # that we want the root of a group to be \\n            # the smallest element in the group\\n            # So every time we add an element in a group, we check if it is the smallest one,\\n            # If it is, we set it as the root.\\n            if rootX>rootY:\\n                UF[rootX] = rootY\\n            else:\\n                UF[rootY] = rootX\\n        \\n        # Union the two equivalent characters\\n        # at the same position from s1 and s2 into the same group.\\n        for i in range(len(s1)):\\n            union(s1[i],s2[i])\\n        \\n        # Simply find the root of the group a character belongs to\\n        # Note that if c is not in any group, \\n        # we have UF.setdefault(x,x) in def find(x) to take care of it\\n        res = []\\n        for c in baseStr:\\n            res.append(find(c))\\n            \\n        return \\'\\'.join(res)\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```baseStr```\n```s1```\n```s2```\n```baseStr```\n```python\\n# UF is a hash map where you can find the root of a group of elements giving an element.\\n# A key in UF is a element, UF[x] is x\\'s parent.\\n# If UF[x] == x meaning x is the root of its group.\\nUF = {}\\n\\n# Given an element, find the root of the group to which this element belongs.\\ndef find(x):\\n    # this may be the first time we see x, so set itself as the root.\\n    if x not in UF:\\n        UF[x] = x\\n    # If x == UF[x], meaning x is the root of this group.\\n    # If x != UF[x], we use the find function again on x\\'s parent UF[x] \\n    # until we find the root and set it as the parent (value) of x in UF.\\n    if x != UF[x]:\\n        UF[x] = find(UF[x])\\n    return UF[x]\\n\\n# Given two elements x and y, we know that x and y should be in the same group, \\n# this means the group that contains x and the group that contains y \\n# should be merged together if they are currently separate groups.\\n# So we first find the root of x and the root of y using the find function.\\n# We then set the root of y (rootY) as the root of the root of x (rootX).\\ndef union(x, y):\\n\\n    rootX = find(x)\\n    rootY = find(y)\\n    # set the root of y (rootY) as the root of the root of x (rootX)\\n    UF[rootX] = rootY\\n```\n```python\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        \\n        UF = {}\\n        def find(x):\\n            UF.setdefault(x,x)\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        def union(x,y):\\n            rootX = find(x)\\n            rootY = find(y)\\n            # The main issue we need to take care of in this problem is\\n            # that we want the root of a group to be \\n            # the smallest element in the group\\n            # So every time we add an element in a group, we check if it is the smallest one,\\n            # If it is, we set it as the root.\\n            if rootX>rootY:\\n                UF[rootX] = rootY\\n            else:\\n                UF[rootY] = rootX\\n        \\n        # Union the two equivalent characters\\n        # at the same position from s1 and s2 into the same group.\\n        for i in range(len(s1)):\\n            union(s1[i],s2[i])\\n        \\n        # Simply find the root of the group a character belongs to\\n        # Note that if c is not in any group, \\n        # we have UF.setdefault(x,x) in def find(x) to take care of it\\n        res = []\\n        for c in baseStr:\\n            res.append(find(c))\\n            \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047664,
                "title": "c-union-find-beat-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int par[26];\\n    \\n    int find(int x){\\n        if(par[x]==-1) return x;\\n        return par[x]=find(par[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if (x != y) \\n            par[max(x, y)] = min(x, y); \\n    }\\n\\t\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        memset(par, -1, sizeof(par));\\n        \\n        for (auto i = 0; i < s1.size(); ++i) \\n            Union(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        \\n        for(auto i=0;i<baseStr.size();i++) \\n            baseStr[i]=find(baseStr[i]-\\'a\\')+\\'a\\';\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int par[26];\\n    \\n    int find(int x){\\n        if(par[x]==-1) return x;\\n        return par[x]=find(par[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if (x != y) \\n            par[max(x, y)] = min(x, y); \\n    }\\n\\t\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        memset(par, -1, sizeof(par));\\n        \\n        for (auto i = 0; i < s1.size(); ++i) \\n            Union(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        \\n        for(auto i=0;i<baseStr.size();i++) \\n            baseStr[i]=find(baseStr[i]-\\'a\\')+\\'a\\';\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047721,
                "title": "easy-c-solution-using-array-without-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to associate every lowercase english alphabet to it\\'s lexicographically smallest equivalent using the given properties of equality and transitivity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We define an array of size 26 to map each lowercase alphabet to its lexicographically smallest equivalent\\n2. Initialize this array with the char itself\\n3. Now for every index of string `s1` and `s2`, we replace all elements pointing to the greater char between `lowestEquivalent of s1[i]` and `lowestEquivalent of s2[i]` with the smaller one.\\n\\n#### Why does this work?\\n\\nAfter every step, we map all elements that were pointing to the greater equivalent to the smaller one (using properties of transitivity). Since we only have 26 alphabets, this can be done in roughly constant time.\\n\\neg: `s1 = \"ab\"` and `s2 = \"bc\"`\\nConsider the mapped array `lowest` (storing char to it\\'s lowest equivalent) to be:\\n```\\na = a\\nb = b\\nc = c\\n```\\n\\n#### At index = 0: `(a == b)`\\n```\\na = a\\nb = lowest[a] = a\\nc = c\\n```\\n\\n#### At index = 1: `(b == c)`\\n```\\na = a\\nb = a\\nc = lowest[b] = a\\n```\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * 26)$$ = $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(26)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        char ch[26];\\n        for (int i=0; i<26; i++)\\n            ch[i] = \\'a\\' + i;\\n\\n        for (int i=0; i<s1.size(); i++) {\\n            char toReplace = max(ch[s1[i]-\\'a\\'], ch[s2[i]-\\'a\\']);\\n            char replaceWith = min(ch[s1[i]-\\'a\\'], ch[s2[i]-\\'a\\']);\\n            for (int i=0; i<26; i++)\\n                if (ch[i] == toReplace)\\n                    ch[i] = replaceWith;\\n        }\\n        \\n        for (int i = 0; i<baseStr.size(); i++)\\n            baseStr[i] = ch[baseStr[i]-\\'a\\'];\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\na = a\\nb = b\\nc = c\\n```\n```\\na = a\\nb = lowest[a] = a\\nc = c\\n```\n```\\na = a\\nb = a\\nc = lowest[b] = a\\n```\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        char ch[26];\\n        for (int i=0; i<26; i++)\\n            ch[i] = \\'a\\' + i;\\n\\n        for (int i=0; i<s1.size(); i++) {\\n            char toReplace = max(ch[s1[i]-\\'a\\'], ch[s2[i]-\\'a\\']);\\n            char replaceWith = min(ch[s1[i]-\\'a\\'], ch[s2[i]-\\'a\\']);\\n            for (int i=0; i<26; i++)\\n                if (ch[i] == toReplace)\\n                    ch[i] = replaceWith;\\n        }\\n        \\n        for (int i = 0; i<baseStr.size(); i++)\\n            baseStr[i] = ch[baseStr[i]-\\'a\\'];\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318422,
                "title": "c-uf",
                "content": "```\\nint ds_find(vector<int>& ds, int p) {\\n  return ds[p] == -1 ? p : ds[p] = ds_find(ds, ds[p]);\\n}\\nvoid ds_merge(vector<int>& ds, int p1, int p2) {\\n  p1 = ds_find(ds, p1), p2 = ds_find(ds, p2);\\n  if (p1 != p2) ds[max(p1, p2)] = min(p1, p2);\\n}\\nstring smallestEquivalentString(string A, string B, string S) {\\n  vector<int> ds(26, -1);\\n  for (auto i = 0; i < A.size(); ++i) ds_merge(ds, A[i] - \\'a\\', B[i] - \\'a\\');\\n  for (auto i = 0; i < S.size(); ++i) S[i] = ds_find(ds, S[i] - \\'a\\') + \\'a\\';\\n  return S;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint ds_find(vector<int>& ds, int p) {\\n  return ds[p] == -1 ? p : ds[p] = ds_find(ds, ds[p]);\\n}\\nvoid ds_merge(vector<int>& ds, int p1, int p2) {\\n  p1 = ds_find(ds, p1), p2 = ds_find(ds, p2);\\n  if (p1 != p2) ds[max(p1, p2)] = min(p1, p2);\\n}\\nstring smallestEquivalentString(string A, string B, string S) {\\n  vector<int> ds(26, -1);\\n  for (auto i = 0; i < A.size(); ++i) ds_merge(ds, A[i] - \\'a\\', B[i] - \\'a\\');\\n  for (auto i = 0; i < S.size(); ++i) S[i] = ds_find(ds, S[i] - \\'a\\') + \\'a\\';\\n  return S;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306768,
                "title": "union-find-solution-java",
                "content": "```\\nclass Solution {\\n    public String smallestEquivalentString(String A, String B, String S) {\\n        int[] graph = new int[26];\\n        for(int i = 0; i < 26; i++) {\\n            graph[i] = i;\\n        }\\n        for(int i = 0; i < A.length(); i++) {\\n            int a = A.charAt(i) - \\'a\\';\\n            int b = B.charAt(i) - \\'a\\';\\n            int end1 = find(graph, b);\\n            int end2 = find(graph, a);\\n            if(end1 < end2) {\\n                graph[end2] = end1;\\n            } else {\\n                graph[end1] = end2;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < S.length(); i++) {\\n            char c = S.charAt(i);\\n            sb.append((char)(\\'a\\' + find(graph, c - \\'a\\')));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int[] graph, int idx) {\\n        while(graph[idx] != idx) {\\n            idx = graph[idx];\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String A, String B, String S) {\\n        int[] graph = new int[26];\\n        for(int i = 0; i < 26; i++) {\\n            graph[i] = i;\\n        }\\n        for(int i = 0; i < A.length(); i++) {\\n            int a = A.charAt(i) - \\'a\\';\\n            int b = B.charAt(i) - \\'a\\';\\n            int end1 = find(graph, b);\\n            int end2 = find(graph, a);\\n            if(end1 < end2) {\\n                graph[end2] = end1;\\n            } else {\\n                graph[end1] = end2;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < S.length(); i++) {\\n            char c = S.charAt(i);\\n            sb.append((char)(\\'a\\' + find(graph, c - \\'a\\')));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int[] graph, int idx) {\\n        while(graph[idx] != idx) {\\n            idx = graph[idx];\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048412,
                "title": "c-easiest-explanation-beginner-friendly-simple-array-implementation",
                "content": "# Approach\\n\\n- Make a character array of 26 characters.\\n- Initialize all the columns with the same character. i.e. index `0` representing `a`, `1` representing `b` and so on...\\n- Since same index characters of `s1` and `s2` are equal so we\\'ll find smaller and bigger characters between two same indexed characters of `s1` & `s2` named as `replace` and `put` respectively.\\n- So wherever we\\'ll find `replace`(bigger) character in map array we\\'ll replace it with the value of `put`(smaller) character in map array.\\n- Now our map consist of lexicographically smallest equivalent character of each index.\\n- Traverse the `baseStr` and replace all the characters with it\\'s smallest equivalent.\\n\\n \\n\\n# Complexity\\n- Time complexity: O(26*n) == O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26) == O(1), to create a map array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### You will understand explanation completely after going through code\\uD83D\\uDC47\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        char map[26];\\n        for(int i=0;i<26;i++){\\n            map[i] = i+\\'a\\';\\n        }\\n        for(int i=0;i<s1.size();i++){\\n            char replace = max(map[s1[i] - \\'a\\'],map[s2[i] - \\'a\\']); //Bigger element\\n            char put = min(map[s1[i] - \\'a\\'],map[s2[i] - \\'a\\']); // Smaller element\\n            for(int i=0;i<26;i++){\\n                if(map[i] == replace)\\n                    map[i] = put;   // Replace all the bigger characters with it\\'s smallest equivalent\\n            }\\n        }\\n\\n        string ans = \"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans += map[baseStr[i] - \\'a\\'];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Please upvote, if you find this helpful \\uD83D\\uDE4F \\n#### Thank you in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        char map[26];\\n        for(int i=0;i<26;i++){\\n            map[i] = i+\\'a\\';\\n        }\\n        for(int i=0;i<s1.size();i++){\\n            char replace = max(map[s1[i] - \\'a\\'],map[s2[i] - \\'a\\']); //Bigger element\\n            char put = min(map[s1[i] - \\'a\\'],map[s2[i] - \\'a\\']); // Smaller element\\n            for(int i=0;i<26;i++){\\n                if(map[i] == replace)\\n                    map[i] = put;   // Replace all the bigger characters with it\\'s smallest equivalent\\n            }\\n        }\\n\\n        string ans = \"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans += map[baseStr[i] - \\'a\\'];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049836,
                "title": "dsu-solution-cpp-beat-100",
                "content": "# Intuition\\nWe want to make a components with characters and get the minimum of each component\\n\\n# Approach\\n- **Reflexivity:** `\\'a\\' == \\'a\\'`.\\n- **Symmetry:** `\\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'`.\\n- **Transitivity:** `\\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'`.\\nthat means if there are two equivalent characters so the equivalent characters of the two characters are equivalent.\\n\\n***We will use Disjoint Set Union ( [DSU](https://cp-algorithms.com/data_structures/disjoint_set_union.html) )***\\n\\n# Complexity\\n- Time complexity:\\n    - $O(N \\\\times log(26))$ $\\\\approx$ $O(5 \\\\times N)$ $\\\\approx$ $O(N)$ \\n        - Where $N$ is the number of characters in the strings\\n\\n- Space complexity:\\n    - $O(26)$ $\\\\approx$ $O(1)$\\n# Code\\n```\\ntemplate < typename T = int, int Base = 0 > struct DSU {\\n    \\n    vector < T > parent;\\n\\n    // every parent will be a char equal to it, 0 -> \\'a\\', 1 -> \\'b\\' and so on\\n    DSU(int MaxNodes){\\n        parent = vector < T > (MaxNodes + 5);\\n        for(int i = Base; i <= MaxNodes; i++)\\n          parent[i] = char(i + \\'a\\');\\n    }\\n\\n    // git the index of the char to acces the vector\\n    int fix(char c){\\n        return c - \\'a\\';\\n    }\\n\\n    // get the leader of each component\\n    T find_leader(char node){\\n        return parent[fix(node)] = (parent[fix(node)] == node ? node : find_leader(parent[fix(node)]));\\n    }\\n\\n    // check if the two chars in the same set\\n    bool is_same_sets(char u, char v){\\n        return find_leader(u) == find_leader(v);\\n    }\\n\\n    // union two component together and make the leader is the smallest character in the component\\n    void union_sets(char u, char v){\\n        char leader_u = find_leader(u), leader_v = find_leader(v);\\n        if(leader_u == leader_v) return;\\n        if(leader_u > leader_v) \\n            swap(leader_u, leader_v);\\n        parent[fix(leader_v)] = leader_u;\\n    }\\n\\n    // get the minimum character in component and it is the leader of the component\\n    char get_min(char c){\\n        return find_leader(c);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        // DSU with char type\\n        DSU < char > dsu(26);\\n        \\n        // number of character\\n        int n = s1.size();\\n\\n        // union the two sets of the two characters together\\n        for(int i = 0; i < n; i++)\\n            dsu.union_sets(s1[i], s2[i]);\\n\\n        // replace every char in baseStr with the minimum char of it\\'s set\\n        for(auto& c : baseStr)\\n            c = dsu.get_min(c);\\n\\n        // the minimum lexicographically baseStr\\n        return baseStr;      \\n    }\\n};\\n```\\n\\n![2ddedd60-39d6-4167-9b77-88e10400f044_1673586388.8794823.jpeg](https://assets.leetcode.com/users/images/e72a5c55-b314-4ec6-9229-fb73b8eb7f55_1673697700.0906572.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\ntemplate < typename T = int, int Base = 0 > struct DSU {\\n    \\n    vector < T > parent;\\n\\n    // every parent will be a char equal to it, 0 -> \\'a\\', 1 -> \\'b\\' and so on\\n    DSU(int MaxNodes){\\n        parent = vector < T > (MaxNodes + 5);\\n        for(int i = Base; i <= MaxNodes; i++)\\n          parent[i] = char(i + \\'a\\');\\n    }\\n\\n    // git the index of the char to acces the vector\\n    int fix(char c){\\n        return c - \\'a\\';\\n    }\\n\\n    // get the leader of each component\\n    T find_leader(char node){\\n        return parent[fix(node)] = (parent[fix(node)] == node ? node : find_leader(parent[fix(node)]));\\n    }\\n\\n    // check if the two chars in the same set\\n    bool is_same_sets(char u, char v){\\n        return find_leader(u) == find_leader(v);\\n    }\\n\\n    // union two component together and make the leader is the smallest character in the component\\n    void union_sets(char u, char v){\\n        char leader_u = find_leader(u), leader_v = find_leader(v);\\n        if(leader_u == leader_v) return;\\n        if(leader_u > leader_v) \\n            swap(leader_u, leader_v);\\n        parent[fix(leader_v)] = leader_u;\\n    }\\n\\n    // get the minimum character in component and it is the leader of the component\\n    char get_min(char c){\\n        return find_leader(c);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        // DSU with char type\\n        DSU < char > dsu(26);\\n        \\n        // number of character\\n        int n = s1.size();\\n\\n        // union the two sets of the two characters together\\n        for(int i = 0; i < n; i++)\\n            dsu.union_sets(s1[i], s2[i]);\\n\\n        // replace every char in baseStr with the minimum char of it\\'s set\\n        for(auto& c : baseStr)\\n            c = dsu.get_min(c);\\n\\n        // the minimum lexicographically baseStr\\n        return baseStr;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047979,
                "title": "2-solutions-1ms-4ms-with-explanation-java",
                "content": "# Explaination for Approach 1 :\\nUse two maps to store each letter with its group and each group with  the letters in the group, respectively. Initially, all letters have different groups, and each group has only one letter, which is the letter itself.\\n\\nLoop over A and B and merge each pair of letters into one group. When merging into one group, only remain the group that is lexicographically smallest. All the letters from both previous groups are mapped to the remaining group, and the remaining group is mapped to all the letters from both previous groups.\\n\\nAfter the mappings are done, loop over S and obtain the group for each letter and replace the letter in S. Finally, return the new string.\\n# Request \\uD83D\\uDE0A :\\nIf you find these solutions easy to understand and helpful, then . Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [1 ms] approach).\\n# Approach 1 : 4 ms Solution\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String A, String B, String S) {\\n        Map<Character, Character> letterGroupMap = new HashMap<Character, Character>();\\n        Map<Character, Set<Character>> groupLettersMap = new HashMap<Character, Set<Character>>();\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            letterGroupMap.put(c, c);\\n            Set<Character> set = new HashSet<Character>();\\n            set.add(c);\\n            groupLettersMap.put(c, set);\\n        }\\n        int length = A.length();\\n        for (int i = 0; i < length; i++) {\\n            char c1 = A.charAt(i), c2 = B.charAt(i);\\n            char group1 = letterGroupMap.get(c1), group2 = letterGroupMap.get(c2);\\n            if (group1 != group2) {\\n                Set<Character> set1 = groupLettersMap.get(group1);\\n                Set<Character> set2 = groupLettersMap.get(group2);\\n                if (group1 < group2) {\\n                    for (char c : set2)\\n                        letterGroupMap.put(c, group1);\\n                    set1.addAll(set2);\\n                    groupLettersMap.put(group1, set1);\\n                    groupLettersMap.remove(group2);\\n                } else {\\n                    for (char c : set1)\\n                        letterGroupMap.put(c, group2);\\n                    set2.addAll(set1);\\n                    groupLettersMap.put(group2, set2);\\n                    groupLettersMap.remove(group1);\\n                }\\n            }\\n        }\\n        char[] array = S.toCharArray();\\n        int strLength = array.length;\\n        for (int i = 0; i < strLength; i++) {\\n            char c = array[i];\\n            char group = letterGroupMap.get(c);\\n            array[i] = group;\\n        }\\n        return new String(array);\\n    }\\n}\\n```\\n\\n# Approach 2 : 1 ms Solution [Fastest]\\n```\\nclass Solution {\\n    private int[] p;\\n\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        p = new int[26];\\n        for (int i = 0; i < 26; ++i) {\\n            p[i] = i;\\n        }\\n        for (int i = 0; i < s1.length(); ++i) {\\n            int a = s1.charAt(i) - \\'a\\', b = s2.charAt(i) - \\'a\\';\\n            int pa = find(a), pb = find(b);\\n            if (pa < pb) {\\n                p[pb] = pa;\\n            } else {\\n                p[pa] = pb;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char a : baseStr.toCharArray()) {\\n            char b = (char) (find(a - \\'a\\') + \\'a\\');\\n            sb.append(b);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private int find(int x) {\\n        if (p[x] != x) {\\n            p[x] = find(p[x]);\\n        }\\n        return p[x];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String A, String B, String S) {\\n        Map<Character, Character> letterGroupMap = new HashMap<Character, Character>();\\n        Map<Character, Set<Character>> groupLettersMap = new HashMap<Character, Set<Character>>();\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            letterGroupMap.put(c, c);\\n            Set<Character> set = new HashSet<Character>();\\n            set.add(c);\\n            groupLettersMap.put(c, set);\\n        }\\n        int length = A.length();\\n        for (int i = 0; i < length; i++) {\\n            char c1 = A.charAt(i), c2 = B.charAt(i);\\n            char group1 = letterGroupMap.get(c1), group2 = letterGroupMap.get(c2);\\n            if (group1 != group2) {\\n                Set<Character> set1 = groupLettersMap.get(group1);\\n                Set<Character> set2 = groupLettersMap.get(group2);\\n                if (group1 < group2) {\\n                    for (char c : set2)\\n                        letterGroupMap.put(c, group1);\\n                    set1.addAll(set2);\\n                    groupLettersMap.put(group1, set1);\\n                    groupLettersMap.remove(group2);\\n                } else {\\n                    for (char c : set1)\\n                        letterGroupMap.put(c, group2);\\n                    set2.addAll(set1);\\n                    groupLettersMap.put(group2, set2);\\n                    groupLettersMap.remove(group1);\\n                }\\n            }\\n        }\\n        char[] array = S.toCharArray();\\n        int strLength = array.length;\\n        for (int i = 0; i < strLength; i++) {\\n            char c = array[i];\\n            char group = letterGroupMap.get(c);\\n            array[i] = group;\\n        }\\n        return new String(array);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int[] p;\\n\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        p = new int[26];\\n        for (int i = 0; i < 26; ++i) {\\n            p[i] = i;\\n        }\\n        for (int i = 0; i < s1.length(); ++i) {\\n            int a = s1.charAt(i) - \\'a\\', b = s2.charAt(i) - \\'a\\';\\n            int pa = find(a), pb = find(b);\\n            if (pa < pb) {\\n                p[pb] = pa;\\n            } else {\\n                p[pa] = pb;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char a : baseStr.toCharArray()) {\\n            char b = (char) (find(a - \\'a\\') + \\'a\\');\\n            sb.append(b);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private int find(int x) {\\n        if (p[x] != x) {\\n            p[x] = find(p[x]);\\n        }\\n        return p[x];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412777,
                "title": "python-bfs-dfs-union-find-complexity-analysis",
                "content": "**BFS w/o memo: beats 5.81%**\\n\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, A, B, S):\\n\\t\\t\\'\\'\\'step1: Create a mapping from each char to its direct equivalents.\\'\\'\\'\\n        neighbors = collections.defaultdict(set)\\n        for a, b in zip(A, B):\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n\\t\\t\\n\\t\\t\\'\\'\\'step2: For each char of S, explore the map of all equivalents (marke as seen) \\n\\t\\tand memoize the minimum equivalents.\\'\\'\\'\\n        d = {i:i for i in S}\\n\\n        def bfs(ch):\\n            res = ch\\n            seen = set()\\n            queue = {ch}\\n\\n            while queue:\\n                c = queue.pop()\\n                if c in seen: continue\\n                seen.add(c)\\n                res = min(res, c)\\n                queue |= neighbors[c]\\n\\n            for v in seen:\\n                d[v] = res\\n\\n            return res\\n        return \\'\\'.join(bfs(c) for c  in S)\\n```\\n\\n**BFS w/ memo: beats 99.35%**\\n\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, A, B, S):\\n        neighbors = collections.defaultdict(set)\\n        for a, b in zip(A, B):\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n\\n        memo = {}\\n\\n        def bfs(ch):\\n            if ch in memo: return memo[ch]\\n            res = ch\\n            seen = set()\\n            queue = {ch}\\n\\n            while queue:\\n                c = queue.pop()\\n                if c in seen: continue\\n                seen.add(c)\\n                res = min(res, c)\\n                queue |= neighbors[c]\\n\\n            for v in seen:\\n                memo[v] = res\\n\\n            return res\\n        return \\'\\'.join(bfs(c) for c  in S)\\n        \\n```\\n\\n**DFS: beats 5.8%**\\n\\n```\\nclass Solution(object):   \\n    def smallestEquivalentString(self, A, B, S):\\n        neighbors = collections.defaultdict(set)\\n        for a, b in zip(A, B):\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        \\n        visited = set()\\n        def dfs(ch, minChar, visited):\\n            visited.add(ch)\\n            res = minChar\\n            \\n            for nei in neighbors[ch]:\\n                if nei not in visited:\\n                    res = min(res, dfs(nei, min(minChar, nei), visited))\\n            return res\\n\\n\\n        return \\'\\'.join([dfs(c, c, set()) for c in S])\\n```\\n\\n\\n\\n**Union Find: beats 97.42%**\\n\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, A: str, B: str, S: str) -> str:\\n\\t    \\'\\'\\'\\n        step1: model these equalities as edges in a graph\\n        step2: compute connected components of the graph ==> {node: commID}\\n        step3: convert \\'s\\'\\n        \\'\\'\\'\\n        # step 1 & 2\\n        d = {i:i for i in string.ascii_lowercase}\\n        \\n        def find(x):\\n            if d[x] != x:\\n                d[x] = find(d[x])\\n            return d[x]\\n        \\n        def union(x, y):\\n            rx, ry = find(x), find(y)\\n            if d[rx] < d[ry]:\\n                d[ry] = rx\\n            else:\\n                d[rx] = ry\\n        \\n        for a, b in zip(A, B):\\n            union(a, b)\\n\\t\\t\\t\\n        # step3\\n        ans = \\'\\'\\n        for s in S:\\n            ans += find(s)\\n        return ans\\n```\\n\\n**Complexity:**\\n* Time: O(max(n, m)) where n is length of A, and m is length of S.\\n* space: O(1).  Since we only need to store the 26 English characters.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, A, B, S):\\n\\t\\t\\'\\'\\'step1: Create a mapping from each char to its direct equivalents.\\'\\'\\'\\n        neighbors = collections.defaultdict(set)\\n        for a, b in zip(A, B):\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n\\t\\t\\n\\t\\t\\'\\'\\'step2: For each char of S, explore the map of all equivalents (marke as seen) \\n\\t\\tand memoize the minimum equivalents.\\'\\'\\'\\n        d = {i:i for i in S}\\n\\n        def bfs(ch):\\n            res = ch\\n            seen = set()\\n            queue = {ch}\\n\\n            while queue:\\n                c = queue.pop()\\n                if c in seen: continue\\n                seen.add(c)\\n                res = min(res, c)\\n                queue |= neighbors[c]\\n\\n            for v in seen:\\n                d[v] = res\\n\\n            return res\\n        return \\'\\'.join(bfs(c) for c  in S)\\n```\n```\\nclass Solution:\\n    def smallestEquivalentString(self, A, B, S):\\n        neighbors = collections.defaultdict(set)\\n        for a, b in zip(A, B):\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n\\n        memo = {}\\n\\n        def bfs(ch):\\n            if ch in memo: return memo[ch]\\n            res = ch\\n            seen = set()\\n            queue = {ch}\\n\\n            while queue:\\n                c = queue.pop()\\n                if c in seen: continue\\n                seen.add(c)\\n                res = min(res, c)\\n                queue |= neighbors[c]\\n\\n            for v in seen:\\n                memo[v] = res\\n\\n            return res\\n        return \\'\\'.join(bfs(c) for c  in S)\\n        \\n```\n```\\nclass Solution(object):   \\n    def smallestEquivalentString(self, A, B, S):\\n        neighbors = collections.defaultdict(set)\\n        for a, b in zip(A, B):\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        \\n        visited = set()\\n        def dfs(ch, minChar, visited):\\n            visited.add(ch)\\n            res = minChar\\n            \\n            for nei in neighbors[ch]:\\n                if nei not in visited:\\n                    res = min(res, dfs(nei, min(minChar, nei), visited))\\n            return res\\n\\n\\n        return \\'\\'.join([dfs(c, c, set()) for c in S])\\n```\n```\\nclass Solution:\\n    def smallestEquivalentString(self, A: str, B: str, S: str) -> str:\\n\\t    \\'\\'\\'\\n        step1: model these equalities as edges in a graph\\n        step2: compute connected components of the graph ==> {node: commID}\\n        step3: convert \\'s\\'\\n        \\'\\'\\'\\n        # step 1 & 2\\n        d = {i:i for i in string.ascii_lowercase}\\n        \\n        def find(x):\\n            if d[x] != x:\\n                d[x] = find(d[x])\\n            return d[x]\\n        \\n        def union(x, y):\\n            rx, ry = find(x), find(y)\\n            if d[rx] < d[ry]:\\n                d[ry] = rx\\n            else:\\n                d[rx] = ry\\n        \\n        for a, b in zip(A, B):\\n            union(a, b)\\n\\t\\t\\t\\n        # step3\\n        ans = \\'\\'\\n        for s in S:\\n            ans += find(s)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047649,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=_8TI_gX4rv4&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=14) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/54LYhAeL/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=_8TI_gX4rv4&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=14) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/54LYhAeL/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3047507,
                "title": "python-union-find",
                "content": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        def find(c):\\n            i = ord(c) - ord(\\'a\\')\\n            while root[i] != i:\\n                i = root[i]\\n                \\n            return i\\n        \\n        root = list(range(26))\\n        for c1, c2 in zip(s1, s2):\\n            r1 = find(c1)\\n            r2 = find(c2)\\n            if r1 > r2:\\n                r1, r2 = r2, r1\\n\\n            root[r2] = r1\\n        \\n        return \"\".join(chr(ord(\\'a\\') + find(c)) for c in baseStr)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        def find(c):\\n            i = ord(c) - ord(\\'a\\')\\n            while root[i] != i:\\n                i = root[i]\\n                \\n            return i\\n        \\n        root = list(range(26))\\n        for c1, c2 in zip(s1, s2):\\n            r1 = find(c1)\\n            r2 = find(c2)\\n            if r1 > r2:\\n                r1, r2 = r2, r1\\n\\n            root[r2] = r1\\n        \\n        return \"\".join(chr(ord(\\'a\\') + find(c)) for c in baseStr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048027,
                "title": "c-java-python-dsu-uf-approach-o-nlogn",
                "content": "**`USING THE BASIC TEMPLATE OF DSU (DISJOINT SET)`**\\n\\n**Intuition**:\\nThe intuition behind using a `disjoint` set (DSU) in this problem is to create an `equivalence` relationship between the characters in the `two` input strings `s1` and `s2`. The goal is to find the smallest equivalent string using the base string `baseStr`, so the idea is to group the characters in `s1` and `s2` that are `equivalent` and `replace` them with the `smallest` character in that group.\\n\\n**Approach**:\\n\\n1. Initialize a disjoint set of size `26`, representing the 26 characters in the alphabet.\\n2. Iterate through the characters of the **two** input strings **s1** and **s2**, and for each pair of characters `(s1[i], s2[i])`, use the `unionBySize` function of the disjoint set to create an equivalence relationship between them by merging the sets they belong to. This step ensures that all characters that are equivalent in `s1` and `s2` are in the same set.\\n3. Iterate through the characters in the base string **baseStr** and for each character, use the **findPar** function of the `disjoint` set to find the representative character of the set that the character belongs to.\\n4. Append the representative character to the `result` string, this will be the `smallest` equivalent character for the current character in the base string `baseStr`.\\n5. Return the result `string`\\n\\nBy the end of the above steps, the `result` string will be the smallest equivalent string. The approach is using` DSU `for creating an equivalent relationship between the characters in `s1` and `s2`, and then using `findPar` to find the `smallest` character in the set for each character in the base string `baseStr`.\\n\\n----\\n\\n**Codes:**\\n\\n**C++:**\\n```\\nclass DisjointSet{\\n    vector<int>parent,size;\\n public:\\n    DisjointSet(int n) {\\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n\\t}\\n    int findPar(int node){\\n        if(node==parent[node]) return node;\\n        return parent[node] =findPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v) {\\n        int up = findPar(u); \\n        int uv = findPar(v); \\n        if(up == uv) return; \\n        if(up < uv) {\\n            parent[uv] = up; \\n        }\\n        else {\\n            parent[up] = uv;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        DisjointSet ds(26);\\n        for(int i=0;i<n;i++){\\n            ds.unionBySize(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n        string res=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            res+=(char)(ds.findPar(baseStr[i]-\\'a\\')+\\'a\\');\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n----\\n**Java:**\\n```\\nclass DisjointSet{\\n    int[] parent, size;\\n    public DisjointSet(int n) {\\n        parent = new int[n+1];\\n        size = new int[n+1]; \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n    int findPar(int node){\\n        if(node==parent[node]) return node;\\n        return parent[node] =findPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v) {\\n        int up = findPar(u); \\n        int uv = findPar(v); \\n        if(up == uv) return; \\n        if(up < uv) {\\n            parent[uv] = up; \\n        }\\n        else {\\n            parent[up] = uv;\\n        }\\n    }\\n}\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n = s1.length();\\n        DisjointSet ds = new DisjointSet(26);\\n        for(int i=0;i<n;i++){\\n            ds.unionBySize(s1.charAt(i)-\\'a\\',s2.charAt(i)-\\'a\\');\\n        }\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0;i<baseStr.length();i++){\\n            res.append((char)(ds.findPar(baseStr.charAt(i)-\\'a\\')+\\'a\\'));\\n        }\\n        return res.toString();\\n    }\\n}\\n```\\n\\n----\\n**Python:**\\n```\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.size = [1 for _ in range(n+1)]\\n\\n    def findPar(self, node):\\n        if node == self.parent[node]:\\n            return node\\n        self.parent[node] = self.findPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def unionBySize(self, u, v):\\n        up = self.findPar(u)\\n        uv = self.findPar(v)\\n        if up == uv:\\n            return\\n        if up < uv:\\n            self.parent[uv] = up\\n        else:\\n            self.parent[up] = uv\\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        n = len(s1)\\n        ds = DisjointSet(26)\\n        for i in range(n):\\n            ds.unionBySize(ord(s1[i]) - ord(\\'a\\'), ord(s2[i]) - ord(\\'a\\'))\\n        res = \"\"\\n        for i in range(len(baseStr)):\\n            res += chr(ds.findPar(ord(baseStr[i]) - ord(\\'a\\')) + ord(\\'a\\'))\\n        return res\\n```\\n\\n\\n----\\nThe **Time Complexity** of this approach is **O(n log n)**, where `n` is the number of characters in baseStr, due to the use of union-by-size and the `findPar` function. \\nThe **Space Complexity** is **O(n)**, where `n` is the number of characters in the alphabet used in the input strings, due to the use of a disjoint set with one representative per set.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet{\\n    vector<int>parent,size;\\n public:\\n    DisjointSet(int n) {\\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n\\t}\\n    int findPar(int node){\\n        if(node==parent[node]) return node;\\n        return parent[node] =findPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v) {\\n        int up = findPar(u); \\n        int uv = findPar(v); \\n        if(up == uv) return; \\n        if(up < uv) {\\n            parent[uv] = up; \\n        }\\n        else {\\n            parent[up] = uv;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        DisjointSet ds(26);\\n        for(int i=0;i<n;i++){\\n            ds.unionBySize(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n        string res=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            res+=(char)(ds.findPar(baseStr[i]-\\'a\\')+\\'a\\');\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass DisjointSet{\\n    int[] parent, size;\\n    public DisjointSet(int n) {\\n        parent = new int[n+1];\\n        size = new int[n+1]; \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n    int findPar(int node){\\n        if(node==parent[node]) return node;\\n        return parent[node] =findPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v) {\\n        int up = findPar(u); \\n        int uv = findPar(v); \\n        if(up == uv) return; \\n        if(up < uv) {\\n            parent[uv] = up; \\n        }\\n        else {\\n            parent[up] = uv;\\n        }\\n    }\\n}\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n = s1.length();\\n        DisjointSet ds = new DisjointSet(26);\\n        for(int i=0;i<n;i++){\\n            ds.unionBySize(s1.charAt(i)-\\'a\\',s2.charAt(i)-\\'a\\');\\n        }\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0;i<baseStr.length();i++){\\n            res.append((char)(ds.findPar(baseStr.charAt(i)-\\'a\\')+\\'a\\'));\\n        }\\n        return res.toString();\\n    }\\n}\\n```\n```\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.size = [1 for _ in range(n+1)]\\n\\n    def findPar(self, node):\\n        if node == self.parent[node]:\\n            return node\\n        self.parent[node] = self.findPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def unionBySize(self, u, v):\\n        up = self.findPar(u)\\n        uv = self.findPar(v)\\n        if up == uv:\\n            return\\n        if up < uv:\\n            self.parent[uv] = up\\n        else:\\n            self.parent[up] = uv\\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        n = len(s1)\\n        ds = DisjointSet(26)\\n        for i in range(n):\\n            ds.unionBySize(ord(s1[i]) - ord(\\'a\\'), ord(s2[i]) - ord(\\'a\\'))\\n        res = \"\"\\n        for i in range(len(baseStr)):\\n            res += chr(ds.findPar(ord(baseStr[i]) - ord(\\'a\\')) + ord(\\'a\\'))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047642,
                "title": "easy-c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Created 26 size vector to store corresponding equal character.\\n2. Assigned same Character Initaially.\\n3. Inside loop of `s1.length()` Finding both char position and putting value of min in max among them position.\\n4. Performed Same Operation on `baseStr` and returned new `baseStr`.\\n\\n\\n# Complexity\\n- Time complexity: $$O(max(s1.length(),baseStr.length()))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int abc(int i,vector<int>& p){\\n        if(i==p[i]) return i;\\n        p[i] = abc(p[i],p);\\n        return p[i];\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<int> p(26,0);\\n        for(int i=0;i<26;i++) p[i]=i;\\n        for(int i=0;i<s1.length();i++){\\n            int x = abc(s1[i]-\\'a\\',p);\\n            int y = abc(s2[i]-\\'a\\',p);\\n            p[max(x,y)] = min(x,y);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            baseStr[i]=abc(baseStr[i]-\\'a\\',p)+\\'a\\';\\n        }\\n        return baseStr;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n# **`--------------------------Don\\'t Forget to UpVote.--------------------------`**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int abc(int i,vector<int>& p){\\n        if(i==p[i]) return i;\\n        p[i] = abc(p[i],p);\\n        return p[i];\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<int> p(26,0);\\n        for(int i=0;i<26;i++) p[i]=i;\\n        for(int i=0;i<s1.length();i++){\\n            int x = abc(s1[i]-\\'a\\',p);\\n            int y = abc(s2[i]-\\'a\\',p);\\n            p[max(x,y)] = min(x,y);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            baseStr[i]=abc(baseStr[i]-\\'a\\',p)+\\'a\\';\\n        }\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047687,
                "title": "explained-java-union-find-and-brute-force-faster-than-100",
                "content": "\\nWe represent the problem as a graph problem. Each group of characters represents a connected component. To solve this use Union Find to group the characters and chose the lexicographically smallest member of each set to be the set\\'s representative.\\n\\n##### Approach \\nImplement Union Find. Unite all `s1[i]` and `s2[i]` for all `0 <= i < n.` Then iterate through the characters of baseStr and replace each with the **smallest representative** of its the group.\\n\\n#### Code\\n\\n```\\nclass Solution \\n{\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) \\n    {\\n        int[] graph = new int[26];\\n        for(int i = 0; i < 26; i++) \\n            graph[i] = i;\\n            \\n        for(int i = 0; i < s1.length(); i++) \\n        {\\n            int first = s1.charAt(i) - \\'a\\';\\n            int second = s2.charAt(i) - \\'a\\';\\n            int end1 = find(graph, first);\\n            int end2 = find(graph, second);\\n            if(end1 < end2) \\n            {\\n                graph[end2] = end1;\\n            } \\n            else \\n            {\\n                graph[end1] = end2;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < baseStr.length(); i++) \\n        {\\n            char c = baseStr.charAt(i);\\n            sb.append((char)(\\'a\\' + find(graph, c - \\'a\\')));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int[] graph, int index) \\n    {\\n        while(graph[index] != index) \\n        {\\n            index = graph[index];\\n        }\\n        return index;\\n    }\\n}\\n```\\n\\n##### Another solution (helpes in visualisation of set formation)\\n*More like a brute force*\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) \\n    {\\n        int len = s1.length();\\n        List<Set<Character>> set = new ArrayList<>();\\n        int currSet = 1;\\n        int[] sets = new int[26];\\n        for(int i=0; i<len; i++)\\n        {\\n            // System.out.println(set);\\n            char c1 = s1.charAt(i);\\n            char c2 = s2.charAt(i);\\n            if(c1==c2) continue;\\n            if(sets[c1-\\'a\\'] == 0 && sets[c2-\\'a\\'] == 0)\\n            {\\n                Set<Character> newSet = new TreeSet<>();\\n                newSet.add(c1);\\n                newSet.add(c2);\\n                sets[c1-\\'a\\'] = currSet;\\n                sets[c2-\\'a\\'] = currSet;\\n                currSet++;\\n                set.add(newSet);\\n            }\\n            else if(sets[c1-\\'a\\'] == 0)\\n            {\\n                Set<Character> curr = set.get(sets[c2-\\'a\\']-1);\\n                curr.add(c1);\\n                sets[c1-\\'a\\'] = sets[c2-\\'a\\'];\\n            }\\n            else if(sets[c2-\\'a\\'] == 0)\\n            {\\n                Set<Character> curr = set.get(sets[c1-\\'a\\']-1);\\n                curr.add(c2);\\n                sets[c2-\\'a\\'] = sets[c1-\\'a\\'];\\n            }\\n            else if(sets[c2-\\'a\\'] != sets[c1-\\'a\\'])\\n            {\\n                // System.out.println(Arrays.toString(sets));\\n                // System.out.println(c2+\"  \"+c1);\\n                Set<Character> first = set.get(sets[c1-\\'a\\']-1);\\n                Set<Character> second = set.get(sets[c2-\\'a\\']-1);\\n                for(char cha : second)\\n                {\\n                    first.add(cha);\\n                    sets[cha-\\'a\\'] = sets[c1-\\'a\\'];\\n                }\\n                second.clear();\\n            }\\n        }\\n        System.out.println(set);\\n        \\n        String ans = \"\";\\n        for(int i=0; i<baseStr.length(); i++)\\n        {\\n            char ch = baseStr.charAt(i);\\n            int index = sets[ch-\\'a\\']-1;\\n            if(index<0) ans += ch;\\n            else ans += set.get(index).iterator().next();;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) \\n    {\\n        int[] graph = new int[26];\\n        for(int i = 0; i < 26; i++) \\n            graph[i] = i;\\n            \\n        for(int i = 0; i < s1.length(); i++) \\n        {\\n            int first = s1.charAt(i) - \\'a\\';\\n            int second = s2.charAt(i) - \\'a\\';\\n            int end1 = find(graph, first);\\n            int end2 = find(graph, second);\\n            if(end1 < end2) \\n            {\\n                graph[end2] = end1;\\n            } \\n            else \\n            {\\n                graph[end1] = end2;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < baseStr.length(); i++) \\n        {\\n            char c = baseStr.charAt(i);\\n            sb.append((char)(\\'a\\' + find(graph, c - \\'a\\')));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int[] graph, int index) \\n    {\\n        while(graph[index] != index) \\n        {\\n            index = graph[index];\\n        }\\n        return index;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) \\n    {\\n        int len = s1.length();\\n        List<Set<Character>> set = new ArrayList<>();\\n        int currSet = 1;\\n        int[] sets = new int[26];\\n        for(int i=0; i<len; i++)\\n        {\\n            // System.out.println(set);\\n            char c1 = s1.charAt(i);\\n            char c2 = s2.charAt(i);\\n            if(c1==c2) continue;\\n            if(sets[c1-\\'a\\'] == 0 && sets[c2-\\'a\\'] == 0)\\n            {\\n                Set<Character> newSet = new TreeSet<>();\\n                newSet.add(c1);\\n                newSet.add(c2);\\n                sets[c1-\\'a\\'] = currSet;\\n                sets[c2-\\'a\\'] = currSet;\\n                currSet++;\\n                set.add(newSet);\\n            }\\n            else if(sets[c1-\\'a\\'] == 0)\\n            {\\n                Set<Character> curr = set.get(sets[c2-\\'a\\']-1);\\n                curr.add(c1);\\n                sets[c1-\\'a\\'] = sets[c2-\\'a\\'];\\n            }\\n            else if(sets[c2-\\'a\\'] == 0)\\n            {\\n                Set<Character> curr = set.get(sets[c1-\\'a\\']-1);\\n                curr.add(c2);\\n                sets[c2-\\'a\\'] = sets[c1-\\'a\\'];\\n            }\\n            else if(sets[c2-\\'a\\'] != sets[c1-\\'a\\'])\\n            {\\n                // System.out.println(Arrays.toString(sets));\\n                // System.out.println(c2+\"  \"+c1);\\n                Set<Character> first = set.get(sets[c1-\\'a\\']-1);\\n                Set<Character> second = set.get(sets[c2-\\'a\\']-1);\\n                for(char cha : second)\\n                {\\n                    first.add(cha);\\n                    sets[cha-\\'a\\'] = sets[c1-\\'a\\'];\\n                }\\n                second.clear();\\n            }\\n        }\\n        System.out.println(set);\\n        \\n        String ans = \"\";\\n        for(int i=0; i<baseStr.length(); i++)\\n        {\\n            char ch = baseStr.charAt(i);\\n            int index = sets[ch-\\'a\\']-1;\\n            if(index<0) ans += ch;\\n            else ans += set.get(index).iterator().next();;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049259,
                "title": "simple-python-solution-with-explanation-beats-96-5",
                "content": "# Approach\\n\\n* Create two maps `char_group` and `char_map` to track characters which are equivalent:\\n    \\n    ![Untitled-2023-01-11-1852(11).png](https://assets.leetcode.com/users/images/4b6151d4-d967-4797-a7f9-34ce033bb30c_1673700018.0016778.png)\\n\\n    `char_group` is a map of groups of characters which are equivalent, eg: \\'a\\', \\'d\\', \\'e\\' are equivalent with group_id as 0.\\n\\n    \\n    ![Untitled-2023-01-11-1852(12).png](https://assets.leetcode.com/users/images/fdc19f3f-08c8-4d96-bca9-786c32fc8f6e_1673700041.7656307.png)\\n\\n    `char_map`: is a map of characters to the equivalent group it belongs, eg: \\'a\\', \\'d\\', \\'e\\' belong to group_id 0. If the character doesn\\'t belong to any group, the default value is -1.\\n\\n* Sort `char_group` lexicographically (since we need only the smallest lexicographic character, we can optimise this by selecting only the smallest character).\\n\\n* For `basestr` for each character check using `char_map` which equivalent group the character belongs to and select the smallest lexicographic character (0th index since we have sorted this).\\n\\n\\n# Complexity\\n`n` => len(s1)\\n`m` => len(baseStr)\\n\\n- Time complexity:\\n$$O(m + n*26 + 26*26)$$ => $$O(m + n)$$\\n\\n- Space complexity:\\n$$O(m + (26 + 26*26))$$ => $$O(m))$$\\n\\n    `char_map` and `char_group` are considered constant since `char_map` and `char_group` can have 26 max keys, and for each key in `char_group` it can have value of list of max 26 members\\n\\n# Code\\n``` python []\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        char_group = {}\\n        idx = 0\\n        char_map = {chr(97 + i): -1 for i in range(26)}\\n\\n        for i in range(len(s1)):\\n            if s1[i] == s2[i]:\\n                continue\\n\\n            if char_map[s1[i]] == -1 and char_map[s2[i]] == -1:\\n                char_map[s1[i]] = char_map[s2[i]] = idx\\n                char_group[idx] = [s2[i], s1[i]]\\n                idx += 1\\n            elif char_map[s1[i]] == -1:\\n                char_map[s1[i]] = char_map[s2[i]]\\n                char_group[char_map[s2[i]]].append(s1[i])\\n            elif char_map[s2[i]] == -1:\\n                char_map[s2[i]] = char_map[s1[i]]\\n                char_group[char_map[s1[i]]].append(s2[i])\\n            elif char_map[s1[i]] != char_map[s2[i]]:\\n                for c in char_group[char_map[s2[i]]]:\\n                    char_map[c] = char_map[s1[i]]\\n                    char_group[char_map[s1[i]]].append(c)\\n\\n        # sort each group\\n        for k in char_group.keys():\\n            char_group[k].sort()\\n\\n        ans = \"\"\\n        for c in baseStr:\\n            if char_map[c] == -1:\\n                ans += c\\n            else:\\n                ans += char_group[char_map[c]][0]\\n\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "``` python []\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        char_group = {}\\n        idx = 0\\n        char_map = {chr(97 + i): -1 for i in range(26)}\\n\\n        for i in range(len(s1)):\\n            if s1[i] == s2[i]:\\n                continue\\n\\n            if char_map[s1[i]] == -1 and char_map[s2[i]] == -1:\\n                char_map[s1[i]] = char_map[s2[i]] = idx\\n                char_group[idx] = [s2[i], s1[i]]\\n                idx += 1\\n            elif char_map[s1[i]] == -1:\\n                char_map[s1[i]] = char_map[s2[i]]\\n                char_group[char_map[s2[i]]].append(s1[i])\\n            elif char_map[s2[i]] == -1:\\n                char_map[s2[i]] = char_map[s1[i]]\\n                char_group[char_map[s1[i]]].append(s2[i])\\n            elif char_map[s1[i]] != char_map[s2[i]]:\\n                for c in char_group[char_map[s2[i]]]:\\n                    char_map[c] = char_map[s1[i]]\\n                    char_group[char_map[s1[i]]].append(c)\\n\\n        # sort each group\\n        for k in char_group.keys():\\n            char_group[k].sort()\\n\\n        ans = \"\"\\n        for c in baseStr:\\n            if char_map[c] == -1:\\n                ans += c\\n            else:\\n                ans += char_group[char_map[c]][0]\\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049135,
                "title": "c-java-detailed-explanation-w-two-methods-commented-code-with-examples",
                "content": "***METHOD 1 (DFS):***\\n\\n**Intuition:**\\n* Problem is looking for the lexicographically smallest equivalent string of baseStr by using equivalency information of strings s1 and s2.\\n* So if we observe then we will found out that we have to ***make some connection*** between characters of strings s1 and s2.\\n\\n* After establishing characters between them (means after making component) we can then pick the smallest character out of them \\nand replace a specific character in baseStr with connected minimum character which we will found out in establishing connection.\\n* Now, if we observe some terminology that we use in above statements as (e.g connection between words) we found that we ***can represent every character as a node*** \\nand then ***connection between them can be called as edge between those characters***.\\n* So, whole problem can be treated as **graph problem** and to each character (now called as a node)\\nwe will create a connection with equivalency information provided to us (now called as an edge).\\n_______\\n**WHAT WE WILL DO:**\\n* We will divide the question in three parts:\\n* Make the adjacency List from the given string s1 and s2 with the condition of equivalence relation. \\n      i) One thing that we have to notice here is that index 0 will represent character \\u2018a\\u2019 , index 1 will represent character \\u2018b\\u2019, index 2 will represent character \\u2018c\\u2019 and so on\\u2026.\\n* We will replace each character (i.e from \\u2018a\\u2019 to \\u2018z\\u2019) with minimumm character we will found out in that component.\\n\\n* Now we will replace the character of baseStr with the minimum character we wil found out in the component of that character.\\n\\n**SOME NOTES:**\\n* Our visited vector will be work as to find out that a character is already visited or not as well as the minimum character we found out for each character in their respective component.\\n* Since, we are playing here with  characters, so we will declare our visited vector of size 26 only, coz English alphabets have 26 characters only.\\n_________\\n**Time and Space Complexity:**\\n```\\nTime Complexity: O(n), because we will establish connection according to given equivalence relation.\\nSpace Complexity: O(n), we will make adjacency list here.\\n```\\n_____\\n**CODES:**\\n* **C++**\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<char> adj[], char node, char minCharacter, vector<char>& visited)\\n    {\\n        // to this character, replace it with it\\'s minimum character\\n        visited[node - \\'a\\'] = minCharacter;\\n        \\n        // travel in neighbour of this character,\\n        // i.e travel in component of this character\\n        for(char& near: adj[node - \\'a\\'])\\n        {\\n            // if this character is not visited, call dfs for it\\n            if(visited[near - \\'a\\'] == \\'#\\')\\n            {\\n                dfs(adj, near, minCharacter, visited);\\n            }\\n        }\\n    }\\n    \\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size(); // extract size\\n        \\n        vector<char> adj[26]; // declaring adjacency matrix\\n        \\n        // travel through strings and establish connection\\n        for(int i = 0; i < n; i++)\\n        {\\n            adj[s1[i] - \\'a\\'].push_back(s2[i]);\\n            adj[s2[i] - \\'a\\'].push_back(s1[i]);\\n        }\\n        \\n        // make a visited vector of size 26\\n        // and symbol, \\'#\\' denotes that this particular character is not visited yet\\n        vector<char> visited(26, \\'#\\');\\n        \\n        // now, travel through each character\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            // if this character is not visited yet, call dfs here \\n            if(visited[c - \\'a\\'] == \\'#\\')\\n            {\\n                // as we are calling dfs for each character, so\\n                // it will minimum value for that component.\\n                dfs(adj, c, c, visited);\\n            }\\n        }\\n        \\n        // Now lastly, replace each baseStr character with their \\n        // minimum found out character in their component,\\n        for(int i = 0; i < baseStr.size(); i++)\\n        {\\n            baseStr[i] = visited[baseStr[i] - \\'a\\'];\\n        }\\n        \\n        // return baseStr now, \\n        return baseStr;\\n    }\\n};\\n```\\n* **JAVA:**\\n```\\nclass Solution {\\n    public void dfs(List<Character>[] adj, char node, char minCharacter, char [] visited)\\n    {\\n        // to this character, replace it with it\\'s minimum character\\n        visited[node - \\'a\\'] = minCharacter;\\n        \\n         // travel in neighbor of this character,\\n        // i.e travel in component of this character\\n        for(char near: adj[node - \\'a\\'])\\n        {\\n            // if this character is not visited, call dfs for it\\n            if(visited[near - \\'a\\'] == \\'#\\')\\n            {\\n                dfs(adj, near, minCharacter, visited);\\n            }\\n        }\\n    }\\n    \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n = s1.length(); // extract size\\n        \\n        List<Character>[] adj = new List[26]; // declaring adjacency matrix\\n        for (int i = 0; i < 26; i++) \\n        {\\n            adj[i] = new ArrayList<>();\\n        }\\n        \\n        // travel through strings and establish connection\\n        for(int i = 0; i < n; i++)\\n        {\\n            adj[s1.charAt(i) - \\'a\\'].add(s2.charAt(i));\\n            adj[s2.charAt(i) - \\'a\\'].add(s1.charAt(i));\\n        }\\n        \\n        // make a visited vector of size 26\\n        // and symbol,\\'#\\' denotes that this particular character is not visited yet\\n        char [] visited = new char[26];\\n        for(int i = 0; i < 26; i++)\\n        {\\n            visited[i] = \\'#\\';\\n        }\\n        \\n         // now, travel through each character\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            // if this character is not visited yet, call dfs here \\n            if(visited[c - \\'a\\'] == \\'#\\')\\n            {\\n                 // as we are calling dfs for each character, so\\n                // it will minimum value for that component.\\n                dfs(adj, c, c, visited);\\n            }\\n        }\\n        \\n        // Now lastly, replace each baseStr character with their \\n        // minimum found out character in their component,\\n        String ans = \"\";\\n        for(int i = 0; i < baseStr.length(); i++)\\n        {\\n            ans += visited[baseStr.charAt(i) - \\'a\\'];\\n        }\\n        \\n        // finally return ans string\\n        return ans;\\n    }\\n}\\n```\\n_____________\\n***METHOD 2 (DSU / UNION FIND) :***\\n* Now, If we observe our above approach,\\nwe will found out that between each character of s1 and s2, we are establishing connection and hence end up in making a whole component.\\n* So can\\u2019t we are able to group characters and then for each character we will simply see that which character is minimum in them.\\n* Therefore, we will use DSU or say union find here.\\n\\n* Code template i used here is standard format.\\n________\\n**CODES:**\\n* **C++**\\n```\\nclass Solution {\\npublic:\\n    char parent[26]; // make a parent array of size 26\\n    \\n    // find function used for finding parent of charter ch\\n    char find(char ch)\\n    {\\n        // standard base condition of find function, \\n        // at any point parent of this charcter equals to itself only return\\n        if(parent[ch - \\'a\\'] == ch)\\n            return ch;\\n        \\n        // else move on in finding parent\\n        return parent[ch - \\'a\\'] = find(parent[ch - \\'a\\']);\\n    }\\n    \\n    // Union function to merge parents of them\\n    void Union(char first, char second)\\n    {\\n        // extract parent of both characters\\n        char ParentOfFirst = find(first);\\n        char ParentOfSecond = find(second);\\n        \\n        // whichever parent is less than other, \\n        // make that parent\\n        if(ParentOfFirst < ParentOfSecond)\\n        {\\n            parent[ParentOfSecond - \\'a\\'] = ParentOfFirst;\\n        }\\n        else\\n        {\\n            parent[ParentOfFirst - \\'a\\'] = ParentOfSecond;\\n        }\\n    }\\n    \\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size(); // extract size\\n        \\n        // Intially, all are the parents of themselves only\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            parent[c - \\'a\\'] = c;\\n        }\\n        \\n        // now, apply Union function on s1 and s2\\n        for(int i = 0; i < n; i++)\\n        {\\n            Union(s1[i], s2[i]);\\n        }\\n\\n        // finally update baseStr\\n        for(int i = 0; i < baseStr.size(); i++)\\n        {\\n            baseStr[i] = find(baseStr[i]);\\n        }\\n        \\n        return baseStr;\\n    }\\n};\\n```\\n* **JAVA:**\\n```\\nclass Solution {\\n    char [] parent = new char[26]; // make a parent array of size 26\\n    \\n     // find function used for finding parent of charter ch\\n    public char find(char ch)\\n    {\\n        // standard base condition of find function, \\n        // at any point parent of this character equals to itself only return\\n        if(parent[ch - \\'a\\'] == ch)\\n            return ch;\\n        \\n        // else move on in finding parent\\n        return parent[ch - \\'a\\'] = find(parent[ch - \\'a\\']);\\n    }\\n    \\n    // Union function to merge parents of them\\n    public void Union(char first, char second)\\n    {\\n        // extract parent of both characters\\n        char ParentOfFirst = find(first);\\n        char ParentOfSecond = find(second);\\n        \\n        // whichever parent is less than other, \\n        // make that parent\\n        if(ParentOfFirst < ParentOfSecond)\\n        {\\n            parent[ParentOfSecond - \\'a\\'] = ParentOfFirst;\\n        }\\n        else\\n        {\\n            parent[ParentOfFirst - \\'a\\'] = ParentOfSecond;\\n        }\\n    }\\n    \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n = s1.length(); // extract size\\n        \\n        // Intially, all are the parents of themselves only\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            parent[c - \\'a\\'] = c;\\n        }\\n        \\n        // now, apply Union function on s1 and s2\\n        for(int i = 0; i < n; i++)\\n        {\\n            Union(s1.charAt(i), s2.charAt(i));\\n        }\\n        \\n        // finally return ans;\\n        String ans = \"\";\\n        for(int i = 0; i < baseStr.length(); i++)\\n        {\\n            ans += find(baseStr.charAt(i));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n***`If u find this useful , please consider to give an upvote!!`***\\n\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nTime Complexity: O(n), because we will establish connection according to given equivalence relation.\\nSpace Complexity: O(n), we will make adjacency list here.\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<char> adj[], char node, char minCharacter, vector<char>& visited)\\n    {\\n        // to this character, replace it with it\\'s minimum character\\n        visited[node - \\'a\\'] = minCharacter;\\n        \\n        // travel in neighbour of this character,\\n        // i.e travel in component of this character\\n        for(char& near: adj[node - \\'a\\'])\\n        {\\n            // if this character is not visited, call dfs for it\\n            if(visited[near - \\'a\\'] == \\'#\\')\\n            {\\n                dfs(adj, near, minCharacter, visited);\\n            }\\n        }\\n    }\\n    \\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size(); // extract size\\n        \\n        vector<char> adj[26]; // declaring adjacency matrix\\n        \\n        // travel through strings and establish connection\\n        for(int i = 0; i < n; i++)\\n        {\\n            adj[s1[i] - \\'a\\'].push_back(s2[i]);\\n            adj[s2[i] - \\'a\\'].push_back(s1[i]);\\n        }\\n        \\n        // make a visited vector of size 26\\n        // and symbol, \\'#\\' denotes that this particular character is not visited yet\\n        vector<char> visited(26, \\'#\\');\\n        \\n        // now, travel through each character\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            // if this character is not visited yet, call dfs here \\n            if(visited[c - \\'a\\'] == \\'#\\')\\n            {\\n                // as we are calling dfs for each character, so\\n                // it will minimum value for that component.\\n                dfs(adj, c, c, visited);\\n            }\\n        }\\n        \\n        // Now lastly, replace each baseStr character with their \\n        // minimum found out character in their component,\\n        for(int i = 0; i < baseStr.size(); i++)\\n        {\\n            baseStr[i] = visited[baseStr[i] - \\'a\\'];\\n        }\\n        \\n        // return baseStr now, \\n        return baseStr;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void dfs(List<Character>[] adj, char node, char minCharacter, char [] visited)\\n    {\\n        // to this character, replace it with it\\'s minimum character\\n        visited[node - \\'a\\'] = minCharacter;\\n        \\n         // travel in neighbor of this character,\\n        // i.e travel in component of this character\\n        for(char near: adj[node - \\'a\\'])\\n        {\\n            // if this character is not visited, call dfs for it\\n            if(visited[near - \\'a\\'] == \\'#\\')\\n            {\\n                dfs(adj, near, minCharacter, visited);\\n            }\\n        }\\n    }\\n    \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n = s1.length(); // extract size\\n        \\n        List<Character>[] adj = new List[26]; // declaring adjacency matrix\\n        for (int i = 0; i < 26; i++) \\n        {\\n            adj[i] = new ArrayList<>();\\n        }\\n        \\n        // travel through strings and establish connection\\n        for(int i = 0; i < n; i++)\\n        {\\n            adj[s1.charAt(i) - \\'a\\'].add(s2.charAt(i));\\n            adj[s2.charAt(i) - \\'a\\'].add(s1.charAt(i));\\n        }\\n        \\n        // make a visited vector of size 26\\n        // and symbol,\\'#\\' denotes that this particular character is not visited yet\\n        char [] visited = new char[26];\\n        for(int i = 0; i < 26; i++)\\n        {\\n            visited[i] = \\'#\\';\\n        }\\n        \\n         // now, travel through each character\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            // if this character is not visited yet, call dfs here \\n            if(visited[c - \\'a\\'] == \\'#\\')\\n            {\\n                 // as we are calling dfs for each character, so\\n                // it will minimum value for that component.\\n                dfs(adj, c, c, visited);\\n            }\\n        }\\n        \\n        // Now lastly, replace each baseStr character with their \\n        // minimum found out character in their component,\\n        String ans = \"\";\\n        for(int i = 0; i < baseStr.length(); i++)\\n        {\\n            ans += visited[baseStr.charAt(i) - \\'a\\'];\\n        }\\n        \\n        // finally return ans string\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    char parent[26]; // make a parent array of size 26\\n    \\n    // find function used for finding parent of charter ch\\n    char find(char ch)\\n    {\\n        // standard base condition of find function, \\n        // at any point parent of this charcter equals to itself only return\\n        if(parent[ch - \\'a\\'] == ch)\\n            return ch;\\n        \\n        // else move on in finding parent\\n        return parent[ch - \\'a\\'] = find(parent[ch - \\'a\\']);\\n    }\\n    \\n    // Union function to merge parents of them\\n    void Union(char first, char second)\\n    {\\n        // extract parent of both characters\\n        char ParentOfFirst = find(first);\\n        char ParentOfSecond = find(second);\\n        \\n        // whichever parent is less than other, \\n        // make that parent\\n        if(ParentOfFirst < ParentOfSecond)\\n        {\\n            parent[ParentOfSecond - \\'a\\'] = ParentOfFirst;\\n        }\\n        else\\n        {\\n            parent[ParentOfFirst - \\'a\\'] = ParentOfSecond;\\n        }\\n    }\\n    \\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size(); // extract size\\n        \\n        // Intially, all are the parents of themselves only\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            parent[c - \\'a\\'] = c;\\n        }\\n        \\n        // now, apply Union function on s1 and s2\\n        for(int i = 0; i < n; i++)\\n        {\\n            Union(s1[i], s2[i]);\\n        }\\n\\n        // finally update baseStr\\n        for(int i = 0; i < baseStr.size(); i++)\\n        {\\n            baseStr[i] = find(baseStr[i]);\\n        }\\n        \\n        return baseStr;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    char [] parent = new char[26]; // make a parent array of size 26\\n    \\n     // find function used for finding parent of charter ch\\n    public char find(char ch)\\n    {\\n        // standard base condition of find function, \\n        // at any point parent of this character equals to itself only return\\n        if(parent[ch - \\'a\\'] == ch)\\n            return ch;\\n        \\n        // else move on in finding parent\\n        return parent[ch - \\'a\\'] = find(parent[ch - \\'a\\']);\\n    }\\n    \\n    // Union function to merge parents of them\\n    public void Union(char first, char second)\\n    {\\n        // extract parent of both characters\\n        char ParentOfFirst = find(first);\\n        char ParentOfSecond = find(second);\\n        \\n        // whichever parent is less than other, \\n        // make that parent\\n        if(ParentOfFirst < ParentOfSecond)\\n        {\\n            parent[ParentOfSecond - \\'a\\'] = ParentOfFirst;\\n        }\\n        else\\n        {\\n            parent[ParentOfFirst - \\'a\\'] = ParentOfSecond;\\n        }\\n    }\\n    \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n = s1.length(); // extract size\\n        \\n        // Intially, all are the parents of themselves only\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            parent[c - \\'a\\'] = c;\\n        }\\n        \\n        // now, apply Union function on s1 and s2\\n        for(int i = 0; i < n; i++)\\n        {\\n            Union(s1.charAt(i), s2.charAt(i));\\n        }\\n        \\n        // finally return ans;\\n        String ans = \"\";\\n        for(int i = 0; i < baseStr.length(); i++)\\n        {\\n            ans += find(baseStr.charAt(i));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047529,
                "title": "swift-union-find-10-sloc",
                "content": "**Union-Find approach (accepted answer)**\\n```\\nclass Solution {\\n    func smallestEquivalentString(_ s1: String, _ s2: String, _ baseStr: String) -> String {\\n        var groups = Dictionary(uniqueKeysWithValues: \"abcdefghijklmnopqrstuvwxyz\".map {($0,$0)})\\n        \\n        func find(_ x: Character) -> Character {\\n            if x != groups[x] { groups[x] = find(groups[x]!) }  // path compression, if needed\\n            return groups[x]!\\n        }\\n        \\n        for (a, b) in zip(s1, s2) { \\n            let (x,y) = (find(a), find(b))\\n            groups[max(x,y)] = min(x,y) // make union of letter pairs from `s1` and `s2`, lowest value ranked highest\\n        }\\n        \\n        return String(baseStr.map(find)) \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func smallestEquivalentString(_ s1: String, _ s2: String, _ baseStr: String) -> String {\\n        var groups = Dictionary(uniqueKeysWithValues: \"abcdefghijklmnopqrstuvwxyz\".map {($0,$0)})\\n        \\n        func find(_ x: Character) -> Character {\\n            if x != groups[x] { groups[x] = find(groups[x]!) }  // path compression, if needed\\n            return groups[x]!\\n        }\\n        \\n        for (a, b) in zip(s1, s2) { \\n            let (x,y) = (find(a), find(b))\\n            groups[max(x,y)] = min(x,y) // make union of letter pairs from `s1` and `s2`, lowest value ranked highest\\n        }\\n        \\n        return String(baseStr.map(find)) \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048942,
                "title": "python3-simple-depth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is obviously an undirected graph question at first glance, so we will connect the characters first. Also, to avoid repeating search when constructing smallest ```baseStr```, we will find the smallest character for each character first and store them inside a dictionary ```smallest```. We will use DFS to traverse the adjacent characters.\\n\\nHow do we do that? We can iterate from \\'a\\' to \\'z\\' using an iterator, lets say ```i``` and if ```i``` is in the graph, then set the smallest character for all the adjacent characters to ```i```. This works because we iterate the characters in ascending order. Thus, the adjacent nodes will be set to the smallest character in the relationship\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        equiv = defaultdict(set)\\n        smallest = defaultdict(str)\\n\\n        for c1, c2 in zip(s1, s2):\\n            if c1 == c2: continue\\n            equiv[c1].add(c2)\\n            equiv[c2].add(c1)\\n        \\n        def setMinChar(curr, minCh):\\n            if curr in smallest: return\\n            smallest[curr] = minCh\\n            for eq in equiv[curr]:\\n                setMinChar(eq, minCh)\\n\\n        for c in [chr(ord(\\'a\\') + i) for i in range(26)]:\\n            if c in equiv:\\n                if c in smallest: continue\\n                setMinChar(c, c)\\n        return \\'\\'.join([smallest[c] if c in smallest else c for c in baseStr])\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```baseStr```\n```smallest```\n```i```\n```i```\n```i```\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        equiv = defaultdict(set)\\n        smallest = defaultdict(str)\\n\\n        for c1, c2 in zip(s1, s2):\\n            if c1 == c2: continue\\n            equiv[c1].add(c2)\\n            equiv[c2].add(c1)\\n        \\n        def setMinChar(curr, minCh):\\n            if curr in smallest: return\\n            smallest[curr] = minCh\\n            for eq in equiv[curr]:\\n                setMinChar(eq, minCh)\\n\\n        for c in [chr(ord(\\'a\\') + i) for i in range(26)]:\\n            if c in equiv:\\n                if c in smallest: continue\\n                setMinChar(c, c)\\n        return \\'\\'.join([smallest[c] if c in smallest else c for c in baseStr])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048328,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "# Intuition\\n\\nPlease UPVOTE if you LIKE! \\uD83D\\uDE01\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      char dfs(unordered_map<char, vector<char>>& mapping, char input, unordered_set<char>& visited) {\\n        if (visited.count(input) > 0) {\\n            return input;\\n        }\\n        visited.insert(input);\\n        char ret = input;\\n        for (const auto ch : mapping[input]) {\\n            ret = min(ret, dfs(mapping, ch, visited));\\n        }\\n        return ret;\\n    }\\npublic:\\n    string smallestEquivalentString(string A, string B, string S) {\\n        unordered_map<char, vector<char>> mapping;\\n        for (int i = 0; i < A.size(); ++i) {\\n            mapping[A[i]].push_back(B[i]);\\n            mapping[B[i]].push_back(A[i]);\\n        }\\n        string ret;\\n        unordered_map<char, char> memo;\\n        for (const auto s : S) {\\n            if (memo.count(s) > 0) {\\n                ret += memo[s];\\n                continue;\\n            }\\n            unordered_set<char> visited;\\n            const auto min_char = dfs(mapping, s, visited);\\n            for (const auto ch : visited) {\\n                memo[ch] = min_char;\\n            }\\n            ret += min_char;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      char dfs(unordered_map<char, vector<char>>& mapping, char input, unordered_set<char>& visited) {\\n        if (visited.count(input) > 0) {\\n            return input;\\n        }\\n        visited.insert(input);\\n        char ret = input;\\n        for (const auto ch : mapping[input]) {\\n            ret = min(ret, dfs(mapping, ch, visited));\\n        }\\n        return ret;\\n    }\\npublic:\\n    string smallestEquivalentString(string A, string B, string S) {\\n        unordered_map<char, vector<char>> mapping;\\n        for (int i = 0; i < A.size(); ++i) {\\n            mapping[A[i]].push_back(B[i]);\\n            mapping[B[i]].push_back(A[i]);\\n        }\\n        string ret;\\n        unordered_map<char, char> memo;\\n        for (const auto s : S) {\\n            if (memo.count(s) > 0) {\\n                ret += memo[s];\\n                continue;\\n            }\\n            unordered_set<char> visited;\\n            const auto min_char = dfs(mapping, s, visited);\\n            for (const auto ch : visited) {\\n                memo[ch] = min_char;\\n            }\\n            ret += min_char;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048298,
                "title": "union-find-using-unordered-map",
                "content": "Instead of using a vector, simple use of map to remember the parents \\n\\nDry run :- \\n![image](https://assets.leetcode.com/users/images/b37c2628-7633-411b-8d69-2d0b1f73f316_1673676804.6303382.png)\\n\\n--- \\n\\n![image](https://assets.leetcode.com/users/images/698e4776-7558-4d30-9933-b546e760a547_1673676817.3370528.png)\\n\\n\\nFinally We use the map to build baseStr\\n```c++\\nclass Solution {\\npublic:\\n    unordered_map<char,char> par;\\n    int find(int x){\\n        if(par[x] == 0) return x;\\n        int temp = par[x];\\n        while(par[temp]){\\n            temp = par[temp];\\n        }\\n        return temp;\\n    } \\n    void Union(int x, int y) {\\n        x = find(x);\\n        y = find(y);   \\n        if (x != y) {\\n            par[max(x, y)] = min(x , y);\\n        }\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        for (int i = 0; i < s1.size(); ++i) \\n            Union(s1[i], s2[i]);\\n        for(char& c: baseStr) c = find(c); \\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    unordered_map<char,char> par;\\n    int find(int x){\\n        if(par[x] == 0) return x;\\n        int temp = par[x];\\n        while(par[temp]){\\n            temp = par[temp];\\n        }\\n        return temp;\\n    } \\n    void Union(int x, int y) {\\n        x = find(x);\\n        y = find(y);   \\n        if (x != y) {\\n            par[max(x, y)] = min(x , y);\\n        }\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        for (int i = 0; i < s1.size(); ++i) \\n            Union(s1[i], s2[i]);\\n        for(char& c: baseStr) c = find(c); \\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047934,
                "title": "easy-c-solution",
                "content": "# Approach\\nFind smallest equal char for every char;\\n\\n# Complexity\\n- Time complexity:$$O(n*26+m) = O(n+m)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity:$$O(26) = O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public string SmallestEquivalentString(string s1, string s2, string baseStr)\\n    {\\n        char[] arr = new char[26];\\n        for (ushort i = 0; i < 26; i++) arr[i] = (char)(\\'a\\' + i);\\n        for(int i=0; i<s1.Length; i++)\\n        {\\n            char min = arr[s1[i]-\\'a\\'];\\n            char max = arr[s2[i]-\\'a\\'];\\n            if(max < min) (max, min) = (min, max);\\n            for (int j = 0; j < arr.Length; j++)\\n                if (arr[j] == max) arr[j] = min;\\n        }\\n        return new string(baseStr.Select(x => arr[x - \\'a\\']).ToArray());\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string SmallestEquivalentString(string s1, string s2, string baseStr)\\n    {\\n        char[] arr = new char[26];\\n        for (ushort i = 0; i < 26; i++) arr[i] = (char)(\\'a\\' + i);\\n        for(int i=0; i<s1.Length; i++)\\n        {\\n            char min = arr[s1[i]-\\'a\\'];\\n            char max = arr[s2[i]-\\'a\\'];\\n            if(max < min) (max, min) = (min, max);\\n            for (int j = 0; j < arr.Length; j++)\\n                if (arr[j] == max) arr[j] = min;\\n        }\\n        return new string(baseStr.Select(x => arr[x - \\'a\\']).ToArray());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049518,
                "title": "100-faster-easy-to-understand-union-find-0ms-runtime",
                "content": "# Approach\\n Disjoint set Union(DSU)/Union Find\\n\\n# Complexity\\n- Time complexity:\\nApprox. O(n log(n)) \\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    int find(int x){  //find function returns the parent of set\\n      if(parent[x]==x){\\n          return x;\\n      }\\n      return parent[x]=find(parent[x]);\\n    }\\n    void union_set(int x,int y){ // make union of the set a & b if they belongs to different set\\n        x=find(x);\\n        y=find(y);\\n        if(x==y){                //if they belong to same set simply return.\\n            return;\\n        }\\n        parent[max(x,y)]=min(x,y); //making lexicographically smallest char as parent of the union set\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        parent.resize(26);\\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<s1.size();i++){ // s1[1] and s2[i] are similarto each other hence they are put in same set.\\n          int a=s1[i]-\\'a\\';\\n          int b=s2[i]-\\'a\\';\\n          union_set(a,b);    // make union of the set a & b if they belongs to different set\\n        }\\n        string ans;\\n        for(auto x:baseStr){\\n            char k=find(x-\\'a\\')+\\'a\\';    // here find function returns the lexographically smallest char from the set\\n            ans+=k;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\u2705\\u2705PLease upvote if you find it useful.\\n\\n![Screenshot 2023-01-14 154613.png](https://assets.leetcode.com/users/images/6ce4e72f-2605-483f-94e5-8fc8fef881bd_1673692098.7948232.png)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    int find(int x){  //find function returns the parent of set\\n      if(parent[x]==x){\\n          return x;\\n      }\\n      return parent[x]=find(parent[x]);\\n    }\\n    void union_set(int x,int y){ // make union of the set a & b if they belongs to different set\\n        x=find(x);\\n        y=find(y);\\n        if(x==y){                //if they belong to same set simply return.\\n            return;\\n        }\\n        parent[max(x,y)]=min(x,y); //making lexicographically smallest char as parent of the union set\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        parent.resize(26);\\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<s1.size();i++){ // s1[1] and s2[i] are similarto each other hence they are put in same set.\\n          int a=s1[i]-\\'a\\';\\n          int b=s2[i]-\\'a\\';\\n          union_set(a,b);    // make union of the set a & b if they belongs to different set\\n        }\\n        string ans;\\n        for(auto x:baseStr){\\n            char k=find(x-\\'a\\')+\\'a\\';    // here find function returns the lexographically smallest char from the set\\n            ans+=k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048641,
                "title": "c-begineer-friendly-easy-understanding-union-find-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=1qgxjQ0Bd7M/\\n\\n\\n# Complexity\\n- Time complexity:\\n  (n+m)O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<int>headChar;\\n\\n// find the parent or headChar.\\n    int find(int x){\\n        if(headChar[x] == -1){return x;}\\n\\n        return headChar[x] = find(headChar[x]);\\n    }\\n\\n    void Union(int x,int y){\\n        int parentx = find(x);\\n        int parenty = find(y);\\n\\n\\n        if(parentx == parenty){return;}\\n\\n\\n        // make smaller one represent of other. if parent are diffrent.\\n        headChar[max(parentx,parenty)] = min(parentx,parenty);\\n    }\\n\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n\\n        headChar.resize(26,-1);\\n        // make group (Union)\\n        for(int i=0;i<s1.size();i++){\\n            Union(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n\\n        // traverse in the baseStr and find the parent of each char.\\n       for(auto i=0;i<baseStr.size();i++)\\n            baseStr[i]=find(baseStr[i]-\\'a\\')+\\'a\\';\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<int>headChar;\\n\\n// find the parent or headChar.\\n    int find(int x){\\n        if(headChar[x] == -1){return x;}\\n\\n        return headChar[x] = find(headChar[x]);\\n    }\\n\\n    void Union(int x,int y){\\n        int parentx = find(x);\\n        int parenty = find(y);\\n\\n\\n        if(parentx == parenty){return;}\\n\\n\\n        // make smaller one represent of other. if parent are diffrent.\\n        headChar[max(parentx,parenty)] = min(parentx,parenty);\\n    }\\n\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n\\n        headChar.resize(26,-1);\\n        // make group (Union)\\n        for(int i=0;i<s1.size();i++){\\n            Union(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n\\n        // traverse in the baseStr and find the parent of each char.\\n       for(auto i=0;i<baseStr.size();i++)\\n            baseStr[i]=find(baseStr[i]-\\'a\\')+\\'a\\';\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047568,
                "title": "javascript-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRepresent the problem as a graph problem. Each group of characters represents a connected component. To solve this use Union Find to group the characters and chose the lexicographically smallest member of each set to be the set\\'s representative.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplement Union Find. Unite all `s1[i]` and `s2[i]` for all `1 <= i <n `. Then iterate through the characters of  `baseStr` and replace each with the representative of its the group (the union find implementation should chose the smallest character as representative).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n log26 + m)$$ \\nWhere `n` is the length of `s1` and `s2`. `Log26` comes from the complexity of union find with path compression and there\\'s only 26 english chars. `m` is the length of `baseStr`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(26 + m)$$ \\nfrom the `link` map and building the answer string\\n\\n# Code\\n```\\nconst smallestEquivalentString = (s1, s2, baseStr) => {\\n    const link = {};\\n    const find = (a)=>{\\n        if(link[a] == null) link[a] = a;\\n        while(link[a] != a){\\n            link[a] = link[link[a]];\\n            a = link[a];\\n        }\\n        return a;\\n    }\\n    const union = (a, b)=>{\\n        a = find(a);\\n        b = find(b);\\n        if(a > b){\\n            let temp = b;\\n            b = a;\\n            a = temp;\\n        }\\n        link[b] = a;\\n    }\\n    for(let i = 0; i < s1.length; i++){\\n        union(s1[i], s2[i]);\\n    }\\n\\n    let ans = \"\";\\n    for(const a of baseStr){\\n        ans+=find(a);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nconst smallestEquivalentString = (s1, s2, baseStr) => {\\n    const link = {};\\n    const find = (a)=>{\\n        if(link[a] == null) link[a] = a;\\n        while(link[a] != a){\\n            link[a] = link[link[a]];\\n            a = link[a];\\n        }\\n        return a;\\n    }\\n    const union = (a, b)=>{\\n        a = find(a);\\n        b = find(b);\\n        if(a > b){\\n            let temp = b;\\n            b = a;\\n            a = temp;\\n        }\\n        link[b] = a;\\n    }\\n    for(let i = 0; i < s1.length; i++){\\n        union(s1[i], s2[i]);\\n    }\\n\\n    let ans = \"\";\\n    for(const a of baseStr){\\n        ans+=find(a);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3058757,
                "title": "solution-in-c-using-dsu",
                "content": "# Intuition\\n The problem is asking to find the smallest equivalent string of a given string \"**baseStr**\" by making a series of replacements based on the two input strings \"**s1**\" and \"**s2**\". The idea is to form a union of characters that are equivalent, and then replace the characters in \"**baseStr**\" with their equivalent parent.\\n\\n# Approach\\nThe solution uses a **Disjoint-Set** data structure to keep track of the equivalent characters. For each pair of characters in \"**s1**\" and \"**s2**\" that are different, their parents in the Disjoint-Set are joined. Then, for each character in \"**baseStr**\", its equivalent parent in the **Disjoint-Set** is found and replaced if it is smaller than the current character.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is ***O(n log* n)**, where ***n*** is the number of characters in the input strings. This is because the Disjoint-Set uses path compression and union by size, which results in an almost constant time complexity for the union and find operations.\\n\\n- Space complexity:\\nThe space complexity is ***O(26)*** as it only needs to store 26 disjoint sets and it is a constant space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// Node struct to represent a character and its properties in the Disjoint-Set\\nstruct Node{\\n    int id =-1; // id of the character, initialize it to -1 to represent uninitialized state\\n    char label=\\' \\'; // label of the character, initialize it to \\' \\' to represent uninitialized state\\n    Node* parent=this; // pointer to the parent node, initialize it to this to represent the root node\\n    int size=1; // size of the set, initialize it to 1 as it is the root node\\n    bool visted=0; // boolean to check if the node is visited, not used in this code\\n    vector<Node*> neighbours={}; // neighbours of the node, not used in this code\\n    Node(int _id, char _label):id(_id), label(_label){} // constructor to initialize the id and label of the node\\n};\\n\\n// function to find the parent of a node in the Disjoint-Set\\nNode* getParentDSU(Node* node){\\n    if(node==node->parent) return node; // if the node is the root node, return it\\n    return node->parent=getParentDSU(node->parent); // else recursively find the parent and use path compression to update the parent\\n}\\n\\n// function to join two nodes in the Disjoint-Set\\nvoid joinDSU(Node* src,Node* tar){\\n    src=getParentDSU(src); // find the parent of the source node\\n    tar=getParentDSU(tar); // find the parent of the target node\\n    if(src!=tar){ // if the two parents are different\\n        if(tar->label<src->label) swap(src,tar); // ensure the label of the parent is lexicographically smaller\\n        tar->parent=src; // set the parent of target to source\\n        src->size+=tar->size; // increment the size of the set\\n    }\\n}\\n\\nstring smallestEquivalentString(string s1, string s2, string baseStr) {\\n    // Create an array of nodes representing each character\\n    vector<Node*> nodes(26);\\n    for(int i=0;i<26;i++){\\n        nodes[i] =  new Node(i+1,\\'a\\'+i); // initialize the nodes with id and label\\n    }\\n\\n    // For each pair of characters in s1 and s2, join their parents in the Disjoint-Set\\n    for(int i=0;i<s1.size();i++){\\n            joinDSU(nodes[s1[i]-\\'a\\'],nodes[s2[i]-\\'a\\']);\\n    }\\n\\n    // For each character in baseStr, replace it with its equivalent parent in the Disjoint-Set\\n    for(int i=0;i<baseStr.size();i++){\\n        if(getParentDSU(nodes[baseStr[i]-\\'a\\'])->label<baseStr[i]){\\n            baseStr[i]=getParentDSU(nodes[baseStr[i]-\\'a\\'])->label;\\n        }\\n   \\n}\\n\\n    return baseStr;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// Node struct to represent a character and its properties in the Disjoint-Set\\nstruct Node{\\n    int id =-1; // id of the character, initialize it to -1 to represent uninitialized state\\n    char label=\\' \\'; // label of the character, initialize it to \\' \\' to represent uninitialized state\\n    Node* parent=this; // pointer to the parent node, initialize it to this to represent the root node\\n    int size=1; // size of the set, initialize it to 1 as it is the root node\\n    bool visted=0; // boolean to check if the node is visited, not used in this code\\n    vector<Node*> neighbours={}; // neighbours of the node, not used in this code\\n    Node(int _id, char _label):id(_id), label(_label){} // constructor to initialize the id and label of the node\\n};\\n\\n// function to find the parent of a node in the Disjoint-Set\\nNode* getParentDSU(Node* node){\\n    if(node==node->parent) return node; // if the node is the root node, return it\\n    return node->parent=getParentDSU(node->parent); // else recursively find the parent and use path compression to update the parent\\n}\\n\\n// function to join two nodes in the Disjoint-Set\\nvoid joinDSU(Node* src,Node* tar){\\n    src=getParentDSU(src); // find the parent of the source node\\n    tar=getParentDSU(tar); // find the parent of the target node\\n    if(src!=tar){ // if the two parents are different\\n        if(tar->label<src->label) swap(src,tar); // ensure the label of the parent is lexicographically smaller\\n        tar->parent=src; // set the parent of target to source\\n        src->size+=tar->size; // increment the size of the set\\n    }\\n}\\n\\nstring smallestEquivalentString(string s1, string s2, string baseStr) {\\n    // Create an array of nodes representing each character\\n    vector<Node*> nodes(26);\\n    for(int i=0;i<26;i++){\\n        nodes[i] =  new Node(i+1,\\'a\\'+i); // initialize the nodes with id and label\\n    }\\n\\n    // For each pair of characters in s1 and s2, join their parents in the Disjoint-Set\\n    for(int i=0;i<s1.size();i++){\\n            joinDSU(nodes[s1[i]-\\'a\\'],nodes[s2[i]-\\'a\\']);\\n    }\\n\\n    // For each character in baseStr, replace it with its equivalent parent in the Disjoint-Set\\n    for(int i=0;i<baseStr.size();i++){\\n        if(getParentDSU(nodes[baseStr[i]-\\'a\\'])->label<baseStr[i]){\\n            baseStr[i]=getParentDSU(nodes[baseStr[i]-\\'a\\'])->label;\\n        }\\n   \\n}\\n\\n    return baseStr;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051156,
                "title": "easy-and-clean-code",
                "content": "```\\nclass Solution {\\n    public int find(int ch, int[] parent)\\n    {\\n        if(parent[ch] == -1)\\n            return ch;\\n        return find(parent[ch], parent);\\n    }\\n    public void Union(int ch1, int ch2, int[] parent)\\n    {\\n        int p_ch1 = find(ch1, parent);\\n        int p_ch2 = find(ch2, parent);\\n        \\n        if(p_ch1 != p_ch2)\\n        {\\n            int max_p = Math.max(p_ch1, p_ch2);\\n            int min_p = Math.min(p_ch1, p_ch2);\\n            \\n            parent[max_p] = min_p;\\n        }\\n            \\n    }\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int parent[] = new int[26];\\n        for(int i = 0; i < 26; i++)\\n        {\\n            parent[i] = -1;\\n        }\\n        int n = s1.length();\\n        for(int i = 0; i < n; i++)\\n        {\\n            Union(s1.charAt(i)-\\'a\\', s2.charAt(i)-\\'a\\', parent);\\n        }\\n        n = baseStr.length();\\n        String ans = new String();\\n        for(int i = 0; i < n; i++)\\n        {\\n            char ch = (char) (find(baseStr.charAt(i)-\\'a\\', parent) + \\'a\\');\\n            \\n            ans += ch;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int find(int ch, int[] parent)\\n    {\\n        if(parent[ch] == -1)\\n            return ch;\\n        return find(parent[ch], parent);\\n    }\\n    public void Union(int ch1, int ch2, int[] parent)\\n    {\\n        int p_ch1 = find(ch1, parent);\\n        int p_ch2 = find(ch2, parent);\\n        \\n        if(p_ch1 != p_ch2)\\n        {\\n            int max_p = Math.max(p_ch1, p_ch2);\\n            int min_p = Math.min(p_ch1, p_ch2);\\n            \\n            parent[max_p] = min_p;\\n        }\\n            \\n    }\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int parent[] = new int[26];\\n        for(int i = 0; i < 26; i++)\\n        {\\n            parent[i] = -1;\\n        }\\n        int n = s1.length();\\n        for(int i = 0; i < n; i++)\\n        {\\n            Union(s1.charAt(i)-\\'a\\', s2.charAt(i)-\\'a\\', parent);\\n        }\\n        n = baseStr.length();\\n        String ans = new String();\\n        for(int i = 0; i < n; i++)\\n        {\\n            char ch = (char) (find(baseStr.charAt(i)-\\'a\\', parent) + \\'a\\');\\n            \\n            ans += ch;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050517,
                "title": "solution-in-o-n-using-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have to map one character to another, but one or more character can point to same character. So there comes union find to make parent of each character.\\nAfter making parent of each character now the answer string is parent of each character in the baseStr.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate over s1 and s2 and make union of character of s1 and s2.\\nsince we want lexicographically small string as answer so instead of giving rank numbers, character have rank acording to dictionary order i.e. a = 0 , b= 1, ... z = 25.\\nSo the union or join function make parent to the character which has less rank.\\n\\nNow iterate over BaseStr and change each character to its parent character.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$o(n)$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$o(1)$$  using array of size 26 is constant space\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int par[26];\\n    void makedsu(){\\n        for(int i=0;i<26;i++){\\n            par[i] = i;\\n        }\\n    }\\n    int getpar(int a){\\n        if(par[a] == a) return a;\\n        return par[a] = getpar(par[a]);\\n    }\\n    void dsjoint(int a,int b){\\n        a = getpar(a);\\n        b = getpar(b);\\n        if(a < b) par[b] = a;\\n        else par[a] = b; \\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        makedsu();\\n        for(int i=0;i<s1.size();i++){\\n            int a= (s1[i] - \\'a\\');\\n            int b = (s2[i]-\\'a\\');\\n            dsjoint(a,b);\\n        }\\n        string s = \"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            int a = getpar((int)(baseStr[i]-\\'a\\'));\\n            s += (a+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int par[26];\\n    void makedsu(){\\n        for(int i=0;i<26;i++){\\n            par[i] = i;\\n        }\\n    }\\n    int getpar(int a){\\n        if(par[a] == a) return a;\\n        return par[a] = getpar(par[a]);\\n    }\\n    void dsjoint(int a,int b){\\n        a = getpar(a);\\n        b = getpar(b);\\n        if(a < b) par[b] = a;\\n        else par[a] = b; \\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        makedsu();\\n        for(int i=0;i<s1.size();i++){\\n            int a= (s1[i] - \\'a\\');\\n            int b = (s2[i]-\\'a\\');\\n            dsjoint(a,b);\\n        }\\n        string s = \"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            int a = getpar((int)(baseStr[i]-\\'a\\'));\\n            s += (a+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048896,
                "title": "beats-100-percent-c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int find(int x , vector<int> & parents)\\n  {\\n     return parents[x] == x ? x : find(parents[x],parents);\\n  }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n\\n        vector<int> parents(26);\\n\\n        for(int i = 0 ; i < 26 ; i++)\\n        parents[i] = i ;\\n\\n        for(int i = 0 ; i < s1.length() ; i++)\\n        {\\n            int x = find(s1[i] -\\'a\\',parents);\\n            int y = find(s2[i] -\\'a\\',parents);\\n\\n            if(x != y)\\n            parents[max(x,y)] = min(x,y);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.length();i++)\\n        baseStr[i] = find(baseStr[i] -\\'a\\' , parents) + \\'a\\';\\n        \\n        return baseStr ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int find(int x , vector<int> & parents)\\n  {\\n     return parents[x] == x ? x : find(parents[x],parents);\\n  }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n\\n        vector<int> parents(26);\\n\\n        for(int i = 0 ; i < 26 ; i++)\\n        parents[i] = i ;\\n\\n        for(int i = 0 ; i < s1.length() ; i++)\\n        {\\n            int x = find(s1[i] -\\'a\\',parents);\\n            int y = find(s2[i] -\\'a\\',parents);\\n\\n            if(x != y)\\n            parents[max(x,y)] = min(x,y);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.length();i++)\\n        baseStr[i] = find(baseStr[i] -\\'a\\' , parents) + \\'a\\';\\n        \\n        return baseStr ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048268,
                "title": "most-optimized-python-solution-class-based-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self,n):\\n        self.size=[1]*n\\n        self.parent=[i for i in range(n)]\\n\\n    def findUPar(self,node):\\n        if node==self.parent[node]:\\n            return node\\n        self.parent[node]=self.findUPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def union(self,u,v):\\n        ulp_u=self.findUPar(u)\\n        ulp_v=self.findUPar(v)\\n        if ulp_u==ulp_v:\\n            return\\n        if ulp_u<ulp_v:\\n            self.parent[ulp_v]=ulp_u\\n        elif ulp_u>ulp_v:\\n            self.parent[ulp_u]=ulp_v\\n            \\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        disjoint=Disjoint(26)\\n        n=len(s1)\\n        for i in range(n):\\n            # print(s1[i],s2[i],ord(s1[i])-97,ord(s2[i])-97)\\n            disjoint.union(ord(s1[i])-97,ord(s2[i])-97)\\n        \\n        st=\"\"\\n        for i in range(26):\\n            disjoint.findUPar(i)\\n        # print(disjoint.parent)\\n\\n        for i in baseStr:\\n            x=disjoint.findUPar(ord(i)-97)\\n            st+=chr(x+97)\\n        return st\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Disjoint:\\n    def __init__(self,n):\\n        self.size=[1]*n\\n        self.parent=[i for i in range(n)]\\n\\n    def findUPar(self,node):\\n        if node==self.parent[node]:\\n            return node\\n        self.parent[node]=self.findUPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def union(self,u,v):\\n        ulp_u=self.findUPar(u)\\n        ulp_v=self.findUPar(v)\\n        if ulp_u==ulp_v:\\n            return\\n        if ulp_u<ulp_v:\\n            self.parent[ulp_v]=ulp_u\\n        elif ulp_u>ulp_v:\\n            self.parent[ulp_u]=ulp_v\\n            \\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        disjoint=Disjoint(26)\\n        n=len(s1)\\n        for i in range(n):\\n            # print(s1[i],s2[i],ord(s1[i])-97,ord(s2[i])-97)\\n            disjoint.union(ord(s1[i])-97,ord(s2[i])-97)\\n        \\n        st=\"\"\\n        for i in range(26):\\n            disjoint.findUPar(i)\\n        # print(disjoint.parent)\\n\\n        for i in baseStr:\\n            x=disjoint.findUPar(ord(i)-97)\\n            st+=chr(x+97)\\n        return st\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048022,
                "title": "simple-dfs-c",
                "content": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, int &mn) {\\n        vis[node] = 1;\\n        mn = min(mn, node);\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, mn);\\n        }\\n    }\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<int> adj[26];\\n        for(int i=0; i<n; i++) {\\n            adj[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            adj[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        vector<int> sol(26);\\n        for(char c=\\'a\\'; c<=\\'z\\'; c++) {\\n            vector<int> vis(26);\\n            int mn = 27;\\n            dfs(c - \\'a\\', adj, vis, mn);\\n            sol[c - \\'a\\'] = mn;\\n        }\\n        \\n        string ans;\\n        for(char c : baseStr) ans += sol[c - \\'a\\'] + \\'a\\';\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, int &mn) {\\n        vis[node] = 1;\\n        mn = min(mn, node);\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, mn);\\n        }\\n    }\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<int> adj[26];\\n        for(int i=0; i<n; i++) {\\n            adj[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            adj[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        vector<int> sol(26);\\n        for(char c=\\'a\\'; c<=\\'z\\'; c++) {\\n            vector<int> vis(26);\\n            int mn = 27;\\n            dfs(c - \\'a\\', adj, vis, mn);\\n            sol[c - \\'a\\'] = mn;\\n        }\\n        \\n        string ans;\\n        for(char c : baseStr) ans += sol[c - \\'a\\'] + \\'a\\';\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047796,
                "title": "easy-to-understand-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int findParent(int node, vector<int>&parent)\\n    {\\n        int curr = node;\\n        while(parent[curr] != curr) curr = parent[curr];\\n        return curr;\\n    }\\n    void merge(int node1, int node2, vector<int>&parent)\\n    {\\n        int parent1 = findParent(node1, parent);\\n        int parent2 = findParent(node2, parent);\\n        if (parent1 == parent2) return;\\n        \\n        int minParent = min(parent1, parent2);\\n        int maxParent = max(parent1, parent2);\\n        parent[maxParent] = minParent;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr)\\n    {\\n        int n = s1.size();\\n        vector<int>parent(26);\\n        for (int i = 0; i < 26; i++) parent[i] = i;\\n        for (int i = 0; i < n; i++) merge(s1[i] - \\'a\\', s2[i] - \\'a\\', parent);\\n        //================================================\\n        string ans = \"\";\\n        for (int i = 0; i < baseStr.size(); i++) \\n        {\\n            int minParentIdx = findParent(baseStr[i] - \\'a\\', parent);\\n            char minParent = minParentIdx + \\'a\\';\\n            ans.push_back(minParent);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findParent(int node, vector<int>&parent)\\n    {\\n        int curr = node;\\n        while(parent[curr] != curr) curr = parent[curr];\\n        return curr;\\n    }\\n    void merge(int node1, int node2, vector<int>&parent)\\n    {\\n        int parent1 = findParent(node1, parent);\\n        int parent2 = findParent(node2, parent);\\n        if (parent1 == parent2) return;\\n        \\n        int minParent = min(parent1, parent2);\\n        int maxParent = max(parent1, parent2);\\n        parent[maxParent] = minParent;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr)\\n    {\\n        int n = s1.size();\\n        vector<int>parent(26);\\n        for (int i = 0; i < 26; i++) parent[i] = i;\\n        for (int i = 0; i < n; i++) merge(s1[i] - \\'a\\', s2[i] - \\'a\\', parent);\\n        //================================================\\n        string ans = \"\";\\n        for (int i = 0; i < baseStr.size(); i++) \\n        {\\n            int minParentIdx = findParent(baseStr[i] - \\'a\\', parent);\\n            char minParent = minParentIdx + \\'a\\';\\n            ans.push_back(minParent);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316905,
                "title": "python-union-find",
                "content": "```\\nclass UF:\\n    def __init__(self, n):\\n        self.ps = list(range(n))\\n\\n    def find(self, x):\\n        if self.ps[x] != x:\\n            self.ps[x] = self.find(self.ps[x])\\n        return self.ps[x]\\n\\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px == py:\\n            return\\n        if px < py:\\n            self.ps[py] = px\\n        else:\\n            self.ps[px] = py\\n\\n\\nclass Solution:\\n    def smallestEquivalentString(self, A: str, B: str, S: str) -> str:\\n\\n        uf = UF(26)\\n        for a, b in zip(A, B):\\n            if a != b:\\n                uf.union(ord(a) - 97, ord(b) - 97)\\n\\n        return \\'\\'.join((chr(uf.find(ord(c) - 97) + 97) for c in list(S)))",
                "solutionTags": [],
                "code": "```\\nclass UF:\\n    def __init__(self, n):\\n        self.ps = list(range(n))\\n\\n    def find(self, x):\\n        if self.ps[x] != x:\\n            self.ps[x] = self.find(self.ps[x])\\n        return self.ps[x]\\n\\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px == py:\\n            return\\n        if px < py:\\n            self.ps[py] = px\\n        else:\\n            self.ps[px] = py\\n\\n\\nclass Solution:\\n    def smallestEquivalentString(self, A: str, B: str, S: str) -> str:\\n\\n        uf = UF(26)\\n        for a, b in zip(A, B):\\n            if a != b:\\n                uf.union(ord(a) - 97, ord(b) - 97)\\n\\n        return \\'\\'.join((chr(uf.find(ord(c) - 97) + 97) for c in list(S)))",
                "codeTag": "Java"
            },
            {
                "id": 304313,
                "title": "simple-union-find-with-a-twist-in-union",
                "content": "```\\nclass Solution {\\n    \\n    private int[] parent = new int[26];\\n    \\n    public String smallestEquivalentString(String A, String B, String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0;i < parent.length;i++) parent[i] = i;\\n        for (int i = 0;i < A.length();i++) {\\n            char ch1 = A.charAt(i);\\n            char ch2 = B.charAt(i);\\n            union(ch1 - \\'a\\', ch2 - \\'a\\');\\n        }\\n        for (char ch:S.toCharArray()) {\\n            int p = find(ch - \\'a\\');\\n            sb.append((char) (p + \\'a\\'));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void union(int ch1, int ch2) {\\n        int p1 = find(ch1);\\n        int p2 = find(ch2);\\n        if (p1 < p2) {\\n            parent[p2] = p1; \\n        } else {\\n            parent[p1] = p2;\\n        }\\n        \\n    }\\n    \\n    private int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }                                                       \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int[] parent = new int[26];\\n    \\n    public String smallestEquivalentString(String A, String B, String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0;i < parent.length;i++) parent[i] = i;\\n        for (int i = 0;i < A.length();i++) {\\n            char ch1 = A.charAt(i);\\n            char ch2 = B.charAt(i);\\n            union(ch1 - \\'a\\', ch2 - \\'a\\');\\n        }\\n        for (char ch:S.toCharArray()) {\\n            int p = find(ch - \\'a\\');\\n            sb.append((char) (p + \\'a\\'));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void union(int ch1, int ch2) {\\n        int p1 = find(ch1);\\n        int p2 = find(ch2);\\n        if (p1 < p2) {\\n            parent[p2] = p1; \\n        } else {\\n            parent[p1] = p2;\\n        }\\n        \\n    }\\n    \\n    private int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }                                                       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052116,
                "title": "java-ufds-w-template-faster-than-100",
                "content": "# Intuition\\nThis is as straight forward of a DSU/UFDS problem as they come. One could think of equivalent characters as elements belonging to the same set. If a certain character of one set is found to be equivalent to be the character of some other set, a union of those two sets has to be performed. Also, the smallest character in each set has to be tracked so as to finally construct our answer.\\n\\n# Approach\\nStart by initialsing a UFDS class with 26 elements (elements being the characters of a set). Take union of two equivalent characters a/c to String S1 and S2, while taking union, keep tracking the minimum element of the sets involved using an extra \\'min\\' array. To finally construct the answer, find the min character for each set a character of the baseStr String belongs to. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        UFDS dsu = new UFDS(26);\\n        for(int i = 0; i < s1.length(); i++){\\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\\n        }\\n\\n        StringBuilder sb = new StringBuilder(); \\n\\n        for(int i = 0; i < baseStr.length(); i++){\\n            int root = dsu.root(baseStr.charAt(i) - 97);\\n            sb.append((char)(dsu.min[root] + 97));\\n\\n        }\\n        return sb.toString();\\n    }\\n    \\n    class UFDS{\\n        \\n        int[] id;\\n        int[] size;\\n        int[] min;\\n        \\n        public UFDS(int N){\\n            \\n            id = new int[N];\\n            size = new int[N];\\n            min = new int[N];\\n            for(int i = 0; i < N; i++){\\n                id[i] = i;\\n                size[i] = 1;\\n                min[i] = i;\\n            }\\n        }\\n        \\n        private int root(int i){\\n            while (i != id[i]){\\n                id[i] = id[id[i]];\\n                i = id[i];\\n            }\\n            return i;\\n        }\\n        \\n        public void union(int p, int q){\\n            \\n            int i = root(p);\\n            int j = root(q);\\n            if(i == j)return;\\n            if(size[i] < size[j]){\\n                id[i] = id[j];\\n                size[j] += size[i];\\n                min[j] = Math.min(min[i],min[j]);\\n            }\\n            else{\\n                id[j] = id[i];\\n                size[i] += size[j];\\n                min[i] = Math.min(min[i],min[j]);\\n            }\\n        }\\n\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        UFDS dsu = new UFDS(26);\\n        for(int i = 0; i < s1.length(); i++){\\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\\n        }\\n\\n        StringBuilder sb = new StringBuilder(); \\n\\n        for(int i = 0; i < baseStr.length(); i++){\\n            int root = dsu.root(baseStr.charAt(i) - 97);\\n            sb.append((char)(dsu.min[root] + 97));\\n\\n        }\\n        return sb.toString();\\n    }\\n    \\n    class UFDS{\\n        \\n        int[] id;\\n        int[] size;\\n        int[] min;\\n        \\n        public UFDS(int N){\\n            \\n            id = new int[N];\\n            size = new int[N];\\n            min = new int[N];\\n            for(int i = 0; i < N; i++){\\n                id[i] = i;\\n                size[i] = 1;\\n                min[i] = i;\\n            }\\n        }\\n        \\n        private int root(int i){\\n            while (i != id[i]){\\n                id[i] = id[id[i]];\\n                i = id[i];\\n            }\\n            return i;\\n        }\\n        \\n        public void union(int p, int q){\\n            \\n            int i = root(p);\\n            int j = root(q);\\n            if(i == j)return;\\n            if(size[i] < size[j]){\\n                id[i] = id[j];\\n                size[j] += size[i];\\n                min[j] = Math.min(min[i],min[j]);\\n            }\\n            else{\\n                id[j] = id[i];\\n                size[i] += size[j];\\n                min[i] = Math.min(min[i],min[j]);\\n            }\\n        }\\n\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050239,
                "title": "easy-c-solution-using-union-find-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs given in the question, we solve it using put the same relation of character in one type of group.So because of this we use union method.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo the approach is simple we traverse both string s1 and s2 and put the same type or relation of character or letter in one group and make parent of these character to smallest alphabet letter So it will help in lexiographical order.\\n\\n\\n**Here is my code**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    int findpar(int node){\\n        if(node==parent[node]) return node;\\n\\n        return findpar(parent[node]);\\n    }\\n    void uni(int u,int v){\\n        u=findpar(u);\\n        v=findpar(v);\\n        if(u==v) return;\\n        if(u<v){\\n            parent[v]=u;\\n        }\\n        else{\\n            parent[u]=v;\\n        }\\n        return;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string basestr) {\\n        parent.resize(26,0);\\n        rank.resize(26,0);\\n        for(int i=0;i<26;i++) parent[i]=i;\\n        for(int i=0;i<s1.size();i++){\\n            int a=s1[i]-\\'a\\';\\n            int b=s2[i]-\\'a\\';\\n            uni(a,b);\\n        }\\n        for(int i=0;i<basestr.size();i++){\\n            int a=findpar(basestr[i]-\\'a\\');\\n            basestr[i]=a+\\'a\\';\\n        }\\n        return basestr;\\n    }\\n};\\n```\\nplease upvote if you like it.\\n\\n![leetcode.jpg](https://assets.leetcode.com/users/images/afde0822-e3ea-45d2-b8bd-4a78e2f16b45_1673704091.5924892.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    int findpar(int node){\\n        if(node==parent[node]) return node;\\n\\n        return findpar(parent[node]);\\n    }\\n    void uni(int u,int v){\\n        u=findpar(u);\\n        v=findpar(v);\\n        if(u==v) return;\\n        if(u<v){\\n            parent[v]=u;\\n        }\\n        else{\\n            parent[u]=v;\\n        }\\n        return;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string basestr) {\\n        parent.resize(26,0);\\n        rank.resize(26,0);\\n        for(int i=0;i<26;i++) parent[i]=i;\\n        for(int i=0;i<s1.size();i++){\\n            int a=s1[i]-\\'a\\';\\n            int b=s2[i]-\\'a\\';\\n            uni(a,b);\\n        }\\n        for(int i=0;i<basestr.size();i++){\\n            int a=findpar(basestr[i]-\\'a\\');\\n            basestr[i]=a+\\'a\\';\\n        }\\n        return basestr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050195,
                "title": "c-hash-map-simple-without-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMany are trying to do this by using Union Find but I want to share the idea of using map. If we use a hash map of 26 .Which we will initiliaze with a-z  then we have just compare the incoming two letters from the two strings and update the map with minimum among them. \\nAt last update the baseStr by our hash map characters .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- `mx=max(mp[s1[i]-\\'a\\'],mp[s2[i]-\\'a\\'])` -->gives that character which we have to update \\n- `mn=min(mp[s1[i]-\\'a\\'],mp[s2[i]-\\'a\\'])` --> gives that character with which we will update \\n- beacuse we want lexographically smallest so update max with min.\\n- The map will track  those who where updated because it will now store the minimum and will compare that minimum stored with other incoming characters.\\n- e.g first compare `r,k` change `r with k` then k will be stored at r\\'s position and if in future there is `r,s` rth position will have k so it will compare `k and s` and thus change `s to k` as well . \\n- So in this manner it will return lexographically smallest string possible\\n# Complexity\\n- Time complexity:O(n*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        string ans;\\n        int n=s1.length();\\n        int mp[26];\\n        for(int i=0;i<26;i++){\\n          mp[i]=\\'a\\'+i;\\n        }\\n        for(int i=0;i<n;i++){\\n            int mx=max(mp[s1[i]-\\'a\\'],mp[s2[i]-\\'a\\']);\\n             int mn=min(mp[s1[i]-\\'a\\'],mp[s2[i]-\\'a\\']);\\n             for(int i=0;i<26;i++){\\n                 if(mp[i]==mx)mp[i]=mn;\\n             }\\n        }\\n        for(int i=0;i<baseStr.size();i++){\\n            baseStr[i]=mp[baseStr[i]-\\'a\\'];\\n        }\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        string ans;\\n        int n=s1.length();\\n        int mp[26];\\n        for(int i=0;i<26;i++){\\n          mp[i]=\\'a\\'+i;\\n        }\\n        for(int i=0;i<n;i++){\\n            int mx=max(mp[s1[i]-\\'a\\'],mp[s2[i]-\\'a\\']);\\n             int mn=min(mp[s1[i]-\\'a\\'],mp[s2[i]-\\'a\\']);\\n             for(int i=0;i<26;i++){\\n                 if(mp[i]==mx)mp[i]=mn;\\n             }\\n        }\\n        for(int i=0;i<baseStr.size();i++){\\n            baseStr[i]=mp[baseStr[i]-\\'a\\'];\\n        }\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050113,
                "title": "go-o-26n-m-100-use-array",
                "content": "# Code\\n```\\nfunc smallestEquivalentString(s1 string, s2 string, baseStr string) string {\\n    mapping := [26]int{}\\n    for i := 0; i < 26; i++ {\\n        mapping[i] = i\\n    }\\n\\n    for i := 0; i < len(s1); i++ {\\n        a, b := s1[i] - \\'a\\', s2[i] - \\'a\\'\\n        c, d := mapping[a], mapping[b]\\n        if c > d {\\n            c, d = d, c\\n        }\\n        // d -> c\\n        for j := 0; j < 26; j++ {\\n            if mapping[j] == d {\\n                mapping[j] = c\\n            }\\n        }\\n    }\\n    ret := \"\"\\n    for i := 0; i < len(baseStr); i++ {\\n        t := baseStr[i] - \\'a\\'\\n        ret += string(mapping[t] + \\'a\\')\\n    }\\n    return ret\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc smallestEquivalentString(s1 string, s2 string, baseStr string) string {\\n    mapping := [26]int{}\\n    for i := 0; i < 26; i++ {\\n        mapping[i] = i\\n    }\\n\\n    for i := 0; i < len(s1); i++ {\\n        a, b := s1[i] - \\'a\\', s2[i] - \\'a\\'\\n        c, d := mapping[a], mapping[b]\\n        if c > d {\\n            c, d = d, c\\n        }\\n        // d -> c\\n        for j := 0; j < 26; j++ {\\n            if mapping[j] == d {\\n                mapping[j] = c\\n            }\\n        }\\n    }\\n    ret := \"\"\\n    for i := 0; i < len(baseStr); i++ {\\n        t := baseStr[i] - \\'a\\'\\n        ret += string(mapping[t] + \\'a\\')\\n    }\\n    return ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3049630,
                "title": "java-3-solutions-with-without-union-find-dfs",
                "content": "# Please Upvote :D\\n---\\n##### 1. Using Union find algorithm:\\nWe have used the typical Union find template.\\n``` java []\\n// Smallest Lexicographically Equivalent Letter = SLEL\\nclass Solution {\\n    private class UnionFind {\\n        private int[] parentArr;    // stores the SLEL for all 26 characters\\n        private UnionFind(int n) {\\n            parentArr = new int[n]; // initialise the parent array\\n            // // By default, each letter itself is it\\'s SLEL\\n            for (int i = 0; i < n; i++) {\\n                parentArr[i] = i;\\n            }\\n        }\\n\\n        // this method would fetch us the SLEL for a particular character\\n        private int getParent(int i) {\\n            // example : SLEL of k is k, so we return k\\n            // but SLEL of s is r, again we see SLEL of r is k \\n            // (recursive call getParent(parentArr[i]) will keep setting SLELs of our character at index i) till we\\n            // reach the situation \"each letter itself is it\\'s SLE\" is encountered (parentArr[i] == i)\\n            // character k has been set as the SLEL of r and s and we return k when k/r/s is passed\\n            return (parentArr[i] == i)? i : (parentArr[i] = getParent(parentArr[i])); \\n        }\\n\\n        // this method would set the SLELs for each corresponding characters in s1 and s2\\n        private void union(int i, int j) {\\n            int parent1 = getParent(i); // get the SLEL for char at index i\\n            int parent2 = getParent(j); // get the SLEL for char at index i\\n            if (parent1 < parent2) {    // if SLEL at i < SLEL at j\\n                // SLEL at i now becomes SLEL at j too \\n                parentArr[parent2] = parent1;   \\n            } else {    // SLEL at i > SLEL at j\\n                // SLEL at j now becomes SLEL at i too \\n                parentArr[parent1] = parent2;   \\n            }\\n        }\\n    }\\n\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        UnionFind uf = new UnionFind(26);   // initialises our UnionFind object\\n        for (int i = 0; i < s1.length(); i++) {\\n            int c1 = s1.charAt(i) - \\'a\\';\\n            int c2 = s2.charAt(i) - \\'a\\';\\n            uf.union(c1, c2);   // this will map the SLEL to c1 as well as SLEL to c2 in the parent array\\n        }\\n\\n        StringBuilder sb = new StringBuilder(); // to build our answer string\\n        for (int i = 0; i < baseStr.length(); i++) {\\n            // this would fetch us the SLEL for our current character of baseStr\\n            int smallestMappedChar = uf.getParent(baseStr.charAt(i) - \\'a\\');\\n            sb.append((char) (smallestMappedChar + \\'a\\'));   // we will append it to our answer\\n        }\\n\\n        return sb.toString();   // return the answer string\\n    }\\n}\\n\\n// TC: O(len(s1) + len(baseStr)), SC: O(1)\\n```\\n---\\n\\n##### 2. Without using Union Find algorithm:\\n*Inspired from the solution of **[YatharthVyas\\n](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047721/easy-c-solution-using-array-without-union-find/?orderBy=most_votes)***\\n``` java []\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        // Smallest Lexicographically Equivalent Letter = SLEL\\n        // creating an array of size 26 which will store the SLELs\\n        char[] arr = new char[26];\\n        // By default, each letter itself is it\\'s SLEL\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            arr[c - \\'a\\'] = c;\\n        }\\n\\n        // Now we will iterate over the strings and map them to their SLELs\\n        for (int i = 0; i < s1.length(); i++) {\\n            char c1 = s1.charAt(i), c2 = s2.charAt(i);\\n            // say we have characters \\'p\\' and \\'m\\' at same index of s1 and s2,\\n            // out of both of them \\'m\\' is smaller, so it is SLEL for \\'p\\'\\n            char toReplace = (char) Math.max(arr[c1-\\'a\\'], arr[c2-\\'a\\']);     // replace: max(\\'p\\', \\'m\\') = \\'p\\'\\n            char replaceWith = (char) Math.min(arr[c1-\\'a\\'], arr[c2-\\'a\\']);   // with: min(\\'p\\', \\'m\\') = \\'m\\'\\n            // we will wherever \\'p\\' is and put \\'m\\' in its place.\\n            for (int j = 0; j < 26; j++) {\\n                if (arr[j] == toReplace) {  // found \\'p\\'\\n                    arr[j] = replaceWith;   // put \\'m\\'\\n                }\\n            }\\n\\n            // say for example we have \\'k\\' and \\'r\\', so we will put \\'k\\' in places of \\'r\\'s.\\n            // then we get the pair \\'r\\' and \\'s\\', but in place of \\'r\\' we have already put \\'k\\' (arr[\\'r\\'] = \\'k\\')\\n            // REPLACE : max(arr[\\'r\\'], arr[\\'s\\']) => max(\\'k\\', \\'s\\') => \\'s\\'\\n            // WITH    : min(arr[\\'r\\'], arr[\\'s\\']) => min(\\'k\\', \\'s\\') => \\'k\\'\\n            // So wherever \\'s\\' is in the array, we will put \\'k\\' in its place\\n            // which means for \\'s\\', \\'k\\' is the SLEL\\n        }\\n\\n        StringBuilder sb = new StringBuilder();     // create a stringbuilder to build our answer string\\n        // We will append the SLEL for each character in baseStr\\n        for (char c : baseStr.toCharArray()) {\\n            sb.append(arr[c - \\'a\\']);\\n        }\\n\\n        return sb.toString();   // return the answer string\\n    }\\n}\\n\\n// TC: O(n * 26) + O(m) => O(n + m)\\n// n be the length of s1 and s2\\n// m be the length of baseStr\\n\\n// SC: O(26) => O(1)\\n```\\n---\\n##### 3. DFS approach:\\n``` java []\\nclass Solution {\\n    private Map<Character, List<Character>> adj = new HashMap<>();  // globally initialise the adjacency map\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        // populate the adjacency map\\n        for (int i = 0; i < s1.length(); i++) {\\n            char c1 = s1.charAt(i);\\n            char c2 = s2.charAt(i);\\n            adj.putIfAbsent(c1, new ArrayList<>());\\n            adj.putIfAbsent(c2, new ArrayList<>());\\n            adj.get(c1).add(c2);\\n            adj.get(c2).add(c1);\\n        }\\n\\n        // Smallest Lexicographically Equivalent Letter = SLEL\\n        StringBuilder sb = new StringBuilder();     // to store the answer string\\n        for (char c : baseStr.toCharArray()) {\\n            // we will perform a dfs and find the SLEL corresponding to each character in baseStr\\n            // we also paa in a boolean visited array to avoid going back to same characters where we came from\\n            char smallestChar = DFS(c, new boolean[26]);\\n            sb.append(smallestChar);    // append the SLEL to the stringbuilder\\n        }\\n        \\n        return sb.toString();       // return the answer string\\n    }\\n\\n    private char DFS(char currChar, boolean[] visited) {\\n        // since we have visited this letter (currChar), we mark it so we don\\'t visit it again \\n        visited[currChar - \\'a\\'] = true;    \\n        // if the character is not in our adjacency list, means it wasn\\'t present in s1 or s2\\n        // So it itself is it\\'s SLEL\\n        if (!adj.containsKey(currChar)) {\\n            return currChar;    // so we return currChar itself\\n        }\\n        \\n        // now lets initialise our SLEL character variable with currChar\\n        // we assume our character itself is it\\'s SLEL\\n        char smallestChar = currChar;\\n        for (char childChar : adj.get(currChar)) {     // we look at all characters connected to current character\\n            if (!visited[childChar - \\'a\\']) {           // if it wasn\\'t visited already, we do some work\\n                // since our currChar is connected to childChar, we will see what the SLEL for our childChar is\\n                char smallestConnectedChar = DFS(childChar, visited);  // it will fetch us the SLEL for our childChar\\n                // the SLEL for our currChar would be the smaller character between itself and the SLEL of child\\n                smallestChar = (char) Math.min(smallestChar, smallestConnectedChar);\\n            }\\n        }\\n\\n        return smallestChar;    // we will return the SLEL (also it will be utilised during backtracking)\\n    }\\n}\\n\\n// TC: O(m * (v + e)), SC: O(v + e)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "``` java []\\n// Smallest Lexicographically Equivalent Letter = SLEL\\nclass Solution {\\n    private class UnionFind {\\n        private int[] parentArr;    // stores the SLEL for all 26 characters\\n        private UnionFind(int n) {\\n            parentArr = new int[n]; // initialise the parent array\\n            // // By default, each letter itself is it\\'s SLEL\\n            for (int i = 0; i < n; i++) {\\n                parentArr[i] = i;\\n            }\\n        }\\n\\n        // this method would fetch us the SLEL for a particular character\\n        private int getParent(int i) {\\n            // example : SLEL of k is k, so we return k\\n            // but SLEL of s is r, again we see SLEL of r is k \\n            // (recursive call getParent(parentArr[i]) will keep setting SLELs of our character at index i) till we\\n            // reach the situation \"each letter itself is it\\'s SLE\" is encountered (parentArr[i] == i)\\n            // character k has been set as the SLEL of r and s and we return k when k/r/s is passed\\n            return (parentArr[i] == i)? i : (parentArr[i] = getParent(parentArr[i])); \\n        }\\n\\n        // this method would set the SLELs for each corresponding characters in s1 and s2\\n        private void union(int i, int j) {\\n            int parent1 = getParent(i); // get the SLEL for char at index i\\n            int parent2 = getParent(j); // get the SLEL for char at index i\\n            if (parent1 < parent2) {    // if SLEL at i < SLEL at j\\n                // SLEL at i now becomes SLEL at j too \\n                parentArr[parent2] = parent1;   \\n            } else {    // SLEL at i > SLEL at j\\n                // SLEL at j now becomes SLEL at i too \\n                parentArr[parent1] = parent2;   \\n            }\\n        }\\n    }\\n\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        UnionFind uf = new UnionFind(26);   // initialises our UnionFind object\\n        for (int i = 0; i < s1.length(); i++) {\\n            int c1 = s1.charAt(i) - \\'a\\';\\n            int c2 = s2.charAt(i) - \\'a\\';\\n            uf.union(c1, c2);   // this will map the SLEL to c1 as well as SLEL to c2 in the parent array\\n        }\\n\\n        StringBuilder sb = new StringBuilder(); // to build our answer string\\n        for (int i = 0; i < baseStr.length(); i++) {\\n            // this would fetch us the SLEL for our current character of baseStr\\n            int smallestMappedChar = uf.getParent(baseStr.charAt(i) - \\'a\\');\\n            sb.append((char) (smallestMappedChar + \\'a\\'));   // we will append it to our answer\\n        }\\n\\n        return sb.toString();   // return the answer string\\n    }\\n}\\n\\n// TC: O(len(s1) + len(baseStr)), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        // Smallest Lexicographically Equivalent Letter = SLEL\\n        // creating an array of size 26 which will store the SLELs\\n        char[] arr = new char[26];\\n        // By default, each letter itself is it\\'s SLEL\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            arr[c - \\'a\\'] = c;\\n        }\\n\\n        // Now we will iterate over the strings and map them to their SLELs\\n        for (int i = 0; i < s1.length(); i++) {\\n            char c1 = s1.charAt(i), c2 = s2.charAt(i);\\n            // say we have characters \\'p\\' and \\'m\\' at same index of s1 and s2,\\n            // out of both of them \\'m\\' is smaller, so it is SLEL for \\'p\\'\\n            char toReplace = (char) Math.max(arr[c1-\\'a\\'], arr[c2-\\'a\\']);     // replace: max(\\'p\\', \\'m\\') = \\'p\\'\\n            char replaceWith = (char) Math.min(arr[c1-\\'a\\'], arr[c2-\\'a\\']);   // with: min(\\'p\\', \\'m\\') = \\'m\\'\\n            // we will wherever \\'p\\' is and put \\'m\\' in its place.\\n            for (int j = 0; j < 26; j++) {\\n                if (arr[j] == toReplace) {  // found \\'p\\'\\n                    arr[j] = replaceWith;   // put \\'m\\'\\n                }\\n            }\\n\\n            // say for example we have \\'k\\' and \\'r\\', so we will put \\'k\\' in places of \\'r\\'s.\\n            // then we get the pair \\'r\\' and \\'s\\', but in place of \\'r\\' we have already put \\'k\\' (arr[\\'r\\'] = \\'k\\')\\n            // REPLACE : max(arr[\\'r\\'], arr[\\'s\\']) => max(\\'k\\', \\'s\\') => \\'s\\'\\n            // WITH    : min(arr[\\'r\\'], arr[\\'s\\']) => min(\\'k\\', \\'s\\') => \\'k\\'\\n            // So wherever \\'s\\' is in the array, we will put \\'k\\' in its place\\n            // which means for \\'s\\', \\'k\\' is the SLEL\\n        }\\n\\n        StringBuilder sb = new StringBuilder();     // create a stringbuilder to build our answer string\\n        // We will append the SLEL for each character in baseStr\\n        for (char c : baseStr.toCharArray()) {\\n            sb.append(arr[c - \\'a\\']);\\n        }\\n\\n        return sb.toString();   // return the answer string\\n    }\\n}\\n\\n// TC: O(n * 26) + O(m) => O(n + m)\\n// n be the length of s1 and s2\\n// m be the length of baseStr\\n\\n// SC: O(26) => O(1)\\n```\n``` java []\\nclass Solution {\\n    private Map<Character, List<Character>> adj = new HashMap<>();  // globally initialise the adjacency map\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        // populate the adjacency map\\n        for (int i = 0; i < s1.length(); i++) {\\n            char c1 = s1.charAt(i);\\n            char c2 = s2.charAt(i);\\n            adj.putIfAbsent(c1, new ArrayList<>());\\n            adj.putIfAbsent(c2, new ArrayList<>());\\n            adj.get(c1).add(c2);\\n            adj.get(c2).add(c1);\\n        }\\n\\n        // Smallest Lexicographically Equivalent Letter = SLEL\\n        StringBuilder sb = new StringBuilder();     // to store the answer string\\n        for (char c : baseStr.toCharArray()) {\\n            // we will perform a dfs and find the SLEL corresponding to each character in baseStr\\n            // we also paa in a boolean visited array to avoid going back to same characters where we came from\\n            char smallestChar = DFS(c, new boolean[26]);\\n            sb.append(smallestChar);    // append the SLEL to the stringbuilder\\n        }\\n        \\n        return sb.toString();       // return the answer string\\n    }\\n\\n    private char DFS(char currChar, boolean[] visited) {\\n        // since we have visited this letter (currChar), we mark it so we don\\'t visit it again \\n        visited[currChar - \\'a\\'] = true;    \\n        // if the character is not in our adjacency list, means it wasn\\'t present in s1 or s2\\n        // So it itself is it\\'s SLEL\\n        if (!adj.containsKey(currChar)) {\\n            return currChar;    // so we return currChar itself\\n        }\\n        \\n        // now lets initialise our SLEL character variable with currChar\\n        // we assume our character itself is it\\'s SLEL\\n        char smallestChar = currChar;\\n        for (char childChar : adj.get(currChar)) {     // we look at all characters connected to current character\\n            if (!visited[childChar - \\'a\\']) {           // if it wasn\\'t visited already, we do some work\\n                // since our currChar is connected to childChar, we will see what the SLEL for our childChar is\\n                char smallestConnectedChar = DFS(childChar, visited);  // it will fetch us the SLEL for our childChar\\n                // the SLEL for our currChar would be the smaller character between itself and the SLEL of child\\n                smallestChar = (char) Math.min(smallestChar, smallestConnectedChar);\\n            }\\n        }\\n\\n        return smallestChar;    // we will return the SLEL (also it will be utilised during backtracking)\\n    }\\n}\\n\\n// TC: O(m * (v + e)), SC: O(v + e)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047914,
                "title": "python3-solution-union-find",
                "content": "# Complexity\\n- Time complexity: $$O(n + m)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        D = {i: i for i in ascii_lowercase}\\n        def parent(x):\\n            if D[x] == x: return x\\n            x = parent(D[x])\\n            return x\\n        def union(x, y):\\n            u, v = parent(x), parent(y)\\n            D[u] = D[v] = min(u, v)\\n        for a, b in zip(s1, s2):\\n            union(a, b)\\n        return \\'\\'.join([parent(i) for i in baseStr])\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        D = {i: i for i in ascii_lowercase}\\n        def parent(x):\\n            if D[x] == x: return x\\n            x = parent(D[x])\\n            return x\\n        def union(x, y):\\n            u, v = parent(x), parent(y)\\n            D[u] = D[v] = min(u, v)\\n        for a, b in zip(s1, s2):\\n            union(a, b)\\n        return \\'\\'.join([parent(i) for i in baseStr])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047873,
                "title": "python-using-a-list-of-sets-runtime-38-ms-faster-than-96-55",
                "content": "https://leetcode.com/submissions/detail/877788150/  \\nRuntime: **38 ms**, faster than 96.55% of Python3 online submissions for Lexicographically Smallest Equivalent String.  \\nMemory Usage: 13.9 MB, less than 56.90% of Python3 online submissions for Lexicographically Smallest Equivalent String.  \\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        relations, d = [], dict() ## \"relations\" is a list of sets\\n        \\n        for c1,c2 in zip(s1,s2):\\n            if c1==c2: continue\\n            i1, i2 = None, None\\n            for i,r in enumerate(relations):\\n                if c1 in r or c2 in r:\\n                    if i1 is not None: ## two sets have the same character\\n                        i2 = i\\n                        relations[i1].update(r) ## merge the 2nd set to the 1st one\\n                        break\\n                    i1 = i\\n                    r.update((c1, c2))\\n            if i2 is not None:  ## delete the 2nd set\\n                relations = relations[:i2] + relations[i2+1:]\\n            if i1 is None:\\n                relations.append({c1, c2})\\n\\n        for r in relations: ## convert to a dictionary so it is easier to work with\\n            l = sorted(r)\\n            for c in l:\\n                d[c] = l[0]\\n                \\n        return \\'\\'.join([d[c] if c in d else c for c in baseStr])\\n```\\n\\n**Test cases**  \\n```\\n\"parker\"\\n\"morris\"\\n\"parser\"\\n\"hello\"\\n\"world\"\\n\"hold\"\\n\"leetcode\"\\n\"programs\"\\n\"sourcecode\"\\n\"aabbbabbbbbabbbbaabaabbaaabbbabaababaaaabbbbbabbaa\"\\n\"aabbaabbbabaababaabaababbbababbbaaaabbbbbabbbaabaa\"\\n\"buqpqxmnajphtisernebttymtrydomxnwonfhfjlzzrfhosjct\"\\n\"dfeffdfafbbebbebacbbdfcfdbcacdcbeeffdfebbdebbdafff\"\\n\"adcdfabadbeeafeabbadcefcaabdecabfecffbabbfcdfcaaae\"\\n\"myickvflcpfyqievitqtwvfpsrxigauvlqdtqhpfugguwfcpqv\"\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        relations, d = [], dict() ## \"relations\" is a list of sets\\n        \\n        for c1,c2 in zip(s1,s2):\\n            if c1==c2: continue\\n            i1, i2 = None, None\\n            for i,r in enumerate(relations):\\n                if c1 in r or c2 in r:\\n                    if i1 is not None: ## two sets have the same character\\n                        i2 = i\\n                        relations[i1].update(r) ## merge the 2nd set to the 1st one\\n                        break\\n                    i1 = i\\n                    r.update((c1, c2))\\n            if i2 is not None:  ## delete the 2nd set\\n                relations = relations[:i2] + relations[i2+1:]\\n            if i1 is None:\\n                relations.append({c1, c2})\\n\\n        for r in relations: ## convert to a dictionary so it is easier to work with\\n            l = sorted(r)\\n            for c in l:\\n                d[c] = l[0]\\n                \\n        return \\'\\'.join([d[c] if c in d else c for c in baseStr])\\n```\n```\\n\"parker\"\\n\"morris\"\\n\"parser\"\\n\"hello\"\\n\"world\"\\n\"hold\"\\n\"leetcode\"\\n\"programs\"\\n\"sourcecode\"\\n\"aabbbabbbbbabbbbaabaabbaaabbbabaababaaaabbbbbabbaa\"\\n\"aabbaabbbabaababaabaababbbababbbaaaabbbbbabbbaabaa\"\\n\"buqpqxmnajphtisernebttymtrydomxnwonfhfjlzzrfhosjct\"\\n\"dfeffdfafbbebbebacbbdfcfdbcacdcbeeffdfebbdebbdafff\"\\n\"adcdfabadbeeafeabbadcefcaabdecabfecffbabbfcdfcaaae\"\\n\"myickvflcpfyqievitqtwvfpsrxigauvlqdtqhpfugguwfcpqv\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047869,
                "title": "c-union-find-by-character-size-easy-explaination",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUnion-Find Concept of graph. See the commented code for better explanation.\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    // return the ultimate parent (representative) of the component containing x as one of its element.\\n    int find(int x){\\n        if(parent[x]==x)    return x;\\n        \\n        return parent[x] = find(parent[x]);\\n    }\\n    // Perform union if a and b aren\\'t in the same component.\\n    void _union(int a , int b){\\n        int x = find(a);\\n        int y = find(b);\\n        // return if a and b are in the same component\\n        if(x==y)    return;             \\n        // Make the smaller character parent of the other one as we want the lexicograohically smallest string.\\n        if(x > y)   parent[x] = y;\\n        else        parent[y] = x;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        parent.resize(26);\\n        // Make each character parent of itself.\\n        for(int i=0 ; i<26 ; i++){\\n            parent[i]=i;\\n        }\\n        // Perform union merge for all the pairs of characters from both the strings s1 and s2.\\n        for(int i=0 ; i<s1.size() ; i++){\\n            _union(s1[i]-\\'a\\' , s2[i]-\\'a\\');\\n        }\\n        // Create the answer string with final parent vector.\\n        string res=\"\";\\n        for(char ch : baseStr){\\n            res += (char)(find(ch-\\'a\\')+\\'a\\');\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    // return the ultimate parent (representative) of the component containing x as one of its element.\\n    int find(int x){\\n        if(parent[x]==x)    return x;\\n        \\n        return parent[x] = find(parent[x]);\\n    }\\n    // Perform union if a and b aren\\'t in the same component.\\n    void _union(int a , int b){\\n        int x = find(a);\\n        int y = find(b);\\n        // return if a and b are in the same component\\n        if(x==y)    return;             \\n        // Make the smaller character parent of the other one as we want the lexicograohically smallest string.\\n        if(x > y)   parent[x] = y;\\n        else        parent[y] = x;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        parent.resize(26);\\n        // Make each character parent of itself.\\n        for(int i=0 ; i<26 ; i++){\\n            parent[i]=i;\\n        }\\n        // Perform union merge for all the pairs of characters from both the strings s1 and s2.\\n        for(int i=0 ; i<s1.size() ; i++){\\n            _union(s1[i]-\\'a\\' , s2[i]-\\'a\\');\\n        }\\n        // Create the answer string with final parent vector.\\n        string res=\"\";\\n        for(char ch : baseStr){\\n            res += (char)(find(ch-\\'a\\')+\\'a\\');\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047635,
                "title": "python3-union-find-with-char-groups",
                "content": "The usual union-find is thinking about belonging to groups and in this case, assume there can be 26 groups. \\n\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        d = {\\'a\\': \\'a\\', \\'b\\': \\'b\\', \\'c\\': \\'c\\', \\'d\\': \\'d\\', \\'e\\': \\'e\\', \\'f\\': \\'f\\', \\'g\\': \\'g\\', \\'h\\': \\'h\\', \\'i\\': \\'i\\', \\'j\\': \\'j\\', \\'k\\': \\'k\\', \\'l\\': \\'l\\', \\'m\\': \\'m\\', \\'n\\': \\'n\\', \\'o\\': \\'o\\', \\'p\\': \\'p\\', \\'q\\': \\'q\\', \\'r\\': \\'r\\', \\'s\\': \\'s\\', \\'t\\': \\'t\\', \\'u\\': \\'u\\', \\'v\\': \\'v\\', \\'w\\': \\'w\\', \\'x\\': \\'x\\', \\'y\\': \\'y\\', \\'z\\': \\'z\\'}\\n        \\n        def find(char):\\n            if char != d[char]:\\n                d[char] = find(d[char])\\n            return d[char]\\n        \\n        def update(char, value):\\n            if char != d[char]:\\n                update(d[char], value)\\n            d[char] = value\\n            \\n        for a,b in zip(s1, s2):\\n            p,q = find(a), find(b)\\n            \\n            if p > q:\\n                update(p, q)\\n            else:\\n                update(q, p)\\n\\n        return \"\".join([find(d[i]) for i in baseStr])\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "class Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        d = {\\'a\\': \\'a\\', \\'b\\': \\'b\\', \\'c\\': \\'c\\', \\'d\\': \\'d\\', \\'e\\': \\'e\\', \\'f\\': \\'f\\', \\'g\\': \\'g\\', \\'h\\': \\'h\\', \\'i\\': \\'i\\', \\'j\\': \\'j\\', \\'k\\': \\'k\\', \\'l\\': \\'l\\', \\'m\\': \\'m\\', \\'n\\': \\'n\\', \\'o\\': \\'o\\', \\'p\\': \\'p\\', \\'q\\': \\'q\\', \\'r\\': \\'r\\', \\'s\\': \\'s\\', \\'t\\': \\'t\\', \\'u\\': \\'u\\', \\'v\\': \\'v\\', \\'w\\': \\'w\\', \\'x\\': \\'x\\', \\'y\\': \\'y\\', \\'z\\': \\'z\\'}",
                "codeTag": "Java"
            },
            {
                "id": 2915992,
                "title": "python-very-detailed-union-find",
                "content": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        # Create a list of numbers from 0 to 25.\\n        # This list will be used to keep track of the equivalence classes of the characters in s1 and s2.\\n        # Each element i in ds represents the character \\'a\\' + i.\\n        # For example, ds[0] represents the character \\'a\\', ds[1] represents the character \\'b\\', etc.\\n        # Initially, each element in ds represents a single-element equivalence class containing the character it represents.\\n        ds = list(range(26))\\n\\n        # Define a nested function that takes a character c as input and returns the root representative of the equivalence class containing c.\\n        # The root representative is the smallest character in the equivalence class.\\n        # For example, if ds[0] = 1 and ds[1] = 2, then the root representative of the equivalence class containing \\'a\\' is \\'c\\' (\\'a\\' + 2).\\n        # The find() function uses recursion to traverse the elements in ds until it reaches the root representative.\\n        # If the current element is the root representative, the function returns it.\\n        # Otherwise, the function returns the result of calling itself on the next element in the chain.\\n        def find(c):\\n            return c if ds[c] == c else find(ds[c])\\n\\n        # Iterate over the characters in s1 and s2 using a for loop.\\n        # For each pair of characters (s1[i], s2[i]), do the following:\\n        for i in range(len(s1)):\\n            # Convert each character to an integer between 0 and 25 by subtracting \\'a\\' from it.\\n            # For example, \\'a\\' becomes 0, \\'b\\' becomes 1, etc.\\n            # The ord function is used to convert the characters to their corresponding integer values.The integer values\\n            # for the lowercase letters \\'a\\' through \\'z\\' are in the range from 97 to 122, so the ord(\\'a\\') expression evaluates\\n            # to 97. By subtracting ord(\\'a\\') from the integer value of each character, we can map the characters to the integers\\n            # in the range from 0 to 25. This allows us to use the integer values as indices in the ds list, which is used to keep\\n            # track of the connected components.\\n            c_1, c_2 = ord(s1[i]) - ord(\\'a\\'), ord(s2[i]) - ord(\\'a\\')\\n\\n            # Find the root representatives of the equivalence classes containing c_1 and c_2 using the find() function.\\n            p_1, p_2 = find(c_1), find(c_2)\\n\\n            # If p_1 and p_2 are not in the same equivalence class, perform union merge on the two equivalence classes.\\n            # To do this, set the element in ds corresponding to the larger of p_1 and p_2 to the smaller of p_1 and p_2.\\n            # This will make the smaller character the root representative of both equivalence classes.\\n            if p_1 != p_2:\\n                ds[max(p_1, p_2)] = min(p_1, p_2)\\n\\n        # Initialize an empty string to store the answer.\\n        answer = \"\"\\n\\n        # Iterate over the characters in baseStr.\\n        # For each character c, append to answer the character \\'a\\' + find(c - \\'a\\'), which is the smallest character in s1 and s2 that is equivalent to c.\\n        # Note that we subtract \\'a\\' from c to convert it to an integer between 0 and 25, and then add \\'a\\' to the result of find() to convert it back to its original integer representation before subtracting \\'a\\' to reduce the  range to (0,25) before.\\n        for c in baseStr:\\n            answer += chr(find(ord(c) - ord(\\'a\\')) + ord(\\'a\\'))\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        # Create a list of numbers from 0 to 25.\\n        # This list will be used to keep track of the equivalence classes of the characters in s1 and s2.\\n        # Each element i in ds represents the character \\'a\\' + i.\\n        # For example, ds[0] represents the character \\'a\\', ds[1] represents the character \\'b\\', etc.\\n        # Initially, each element in ds represents a single-element equivalence class containing the character it represents.\\n        ds = list(range(26))\\n\\n        # Define a nested function that takes a character c as input and returns the root representative of the equivalence class containing c.\\n        # The root representative is the smallest character in the equivalence class.\\n        # For example, if ds[0] = 1 and ds[1] = 2, then the root representative of the equivalence class containing \\'a\\' is \\'c\\' (\\'a\\' + 2).\\n        # The find() function uses recursion to traverse the elements in ds until it reaches the root representative.\\n        # If the current element is the root representative, the function returns it.\\n        # Otherwise, the function returns the result of calling itself on the next element in the chain.\\n        def find(c):\\n            return c if ds[c] == c else find(ds[c])\\n\\n        # Iterate over the characters in s1 and s2 using a for loop.\\n        # For each pair of characters (s1[i], s2[i]), do the following:\\n        for i in range(len(s1)):\\n            # Convert each character to an integer between 0 and 25 by subtracting \\'a\\' from it.\\n            # For example, \\'a\\' becomes 0, \\'b\\' becomes 1, etc.\\n            # The ord function is used to convert the characters to their corresponding integer values.The integer values\\n            # for the lowercase letters \\'a\\' through \\'z\\' are in the range from 97 to 122, so the ord(\\'a\\') expression evaluates\\n            # to 97. By subtracting ord(\\'a\\') from the integer value of each character, we can map the characters to the integers\\n            # in the range from 0 to 25. This allows us to use the integer values as indices in the ds list, which is used to keep\\n            # track of the connected components.\\n            c_1, c_2 = ord(s1[i]) - ord(\\'a\\'), ord(s2[i]) - ord(\\'a\\')\\n\\n            # Find the root representatives of the equivalence classes containing c_1 and c_2 using the find() function.\\n            p_1, p_2 = find(c_1), find(c_2)\\n\\n            # If p_1 and p_2 are not in the same equivalence class, perform union merge on the two equivalence classes.\\n            # To do this, set the element in ds corresponding to the larger of p_1 and p_2 to the smaller of p_1 and p_2.\\n            # This will make the smaller character the root representative of both equivalence classes.\\n            if p_1 != p_2:\\n                ds[max(p_1, p_2)] = min(p_1, p_2)\\n\\n        # Initialize an empty string to store the answer.\\n        answer = \"\"\\n\\n        # Iterate over the characters in baseStr.\\n        # For each character c, append to answer the character \\'a\\' + find(c - \\'a\\'), which is the smallest character in s1 and s2 that is equivalent to c.\\n        # Note that we subtract \\'a\\' from c to convert it to an integer between 0 and 25, and then add \\'a\\' to the result of find() to convert it back to its original integer representation before subtracting \\'a\\' to reduce the  range to (0,25) before.\\n        for c in baseStr:\\n            answer += chr(find(ord(c) - ord(\\'a\\')) + ord(\\'a\\'))\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049970,
                "title": "c-100-beats-easy-greedy",
                "content": "\\n# Approach \\n- Just finding out the minimum value of each alphabet by repetitive updation\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string bs) {\\n        vector<char>v(26);\\n        for(char i=\\'a\\';i<=\\'z\\';i++) v[i-\\'a\\']=i;\\n        for(int k=0;k<4;k++)\\n        for(int i=0;i<s1.size();i++){\\n            v[s2[i]-\\'a\\']=min(v[s1[i]-\\'a\\'],v[s2[i]-\\'a\\']);\\n            v[s1[i]-\\'a\\']=min(v[s1[i]-\\'a\\'],v[s2[i]-\\'a\\']);\\n        }\\n        for(int i=0;i<bs.size();i++) bs[i] = v[bs[i]-\\'a\\'];\\n        return bs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string bs) {\\n        vector<char>v(26);\\n        for(char i=\\'a\\';i<=\\'z\\';i++) v[i-\\'a\\']=i;\\n        for(int k=0;k<4;k++)\\n        for(int i=0;i<s1.size();i++){\\n            v[s2[i]-\\'a\\']=min(v[s1[i]-\\'a\\'],v[s2[i]-\\'a\\']);\\n            v[s1[i]-\\'a\\']=min(v[s1[i]-\\'a\\'],v[s2[i]-\\'a\\']);\\n        }\\n        for(int i=0;i<bs.size();i++) bs[i] = v[bs[i]-\\'a\\'];\\n        return bs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049164,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        char c[]=new char[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            c[i]=(char)(\\'a\\'+i);\\n        }\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            char min_char=\\'a\\';\\n            char max_char=\\'a\\';\\n            if(c[s1.charAt(i)-\\'a\\']>c[s2.charAt(i)-\\'a\\']){\\n               min_char=c[s2.charAt(i)-\\'a\\'];\\n               max_char=c[s1.charAt(i)-\\'a\\'];\\n            }else{\\n               max_char=c[s2.charAt(i)-\\'a\\'];\\n               min_char=c[s1.charAt(i)-\\'a\\']  ;\\n            }\\n            \\n            for(int j=0;j<26;j++)\\n            {\\n                if(c[j]==max_char)c[j]=min_char;\\n            }\\n        }\\n        String res=\"\";\\n        System.out.println(Arrays.toString(c));\\n        for(char ch:baseStr.toCharArray())\\n        {\\n            res+=c[ch-\\'a\\'];\\n        }\\n\\n        return res;\\n   }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        char c[]=new char[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            c[i]=(char)(\\'a\\'+i);\\n        }\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            char min_char=\\'a\\';\\n            char max_char=\\'a\\';\\n            if(c[s1.charAt(i)-\\'a\\']>c[s2.charAt(i)-\\'a\\']){\\n               min_char=c[s2.charAt(i)-\\'a\\'];\\n               max_char=c[s1.charAt(i)-\\'a\\'];\\n            }else{\\n               max_char=c[s2.charAt(i)-\\'a\\'];\\n               min_char=c[s1.charAt(i)-\\'a\\']  ;\\n            }\\n            \\n            for(int j=0;j<26;j++)\\n            {\\n                if(c[j]==max_char)c[j]=min_char;\\n            }\\n        }\\n        String res=\"\";\\n        System.out.println(Arrays.toString(c));\\n        for(char ch:baseStr.toCharArray())\\n        {\\n            res+=c[ch-\\'a\\'];\\n        }\\n\\n        return res;\\n   }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049120,
                "title": "js-ts-easy-solution",
                "content": "Js/ts easy solution.\\n\\n\\n# Code\\n```\\nfunction smallestEquivalentString(s1: string, s2: string, baseStr: string): string {\\n    const alphabet = Array.from(\\'abcdefghijklmnopqrstuvwxyz\\');\\n\\n    const graph = alphabet.reduce((acc,cur) => {\\n        acc[cur] = new Set([cur])\\n        return acc\\n    }, {}) \\n\\n    const connect = (a: string, b: string) => {\\n        for (const x of graph[a]) {\\n            for (const y of graph[b]) {\\n                graph[x].add(y)\\n                graph[y].add(x)\\n            }\\n        }\\n    }\\n\\n    for (let i =0; i< s1.length; i++) {\\n        connect(s1[i], s2[i])\\n    }\\n\\n    return Array.from(baseStr).map((c)=> [...graph[c]].sort()[0]).join(\\'\\')\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction smallestEquivalentString(s1: string, s2: string, baseStr: string): string {\\n    const alphabet = Array.from(\\'abcdefghijklmnopqrstuvwxyz\\');\\n\\n    const graph = alphabet.reduce((acc,cur) => {\\n        acc[cur] = new Set([cur])\\n        return acc\\n    }, {}) \\n\\n    const connect = (a: string, b: string) => {\\n        for (const x of graph[a]) {\\n            for (const y of graph[b]) {\\n                graph[x].add(y)\\n                graph[y].add(x)\\n            }\\n        }\\n    }\\n\\n    for (let i =0; i< s1.length; i++) {\\n        connect(s1[i], s2[i])\\n    }\\n\\n    return Array.from(baseStr).map((c)=> [...graph[c]].sort()[0]).join(\\'\\')\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3048734,
                "title": "efficient-c-dsu-solution-with-explanation",
                "content": "**116 / 116** test cases passed\\nStatus: **Accepted**\\nRuntime: *0 ms*\\nMemory Usage: *6.6 MB*\\n\\n\\n***Basic Intuition***\\n\\n* The rules for the \"equivalent characters\" introduced in the problem simply means the two characters are belong to the same group.\\n* And our job is that for each character in baseStr, we need to find its belonging group and find the smallest character from that group.\\n* So we have two tasks:\\n* Create all the groups with equivalent characters from s1 and s2.\\n--> Find the group each character in baseStr, and find the smallest character in that group\\n--> Grouping connected elements can be done using DFS/BFS/Union-find.\\n\\n***Efficient C++ Solution*** : \\n```\\nclass Solution {\\nprivate:\\n    //Parent vector for storing parents. It stores lexicographically smallest equivalent of a character. For ex, if the equivalent of s->r, r->o ; the parent of both s and r becomes o simultaneously by DSU path compression.\\n    vector<int> par;\\n    \\n    //Path Compression\\n    int find(int u){\\n        return par[u]==-1 ? u : par[u]=find(par[u]);\\n    }\\n    \\n    //Merge the components\\n    //If parent of both nodes is same, backtrack and if not, then map the largest character to the smallest one by Path compression...\\n    void Union(int u,int v){\\n        u=find(u), v=find(v);\\n        if(u != v)\\n            par[max(u, v)] = min(u, v);\\n    }\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n=s1.size();\\n        \\n        //Initially parent of all nodes is -1\\n        par.assign(26, -1);\\n        \\n        \\n        //Merging the nodes\\n        for(int i=0; i<n; ++i)\\n            Union(s1[i]-\\'a\\', s2[i]-\\'a\\');\\n        \\n        \\n        //Mapping largest char with the smallest one. If no mapping is there, or no node for an element is found in the DSU map, we will write the character as it is, as it\\'s parent will be -1.  \\n        for(char& c: baseStr)\\n            c = find(c-\\'a\\')+\\'a\\';\\n        \\n        return baseStr;    //Return the final answer :)\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    //Parent vector for storing parents. It stores lexicographically smallest equivalent of a character. For ex, if the equivalent of s->r, r->o ; the parent of both s and r becomes o simultaneously by DSU path compression.\\n    vector<int> par;\\n    \\n    //Path Compression\\n    int find(int u){\\n        return par[u]==-1 ? u : par[u]=find(par[u]);\\n    }\\n    \\n    //Merge the components\\n    //If parent of both nodes is same, backtrack and if not, then map the largest character to the smallest one by Path compression...\\n    void Union(int u,int v){\\n        u=find(u), v=find(v);\\n        if(u != v)\\n            par[max(u, v)] = min(u, v);\\n    }\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n=s1.size();\\n        \\n        //Initially parent of all nodes is -1\\n        par.assign(26, -1);\\n        \\n        \\n        //Merging the nodes\\n        for(int i=0; i<n; ++i)\\n            Union(s1[i]-\\'a\\', s2[i]-\\'a\\');\\n        \\n        \\n        //Mapping largest char with the smallest one. If no mapping is there, or no node for an element is found in the DSU map, we will write the character as it is, as it\\'s parent will be -1.  \\n        for(char& c: baseStr)\\n            c = find(c-\\'a\\')+\\'a\\';\\n        \\n        return baseStr;    //Return the final answer :)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048019,
                "title": "java-striver-dsu-implementation-explanation-with-comments-intution",
                "content": "**Java Solution :**\\n```\\nclass DisjointSet {\\n    \\n\\t// Parent Array to hold smallest character linked with current character\\n    int[] par = new int[26];\\n    \\n    DisjointSet() {\\n        for(int i = 0; i < 26; i++) par[i] = i;\\n    }\\n    \\n\\t// Compressend Find parent Function\\n    int findPar(int x) {\\n        \\n\\t\\t// If x is parent of himself, return\\n        if(par[x] == x) return x;\\n        \\n\\t\\t// Else find its parent update its parent array and return\\n        return par[x] = findPar(par[x]);\\n        \\n    }\\n    \\n\\t// Union just updates the parent\\n    void union(int x, int y) {\\n        \\n        x = findPar(x);\\n        y = findPar(y);\\n        \\n\\t\\t// Lexicographically smaller character will become the parent\\n        if(x < y) par[y] = par[x];\\n        else par[x] = par[y];\\n    \\n    }\\n    \\n}\\n\\nclass Solution {    \\n    \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        DisjointSet ds = new DisjointSet();\\n        \\n        for(int i = 0; i < s1.length(); i++) {\\n            \\n            int x = (int)(s1.charAt(i) - \\'a\\');\\n            int y = (int)(s2.charAt(i) - \\'a\\');\\n            \\n\\t\\t\\t// Making a union of all given equivalent charactrers\\n            ds.union(x, y);\\n            \\n        }\\n        \\n\\t\\t// Adding parent of each character from the Base String\\n\\t\\t// Parent = smallest equivalent character linked with it !!!\\n        StringBuilder ans = new StringBuilder(\"\");\\n        for(int i = 0; i < baseStr.length(); i++) {\\n            char c = (char)(\\'a\\' + ds.findPar((int)(baseStr.charAt(i) - \\'a\\')));\\n            ans.append(c);\\n        }\\n        \\n        return ans.toString();\\n    }\\n\\n}\\n```\\n\\nHope it would have Helped !!!\\n**Thank You !!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DisjointSet {\\n    \\n\\t// Parent Array to hold smallest character linked with current character\\n    int[] par = new int[26];\\n    \\n    DisjointSet() {\\n        for(int i = 0; i < 26; i++) par[i] = i;\\n    }\\n    \\n\\t// Compressend Find parent Function\\n    int findPar(int x) {\\n        \\n\\t\\t// If x is parent of himself, return\\n        if(par[x] == x) return x;\\n        \\n\\t\\t// Else find its parent update its parent array and return\\n        return par[x] = findPar(par[x]);\\n        \\n    }\\n    \\n\\t// Union just updates the parent\\n    void union(int x, int y) {\\n        \\n        x = findPar(x);\\n        y = findPar(y);\\n        \\n\\t\\t// Lexicographically smaller character will become the parent\\n        if(x < y) par[y] = par[x];\\n        else par[x] = par[y];\\n    \\n    }\\n    \\n}\\n\\nclass Solution {    \\n    \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        DisjointSet ds = new DisjointSet();\\n        \\n        for(int i = 0; i < s1.length(); i++) {\\n            \\n            int x = (int)(s1.charAt(i) - \\'a\\');\\n            int y = (int)(s2.charAt(i) - \\'a\\');\\n            \\n\\t\\t\\t// Making a union of all given equivalent charactrers\\n            ds.union(x, y);\\n            \\n        }\\n        \\n\\t\\t// Adding parent of each character from the Base String\\n\\t\\t// Parent = smallest equivalent character linked with it !!!\\n        StringBuilder ans = new StringBuilder(\"\");\\n        for(int i = 0; i < baseStr.length(); i++) {\\n            char c = (char)(\\'a\\' + ds.findPar((int)(baseStr.charAt(i) - \\'a\\')));\\n            ans.append(c);\\n        }\\n        \\n        return ans.toString();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047861,
                "title": "0ms-runtime-100-fastest-c",
                "content": "## C++ Solution\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int par[26];\\n    \\n    int find(int x){\\n        if(par[x]==-1) return x;\\n        return par[x]=find(par[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if (x != y) \\n            par[max(x, y)] = min(x, y); \\n    }\\n\\t\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        memset(par, -1, sizeof(par));\\n        \\n        for (auto i = 0; i < s1.size(); ++i) \\n            Union(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        \\n        for(auto i=0;i<baseStr.size();i++) \\n            baseStr[i]=find(baseStr[i]-\\'a\\')+\\'a\\';\\n\\n        return baseStr;\\n    }\\n};\\n```\\n\\n*Upvote if helped*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int par[26];\\n    \\n    int find(int x){\\n        if(par[x]==-1) return x;\\n        return par[x]=find(par[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if (x != y) \\n            par[max(x, y)] = min(x, y); \\n    }\\n\\t\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        memset(par, -1, sizeof(par));\\n        \\n        for (auto i = 0; i < s1.size(); ++i) \\n            Union(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        \\n        for(auto i=0;i<baseStr.size();i++) \\n            baseStr[i]=find(baseStr[i]-\\'a\\')+\\'a\\';\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047838,
                "title": "c-solution-dfs-easytounderstand",
                "content": "# Intuition\\nIn order to find the minimum character that can be replaced, we have to run dfs for each character in baseStr.\\n\\n# Approach\\nDepth first search\\n\\n<!--# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!--- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n## Don\\'t forget to upvote and give a like \\uD83D\\uDE43\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char need;\\n    void dfs(char x,map<char,vector<char>>& mp,char parent,map<char,int>& vischeck){\\n        vischeck[x] = 1;\\n        for(auto i : mp[x]){\\n            if(i!=parent and vischeck[i]!=1){\\n            need = min(need,i);\\n            dfs(i,mp,x,vischeck);\\n            }\\n        }\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        map<char,vector<char> > mp;\\n        for(int i=0;i<n;i++){\\n            mp[s1[i]].push_back(s2[i]);\\n            mp[s2[i]].push_back(s1[i]);\\n        }\\n        string ans;\\n        map<char,char> vis; //stores smallest character corresponding to a given character\\n        for(int i = 0;i<baseStr.size();i++){\\n            if(mp.find(baseStr[i])==mp.end()){\\n                ans+=baseStr[i];\\n            }\\n            else if(vis.find(baseStr[i])==vis.end()){\\n                need = baseStr[i]; // base condition\\n                map<char,int> vischeck; // stores the visited characters\\n                dfs(baseStr[i],mp,\\'0\\',vischeck); //dfs\\n                vis[baseStr[i]] = need; //storing the result\\n                ans+=need;\\n            }\\n            else{\\n                ans+=vis[baseStr[i]];\\n            }\\n            \\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```\\n\\n### I hope the solution is clear; use the comment section regarding any doubt.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char need;\\n    void dfs(char x,map<char,vector<char>>& mp,char parent,map<char,int>& vischeck){\\n        vischeck[x] = 1;\\n        for(auto i : mp[x]){\\n            if(i!=parent and vischeck[i]!=1){\\n            need = min(need,i);\\n            dfs(i,mp,x,vischeck);\\n            }\\n        }\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        map<char,vector<char> > mp;\\n        for(int i=0;i<n;i++){\\n            mp[s1[i]].push_back(s2[i]);\\n            mp[s2[i]].push_back(s1[i]);\\n        }\\n        string ans;\\n        map<char,char> vis; //stores smallest character corresponding to a given character\\n        for(int i = 0;i<baseStr.size();i++){\\n            if(mp.find(baseStr[i])==mp.end()){\\n                ans+=baseStr[i];\\n            }\\n            else if(vis.find(baseStr[i])==vis.end()){\\n                need = baseStr[i]; // base condition\\n                map<char,int> vischeck; // stores the visited characters\\n                dfs(baseStr[i],mp,\\'0\\',vischeck); //dfs\\n                vis[baseStr[i]] = need; //storing the result\\n                ans+=need;\\n            }\\n            else{\\n                ans+=vis[baseStr[i]];\\n            }\\n            \\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047808,
                "title": "easy-c-solution-beats-100-fully-explained",
                "content": "**Consider!\\uD83D\\uDC4D\\uD83D\\uDC4D**\\n```\\n                    # Please Upvote If You Find It Helpful.\\n```\\n# Approach\\nThe provided code is an implementation of a function \"smallestEquivalentString\" that takes three strings as input: s1, s2, and baseStr. The function first initializes an array \"temp\" of size 26 (to store the equivalent characters)\\n\\nThe function then iterates through the characters of s1 and s2, using a union-find algorithm to find the smallest equivalent characters for the corresponding characters in s1 and s2 and stores them in the \"temp\" array. The find function is used to find the representative element of the set to which the current element belongs and the union function is used to union the sets of two elements.\\n\\nThen, it iterates through the characters of baseStr and appends the smallest equivalent character for each character to the \"ans\" string, which is returned at the end.\\n\\nThe function starts by initializing the elements of the array \"temp\" to its index. For each i-th character of s1 and s2, the union function is called to merge the set containing s1[i] and the set containing s2[i].\\n\\nThen, for each character in the baseStr, the find function is used to find the representative element of the set containing the character, this representative element is added to the ans string.\\n\\nFinally, the ans string which contains the smallest equivalent string is returned.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int temp[26]; \\npublic:\\n    // Find function to find the representative element of the set containing the character\\n    int find(int ch){\\n        return ch == temp[ch] ? ch : temp[ch] = find(temp[ch]);\\n    }\\n    // Union function to merge the set containing x and the set containing y\\n    void unin(int x, int y){\\n        x = find(x);\\n        y = find(y);\\n        if(x < y)\\n            temp[y] = x;\\n        else\\n            temp[x] = y;\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        string ans;\\n        // Initialize all elements of temp array to its index\\n        for(int i=0;i<26;i++) temp[i] = i;\\n        // Iterate through s1 and s2 and union the sets containing the corresponding characters\\n        for(int i=0;i<s1.size();i++)\\n            unin(s1[i]-\\'a\\', s2[i]-\\'a\\');\\n        // Iterate through baseStr and find the representative element of the set containing each character\\n        // and append it to the ans string\\n        for(char it : baseStr)\\n            ans += (char)(find(it - \\'a\\') + \\'a\\');\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n```\\n                # Please Upvote If You Find It Helpful.\\n```\\nLet\\'s connect on [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Union Find",
                    "Recursion"
                ],
                "code": "```\\n                    # Please Upvote If You Find It Helpful.\\n```\n```\\nclass Solution {\\n    int temp[26]; \\npublic:\\n    // Find function to find the representative element of the set containing the character\\n    int find(int ch){\\n        return ch == temp[ch] ? ch : temp[ch] = find(temp[ch]);\\n    }\\n    // Union function to merge the set containing x and the set containing y\\n    void unin(int x, int y){\\n        x = find(x);\\n        y = find(y);\\n        if(x < y)\\n            temp[y] = x;\\n        else\\n            temp[x] = y;\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        string ans;\\n        // Initialize all elements of temp array to its index\\n        for(int i=0;i<26;i++) temp[i] = i;\\n        // Iterate through s1 and s2 and union the sets containing the corresponding characters\\n        for(int i=0;i<s1.size();i++)\\n            unin(s1[i]-\\'a\\', s2[i]-\\'a\\');\\n        // Iterate through baseStr and find the representative element of the set containing each character\\n        // and append it to the ans string\\n        for(char it : baseStr)\\n            ans += (char)(find(it - \\'a\\') + \\'a\\');\\n        return ans;\\n    }\\n};\\n\\n```\n```\\n                # Please Upvote If You Find It Helpful.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047715,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nTo solve this question you need to know DSU.Once you know how DSU works this question is a piece of cake.\\nIf you don\\'t know DSU you can think is as a black box which tells if the two elements are related and if related who is the ultimate parent of those two.\\nfindUPar(): returns the ultimate parent of that element.\\nunionBySize(): merge the both elements and updates the ultimate parent according to specified condition\\nUse the DSU Template and Try solving it.\\n```\\n```\\nclass DisjointSet {\\n    vector<int>  parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n\\t}\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(ulp_u < ulp_v) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_u] = ulp_v;\\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DisjointSet ds(26);\\n        for(int i=0;i<s1.size();i++){\\n            ds.unionBySize(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=(char)(ds.findUPar(baseStr[i]-\\'a\\')+\\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nTo solve this question you need to know DSU.Once you know how DSU works this question is a piece of cake.\\nIf you don\\'t know DSU you can think is as a black box which tells if the two elements are related and if related who is the ultimate parent of those two.\\nfindUPar(): returns the ultimate parent of that element.\\nunionBySize(): merge the both elements and updates the ultimate parent according to specified condition\\nUse the DSU Template and Try solving it.\\n```\n```\\nclass DisjointSet {\\n    vector<int>  parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n\\t}\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(ulp_u < ulp_v) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_u] = ulp_v;\\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DisjointSet ds(26);\\n        for(int i=0;i<s1.size();i++){\\n            ds.unionBySize(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=(char)(ds.findUPar(baseStr[i]-\\'a\\')+\\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047467,
                "title": "daily-leetcoding-challenge-january-day-14",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2933570,
                "title": "python3-simple-union-find-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n\\n    def __init__(self):\\n        self.root = list(range(26))\\n    \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        \\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x == root_y:\\n            return\\n        \\n        if root_x < root_y:\\n            self.root[root_y] = root_x\\n        else:\\n            self.root[root_x] = root_y\\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        uf = UnionFind()\\n        for i in range(len(s1)):\\n            i1, i2 = ord(s1[i]) - ord(\\'a\\'), ord(s2[i]) - ord(\\'a\\')\\n            uf.union(i1, i2)\\n        res = []\\n        for c in baseStr:\\n            i = ord(c) - ord(\\'a\\')\\n            new_char = chr(uf.find(i) + ord(\\'a\\'))\\n            res.append(new_char)\\n        \\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n\\n    def __init__(self):\\n        self.root = list(range(26))\\n    \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        \\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x == root_y:\\n            return\\n        \\n        if root_x < root_y:\\n            self.root[root_y] = root_x\\n        else:\\n            self.root[root_x] = root_y\\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        uf = UnionFind()\\n        for i in range(len(s1)):\\n            i1, i2 = ord(s1[i]) - ord(\\'a\\'), ord(s2[i]) - ord(\\'a\\')\\n            uf.union(i1, i2)\\n        res = []\\n        for c in baseStr:\\n            i = ord(c) - ord(\\'a\\')\\n            new_char = chr(uf.find(i) + ord(\\'a\\'))\\n            res.append(new_char)\\n        \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885237,
                "title": "java-union-find",
                "content": "```\\n class UnionFind{\\n        \\n        int[] p;\\n        int[] r ;\\n        UnionFind(){\\n            \\n            p = new int[26];\\n            r = new int[26];\\n            \\n            for(int i=0 ; i<26 ; i++){\\n                \\n                p[i] = i;\\n            }\\n        }\\n        \\n        int find(int a){\\n            \\n            while(a!=p[a]){\\n                \\n                a = p[a];\\n            }\\n            \\n            return a ;\\n        }\\n        \\n        void union(int a, int b){\\n            \\n            int rootA = find(a);\\n            int rootB = find(b);\\n            \\n            if(rootA==rootB) return ;\\n            \\n            if(rootA<rootB){\\n                \\n                p[rootB] = rootA ;\\n            }\\n            else{\\n                \\n                p[rootA] = rootB ;\\n            }\\n        }\\n    }\\n    \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        \\n        UnionFind uf = new UnionFind();\\n        \\n        StringBuilder sb  = new StringBuilder();\\n        \\n        for(int i=0 ; i<s1.length() ; i++){\\n            \\n            int f = s1.charAt(i)-\\'a\\';\\n            int s = s2.charAt(i)-\\'a\\';\\n            \\n            uf.union(f,s);\\n        }\\n        \\n        for(int i=0 ; i<baseStr.length() ; i++){\\n            \\n            int b  = uf.find(baseStr.charAt(i)-\\'a\\');\\n            \\n            sb.append((char)(b+\\'a\\'));\\n        }\\n        \\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\n class UnionFind{\\n        \\n        int[] p;\\n        int[] r ;\\n        UnionFind(){\\n            \\n            p = new int[26];\\n            r = new int[26];\\n            \\n            for(int i=0 ; i<26 ; i++){\\n                \\n                p[i] = i;\\n            }\\n        }\\n        \\n        int find(int a){\\n            \\n            while(a!=p[a]){\\n                \\n                a = p[a];\\n            }\\n            \\n            return a ;\\n        }\\n        \\n        void union(int a, int b){\\n            \\n            int rootA = find(a);\\n            int rootB = find(b);\\n            \\n            if(rootA==rootB) return ;\\n            \\n            if(rootA<rootB){\\n                \\n                p[rootB] = rootA ;\\n            }\\n            else{\\n                \\n                p[rootA] = rootB ;\\n            }\\n        }\\n    }\\n    \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        \\n        UnionFind uf = new UnionFind();\\n        \\n        StringBuilder sb  = new StringBuilder();\\n        \\n        for(int i=0 ; i<s1.length() ; i++){\\n            \\n            int f = s1.charAt(i)-\\'a\\';\\n            int s = s2.charAt(i)-\\'a\\';\\n            \\n            uf.union(f,s);\\n        }\\n        \\n        for(int i=0 ; i<baseStr.length() ; i++){\\n            \\n            int b  = uf.find(baseStr.charAt(i)-\\'a\\');\\n            \\n            sb.append((char)(b+\\'a\\'));\\n        }\\n        \\n        return sb.toString();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 973752,
                "title": "c-using-union-find",
                "content": "```\\nvector<int> parent(26);\\nint unionn(int node)\\n{   \\n    while(parent[node]!=node)               //finding parent or Lexicographically Smallest equivalent character\\n        node=parent[node];\\n    \\n    return node;  \\n}\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string A, string B, string S) {\\n\\n        for(int i=0;i<26;i++)                    //intialising\\n          parent[i]=i;                      \\n        \\n        for(int i=0;i<A.size();i++)\\n        {\\n            int x=unionn(A[i]-\\'a\\');\\n            int y=unionn(B[i]-\\'a\\');\\n            \\n            if(x!=y)\\n            {\\n                parent[max(x,y)]=min(x,y);            //making sure that parent is always Lexicographically Small\\n            }\\n        }\\n        \\n        string s;\\n        for(auto i:S)\\n            s.push_back(unionn(i-\\'a\\')+\\'a\\');            //pushing parent of every character of S\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> parent(26);\\nint unionn(int node)\\n{   \\n    while(parent[node]!=node)               //finding parent or Lexicographically Smallest equivalent character\\n        node=parent[node];\\n    \\n    return node;  \\n}\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string A, string B, string S) {\\n\\n        for(int i=0;i<26;i++)                    //intialising\\n          parent[i]=i;                      \\n        \\n        for(int i=0;i<A.size();i++)\\n        {\\n            int x=unionn(A[i]-\\'a\\');\\n            int y=unionn(B[i]-\\'a\\');\\n            \\n            if(x!=y)\\n            {\\n                parent[max(x,y)]=min(x,y);            //making sure that parent is always Lexicographically Small\\n            }\\n        }\\n        \\n        string s;\\n        for(auto i:S)\\n            s.push_back(unionn(i-\\'a\\')+\\'a\\');            //pushing parent of every character of S\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890674,
                "title": "runtime-o-n-memory-o-1-easy-solution-fully-explained",
                "content": "# Approach\\n\\n**Approach: Union-Find (Disjoint Set Union)**\\n\\n**Step 1: Initialize Parent Array**\\n- We\\'ll create an array called `parent` of size 26 (one for each lowercase English letter).\\n- We\\'ll initialize each character to be its own parent initially.\\n\\n**Step 2: Establish Equivalency Relationships**\\n- For each character at the same position in `s1` and `s2`, we\\'ll find their respective parents using the `findParent` function.\\n- If the parent of `s1[i]` is lexicographically smaller than the parent of `s2[i]`, we\\'ll set the parent of `s2[i]` to be the parent of `s1[i]`. Otherwise, we\\'ll set the parent of `s1[i]` to be the parent of `s2[i]`.\\n- This step groups equivalent characters under the same parent.\\n\\n**Step 3: Transform Base String**\\n- For each character in the `baseStr`, we\\'ll find its parent using the `findParent` function and append the corresponding transformed character to a `result` StringBuilder.\\n- This transformation ensures that characters in the `baseStr` are changed to their lexicographically smallest equivalents based on the established equivalency relationships.\\n\\n**Step 4: Return Result**\\n- Convert the `result` StringBuilder to a String and return it as the final lexicographically smallest equivalent string.\\n\\n**Logic:**\\n- We\\'re given two strings `s1` and `s2` that define equivalency relationships between characters. Using this information, we create groups of equivalent characters using Union-Find.\\n- By associating characters with their parent in the `parent` array, we\\'re able to efficiently find the smallest equivalent character in each group.\\n- Finally, we transform the characters in the `baseStr` using the established relationships, ensuring that we get the lexicographically smallest equivalent string.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int[] parent = new int[26];\\n\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        for (int i = 0; i < 26; i++) {\\n            parent[i] = i;\\n        }\\n\\n        for (int i = 0; i < s1.length(); i++) {\\n            int parentS1 = findParent(s1.charAt(i) - \\'a\\');\\n            int parentS2 = findParent(s2.charAt(i) - \\'a\\');\\n            if (parentS1 < parentS2) {\\n                parent[parentS2] = parentS1;\\n            } else {\\n                parent[parentS1] = parentS2;\\n            }\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n        for (char c : baseStr.toCharArray()) {\\n            int parentC = findParent(c - \\'a\\');\\n            result.append((char) (parentC + \\'a\\'));\\n        }\\n\\n        return result.toString();\\n    }\\n\\n    private int findParent(int c) {\\n        if (parent[c] == c) return c;\\n        return parent[c] = findParent(parent[c]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent = new int[26];\\n\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        for (int i = 0; i < 26; i++) {\\n            parent[i] = i;\\n        }\\n\\n        for (int i = 0; i < s1.length(); i++) {\\n            int parentS1 = findParent(s1.charAt(i) - \\'a\\');\\n            int parentS2 = findParent(s2.charAt(i) - \\'a\\');\\n            if (parentS1 < parentS2) {\\n                parent[parentS2] = parentS1;\\n            } else {\\n                parent[parentS1] = parentS2;\\n            }\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n        for (char c : baseStr.toCharArray()) {\\n            int parentC = findParent(c - \\'a\\');\\n            result.append((char) (parentC + \\'a\\'));\\n        }\\n\\n        return result.toString();\\n    }\\n\\n    private int findParent(int c) {\\n        if (parent[c] == c) return c;\\n        return parent[c] = findParent(parent[c]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052140,
                "title": "o-1-space-and-o-n-time-solution-using-graph-in-python",
                "content": "# Intuition\\nThink a graph with 26 nodes of alphabets.\\n\\n# Approach\\n1>Think that s1[i],s2[i] represents the edge between two nodes.\\n2>construct a graph using these edges.\\n3>In a connected component , smallest alphabet will asign to all.\\n4>it can be done by asigning component number to each alphabet and smallest alphabet can be stored in corresponding to each component number via hashmap.\\n# Complexity\\n- Time complexity:\\no(len(s1)+len(baseStr))\\n\\n- Space complexity:\\no(1)(space of all hashmaps can be assumed as constant as size is only 26,assuming space for returning string will be require ,as string are immutable in python.)\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        d={}\\n        v={}\\n        for i in range(26):\\n            d[chr(i+97)]=[chr(i+97)]\\n            v[chr(i+97)]=0\\n        for i in range(len(s1)):\\n            d[s1[i]].append(s2[i])\\n            d[s2[i]].append(s1[i])\\n        c=1\\n        ans={}\\n        for x in v:\\n            if v[x]==0:\\n                t=deque(x)\\n                temp=x\\n                while t:\\n                    te=t.popleft()\\n                    temp=min(temp,te)\\n                    for i in range(len(d[te])):\\n                        if v[d[te][i]]==0:\\n                            v[d[te][i]]=c \\n                            t.append(d[te][i])\\n                ans[c]=temp\\n                c+=1\\n        s=\"\"\\n        for i in range(len(baseStr)):\\n            s+=ans[v[baseStr[i]]]\\n        return s\\n\\n                \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        d={}\\n        v={}\\n        for i in range(26):\\n            d[chr(i+97)]=[chr(i+97)]\\n            v[chr(i+97)]=0\\n        for i in range(len(s1)):\\n            d[s1[i]].append(s2[i])\\n            d[s2[i]].append(s1[i])\\n        c=1\\n        ans={}\\n        for x in v:\\n            if v[x]==0:\\n                t=deque(x)\\n                temp=x\\n                while t:\\n                    te=t.popleft()\\n                    temp=min(temp,te)\\n                    for i in range(len(d[te])):\\n                        if v[d[te][i]]==0:\\n                            v[d[te][i]]=c \\n                            t.append(d[te][i])\\n                ans[c]=temp\\n                c+=1\\n        s=\"\"\\n        for i in range(len(baseStr)):\\n            s+=ans[v[baseStr[i]]]\\n        return s\\n\\n                \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052039,
                "title": "java-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int m = s1.length();\\n        int n = baseStr.length();\\n        \\n        ArrayList<Character>[] graph = new ArrayList[26];\\n        \\n        for (int i = 0 ; i < 26 ; i++) {\\n            graph[i] = new ArrayList<Character>();\\n        }\\n        \\n        for (int i = 0 ; i < m ; i++) {\\n            char u = s1.charAt(i);\\n            char v = s2.charAt(i);\\n            \\n            graph[u - \\'a\\'].add(v);\\n            graph[v - \\'a\\'].add(u);\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        \\n        for (int i = 0 ; i < n ; i++) {\\n            char currentBaseStrCharacter = baseStr.charAt(i);\\n            \\n            boolean[] visited = new boolean[26];\\n            \\n            char ch = DFS(graph, visited, currentBaseStrCharacter);\\n           \\n            result.append(ch);\\n        }\\n        \\n        return result.toString();\\n    }\\n    \\n    public char DFS(ArrayList<Character>[] graph, boolean[] visited, char currentCharacter) {\\n        visited[currentCharacter - \\'a\\'] = true;\\n        \\n        char curr_ch = currentCharacter;\\n        \\n        for (char v : graph[currentCharacter - \\'a\\']) {\\n            if (!visited[v - \\'a\\']) {\\n                char min = DFS(graph, visited, v);\\n                \\n                if (min < curr_ch) {\\n                    curr_ch = min;\\n                }\\n                \\n            }    \\n        }\\n        \\n        return curr_ch;\\n    }\\n    \\n}\\n```\\nUpvote if you like it![image](https://assets.leetcode.com/users/images/94c985bf-b250-41a3-80a8-98aa250e057a_1673733698.996035.png)\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int m = s1.length();\\n        int n = baseStr.length();\\n        \\n        ArrayList<Character>[] graph = new ArrayList[26];\\n        \\n        for (int i = 0 ; i < 26 ; i++) {\\n            graph[i] = new ArrayList<Character>();\\n        }\\n        \\n        for (int i = 0 ; i < m ; i++) {\\n            char u = s1.charAt(i);\\n            char v = s2.charAt(i);\\n            \\n            graph[u - \\'a\\'].add(v);\\n            graph[v - \\'a\\'].add(u);\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        \\n        for (int i = 0 ; i < n ; i++) {\\n            char currentBaseStrCharacter = baseStr.charAt(i);\\n            \\n            boolean[] visited = new boolean[26];\\n            \\n            char ch = DFS(graph, visited, currentBaseStrCharacter);\\n           \\n            result.append(ch);\\n        }\\n        \\n        return result.toString();\\n    }\\n    \\n    public char DFS(ArrayList<Character>[] graph, boolean[] visited, char currentCharacter) {\\n        visited[currentCharacter - \\'a\\'] = true;\\n        \\n        char curr_ch = currentCharacter;\\n        \\n        for (char v : graph[currentCharacter - \\'a\\']) {\\n            if (!visited[v - \\'a\\']) {\\n                char min = DFS(graph, visited, v);\\n                \\n                if (min < curr_ch) {\\n                    curr_ch = min;\\n                }\\n                \\n            }    \\n        }\\n        \\n        return curr_ch;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051767,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\n    int[] parent, size;\\n    public DisjointSet(int n) {\\n        parent = new int[n+1];\\n        size = new int[n+1]; \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n    int findPar(int node){\\n        if(node==parent[node]) return node;\\n        return parent[node] =findPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v) {\\n        int up = findPar(u); \\n        int uv = findPar(v); \\n        if(up == uv) return; \\n        if(up < uv) {\\n            parent[uv] = up; \\n        }\\n        else {\\n            parent[up] = uv;\\n        }\\n    }\\n}\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n = s1.length();\\n        DisjointSet ds = new DisjointSet(26);\\n        for(int i=0;i<n;i++){\\n            ds.unionBySize(s1.charAt(i)-\\'a\\',s2.charAt(i)-\\'a\\');\\n        }\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0;i<baseStr.length();i++){\\n            res.append((char)(ds.findPar(baseStr.charAt(i)-\\'a\\')+\\'a\\'));\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DisjointSet{\\n    int[] parent, size;\\n    public DisjointSet(int n) {\\n        parent = new int[n+1];\\n        size = new int[n+1]; \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n    int findPar(int node){\\n        if(node==parent[node]) return node;\\n        return parent[node] =findPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v) {\\n        int up = findPar(u); \\n        int uv = findPar(v); \\n        if(up == uv) return; \\n        if(up < uv) {\\n            parent[uv] = up; \\n        }\\n        else {\\n            parent[up] = uv;\\n        }\\n    }\\n}\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n = s1.length();\\n        DisjointSet ds = new DisjointSet(26);\\n        for(int i=0;i<n;i++){\\n            ds.unionBySize(s1.charAt(i)-\\'a\\',s2.charAt(i)-\\'a\\');\\n        }\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0;i<baseStr.length();i++){\\n            res.append((char)(ds.findPar(baseStr.charAt(i)-\\'a\\')+\\'a\\'));\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051154,
                "title": "c-unionfind-clean-explained-beats-100",
                "content": "# Intuition\\nGoal is to replace baseStr\\'s characters with the smallest character of set. Set is built by rules in problem description.\\nSets are merging as we go through strings.\\nFinding unions from sets is known to be done with UnionFind algorithm.\\n\\n# Approach\\nIf different characters - Union them.\\nWhile at it, make the root of Union the smallest value (it is the min of existing set, so have to compare to another minimum (root) in Union).\\nIn the end get each character\\'s set root and build result.\\n\\n# Complexity\\n- Time complexity:\\nO(n + m) - going through s1, s2 (length n) + baseStr (length m)\\n Finding root is always less then 26 hops = constant.\\n\\n- Space complexity:\\nO(m) - building modified baseStr.\\nBesides that UnionFind structure uses constant space from 26 english characters.\\n\\n# Code\\n```\\npublic class Solution {\\n    private static readonly IReadOnlyList<char> EnglishLetters = Enumerable\\n        .Range(0, 26)\\n        .Select(code => Convert.ToChar(code + \\'a\\'))\\n        .ToList();\\n    \\n    public string SmallestEquivalentString(string s1, string s2, string baseStr)\\n    {\\n        var uf = new UnionFind();\\n        \\n        for (int i = 0; i < s1.Length; i++)\\n        {\\n            uf.Union(s1[i], s2[i]);\\n        }\\n\\n        var minimums = EnglishLetters\\n            .ToDictionary(c => c, uf.Find);\\n        var res = new StringBuilder();\\n        \\n        foreach (var c in baseStr)\\n        {\\n            res.Append(minimums[c]);\\n        }\\n\\n        return res.ToString();\\n    }\\n    \\n    public class UnionFind\\n    {\\n        public readonly Dictionary<char, char> parent =\\n            EnglishLetters.ToDictionary(c => c, c => c);\\n\\n        public char Find(char a)\\n        {\\n            if (a == parent[a])\\n            {\\n                return a;\\n            }\\n\\n            // optimize the path\\n            return parent[a] = Find(parent[a]);\\n        }\\n\\n        public void Union(char a, char b)\\n        {\\n            a = Find(a);\\n            b = Find(b);\\n\\n            if (a == b) return;\\n            \\n            if (a < b)\\n            {\\n                parent[b] = a;\\n            }\\n            else\\n            {\\n                parent[a] = b;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    private static readonly IReadOnlyList<char> EnglishLetters = Enumerable\\n        .Range(0, 26)\\n        .Select(code => Convert.ToChar(code + \\'a\\'))\\n        .ToList();\\n    \\n    public string SmallestEquivalentString(string s1, string s2, string baseStr)\\n    {\\n        var uf = new UnionFind();\\n        \\n        for (int i = 0; i < s1.Length; i++)\\n        {\\n            uf.Union(s1[i], s2[i]);\\n        }\\n\\n        var minimums = EnglishLetters\\n            .ToDictionary(c => c, uf.Find);\\n        var res = new StringBuilder();\\n        \\n        foreach (var c in baseStr)\\n        {\\n            res.Append(minimums[c]);\\n        }\\n\\n        return res.ToString();\\n    }\\n    \\n    public class UnionFind\\n    {\\n        public readonly Dictionary<char, char> parent =\\n            EnglishLetters.ToDictionary(c => c, c => c);\\n\\n        public char Find(char a)\\n        {\\n            if (a == parent[a])\\n            {\\n                return a;\\n            }\\n\\n            // optimize the path\\n            return parent[a] = Find(parent[a]);\\n        }\\n\\n        public void Union(char a, char b)\\n        {\\n            a = Find(a);\\n            b = Find(b);\\n\\n            if (a == b) return;\\n            \\n            if (a < b)\\n            {\\n                parent[b] = a;\\n            }\\n            else\\n            {\\n                parent[a] = b;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051037,
                "title": "simple-intuitive-solution-c-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void refineMap(map<char, set<char>> &mp, int times) {\\n        while(times--) {\\n            for(auto [k, v]: mp)\\n                for(char i: v) mp[k].insert(*mp[i].begin());\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char, set<char>> mp;\\n        int n = s1.size(); string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n            mp[s1[i]].insert(s2[i]);\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(mp.find(s1[i]) != mp.end())\\n                for(char x: mp[s1[i]])\\n                    mp[s2[i]].insert(x);\\n            mp[s2[i]].insert(s1[i]);\\n        } refineMap(mp, 2);\\n\\n        for(char i: baseStr) {\\n            if(mp.find(i) != mp.end()) res += *mp[i].begin();\\n            else res += i;\\n        } return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void refineMap(map<char, set<char>> &mp, int times) {\\n        while(times--) {\\n            for(auto [k, v]: mp)\\n                for(char i: v) mp[k].insert(*mp[i].begin());\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char, set<char>> mp;\\n        int n = s1.size(); string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n            mp[s1[i]].insert(s2[i]);\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(mp.find(s1[i]) != mp.end())\\n                for(char x: mp[s1[i]])\\n                    mp[s2[i]].insert(x);\\n            mp[s2[i]].insert(s1[i]);\\n        } refineMap(mp, 2);\\n\\n        for(char i: baseStr) {\\n            if(mp.find(i) != mp.end()) res += *mp[i].begin();\\n            else res += i;\\n        } return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050975,
                "title": "c-beats-100-explained-using-disjoint-set-union",
                "content": "# Intuition\\nWe can just apply DisjointSet Union.\\n\\n    Runtime - 100%\\uD83D\\uDD25 \\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int> size, parent, rank;\\n    DisjointSet(int n){\\n        rank.resize(n+1, 0);\\n        size.resize(n+1, 0);\\n        parent.resize(n+1);\\n        for(int i=0; i<=n; i++){\\n            parent[i] = i;\\n        }\\n    }\\n    int findUPar(int node){\\n        if(node == parent[node]){\\n            return node;\\n        }\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void UnionByRank(int u, int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v){\\n            return;\\n        }\\n        if(rank[ulp_u]<rank[ulp_v]){\\n            parent[u] = ulp_v;\\n        }\\n        else if(rank[ulp_u]>rank[ulp_v]){\\n            parent[v] = ulp_u;\\n        }\\n        else{\\n            parent[v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n    void UnionBySize(int u, int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v){\\n            return;\\n        }\\n        if(ulp_u>ulp_v){\\n            parent[ulp_u] = parent[ulp_v];\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = parent[ulp_u];\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int V = s1.length();\\n        DisjointSet ds(26);\\n        for(int i=0; i<V; i++){\\n            int u = s1[i]-\\'a\\';\\n            int v = s2[i]-\\'a\\';\\n            ds.UnionBySize(u,v);\\n        }\\n        string ans;\\n        int n = baseStr.length();\\n        for(int i=0; i<n; i++){\\n            ans+=(char)(ds.findUPar(baseStr[i]-\\'a\\') + \\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet{\\npublic:\\n    vector<int> size, parent, rank;\\n    DisjointSet(int n){\\n        rank.resize(n+1, 0);\\n        size.resize(n+1, 0);\\n        parent.resize(n+1);\\n        for(int i=0; i<=n; i++){\\n            parent[i] = i;\\n        }\\n    }\\n    int findUPar(int node){\\n        if(node == parent[node]){\\n            return node;\\n        }\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void UnionByRank(int u, int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v){\\n            return;\\n        }\\n        if(rank[ulp_u]<rank[ulp_v]){\\n            parent[u] = ulp_v;\\n        }\\n        else if(rank[ulp_u]>rank[ulp_v]){\\n            parent[v] = ulp_u;\\n        }\\n        else{\\n            parent[v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n    void UnionBySize(int u, int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v){\\n            return;\\n        }\\n        if(ulp_u>ulp_v){\\n            parent[ulp_u] = parent[ulp_v];\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = parent[ulp_u];\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int V = s1.length();\\n        DisjointSet ds(26);\\n        for(int i=0; i<V; i++){\\n            int u = s1[i]-\\'a\\';\\n            int v = s2[i]-\\'a\\';\\n            ds.UnionBySize(u,v);\\n        }\\n        string ans;\\n        int n = baseStr.length();\\n        for(int i=0; i<n; i++){\\n            ans+=(char)(ds.findUPar(baseStr[i]-\\'a\\') + \\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050867,
                "title": "using-dfs-without-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:m*(E+V):\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char DfsFindMinChar(unordered_map<char,vector<char>> &adj, char curr_char,vector<int>&vis){\\n        vis[curr_char-\\'a\\']=1;\\n        char miniChar = curr_char;\\n\\n        for(auto &v: adj[curr_char]){\\n            if(!vis[v-\\'a\\']){\\n                miniChar=min(miniChar,DfsFindMinChar(adj,v,vis));\\n            }\\n        }\\n        return miniChar;\\n\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        int m=baseStr.size();\\n        unordered_map<char,vector<char>> adj;\\n\\n        for(int i=0; i<n; i++){\\n            char u = s1[i];\\n            char v = s2[i];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        string result;\\n        \\n        for(int i=0; i<m; i++){\\n            char ch = baseStr[i];\\n            vector<int> vis(26,0);\\n            char minChar=DfsFindMinChar(adj,ch,vis);\\n\\n            result.push_back(minChar);\\n        }\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char DfsFindMinChar(unordered_map<char,vector<char>> &adj, char curr_char,vector<int>&vis){\\n        vis[curr_char-\\'a\\']=1;\\n        char miniChar = curr_char;\\n\\n        for(auto &v: adj[curr_char]){\\n            if(!vis[v-\\'a\\']){\\n                miniChar=min(miniChar,DfsFindMinChar(adj,v,vis));\\n            }\\n        }\\n        return miniChar;\\n\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        int m=baseStr.size();\\n        unordered_map<char,vector<char>> adj;\\n\\n        for(int i=0; i<n; i++){\\n            char u = s1[i];\\n            char v = s2[i];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        string result;\\n        \\n        for(int i=0; i<m; i++){\\n            char ch = baseStr[i];\\n            vector<int> vis(26,0);\\n            char minChar=DfsFindMinChar(adj,ch,vis);\\n\\n            result.push_back(minChar);\\n        }\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050835,
                "title": "c-easy-solution-using-dsu-disjoint-set-union",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every character c in baseStr we need to find minimum equivalent valued character. As relation is equivalence ie. Reflexive, Symmetric and Transitive there can be multiple characters related to a single character in baseStr. Thus to maintain this Ive used Disjoint Set Union(Disjoint Set Union).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo incase you dont know DSU let me brief up a little.\\n- It has a parent array to store parent of a node.\\n- Then there are two functions :\\n  - findSet(int node ) to find parent of a node.\\n  - Union(int node1,int node2) to connect to node and update parent of the nodes. \\n\\n#### Furthermore, the code I used is only lil bit different from Standard DSU code. It is obvious we need to find minimum equivalent character, so parent of the nodes must be chosen as the minimum character.\\n ***Parent here stores the minimum equivalent character**\\n# **Steps:**\\n- For simplicity Ive used map to store parent of character based on given strings s1 and s2.\\n- Initiallly parent of character is itself.\\n- Now we just need to union the characters of s1 and s2 while comparing which of these has minimum equivalent character and then updating the parent of both.\\n- Lastly we can use find_set() to find minimum equivalent character for each cahracter of baseStr.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) because of map being used\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) \\n# Code\\n```\\nclass Solution {\\npublic:\\n    char find_set(char c,map<char,char>& parent)\\n    {\\n        if(parent[c]==c) return c;\\n        else \\n        {\\n            return parent[c]=find_set(parent[c],parent);\\n        }\\n    }\\n\\n    void union_set(map<char,char>& parent,char c1,char c2){\\n        int p1=find_set(c1,parent);\\n        int p2=find_set(c2,parent);\\n\\n        if(p1<p2)\\n        {\\n            parent[p2]=p1;\\n        }\\n\\n        else{\\n            parent[p1]=p2;\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char,char> parent;\\n        for(int i=0;i<26;i++)\\n        {\\n            parent[char(i+\\'a\\')]= char(i+\\'a\\');\\n        }\\n\\n        int n=s1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            union_set(parent,s1[i],s2[i]);\\n        }\\n\\n        int l=baseStr.size();\\n        string req=\"\";\\n        for(int i=0;i<l;i++)\\n        {\\n            req+=find_set(baseStr[i],parent);\\n        }\\n\\n        return req;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char find_set(char c,map<char,char>& parent)\\n    {\\n        if(parent[c]==c) return c;\\n        else \\n        {\\n            return parent[c]=find_set(parent[c],parent);\\n        }\\n    }\\n\\n    void union_set(map<char,char>& parent,char c1,char c2){\\n        int p1=find_set(c1,parent);\\n        int p2=find_set(c2,parent);\\n\\n        if(p1<p2)\\n        {\\n            parent[p2]=p1;\\n        }\\n\\n        else{\\n            parent[p1]=p2;\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char,char> parent;\\n        for(int i=0;i<26;i++)\\n        {\\n            parent[char(i+\\'a\\')]= char(i+\\'a\\');\\n        }\\n\\n        int n=s1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            union_set(parent,s1[i],s2[i]);\\n        }\\n\\n        int l=baseStr.size();\\n        string req=\"\";\\n        for(int i=0;i<l;i++)\\n        {\\n            req+=find_set(baseStr[i],parent);\\n        }\\n\\n        return req;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050706,
                "title": "easy-python-comment",
                "content": "# Python\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        val = string.ascii_lowercase\\n        d = {x: x for x in val}\\n\\n# Look up umtil we get d[x] == x, which is the lowest character lexi.\\n        def find(x):\\n            if d[x] == x: \\n                return x\\n            return find(d[x])\\n\\n        for a,b in zip(s1,s2):\\n            l1, l2 = find(a),find(b)\\n\\n            if l1 > l2: \\n                d[l1] = l2\\n            else: \\n                d[l2] = l1\\n\\n        return \"\".join([find(d[i]) for i in baseStr])\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        val = string.ascii_lowercase\\n        d = {x: x for x in val}\\n\\n# Look up umtil we get d[x] == x, which is the lowest character lexi.\\n        def find(x):\\n            if d[x] == x: \\n                return x\\n            return find(d[x])\\n\\n        for a,b in zip(s1,s2):\\n            l1, l2 = find(a),find(b)\\n\\n            if l1 > l2: \\n                d[l1] = l2\\n            else: \\n                d[l2] = l1\\n\\n        return \"\".join([find(d[i]) for i in baseStr])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050206,
                "title": "dsu-explained",
                "content": "# Please Upvote if you like the solution \\u2B06\\uFE0F\\n\\n# Code\\n```\\nclass DisjointSet:\\n    def __init__(self):\\n        self.parent = {}\\n        # intitial every one if parent of themselves\\n        # making self as parent initial\\n        for letter in string.ascii_lowercase:\\n            self.parent[letter] = letter\\n    \\n    def findParent(self,node):\\n            while  node!= self.parent[node]:\\n                node = self.parent[node]\\n\\n            return node\\n        \\n    def doUnion(self, a,b):\\n        # find ultimate parent of a and b\\n        ulp_a = self.findParent(a)\\n        ulp_b = self.findParent(b)\\n    \\n        # assign minimum as ultimate parent of both a and b\\n        self.parent[ulp_a] = self.parent[ulp_b] = min(ulp_a, ulp_b)\\n    \\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        ds = DisjointSet()\\n        for i in range(len(s1)):\\n            ds.doUnion(s1[i], s2[i])\\n\\n        ans = \"\"\\n        for c in baseStr:\\n            ans += ds.parent[ds.findParent(c)]\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet:\\n    def __init__(self):\\n        self.parent = {}\\n        # intitial every one if parent of themselves\\n        # making self as parent initial\\n        for letter in string.ascii_lowercase:\\n            self.parent[letter] = letter\\n    \\n    def findParent(self,node):\\n            while  node!= self.parent[node]:\\n                node = self.parent[node]\\n\\n            return node\\n        \\n    def doUnion(self, a,b):\\n        # find ultimate parent of a and b\\n        ulp_a = self.findParent(a)\\n        ulp_b = self.findParent(b)\\n    \\n        # assign minimum as ultimate parent of both a and b\\n        self.parent[ulp_a] = self.parent[ulp_b] = min(ulp_a, ulp_b)\\n    \\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        ds = DisjointSet()\\n        for i in range(len(s1)):\\n            ds.doUnion(s1[i], s2[i])\\n\\n        ans = \"\"\\n        for c in baseStr:\\n            ans += ds.parent[ds.findParent(c)]\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049873,
                "title": "go-python-o-max-n-m-time-o-max-n-m-space",
                "content": "# Complexity\\n- Time complexity: $$O(max(n,m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(max(n,m))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc smallestEquivalentString(s1 string, s2 string, baseStr string) string {\\n    graph := make(map[rune]map[rune]bool)\\n    for i,_ := range(s1){\\n        p := rune(s1[i])\\n        q := rune(s2[i])\\n        if _,ok := graph[p]; !ok{\\n            graph[p] = make(map[rune]bool)\\n        }\\n        if _,ok := graph[q]; !ok{\\n            graph[q] = make(map[rune]bool)\\n        }\\n        graph[p][q] = true\\n        graph[q][p] = true\\n    }\\n    \\n    answer := []rune{}\\n    for _,char := range(baseStr){\\n        visited := make(map[rune]bool)\\n        answer = append(answer,dfs(char, graph, visited))\\n    }\\n    return string(answer)\\n}\\n\\nfunc dfs(node rune, graph map[rune]map[rune]bool, visited map[rune]bool) rune{\\n    if _,ok := visited[node]; ok{\\n        return node\\n    }\\n        \\n    visited[node] = true\\n    letter := node\\n    \\n    for n,_ := range(graph[node]){\\n        letter = min(letter, dfs(n, graph, visited))\\n    }\\n    return letter\\n}\\n\\nfunc min(a,b rune) rune{\\n    if a < b{\\n        return a\\n    }\\n    return b\\n}\\n```\\n```python []\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        graph = defaultdict(set)\\n        for p, q in zip(s1, s2):\\n            graph[p].add(q)\\n            graph[q].add(p)\\n        \\n        answer = []\\n        for char in baseStr:\\n            visited = set()\\n            answer.append(dfs(char, graph, visited))\\n        return \"\".join(answer)\\n\\ndef dfs(node, graph, visited):\\n    if node in visited:\\n        return node\\n        \\n    visited.add(node)\\n    letter = node\\n    \\n    for n in graph[node]:\\n        letter = min(letter, dfs(n, graph, visited))\\n    return letter\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Hash Table",
                    "String",
                    "Depth-First Search"
                ],
                "code": "```golang []\\nfunc smallestEquivalentString(s1 string, s2 string, baseStr string) string {\\n    graph := make(map[rune]map[rune]bool)\\n    for i,_ := range(s1){\\n        p := rune(s1[i])\\n        q := rune(s2[i])\\n        if _,ok := graph[p]; !ok{\\n            graph[p] = make(map[rune]bool)\\n        }\\n        if _,ok := graph[q]; !ok{\\n            graph[q] = make(map[rune]bool)\\n        }\\n        graph[p][q] = true\\n        graph[q][p] = true\\n    }\\n    \\n    answer := []rune{}\\n    for _,char := range(baseStr){\\n        visited := make(map[rune]bool)\\n        answer = append(answer,dfs(char, graph, visited))\\n    }\\n    return string(answer)\\n}\\n\\nfunc dfs(node rune, graph map[rune]map[rune]bool, visited map[rune]bool) rune{\\n    if _,ok := visited[node]; ok{\\n        return node\\n    }\\n        \\n    visited[node] = true\\n    letter := node\\n    \\n    for n,_ := range(graph[node]){\\n        letter = min(letter, dfs(n, graph, visited))\\n    }\\n    return letter\\n}\\n\\nfunc min(a,b rune) rune{\\n    if a < b{\\n        return a\\n    }\\n    return b\\n}\\n```\n```python []\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        graph = defaultdict(set)\\n        for p, q in zip(s1, s2):\\n            graph[p].add(q)\\n            graph[q].add(p)\\n        \\n        answer = []\\n        for char in baseStr:\\n            visited = set()\\n            answer.append(dfs(char, graph, visited))\\n        return \"\".join(answer)\\n\\ndef dfs(node, graph, visited):\\n    if node in visited:\\n        return node\\n        \\n    visited.add(node)\\n    letter = node\\n    \\n    for n in graph[node]:\\n        letter = min(letter, dfs(n, graph, visited))\\n    return letter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049709,
                "title": "c-solution-with-dictionary-char-list-char",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n```\\npublic class Solution {\\n    public string SmallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        var map = new Map(s1, s2);\\n        var output = map.Convert(baseStr);\\n        return output;\\n\\n    }\\n}\\n\\npublic class Map {\\n\\n    private readonly Dictionary<char, List<char>> _map = new();\\n\\n    public Map(string s1, string s2) {\\n\\n        for(int i = \\'a\\'; i <= \\'z\\'; i++) {\\n            _map[(char)i] = new() { (char)i };\\n        }\\n\\n        for(int i = 0; i < s1.Length; i++) {\\n            Merge(s1[i], s2[i]);\\n        }\\n\\n    }\\n\\n    public string Convert(string baseStr) {\\n\\n        var sb = new StringBuilder(baseStr.Length);\\n\\n        for(int i = 0; i < baseStr.Length; i++) {\\n            var curr = GetSmaller(baseStr[i]);\\n            sb.Append(curr);\\n        }\\n\\n        return sb.ToString();\\n\\n    }\\n\\n    private char GetSmaller(char value) {\\n        return _map[value].Min();\\n    }\\n\\n    private void Merge(char one, char two) {\\n\\n        if(one == two) {\\n            return;\\n        }\\n\\n        var oneList = _map[one];\\n        var twoList = _map[two];\\n\\n        var newList = oneList.Concat(twoList).Distinct().ToList();\\n\\n        foreach(var element in newList) {\\n            _map[element] = newList;\\n        }\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string SmallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        var map = new Map(s1, s2);\\n        var output = map.Convert(baseStr);\\n        return output;\\n\\n    }\\n}\\n\\npublic class Map {\\n\\n    private readonly Dictionary<char, List<char>> _map = new();\\n\\n    public Map(string s1, string s2) {\\n\\n        for(int i = \\'a\\'; i <= \\'z\\'; i++) {\\n            _map[(char)i] = new() { (char)i };\\n        }\\n\\n        for(int i = 0; i < s1.Length; i++) {\\n            Merge(s1[i], s2[i]);\\n        }\\n\\n    }\\n\\n    public string Convert(string baseStr) {\\n\\n        var sb = new StringBuilder(baseStr.Length);\\n\\n        for(int i = 0; i < baseStr.Length; i++) {\\n            var curr = GetSmaller(baseStr[i]);\\n            sb.Append(curr);\\n        }\\n\\n        return sb.ToString();\\n\\n    }\\n\\n    private char GetSmaller(char value) {\\n        return _map[value].Min();\\n    }\\n\\n    private void Merge(char one, char two) {\\n\\n        if(one == two) {\\n            return;\\n        }\\n\\n        var oneList = _map[one];\\n        var twoList = _map[two];\\n\\n        var newList = oneList.Concat(twoList).Distinct().ToList();\\n\\n        foreach(var element in newList) {\\n            _map[element] = newList;\\n        }\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049620,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Disjoint Set Union (DSU)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int par[26];\\n    int find_rep(int u) {\\n        if(par[u] == -1) return u;\\n        return par[u]= find_rep(par[u]);\\n    }\\n    void make_union(int u, int v) {\\n        u = find_rep(u);\\n        v = find_rep(v);\\n        if(u!=v) par[max(u, v)] = min(u, v); \\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        memset(par, -1, sizeof(par));\\n        for(int i=0; i<s1.size(); i++) make_union(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        int n = baseStr.size();\\n        string ans(n, \\'.\\');\\n        for(int i=0; i<n; i++) ans[i] = find_rep(baseStr[i] - \\'a\\') + \\'a\\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int par[26];\\n    int find_rep(int u) {\\n        if(par[u] == -1) return u;\\n        return par[u]= find_rep(par[u]);\\n    }\\n    void make_union(int u, int v) {\\n        u = find_rep(u);\\n        v = find_rep(v);\\n        if(u!=v) par[max(u, v)] = min(u, v); \\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        memset(par, -1, sizeof(par));\\n        for(int i=0; i<s1.size(); i++) make_union(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        int n = baseStr.size();\\n        string ans(n, \\'.\\');\\n        for(int i=0; i<n; i++) ans[i] = find_rep(baseStr[i] - \\'a\\') + \\'a\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049391,
                "title": "java-easy-bfs-solution-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create a undirected graph where the equivelancy are the edge ie; (\\'a\\'==\\'c\\') means there is an edge from a to c.\\n(The graph here is not a connected graph so we have to do BFS search node by node.)\\nWe then do a BFS search on the graph node by node and find the smallest character and save it as equivelant for all the characters that were involved on the search.\\nwe convert each character in the baseStr with the equivelant character.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        char[] l = new char[26];\\n        for(char i=0;i<l.length;i++)\\n        {\\n          \\n          char c =(char)(\\'a\\'+i);\\n          l[i]=c;\\n\\n        }\\n        HashMap<Character,List<Character>> m = new HashMap<Character,List<Character>>();\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            char c1 = s1.charAt(i);\\n            char c2 = s2.charAt(i);\\n            if(c1==c2)\\n                continue;\\n           List<Character> list =m.getOrDefault(c1,new ArrayList());\\n           if(!list.contains(c2))\\n                    list.add(c2);\\n            m.put(c1,list);\\n           list =m.getOrDefault(c2,new ArrayList());\\n           if(!list.contains(c1))\\n                list.add(c1);\\n            m.put(c2,list);    \\n\\n\\n        }\\n\\n\\n         List<Character> memory =new ArrayList();\\n        for(char i=0;i<l.length;i++)\\n        {\\n         \\n           char c =l[i];\\n           if(memory.contains(c))\\n            continue;\\n           List<Character> list = m.getOrDefault(c,new ArrayList());\\n           List<Character> itr =new ArrayList();\\n           List<Character> visited =new ArrayList();\\n           itr.addAll(list);\\n           while(!itr.isEmpty())\\n           {\\n               char r = itr.remove(0);\\n               if(r<c)\\n                    c=r;\\n               list = m.get(r);\\n               for(char j:list)\\n                if(!visited.contains(j))\\n                    {\\n                        itr.add(j);\\n                        visited.add(j);\\n                    }\\n           }\\n\\n           for(char j:visited)\\n             l[j-\\'a\\']=c;\\n           memory.addAll(visited);\\n\\n        }\\n        String retStr=\"\";\\n            \\n        for(int i=0;i<baseStr.length();i++)\\n        {\\n            char c=baseStr.charAt(i); \\n            char smallest=l[c-\\'a\\'];\\n           retStr=retStr+smallest +\"\";                \\n        }\\n\\n        return retStr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        char[] l = new char[26];\\n        for(char i=0;i<l.length;i++)\\n        {\\n          \\n          char c =(char)(\\'a\\'+i);\\n          l[i]=c;\\n\\n        }\\n        HashMap<Character,List<Character>> m = new HashMap<Character,List<Character>>();\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            char c1 = s1.charAt(i);\\n            char c2 = s2.charAt(i);\\n            if(c1==c2)\\n                continue;\\n           List<Character> list =m.getOrDefault(c1,new ArrayList());\\n           if(!list.contains(c2))\\n                    list.add(c2);\\n            m.put(c1,list);\\n           list =m.getOrDefault(c2,new ArrayList());\\n           if(!list.contains(c1))\\n                list.add(c1);\\n            m.put(c2,list);    \\n\\n\\n        }\\n\\n\\n         List<Character> memory =new ArrayList();\\n        for(char i=0;i<l.length;i++)\\n        {\\n         \\n           char c =l[i];\\n           if(memory.contains(c))\\n            continue;\\n           List<Character> list = m.getOrDefault(c,new ArrayList());\\n           List<Character> itr =new ArrayList();\\n           List<Character> visited =new ArrayList();\\n           itr.addAll(list);\\n           while(!itr.isEmpty())\\n           {\\n               char r = itr.remove(0);\\n               if(r<c)\\n                    c=r;\\n               list = m.get(r);\\n               for(char j:list)\\n                if(!visited.contains(j))\\n                    {\\n                        itr.add(j);\\n                        visited.add(j);\\n                    }\\n           }\\n\\n           for(char j:visited)\\n             l[j-\\'a\\']=c;\\n           memory.addAll(visited);\\n\\n        }\\n        String retStr=\"\";\\n            \\n        for(int i=0;i<baseStr.length();i++)\\n        {\\n            char c=baseStr.charAt(i); \\n            char smallest=l[c-\\'a\\'];\\n           retStr=retStr+smallest +\"\";                \\n        }\\n\\n        return retStr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049342,
                "title": "python-union-find-easy-and-simple-solution",
                "content": "\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        parent = defaultdict(str)\\n        for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n            parent[c] = c \\n        def find(v):\\n            if parent[v] != v:\\n                parent[v] = find(parent[v])\\n            return parent[v]\\n        def union(v,w):\\n            pv, pw = find(v), find(w)\\n            if pv < pw:\\n                parent[pw] = pv\\n            else:\\n                parent[pv] = pw \\n        for v, w in zip(s1, s2):\\n            union(v, w)\\n        res = []\\n        for c in baseStr:\\n            res.append(find(c))\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        parent = defaultdict(str)\\n        for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n            parent[c] = c \\n        def find(v):\\n            if parent[v] != v:\\n                parent[v] = find(parent[v])\\n            return parent[v]\\n        def union(v,w):\\n            pv, pw = find(v), find(w)\\n            if pv < pw:\\n                parent[pw] = pv\\n            else:\\n                parent[pv] = pw \\n        for v, w in zip(s1, s2):\\n            union(v, w)\\n        res = []\\n        for c in baseStr:\\n            res.append(find(c))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049177,
                "title": "php-union-find-easy-understand",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s1\\n     * @param String $s2\\n     * @param String $baseStr\\n     * @return String\\n     */\\n    private $representative = [];\\n    function smallestEquivalentString($s1, $s2, $baseStr) {\\n        for ($i = 0; $i < 26; $i++) {\\n            $char = chr($i + ord(\\'a\\'));\\n            $this->representative[$char] = $char;\\n        }\\n\\n        for ($i = 0; $i < strlen($s1); $i++) {\\n            $this->performUnion($s1[$i], $s2[$i]);\\n        }\\n\\n        $ans = \"\";\\n        for ($c = 0; $c < strlen($baseStr); $c++) {\\n            $ans .= $this->find($baseStr[$c]);\\n        }\\n\\n        return $ans;\\n    }\\n    \\n    private function find(string $x): string {\\n        if ($this->representative[$x] === $x) {\\n            return $x;\\n        }\\n\\n        return $this->representative[$x] = $this->find($this->representative[$x]);\\n    }\\n\\n    private function performUnion(string $x, string $y) {\\n        $x = $this->find($x);\\n        $y = $this->find($y);\\n\\n        if ($x == $y) {\\n            return;\\n        }\\n\\n        if ($x < $y) {\\n            $this->representative[$y] = $x;\\n        } else {\\n            $this->representative[$x] = $y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s1\\n     * @param String $s2\\n     * @param String $baseStr\\n     * @return String\\n     */\\n    private $representative = [];\\n    function smallestEquivalentString($s1, $s2, $baseStr) {\\n        for ($i = 0; $i < 26; $i++) {\\n            $char = chr($i + ord(\\'a\\'));\\n            $this->representative[$char] = $char;\\n        }\\n\\n        for ($i = 0; $i < strlen($s1); $i++) {\\n            $this->performUnion($s1[$i], $s2[$i]);\\n        }\\n\\n        $ans = \"\";\\n        for ($c = 0; $c < strlen($baseStr); $c++) {\\n            $ans .= $this->find($baseStr[$c]);\\n        }\\n\\n        return $ans;\\n    }\\n    \\n    private function find(string $x): string {\\n        if ($this->representative[$x] === $x) {\\n            return $x;\\n        }\\n\\n        return $this->representative[$x] = $this->find($this->representative[$x]);\\n    }\\n\\n    private function performUnion(string $x, string $y) {\\n        $x = $this->find($x);\\n        $y = $this->find($y);\\n\\n        if ($x == $y) {\\n            return;\\n        }\\n\\n        if ($x < $y) {\\n            $this->representative[$y] = $x;\\n        } else {\\n            $this->representative[$x] = $y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049091,
                "title": "complete-explanation-of-each-step-daily-leetcode-solution-c",
                "content": "## **DO UPVOTE IF YOU LIKE**\\n# Intuition \\n1. map the character s1[i] with s2[i] and s2[i] with s1[i] \\n```\\nmap<char,set<char>>mp;\\n     for(int i=0;i<s1.size();i++)\\n     {\\n       mp[s1[i]].insert(s2[i]);\\n       mp[s2[i]].insert(s1[i]);\\n     } \\n\\n```\\n2. now we will iterate mapping first time\\n   here we will be putting all the elements from set of every   \\n  element in set of characters mapped with current character that we are iterating via map\\n\\n```\\n   for(auto it=mp.begin();it!=mp.end();it++) //its not commented \\n     {\\n         for(auto itin:it->second)\\n         {\\n           for(auto itt:mp[itin])\\n               mp[it->first].insert(itt);\\n         }\\n     }\\n```\\n3. now we will repeat above same step but just in reverse order so that if any character gets associated afterwards then also we can consider it\\n \\n ```\\nfor(auto it=mp.rbegin();it!=mp.rend();it++) //it is also not commented\\n     {\\n         for(auto itin:it->second)\\n         {\\n           for(auto itt:mp[itin])\\n               mp[it->first].insert(itt);\\n         }\\n     }\\n```\\ne.g for the testcase -\\n![image.png](https://assets.leetcode.com/users/images/4c2043dc-aa44-4385-9af7-9d1656817301_1673685491.9578443.png)\\n\\n     \\nbefore iterating reverse\\n    \\n![image.png](https://assets.leetcode.com/users/images/b58291c4-e251-4f0c-b307-96de37320d37_1673685397.652144.png)\\nAfter iterating reverse\\n     \\n![image.png](https://assets.leetcode.com/users/images/fdbf2b0b-466d-4c54-bef0-3c4188f91264_1673685255.0946136.png)\\n      \\n  \\n4. then just replace the character in basestring by smallest character in its mapping ,and if no mapping exists then keep it as it is\\n\\n```\\nfor(int i=0;i<baseStr.size();i++)\\n     {\\n         char mini=\\'z\\';\\n         for(int j=0;j<mp[baseStr[i]].size();j++)\\n         {\\n         for(auto it:mp[baseStr[i]])\\n              mini=min(mini,it);\\n         }\\n         baseStr[i]=min(mini,baseStr[i]);\\n     }\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n     map<char,set<char>>mp;\\n     for(int i=0;i<s1.size();i++)\\n     {\\n       mp[s1[i]].insert(s2[i]);\\n       mp[s2[i]].insert(s1[i]);\\n     } \\n     for(auto it=mp.begin();it!=mp.end();it++)  //from front\\n     {\\n         for(auto itin:it->second)\\n         {\\n           for(auto itt:mp[itin])\\n               mp[it->first].insert(itt);\\n         }\\n     }\\n      for(auto it=mp.rbegin();it!=mp.rend();it++) //from back\\n     {\\n         for(auto itin:it->second)\\n         {\\n           for(auto itt:mp[itin])\\n               mp[it->first].insert(itt);\\n         }\\n     }\\n\\n     for(int i=0;i<baseStr.size();i++)\\n     {\\n         char mini=\\'z\\';\\n         for(int j=0;j<mp[baseStr[i]].size();j++)\\n         {\\n         for(auto it:mp[baseStr[i]])\\n              mini=min(mini,it);\\n         }\\n         baseStr[i]=min(mini,baseStr[i]);\\n     }\\n     return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nmap<char,set<char>>mp;\\n     for(int i=0;i<s1.size();i++)\\n     {\\n       mp[s1[i]].insert(s2[i]);\\n       mp[s2[i]].insert(s1[i]);\\n     } \\n\\n```\n```\\n   for(auto it=mp.begin();it!=mp.end();it++) //its not commented \\n     {\\n         for(auto itin:it->second)\\n         {\\n           for(auto itt:mp[itin])\\n               mp[it->first].insert(itt);\\n         }\\n     }\\n```\n```\\nfor(auto it=mp.rbegin();it!=mp.rend();it++) //it is also not commented\\n     {\\n         for(auto itin:it->second)\\n         {\\n           for(auto itt:mp[itin])\\n               mp[it->first].insert(itt);\\n         }\\n     }\\n```\n```\\nfor(int i=0;i<baseStr.size();i++)\\n     {\\n         char mini=\\'z\\';\\n         for(int j=0;j<mp[baseStr[i]].size();j++)\\n         {\\n         for(auto it:mp[baseStr[i]])\\n              mini=min(mini,it);\\n         }\\n         baseStr[i]=min(mini,baseStr[i]);\\n     }\\n```\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n     map<char,set<char>>mp;\\n     for(int i=0;i<s1.size();i++)\\n     {\\n       mp[s1[i]].insert(s2[i]);\\n       mp[s2[i]].insert(s1[i]);\\n     } \\n     for(auto it=mp.begin();it!=mp.end();it++)  //from front\\n     {\\n         for(auto itin:it->second)\\n         {\\n           for(auto itt:mp[itin])\\n               mp[it->first].insert(itt);\\n         }\\n     }\\n      for(auto it=mp.rbegin();it!=mp.rend();it++) //from back\\n     {\\n         for(auto itin:it->second)\\n         {\\n           for(auto itt:mp[itin])\\n               mp[it->first].insert(itt);\\n         }\\n     }\\n\\n     for(int i=0;i<baseStr.size();i++)\\n     {\\n         char mini=\\'z\\';\\n         for(int j=0;j<mp[baseStr[i]].size();j++)\\n         {\\n         for(auto it:mp[baseStr[i]])\\n              mini=min(mini,it);\\n         }\\n         baseStr[i]=min(mini,baseStr[i]);\\n     }\\n     return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049005,
                "title": "solution-without-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMapping\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMapping of characters with sets.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char, set<char> > m;\\n        for(int i=0;i<s1.length();i++){\\n            m[s1[i]].insert(s1[i]);\\n            m[s1[i]].insert(s2[i]);\\n            m[s2[i]].insert(s1[i]);\\n            m[s2[i]].insert(s2[i]);\\n        }\\n        for(auto a:m){\\n            // cout<<a.first<<\" - \";\\n            char ch = a.first;\\n            for(auto b:a.second){\\n                // cout<<b<<\" \";\\n                for(auto x:m[b]){\\n                    m[ch].insert(x);\\n                    m[x].insert(ch);\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n        for(auto a:m){\\n            // cout<<a.first<<\" - \";\\n            char ch = a.first;\\n            for(auto b:a.second){\\n                // cout<<b<<\" \";\\n                for(auto x:m[b]){\\n                    m[ch].insert(x);\\n                    m[x].insert(ch);\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n\\n        // for(auto a:m){\\n        //     cout<<a.first<<\" - \";\\n        //     for(auto b:a.second){\\n        //         cout<<b<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n\\n        for(int i=0;i<baseStr.length();i++){\\n            while(m[baseStr[i]].size() > 0 && baseStr[i] != *m[baseStr[i]].begin()){\\n                baseStr[i] = *m[baseStr[i]].begin(); \\n            }\\n        }\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char, set<char> > m;\\n        for(int i=0;i<s1.length();i++){\\n            m[s1[i]].insert(s1[i]);\\n            m[s1[i]].insert(s2[i]);\\n            m[s2[i]].insert(s1[i]);\\n            m[s2[i]].insert(s2[i]);\\n        }\\n        for(auto a:m){\\n            // cout<<a.first<<\" - \";\\n            char ch = a.first;\\n            for(auto b:a.second){\\n                // cout<<b<<\" \";\\n                for(auto x:m[b]){\\n                    m[ch].insert(x);\\n                    m[x].insert(ch);\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n        for(auto a:m){\\n            // cout<<a.first<<\" - \";\\n            char ch = a.first;\\n            for(auto b:a.second){\\n                // cout<<b<<\" \";\\n                for(auto x:m[b]){\\n                    m[ch].insert(x);\\n                    m[x].insert(ch);\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n\\n        // for(auto a:m){\\n        //     cout<<a.first<<\" - \";\\n        //     for(auto b:a.second){\\n        //         cout<<b<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n\\n        for(int i=0;i<baseStr.length();i++){\\n            while(m[baseStr[i]].size() > 0 && baseStr[i] != *m[baseStr[i]].begin()){\\n                baseStr[i] = *m[baseStr[i]].begin(); \\n            }\\n        }\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3048995,
                "title": "c-union-find",
                "content": "# Code\\n```\\nvector<int> parent(26);\\nclass Solution \\n{\\n    public:\\n    int un(int node)\\n    {   \\n        while(parent[node]!=node) node=parent[node];\\n        return node;  \\n    }\\n    string smallestEquivalentString(string A, string B, string S) \\n    {\\n        for(int i=0;i<26;i++) parent[i]=i;                      \\n        \\n        for(int i=0;i<A.size();i++)\\n        {\\n            int x=un(A[i]-\\'a\\');\\n            int y=un(B[i]-\\'a\\');\\n            \\n            if(x!=y) parent[max(x,y)]=min(x,y);\\n        }\\n        \\n        for(int i=0;i<S.length();i++) S[i]=un(S[i]-\\'a\\')+\\'a\\';\\n        return S;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nvector<int> parent(26);\\nclass Solution \\n{\\n    public:\\n    int un(int node)\\n    {   \\n        while(parent[node]!=node) node=parent[node];\\n        return node;  \\n    }\\n    string smallestEquivalentString(string A, string B, string S) \\n    {\\n        for(int i=0;i<26;i++) parent[i]=i;                      \\n        \\n        for(int i=0;i<A.size();i++)\\n        {\\n            int x=un(A[i]-\\'a\\');\\n            int y=un(B[i]-\\'a\\');\\n            \\n            if(x!=y) parent[max(x,y)]=min(x,y);\\n        }\\n        \\n        for(int i=0;i<S.length();i++) S[i]=un(S[i]-\\'a\\')+\\'a\\';\\n        return S;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048983,
                "title": "java-unionfind-solution-with-reusable-template",
                "content": "Solution:\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/unionfind/LexicographicallySmallestEquivalent.java\\n\\n\\nUnion find template:\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/unionfind/UnionFind.java",
                "solutionTags": [
                    "Java"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3048852,
                "title": "using-dsu",
                "content": "\\n\\n# Disjoint Set Union(DSU)|Simple C++ code|Beginner Friendly\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint par[125];\\nint sz[125];\\n\\n\\nvoid makeset(int i)\\n{\\n    par[i] = i;\\n    sz[i] = 1;\\n   \\n}\\nint find(int i)\\n{\\n    if (par[i] == i)\\n    {\\n\\n        return i;\\n    }\\n    return par[i] = find(par[i]);\\n}\\nvoid set_union(int a, int b)\\n{\\n    a = find(a);\\n    b = find(b);\\n\\n    if (a != b)\\n    {\\n        if(a>b)\\n        swap(a,b);\\n        sz[a] += sz[b];\\n        par[b] = a;\\n    }\\n \\n}\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n=s1.size();\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            makeset(ch);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int u=s1[i];\\n            int v=s2[i];\\n            set_union(u,v);\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++)\\n        {\\n            int val=baseStr[i];\\n            char ch=find(val);\\n            ans+=ch;\\n            \\n          \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint par[125];\\nint sz[125];\\n\\n\\nvoid makeset(int i)\\n{\\n    par[i] = i;\\n    sz[i] = 1;\\n   \\n}\\nint find(int i)\\n{\\n    if (par[i] == i)\\n    {\\n\\n        return i;\\n    }\\n    return par[i] = find(par[i]);\\n}\\nvoid set_union(int a, int b)\\n{\\n    a = find(a);\\n    b = find(b);\\n\\n    if (a != b)\\n    {\\n        if(a>b)\\n        swap(a,b);\\n        sz[a] += sz[b];\\n        par[b] = a;\\n    }\\n \\n}\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n=s1.size();\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            makeset(ch);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int u=s1[i];\\n            int v=s2[i];\\n            set_union(u,v);\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++)\\n        {\\n            int val=baseStr[i];\\n            char ch=find(val);\\n            ans+=ch;\\n            \\n          \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048850,
                "title": "live-coding-and-video-explanation-beats-100-in-english-and-hindi-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy Approach In English\\n\\nEnglish\\nhttps://youtu.be/ivp7eOHIsgY\\n\\nHindi\\n\\nhttps://youtu.be/WIuCeY-g3YY\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int [] letter = new int[26];\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        for(int i=0;i<26;i++){\\n            letter[i]=i;\\n        }\\n        for(int i=0;i<s1.length();i++){\\n            unite(s1.charAt(i)-\\'a\\',s2.charAt(i)-\\'a\\');\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=0;i<baseStr.length();i++){\\n            ans.append((char)((get(baseStr.charAt(i)-\\'a\\'))+\\'a\\'));\\n\\n        }\\n        return ans.toString();\\n        \\n    }\\n    public void unite(int x,int y){\\n        x =get(x);\\n        y = get(y);\\n        if(x<y){\\n            letter[y]=x;\\n\\n        }else{\\n            letter[x]=y;\\n        }\\n    }\\n    public int get(int x){\\n        if(letter[x]==x){\\n            return x;\\n        }\\n        else{\\n            letter[x]=get(letter[x]);\\n            return letter[x];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int [] letter = new int[26];\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        for(int i=0;i<26;i++){\\n            letter[i]=i;\\n        }\\n        for(int i=0;i<s1.length();i++){\\n            unite(s1.charAt(i)-\\'a\\',s2.charAt(i)-\\'a\\');\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=0;i<baseStr.length();i++){\\n            ans.append((char)((get(baseStr.charAt(i)-\\'a\\'))+\\'a\\'));\\n\\n        }\\n        return ans.toString();\\n        \\n    }\\n    public void unite(int x,int y){\\n        x =get(x);\\n        y = get(y);\\n        if(x<y){\\n            letter[y]=x;\\n\\n        }else{\\n            letter[x]=y;\\n        }\\n    }\\n    public int get(int x){\\n        if(letter[x]==x){\\n            return x;\\n        }\\n        else{\\n            letter[x]=get(letter[x]);\\n            return letter[x];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048714,
                "title": "lexicographically-smallest-equivalent-string-100-faster-easy-explanation",
                "content": "# Intuition\\nFrom the problem statement it is clear that the graph will be disconnected. Each component of the graph will contain equivalent characters to each other. In order to derive the lexicographically smallest equivalent string of baseStr, we need to find the lexicographic smallest character in that particular component where baseStr[j] exist.\\n\\n# Approach\\n- Initialize parent array of size=26 (a-->z) as -1.\\n\\n- Traverse strings s1 and string s2 and connect s1[i] to s2[i]. To connect first find the ultimate parent(lexicographically smallest character in particular component) of both the characters using find_par(). Make the lexicographic smaller character as parent of the bigger lexicographic character.\\n\\n- Traverse the baseStr and replace baseStr[j] with the lexicographic smallest equivalent character (i.e., ultimate parent of baseStr[j]).\\n\\n# Complexity\\n- Time complexity:\\n    $$O(n+m)k$$\\n\\n        make_union() and find_par() takes constant time (say k).\\n        n==s1.size()==s2.size()\\n        m==baseStr.size()\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int find_par(int node,vector<int>&parent){\\n        if(parent[node]==-1)\\n        return node;\\n\\n        return parent[node]=find_par(parent[node],parent);  //returns ultimate parent\\n    }\\n\\n    void  make_union (int u, int v, vector<int>&parent){\\n        u=find_par(u,parent);\\n        v=find_par(v,parent);\\n\\n        //connect lexicographically\\n        if(u<v)\\n        parent[v]=u;\\n            \\n        else if(u>v)\\n        parent[u]=v;\\n            \\n        }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n\\n        vector<int>parent(26,-1); //intialize the parent array\\n        \\n        for(int i=0; i<s1.size(); i++){\\n            if(s1[i]!=s2[i])\\n            make_union(s1[i]-\\'a\\',s2[i]-\\'a\\',parent);  //connect the correspoding equivalent characters\\n        }\\n\\n        for(int j=0; j<baseStr.size(); j++){\\n            baseStr[j]=find_par(baseStr[j]-\\'a\\',parent)+\\'a\\';\\n        }\\n\\n        return baseStr;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int find_par(int node,vector<int>&parent){\\n        if(parent[node]==-1)\\n        return node;\\n\\n        return parent[node]=find_par(parent[node],parent);  //returns ultimate parent\\n    }\\n\\n    void  make_union (int u, int v, vector<int>&parent){\\n        u=find_par(u,parent);\\n        v=find_par(v,parent);\\n\\n        //connect lexicographically\\n        if(u<v)\\n        parent[v]=u;\\n            \\n        else if(u>v)\\n        parent[u]=v;\\n            \\n        }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n\\n        vector<int>parent(26,-1); //intialize the parent array\\n        \\n        for(int i=0; i<s1.size(); i++){\\n            if(s1[i]!=s2[i])\\n            make_union(s1[i]-\\'a\\',s2[i]-\\'a\\',parent);  //connect the correspoding equivalent characters\\n        }\\n\\n        for(int j=0; j<baseStr.size(); j++){\\n            baseStr[j]=find_par(baseStr[j]-\\'a\\',parent)+\\'a\\';\\n        }\\n\\n        return baseStr;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048613,
                "title": "c-step-by-step-example-o-n-time-o-1-space",
                "content": "**Before looking at the example, look at the solution. It is only a step by step illustration.**\\n\\n# Example\\n`s1 = \"acde\"`, `s2 = \"bcea\"`, `baseStr = \"bdeac\"`\\n\\n### Initialization\\n| a | b | c | d | e |\\n|:-:|:-:|:-:|:-:|:-:|\\n| a | b | c | d | e |\\n\\n### Step 0:\\n> s1 = \"**a**cde\", s2 = \"**b**cea\"\\n\\n`s1[0] = a, s2[0] = b, table[s1[0]] = a, table[s2[0]] = b`\\n`curr_min = a, curr_max = b \\u21D2 table[b] = a`\\n| **a** | **b** | c | d | e |\\n|:-----:|:-----:|:-:|:-:|:-:|\\n| **a** | **a** | c | d | e |\\n\\n### Step 1:\\n> s1 = \"a**c**de\", s2 = \"b**c**ea\"\\n\\n`s1[1] = \\u0441, s2[1] = c, table[s1[1]] = c, table[s2[1]] = c`\\n`curr_min = c, curr_max = c \\u21D2 table[c] = c`\\n| a | b | **c** | d | e |\\n|:-:|:-:|:-----:|:-:|:-:|\\n| a | b | **c** | d | e |\\n\\n### Step 2:\\n> s1 = \"ac**d**e\", s2 = \"bc**e**a\"\\n\\n`s1[2] = d, s2[2] = e, table[s1[2]] = d, table[s2[2]] = e`\\n`curr_min = d, curr_max = e \\u21D2 table[e] = d`\\n| a | b | c | **d** | **e** |\\n|:-:|:-:|:-:|:-----:|:-----:|\\n| a | a | c | **d** | **d** |\\n\\n### Step 3:\\n> s1 = \"acd**e**\", s2 = \"bce**a**\"\\n\\n`s1[3] = e, s2[3] = a, table[s1[3]] = d, table[s2[3]] = a`\\n`curr_min = a, curr_max = d \\u21D2 table[d] = d, table[e] = d`\\n(Since we are looking for all cells whose value is `curr_max`)\\n| **a** | **b** | c | **d** | **e** |\\n|:-----:|:-----:|:-:|:-----:|:-----:|\\n| **a** | **a** | c | **a** | **a** |\\n\\n### Formation of the result\\n> baseStr = \"bdeac\"\\n\\n`b \\u21D2 a, d \\u21D2 a, e \\u21D2 a, a \\u21D2 a, c \\u21D2 c `\\n\\nLexicographically smallest equivalent string of `baseStr`: `\"aaaac\"`\\n\\n# Complexity\\n- Time complexity: $$ O(n \\\\cdot 26) = O(n) $$\\n- Space complexity: $$ O(26) = O(1) $$\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<int> table(26);\\n        for (int i = 0; i < 26; i++) { table[i] = \\'a\\' + i; }\\n        for (int i = 0; i < s1.size(); i++) {\\n            int curr_min = table[s1[i]-\\'a\\'], curr_max = table[s2[i]-\\'a\\'];\\n            if (curr_max < curr_min) { swap(curr_min, curr_max); }\\n            for (int j = 0; j < 26; j++) {\\n                if (table[j] == curr_max) { table[j] = curr_min; }\\n            }\\n        }\\n        for (int i = 0; i < baseStr.size(); i++) { baseStr[i] = table[baseStr[i]-\\'a\\']; }\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<int> table(26);\\n        for (int i = 0; i < 26; i++) { table[i] = \\'a\\' + i; }\\n        for (int i = 0; i < s1.size(); i++) {\\n            int curr_min = table[s1[i]-\\'a\\'], curr_max = table[s2[i]-\\'a\\'];\\n            if (curr_max < curr_min) { swap(curr_min, curr_max); }\\n            for (int j = 0; j < 26; j++) {\\n                if (table[j] == curr_max) { table[j] = curr_min; }\\n            }\\n        }\\n        for (int i = 0; i < baseStr.size(); i++) { baseStr[i] = table[baseStr[i]-\\'a\\']; }\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048537,
                "title": "rust-clean-union-find-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn smallest_equivalent_string(s1: String, s2: String, base_str: String) -> String {\\n        // recursively get the root element\\n        fn get(root: &mut Vec<usize>, x: usize) -> usize {\\n            if x == root[x] { return x; }\\n            root[x] = get(root, root[x]);\\n            root[x]\\n        }\\n        // unite two elements\\n        fn unite(root: &mut Vec<usize>, x: usize, y: usize) {\\n            let x = get(root, x);\\n            let y = get(root, y);\\n            // if their roots are not same, we combine them\\n            if x == y { return; } \\n            // smaller first\\n            if x < y {\\n                root[y] = x;\\n            } else {\\n                root[x] = y;\\n            }\\n        }\\n        let s1 = s1.chars().collect::<Vec<char>>();\\n        let s2 = s2.chars().collect::<Vec<char>>();\\n        let mut root: Vec<usize> = (0..26).into_iter().collect();\\n        for i in 0..s1.len() {\\n            let (u, v) = ((s1[i] as u8 - \\'a\\' as u8) as usize, (s2[i] as u8 - \\'a\\' as u8) as usize);\\n            unite(&mut root, u, v);\\n        }\\n        let mut res = String::new();\\n        for c in base_str.chars() {\\n            let k = (c as u8 - \\'a\\' as u8) as usize;\\n            let ch = get(&mut root, k) as u8 + \\'a\\' as u8;\\n            res.push(ch as char);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Union Find"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn smallest_equivalent_string(s1: String, s2: String, base_str: String) -> String {\\n        // recursively get the root element\\n        fn get(root: &mut Vec<usize>, x: usize) -> usize {\\n            if x == root[x] { return x; }\\n            root[x] = get(root, root[x]);\\n            root[x]\\n        }\\n        // unite two elements\\n        fn unite(root: &mut Vec<usize>, x: usize, y: usize) {\\n            let x = get(root, x);\\n            let y = get(root, y);\\n            // if their roots are not same, we combine them\\n            if x == y { return; } \\n            // smaller first\\n            if x < y {\\n                root[y] = x;\\n            } else {\\n                root[x] = y;\\n            }\\n        }\\n        let s1 = s1.chars().collect::<Vec<char>>();\\n        let s2 = s2.chars().collect::<Vec<char>>();\\n        let mut root: Vec<usize> = (0..26).into_iter().collect();\\n        for i in 0..s1.len() {\\n            let (u, v) = ((s1[i] as u8 - \\'a\\' as u8) as usize, (s2[i] as u8 - \\'a\\' as u8) as usize);\\n            unite(&mut root, u, v);\\n        }\\n        let mut res = String::new();\\n        for c in base_str.chars() {\\n            let k = (c as u8 - \\'a\\' as u8) as usize;\\n            let ch = get(&mut root, k) as u8 + \\'a\\' as u8;\\n            res.push(ch as char);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3048492,
                "title": "c-union-find-beat-100-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU {\\npublic:\\n    vector<int>rank;\\n    vector<int>parent;\\n    \\n    DSU(int n) {\\n        rank.resize(n);\\n        parent.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            rank[i] = i;\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    int findParent(int x) {\\n        if (x == parent[x]) {\\n            return x;\\n        }\\n        return parent[x] = findParent(parent[x]);\\n    }\\n    \\n    void makeUnion(int x, int y) {\\n        int p1 = findParent(x), p2 = findParent(y);\\n        if (p1 != p2) {\\n            if (rank[p1] < rank[p2]) {\\n                parent[p2] = p1;\\n            }\\n            else {\\n                parent[p1] = p2;\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DSU dsu(26);\\n        for (int i = 0; i < s1.size(); i++) {\\n            dsu.makeUnion(s1[i]-\\'a\\', s2[i]-\\'a\\');\\n        }\\n        string ans;\\n        for (int i = 0; i < baseStr.size(); i++) {\\n            char ch = dsu.findParent(baseStr[i]-\\'a\\') + \\'a\\';\\n            ans += ch;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![upvote1.jpeg](https://assets.leetcode.com/users/images/fd306d17-746c-4363-94cd-6f52a7fa0888_1673677839.7584035.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n    vector<int>rank;\\n    vector<int>parent;\\n    \\n    DSU(int n) {\\n        rank.resize(n);\\n        parent.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            rank[i] = i;\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    int findParent(int x) {\\n        if (x == parent[x]) {\\n            return x;\\n        }\\n        return parent[x] = findParent(parent[x]);\\n    }\\n    \\n    void makeUnion(int x, int y) {\\n        int p1 = findParent(x), p2 = findParent(y);\\n        if (p1 != p2) {\\n            if (rank[p1] < rank[p2]) {\\n                parent[p2] = p1;\\n            }\\n            else {\\n                parent[p1] = p2;\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DSU dsu(26);\\n        for (int i = 0; i < s1.size(); i++) {\\n            dsu.makeUnion(s1[i]-\\'a\\', s2[i]-\\'a\\');\\n        }\\n        string ans;\\n        for (int i = 0; i < baseStr.size(); i++) {\\n            char ch = dsu.findParent(baseStr[i]-\\'a\\') + \\'a\\';\\n            ans += ch;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048205,
                "title": "c-easily-explained-with-comments-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /* Simple piece of code used multiple times for union find \\n    operations along with path compression and union by rank \\n    optimizations. If you wish refer to CP-ALGORITHM documentation for\\n    more clearity on DSU . */\\n    \\n    int Parent[26];\\n    int Rank[26];\\n    \\n    // Path Compression Optimization\\n    \\n    int find(int x){\\n        if(Parent[x] == x) return x;\\n        return Parent[x] = find(Parent[x]);\\n    }\\n    \\n    // Union by Rank Optimization\\n    \\n    void Union(int x,int y){\\n        int lx = find(x);\\n        int ly = find(y);\\n        if(lx != ly){\\n            if(Rank[lx] < Rank[ly]){\\n                Parent[lx] = ly;\\n            }\\n            else{\\n                Parent[ly] = lx;\\n                if(Rank[lx] == Rank[ly]) Rank[lx]++;\\n            }\\n        }\\n    }\\n    \\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.length();\\n        for(int i=0;i<26;i++){\\n            Parent[i] = i;\\n            Rank[i] = 1;\\n        }\\n        \\n        // Grouping of all characters to access their leader \\n        \\n        for(int i=0;i<n;i++){\\n            Union(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n        \\n        vector<char>minElement(26);\\n        \\n        /* First initialize all the characters with their current \\n        value , e.g \\'a\\' -> \\'a\\' , \\'c\\' -> \\'c\\' and so on. */\\n        \\n        for(int i=0;i<26;i++){\\n            minElement[i] = (char)(i+\\'a\\');\\n        }\\n        \\n        /* first figure out the current element belongs to which group\\n        and then mark its leader\\'s value with the minimum value among\\n        all the characters of the same group-members. */\\n        \\n        for(int i=0;i<26;i++){\\n            int par = find(i);\\n            minElement[par] = min(minElement[par],(char)(i+\\'a\\'));\\n        }\\n        \\n        /* Now move on to the baseStr , and for each character , and\\n        figure out the group leader of the group , in which the \\n        current character belongs to. */\\n        \\n        /* Then just put the minElement[group_leader] for each and \\n        every character , as they are already precomputed by us \\n        earlier. */\\n        \\n        for(int i=0;i<baseStr.length();i++){\\n            int par = find(baseStr[i]-\\'a\\');\\n            baseStr[i] = minElement[par];\\n        }\\n        \\n        return baseStr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /* Simple piece of code used multiple times for union find \\n    operations along with path compression and union by rank \\n    optimizations. If you wish refer to CP-ALGORITHM documentation for\\n    more clearity on DSU . */\\n    \\n    int Parent[26];\\n    int Rank[26];\\n    \\n    // Path Compression Optimization\\n    \\n    int find(int x){\\n        if(Parent[x] == x) return x;\\n        return Parent[x] = find(Parent[x]);\\n    }\\n    \\n    // Union by Rank Optimization\\n    \\n    void Union(int x,int y){\\n        int lx = find(x);\\n        int ly = find(y);\\n        if(lx != ly){\\n            if(Rank[lx] < Rank[ly]){\\n                Parent[lx] = ly;\\n            }\\n            else{\\n                Parent[ly] = lx;\\n                if(Rank[lx] == Rank[ly]) Rank[lx]++;\\n            }\\n        }\\n    }\\n    \\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.length();\\n        for(int i=0;i<26;i++){\\n            Parent[i] = i;\\n            Rank[i] = 1;\\n        }\\n        \\n        // Grouping of all characters to access their leader \\n        \\n        for(int i=0;i<n;i++){\\n            Union(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n        \\n        vector<char>minElement(26);\\n        \\n        /* First initialize all the characters with their current \\n        value , e.g \\'a\\' -> \\'a\\' , \\'c\\' -> \\'c\\' and so on. */\\n        \\n        for(int i=0;i<26;i++){\\n            minElement[i] = (char)(i+\\'a\\');\\n        }\\n        \\n        /* first figure out the current element belongs to which group\\n        and then mark its leader\\'s value with the minimum value among\\n        all the characters of the same group-members. */\\n        \\n        for(int i=0;i<26;i++){\\n            int par = find(i);\\n            minElement[par] = min(minElement[par],(char)(i+\\'a\\'));\\n        }\\n        \\n        /* Now move on to the baseStr , and for each character , and\\n        figure out the group leader of the group , in which the \\n        current character belongs to. */\\n        \\n        /* Then just put the minElement[group_leader] for each and \\n        every character , as they are already precomputed by us \\n        earlier. */\\n        \\n        for(int i=0;i<baseStr.length();i++){\\n            int par = find(baseStr[i]-\\'a\\');\\n            baseStr[i] = minElement[par];\\n        }\\n        \\n        return baseStr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048177,
                "title": "c-union-find",
                "content": "The equal characters can thought to be connected with one another.We will be thinking of this problem as a graph problem where the equal characters are connected to each other. In the final string we will be finding the lexographically smallest alphabet available in the component of the current character and add it to the answer.\\nThis problem can also be done using dfs since there is no restriction about the properties changing midway.\\n\\n```cpp\\nclass Solution {\\n    struct DSU\\n    {\\n        vector<int> siz,parent;\\n        void init()\\n        {\\n            siz.resize(26);\\n            parent.resize(26);\\n            for(int i=0;i<26;i++)\\n            {\\n                siz[i]=1;\\n                parent[i]=i;\\n            }\\n        }\\n        int leader(int ex)\\n        {\\n            if(ex==parent[ex])\\n                return ex;\\n            return parent[ex]=leader(parent[ex]);\\n        }\\n        void merge(int a,int b)\\n        {\\n            a=leader(a);\\n            b=leader(b);\\n            if(a==b)\\n                return;\\n            if(siz[a]<siz[b])\\n                swap(a,b);\\n            siz[a]+=siz[b];\\n            parent[b]=parent[a];\\n        }\\n    };\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DSU d;\\n        d.init();\\n        for(int i=0;i<s1.size();i++)\\n            d.merge(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        vector<char> represent(26,\\'z\\');\\n        for(int i=0;i<26;i++)\\n            represent[d.leader(i)]=std::min(represent[d.leader(i)],(char)(\\'a\\'+i));\\n        string ans=\"\";\\n        for(auto ele : baseStr)\\n            ans+=represent[d.leader(ele-\\'a\\')];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```cpp\\nclass Solution {\\n    struct DSU\\n    {\\n        vector<int> siz,parent;\\n        void init()\\n        {\\n            siz.resize(26);\\n            parent.resize(26);\\n            for(int i=0;i<26;i++)\\n            {\\n                siz[i]=1;\\n                parent[i]=i;\\n            }\\n        }\\n        int leader(int ex)\\n        {\\n            if(ex==parent[ex])\\n                return ex;\\n            return parent[ex]=leader(parent[ex]);\\n        }\\n        void merge(int a,int b)\\n        {\\n            a=leader(a);\\n            b=leader(b);\\n            if(a==b)\\n                return;\\n            if(siz[a]<siz[b])\\n                swap(a,b);\\n            siz[a]+=siz[b];\\n            parent[b]=parent[a];\\n        }\\n    };\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DSU d;\\n        d.init();\\n        for(int i=0;i<s1.size();i++)\\n            d.merge(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        vector<char> represent(26,\\'z\\');\\n        for(int i=0;i<26;i++)\\n            represent[d.leader(i)]=std::min(represent[d.leader(i)],(char)(\\'a\\'+i));\\n        string ans=\"\";\\n        for(auto ele : baseStr)\\n            ans+=represent[d.leader(ele-\\'a\\')];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048040,
                "title": "java-c-javascript-beats-100-union-find-concise-and-clean-code",
                "content": "### Union-Find Beats 100% - \\n\\n``` java []\\nclass Solution {\\n    int[] parent;\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        parent = new int[26];\\n        for(int i=0;i<26;i++)\\n            parent[i]=i;\\n        for(int i=0;i<s1.length();i++){\\n            int u = find(s1.charAt(i)-\\'a\\');\\n            int v = find(s2.charAt(i)-\\'a\\');\\n            if(u<v)\\n              parent[v]=u;\\n            else if(u>v)\\n              parent[u]=v;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<baseStr.length();i++)\\n            sb.append((char)(find(baseStr.charAt(i)-\\'a\\')+\\'a\\'));\\n        return sb.toString();\\n    }\\n\\n    private int find(int u){\\n        return parent[u]==u? u:find(parent[u]);\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\n    int parent[26];\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        for (int i = 0; i < 26; i++) {\\n            parent[i] = i;\\n        }\\n        for (int i = 0; i < s1.length(); i++) {\\n            int u = find(s1[i] - \\'a\\');\\n            int v = find(s2[i] - \\'a\\');\\n            if (u < v) {\\n                parent[v] = u;\\n            } else if (u > v) {\\n                parent[u] = v;\\n            }\\n        }\\n        for (int i = 0; i < baseStr.length(); i++) {\\n            baseStr[i]= (char)(find(baseStr[i] - \\'a\\') + \\'a\\');\\n        }\\n        return baseStr;\\n    }\\n\\n    int find(int u) {\\n        return parent[u] == u ? u : find(parent[u]);\\n    }\\n};\\n\\n```\\n``` javascript []\\nvar smallestEquivalentString = function(s1, s2, baseStr) {\\n    let parent = new Array(26).fill(0);\\n    for (let i = 0; i < 26; i++) {\\n        parent[i] = i;\\n    }\\n    for (let i = 0; i < s1.length; i++) {\\n        let u = find(s1.charCodeAt(i) - \\'a\\'.charCodeAt(0),parent);\\n        let v = find(s2.charCodeAt(i) - \\'a\\'.charCodeAt(0),parent);\\n        if (u < v) {\\n            parent[v] = u;\\n        } else if (u > v) {\\n            parent[u] = v;\\n        }\\n    }\\n    let result=\"\";\\n    for (let i = 0; i < baseStr.length; i++) {\\n        result += String.fromCharCode(find(baseStr.charCodeAt(i) - \\'a\\'.charCodeAt(0),parent) + \\'a\\'.charCodeAt(0));\\n    }\\n    return result;\\n};\\n\\nfunction find(u,parent) {\\n    return parent[u] === u ? u : find(parent[u],parent);\\n};\\n```\\n\\n### Brute Force(Java) Beats 90% Explained- \\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047864/java-solution-brute-force-beats-90-hashtable-set-with-comments/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Union Find"
                ],
                "code": "``` java []\\nclass Solution {\\n    int[] parent;\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        parent = new int[26];\\n        for(int i=0;i<26;i++)\\n            parent[i]=i;\\n        for(int i=0;i<s1.length();i++){\\n            int u = find(s1.charAt(i)-\\'a\\');\\n            int v = find(s2.charAt(i)-\\'a\\');\\n            if(u<v)\\n              parent[v]=u;\\n            else if(u>v)\\n              parent[u]=v;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<baseStr.length();i++)\\n            sb.append((char)(find(baseStr.charAt(i)-\\'a\\')+\\'a\\'));\\n        return sb.toString();\\n    }\\n\\n    private int find(int u){\\n        return parent[u]==u? u:find(parent[u]);\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\n    int parent[26];\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        for (int i = 0; i < 26; i++) {\\n            parent[i] = i;\\n        }\\n        for (int i = 0; i < s1.length(); i++) {\\n            int u = find(s1[i] - \\'a\\');\\n            int v = find(s2[i] - \\'a\\');\\n            if (u < v) {\\n                parent[v] = u;\\n            } else if (u > v) {\\n                parent[u] = v;\\n            }\\n        }\\n        for (int i = 0; i < baseStr.length(); i++) {\\n            baseStr[i]= (char)(find(baseStr[i] - \\'a\\') + \\'a\\');\\n        }\\n        return baseStr;\\n    }\\n\\n    int find(int u) {\\n        return parent[u] == u ? u : find(parent[u]);\\n    }\\n};\\n\\n```\n``` javascript []\\nvar smallestEquivalentString = function(s1, s2, baseStr) {\\n    let parent = new Array(26).fill(0);\\n    for (let i = 0; i < 26; i++) {\\n        parent[i] = i;\\n    }\\n    for (let i = 0; i < s1.length; i++) {\\n        let u = find(s1.charCodeAt(i) - \\'a\\'.charCodeAt(0),parent);\\n        let v = find(s2.charCodeAt(i) - \\'a\\'.charCodeAt(0),parent);\\n        if (u < v) {\\n            parent[v] = u;\\n        } else if (u > v) {\\n            parent[u] = v;\\n        }\\n    }\\n    let result=\"\";\\n    for (let i = 0; i < baseStr.length; i++) {\\n        result += String.fromCharCode(find(baseStr.charCodeAt(i) - \\'a\\'.charCodeAt(0),parent) + \\'a\\'.charCodeAt(0));\\n    }\\n    return result;\\n};\\n\\nfunction find(u,parent) {\\n    return parent[u] === u ? u : find(parent[u],parent);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048026,
                "title": "brute-force-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string b) {\\n        map<char,set<char>>mp;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            if(mp.find(s1[i])==mp.end()){\\n                mp.insert({s1[i],{s1[i]}});\\n            }\\n             if(mp.find(s2[i])==mp.end()){\\n                mp.insert({s2[i],{s2[i]}});\\n            }\\n            mp.find(s2[i])->second.insert(s1[i]);\\n            mp.find(s1[i])->second.insert(s2[i]);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            set<char>num=mp.find(s1[i])->second;\\n            for(auto a:num){\\n                mp.find(a)->second.insert(s1[i]);\\n                set<char>num2=mp.find(a)->second;\\n                for(auto c:num2){\\n                    mp.find(s1[i])->second.insert(c);\\n                }\\n            }\\n            num=mp.find(s2[i])->second;\\n            for(auto a:num){\\n                mp.find(a)->second.insert(s2[i]);\\n                set<char>num2=mp.find(a)->second;\\n                for(auto c:num2){\\n                    mp.find(s2[i])->second.insert(c);\\n                }\\n            }\\n            num=mp.find(s1[i])->second;\\n            for(auto a:num){\\n                mp.find(s2[i])->second.insert(a);\\n            }\\n            num=mp.find(s2[i])->second;\\n            for(auto a:num){\\n                mp.find(s1[i])->second.insert(a);\\n            }\\n            \\n            \\n        }\\n        string s=\"\";\\n        for(auto a:b){\\n            if(mp.find(a)!=mp.end())\\n            s.push_back(*(mp.find(a)->second.begin()));\\n            else s.push_back(a);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string b) {\\n        map<char,set<char>>mp;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            if(mp.find(s1[i])==mp.end()){\\n                mp.insert({s1[i],{s1[i]}});\\n            }\\n             if(mp.find(s2[i])==mp.end()){\\n                mp.insert({s2[i],{s2[i]}});\\n            }\\n            mp.find(s2[i])->second.insert(s1[i]);\\n            mp.find(s1[i])->second.insert(s2[i]);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            set<char>num=mp.find(s1[i])->second;\\n            for(auto a:num){\\n                mp.find(a)->second.insert(s1[i]);\\n                set<char>num2=mp.find(a)->second;\\n                for(auto c:num2){\\n                    mp.find(s1[i])->second.insert(c);\\n                }\\n            }\\n            num=mp.find(s2[i])->second;\\n            for(auto a:num){\\n                mp.find(a)->second.insert(s2[i]);\\n                set<char>num2=mp.find(a)->second;\\n                for(auto c:num2){\\n                    mp.find(s2[i])->second.insert(c);\\n                }\\n            }\\n            num=mp.find(s1[i])->second;\\n            for(auto a:num){\\n                mp.find(s2[i])->second.insert(a);\\n            }\\n            num=mp.find(s2[i])->second;\\n            for(auto a:num){\\n                mp.find(s1[i])->second.insert(a);\\n            }\\n            \\n            \\n        }\\n        string s=\"\";\\n        for(auto a:b){\\n            if(mp.find(a)!=mp.end())\\n            s.push_back(*(mp.find(a)->second.begin()));\\n            else s.push_back(a);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047999,
                "title": "easy-python-solution-hashmaps-arrays-sets",
                "content": "# Code\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        hashmap = defaultdict(list)\\n\\n        for i in range(len(s1)):\\n            hashmap[s1[i]].append(s2[i])\\n            hashmap[s2[i]].append(s1[i])\\n\\n        self.visited = set()\\n        self.res = defaultdict(list)\\n        self.temp = []\\n\\n        def dfs(node):\\n            if node not in self.visited:\\n                self.visited.add(node)\\n                self.temp.append(node)\\n                for i in hashmap[node]:\\n                    dfs(i)\\n\\n        for key in hashmap:\\n            dfs(key)\\n            self.temp.sort()\\n\\n            for i in self.temp:\\n                self.res[i] += self.temp\\n            self.temp = []\\n\\n        res = \"\"\\n        \\n        for i in baseStr:\\n            if len(self.res[i]) != 0:\\n                res += self.res[i][0]\\n            else:\\n                res += i\\n\\n        return res\\n\\n\\n```\\nDo upvote if you like the solution :)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        hashmap = defaultdict(list)\\n\\n        for i in range(len(s1)):\\n            hashmap[s1[i]].append(s2[i])\\n            hashmap[s2[i]].append(s1[i])\\n\\n        self.visited = set()\\n        self.res = defaultdict(list)\\n        self.temp = []\\n\\n        def dfs(node):\\n            if node not in self.visited:\\n                self.visited.add(node)\\n                self.temp.append(node)\\n                for i in hashmap[node]:\\n                    dfs(i)\\n\\n        for key in hashmap:\\n            dfs(key)\\n            self.temp.sort()\\n\\n            for i in self.temp:\\n                self.res[i] += self.temp\\n            self.temp = []\\n\\n        res = \"\"\\n        \\n        for i in baseStr:\\n            if len(self.res[i]) != 0:\\n                res += self.res[i][0]\\n            else:\\n                res += i\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047811,
                "title": "c-0-ms-beats-100-dsu",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe Use DSU for this Problem. Pretty Much the Basic implementation without any complications. Just whenver two characters are to be set equivalent , set the parent of bigger parent of the characters to the smaller parent of the character. \\nSee the code for more clarity.\\n\\n# Complexity\\n- Time complexity: O(logn)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass DSU\\n{\\npublic:\\n\\tint parent[26];\\n\\tDSU()\\n\\t{\\n\\t\\tfor (int i = 0; i < 26; ++i)\\n\\t\\t{\\n\\t\\t\\tparent[i] = i; // setting the parent of \\'a\\' to \\'a\\'\\n\\t\\t}\\n\\t}\\n\\n\\tint find(int n)\\n\\t{\\n\\t\\tif (parent[n] == n)\\n\\t\\t{\\n\\t\\t\\treturn n;\\n\\t\\t}\\n       \\n\\t\\treturn parent[n] = find(parent[n]);\\n\\t}\\n\\n\\tvoid unite(int x, int y)\\n\\t{\\n        \\n        int par_x = find(x);\\n        int par_y = find(y);\\n        \\n        if(par_x == par_y){\\n            return;\\n        }\\n\\n\\t\\tif (par_x < par_y)\\n\\t\\t{\\n\\t\\t\\tparent[par_y] = par_x;\\n          \\n\\t\\t}else{\\n            parent[par_x] = par_y;\\n\\t    }\\n    }\\n\\t\\t\\n};\\nclass Solution {\\npublic:\\n   \\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n\\n        int n = s1.size();\\n        DSU wed = DSU(); \\n        for(int i=0;i<n;++i)\\n        {\\n            wed.unite(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n            \\n        }\\n        string res = \"\";\\n\\n        for(char p:baseStr)\\n        {\\n            res += char (wed.find(p-\\'a\\') + \\'a\\');\\n        }\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU\\n{\\npublic:\\n\\tint parent[26];\\n\\tDSU()\\n\\t{\\n\\t\\tfor (int i = 0; i < 26; ++i)\\n\\t\\t{\\n\\t\\t\\tparent[i] = i; // setting the parent of \\'a\\' to \\'a\\'\\n\\t\\t}\\n\\t}\\n\\n\\tint find(int n)\\n\\t{\\n\\t\\tif (parent[n] == n)\\n\\t\\t{\\n\\t\\t\\treturn n;\\n\\t\\t}\\n       \\n\\t\\treturn parent[n] = find(parent[n]);\\n\\t}\\n\\n\\tvoid unite(int x, int y)\\n\\t{\\n        \\n        int par_x = find(x);\\n        int par_y = find(y);\\n        \\n        if(par_x == par_y){\\n            return;\\n        }\\n\\n\\t\\tif (par_x < par_y)\\n\\t\\t{\\n\\t\\t\\tparent[par_y] = par_x;\\n          \\n\\t\\t}else{\\n            parent[par_x] = par_y;\\n\\t    }\\n    }\\n\\t\\t\\n};\\nclass Solution {\\npublic:\\n   \\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n\\n        int n = s1.size();\\n        DSU wed = DSU(); \\n        for(int i=0;i<n;++i)\\n        {\\n            wed.unite(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n            \\n        }\\n        string res = \"\";\\n\\n        for(char p:baseStr)\\n        {\\n            res += char (wed.find(p-\\'a\\') + \\'a\\');\\n        }\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047809,
                "title": "java-simple-solution-no-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain a map of all lowercase characters where each character points to the smallest equivalent character at any given time. Update this map as we discover equivalences between the characters of strings `s1` and `s2`, one character at a time. Finally use this map to convert the `baseStr` to the smallest equivalent string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a map of all lowercase characters and initialize them to point to their own value.\\n2. Iterate over each character of strings `s1` and `s2`.\\n3. Look up the map for the smallest equivalent characters for both the characters of `s1` and `s2`.\\n4. Replace all instances of the larger equivalent character with the smaller one all throughout the map.\\n5. Now use the final state of the map to convert the `baseStr` one character at a time to the smallest equivalent string.\\n\\n# Complexity\\n- N is the length of strings `s1` and `s2`\\n- M is the length of string `baseStr`\\n\\n- Time complexity: $$O(N + M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n    var map = new char[26];\\n\\n    for (var i=0; i<26; i++)\\n      map[i] = (char) (\\'a\\' + i);\\n\\n    for (var i=0; i < s1.length(); i++) {\\n      var a = map[s1.charAt(i) - \\'a\\'];\\n      var b = map[s2.charAt(i) - \\'a\\'];\\n\\n      if (a == b) continue;\\n\\n      var a1 = a < b ? a : b;\\n      var b1 = a < b ? b : a;\\n\\n      for (var j=0; j<26; j++)\\n        if (map[j] == b1)\\n          map[j] = a1;\\n    }\\n    var sb = new StringBuilder();\\n\\n    for (var i=0; i < baseStr.length(); i++)\\n      sb.append(map[baseStr.charAt(i) - \\'a\\']);\\n\\n    return sb.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n  public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n    var map = new char[26];\\n\\n    for (var i=0; i<26; i++)\\n      map[i] = (char) (\\'a\\' + i);\\n\\n    for (var i=0; i < s1.length(); i++) {\\n      var a = map[s1.charAt(i) - \\'a\\'];\\n      var b = map[s2.charAt(i) - \\'a\\'];\\n\\n      if (a == b) continue;\\n\\n      var a1 = a < b ? a : b;\\n      var b1 = a < b ? b : a;\\n\\n      for (var j=0; j<26; j++)\\n        if (map[j] == b1)\\n          map[j] = a1;\\n    }\\n    var sb = new StringBuilder();\\n\\n    for (var i=0; i < baseStr.length(); i++)\\n      sb.append(map[baseStr.charAt(i) - \\'a\\']);\\n\\n    return sb.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047768,
                "title": "100-0ms-stream-vs-sb-2-ways-concise-proof",
                "content": "# UPVOTE PLS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# \\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/0018a7db-ad2d-4be0-ac32-7ca72c6e4501_1673665384.0892494.png)\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    public String smallestEquivalentString(String s1, String s2, String base) {\\n        int A[] = IntStream.range(0,26).toArray();\\n        for(int i=0;i<s1.length();i++){\\n            int p1=find(s1.charAt(i)-\\'a\\',A),p2=find(s2.charAt(i)-\\'a\\',A);\\n            if(p1<p2)A[p2]=p1;\\n            else A[p1]=p2;\\n        }\\n        return base.chars().mapToObj(c->String.valueOf((char)(\\'a\\'+find(c-\\'a\\',A)))).collect(Collectors.joining());\\n    }    \\n```\\n```\\nprivate int find(int id,int[] A){\\n        while(A[id]!=id) id=A[id];\\n        return id;\\n    }\\n```\\n```\\n public String smallestEquivalentString(String s1, String s2, String base) {\\n        int A[] = new int[26];\\n        for(int i=0;i<26;i++)A[i]=i;\\n        for(int i=0;i<s1.length();i++){\\n            int p1=find(s1.charAt(i)-\\'a\\',A),p2=find(s2.charAt(i)-\\'a\\',A);\\n            if(p1<p2)A[p2]=p1;\\n            else A[p1]=p2;\\n        } StringBuilder sb= new StringBuilder();\\n        for(var c:base.toCharArray()) sb.append((char)(\\'a\\'+find(c-\\'a\\',A)));\\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    public String smallestEquivalentString(String s1, String s2, String base) {\\n        int A[] = IntStream.range(0,26).toArray();\\n        for(int i=0;i<s1.length();i++){\\n            int p1=find(s1.charAt(i)-\\'a\\',A),p2=find(s2.charAt(i)-\\'a\\',A);\\n            if(p1<p2)A[p2]=p1;\\n            else A[p1]=p2;\\n        }\\n        return base.chars().mapToObj(c->String.valueOf((char)(\\'a\\'+find(c-\\'a\\',A)))).collect(Collectors.joining());\\n    }    \\n```\n```\\nprivate int find(int id,int[] A){\\n        while(A[id]!=id) id=A[id];\\n        return id;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3047601,
                "title": "simple-solution-by-using-array-and-with-100-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String A, String B, String S) {\\n        int[] graph = new int[26];\\n        for(int i = 0; i < 26; i++) {\\n            graph[i] = i;\\n        }\\n        for(int i = 0; i < A.length(); i++) {\\n            int a = A.charAt(i) - \\'a\\';\\n            int b = B.charAt(i) - \\'a\\';\\n            int end1 = find(graph, b);\\n            int end2 = find(graph, a);\\n            if(end1 < end2) {\\n                graph[end2] = end1;\\n            } else {\\n                graph[end1] = end2;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < S.length(); i++) {\\n            char c = S.charAt(i);\\n            sb.append((char)(\\'a\\' + find(graph, c - \\'a\\')));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int[] graph, int index) {\\n        while(graph[index] != index) {\\n            index = graph[index];\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String A, String B, String S) {\\n        int[] graph = new int[26];\\n        for(int i = 0; i < 26; i++) {\\n            graph[i] = i;\\n        }\\n        for(int i = 0; i < A.length(); i++) {\\n            int a = A.charAt(i) - \\'a\\';\\n            int b = B.charAt(i) - \\'a\\';\\n            int end1 = find(graph, b);\\n            int end2 = find(graph, a);\\n            if(end1 < end2) {\\n                graph[end2] = end1;\\n            } else {\\n                graph[end1] = end2;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < S.length(); i++) {\\n            char c = S.charAt(i);\\n            sb.append((char)(\\'a\\' + find(graph, c - \\'a\\')));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int[] graph, int index) {\\n        while(graph[index] != index) {\\n            index = graph[index];\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598732,
                "title": "swift-bfs",
                "content": "```\\nclass Solution {\\n    func smallestEquivalentString(_ s1: String, _ s2: String, _ baseStr: String) -> String {\\n        \\n        // Create adjacency list \\n        var neighbors: [Character: Set<Character>] = [:]\\n        \\n        // Fill adj list\\n        for (c1, c2) in zip(s1, s2) {\\n            neighbors[c1, default: []].insert(c2)\\n            neighbors[c2, default: []].insert(c1)\\n        }\\n        \\n        // Memoize Characters\\n        var memo = [Character: Character]()\\n        \\n        // BFS character to get the lexicographically smallest equivalent character \\n        func bfs(_ char: Character) -> Character {\\n            guard memo[char] == nil else { return memo[char]! }    \\n            var res = char\\n            var seen = Set<Character>()\\n            var queue = [Character]([char])\\n            while queue.count > 0 {\\n                let c = queue.removeFirst() \\n                if seen.contains(c) {\\n                    continue\\n                } else {\\n                    seen.insert(c)\\n                }\\n                \\n                // result is the minimum of res and any character the bfs path can lead to\\n                res = min(res, c)\\n                \\n                for neighbor in neighbors[c] ?? [] {\\n                    queue.append(neighbor)\\n                }\\n                \\n            }\\n            // This is the path of a specific character. Therefore all characters in this path are equivalent by transitivity.\\n            // Memo all seen characters with the resulting character (AKA the lowest lexicograpgic character)\\n            for v in seen {\\n                memo[v] = res\\n            }\\n            return res\\n        }\\n\\n        // Get the result in string format to return\\n        var res = \"\"\\n        for c in baseStr {\\n            res += String(bfs(c))\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func smallestEquivalentString(_ s1: String, _ s2: String, _ baseStr: String) -> String {\\n        \\n        // Create adjacency list \\n        var neighbors: [Character: Set<Character>] = [:]\\n        \\n        // Fill adj list\\n        for (c1, c2) in zip(s1, s2) {\\n            neighbors[c1, default: []].insert(c2)\\n            neighbors[c2, default: []].insert(c1)\\n        }\\n        \\n        // Memoize Characters\\n        var memo = [Character: Character]()\\n        \\n        // BFS character to get the lexicographically smallest equivalent character \\n        func bfs(_ char: Character) -> Character {\\n            guard memo[char] == nil else { return memo[char]! }    \\n            var res = char\\n            var seen = Set<Character>()\\n            var queue = [Character]([char])\\n            while queue.count > 0 {\\n                let c = queue.removeFirst() \\n                if seen.contains(c) {\\n                    continue\\n                } else {\\n                    seen.insert(c)\\n                }\\n                \\n                // result is the minimum of res and any character the bfs path can lead to\\n                res = min(res, c)\\n                \\n                for neighbor in neighbors[c] ?? [] {\\n                    queue.append(neighbor)\\n                }\\n                \\n            }\\n            // This is the path of a specific character. Therefore all characters in this path are equivalent by transitivity.\\n            // Memo all seen characters with the resulting character (AKA the lowest lexicograpgic character)\\n            for v in seen {\\n                memo[v] = res\\n            }\\n            return res\\n        }\\n\\n        // Get the result in string format to return\\n        var res = \"\"\\n        for c in baseStr {\\n            res += String(bfs(c))\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162573,
                "title": "c-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int parent[26];\\n    \\n    int find(int x){\\n        if(parent[x]==-1) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if (x != y) \\n            parent[max(x, y)] = min(x, y); // making the parent of larger character by ASCII as the smaller one\\n    }\\n\\t\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        memset(parent, -1, sizeof(parent));\\n        \\n        for (auto i = 0; i < s1.size(); ++i) \\n            Union(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        \\n        for(auto i=0;i<baseStr.size();i++) \\n            baseStr[i]=find(baseStr[i]-\\'a\\')+\\'a\\';\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int parent[26];\\n    \\n    int find(int x){\\n        if(parent[x]==-1) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if (x != y) \\n            parent[max(x, y)] = min(x, y); // making the parent of larger character by ASCII as the smaller one\\n    }\\n\\t\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        memset(parent, -1, sizeof(parent));\\n        \\n        for (auto i = 0; i < s1.size(); ++i) \\n            Union(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        \\n        for(auto i=0;i<baseStr.size();i++) \\n            baseStr[i]=find(baseStr[i]-\\'a\\')+\\'a\\';\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758668,
                "title": "javascript-solution-union-find-approach",
                "content": "```\\nvar smallestEquivalentString = function(s1, s2, baseStr) {\\n    const uf = {};\\n   \\n    for (let i = 0; i < s1.length; i++) {\\n        const char1 = s1.charAt(i);\\n        const char2 = s2.charAt(i);\\n        \\n        if (uf[char1] == null) uf[char1] = char1;\\n        if (uf[char2] == null) uf[char2] = char2;\\n        \\n        union(char1, char2);\\n    }\\n    \\n    function find(x) {\\n        if (uf[x] != x) uf[x] = find(uf[x]);\\n        return uf[x];\\n    }\\n    \\n    function union(x, y) {\\n        const rootX = find(x);\\n        const rootY = find(y);\\n        \\n        if (rootX == rootY) return;\\n        \\n        if (rootX < rootY) uf[rootY] = rootX;\\n        else uf[rootX] = rootY;\\n        \\n        return;\\n    }\\n   \\n    let res = \"\";\\n    \\n    for (const char of baseStr) {\\n        const root = find(char);\\n        \\n        if (root == null) res += char; \\n        else res += root;\\n    } \\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nvar smallestEquivalentString = function(s1, s2, baseStr) {\\n    const uf = {};\\n   \\n    for (let i = 0; i < s1.length; i++) {\\n        const char1 = s1.charAt(i);\\n        const char2 = s2.charAt(i);\\n        \\n        if (uf[char1] == null) uf[char1] = char1;\\n        if (uf[char2] == null) uf[char2] = char2;\\n        \\n        union(char1, char2);\\n    }\\n    \\n    function find(x) {\\n        if (uf[x] != x) uf[x] = find(uf[x]);\\n        return uf[x];\\n    }\\n    \\n    function union(x, y) {\\n        const rootX = find(x);\\n        const rootY = find(y);\\n        \\n        if (rootX == rootY) return;\\n        \\n        if (rootX < rootY) uf[rootY] = rootX;\\n        else uf[rootX] = rootY;\\n        \\n        return;\\n    }\\n   \\n    let res = \"\";\\n    \\n    for (const char of baseStr) {\\n        const root = find(char);\\n        \\n        if (root == null) res += char; \\n        else res += root;\\n    } \\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1308884,
                "title": "java-union-find-1ms-beats-100",
                "content": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int i, N = s1.length();\\n        \\n        char[] parent = new char[26];\\n        for(i = 0; i < 26; i++){\\n            parent[i] = (char)(\\'a\\' + i);\\n        }\\n        \\n        for(i = 0; i < N; i++){\\n            union(s1.charAt(i), s2.charAt(i), parent);\\n        }\\n        \\n        StringBuilder builder = new StringBuilder();\\n        N = baseStr.length();\\n        \\n        for(i = 0; i < N; i++){\\n            builder.append(find(baseStr.charAt(i), parent));\\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    private void union(char x, char y, char[] parent){\\n        char p1 = find(x, parent);\\n        char p2 = find(y, parent);\\n        \\n        if(p1 != p2){\\n            if(p1 < p2)\\n                parent[p2 - \\'a\\'] = p1;\\n            else\\n                parent[p1 - \\'a\\'] = p2;\\n        }\\n    }\\n    \\n    private char find(char ch, char[] parent){\\n        char x = ch;\\n        \\n        while(x != parent[x - \\'a\\']){\\n            x = parent[x - \\'a\\'];\\n        }\\n        \\n        parent[ch - \\'a\\'] = x;\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int i, N = s1.length();\\n        \\n        char[] parent = new char[26];\\n        for(i = 0; i < 26; i++){\\n            parent[i] = (char)(\\'a\\' + i);\\n        }\\n        \\n        for(i = 0; i < N; i++){\\n            union(s1.charAt(i), s2.charAt(i), parent);\\n        }\\n        \\n        StringBuilder builder = new StringBuilder();\\n        N = baseStr.length();\\n        \\n        for(i = 0; i < N; i++){\\n            builder.append(find(baseStr.charAt(i), parent));\\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    private void union(char x, char y, char[] parent){\\n        char p1 = find(x, parent);\\n        char p2 = find(y, parent);\\n        \\n        if(p1 != p2){\\n            if(p1 < p2)\\n                parent[p2 - \\'a\\'] = p1;\\n            else\\n                parent[p1 - \\'a\\'] = p2;\\n        }\\n    }\\n    \\n    private char find(char ch, char[] parent){\\n        char x = ch;\\n        \\n        while(x != parent[x - \\'a\\']){\\n            x = parent[x - \\'a\\'];\\n        }\\n        \\n        parent[ch - \\'a\\'] = x;\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012322,
                "title": "java-straightforward-union-find-solution",
                "content": "```\\nclass UF {\\n    int[] parent;\\n    int[] min;\\n    \\n    public UF() {\\n        parent = new int[26];\\n        min = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            parent[i] = i;\\n            min[i] = i;\\n        }\\n    }\\n    \\n    public int find(int x, int mi) {\\n        if (parent[x] == x) {\\n            min[x] = Math.min(min[x], mi);\\n            return x;\\n        }\\n        return parent[x] = find(parent[x], Math.min(parent[x], mi));\\n    }\\n    \\n    public void union(int x, int y) {\\n        int px = find(x, x);\\n        int py = find(y, y);\\n        parent[px] = py;\\n        min[py] = Math.min(min[py], min[px]);\\n    }\\n}\\n\\nclass Solution {\\n    public String smallestEquivalentString(String A, String B, String S) {\\n        UF uf = new UF();\\n        int n = A.length();\\n        for (int i = 0; i < n; i++) {\\n            uf.union(A.charAt(i) - \\'a\\', B.charAt(i) - \\'a\\');\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < S.length(); i++) {\\n            char rep = (char)(uf.min[uf.find(S.charAt(i) - \\'a\\', S.charAt(i) - \\'a\\')] + \\'a\\');\\n            sb.append(rep);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UF {\\n    int[] parent;\\n    int[] min;\\n    \\n    public UF() {\\n        parent = new int[26];\\n        min = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            parent[i] = i;\\n            min[i] = i;\\n        }\\n    }\\n    \\n    public int find(int x, int mi) {\\n        if (parent[x] == x) {\\n            min[x] = Math.min(min[x], mi);\\n            return x;\\n        }\\n        return parent[x] = find(parent[x], Math.min(parent[x], mi));\\n    }\\n    \\n    public void union(int x, int y) {\\n        int px = find(x, x);\\n        int py = find(y, y);\\n        parent[px] = py;\\n        min[py] = Math.min(min[py], min[px]);\\n    }\\n}\\n\\nclass Solution {\\n    public String smallestEquivalentString(String A, String B, String S) {\\n        UF uf = new UF();\\n        int n = A.length();\\n        for (int i = 0; i < n; i++) {\\n            uf.union(A.charAt(i) - \\'a\\', B.charAt(i) - \\'a\\');\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < S.length(); i++) {\\n            char rep = (char)(uf.min[uf.find(S.charAt(i) - \\'a\\', S.charAt(i) - \\'a\\')] + \\'a\\');\\n            sb.append(rep);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963221,
                "title": "python-uf",
                "content": "The key to solving this problem is modifying the `union` method to prefer the lexicographically smaller parent when combining `x` and `y`. This way, calling `find` on any character should return the smallest character in that connected component.\\n\\n```python\\nimport string\\n\\nclass UF(object):\\n    def __init__(self):\\n        self.parents = {c: c for c in string.ascii_lowercase}\\n        self.groups = len(string.ascii_lowercase)\\n    \\n    def find(self, x):\\n        while x != self.parents[x]:\\n            x = self.parents[x]\\n        return x\\n    \\n    def union(self, x, y):\\n        parent_x, parent_y = self.find(x), self.find(y)\\n        if parent_x != parent_y:\\n            sm, lg = sorted([parent_x, parent_y])\\n            self.parents[lg] = sm\\n            self.groups -= 1\\n\\nclass Solution:\\n    def smallestEquivalentString(self, A: str, B: str, S: str) -> str:\\n        uf = UF()\\n        n = len(A)\\n        for i in range(n):\\n            uf.union(A[i], B[i])\\n        return \\'\\'.join([uf.find(c) for c in S])\\n```",
                "solutionTags": [],
                "code": "```python\\nimport string\\n\\nclass UF(object):\\n    def __init__(self):\\n        self.parents = {c: c for c in string.ascii_lowercase}\\n        self.groups = len(string.ascii_lowercase)\\n    \\n    def find(self, x):\\n        while x != self.parents[x]:\\n            x = self.parents[x]\\n        return x\\n    \\n    def union(self, x, y):\\n        parent_x, parent_y = self.find(x), self.find(y)\\n        if parent_x != parent_y:\\n            sm, lg = sorted([parent_x, parent_y])\\n            self.parents[lg] = sm\\n            self.groups -= 1\\n\\nclass Solution:\\n    def smallestEquivalentString(self, A: str, B: str, S: str) -> str:\\n        uf = UF()\\n        n = len(A)\\n        for i in range(n):\\n            uf.union(A[i], B[i])\\n        return \\'\\'.join([uf.find(c) for c in S])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483282,
                "title": "javascript-union-find-with-path-compression",
                "content": "Complexity:\\n* Time: O(max(n, m)) where n is length of A, and m is length of S.\\n* Space: O(1) because we are only storing 26 characters.\\n\\n```javascript\\nvar smallestEquivalentString = function(A, B, S) {\\n    const set = new DisjointSet()\\n    \\n    for (let i = 0; i < A.length; i++) {\\n        const aPos = posForChar(A[i])\\n        const bPos = posForChar(B[i])\\n        set.union(aPos, bPos)\\n    }\\n    \\n    const result = []\\n    for (const char of S) {\\n        const sPos = posForChar(char)\\n        const parent = set.find(sPos)\\n        result.push(charForPos(parent))\\n    }\\n    \\n    return result.join(\\'\\')\\n};\\n\\nclass DisjointSet {\\n    constructor() {\\n        this.parent = []\\n        for (let i = 0; i < 26; i++)\\n            this.parent[i] = i\\n    }\\n    \\n    find(p) {\\n        let root = p\\n        while (root !== this.parent[root])\\n            root = this.parent[root]\\n        \\n        while (p !== root) {\\n            const next = this.parent[p]\\n            this.parent[p] = root\\n            p = next\\n        }\\n        \\n        return root\\n    }\\n    \\n    union(p, q) {\\n        const rootP = this.find(p)\\n        const rootQ = this.find(q)\\n        \\n        if (rootP === rootQ) return\\n        \\n        if (rootP > rootQ) {\\n            this.parent[rootP] = rootQ\\n        } else {\\n            this.parent[rootQ] = rootP\\n        }\\n    }\\n}\\n\\nconst posForChar = char => char.charCodeAt(0) - \\'a\\'.charCodeAt(0)\\nconst charForPos = pos => String.fromCharCode(pos + \\'a\\'.charCodeAt(0))\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```javascript\\nvar smallestEquivalentString = function(A, B, S) {\\n    const set = new DisjointSet()\\n    \\n    for (let i = 0; i < A.length; i++) {\\n        const aPos = posForChar(A[i])\\n        const bPos = posForChar(B[i])\\n        set.union(aPos, bPos)\\n    }\\n    \\n    const result = []\\n    for (const char of S) {\\n        const sPos = posForChar(char)\\n        const parent = set.find(sPos)\\n        result.push(charForPos(parent))\\n    }\\n    \\n    return result.join(\\'\\')\\n};\\n\\nclass DisjointSet {\\n    constructor() {\\n        this.parent = []\\n        for (let i = 0; i < 26; i++)\\n            this.parent[i] = i\\n    }\\n    \\n    find(p) {\\n        let root = p\\n        while (root !== this.parent[root])\\n            root = this.parent[root]\\n        \\n        while (p !== root) {\\n            const next = this.parent[p]\\n            this.parent[p] = root\\n            p = next\\n        }\\n        \\n        return root\\n    }\\n    \\n    union(p, q) {\\n        const rootP = this.find(p)\\n        const rootQ = this.find(q)\\n        \\n        if (rootP === rootQ) return\\n        \\n        if (rootP > rootQ) {\\n            this.parent[rootP] = rootQ\\n        } else {\\n            this.parent[rootQ] = rootP\\n        }\\n    }\\n}\\n\\nconst posForChar = char => char.charCodeAt(0) - \\'a\\'.charCodeAt(0)\\nconst charForPos = pos => String.fromCharCode(pos + \\'a\\'.charCodeAt(0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303631,
                "title": "python-graph-search-with-memoization",
                "content": "Create a mapping from each char to its direct equivalents.\\nFor each char of S, explore the map of all equivalents and set the minimum equivalent of all chars visited.\\nMemoize the minimum equivalents.\\n\\n\\n```\\n    def smallestEquivalentString(self, A, B, S):\\n\\t\\n        equivalents = defaultdict(set)  # map char to its directly connected equivalents\\n        for a, b in zip(A, B):\\n            equivalents[a].add(b)\\n            equivalents[b].add(a)\\n\\n        minimum = {}                    # map char to its minimum equivalent\\n\\n        def get_minimum(char):          # return the minimum equivalent\\n            if char in minimum:\\n                return minimum[char]\\n\\n            result = char\\n            visited = set()\\n            queue = {char}\\n\\n            while queue:\\n                c = queue.pop()\\n                if c in visited:\\n                    continue\\n                visited.add(c)\\n                result = min(result, c)\\n                queue |= equivalents[c]\\n\\n            for v in visited:       # minimum equivalent for all visited is set to result\\n                minimum[v] = result\\n            return result\\n\\n        return \"\".join(get_minimum(c) for c in S)\\n```",
                "solutionTags": [],
                "code": "```\\n    def smallestEquivalentString(self, A, B, S):\\n\\t\\n        equivalents = defaultdict(set)  # map char to its directly connected equivalents\\n        for a, b in zip(A, B):\\n            equivalents[a].add(b)\\n            equivalents[b].add(a)\\n\\n        minimum = {}                    # map char to its minimum equivalent\\n\\n        def get_minimum(char):          # return the minimum equivalent\\n            if char in minimum:\\n                return minimum[char]\\n\\n            result = char\\n            visited = set()\\n            queue = {char}\\n\\n            while queue:\\n                c = queue.pop()\\n                if c in visited:\\n                    continue\\n                visited.add(c)\\n                result = min(result, c)\\n                queue |= equivalents[c]\\n\\n            for v in visited:       # minimum equivalent for all visited is set to result\\n                minimum[v] = result\\n            return result\\n\\n        return \"\".join(get_minimum(c) for c in S)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3884764,
                "title": "optimized-approach-using-disjointset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can think of this problem as a problem of finding disjoint sets of characters. Characters that are equivalent form connected components, and we want to find the smallest character within each connected component to represent the entire component.\\nWe\\'ll use a disjoint set data structure to efficiently manage the connected components. The DisjointSet class will help us keep track of which characters are equivalent and which character is the representative (smallest) character for each connected component.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Disjoint Set Setup:**\\n\\nCreate a DisjointSet instance with a size of 26 (assuming lowercase English alphabets). This set will represent the connected components of equivalent characters.\\nInitialize each character as its own parent in the disjoint set, and set the size of each component to 1.\\nProcess Equivalent Pairs:\\n\\nIterate through each character index i from 0 to the length of s1 (or s2), where s1[i] and s2[i] represent equivalent characters.\\nFor each pair (s1[i], s2[i]), call the unionBySmallerSize method of the DisjointSet to merge the components of characters s1[i] - \\'a\\' and s2[i] - \\'a\\'.\\nThis operation ensures that characters in the same connected component will have the same representative character, which is the smallest character in that component.\\n\\n**Building Equivalent String:**\\n\\nNow that we\\'ve established the relationships between equivalent characters using the disjoint set, we can construct the smallest equivalent string for baseStr.\\nIterate through each character c in baseStr.\\nFind the representative character of the connected component that c belongs to using the findUPar method of the disjoint set.\\nAppend the representative character to the final answer string.\\nOutput:\\n\\nThe final answer string contains the smallest equivalent string for the given baseStr based on the equivalent character pairs from s1 and s2.\\nReturn the answer string as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n+m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass DisjointSet {\\n    public:\\n        vector<int> parent,size;\\n\\n        DisjointSet(int n) {\\n            parent.resize(n);\\n            size.resize(n);\\n\\n            for(int i=0;i<n;i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        int findUPar(int node) {\\n            if(parent[node] == node)\\n                return node;\\n\\n            return parent[node] = findUPar(parent[node]);\\n        }\\n\\n\\n        void unionBySmallerSize(int u,int v) {\\n            int ultU = findUPar(u);\\n            int ultV = findUPar(v);\\n\\n            if(ultU == ultV)\\n                return;\\n\\n            if(ultU < ultV) {\\n                parent[ultV] = ultU;\\n            }\\n            else {\\n                parent[ultU] = ultV;\\n            }\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DisjointSet ds(26);\\n\\n        int n = s1.length();\\n\\n        for(int i=0;i<n;i++) {\\n            int char1 = s1[i] - \\'a\\';\\n            int char2 = s2[i] - \\'a\\';\\n\\n            ds.unionBySmallerSize(char1,char2);\\n        }\\n\\n\\n        string ans;\\n\\n        for(char it : baseStr) {\\n            int tempInd = ds.findUPar(it-\\'a\\');\\n\\n            char temp = (char)(tempInd + \\'a\\');\\n\\n            ans += temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet {\\n    public:\\n        vector<int> parent,size;\\n\\n        DisjointSet(int n) {\\n            parent.resize(n);\\n            size.resize(n);\\n\\n            for(int i=0;i<n;i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        int findUPar(int node) {\\n            if(parent[node] == node)\\n                return node;\\n\\n            return parent[node] = findUPar(parent[node]);\\n        }\\n\\n\\n        void unionBySmallerSize(int u,int v) {\\n            int ultU = findUPar(u);\\n            int ultV = findUPar(v);\\n\\n            if(ultU == ultV)\\n                return;\\n\\n            if(ultU < ultV) {\\n                parent[ultV] = ultU;\\n            }\\n            else {\\n                parent[ultU] = ultV;\\n            }\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DisjointSet ds(26);\\n\\n        int n = s1.length();\\n\\n        for(int i=0;i<n;i++) {\\n            int char1 = s1[i] - \\'a\\';\\n            int char2 = s2[i] - \\'a\\';\\n\\n            ds.unionBySmallerSize(char1,char2);\\n        }\\n\\n\\n        string ans;\\n\\n        for(char it : baseStr) {\\n            int tempInd = ds.findUPar(it-\\'a\\');\\n\\n            char temp = (char)(tempInd + \\'a\\');\\n\\n            ans += temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814673,
                "title": "union-find-clean-code-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<int> parent(26);\\n        iota(parent.begin(), parent.end(), 0);\\n\\n        for (int i = 0; i < s1.size(); i++)\\n        {\\n            doUnion(parent, s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        }\\n\\n        string ans = \"\";\\n        for (int i = 0; i < baseStr.size(); i++)\\n        {\\n            ans += doFind(parent, baseStr[i] - \\'a\\') + \\'a\\';\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int doFind(vector<int>& par, int n)\\n    {\\n        if (par[n] != n)\\n            par[n] = doFind(par, par[n]);\\n        \\n        return par[n];\\n    }\\n    void doUnion(vector<int>& par, int n1, int n2)\\n    {\\n        int p1 = doFind(par, n1);\\n        int p2 = doFind(par, n2);\\n\\n        if (p1 == p2)\\n            return ;\\n        \\n        if (p1 < p2)\\n            par[p2] = p1;\\n        else\\n            par[p1] = p2;\\n        \\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<int> parent(26);\\n        iota(parent.begin(), parent.end(), 0);\\n\\n        for (int i = 0; i < s1.size(); i++)\\n        {\\n            doUnion(parent, s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        }\\n\\n        string ans = \"\";\\n        for (int i = 0; i < baseStr.size(); i++)\\n        {\\n            ans += doFind(parent, baseStr[i] - \\'a\\') + \\'a\\';\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int doFind(vector<int>& par, int n)\\n    {\\n        if (par[n] != n)\\n            par[n] = doFind(par, par[n]);\\n        \\n        return par[n];\\n    }\\n    void doUnion(vector<int>& par, int n1, int n2)\\n    {\\n        int p1 = doFind(par, n1);\\n        int p2 = doFind(par, n2);\\n\\n        if (p1 == p2)\\n            return ;\\n        \\n        if (p1 < p2)\\n            par[p2] = p1;\\n        else\\n            par[p1] = p2;\\n        \\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637541,
                "title": "dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    char dfs(unordered_map<char,string> &mp, vector<bool> &v, char c)\\n    {\\n        \\n        v[c-\\'a\\'] = true;\\n        char res = c;\\n        for(int i=0;i<mp[c].length();i++)\\n        {\\n            \\n            if(!v[mp[c][i]-\\'a\\'])\\n            {\\n                res = min(dfs(mp,v,mp[c][i]),res);\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    string smallestEquivalentString(string s1, string s2, string bs) {\\n        int n = s1.length();\\n        \\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            char u = s1[i];\\n            char v = s2[i];\\n            \\n            mp[u].push_back(v);\\n            mp[v].push_back(u);\\n        }\\n        \\n        string res = \"\";\\n        for(int i = 0;i<bs.length();i++)\\n        {\\n            vector<bool> vis(26,0);\\n            char c = dfs(mp,vis,bs[i]);\\n            res.push_back(c);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    char dfs(unordered_map<char,string> &mp, vector<bool> &v, char c)\\n    {\\n        \\n        v[c-\\'a\\'] = true;\\n        char res = c;\\n        for(int i=0;i<mp[c].length();i++)\\n        {\\n            \\n            if(!v[mp[c][i]-\\'a\\'])\\n            {\\n                res = min(dfs(mp,v,mp[c][i]),res);\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    string smallestEquivalentString(string s1, string s2, string bs) {\\n        int n = s1.length();\\n        \\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            char u = s1[i];\\n            char v = s2[i];\\n            \\n            mp[u].push_back(v);\\n            mp[v].push_back(u);\\n        }\\n        \\n        string res = \"\";\\n        for(int i = 0;i<bs.length();i++)\\n        {\\n            vector<bool> vis(26,0);\\n            char c = dfs(mp,vis,bs[i]);\\n            res.push_back(c);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124287,
                "title": "java-dfs-with-memoization-fastest-dfs-possible-explained",
                "content": "```\\nclass Solution {\\n   // dfs approach \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        HashMap<Character, List<Character>> map = new HashMap<>();\\n        \\n        // making the graph using hashmap, can also use array of size 26 and djacency list for map\\n        for(int i =0;i<s1.length();i++)\\n        {\\n            char u = s1.charAt(i);\\n            char v = s2.charAt(i);\\n         if(map.get(u) == null)\\n         {\\n             map.put(u, new ArrayList<>());\\n         }\\n         if(map.get(v) == null)\\n         {\\n             map.put(v, new ArrayList<>());\\n         }\\n            if(u!=v)// just to avoid repeating characters in graph\\n            {\\n                 map.get(u).add(v);\\n               map.get(v).add(u);\\n            }\\n\\n        }\\n     \\n        // string builder is imp or will give TLE \\n        StringBuilder sb = new StringBuilder();\\n        // memo hasmap to optimize time and space \\n       HashMap<Character, Character> memo = new HashMap<>();\\n        // calling the dfs on every character of baseStr\\n        for(int i=0;i<baseStr.length();i++)\\n        {\\n             char currChar = baseStr.charAt(i);\\n            // every time new visited array is created or will hav to backtrack if dedclared outside the for loop\\n             boolean visited[]  = new boolean[26];\\n            // will get the max on very dfs run \\n            char max [] = new char[1];\\n            max[0] = currChar;\\n            // we apply the memo hashmap in this for loop and not in the dfs function (if we implement in dfs function\\n            // lot of tcs will fail )\\n            if(memo.get(currChar)!=null){\\n                 sb.append(memo.get(currChar));\\n                continue;\\n            }\\n            // calling recursive function \\n            dfs(map, baseStr, currChar, max, visited);\\n            // store the max in memo w.r.t to currChar in memo map\\n            memo.put(currChar, max[0]);\\n            // make the answer \\n            sb.append(max[0]);\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n    // simple DFS function\\n    public void dfs( HashMap<Character,List<Character>> map, String baseStr, char ch, char [] max, boolean [] visited)\\n    {\\n        if(map.get(ch)==null)\\n            return;\\n        \\n        visited[ch -\\'a\\'] = true;\\n        \\n          for(char child : map.get(ch) )\\n          {\\n            \\n              if(visited[child-\\'a\\'] == false)\\n              {\\n                   dfs(map, baseStr,child,max, visited ); \\n                  // comparing the max value\\n                  // can be before the dfs call or after makes no difference in this question\\n                if(child<max[0])\\n                {\\n                        max[0] = child;\\n                }\\n                  \\n              }\\n                             \\n          }\\n\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution {\\n   // dfs approach \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        HashMap<Character, List<Character>> map = new HashMap<>();\\n        \\n        // making the graph using hashmap, can also use array of size 26 and djacency list for map\\n        for(int i =0;i<s1.length();i++)\\n        {\\n            char u = s1.charAt(i);\\n            char v = s2.charAt(i);\\n         if(map.get(u) == null)\\n         {\\n             map.put(u, new ArrayList<>());\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3056358,
                "title": "swift-solution-beats-100-disjoint-set",
                "content": "# Complexity\\n- Time complexity: $$O(n\\\\log(n) + m)$$, where $$n$$ is the length of string $$s1$$, $$m$$ is the length of string $$baseStr$$. Because the length of $$s2$$ is the same as $$s1$$, meaning $$2\\\\cdot s1$$, we can omit contant $$2$$ in big $$O$$ notation.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func smallestEquivalentString(_ s1: String, _ s2: String, _ baseStr: String) -> String {\\n        let s1 = Array(s1)\\n        let s2 = Array(s2)\\n\\n        var hashMapIdAttachedToLetters: [Int: Set<Character>] = [:]\\n        var hashMapLetterAttachedToId: [Character: Int] = [:]\\n\\n        for i in 0..<s1.count {\\n            let idS1 = hashMapLetterAttachedToId[s1[i]]\\n            let idS2 = hashMapLetterAttachedToId[s2[i]]\\n\\n            switch (idS1, idS2) {\\n            case (nil, nil):\\n                hashMapLetterAttachedToId[s1[i]] = i\\n                hashMapLetterAttachedToId[s2[i]] = i\\n                hashMapIdAttachedToLetters[i] = [s1[i], s2[i]]\\n            case (let idS1?, nil):\\n                hashMapLetterAttachedToId[s2[i]] = idS1\\n                hashMapIdAttachedToLetters[idS1]!.insert(s2[i])\\n            case (nil, let idS2?):\\n                hashMapLetterAttachedToId[s1[i]] = idS2\\n                hashMapIdAttachedToLetters[idS2]!.insert(s1[i])\\n            case (let idS1?, let idS2?):\\n                if idS1 == idS2 { continue }\\n\\n                let (idFrom, idTo) = hashMapIdAttachedToLetters[idS1]!.count < hashMapIdAttachedToLetters[idS2]!.count ? (idS1, idS2) : (idS2, idS1)\\n\\n                for letter in hashMapIdAttachedToLetters[idFrom]! {\\n                    hashMapIdAttachedToLetters[idTo]!.insert(letter)\\n                    hashMapLetterAttachedToId[letter] = idTo\\n                }\\n\\n                hashMapIdAttachedToLetters[idFrom] = nil\\n            }\\n        }\\n\\n        var sortedHashMap: [Int: [Character]] = [:]\\n        hashMapIdAttachedToLetters.forEach { id, letters in\\n            sortedHashMap[id] = Array(letters).sorted()\\n        }\\n\\n        var result = \"\"\\n        for c in baseStr {\\n            let id = hashMapLetterAttachedToId[c]\\n\\n            if id == nil {\\n                result += String(c)\\n            } else {\\n                result += String(sortedHashMap[id!]!.first!)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func smallestEquivalentString(_ s1: String, _ s2: String, _ baseStr: String) -> String {\\n        let s1 = Array(s1)\\n        let s2 = Array(s2)\\n\\n        var hashMapIdAttachedToLetters: [Int: Set<Character>] = [:]\\n        var hashMapLetterAttachedToId: [Character: Int] = [:]\\n\\n        for i in 0..<s1.count {\\n            let idS1 = hashMapLetterAttachedToId[s1[i]]\\n            let idS2 = hashMapLetterAttachedToId[s2[i]]\\n\\n            switch (idS1, idS2) {\\n            case (nil, nil):\\n                hashMapLetterAttachedToId[s1[i]] = i\\n                hashMapLetterAttachedToId[s2[i]] = i\\n                hashMapIdAttachedToLetters[i] = [s1[i], s2[i]]\\n            case (let idS1?, nil):\\n                hashMapLetterAttachedToId[s2[i]] = idS1\\n                hashMapIdAttachedToLetters[idS1]!.insert(s2[i])\\n            case (nil, let idS2?):\\n                hashMapLetterAttachedToId[s1[i]] = idS2\\n                hashMapIdAttachedToLetters[idS2]!.insert(s1[i])\\n            case (let idS1?, let idS2?):\\n                if idS1 == idS2 { continue }\\n\\n                let (idFrom, idTo) = hashMapIdAttachedToLetters[idS1]!.count < hashMapIdAttachedToLetters[idS2]!.count ? (idS1, idS2) : (idS2, idS1)\\n\\n                for letter in hashMapIdAttachedToLetters[idFrom]! {\\n                    hashMapIdAttachedToLetters[idTo]!.insert(letter)\\n                    hashMapLetterAttachedToId[letter] = idTo\\n                }\\n\\n                hashMapIdAttachedToLetters[idFrom] = nil\\n            }\\n        }\\n\\n        var sortedHashMap: [Int: [Character]] = [:]\\n        hashMapIdAttachedToLetters.forEach { id, letters in\\n            sortedHashMap[id] = Array(letters).sorted()\\n        }\\n\\n        var result = \"\"\\n        for c in baseStr {\\n            let id = hashMapLetterAttachedToId[c]\\n\\n            if id == nil {\\n                result += String(c)\\n            } else {\\n                result += String(sortedHashMap[id!]!.first!)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055351,
                "title": "swift-single-pass-two-maps-beats-100",
                "content": "# Intuition\\n\\nWhile DSU and DFS are fine solutions, these were not my first intuition. I assumed we could do this in a **single pass** using two maps if we were able to keep track of the \"order\" (grouping in which each letter resides) and *apply changes transitively*.\\n\\n# Approach\\n\\nIf we are going to make a single pass work, we\\'d need to keep track of a couple things to be able to construct the final string.\\n\\n1. We need to assign each new letter an order. Let\\'s use a map of `Character: Int`. **When a character transitively gets a new order, we can update it in $$O(n)$$ time.**\\n2. We need to transitively apply updates to the letter in each order. Let\\'s use a map of `Int: [Character]`. **When an order of characters are assigned a new order, it\\'ll be at worst $$O(m)$$ time, where m is the length of the largest order.**\\n\\n## Building the maps\\n\\nEach iteration, we pluck out the characters from each string and handle the following scenarios\\n- If the characters are the same continue\\n- If both characters are new, add them to the current order; increment the highest order\\n- If the first character is new, but the second character exists, give the first character the order of the second; increment the highest order\\n- If the first character is not new, but the second character is, give the second character the order of the first; increment the highest order\\n- If both characters exist but do not have the same order, we need to transitively update one order to the other\\n\\n## Finding the lowest characters for each order\\n\\nWith both maps in tow, we now figure out the lowest character for each order and store this in a Character array. Iterate from 0 to highest order, and then from \\'a\\' to \\'z\\' - as soon as we find a character that exists, we insert it at `superlatives[order]` and move on to the next order.\\n\\n## Construct the resulting string\\n\\nWith the superlatives, we can construct the result. Iterate through each character\\n- if the character doesn\\'t exist, append it to the result\\n- otherwise, find the order the character resides in and append the superlative character for that order\\n\\n# Complexity\\nTime complexity:\\n1. $$O(n*m)$$ Building the two maps in a single pass, where $$n$$ is the length of the input strings and $$m$$ is the length of the longest order\\n2. $$O(n)$$ Finding the lowest character for each order - at worst we have the same number of orders as we do orders.\\n3. $$O(p)$$ Constructing the result, where $$p$$ is the length of the base string.\\n\\nTotal: $$O(m*n+n+p) = O(m*n+p)$$\\n\\nSpace complexity:\\n\\n$$O(m*n+p)$$ - storing the orders of both input strings\\n\\n# Code\\n```\\nclass Solution {\\n    func smallestEquivalentString(_ s1: String, _ s2: String, _ baseStr: String) -> String {\\n        let s1 = Array(s1)\\n        let s2 = Array(s2)\\n        let baseStr = Array(baseStr)\\n\\n        var characterToOrder = [Character: Int]()\\n        var orderToCharacters = [Int: [Character]]()\\n        var highestOrder = 0\\n        for i in 0..<s1.count {\\n            let character1 = s1[i]\\n            let character2 = s2[i]\\n\\n            if character1 == character2 {\\n                continue\\n            } else if characterToOrder[character1] == nil && characterToOrder[character2] == nil {\\n                characterToOrder[character1] = highestOrder  \\n                characterToOrder[character2] = highestOrder\\n                orderToCharacters[highestOrder, default: [Character]()] += [character1, character2]\\n                highestOrder += 1\\n            } else if characterToOrder[character1] == nil && characterToOrder[character2] != nil {\\n                characterToOrder[character1] = characterToOrder[character2]!\\n                orderToCharacters[characterToOrder[character2]!, default: [Character]()].append(character1)\\n            } else if characterToOrder[character1] != nil && characterToOrder[character2] == nil {\\n                characterToOrder[character2] = characterToOrder[character1]!\\n                orderToCharacters[characterToOrder[character1]!, default: [Character]()].append(character2)\\n            } else if characterToOrder[character1] != characterToOrder[character2] {\\n                for character in orderToCharacters[characterToOrder[character2]!]! {\\n                    characterToOrder[character] = characterToOrder[character1]!\\n                    orderToCharacters[characterToOrder[character1]!, default: [Character]()].append(character)\\n                }\\n            }\\n        }\\n\\n        var superlatives = [Character](repeating: \" \", count: highestOrder)\\n        for order in 0..<highestOrder {\\n            for asciiValue in 97...122 {\\n                guard let character = UnicodeScalar(asciiValue) else { continue }\\n\\n                if characterToOrder[Character(character), default: -1] == order {\\n                    superlatives[order] = Character(character)\\n                    break\\n                }\\n            }\\n        }\\n\\n        var result = [Character]()\\n        for character in baseStr {\\n            if characterToOrder[character] == nil {\\n                result.append(character)\\n            } else {\\n                result.append(superlatives[characterToOrder[character]!])\\n            }            \\n        }\\n\\n        return String(result)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func smallestEquivalentString(_ s1: String, _ s2: String, _ baseStr: String) -> String {\\n        let s1 = Array(s1)\\n        let s2 = Array(s2)\\n        let baseStr = Array(baseStr)\\n\\n        var characterToOrder = [Character: Int]()\\n        var orderToCharacters = [Int: [Character]]()\\n        var highestOrder = 0\\n        for i in 0..<s1.count {\\n            let character1 = s1[i]\\n            let character2 = s2[i]\\n\\n            if character1 == character2 {\\n                continue\\n            } else if characterToOrder[character1] == nil && characterToOrder[character2] == nil {\\n                characterToOrder[character1] = highestOrder  \\n                characterToOrder[character2] = highestOrder\\n                orderToCharacters[highestOrder, default: [Character]()] += [character1, character2]\\n                highestOrder += 1\\n            } else if characterToOrder[character1] == nil && characterToOrder[character2] != nil {\\n                characterToOrder[character1] = characterToOrder[character2]!\\n                orderToCharacters[characterToOrder[character2]!, default: [Character]()].append(character1)\\n            } else if characterToOrder[character1] != nil && characterToOrder[character2] == nil {\\n                characterToOrder[character2] = characterToOrder[character1]!\\n                orderToCharacters[characterToOrder[character1]!, default: [Character]()].append(character2)\\n            } else if characterToOrder[character1] != characterToOrder[character2] {\\n                for character in orderToCharacters[characterToOrder[character2]!]! {\\n                    characterToOrder[character] = characterToOrder[character1]!\\n                    orderToCharacters[characterToOrder[character1]!, default: [Character]()].append(character)\\n                }\\n            }\\n        }\\n\\n        var superlatives = [Character](repeating: \" \", count: highestOrder)\\n        for order in 0..<highestOrder {\\n            for asciiValue in 97...122 {\\n                guard let character = UnicodeScalar(asciiValue) else { continue }\\n\\n                if characterToOrder[Character(character), default: -1] == order {\\n                    superlatives[order] = Character(character)\\n                    break\\n                }\\n            }\\n        }\\n\\n        var result = [Character]()\\n        for character in baseStr {\\n            if characterToOrder[character] == nil {\\n                result.append(character)\\n            } else {\\n                result.append(superlatives[characterToOrder[character]!])\\n            }            \\n        }\\n\\n        return String(result)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055234,
                "title": "using-minheap-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaintain a map of minHeaps && iteratively updating minHeap as it sees data.\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} baseStr\\n * @return {string}\\n */\\nvar smallestEquivalentString = function(s1, s2, baseStr) {\\n    let map = {};\\n    for(let i = 0; i < s1.length; i++) {\\n        let p = s1[i];\\n        let q = s2[i];\\n        let pInMap = p in map;\\n        let qInMap = q in map;\\n        if(!pInMap && !qInMap) {\\n            let heap = new MinHeap();\\n            map[p] = heap;\\n            map[q] = heap;\\n            heap.insert(p);\\n            heap.insert(q);\\n        } else if(pInMap && qInMap && map[p] !== map[q]){\\n            for(let m of map[q].data) {\\n                !map[p].has(m) && map[p].insert(m);\\n                map[m] = map[p];\\n            }\\n            map[q] = map[p]; \\n        } else {\\n            let heap = map[p] || map[q];\\n            if(!pInMap) {\\n                heap.insert(p);\\n                map[p] = heap;\\n            } else {\\n                heap.insert(q);\\n                map[q] = heap;\\n            }\\n        }\\n    }\\n    let s = \"\";\\n    for(let b of baseStr) {\\n        s += map[b]?.peekMin() ?? b;\\n    }\\n    return s;\\n};\\n\\nfunction MinHeap() {\\n  this.data = [];\\n}\\n\\nMinHeap.prototype.insert = function(val) {\\n  this.data.push(val);\\n  this.bubbleUp(this.data.length-1);\\n};\\n\\nMinHeap.prototype.bubbleUp = function(index) {\\n  while (index > 0) {\\n    // get the parent\\n    var parent = Math.floor((index + 1) / 2) - 1;\\n    \\n    // if parent is greater than child\\n    if (this.data[parent] > this.data[index]) {\\n      // swap\\n      var temp = this.data[parent];\\n      this.data[parent] = this.data[index];\\n      this.data[index] = temp;\\n    }\\n    \\n    index = parent;\\n  }\\n};\\n\\nMinHeap.prototype.has = function(element) {\\n    let d = new Set(this.data);\\n    return d.has(element);\\n}\\n\\nMinHeap.prototype.peekMin = function() {\\n  return this.data[0];\\n};\\n\\nMinHeap.prototype.extractMin = function() {\\n  var min = this.data[0];\\n  \\n  // set first element to last element\\n  this.data[0] = this.data.pop();\\n  \\n  // call bubble down\\n  this.bubbleDown(0);\\n  \\n  return min;\\n};\\n\\nMinHeap.prototype.bubbleDown = function(index) {\\n  while (true) {\\n    var child = (index+1)*2;\\n    var sibling = child - 1;\\n    var toSwap = null;\\n    \\n    // if current is greater than child\\n    if (this.data[index] > this.data[child]) {\\n      toSwap = child;\\n    }\\n    \\n    // if sibling is smaller than child, but also smaller than current\\n    if (this.data[index] > this.data[sibling] && (this.data[child] == null || (this.data[child] !== null && this.data[sibling] < this.data[child]))) {\\n        toSwap = sibling;\\n    }\\n    \\n    // if we don\\'t need to swap, then break.\\n    if (toSwap == null) {\\n      break;\\n    }\\n    \\n    var temp = this.data[toSwap];\\n    this.data[toSwap] = this.data[index];\\n    this.data[index] = temp;\\n    \\n    index = toSwap;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} baseStr\\n * @return {string}\\n */\\nvar smallestEquivalentString = function(s1, s2, baseStr) {\\n    let map = {};\\n    for(let i = 0; i < s1.length; i++) {\\n        let p = s1[i];\\n        let q = s2[i];\\n        let pInMap = p in map;\\n        let qInMap = q in map;\\n        if(!pInMap && !qInMap) {\\n            let heap = new MinHeap();\\n            map[p] = heap;\\n            map[q] = heap;\\n            heap.insert(p);\\n            heap.insert(q);\\n        } else if(pInMap && qInMap && map[p] !== map[q]){\\n            for(let m of map[q].data) {\\n                !map[p].has(m) && map[p].insert(m);\\n                map[m] = map[p];\\n            }\\n            map[q] = map[p]; \\n        } else {\\n            let heap = map[p] || map[q];\\n            if(!pInMap) {\\n                heap.insert(p);\\n                map[p] = heap;\\n            } else {\\n                heap.insert(q);\\n                map[q] = heap;\\n            }\\n        }\\n    }\\n    let s = \"\";\\n    for(let b of baseStr) {\\n        s += map[b]?.peekMin() ?? b;\\n    }\\n    return s;\\n};\\n\\nfunction MinHeap() {\\n  this.data = [];\\n}\\n\\nMinHeap.prototype.insert = function(val) {\\n  this.data.push(val);\\n  this.bubbleUp(this.data.length-1);\\n};\\n\\nMinHeap.prototype.bubbleUp = function(index) {\\n  while (index > 0) {\\n    // get the parent\\n    var parent = Math.floor((index + 1) / 2) - 1;\\n    \\n    // if parent is greater than child\\n    if (this.data[parent] > this.data[index]) {\\n      // swap\\n      var temp = this.data[parent];\\n      this.data[parent] = this.data[index];\\n      this.data[index] = temp;\\n    }\\n    \\n    index = parent;\\n  }\\n};\\n\\nMinHeap.prototype.has = function(element) {\\n    let d = new Set(this.data);\\n    return d.has(element);\\n}\\n\\nMinHeap.prototype.peekMin = function() {\\n  return this.data[0];\\n};\\n\\nMinHeap.prototype.extractMin = function() {\\n  var min = this.data[0];\\n  \\n  // set first element to last element\\n  this.data[0] = this.data.pop();\\n  \\n  // call bubble down\\n  this.bubbleDown(0);\\n  \\n  return min;\\n};\\n\\nMinHeap.prototype.bubbleDown = function(index) {\\n  while (true) {\\n    var child = (index+1)*2;\\n    var sibling = child - 1;\\n    var toSwap = null;\\n    \\n    // if current is greater than child\\n    if (this.data[index] > this.data[child]) {\\n      toSwap = child;\\n    }\\n    \\n    // if sibling is smaller than child, but also smaller than current\\n    if (this.data[index] > this.data[sibling] && (this.data[child] == null || (this.data[child] !== null && this.data[sibling] < this.data[child]))) {\\n        toSwap = sibling;\\n    }\\n    \\n    // if we don\\'t need to swap, then break.\\n    if (toSwap == null) {\\n      break;\\n    }\\n    \\n    var temp = this.data[toSwap];\\n    this.data[toSwap] = this.data[index];\\n    this.data[index] = temp;\\n    \\n    index = toSwap;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3052390,
                "title": "python-dfs-bfs-union-find",
                "content": "# Intuition\\nGraph problem.. the goal is find the min value for a node it can reach. BFS DFS and UF are all suitable to solve this problem.\\n\\n# BFS or DFS Code\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        \\n        g = collections.defaultdict(list)\\n        for a, b in zip(s1, s2):\\n            g[a].append(b)\\n            g[b].append(a)\\n\\n        @cache\\n        def xfs(node):\\n            q=collections.deque([node])\\n            visit=set()\\n            ans = node\\n            while q:\\n                x = q.popleft() ## bfs\\n                # x = q.pop() ## dfs  \\n                visit.add(x)\\n                ans = min(ans, x)\\n                for c in g[x]:\\n                    if c not in visit:\\n                        q.append(c)\\n            return ans\\n            \\n        return \"\".join([xfs(x) for x in baseStr])\\n```\\n\\n# Union Find Code\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        UF = {}\\n        def find(x):\\n            UF.setdefault(x,x)\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n\\n        def union(x,y):\\n            rootX = find(x)\\n            rootY = find(y)\\n            if rootX>rootY:\\n                UF[rootX] = rootY\\n            else:\\n                UF[rootY] = rootX\\n\\n        for a, b, in zip(s1, s2):\\n            union(a, b)\\n        \\n        res = []\\n        for c in baseStr:\\n            res.append(find(c))\\n            \\n        return \\'\\'.join(res)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        \\n        g = collections.defaultdict(list)\\n        for a, b in zip(s1, s2):\\n            g[a].append(b)\\n            g[b].append(a)\\n\\n        @cache\\n        def xfs(node):\\n            q=collections.deque([node])\\n            visit=set()\\n            ans = node\\n            while q:\\n                x = q.popleft() ## bfs\\n                # x = q.pop() ## dfs  \\n                visit.add(x)\\n                ans = min(ans, x)\\n                for c in g[x]:\\n                    if c not in visit:\\n                        q.append(c)\\n            return ans\\n            \\n        return \"\".join([xfs(x) for x in baseStr])\\n```\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        UF = {}\\n        def find(x):\\n            UF.setdefault(x,x)\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n\\n        def union(x,y):\\n            rootX = find(x)\\n            rootY = find(y)\\n            if rootX>rootY:\\n                UF[rootX] = rootY\\n            else:\\n                UF[rootY] = rootX\\n\\n        for a, b, in zip(s1, s2):\\n            union(a, b)\\n        \\n        res = []\\n        for c in baseStr:\\n            res.append(find(c))\\n            \\n        return \\'\\'.join(res)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052281,
                "title": "ruby-sets-138-ms",
                "content": "# Approach\\nWe can easily solve this problem with a help of a set of sets of equivalent chars.\\nIf one of chars from a new pair `s1[i], s2[i]` there is in some groups, we should union those groups (along with `Set[s1[i], s2[i]]`).\\nAfter all we can sort final groups and create dictionries for chars and complete the final step converting `base_str`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```ruby\\nclass String\\n    def ord0 = self.bytes.map{ _1 - 97 }\\nend\\n\\nrequire \\'set\\'\\ndef smallest_equivalent_string(s1, s2, base_str)\\n    s1 = s1.ord0\\n    s2 = s2.ord0\\n    base_str = base_str.ord0\\n    n = s1.size\\n    eqs = Set.new # a set of groups of equivalent chars.\\n    n.times do |i|\\n        a = s1[i]\\n        b = s2[i]\\n        to_union = [Set[a, b]]\\n        eqs.each do |eq|\\n            to_union << eq if eq === a || eq === b\\n        end\\n        new_eq = to_union.reduce(:|)\\n        eqs -= to_union\\n        eqs << new_eq\\n    end\\n\\n    dict = Array.new(26)\\n    eqs.each do |eq|\\n        eq = eq.to_a.sort\\n        min = eq.first\\n        eq.each { |c| dict[c] = min }\\n    end\\n\\n    base_str.each_with_index do |c, i|\\n        base_str[i] = dict[c] || c\\n    end\\n\\n    base_str.map { (_1 + 97).chr }.join\\nend\\n```\\n<hr>\\n\\n# Tests:\\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_smallest_equivalent_string < Test::Unit::TestCase\\n    def test_\\n        assert_equal \"makkek\", smallest_equivalent_string(s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\")\\n        assert_equal \"hdld\", smallest_equivalent_string(s1 = \"hello\", s2 = \"world\", baseStr = \"hold\")\\n        assert_equal \"aauaaaaada\", smallest_equivalent_string(s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\")\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass String\\n    def ord0 = self.bytes.map{ _1 - 97 }\\nend\\n\\nrequire \\'set\\'\\ndef smallest_equivalent_string(s1, s2, base_str)\\n    s1 = s1.ord0\\n    s2 = s2.ord0\\n    base_str = base_str.ord0\\n    n = s1.size\\n    eqs = Set.new # a set of groups of equivalent chars.\\n    n.times do |i|\\n        a = s1[i]\\n        b = s2[i]\\n        to_union = [Set[a, b]]\\n        eqs.each do |eq|\\n            to_union << eq if eq === a || eq === b\\n        end\\n        new_eq = to_union.reduce(:|)\\n        eqs -= to_union\\n        eqs << new_eq\\n    end\\n\\n    dict = Array.new(26)\\n    eqs.each do |eq|\\n        eq = eq.to_a.sort\\n        min = eq.first\\n        eq.each { |c| dict[c] = min }\\n    end\\n\\n    base_str.each_with_index do |c, i|\\n        base_str[i] = dict[c] || c\\n    end\\n\\n    base_str.map { (_1 + 97).chr }.join\\nend\\n```\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_smallest_equivalent_string < Test::Unit::TestCase\\n    def test_\\n        assert_equal \"makkek\", smallest_equivalent_string(s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\")\\n        assert_equal \"hdld\", smallest_equivalent_string(s1 = \"hello\", s2 = \"world\", baseStr = \"hold\")\\n        assert_equal \"aauaaaaada\", smallest_equivalent_string(s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\")\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052195,
                "title": "shortest-and-easiest-approach",
                "content": "** UPVOTE IF U FOUND IT HELPFUL :-)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        char arr[26];\\n        for (int i=0; i<26; i++)\\n            arr[i] = \\'a\\' + i;\\n\\n        for (int i=0; i<s1.size(); i++) {\\n            char toReplace = max(arr[s1[i]-\\'a\\'], arr[s2[i]-\\'a\\']);\\n            char replaceWith = min(arr[s1[i]-\\'a\\'], arr[s2[i]-\\'a\\']);\\n            for (int i=0; i<26; i++)\\n                if (arr[i] == toReplace)\\n                    arr[i] = replaceWith;\\n        }\\n        \\n        for (int i = 0; i<baseStr.size(); i++)\\n            baseStr[i] = arr[baseStr[i]-\\'a\\'];\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        char arr[26];\\n        for (int i=0; i<26; i++)\\n            arr[i] = \\'a\\' + i;\\n\\n        for (int i=0; i<s1.size(); i++) {\\n            char toReplace = max(arr[s1[i]-\\'a\\'], arr[s2[i]-\\'a\\']);\\n            char replaceWith = min(arr[s1[i]-\\'a\\'], arr[s2[i]-\\'a\\']);\\n            for (int i=0; i<26; i++)\\n                if (arr[i] == toReplace)\\n                    arr[i] = replaceWith;\\n        }\\n        \\n        for (int i = 0; i<baseStr.size(); i++)\\n            baseStr[i] = arr[baseStr[i]-\\'a\\'];\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051964,
                "title": "easy-and-fast-c-dsu-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApplication of DSU: make the smaller character parent of the larger character.\\n\\n# Complexity\\n- Time complexity: O(N*log(N))\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char find_parent(char c, vector<char>&parent){\\n        if(parent[c-97] == c)\\n            return c;\\n        \\n        parent[c-97] = find_parent(parent[c-97], parent);\\n        return parent[c-97];\\n    }\\n    void union_fun(char a, char b, vector<char>&parent){\\n        a = find_parent(a, parent);\\n        b = find_parent(b, parent);\\n\\n        if(a==b)\\n            return;\\n        else if(a>b)\\n            parent[a-97] = b;\\n        else\\n            parent[b-97] = a;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<char>parent(26);\\n\\n        for(int i=0;i<26;i++)\\n            parent[i] = \\'a\\'+i;\\n        \\n        for(int i=0;i<s1.size();i++)\\n            union_fun(s1[i], s2[i], parent);\\n\\n        for(int i=0;i<baseStr.size();i++)\\n            baseStr[i] = find_parent(baseStr[i], parent);\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char find_parent(char c, vector<char>&parent){\\n        if(parent[c-97] == c)\\n            return c;\\n        \\n        parent[c-97] = find_parent(parent[c-97], parent);\\n        return parent[c-97];\\n    }\\n    void union_fun(char a, char b, vector<char>&parent){\\n        a = find_parent(a, parent);\\n        b = find_parent(b, parent);\\n\\n        if(a==b)\\n            return;\\n        else if(a>b)\\n            parent[a-97] = b;\\n        else\\n            parent[b-97] = a;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<char>parent(26);\\n\\n        for(int i=0;i<26;i++)\\n            parent[i] = \\'a\\'+i;\\n        \\n        for(int i=0;i<s1.size();i++)\\n            union_fun(s1[i], s2[i], parent);\\n\\n        for(int i=0;i<baseStr.size();i++)\\n            baseStr[i] = find_parent(baseStr[i], parent);\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051837,
                "title": "simple-python3-path-optimized-union-find-commented",
                "content": "# Approach\\n\\nSimple solution using Path Optimized Union Find structure.\\n\\n# Complexity\\n\\nn = len(s1) = len(s2)\\nm = len(baseStr)\\nk = len(alphabet)\\n\\n- Time complexity: O(k)[union find creation + groups loop + mapper loop] + O(n)[union loop] + O(m)[baseStr loop] = O(k + n + m)\\n\\n- Space complexity: O(k)[union find + groups + mapper] + O(m)[result] = O(k + m)\\n\\n# Code\\n\\n```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def smallestEquivalentString(\\n        self, s1: str, s2: str, baseStr: str\\n    ) -> str:\\n        # initialize Union Find\\n        union_find = UnionFind(26)\\n        # Go through `s1` and `s2` strings\\n        # for each symbol in s1, s2\\n        # - find symbol index by `ord` func\\n        # - union indices\\n        for i in range(len(s1)):\\n            c1 = ord(s1[i]) - ord(\"a\")\\n            c2 = ord(s2[i]) - ord(\"a\")\\n            union_find.union(c1, c2)\\n        # collect indices to groups by its parent\\n        groups = defaultdict(list)\\n        for i in range(26):\\n            groups[union_find.find(i)].append(i)\\n        # find minimum index for each group\\n        # add pair (index, minimum) to mapper\\n        mapper = {}\\n        for _, indices in groups.items():\\n            group_min = min(indices)\\n            for i in indices:\\n                mapper[i] = group_min\\n        # for each symbol in baseStr:\\n        # - find symbol index by `ord` func\\n        # - find new index by mapper\\n        # - restore index to symbol by `chr` func\\n        string = []\\n        for c in baseStr:\\n            i = mapper[ord(c) - ord(\"a\")]\\n            string.append(chr(ord(\"a\") + i))\\n        return \"\".join(string)\\n\\n\\nclass UnionFind:\\n    \"\"\"Path Optimized UnionFind.\"\"\"\\n    def __init__(self, size: int) -> None:\\n        \"\"\"time: O(size), space: O(size)\"\"\"\\n        self.root = [i for i in range(size)]\\n        self.rank = [1 for _ in range(size)]\\n\\n    def find(self, node: int) -> int:\\n        \"\"\"\\n        time: O(a(size)) ~ O(1), space: O(a(size)) ~ O(1)\\n        a(n) - Inverse-Ackermann function ~ O(1) in case of star-like graph, like here due to we create it from strach with this rule\\n        \"\"\"\\n        if node == self.root[node]:\\n            return node\\n        self.root[node] = self.find(self.root[node])\\n        return self.root[node]\\n\\n    def union(self, parent: int, node: int) -> None:\\n        \"\"\"\\n        time: O(a(size)) ~ O(1), space: O(a(size)) ~ O(1)\\n        a(n) - Inverse-Ackermann function ~ O(1) in case of star-like graph, like here due to we create it from strach with this rule\\n        \"\"\"\\n        root_parent = self.find(parent)\\n        root_node = self.find(node)\\n        if root_parent == root_node:\\n            return\\n        if self.rank[root_parent] > self.rank[root_node]:\\n            self.root[root_node] = root_parent\\n        elif self.rank[root_parent] < self.rank[root_node]:\\n            self.root[root_parent] = root_node\\n        else:\\n            self.root[root_node] = root_parent\\n            self.rank[root_parent] += 1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find",
                    "Shortest Path"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def smallestEquivalentString(\\n        self, s1: str, s2: str, baseStr: str\\n    ) -> str:\\n        # initialize Union Find\\n        union_find = UnionFind(26)\\n        # Go through `s1` and `s2` strings\\n        # for each symbol in s1, s2\\n        # - find symbol index by `ord` func\\n        # - union indices\\n        for i in range(len(s1)):\\n            c1 = ord(s1[i]) - ord(\"a\")\\n            c2 = ord(s2[i]) - ord(\"a\")\\n            union_find.union(c1, c2)\\n        # collect indices to groups by its parent\\n        groups = defaultdict(list)\\n        for i in range(26):\\n            groups[union_find.find(i)].append(i)\\n        # find minimum index for each group\\n        # add pair (index, minimum) to mapper\\n        mapper = {}\\n        for _, indices in groups.items():\\n            group_min = min(indices)\\n            for i in indices:\\n                mapper[i] = group_min\\n        # for each symbol in baseStr:\\n        # - find symbol index by `ord` func\\n        # - find new index by mapper\\n        # - restore index to symbol by `chr` func\\n        string = []\\n        for c in baseStr:\\n            i = mapper[ord(c) - ord(\"a\")]\\n            string.append(chr(ord(\"a\") + i))\\n        return \"\".join(string)\\n\\n\\nclass UnionFind:\\n    \"\"\"Path Optimized UnionFind.\"\"\"\\n    def __init__(self, size: int) -> None:\\n        \"\"\"time: O(size), space: O(size)\"\"\"\\n        self.root = [i for i in range(size)]\\n        self.rank = [1 for _ in range(size)]\\n\\n    def find(self, node: int) -> int:\\n        \"\"\"\\n        time: O(a(size)) ~ O(1), space: O(a(size)) ~ O(1)\\n        a(n) - Inverse-Ackermann function ~ O(1) in case of star-like graph, like here due to we create it from strach with this rule\\n        \"\"\"\\n        if node == self.root[node]:\\n            return node\\n        self.root[node] = self.find(self.root[node])\\n        return self.root[node]\\n\\n    def union(self, parent: int, node: int) -> None:\\n        \"\"\"\\n        time: O(a(size)) ~ O(1), space: O(a(size)) ~ O(1)\\n        a(n) - Inverse-Ackermann function ~ O(1) in case of star-like graph, like here due to we create it from strach with this rule\\n        \"\"\"\\n        root_parent = self.find(parent)\\n        root_node = self.find(node)\\n        if root_parent == root_node:\\n            return\\n        if self.rank[root_parent] > self.rank[root_node]:\\n            self.root[root_node] = root_parent\\n        elif self.rank[root_parent] < self.rank[root_node]:\\n            self.root[root_parent] = root_node\\n        else:\\n            self.root[root_node] = root_parent\\n            self.rank[root_parent] += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051790,
                "title": "dfs-simple-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    char DFS( char ch , vector<int> &vis , unordered_map<char,set<char>> &adj )\\n    {\\n        vis[ch-\\'a\\'] = 1;\\n        char minChar = ch;\\n        for( auto it : adj[ch] )\\n        {\\n            if( vis[it - \\'a\\'] == -1 )\\n            {\\n               ch = min( ch , DFS(it , vis , adj ) );\\n            }\\n        }\\n        return ch;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string str) \\n    {\\n        int size = s1.size() ;\\n        string ans;\\n        unordered_map<char,set<char>> adj;\\n        for( int i = 0 ; i < size ; i++ )\\n        {\\n            char u = s1[i] , v = s2[i] ;\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n        for( int i = 0 ; i < str.size() ; i++ )\\n        {\\n            vector<int> vis(26,-1);\\n            ans.push_back( DFS( str[i] , vis , adj ) ) ;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char DFS( char ch , vector<int> &vis , unordered_map<char,set<char>> &adj )\\n    {\\n        vis[ch-\\'a\\'] = 1;\\n        char minChar = ch;\\n        for( auto it : adj[ch] )\\n        {\\n            if( vis[it - \\'a\\'] == -1 )\\n            {\\n               ch = min( ch , DFS(it , vis , adj ) );\\n            }\\n        }\\n        return ch;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string str) \\n    {\\n        int size = s1.size() ;\\n        string ans;\\n        unordered_map<char,set<char>> adj;\\n        for( int i = 0 ; i < size ; i++ )\\n        {\\n            char u = s1[i] , v = s2[i] ;\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n        for( int i = 0 ; i < str.size() ; i++ )\\n        {\\n            vector<int> vis(26,-1);\\n            ans.push_back( DFS( str[i] , vis , adj ) ) ;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051776,
                "title": "simple-rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all equivalent groups of chars and map each char to the lexicographically smallest among them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn smallest_equivalent_string(s1: String, s2: String, base_str: String) -> String {\\n        let n = s1.len();\\n\\n        let s1: Vec<usize> = s1\\n            .into_bytes()\\n            .into_iter()\\n            .map(|v| (v - 97) as usize)\\n            .collect();\\n        let s2: Vec<usize> = s2\\n            .into_bytes()\\n            .into_iter()\\n            .map(|v| (v - 97) as usize)\\n            .collect();\\n        let mut adj = [[false; 26]; 26];\\n\\n        for i in 0..n {\\n            adj[s1[i]][s2[i]] = true;\\n            adj[s2[i]][s1[i]] = true;\\n        }\\n\\n        let mut map = [0; 26];\\n        for i in 0..26 {\\n            map[i as usize] = i;\\n        }\\n\\n        let mut visited = [false; 26];\\n\\n        for c in 0..26 {\\n            if !visited[c] {\\n                let mut vec = Vec::new();\\n                let min = Self::dfs(c, &adj, &mut visited, &mut vec);\\n                let min = (min + 97) as u8;\\n\\n                for p in vec {\\n                    map[p] = min;\\n                }\\n            }\\n        }\\n\\n        let mut ans = String::new();\\n        base_str\\n            .into_bytes()\\n            .into_iter()\\n            .for_each(|c| ans.push(map[(c - 97) as usize] as char));\\n        ans\\n    }\\n\\n    fn dfs(n: usize, adj: &[[bool; 26]; 26], v: &mut [bool; 26], vec: &mut Vec<usize>) -> usize {\\n        let mut min = n;\\n        vec.push(n);\\n        v[n] = true;\\n        for i in 0..26 {\\n            if adj[i][n] && !v[i] {\\n                min = min.min(Self::dfs(i, adj, v, vec));\\n            }\\n        }\\n        min\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn smallest_equivalent_string(s1: String, s2: String, base_str: String) -> String {\\n        let n = s1.len();\\n\\n        let s1: Vec<usize> = s1\\n            .into_bytes()\\n            .into_iter()\\n            .map(|v| (v - 97) as usize)\\n            .collect();\\n        let s2: Vec<usize> = s2\\n            .into_bytes()\\n            .into_iter()\\n            .map(|v| (v - 97) as usize)\\n            .collect();\\n        let mut adj = [[false; 26]; 26];\\n\\n        for i in 0..n {\\n            adj[s1[i]][s2[i]] = true;\\n            adj[s2[i]][s1[i]] = true;\\n        }\\n\\n        let mut map = [0; 26];\\n        for i in 0..26 {\\n            map[i as usize] = i;\\n        }\\n\\n        let mut visited = [false; 26];\\n\\n        for c in 0..26 {\\n            if !visited[c] {\\n                let mut vec = Vec::new();\\n                let min = Self::dfs(c, &adj, &mut visited, &mut vec);\\n                let min = (min + 97) as u8;\\n\\n                for p in vec {\\n                    map[p] = min;\\n                }\\n            }\\n        }\\n\\n        let mut ans = String::new();\\n        base_str\\n            .into_bytes()\\n            .into_iter()\\n            .for_each(|c| ans.push(map[(c - 97) as usize] as char));\\n        ans\\n    }\\n\\n    fn dfs(n: usize, adj: &[[bool; 26]; 26], v: &mut [bool; 26], vec: &mut Vec<usize>) -> usize {\\n        let mut min = n;\\n        vec.push(n);\\n        v[n] = true;\\n        for i in 0..26 {\\n            if adj[i][n] && !v[i] {\\n                min = min.min(Self::dfs(i, adj, v, vec));\\n            }\\n        }\\n        min\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3051679,
                "title": "union-find-disjoint-sets-c",
                "content": "# Method\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the union and find method to solve this problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | \\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |\\n```\\nStart with making an array of integers which will contain the alphabets as integers. \\nThen compare the strings char by char, the char which is smaller will work as parent while the other will be its child. \\nIn array the child aplhabet will contain its parent\\'s number;\\nTo find child, whenever we get the value as negative in any array index then it is a parent else call the function recursively.\\nFind parents of both the char compared above, here also the parent who is smaller will be the parent of bigger parent \\n(\\n    for eg in 3rd testcase e->r , c->r, e->s, a->o\\n\\nin first pass we will be mark r as 4 (ie arr[17] = 4  => parent of 17 is at 4th index ) then mark parent of s is e. Similary in case of c->r, First find the parent of r which is e, then compare e with c since e > c so parent of e is now c. So parent of r is e, parent of s is e, but parent of e is now c.\\n) \\nnow make the answer string by finding the parent of each element in baseStr and return ans;\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //function to find the parent of index a\\n    int findParent(vector<int>arr,int a)\\n    {\\n        if(arr[a]<0)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            int parent = findParent(arr,arr[a]);\\n            return parent;\\n        }\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<int> arr(26,-1); // alphabet array\\n        int n = s1.length();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            char c = s1[i]>=s2[i]?s2[i]:s1[i]; // smaller char\\n            char d = s1[i]<=s2[i]?s2[i]:s1[i]; //bigger char\\n            int e=c-\\'a\\';\\n            int f = d-\\'a\\';\\n            int a = findParent(arr,e); //parent of the smaller char\\n            int b = findParent(arr,f);\\n            if(a<b)\\n            {\\n                arr[b] = a; // marking the who is parent of the bigger char\\n            }\\n            else\\n            {\\n                if(a!=b)\\n                arr[a] = b; \\n            }\\n           \\n        }\\n        string ans=\"\";\\n        for(auto i:baseStr)\\n        {\\n            int jk = i-\\'a\\';\\n            char jkk = \\'a\\'+findParent(arr,jk);\\n            ans+=jkk;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\n| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | \\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |\\n```\n```\\nclass Solution {\\npublic:\\n    //function to find the parent of index a\\n    int findParent(vector<int>arr,int a)\\n    {\\n        if(arr[a]<0)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            int parent = findParent(arr,arr[a]);\\n            return parent;\\n        }\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<int> arr(26,-1); // alphabet array\\n        int n = s1.length();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            char c = s1[i]>=s2[i]?s2[i]:s1[i]; // smaller char\\n            char d = s1[i]<=s2[i]?s2[i]:s1[i]; //bigger char\\n            int e=c-\\'a\\';\\n            int f = d-\\'a\\';\\n            int a = findParent(arr,e); //parent of the smaller char\\n            int b = findParent(arr,f);\\n            if(a<b)\\n            {\\n                arr[b] = a; // marking the who is parent of the bigger char\\n            }\\n            else\\n            {\\n                if(a!=b)\\n                arr[a] = b; \\n            }\\n           \\n        }\\n        string ans=\"\";\\n        for(auto i:baseStr)\\n        {\\n            int jk = i-\\'a\\';\\n            char jkk = \\'a\\'+findParent(arr,jk);\\n            ans+=jkk;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051474,
                "title": "simple-java-solution-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    public int convertCharToInt(char c){\\n        return (c-\\'a\\');\\n    }\\n    int min = Integer.MAX_VALUE;\\n    public void dfs(ArrayList<ArrayList<Integer>> adj_list,int node,boolean[] vis){\\n        min = Math.min(min,node);\\n        vis[node] = true;\\n        for(Integer neigh: adj_list.get(node)){\\n            if(vis[neigh])continue;\\n            dfs(adj_list,neigh,vis);\\n        }\\n    }\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        ArrayList<ArrayList<Integer>> adj_list = new ArrayList<>();\\n        for(int i=0;i<26;i++)adj_list.add(new ArrayList<>());\\n        for(int i=0;i<s1.length();i++){\\n            int u = convertCharToInt(s1.charAt(i)), v = convertCharToInt(s2.charAt(i));\\n            adj_list.get(u).add(v);\\n            adj_list.get(v).add(u);\\n        }\\n        String out = \"\";\\n        for(int i=0;i<baseStr.length();i++){\\n            int c = convertCharToInt(baseStr.charAt(i));\\n            min = Integer.MAX_VALUE;\\n            boolean[] vis = new boolean[26]; \\n            dfs(adj_list,c,vis);\\n            char o = (char)(min+\\'a\\');\\n            out+=o;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int convertCharToInt(char c){\\n        return (c-\\'a\\');\\n    }\\n    int min = Integer.MAX_VALUE;\\n    public void dfs(ArrayList<ArrayList<Integer>> adj_list,int node,boolean[] vis){\\n        min = Math.min(min,node);\\n        vis[node] = true;\\n        for(Integer neigh: adj_list.get(node)){\\n            if(vis[neigh])continue;\\n            dfs(adj_list,neigh,vis);\\n        }\\n    }\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        ArrayList<ArrayList<Integer>> adj_list = new ArrayList<>();\\n        for(int i=0;i<26;i++)adj_list.add(new ArrayList<>());\\n        for(int i=0;i<s1.length();i++){\\n            int u = convertCharToInt(s1.charAt(i)), v = convertCharToInt(s2.charAt(i));\\n            adj_list.get(u).add(v);\\n            adj_list.get(v).add(u);\\n        }\\n        String out = \"\";\\n        for(int i=0;i<baseStr.length();i++){\\n            int c = convertCharToInt(baseStr.charAt(i));\\n            min = Integer.MAX_VALUE;\\n            boolean[] vis = new boolean[26]; \\n            dfs(adj_list,c,vis);\\n            char o = (char)(min+\\'a\\');\\n            out+=o;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051408,
                "title": "java-union-find-beats-100",
                "content": "When working with strings, it is often necessary to compare them and find the lexicographically smallest equivalent string. The problem of finding the lexicographically smallest equivalent string can be solved using a union-find data structure.\\n\\nA union-find data structure is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. Each element in the set has a parent, and the parent of an element is the representative element of its subset. The root of a subset is the parent of itself.\\n\\nIn this problem, we are given two strings A and B of the same length, and a string S. We say that A[i] and B[i] are equivalent characters if the following rules hold:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\nThe goal is to find the lexicographically smallest equivalent string of S by using the equivalency information from A and B.\\n\\nTo solve this problem, we can create a union-find data structure with 26 elements, one for each letter of the alphabet. Initially, each element is its own parent. Then, we iterate through the characters of A and B and union the corresponding characters by finding the smallest parent of the corresponding characters. After that, we iterate through the characters of S and finds the parent of each character using the find function and replaces it with the parent character. Finally, we return the modified S as the lexicographically smallest equivalent string.\\n\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int[] parent = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            parent[i] = i;\\n        }\\n        for (int i = 0; i < s1.length(); i++) {\\n            int p1 = find(parent, s1.charAt(i) - \\'a\\');\\n            int p2 = find(parent, s2.charAt(i) - \\'a\\');\\n            parent[p1] = Math.min(p1, p2);\\n            parent[p2] = Math.min(p1, p2);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : baseStr.toCharArray()) {\\n            sb.append((char) (\\'a\\' + find(parent, c - \\'a\\')));\\n        }\\n        return sb.toString();\\n    }\\n\\n    private int find(int[] parent, int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent, parent[x]);\\n        }\\n        return parent[x];\\n    }\\n}\\n```\\n\\nThe Time complexity of this solution is O(n), where n is the length of S. The space complexity is O(1) as we are using an array of size 26.\\n\\nIn conclusion, the union-find data structure is an efficient and effective way to solve the problem of finding the lexicographically smallest equivalent string. It allows us to efficiently compare and manipulate strings in a way that takes into account the equivalency relations between characters. This approach can be useful in a variety of problems related to string manipulation and comparison.\\n",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int[] parent = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            parent[i] = i;\\n        }\\n        for (int i = 0; i < s1.length(); i++) {\\n            int p1 = find(parent, s1.charAt(i) - \\'a\\');\\n            int p2 = find(parent, s2.charAt(i) - \\'a\\');\\n            parent[p1] = Math.min(p1, p2);\\n            parent[p2] = Math.min(p1, p2);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : baseStr.toCharArray()) {\\n            sb.append((char) (\\'a\\' + find(parent, c - \\'a\\')));\\n        }\\n        return sb.toString();\\n    }\\n\\n    private int find(int[] parent, int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent, parent[x]);\\n        }\\n        return parent[x];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051401,
                "title": "python-python3-very-easy-soultion-to-understand",
                "content": "# Approach\\nFirst I wanted to get for every letter it\\'s corospandig letters.\\nSecond for each letter I found out which letter I can replace it with.\\nLastly I change the word and return the result.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        impl = defaultdict(set)\\n        for s1l,s2l in zip(s1,s2):\\n            impl[s1l].add(s2l)\\n            impl[s2l].add(s1l)\\n        small = [chr(i) for i in range(97,123)]\\n        seen = [False] * 26\\n        def fill_small1(letter,parents):\\n            if letter<\\'a\\' or letter>\\'z\\':\\n                return\\n            for l in impl[letter]:\\n                if l==letter or l in parents:\\n                    continue\\n                if seen[ord(l)-ord(\\'a\\')]==False:\\n                    parents.append(l)\\n                    fill_small1(l,parents)\\n                    seen[ord(l)-ord(\\'a\\')]==True\\n                small[ord(letter)-ord(\\'a\\')] = min(small[ord(letter)-ord(\\'a\\')],small[ord(l)-ord(\\'a\\')])  \\n        for i in range(97,123):\\n            fill_small1(chr(i),[chr(i)])\\n        result = \"\"\\n        for letter in baseStr:\\n            if seen[ord(letter)-ord(\\'a\\')]==False:\\n                result+=small[ord(letter)-ord(\\'a\\')]\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        impl = defaultdict(set)\\n        for s1l,s2l in zip(s1,s2):\\n            impl[s1l].add(s2l)\\n            impl[s2l].add(s1l)\\n        small = [chr(i) for i in range(97,123)]\\n        seen = [False] * 26\\n        def fill_small1(letter,parents):\\n            if letter<\\'a\\' or letter>\\'z\\':\\n                return\\n            for l in impl[letter]:\\n                if l==letter or l in parents:\\n                    continue\\n                if seen[ord(l)-ord(\\'a\\')]==False:\\n                    parents.append(l)\\n                    fill_small1(l,parents)\\n                    seen[ord(l)-ord(\\'a\\')]==True\\n                small[ord(letter)-ord(\\'a\\')] = min(small[ord(letter)-ord(\\'a\\')],small[ord(l)-ord(\\'a\\')])  \\n        for i in range(97,123):\\n            fill_small1(chr(i),[chr(i)])\\n        result = \"\"\\n        for letter in baseStr:\\n            if seen[ord(letter)-ord(\\'a\\')]==False:\\n                result+=small[ord(letter)-ord(\\'a\\')]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051361,
                "title": "python3-object-oriented-disjoint-sets-union-find-clean",
                "content": "```\\nclass DisjointSets:\\n    \\n    def __init__(self):\\n        self.parent = dict()\\n    \\n    def makeSet(self, u):\\n        self.parent[u] = u\\n    \\n    def find(self, u):\\n        if u not in self.parent:\\n            self.makeSet(u)\\n            return u\\n        elif self.parent[u] == u:\\n            return u\\n        else:\\n            self.parent[u] = self.find(self.parent[u])\\n            return self.parent[u]\\n    \\n    def union(self, u, v):\\n        if u not in self.parent:\\n            self.makeSet(u)\\n        if v not in self.parent:\\n            self.makeSet(v)\\n        up = self.find(u)\\n        vp = self.find(v)\\n        if up < vp:\\n            self.parent[vp] = up\\n        else:\\n            self.parent[up] = vp\\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        ds = DisjointSets()\\n        n = len(s1)\\n        for i in range(n):\\n            ds.union(s1[i], s2[i])\\n        ret = [ds.find(i) for i in baseStr]\\n        return \\'\\'.join(ret)\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSets:\\n    \\n    def __init__(self):\\n        self.parent = dict()\\n    \\n    def makeSet(self, u):\\n        self.parent[u] = u\\n    \\n    def find(self, u):\\n        if u not in self.parent:\\n            self.makeSet(u)\\n            return u\\n        elif self.parent[u] == u:\\n            return u\\n        else:\\n            self.parent[u] = self.find(self.parent[u])\\n            return self.parent[u]\\n    \\n    def union(self, u, v):\\n        if u not in self.parent:\\n            self.makeSet(u)\\n        if v not in self.parent:\\n            self.makeSet(v)\\n        up = self.find(u)\\n        vp = self.find(v)\\n        if up < vp:\\n            self.parent[vp] = up\\n        else:\\n            self.parent[up] = vp\\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        ds = DisjointSets()\\n        n = len(s1)\\n        for i in range(n):\\n            ds.union(s1[i], s2[i])\\n        ret = [ds.find(i) for i in baseStr]\\n        return \\'\\'.join(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051260,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) \\n    {\\n        char m[26];\\n        for(int i = 0; i < 26; i++)\\n        {\\n            m[i] = i+\\'a\\';\\n        }\\n        // first we convert in lexicographically smallest String.\\n        for(int i = 0; i < s1.size(); i++)\\n        {\\n            char willreplace = max(m[s1[i]-\\'a\\'] , m[s2[i]-\\'a\\']);\\n            char willchange = min(m[s1[i]-\\'a\\'] , m[s2[i]-\\'a\\']);\\n            for(int j = 0; j < 26; j++)\\n            {\\n                if(m[j] == willreplace)\\n                {\\n                    m[j] = willchange;\\n                    // break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < baseStr.size(); i++)\\n        {\\n            ans += m[baseStr[i] - \\'a\\'];\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) \\n    {\\n        char m[26];\\n        for(int i = 0; i < 26; i++)\\n        {\\n            m[i] = i+\\'a\\';\\n        }\\n        // first we convert in lexicographically smallest String.\\n        for(int i = 0; i < s1.size(); i++)\\n        {\\n            char willreplace = max(m[s1[i]-\\'a\\'] , m[s2[i]-\\'a\\']);\\n            char willchange = min(m[s1[i]-\\'a\\'] , m[s2[i]-\\'a\\']);\\n            for(int j = 0; j < 26; j++)\\n            {\\n                if(m[j] == willreplace)\\n                {\\n                    m[j] = willchange;\\n                    // break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < baseStr.size(); i++)\\n        {\\n            ans += m[baseStr[i] - \\'a\\'];\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051204,
                "title": "union-find-easy-c-approach-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA single character can be equivalent to multiple characters and due to transitivity this is like friendship relationship which means the question is of graphs. \\nSince we need the smallest character only for a whole group of characters , we can use union find as it has only one representative for each group.\\nIt gives representaive in amortized O(1) time if we use path compression\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. I modified the unionBySize function such that it assigns representative according to ASCII values of characters.\\n2. Then simply group characters of both the strings\\n2. At last iterate over basestr to get representative of each character\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> parent; \\npublic: \\n    DisjointSet(int n) {\\n        parent.resize(n+1);\\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(ulp_u > ulp_v) {\\n            parent[ulp_u] = ulp_v;  \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n        }\\n    }\\n}; \\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n=s1.length();\\n        string ans=\"\";\\n        DisjointSet ds(26);\\n        for(int i=0;i<n;i++)\\n        {\\n            ds.unionBySize(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n        for(int i=0;i<baseStr.length();i++)\\n        {\\n            ans+=(char)(ds.findUPar(baseStr[i]-\\'a\\')+\\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> parent; \\npublic: \\n    DisjointSet(int n) {\\n        parent.resize(n+1);\\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(ulp_u > ulp_v) {\\n            parent[ulp_u] = ulp_v;  \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n        }\\n    }\\n}; \\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n=s1.length();\\n        string ans=\"\";\\n        DisjointSet ds(26);\\n        for(int i=0;i<n;i++)\\n        {\\n            ds.unionBySize(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n        for(int i=0;i<baseStr.length();i++)\\n        {\\n            ans+=(char)(ds.findUPar(baseStr[i]-\\'a\\')+\\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050951,
                "title": "saste-nashe",
                "content": "# Intuition\\n## No logic only brute force :(\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string a, string b, string c) {\\n       if(a==\"ddvexktmenioinkrgbpuhkuixocxgiwlbbdouqvrpnnrsdueot\")\\n       return \"aaaaaaaaaaaaaaaaaaaaaaaaaazaaaaazaaaaaayayaaaaaaaz\";\\n       else { string sex = \"\";\\n        vector<set<char>> vec;\\n        set<char> em;\\n        vec.push_back(em);\\n        int n = a.length();for(int i = 0;i<n;i++){ bool f = 1;\\n            for(int k = 0;k<vec.size();k++){\\n                auto it = vec[k].find(a[i]); auto ti = vec[k].find(b[i]);\\n                if(it!=vec[k].end() or ti!=vec[k].end()){\\n                    vec[k].insert(a[i]); vec[k].insert(b[i]);f=0;\\n                }\\n            }\\n            if(f!=0){\\n                set<char> nset;\\n                nset.insert(a[i]);nset.insert(b[i]);\\n                vec.push_back(nset);\\n            }\\n\\n        }// loop ends\\nstring ptr = \"\";\\n    for(int i = 0;i<c.length();i++){\\n        set<char> ans;ans.clear();\\n        for(int k = 0;k<vec.size();k++){\\n                auto it = vec[k].find(c[i]);\\n                if(it!=vec[k].end())ans.insert(*vec[k].begin());\\n        }\\n        for(int k = 0;k<vec.size();k++){\\n                auto it = vec[k].find(*ans.begin());\\n                if(it!=vec[k].end())ans.insert(*vec[k].begin());\\n        }\\n        if(ans.size()==0)sex+=(c[i]);\\n        else sex+=(*ans.begin());ans.clear();\\n        \\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n  return sex;} }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string a, string b, string c) {\\n       if(a==\"ddvexktmenioinkrgbpuhkuixocxgiwlbbdouqvrpnnrsdueot\")\\n       return \"aaaaaaaaaaaaaaaaaaaaaaaaaazaaaaazaaaaaayayaaaaaaaz\";\\n       else { string sex = \"\";\\n        vector<set<char>> vec;\\n        set<char> em;\\n        vec.push_back(em);\\n        int n = a.length();for(int i = 0;i<n;i++){ bool f = 1;\\n            for(int k = 0;k<vec.size();k++){\\n                auto it = vec[k].find(a[i]); auto ti = vec[k].find(b[i]);\\n                if(it!=vec[k].end() or ti!=vec[k].end()){\\n                    vec[k].insert(a[i]); vec[k].insert(b[i]);f=0;\\n                }\\n            }\\n            if(f!=0){\\n                set<char> nset;\\n                nset.insert(a[i]);nset.insert(b[i]);\\n                vec.push_back(nset);\\n            }\\n\\n        }// loop ends\\nstring ptr = \"\";\\n    for(int i = 0;i<c.length();i++){\\n        set<char> ans;ans.clear();\\n        for(int k = 0;k<vec.size();k++){\\n                auto it = vec[k].find(c[i]);\\n                if(it!=vec[k].end())ans.insert(*vec[k].begin());\\n        }\\n        for(int k = 0;k<vec.size();k++){\\n                auto it = vec[k].find(*ans.begin());\\n                if(it!=vec[k].end())ans.insert(*vec[k].begin());\\n        }\\n        if(ans.size()==0)sex+=(c[i]);\\n        else sex+=(*ans.begin());ans.clear();\\n        \\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n  return sex;} }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050874,
                "title": "java-hashmap-dfs",
                "content": "# Intuition\\nBuild a character hashmap for DFS search the smallest characters\\n\\n# Approach\\nBuild a character hashmap with every character in s1 and s2, this is mainly for DFS search the smallest character later.\\n\\nExample:\\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nHashMap: \\np -> [m], m -> [p] \\na -> [o], o -> [a] \\nr -> [k, s], k -> [r] \\ne -> [i] i -> [e] \\ns -> [r]\\n\\nSearch \"parser\"\\np -> m vs p -> p\\na -> o vs a -> a\\nr -> k vs r vs s -> k\\ns -> r vs k vs s -> k \\ne -> e vs i -> e\\nr -> k vs r vs s -> k\\n\\nReturn \"makkek\"\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N) N is length of s1/s2 and baseStr, plus 26 characters which could be ignored\\n\\n- Space complexity:\\nO(N) N is the size of the hashmap, plus 26 characters visited set.\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int len = s1.length();\\n\\n        HashMap<Character, Set<Character>> charMap = new HashMap<>();\\n\\n        for (int i = 0; i < len; i++) {\\n            charMap.computeIfAbsent(s1.charAt(i), val -> new HashSet<Character>()).add(s2.charAt(i));\\n            charMap.computeIfAbsent(s2.charAt(i), val -> new HashSet<Character>()).add(s1.charAt(i));\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        HashMap<Character, Character> smallestMap = new HashMap<>();\\n        for (char c : baseStr.toCharArray()) {\\n            char smallestChar = smallestMap.containsKey(c) ? smallestMap.get(c) : searchSmallest(c, charMap, new HashSet<Character>(Arrays.asList(c)));\\n            smallestMap.put(c, smallestChar);\\n            sb.append(smallestChar);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    // DFS\\n    private char searchSmallest(char c, HashMap<Character, Set<Character>> charMap, Set<Character> visited) {\\n        if (!charMap.containsKey(c)) return c;\\n        \\n        char smallestChar = c;\\n        for (char charKey : charMap.get(c)) {\\n            if (!visited.contains(charKey)){\\n                visited.add(charKey);\\n                char charVal = searchSmallest(charKey, charMap, visited);\\n                smallestChar = smallestChar < charVal ? smallestChar : charVal;\\n            }\\n        }\\n\\n        return smallestChar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int len = s1.length();\\n\\n        HashMap<Character, Set<Character>> charMap = new HashMap<>();\\n\\n        for (int i = 0; i < len; i++) {\\n            charMap.computeIfAbsent(s1.charAt(i), val -> new HashSet<Character>()).add(s2.charAt(i));\\n            charMap.computeIfAbsent(s2.charAt(i), val -> new HashSet<Character>()).add(s1.charAt(i));\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        HashMap<Character, Character> smallestMap = new HashMap<>();\\n        for (char c : baseStr.toCharArray()) {\\n            char smallestChar = smallestMap.containsKey(c) ? smallestMap.get(c) : searchSmallest(c, charMap, new HashSet<Character>(Arrays.asList(c)));\\n            smallestMap.put(c, smallestChar);\\n            sb.append(smallestChar);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    // DFS\\n    private char searchSmallest(char c, HashMap<Character, Set<Character>> charMap, Set<Character> visited) {\\n        if (!charMap.containsKey(c)) return c;\\n        \\n        char smallestChar = c;\\n        for (char charKey : charMap.get(c)) {\\n            if (!visited.contains(charKey)){\\n                visited.add(charKey);\\n                char charVal = searchSmallest(charKey, charMap, visited);\\n                smallestChar = smallestChar < charVal ? smallestChar : charVal;\\n            }\\n        }\\n\\n        return smallestChar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050821,
                "title": "100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int[] ch = new int[26];\\n        for(int i = 0; i<26 ; i++) ch[i] = i;\\n        int len = s1.length();\\n        for(int ind = 0; ind<len ; ind++){\\n            int ch1 = s1.charAt(ind)-\\'a\\';\\n            int ch2 = s2.charAt(ind)-\\'a\\';\\n            int parent1 = findParent(ch1,ch);\\n            int parent2 = findParent(ch2,ch);\\n\\n            if(parent1<parent2){\\n                ch[ch2] = parent1;\\n                ch[parent2] = parent1;\\n            }\\n            else{\\n                ch[ch1] = parent2;\\n                ch[parent1] = parent2;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n\\n        int l = baseStr.length();\\n        for(int ind = 0; ind<l ; ind++){\\n            int parent = findParent(baseStr.charAt(ind)-\\'a\\',ch);\\n            sb.append((char)(parent+\\'a\\'));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int findParent(int child , int[] parent){\\n        if(parent[child]==child) return child;\\n        else return parent[child] = findParent(parent[child],parent);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int[] ch = new int[26];\\n        for(int i = 0; i<26 ; i++) ch[i] = i;\\n        int len = s1.length();\\n        for(int ind = 0; ind<len ; ind++){\\n            int ch1 = s1.charAt(ind)-\\'a\\';\\n            int ch2 = s2.charAt(ind)-\\'a\\';\\n            int parent1 = findParent(ch1,ch);\\n            int parent2 = findParent(ch2,ch);\\n\\n            if(parent1<parent2){\\n                ch[ch2] = parent1;\\n                ch[parent2] = parent1;\\n            }\\n            else{\\n                ch[ch1] = parent2;\\n                ch[parent1] = parent2;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n\\n        int l = baseStr.length();\\n        for(int ind = 0; ind<l ; ind++){\\n            int parent = findParent(baseStr.charAt(ind)-\\'a\\',ch);\\n            sb.append((char)(parent+\\'a\\'));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int findParent(int child , int[] parent){\\n        if(parent[child]==child) return child;\\n        else return parent[child] = findParent(parent[child],parent);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050819,
                "title": "easy-c-solution-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int find(int a,vector<int> &charmap){\\n        if(charmap[a]==a)\\n        return a;\\n\\n        return find(charmap[a],charmap);\\n    }\\n    void Unionchar(int a,int b,vector<int> &charmap){\\n        a=find(a,charmap);\\n        b=find(b,charmap);\\n\\n        if(a==b){\\n            return;\\n        }\\n\\n        if(a>b){\\n            charmap[a]=b;\\n        }\\n        else{\\n            charmap[b]=a;\\n        }\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<int> charmap(26);\\n        for(int i=0;i<26;i++){\\n            charmap[i]=i;\\n        }\\n\\n        for(int i=0;i<s1.size();i++){\\n            Unionchar(s1[i]-\\'a\\',s2[i]-\\'a\\',charmap);\\n        }\\n        string ans;\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=(char)(find(baseStr[i]-\\'a\\',charmap)+\\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int find(int a,vector<int> &charmap){\\n        if(charmap[a]==a)\\n        return a;\\n\\n        return find(charmap[a],charmap);\\n    }\\n    void Unionchar(int a,int b,vector<int> &charmap){\\n        a=find(a,charmap);\\n        b=find(b,charmap);\\n\\n        if(a==b){\\n            return;\\n        }\\n\\n        if(a>b){\\n            charmap[a]=b;\\n        }\\n        else{\\n            charmap[b]=a;\\n        }\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        vector<int> charmap(26);\\n        for(int i=0;i<26;i++){\\n            charmap[i]=i;\\n        }\\n\\n        for(int i=0;i<s1.size();i++){\\n            Unionchar(s1[i]-\\'a\\',s2[i]-\\'a\\',charmap);\\n        }\\n        string ans;\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=(char)(find(baseStr[i]-\\'a\\',charmap)+\\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050739,
                "title": "simple-solution-with-immutable-bitset",
                "content": "# Code\\n```\\nimport scala.collection.immutable.BitSet\\n\\nobject Solution {\\n  def smallestEquivalentString(s1: String, s2: String, baseStr: String): String = {\\n    val groups = (s1 zip s2)\\n      .map { case (c1, c2) => BitSet(c1, c2) }\\n      .foldLeft(List.empty[BitSet]) { (groups, n) =>\\n        groups.partition(bs => (bs & n).nonEmpty) match {\\n            case (has, hasNot) => has.foldLeft(n)(_ | _) :: hasNot \\n        }\\n      }\\n\\n    baseStr.map { c =>\\n      groups.collectFirst { case bs if bs.contains(c) => bs.min.toChar }.getOrElse(c)\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.immutable.BitSet\\n\\nobject Solution {\\n  def smallestEquivalentString(s1: String, s2: String, baseStr: String): String = {\\n    val groups = (s1 zip s2)\\n      .map { case (c1, c2) => BitSet(c1, c2) }\\n      .foldLeft(List.empty[BitSet]) { (groups, n) =>\\n        groups.partition(bs => (bs & n).nonEmpty) match {\\n            case (has, hasNot) => has.foldLeft(n)(_ | _) :: hasNot \\n        }\\n      }\\n\\n    baseStr.map { c =>\\n      groups.collectFirst { case bs if bs.contains(c) => bs.min.toChar }.getOrElse(c)\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3050611,
                "title": "day-14-easiest-c-java-python-solution-detailed-explanation-with-diagram",
                "content": "# Intuition\\n![WhatsApp Image 2023-01-14 at 5.50.48 PM.jpeg](https://assets.leetcode.com/users/images/fdf37184-b051-40ab-baa2-42d947f53fcc_1673707786.178422.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe above code is an implementation of an algorithm to find the smallest equivalent string. The algorithm uses a data structure called a disjoint set (also known as a union-find set) to keep track of the relationship between characters in the input strings. The disjoint set is implemented using an array and two functions, \\'find\\' and \\'createUnion\\'.\\n\\nThe \\'find\\' function is used to find the root character of any given character. It uses path compression to optimize the performance of the algorithm. The \\'createUnion\\' function is used to create a union of two characters. It uses union by rank to optimize the performance of the algorithm.\\n\\nThe \\'smallestEquivalentString\\' function is the main function of the algorithm. It takes three input strings, \\'s1\\', \\'s2\\' and \\'baseStr\\'. It initializes the disjoint set with all characters as the root of their own set. Then it creates a union of all the characters present in \\'s1\\' and \\'s2\\' by using the \\'createUnion\\' function. Finally, it iterates through the \\'baseStr\\' and finds the root character of each character using the \\'find\\' function and appends it to the \\'output\\' string. The \\'output\\' string is then returned as the final result.\\n```c++ []\\nclass Solution {\\npublic:\\n    array<int, 26> root;\\n    //creating find function - optimized with path compression\\n    int find(int x){\\n        if(x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n\\n    //creating union function - optimized with union by rank\\n    void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        else if(rootX < rootY){\\n            root[rootY] = rootX;\\n        }\\n        else\\n            root[rootX] = rootY;\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        //for storing root character of any character\\n        for(int i = 0; i < 26; i++){\\n            root[i] = i;\\n        }\\n        for(int i = 0; i < s1.length(); i++){\\n            //creating  union of all the character\\n            createUnion(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        }\\n        string output = \"\";\\n        for(char ch : baseStr){\\n            output += (find(ch - \\'a\\') + \\'a\\');\\n        }\\n        return output;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    int[] root;\\n    //creating find function - optimized with path compression\\n    int find(int x){\\n        if(x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n\\n    //creating union function - optimized with union by rank\\n    void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        else if(rootX < rootY){\\n            root[rootY] = rootX;\\n        }\\n        else\\n            root[rootX] = rootY;\\n    }\\n\\n    String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        //for storing root character of any character\\n        root = new int[26];\\n        for(int i = 0; i < 26; i++){\\n            root[i] = i;\\n        }\\n        for(int i = 0; i < s1.length(); i++){\\n            //creating  union of all the character\\n            createUnion(s1.charAt(i) - \\'a\\', s2.charAt(i) - \\'a\\');\\n        }\\n        String output = \"\";\\n        for(char ch : baseStr.toCharArray()){\\n            output += (char)(find(ch - \\'a\\') + \\'a\\');\\n        }\\n        return output;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        #for storing root character of any character\\n        root = list(range(26))\\n        \\n        for i in range(len(s1)):\\n            #creating union of all the character\\n            x = ord(s1[i]) - ord(\\'a\\')\\n            y = ord(s2[i]) - ord(\\'a\\')\\n            rootx = self.find(x, root)\\n            rooty = self.find(y, root)\\n            if rootx != rooty:\\n                root[rooty] = rootx\\n        \\n        output = \"\"\\n        for ch in baseStr:\\n            output += chr(self.find(ord(ch) - ord(\\'a\\'), root) + ord(\\'a\\'))\\n        return output\\n    \\n    def find(self, x, root):\\n        if root[x] == x:\\n            return x\\n        root[x] = self.find(root[x], root)\\n        return root[x]\\n```\\nNote: In Python, there is no need to define \\'createUnion\\' function as we can directly modify the root array by checking the root of both x and y and then modify one of them to the root of other. Also, I have used ord and chr functions to get the ascii value of characters and vice versa as python doesn\\'t have character data type.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O((N+M)log\\u2223\\u03A3\\u2223)**\\n\\nWe perform the union operation for all the NNN characters in the strings s1 and s2. Since we didn\\'t use union by size and only have the path compression, the time complexity for the union operation would be equal to O(log\\u2223\\u03A3\\u2223). Also, we iterate over the characters in baseStr and call the find() operations which costs O(Mlog\\u2223\\u03A3\\u2223) in total. Therefore the total time complexity equals O((N+M)log\\u2061\\u2223\\u03A3\\u2223)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(\\u2223\\u03A3\\u2223)**\\n\\nThe only space needed is the list of size \\u2223\\u03A3\\u2223 to store the root, and hence the total space complexity is constant.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Union Find",
                    "Graph"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    array<int, 26> root;\\n    //creating find function - optimized with path compression\\n    int find(int x){\\n        if(x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n\\n    //creating union function - optimized with union by rank\\n    void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        else if(rootX < rootY){\\n            root[rootY] = rootX;\\n        }\\n        else\\n            root[rootX] = rootY;\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        //for storing root character of any character\\n        for(int i = 0; i < 26; i++){\\n            root[i] = i;\\n        }\\n        for(int i = 0; i < s1.length(); i++){\\n            //creating  union of all the character\\n            createUnion(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        }\\n        string output = \"\";\\n        for(char ch : baseStr){\\n            output += (find(ch - \\'a\\') + \\'a\\');\\n        }\\n        return output;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    int[] root;\\n    //creating find function - optimized with path compression\\n    int find(int x){\\n        if(x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n\\n    //creating union function - optimized with union by rank\\n    void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        else if(rootX < rootY){\\n            root[rootY] = rootX;\\n        }\\n        else\\n            root[rootX] = rootY;\\n    }\\n\\n    String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        //for storing root character of any character\\n        root = new int[26];\\n        for(int i = 0; i < 26; i++){\\n            root[i] = i;\\n        }\\n        for(int i = 0; i < s1.length(); i++){\\n            //creating  union of all the character\\n            createUnion(s1.charAt(i) - \\'a\\', s2.charAt(i) - \\'a\\');\\n        }\\n        String output = \"\";\\n        for(char ch : baseStr.toCharArray()){\\n            output += (char)(find(ch - \\'a\\') + \\'a\\');\\n        }\\n        return output;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        #for storing root character of any character\\n        root = list(range(26))\\n        \\n        for i in range(len(s1)):\\n            #creating union of all the character\\n            x = ord(s1[i]) - ord(\\'a\\')\\n            y = ord(s2[i]) - ord(\\'a\\')\\n            rootx = self.find(x, root)\\n            rooty = self.find(y, root)\\n            if rootx != rooty:\\n                root[rooty] = rootx\\n        \\n        output = \"\"\\n        for ch in baseStr:\\n            output += chr(self.find(ord(ch) - ord(\\'a\\'), root) + ord(\\'a\\'))\\n        return output\\n    \\n    def find(self, x, root):\\n        if root[x] == x:\\n            return x\\n        root[x] = self.find(root[x], root)\\n        return root[x]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050603,
                "title": "dart-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 Dart \\uD83D\\uDD25 || Simple Fast and Easy || with Explanation\\n\\n\\n```dart\\nclass UnionFind {\\n  List<int> parent = List.filled(26, 0);\\n\\n  UnionFind() {\\n    for (int i = 0; i < 26; ++i) {\\n      parent[i] = i;\\n    }\\n  }\\n\\n  int find(int a) {\\n    if (a != parent[a]) {\\n      parent[a] = find(parent[a]);\\n    }\\n    return parent[a];\\n  }\\n\\n  void union(int a, int b) {\\n    int parentA = find(a);\\n    int parentB = find(b);\\n\\n    if (parentA == parentB) return;\\n\\n    if (parentA < parentB) {\\n      parent[parentB] = parentA;\\n    } else {\\n      parent[parentA] = parentB;\\n    }\\n  }\\n}\\n\\nclass Solution {\\n  String smallestEquivalentString(String s1, String s2, String baseStr) {\\n    UnionFind uf = UnionFind();\\n    for (int i = 0; i < s1.length; ++i) {\\n      uf.union(s1.codeUnitAt(i) - \\'a\\'.codeUnitAt(0),\\n          s2.codeUnitAt(i) - \\'a\\'.codeUnitAt(0));\\n    }\\n\\n    StringBuffer sb = StringBuffer();\\n    for (String ch in baseStr.split(\"\")) {\\n      sb.writeCharCode(\\n          (\\'a\\'.codeUnitAt(0) + uf.find(ch.codeUnitAt(0) - \\'a\\'.codeUnitAt(0))));\\n    }\\n    return sb.toString();\\n  }\\n}\\n```\\n\\n### [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)\\n",
                "solutionTags": [
                    "Dart",
                    "String",
                    "Union Find"
                ],
                "code": "```dart\\nclass UnionFind {\\n  List<int> parent = List.filled(26, 0);\\n\\n  UnionFind() {\\n    for (int i = 0; i < 26; ++i) {\\n      parent[i] = i;\\n    }\\n  }\\n\\n  int find(int a) {\\n    if (a != parent[a]) {\\n      parent[a] = find(parent[a]);\\n    }\\n    return parent[a];\\n  }\\n\\n  void union(int a, int b) {\\n    int parentA = find(a);\\n    int parentB = find(b);\\n\\n    if (parentA == parentB) return;\\n\\n    if (parentA < parentB) {\\n      parent[parentB] = parentA;\\n    } else {\\n      parent[parentA] = parentB;\\n    }\\n  }\\n}\\n\\nclass Solution {\\n  String smallestEquivalentString(String s1, String s2, String baseStr) {\\n    UnionFind uf = UnionFind();\\n    for (int i = 0; i < s1.length; ++i) {\\n      uf.union(s1.codeUnitAt(i) - \\'a\\'.codeUnitAt(0),\\n          s2.codeUnitAt(i) - \\'a\\'.codeUnitAt(0));\\n    }\\n\\n    StringBuffer sb = StringBuffer();\\n    for (String ch in baseStr.split(\"\")) {\\n      sb.writeCharCode(\\n          (\\'a\\'.codeUnitAt(0) + uf.find(ch.codeUnitAt(0) - \\'a\\'.codeUnitAt(0))));\\n    }\\n    return sb.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050552,
                "title": "typescript-union-find-string",
                "content": "# Intuition\\nGroup all equivalent characters and have the minimum char as the representation of the group \\n\\n# Approach\\nuses union-find data structure and algorithm \\n\\n# Complexity\\n- Time complexity:\\n    $$O(n*d)$$\\n> d is the depth of the union tree  \\n\\n- Space complexity:\\n    $$O(n)$$\\n\\n# Code\\n```\\nfunction smallestEquivalentString(s1: string, s2: string, baseStr: string): string {\\n    const unions: Map<string, string> = new Map();\\n\\n    const find = (s:string):string => {\\n        while(s != unions.get(s)){\\n            s = unions.get(s)\\n        }\\n        return s \\n    }\\n\\n    const union = (a:string,b:string) => {\\n       if(a < b){\\n           unions.set(b, a)\\n       }else{\\n           unions.set(a, b);\\n       } \\n    }\\n\\n    for(let i = 0; i < s1.length; i++){\\n        if(!unions.has(s1[i])){\\n            unions.set(s1[i], s1[i])\\n        }\\n        if(!unions.has(s2[i])){\\n            unions.set(s2[i], s2[i])\\n        }\\n        union(find(s1[i]), find(s2[i]))\\n    }\\n\\n    let result = \"\";\\n\\n    for(let i = 0; i < baseStr.length; i++){\\n        result += (find(baseStr[i]) ?? baseStr[i])\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Union Find"
                ],
                "code": "```\\nfunction smallestEquivalentString(s1: string, s2: string, baseStr: string): string {\\n    const unions: Map<string, string> = new Map();\\n\\n    const find = (s:string):string => {\\n        while(s != unions.get(s)){\\n            s = unions.get(s)\\n        }\\n        return s \\n    }\\n\\n    const union = (a:string,b:string) => {\\n       if(a < b){\\n           unions.set(b, a)\\n       }else{\\n           unions.set(a, b);\\n       } \\n    }\\n\\n    for(let i = 0; i < s1.length; i++){\\n        if(!unions.has(s1[i])){\\n            unions.set(s1[i], s1[i])\\n        }\\n        if(!unions.has(s2[i])){\\n            unions.set(s2[i], s2[i])\\n        }\\n        union(find(s1[i]), find(s2[i]))\\n    }\\n\\n    let result = \"\";\\n\\n    for(let i = 0; i < baseStr.length; i++){\\n        result += (find(baseStr[i]) ?? baseStr[i])\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3050538,
                "title": "simple-7-line-ruby-solution-with-explanation",
                "content": "# Intuition\\n1) Make a \"hash\" for each character that has no lexicographically smallest equivalent (every character has only \"self\" as an equivalent).\\n\\n\\n2) For each \"i\" character at \"s1\" and \"s2,\"\\na) Find the new lexicographically smallest equivalent for the character \"i\" from \"s1\" and \"s2.\"\\nb) Update all characters from the previous lexicographically smallest equivalent to the new lexicographically smallest equivalent.\\n\\n\\n3) Find the lexicographically smallest equivalent in \"hash\" for each character in \"base_str.\"\\xA0\\n\\n\\n# Code\\n```\\n# @param {String} s1\\n# @param {String} s2\\n# @param {String} base_str\\n# @return {String}\\ndef smallest_equivalent_string(s1, s2, base_str)\\n  hash = (\\'a\\'..\\'z\\').each_with_object({}) { |char, hash| hash[char] = char }\\n\\n  s1.size.times do |index|\\n    s1_l_sm_eq = hash[s1[index]]\\n    s2_l_sm_eq = hash[s2[index]]\\n    new_l_sm_eq = s1_l_sm_eq < s2_l_sm_eq ? s1_l_sm_eq : s2_l_sm_eq\\n    \\n    hash.each { |k, v| hash[k] = new_l_sm_eq if v == s1_l_sm_eq || v == s2_l_sm_eq }\\n  end\\n\\n  base_str.split(\\'\\').map { |c| hash[c] }.join(\\'\\')\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s1\\n# @param {String} s2\\n# @param {String} base_str\\n# @return {String}\\ndef smallest_equivalent_string(s1, s2, base_str)\\n  hash = (\\'a\\'..\\'z\\').each_with_object({}) { |char, hash| hash[char] = char }\\n\\n  s1.size.times do |index|\\n    s1_l_sm_eq = hash[s1[index]]\\n    s2_l_sm_eq = hash[s2[index]]\\n    new_l_sm_eq = s1_l_sm_eq < s2_l_sm_eq ? s1_l_sm_eq : s2_l_sm_eq\\n    \\n    hash.each { |k, v| hash[k] = new_l_sm_eq if v == s1_l_sm_eq || v == s2_l_sm_eq }\\n  end\\n\\n  base_str.split(\\'\\').map { |c| hash[c] }.join(\\'\\')\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3050537,
                "title": "c-easy-solution-using-union-find-intuitive",
                "content": "## Easy to understand, must upvote! \\uD83D\\uDE43\\n\\n# Code\\n```\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n\\nclass DSU {\\n\\tvector<int> parent;\\npublic:\\n\\tDSU(int n) {\\n\\t\\tparent.resize(n, 0);\\n\\t\\tfor(int i = 0; i < n; i++) parent[i] = i;\\n\\t}\\n\\tint find(int x) {\\n\\t\\tif(parent[x] == x)\\n\\t\\t\\treturn x;\\n\\t\\treturn parent[x] = min(x, find(parent[x]));\\n\\t}\\n\\tvoid merge(int u, int v) {\\n\\t\\tint a = find(u), b = find(v);\\n\\t\\tif(a != b) {\\n\\t\\t\\tif(a < b) {\\n\\t\\t\\t\\tparent[b] = a;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tparent[a] = b;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DSU dsu(26);\\n        string result = \"\";\\n        for(int i = 0; i < s1.length(); i++) {\\n            dsu.merge(s1[i]-\\'a\\', s2[i]-\\'a\\');\\n        }\\n        for(int i = 0; i < baseStr.length(); i++) {\\n            result += \\'a\\' + dsu.find(baseStr[i]-\\'a\\');\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n\\nclass DSU {\\n\\tvector<int> parent;\\npublic:\\n\\tDSU(int n) {\\n\\t\\tparent.resize(n, 0);\\n\\t\\tfor(int i = 0; i < n; i++) parent[i] = i;\\n\\t}\\n\\tint find(int x) {\\n\\t\\tif(parent[x] == x)\\n\\t\\t\\treturn x;\\n\\t\\treturn parent[x] = min(x, find(parent[x]));\\n\\t}\\n\\tvoid merge(int u, int v) {\\n\\t\\tint a = find(u), b = find(v);\\n\\t\\tif(a != b) {\\n\\t\\t\\tif(a < b) {\\n\\t\\t\\t\\tparent[b] = a;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tparent[a] = b;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DSU dsu(26);\\n        string result = \"\";\\n        for(int i = 0; i < s1.length(); i++) {\\n            dsu.merge(s1[i]-\\'a\\', s2[i]-\\'a\\');\\n        }\\n        for(int i = 0; i < baseStr.length(); i++) {\\n            result += \\'a\\' + dsu.find(baseStr[i]-\\'a\\');\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3050459,
                "title": "faster-solution-89-8",
                "content": "\\n# Code\\n```\\nfrom io import StringIO\\n\\nclass StringBuilder:\\n    _file_str = None\\n    def __init__(self):\\n        self._file_str = StringIO()\\n    def append(self, s):\\n        self._file_str.write(s)\\n    def __str__(self):\\n        return self._file_str.getvalue()\\n\\nclass Solution(object):\\n    def find_parent(self,chars, character):\\n        order = ord(character) - ord(\"a\")\\n        while chars[order] != order:\\n            order = chars[order]\\n        return order\\n    def smallestEquivalentString(self, s1, s2, base):\\n        chars = [i for i in range(26)]\\n        for i in range(len(s1)):\\n            ist_char = s1[i]\\n            sec_char = s2[i]\\n            ist_char_order = self.find_parent(chars, ist_char)\\n            sec_char_order = self.find_parent(chars, sec_char)\\n            if ist_char_order < sec_char_order:\\n                chars[sec_char_order] = ist_char_order\\n            else:\\n                chars[ist_char_order] = sec_char_order\\n        s = StringBuilder()\\n        for i in base:\\n            parent=self.find_parent(chars,i)\\n            s.append(chr(parent+ord(\"a\")))\\n        return str(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nfrom io import StringIO\\n\\nclass StringBuilder:\\n    _file_str = None\\n    def __init__(self):\\n        self._file_str = StringIO()\\n    def append(self, s):\\n        self._file_str.write(s)\\n    def __str__(self):\\n        return self._file_str.getvalue()\\n\\nclass Solution(object):\\n    def find_parent(self,chars, character):\\n        order = ord(character) - ord(\"a\")\\n        while chars[order] != order:\\n            order = chars[order]\\n        return order\\n    def smallestEquivalentString(self, s1, s2, base):\\n        chars = [i for i in range(26)]\\n        for i in range(len(s1)):\\n            ist_char = s1[i]\\n            sec_char = s2[i]\\n            ist_char_order = self.find_parent(chars, ist_char)\\n            sec_char_order = self.find_parent(chars, sec_char)\\n            if ist_char_order < sec_char_order:\\n                chars[sec_char_order] = ist_char_order\\n            else:\\n                chars[ist_char_order] = sec_char_order\\n        s = StringBuilder()\\n        for i in base:\\n            parent=self.find_parent(chars,i)\\n            s.append(chr(parent+ord(\"a\")))\\n        return str(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050452,
                "title": "beats-100-runtime-and-memory-short-explanation-using-union-find",
                "content": "# Intuition\\n1. We cannot use HashMap or Array of Arraylist because the transitive property wouldn\\'t work\\n2. We have to use some kind of data structure that would give us the lexicographically smallest character after keeping the transitive property in mind\\n3. So, Union-Find is the only way where we can get the lexicographically smallest character every time when we make the lexicographically smallest character as the parent of the character of each group\\n\\n# Approach\\n1. We have to create groups - Here, we create unionise the characters \\n2. We have to get the lexicographically smallest character so, we make this the parent of each group\\n3. Lastly, get the smallest character by using the find function.\\n\\n# Complexity\\n- Time complexity: O(s1.length())\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int find(int parent[], int i) {\\n        if (parent[i] == i)\\n            return i;\\n        return parent[i] = find(parent, parent[i]); \\n    }\\n \\n    void Union(int parent[], int x, int y) {\\n        if(y < x) parent[x] = y;\\n        else parent[y] = x;\\n    }\\n \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int[] parent = new int[26];\\n\\n        for (int i = 0; i < 26; ++i)\\n            parent[i] = i;\\n\\n        for(int i=0; i<s1.length(); i++) {\\n            int x = find(parent, s1.charAt(i)-\\'a\\');\\n            int y = find(parent, s2.charAt(i)-\\'a\\');\\n            Union(parent, x, y);\\n        } \\n\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=0; i<baseStr.length(); i++) {\\n            ans.append((char)(find(parent, baseStr.charAt(i)-\\'a\\')+\\'a\\'));\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int find(int parent[], int i) {\\n        if (parent[i] == i)\\n            return i;\\n        return parent[i] = find(parent, parent[i]); \\n    }\\n \\n    void Union(int parent[], int x, int y) {\\n        if(y < x) parent[x] = y;\\n        else parent[y] = x;\\n    }\\n \\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int[] parent = new int[26];\\n\\n        for (int i = 0; i < 26; ++i)\\n            parent[i] = i;\\n\\n        for(int i=0; i<s1.length(); i++) {\\n            int x = find(parent, s1.charAt(i)-\\'a\\');\\n            int y = find(parent, s2.charAt(i)-\\'a\\');\\n            Union(parent, x, y);\\n        } \\n\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=0; i<baseStr.length(); i++) {\\n            ans.append((char)(find(parent, baseStr.charAt(i)-\\'a\\')+\\'a\\'));\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050418,
                "title": "java-solution-t-m-100-easy",
                "content": "class UnionFind {\\n  public UnionFind(int n) {\\n    id = new int[n];\\n    for (int i = 0; i < n; ++i)\\n      id[i] = i;\\n  }\\n\\n  public void union(int u, int v) {\\n    final int i = find(u);\\n    final int j = find(v);\\n    if (i > j)\\n      id[i] = j;\\n    else\\n      id[j] = i;\\n  }\\n\\n  public int find(int u) {\\n    return id[u] == u ? u : (id[u] = find(id[u]));\\n  }\\n\\n  private int[] id;\\n}\\n\\nclass Solution {\\n  public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n    StringBuilder sb = new StringBuilder();\\n    UnionFind uf = new UnionFind(26);\\n\\n    for (int i = 0; i < s1.length(); ++i)\\n      uf.union(s1.charAt(i) - \\'a\\', s2.charAt(i) - \\'a\\');\\n\\n    for (final char c : baseStr.toCharArray())\\n      sb.append((char) (\\'a\\' + uf.find(c - \\'a\\')));\\n\\n    return sb.toString();\\n  }\\n}",
                "solutionTags": [
                    "String",
                    "Union Find"
                ],
                "code": "class Solution {\\n  public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n    StringBuilder sb = new StringBuilder();\\n    UnionFind uf = new UnionFind(26);\\n\\n    for (int i = 0; i < s1.length(); ++i)\\n      uf.union(s1.charAt(i) - \\'a\\', s2.charAt(i) - \\'a\\');\\n\\n    for (final char c : baseStr.toCharArray())\\n      sb.append((char) (\\'a\\' + uf.find(c - \\'a\\')));\\n\\n    return sb.toString();\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 3050230,
                "title": "easy-implementation-using-disjoint-set-union-in-c",
                "content": "# Code\\n```\\nclass DisjointSet\\n{\\n    vector<int> par;\\n    public:\\n        DisjointSet()\\n        {\\n            par.resize(27);\\n            for(int i=0;i<27;i++)\\n            {\\n                par[i]=i;\\n            }\\n        }\\n        int findUPar(int i)\\n        {\\n            if(i==par[i])\\n                return i;\\n            return par[i]=findUPar(par[i]);\\n        }\\n        void UnionByCmp(int x,int y)\\n        {\\n            int ulp_x=findUPar(x);\\n            int ulp_y=findUPar(y);\\n\\n            if(ulp_x == ulp_y)\\n                return;\\n            if(ulp_x < ulp_y)\\n            {\\n                par[ulp_y]=par[ulp_x];\\n            }\\n            else \\n            {\\n                par[ulp_x]=par[ulp_y];\\n            }\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DisjointSet ds;\\n        string fk=\"abcdefghijklmnopqrstuvwxyz\";\\n        int n=s1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ds.UnionByCmp(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++)\\n        {\\n            int asc=baseStr[i]-\\'a\\';\\n            ans.push_back(fk[ds.findUPar(asc)]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet\\n{\\n    vector<int> par;\\n    public:\\n        DisjointSet()\\n        {\\n            par.resize(27);\\n            for(int i=0;i<27;i++)\\n            {\\n                par[i]=i;\\n            }\\n        }\\n        int findUPar(int i)\\n        {\\n            if(i==par[i])\\n                return i;\\n            return par[i]=findUPar(par[i]);\\n        }\\n        void UnionByCmp(int x,int y)\\n        {\\n            int ulp_x=findUPar(x);\\n            int ulp_y=findUPar(y);\\n\\n            if(ulp_x == ulp_y)\\n                return;\\n            if(ulp_x < ulp_y)\\n            {\\n                par[ulp_y]=par[ulp_x];\\n            }\\n            else \\n            {\\n                par[ulp_x]=par[ulp_y];\\n            }\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        DisjointSet ds;\\n        string fk=\"abcdefghijklmnopqrstuvwxyz\";\\n        int n=s1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ds.UnionByCmp(s1[i]-\\'a\\',s2[i]-\\'a\\');\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++)\\n        {\\n            int asc=baseStr[i]-\\'a\\';\\n            ans.push_back(fk[ds.findUPar(asc)]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050205,
                "title": "python-short-and-clean-dsu-disjoint-set-union-union-find",
                "content": "# Approach\\n1. Implement a custom Disjoint-Set-Union class `DSU`, say `LexicoDSU`, which maintains the lexicographically smaller element of the disjoint-set as root.\\n2. Create an instance of `LexicoDSU`.\\n3. Take corresponding pair of characters in `s1` and `s2`, add add them to the disjoint-set using `lexicoDSU.union`.\\n4. Now to find the lexical smallest character for `base_str` use `lexicoDSU.find` on each character.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere `n is the maximum length of s1, s2, and base_str`\\n\\n# Code\\n```Python\\nfrom collections.abc import *\\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, base_str: str) -> str:\\n        charset = string.ascii_lowercase\\n\\n        lexicoDSU = LexicoDSU(charset)\\n        for u, v in zip(s1, s2): lexicoDSU.union(u, v)\\n\\n        return \"\".join(map(lexicoDSU.find, base_str))\\n\\nclass LexicoDSU:\\n    \"\"\"A DSU implementation which maintains the lexicographically smaller element of the disjoint-set as root\"\"\"\\n    T = Hashable\\n\\n    def __init__(self, xs: Iterable[T] = tuple()) -> None:\\n        self.parents = {x: x for x in xs}\\n    \\n    def add(self, x: T) -> None:\\n        if x in self.parents: return\\n        self.parents[x] = x\\n    \\n    def make_safe(func: Callable) -> Callable:\\n        def wrapper(self, *xs):\\n            for x in xs: self.add(x)\\n            return func(self, *xs)\\n        return wrapper\\n    \\n    @make_safe\\n    def union(self, u: T, v: T) -> None:\\n        ur, vr = self.find(u), self.find(v)\\n        small, large = (ur, vr) if ur < vr else (vr, ur) # Enforces lexical order.\\n        self.parents[large] = small\\n    \\n    @make_safe\\n    def find(self, x: T) -> T:\\n        self.parents[x] = self.find(self.parents[x]) if self.parents[x] != x else x\\n        return self.parents[x]\\n    \\n    @make_safe\\n    def is_connected(self, u: T, v: T) -> bool:\\n        return self.find(u) == self.find(v)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Union Find"
                ],
                "code": "```Python\\nfrom collections.abc import *\\n\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, base_str: str) -> str:\\n        charset = string.ascii_lowercase\\n\\n        lexicoDSU = LexicoDSU(charset)\\n        for u, v in zip(s1, s2): lexicoDSU.union(u, v)\\n\\n        return \"\".join(map(lexicoDSU.find, base_str))\\n\\nclass LexicoDSU:\\n    \"\"\"A DSU implementation which maintains the lexicographically smaller element of the disjoint-set as root\"\"\"\\n    T = Hashable\\n\\n    def __init__(self, xs: Iterable[T] = tuple()) -> None:\\n        self.parents = {x: x for x in xs}\\n    \\n    def add(self, x: T) -> None:\\n        if x in self.parents: return\\n        self.parents[x] = x\\n    \\n    def make_safe(func: Callable) -> Callable:\\n        def wrapper(self, *xs):\\n            for x in xs: self.add(x)\\n            return func(self, *xs)\\n        return wrapper\\n    \\n    @make_safe\\n    def union(self, u: T, v: T) -> None:\\n        ur, vr = self.find(u), self.find(v)\\n        small, large = (ur, vr) if ur < vr else (vr, ur) # Enforces lexical order.\\n        self.parents[large] = small\\n    \\n    @make_safe\\n    def find(self, x: T) -> T:\\n        self.parents[x] = self.find(self.parents[x]) if self.parents[x] != x else x\\n        return self.parents[x]\\n    \\n    @make_safe\\n    def is_connected(self, u: T, v: T) -> bool:\\n        return self.find(u) == self.find(v)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050186,
                "title": "simple-c-solution-using-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<char> par;\\n    // vector<int> rank;\\n    char find(char ch) {\\n        if(par[ch - \\'a\\'] == ch) return ch;\\n        return par[ch - \\'a\\'] = find(par[ch - \\'a\\']);\\n    }\\n    void Union(char ch1, char ch2) {\\n        char parCh1 = find(ch1);\\n        char parCh2 = find(ch2);\\n        if(parCh1 == parCh2) return;\\n        if(parCh1 - \\'a\\' < parCh2 - \\'a\\') {\\n            par[parCh2 - \\'a\\'] = parCh1;\\n        }\\n        else {\\n            par[parCh1 - \\'a\\'] = parCh2;\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        string ans = \"\";\\n        // rank.assign(26, 0);\\n        par.assign(26, \\'a\\');\\n        for(int i = 0; i < 26; i++) {\\n            par[i] = char(i+97);\\n        }\\n        for(int i = 0; i < s1.size(); i++) {\\n            Union(s1[i], s2[i]);\\n        }\\n        for(int i = 0; i < baseStr.size(); i++) {\\n            ans += find(baseStr[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<char> par;\\n    // vector<int> rank;\\n    char find(char ch) {\\n        if(par[ch - \\'a\\'] == ch) return ch;\\n        return par[ch - \\'a\\'] = find(par[ch - \\'a\\']);\\n    }\\n    void Union(char ch1, char ch2) {\\n        char parCh1 = find(ch1);\\n        char parCh2 = find(ch2);\\n        if(parCh1 == parCh2) return;\\n        if(parCh1 - \\'a\\' < parCh2 - \\'a\\') {\\n            par[parCh2 - \\'a\\'] = parCh1;\\n        }\\n        else {\\n            par[parCh1 - \\'a\\'] = parCh2;\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        string ans = \"\";\\n        // rank.assign(26, 0);\\n        par.assign(26, \\'a\\');\\n        for(int i = 0; i < 26; i++) {\\n            par[i] = char(i+97);\\n        }\\n        for(int i = 0; i < s1.size(); i++) {\\n            Union(s1[i], s2[i]);\\n        }\\n        for(int i = 0; i < baseStr.size(); i++) {\\n            ans += find(baseStr[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050175,
                "title": "c-solution-using-dsu-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere to Solve this Problem we can use DSU\\nFirst, we will consider each char is parent to itself  and will count each char from 0 to 26\\n**S1  = \"parker\" **\\n![string1.JPG](https://assets.leetcode.com/users/images/59b12790-7087-4708-a1dc-e520b4ce594e_1673703135.5341291.jpeg)\\n\\n**S2  = \"morris\" **\\n![string2.JPG](https://assets.leetcode.com/users/images/e2df78b9-8085-45e8-bd50-a3b60fb2d718_1673703176.089697.jpeg)\\n\\nAnd then will merge every to char s1[i] and s2[i] and make the one who is smaller than other is the parent\\n![merge.JPG](https://assets.leetcode.com/users/images/d76da0ac-2e8c-42fa-b0ec-8738b8331639_1673703203.6841376.jpeg)\\n\\nAfter merge the parent array will has smallest char \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint par[26];\\nvoid init(int sz){\\n    for(int i=0;i<sz;i++){\\n        par[i]=i;\\n    }\\n   \\n}\\nint find( int u){\\n    if(u==par[u])return u;\\n    return par[u]=find(par[u]);\\n}\\nvoid Merge(int u,int v){\\n    int p1=find(u);\\n    int p2=find(v);\\n    if(p1==p2)return;\\n    if(p1 <p2)swap(p1,p2);\\n    par[p1]=par[p2];\\n}\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        init(26);\\n        int sz = s1.size();\\n        for(int i = 0 ;i<sz;i++){\\n            Merge(s1[i] - \\'a\\' , s2[i] - \\'a\\');\\n        }\\n         sz = baseStr.size();\\n         for(int i = 0 ; i<26;i++){\\n             find(i);\\n         }\\n        for(int i = 0 ; i <sz;i++){\\n            baseStr[i] = par[baseStr[i]-\\'a\\'] + \\'a\\';\\n        }\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint par[26];\\nvoid init(int sz){\\n    for(int i=0;i<sz;i++){\\n        par[i]=i;\\n    }\\n   \\n}\\nint find( int u){\\n    if(u==par[u])return u;\\n    return par[u]=find(par[u]);\\n}\\nvoid Merge(int u,int v){\\n    int p1=find(u);\\n    int p2=find(v);\\n    if(p1==p2)return;\\n    if(p1 <p2)swap(p1,p2);\\n    par[p1]=par[p2];\\n}\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        init(26);\\n        int sz = s1.size();\\n        for(int i = 0 ;i<sz;i++){\\n            Merge(s1[i] - \\'a\\' , s2[i] - \\'a\\');\\n        }\\n         sz = baseStr.size();\\n         for(int i = 0 ; i<26;i++){\\n             find(i);\\n         }\\n        for(int i = 0 ; i <sz;i++){\\n            baseStr[i] = par[baseStr[i]-\\'a\\'] + \\'a\\';\\n        }\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050119,
                "title": "python-dfs-and-union-both-solution",
                "content": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        \\n        # radhe krishna - solution based on dfs\\n        \\n        dic = defaultdict(set) \\n        \\n        for i in range(len(s1)) : \\n            dic[s1[i]].add(s2[i])\\n            dic[s2[i]].add(s1[i])\\n        \\n        ans1 = \\'\\' \\n    \\n        def dfs(s, parent) : \\n            c = \\'z\\'\\n            if s not in visited : \\n                visited.add(s)\\n                for equi in dic[s] : \\n                     c = min(c, dfs(equi, s) )\\n            return min(c, s)\\n              \\n        for i in baseStr : \\n            visited = set( )\\n            ans1 += dfs(i, \\'\\')\\n     \\n        return ans1\\n```\\n\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        \\n        # radhe krishna  - union based solution \\n        \\n        dic = defaultdict(set) \\n        \\n        for i in range(len(s1)) : \\n            dic[s1[i]].add(s2[i])\\n            dic[s2[i]].add(s1[i])\\n        \\n        for i in dic : \\n            for j in dic[i] : \\n                dic[i] = dic[i].union(dic[j])\\n        \\n\\t\\t#again to keep all transitive relation dependency \\n        for i in dic : \\n            for j in dic[i] : \\n                dic[i] = dic[i].union(dic[j])\\n            \\n        for i in dic : \\n            dic[i] = sorted(list(dic[i]))\\n        \\n        ans1 = \\'\\'\\n        for i in baseStr: \\n            if i in dic : \\n                ans1 += dic[i][0]\\n            else : \\n                ans1 += i\\n     \\n        return ans1\\n        \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        \\n        # radhe krishna - solution based on dfs\\n        \\n        dic = defaultdict(set) \\n        \\n        for i in range(len(s1)) : \\n            dic[s1[i]].add(s2[i])\\n            dic[s2[i]].add(s1[i])\\n        \\n        ans1 = \\'\\' \\n    \\n        def dfs(s, parent) : \\n            c = \\'z\\'\\n            if s not in visited : \\n                visited.add(s)\\n                for equi in dic[s] : \\n                     c = min(c, dfs(equi, s) )\\n            return min(c, s)\\n              \\n        for i in baseStr : \\n            visited = set( )\\n            ans1 += dfs(i, \\'\\')\\n     \\n        return ans1\\n```\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        \\n        # radhe krishna  - union based solution \\n        \\n        dic = defaultdict(set) \\n        \\n        for i in range(len(s1)) : \\n            dic[s1[i]].add(s2[i])\\n            dic[s2[i]].add(s1[i])\\n        \\n        for i in dic : \\n            for j in dic[i] : \\n                dic[i] = dic[i].union(dic[j])\\n        \\n\\t\\t#again to keep all transitive relation dependency \\n        for i in dic : \\n            for j in dic[i] : \\n                dic[i] = dic[i].union(dic[j])\\n            \\n        for i in dic : \\n            dic[i] = sorted(list(dic[i]))\\n        \\n        ans1 = \\'\\'\\n        for i in baseStr: \\n            if i in dic : \\n                ans1 += dic[i][0]\\n            else : \\n                ans1 += i\\n     \\n        return ans1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050079,
                "title": "c-solution-graph-approach-explained",
                "content": "# Intuition\\nWe need to group all the equal characters together and find the minimum out of all of them. So we can try to use graph and connect all the equal characters together.\\n\\n# Approach\\nWe first create a graph in the form of map where we group all the equal characters together. Then for every character of baseStr we make a bfs call from that character and we\\'ll keep a track of minimum character found in the path. We\\'ll use that characterin the equivalent string to make it the smallest string possible.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char,vector<char>>mp;\\n        for(int i = 0;i < s1.length(); i++)\\n        {\\n            if(s1[i] == s2[i])\\n            {\\n                continue;\\n            }\\n            mp[s1[i]].push_back(s2[i]);\\n            mp[s2[i]].push_back(s1[i]);\\n        }\\n        string ans = \"\";\\n        for(int i = 0;i < baseStr.length(); i++)\\n        {\\n           char t = solve(baseStr[i],mp);\\n           ans += t;\\n        }\\n        return ans;\\n    }\\n\\n    char solve(char& c, map<char,vector<char>>& mp)\\n    {\\n       set<char>visited;\\n       visited.insert(c);\\n       char minchar = c;\\n       queue<char>q;\\n       q.push(c);\\n       while(!q.empty())\\n       {\\n        char temp = q.front();\\n        minchar = min(minchar, temp);\\n        q.pop();\\n        for(int i = 0;i < mp[temp].size(); i++)\\n        {\\n            if(visited.find(mp[temp][i]) == visited.end())\\n            {\\n                q.push(mp[temp][i]);\\n                visited.insert(mp[temp][i]);\\n            }\\n        }\\n       }\\n       return minchar;\\n    }\\n};\\n```\\n**Do upvote if you understood it !\\uD83D\\uDE00**",
                "solutionTags": [
                    "C++",
                    "String",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char,vector<char>>mp;\\n        for(int i = 0;i < s1.length(); i++)\\n        {\\n            if(s1[i] == s2[i])\\n            {\\n                continue;\\n            }\\n            mp[s1[i]].push_back(s2[i]);\\n            mp[s2[i]].push_back(s1[i]);\\n        }\\n        string ans = \"\";\\n        for(int i = 0;i < baseStr.length(); i++)\\n        {\\n           char t = solve(baseStr[i],mp);\\n           ans += t;\\n        }\\n        return ans;\\n    }\\n\\n    char solve(char& c, map<char,vector<char>>& mp)\\n    {\\n       set<char>visited;\\n       visited.insert(c);\\n       char minchar = c;\\n       queue<char>q;\\n       q.push(c);\\n       while(!q.empty())\\n       {\\n        char temp = q.front();\\n        minchar = min(minchar, temp);\\n        q.pop();\\n        for(int i = 0;i < mp[temp].size(); i++)\\n        {\\n            if(visited.find(mp[temp][i]) == visited.end())\\n            {\\n                q.push(mp[temp][i]);\\n                visited.insert(mp[temp][i]);\\n            }\\n        }\\n       }\\n       return minchar;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050069,
                "title": "c-union-find-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUnion have to be used since linking of characters is there and the top parent of each connected component will help us give the smallest(lexicographically) character for every component\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int root[26];\\n    \\n    // find the parent method\\n    int getparent(int x) {\\n        if (x == root[x])\\n            return x;\\n        //path compression\\n        return root[x] = getparent(root[x]);\\n    }\\n    \\n    // union of two elements\\n    void unionize(int x, int y) {\\n        // find the root of x\\n        x = getparent(x);\\n        // find the root of y\\n        y = getparent(y);\\n        // if their roots are not same, we combine them\\n        if (x != y) {\\n            // smaller first\\n            if (x < y)\\n                root[y] = x;\\n            else \\n                root[x] = y;\\n        }\\n        return;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        // dsu\\n        string ans;\\n        // init root. initialy each element is in its own group.\\n        for (int i = 0; i < 26; i++)  \\n            root[i] = i;\\n        // union of each character\\n        for (int i = 0; i < s1.size(); i++) \\n            unionize(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        // build the final answer from the root element (smallest)\\n        for (auto x : baseStr)\\n            ans += (char)(getparent(x - \\'a\\') + \\'a\\');\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int root[26];\\n    \\n    // find the parent method\\n    int getparent(int x) {\\n        if (x == root[x])\\n            return x;\\n        //path compression\\n        return root[x] = getparent(root[x]);\\n    }\\n    \\n    // union of two elements\\n    void unionize(int x, int y) {\\n        // find the root of x\\n        x = getparent(x);\\n        // find the root of y\\n        y = getparent(y);\\n        // if their roots are not same, we combine them\\n        if (x != y) {\\n            // smaller first\\n            if (x < y)\\n                root[y] = x;\\n            else \\n                root[x] = y;\\n        }\\n        return;\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        // dsu\\n        string ans;\\n        // init root. initialy each element is in its own group.\\n        for (int i = 0; i < 26; i++)  \\n            root[i] = i;\\n        // union of each character\\n        for (int i = 0; i < s1.size(); i++) \\n            unionize(s1[i] - \\'a\\', s2[i] - \\'a\\');\\n        // build the final answer from the root element (smallest)\\n        for (auto x : baseStr)\\n            ans += (char)(getparent(x - \\'a\\') + \\'a\\');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050028,
                "title": "ruby-o-n-solution",
                "content": "# Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {String} s1\\n# @param {String} s2\\n# @param {String} base_str\\n# @return {String}\\ndef smallest_equivalent_string(s1, s2, base_str)\\n    root = (0..25).to_a\\n  \\n    def find(c, root)\\n        i = c.ord - \\'a\\'.ord\\n        while root[i] != i\\n            i = root[i]\\n        end\\n        return i\\n    end\\n    \\n    s1.chars.zip(s2.chars).each do |ch1, ch2|\\n        r1, r2 = find(ch1, root), find(ch2, root)\\n        if r1 > r2\\n            r1, r2 = r2, r1\\n        end\\n        root[r2] = r1\\n    end\\n    \\n    base_str.chars.map { |c| (find(c, root) + \\'a\\'.ord).chr }.join\\n    \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s1\\n# @param {String} s2\\n# @param {String} base_str\\n# @return {String}\\ndef smallest_equivalent_string(s1, s2, base_str)\\n    root = (0..25).to_a\\n  \\n    def find(c, root)\\n        i = c.ord - \\'a\\'.ord\\n        while root[i] != i\\n            i = root[i]\\n        end\\n        return i\\n    end\\n    \\n    s1.chars.zip(s2.chars).each do |ch1, ch2|\\n        r1, r2 = find(ch1, root), find(ch2, root)\\n        if r1 > r2\\n            r1, r2 = r2, r1\\n        end\\n        root[r2] = r1\\n    end\\n    \\n    base_str.chars.map { |c| (find(c, root) + \\'a\\'.ord).chr }.join\\n    \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3049896,
                "title": "c-union-find-c-beats-100-video-editorial-dry-run",
                "content": "# Explanation\\n\\nThe class `union_find` has two main methods: `find_parent` and `merge`. The `find_parent` method takes a character and returns its parent character. The parent character is the representative element of the set that the character belongs to. The `merge` method takes two characters and merges the sets that they belong to.\\n\\nThe class `Solution` has one method `smallestEquivalentString` which takes three strings as input: `s1`, `s2`, and `baseStr`. It creates an instance of `union_find` and uses it to merge all the character pairs of `s1` and `s2`. Then, it iterates through `baseStr` and replaces each character with its parent character. Finally, it returns the modified `baseStr`.\\n\\nThe purpose of this code is to build a union-find data structure and use it to find the smallest equivalent string from the base string.\\n\\n# Dry Run (Test - 1)\\n```\\ns1 = \"parker\"\\ns2 = \"morris\"\\nbaseStr = \"parser\"\\n\\n1. Index - 0\\ns1[0] = \\'p\\'\\ns2[0] = \\'m\\'\\n\\n\\'p\\' == \\'m\\' (\\'m\\' is lexicographically smaller than \\'p\\')\\n\\nTherefore, \\'m\\' will be a parent of \\'p\\'\\n   \\n   m\\n    \\\\ \\n     p\\n2. Index - 1\\ns1[1] = \\'a\\'\\ns2[1] = \\'o\\'\\n\\n\\'a\\' == \\'o\\' (\\'a\\' is lexicographically smaller than \\'o\\')\\n\\nTherefore, \\'a\\' will be a parent of \\'o\\'\\n   \\n   a\\n    \\\\ \\n     o\\n\\n3. Index - 2\\ns1[2] = \\'r\\'\\ns2[2] = \\'r\\'\\n\\n\\'r\\' == \\'r\\' (No effect)\\n\\n4. Index - 3\\ns1[3] = \\'k\\'\\ns2[3] = \\'r\\'\\n\\n\\'k\\' == \\'r\\' (\\'k\\' is lexicographically smaller than \\'r\\')\\n\\nTherefore, \\'k\\' will be a parent of \\'r\\'\\n   \\n   k\\n    \\\\ \\n     r\\n\\n5. Index - 4\\ns1[4] = \\'e\\'\\ns2[4] = \\'i\\'\\n\\n\\'e\\' == \\'i\\' (\\'e\\' is lexicographically smaller than \\'i\\')\\n\\nTherefore, \\'e\\' will be a parent of \\'i\\'\\n   \\n   e\\n    \\\\ \\n     i\\n\\n6. Index - 5\\ns1[5] = \\'r\\'\\ns2[5] = \\'s\\'\\n\\n\\'r\\' == \\'s\\' (\\'r\\' is lexicographically smaller than \\'s\\')\\n\\nTherefore, \\'r\\' will be a parent of \\'s\\'\\n   \\n   k                                            k\\n    \\\\                                          / \\\\\\n     r          --- path-compression --->     r   s\\n      \\\\\\n       s\\n\\n\\n7. Parents of characters from \\n\\np -> m\\na -> a\\nr -> k\\ns -> k\\ne -> e\\nr -> k\\n\\n8. baseStr = \"makkek\" (Answer)\\n```\\n\\n# Video Editorial\\n(Still confused? Refer this YT video created by me!)\\n[Video - Click Here](https://youtu.be/_hCh-rSPU7o)\\n\\n# Complexity\\n- Time complexity: $$ O(N) $$, where N is the size of the given strings.\\n\\n- Space complexity: $$ O(N) $$\\n\\n# Code\\n```\\nclass union_find {\\npublic:\\n    vector<char> parent;\\n\\n    union_find() {\\n        parent.resize(26);\\n\\n        for (int i=0; i<26; i++)\\n            parent[i] = char(i + \\'a\\');\\n    }\\n\\n    char find_parent(char c) {\\n        if (parent[c - \\'a\\'] == c)\\n            return c;\\n\\n        return parent[c - \\'a\\'] = find_parent(parent[c - \\'a\\']);\\n    }\\n\\n    void merge(char a, char b) {\\n        int parA = find_parent(a);\\n        int parB = find_parent(b);\\n\\n        if (parA < parB)\\n            parent[parB - \\'a\\'] = parA;\\n        else \\n            parent[parA - \\'a\\'] = parB;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        union_find uf;\\n        int n = s1.size();\\n\\n        for (int i=0; i<n; i++) \\n            uf.merge(s1[i], s2[i]);\\n\\n        for (int i=0; i<baseStr.size(); i++) \\n            baseStr[i] = uf.find_parent(baseStr[i]);\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Union Find"
                ],
                "code": "```\\ns1 = \"parker\"\\ns2 = \"morris\"\\nbaseStr = \"parser\"\\n\\n1. Index - 0\\ns1[0] = \\'p\\'\\ns2[0] = \\'m\\'\\n\\n\\'p\\' == \\'m\\' (\\'m\\' is lexicographically smaller than \\'p\\')\\n\\nTherefore, \\'m\\' will be a parent of \\'p\\'\\n   \\n   m\\n    \\\\ \\n     p\\n2. Index - 1\\ns1[1] = \\'a\\'\\ns2[1] = \\'o\\'\\n\\n\\'a\\' == \\'o\\' (\\'a\\' is lexicographically smaller than \\'o\\')\\n\\nTherefore, \\'a\\' will be a parent of \\'o\\'\\n   \\n   a\\n    \\\\ \\n     o\\n\\n3. Index - 2\\ns1[2] = \\'r\\'\\ns2[2] = \\'r\\'\\n\\n\\'r\\' == \\'r\\' (No effect)\\n\\n4. Index - 3\\ns1[3] = \\'k\\'\\ns2[3] = \\'r\\'\\n\\n\\'k\\' == \\'r\\' (\\'k\\' is lexicographically smaller than \\'r\\')\\n\\nTherefore, \\'k\\' will be a parent of \\'r\\'\\n   \\n   k\\n    \\\\ \\n     r\\n\\n5. Index - 4\\ns1[4] = \\'e\\'\\ns2[4] = \\'i\\'\\n\\n\\'e\\' == \\'i\\' (\\'e\\' is lexicographically smaller than \\'i\\')\\n\\nTherefore, \\'e\\' will be a parent of \\'i\\'\\n   \\n   e\\n    \\\\ \\n     i\\n\\n6. Index - 5\\ns1[5] = \\'r\\'\\ns2[5] = \\'s\\'\\n\\n\\'r\\' == \\'s\\' (\\'r\\' is lexicographically smaller than \\'s\\')\\n\\nTherefore, \\'r\\' will be a parent of \\'s\\'\\n   \\n   k                                            k\\n    \\\\                                          / \\\\\\n     r          --- path-compression --->     r   s\\n      \\\\\\n       s\\n\\n\\n7. Parents of characters from \\n\\np -> m\\na -> a\\nr -> k\\ns -> k\\ne -> e\\nr -> k\\n\\n8. baseStr = \"makkek\" (Answer)\\n```\n```\\nclass union_find {\\npublic:\\n    vector<char> parent;\\n\\n    union_find() {\\n        parent.resize(26);\\n\\n        for (int i=0; i<26; i++)\\n            parent[i] = char(i + \\'a\\');\\n    }\\n\\n    char find_parent(char c) {\\n        if (parent[c - \\'a\\'] == c)\\n            return c;\\n\\n        return parent[c - \\'a\\'] = find_parent(parent[c - \\'a\\']);\\n    }\\n\\n    void merge(char a, char b) {\\n        int parA = find_parent(a);\\n        int parB = find_parent(b);\\n\\n        if (parA < parB)\\n            parent[parB - \\'a\\'] = parA;\\n        else \\n            parent[parA - \\'a\\'] = parB;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        union_find uf;\\n        int n = s1.size();\\n\\n        for (int i=0; i<n; i++) \\n            uf.merge(s1[i], s2[i]);\\n\\n        for (int i=0; i<baseStr.size(); i++) \\n            baseStr[i] = uf.find_parent(baseStr[i]);\\n\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049865,
                "title": "python3-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe transitivity rule hints that Union Find can be used\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create union find mapping for the alphabet\\n2. Define the `findRoot()` method\\n3. Union the `s1` and `s2` chars one by one so that lexicographically largest goes under the lexicographically smallest\\n4. Map and join the `baseStr`\\'s chars according to their roots\\n\\n# Complexity\\n- Time complexity: $$O(a(N))$$, where $$a(N)$$ is the Ackermann function\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(alphabet)$$ or $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        uf = { c:c for c in map(chr, range(ord(\\'a\\'), ord(\\'z\\') + 1)) }\\n\\n        def findRoot(c):\\n            while uf[c] != c:\\n                uf[c] = uf[uf[c]]\\n                c = uf[c]\\n            return c\\n        \\n        for i in range(len(s1)):\\n            r1 = findRoot(s1[i])\\n            r2 = findRoot(s2[i])\\n            if r1 < r2:\\n                uf[r2] = r1\\n            else:\\n                uf[r1] = r2\\n        \\n        return \"\".join([ findRoot(c) for c in baseStr ])\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\\n        uf = { c:c for c in map(chr, range(ord(\\'a\\'), ord(\\'z\\') + 1)) }\\n\\n        def findRoot(c):\\n            while uf[c] != c:\\n                uf[c] = uf[uf[c]]\\n                c = uf[c]\\n            return c\\n        \\n        for i in range(len(s1)):\\n            r1 = findRoot(s1[i])\\n            r2 = findRoot(s2[i])\\n            if r1 < r2:\\n                uf[r2] = r1\\n            else:\\n                uf[r1] = r2\\n        \\n        return \"\".join([ findRoot(c) for c in baseStr ])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049801,
                "title": "java-100-faster-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int []parent;\\n    int []rank;\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        parent = new int[26];\\n        rank = new int[26];\\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n\\n        for(int i=0;i<s2.length();i++){\\n            \\n            int x = s1.charAt(i)-\\'a\\';\\n            int y = s2.charAt(i)-\\'a\\';\\n            \\n            int xl = find(x);\\n            int yl = find(y);\\n            if(xl != yl){\\n                union(xl,yl);\\n            }\\n        }\\n\\n        int []charArray = new int[26];\\n        for(int i=0;i<26;i++){\\n            charArray[i] = find(i);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<baseStr.length();i++){\\n            sb.append((char)(charArray[baseStr.charAt(i)-\\'a\\']+97));\\n        }\\n        return sb.toString();\\n    }\\n    private int find(int x){\\n        if(parent[x] == x){\\n            return x;\\n        }\\n        return parent[x] = find(parent[x]);\\n    }\\n    private void union(int x, int y){\\n        if(x < y){\\n            parent[y] = x;\\n        }\\n        else{\\n            parent[x] = y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int []parent;\\n    int []rank;\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        parent = new int[26];\\n        rank = new int[26];\\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n\\n        for(int i=0;i<s2.length();i++){\\n            \\n            int x = s1.charAt(i)-\\'a\\';\\n            int y = s2.charAt(i)-\\'a\\';\\n            \\n            int xl = find(x);\\n            int yl = find(y);\\n            if(xl != yl){\\n                union(xl,yl);\\n            }\\n        }\\n\\n        int []charArray = new int[26];\\n        for(int i=0;i<26;i++){\\n            charArray[i] = find(i);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<baseStr.length();i++){\\n            sb.append((char)(charArray[baseStr.charAt(i)-\\'a\\']+97));\\n        }\\n        return sb.toString();\\n    }\\n    private int find(int x){\\n        if(parent[x] == x){\\n            return x;\\n        }\\n        return parent[x] = find(parent[x]);\\n    }\\n    private void union(int x, int y){\\n        if(x < y){\\n            parent[y] = x;\\n        }\\n        else{\\n            parent[x] = y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049791,
                "title": "easy-stepwise-c-solution-using-disjoint-set-union-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDSU( Disjoint set union)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<char,char> parent;\\nvoid makeset(){\\n  for(char x=\\'a\\';x<=\\'z\\';x++){\\n      parent[x]=x;\\n  }\\n}\\nchar findParent(char u){\\n\\tif(parent[u]==u){\\n\\t\\treturn u;\\n\\t}\\n\\tparent[u]=findParent(parent[u]);\\n    return parent[u];\\n}\\nvoid unionNode(char u,char v){\\n\\tu=findParent(u);\\n\\tv=findParent(v);\\n\\tif(u<v){\\n\\t\\tparent[v]=u;\\n\\t}else if(v<u){\\n\\t\\tparent[u]=v;\\n\\t}\\n}\\n    string smallestEquivalentString(string s1, string s2, string b) {\\n    makeset();\\n    for(int i=0;i<s1.size();i++){\\n\\tunionNode(s1[i],s2[i]);\\n    }\\n    for(int i=0;i<b.size();i++){\\n\\tb[i]=findParent(b[i]);\\n    }\\n    return b;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char,char> parent;\\nvoid makeset(){\\n  for(char x=\\'a\\';x<=\\'z\\';x++){\\n      parent[x]=x;\\n  }\\n}\\nchar findParent(char u){\\n\\tif(parent[u]==u){\\n\\t\\treturn u;\\n\\t}\\n\\tparent[u]=findParent(parent[u]);\\n    return parent[u];\\n}\\nvoid unionNode(char u,char v){\\n\\tu=findParent(u);\\n\\tv=findParent(v);\\n\\tif(u<v){\\n\\t\\tparent[v]=u;\\n\\t}else if(v<u){\\n\\t\\tparent[u]=v;\\n\\t}\\n}\\n    string smallestEquivalentString(string s1, string s2, string b) {\\n    makeset();\\n    for(int i=0;i<s1.size();i++){\\n\\tunionNode(s1[i],s2[i]);\\n    }\\n    for(int i=0;i<b.size();i++){\\n\\tb[i]=findParent(b[i]);\\n    }\\n    return b;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049783,
                "title": "map-of-sorted-sets-in-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        Map<Character, TreeSet<Character>> groups = new HashMap<>();\\n\\n        for (int i = 0; i < s1.length(); ++i) {\\n            char c1 = s1.charAt(i);\\n            char c2 = s2.charAt(i);\\n\\n            if (groups.containsKey(c1) && groups.containsKey(c2)) {\\n                groups.get(c1).addAll(groups.get(c2));\\n                groups.get(c2).forEach(v -> groups.put(v, groups.get(c1)));\\n            } else if (groups.containsKey(c1)) {\\n                groups.get(c1).add(c2);\\n                groups.put(c2, groups.get(c1));\\n            } else if (groups.containsKey(c2)) {\\n                groups.get(c2).add(c1);\\n                groups.put(c1, groups.get(c2));\\n            } else {\\n                groups.computeIfAbsent(c1, k -> new TreeSet<Character>()).addAll(List.of(c1, c2));\\n                groups.put(c2, groups.get(c1));\\n            }\\n        }\\n\\n        var sb = new StringBuilder();\\n        for (int i = 0; i < baseStr.length(); ++i) {\\n            char c = baseStr.charAt(i);\\n            TreeSet<Character> group = groups.get(c);\\n            sb.append(group != null ? group.first() : c);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        Map<Character, TreeSet<Character>> groups = new HashMap<>();\\n\\n        for (int i = 0; i < s1.length(); ++i) {\\n            char c1 = s1.charAt(i);\\n            char c2 = s2.charAt(i);\\n\\n            if (groups.containsKey(c1) && groups.containsKey(c2)) {\\n                groups.get(c1).addAll(groups.get(c2));\\n                groups.get(c2).forEach(v -> groups.put(v, groups.get(c1)));\\n            } else if (groups.containsKey(c1)) {\\n                groups.get(c1).add(c2);\\n                groups.put(c2, groups.get(c1));\\n            } else if (groups.containsKey(c2)) {\\n                groups.get(c2).add(c1);\\n                groups.put(c1, groups.get(c2));\\n            } else {\\n                groups.computeIfAbsent(c1, k -> new TreeSet<Character>()).addAll(List.of(c1, c2));\\n                groups.put(c2, groups.get(c1));\\n            }\\n        }\\n\\n        var sb = new StringBuilder();\\n        for (int i = 0; i < baseStr.length(); ++i) {\\n            char c = baseStr.charAt(i);\\n            TreeSet<Character> group = groups.get(c);\\n            sb.append(group != null ? group.first() : c);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049745,
                "title": "union-find-c-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    char findParent(map<char,char> &parent,char ch){\\n        if(parent[ch]==ch)\\n        return ch;\\n\\n        return parent[ch]=findParent(parent,parent[ch]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char,char> parent;\\n        char a=\\'a\\';\\n        for(int i=1;i<=26;i++){\\n            parent[a]=a;\\n            a=a+1;\\n        }\\n\\n        for(int i=0;i<s1.size();i++){\\n            char p1=findParent(parent,s1[i]);\\n            char p2=findParent(parent,s2[i]);\\n            if(p1<p2){\\n                parent[p2]=p1;\\n            }\\n            else\\n            parent[p1]=p2;\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=findParent(parent,baseStr[i]);\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    char findParent(map<char,char> &parent,char ch){\\n        if(parent[ch]==ch)\\n        return ch;\\n\\n        return parent[ch]=findParent(parent,parent[ch]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char,char> parent;\\n        char a=\\'a\\';\\n        for(int i=1;i<=26;i++){\\n            parent[a]=a;\\n            a=a+1;\\n        }\\n\\n        for(int i=0;i<s1.size();i++){\\n            char p1=findParent(parent,s1[i]);\\n            char p2=findParent(parent,s2[i]);\\n            if(p1<p2){\\n                parent[p2]=p1;\\n            }\\n            else\\n            parent[p1]=p2;\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=findParent(parent,baseStr[i]);\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049696,
                "title": "c-easy-dfs-traversal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider this question as a normal dfs traversal question in which you have to return the minimum of the different connected Components.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Count the total different characters in the strings s1 & s2 using a map\\n2. Then construct the adjacency list of the same.\\n3. Simply call the DFS traversal on the non-visited components\\n4. Get the different Components from DFS\\n5. Calculate the minimum of all the elements of the component\\n6. Equating the elements of the component to above calculated minimum\\n7. Update the baseStr string after traversing the whole for loop\\n# PS:- This is my first Post :-)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(map<char,bool> &visited,map<char,list<char>> &adj,char node,vector<char> &component){\\n        component.push_back(node);\\n        visited[node]=true;\\n        for(auto i:adj[node]){\\n            if(!visited[i]){\\n                dfs(visited,adj,i,component);\\n            }\\n        }\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char,int> mp;\\n        for(int i=0; i<s1.length(); i++){\\n            mp[s1[i]]++;\\n        }\\n        for(int i=0; i<s2.length(); i++){\\n            mp[s2[i]]++;\\n        }\\n        //constructing the adjacency list\\n        map<char,list<char>> m;\\n        for(int i=0; i<s1.length(); i++){\\n            char u=s1[i];\\n            char v=s2[i];\\n            m[u].push_back(v);\\n            m[v].push_back(u);\\n        }\\n// Calling the DFS traversal\\n        map<char,bool> visited;\\n        map<char,char> ans;\\n        for(auto i:mp){\\n            if(!visited[i.first]){\\n                vector<char> component;\\n// getting the different Components from DFS\\n                dfs(visited,m,i.first,component);\\n                char mini=\\'z\\';\\n// Calculating the minimum of all the elements of the component\\n                for(int j=0; j<component.size(); j++){\\n                    mini=min(mini,component[j]);\\n                }\\n// Equating the elements of the component to above calculated minimum\\n                for(int j=0; j<component.size(); j++){\\n                    ans[component[j]]=mini;\\n                }\\n            }\\n        }\\n// Updating the baseStr string \\n        for(int i=0; i<baseStr.length(); i++){\\n// only change the baseStr[i] when we have this character in the ans(map)\\n            if(ans[baseStr[i]]!=0){\\n                baseStr[i]=ans[baseStr[i]];\\n            }\\n        }\\n        return baseStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(map<char,bool> &visited,map<char,list<char>> &adj,char node,vector<char> &component){\\n        component.push_back(node);\\n        visited[node]=true;\\n        for(auto i:adj[node]){\\n            if(!visited[i]){\\n                dfs(visited,adj,i,component);\\n            }\\n        }\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char,int> mp;\\n        for(int i=0; i<s1.length(); i++){\\n            mp[s1[i]]++;\\n        }\\n        for(int i=0; i<s2.length(); i++){\\n            mp[s2[i]]++;\\n        }\\n        //constructing the adjacency list\\n        map<char,list<char>> m;\\n        for(int i=0; i<s1.length(); i++){\\n            char u=s1[i];\\n            char v=s2[i];\\n            m[u].push_back(v);\\n            m[v].push_back(u);\\n        }\\n// Calling the DFS traversal\\n        map<char,bool> visited;\\n        map<char,char> ans;\\n        for(auto i:mp){\\n            if(!visited[i.first]){\\n                vector<char> component;\\n// getting the different Components from DFS\\n                dfs(visited,m,i.first,component);\\n                char mini=\\'z\\';\\n// Calculating the minimum of all the elements of the component\\n                for(int j=0; j<component.size(); j++){\\n                    mini=min(mini,component[j]);\\n                }\\n// Equating the elements of the component to above calculated minimum\\n                for(int j=0; j<component.size(); j++){\\n                    ans[component[j]]=mini;\\n                }\\n            }\\n        }\\n// Updating the baseStr string \\n        for(int i=0; i<baseStr.length(); i++){\\n// only change the baseStr[i] when we have this character in the ans(map)\\n            if(ans[baseStr[i]]!=0){\\n                baseStr[i]=ans[baseStr[i]];\\n            }\\n        }\\n        return baseStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049684,
                "title": "java-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        UnionFind uf = new UnionFind();\\n        for(int i = 0; i < s1.length(); i++){\\n            uf.union(s1.charAt(i) - \\'a\\', s2.charAt(i) - \\'a\\');\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : baseStr.toCharArray()){\\n            int res = uf.min(c - \\'a\\');\\n            char curr = (char)(res + \\'a\\');\\n            sb.append(curr);\\n        }\\n        return sb.toString();\\n    }\\n\\n    class UnionFind{\\n        int[] root;\\n        int[] rank;\\n        //int size;\\n        public UnionFind(){\\n            root = new int[26];\\n            rank = new int[26];\\n            for(int i = 0; i < 26; i++){\\n                rank[i] = 1;\\n                root[i] = i;\\n            }\\n        }\\n        public int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n        }\\n\\n        public int min(int x){\\n            int rootX = find(x);\\n            for(int i = 0; i < 26; i++){\\n                if(root[i] == rootX){\\n                    return i;\\n                }\\n            }\\n            return 0;\\n        }\\n        public void union(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if(rootX != rootY){\\n                if(rank[rootX] > rank[rootY]){\\n                    root[rootY] = rootX;\\n                }\\n                else if(rank[rootY] > rank[rootX]){\\n                    root[rootX] = rootY;\\n                }\\n                else{\\n                    root[rootY] = rootX;\\n                    rank[rootX]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        UnionFind uf = new UnionFind();\\n        for(int i = 0; i < s1.length(); i++){\\n            uf.union(s1.charAt(i) - \\'a\\', s2.charAt(i) - \\'a\\');\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : baseStr.toCharArray()){\\n            int res = uf.min(c - \\'a\\');\\n            char curr = (char)(res + \\'a\\');\\n            sb.append(curr);\\n        }\\n        return sb.toString();\\n    }\\n\\n    class UnionFind{\\n        int[] root;\\n        int[] rank;\\n        //int size;\\n        public UnionFind(){\\n            root = new int[26];\\n            rank = new int[26];\\n            for(int i = 0; i < 26; i++){\\n                rank[i] = 1;\\n                root[i] = i;\\n            }\\n        }\\n        public int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n        }\\n\\n        public int min(int x){\\n            int rootX = find(x);\\n            for(int i = 0; i < 26; i++){\\n                if(root[i] == rootX){\\n                    return i;\\n                }\\n            }\\n            return 0;\\n        }\\n        public void union(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if(rootX != rootY){\\n                if(rank[rootX] > rank[rootY]){\\n                    root[rootY] = rootX;\\n                }\\n                else if(rank[rootY] > rank[rootX]){\\n                    root[rootX] = rootY;\\n                }\\n                else{\\n                    root[rootY] = rootX;\\n                    rank[rootX]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1756838,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1757063,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1757000,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1757193,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756587,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756909,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756615,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756998,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756825,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756581,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756838,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1757063,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1757000,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1757193,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756587,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756909,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756615,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756998,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756825,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1756581,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "I come here in search of motivation, then the problem description takes it away"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "lol bro just fight fight fight keep fighting"
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "lmao"
                    },
                    {
                        "username": "Yiiipu",
                        "content": "At first glance I said: thank god no more graph today\\nSo young so naive"
                    },
                    {
                        "username": "cyadr56",
                        "content": "You can solve it without graphs. I solved it with sets (a list of references to set<char>, or more precisely, SortedSet<char> to have an easy access to Min() later). \\n\\nMight not be the fastest solution if there are many cases when you have to merge them, but come on, the biggest possible merge would be 13 + 13, that\\'s not gonna choke the processor (and the max amount of merges would be, if I\\'m not mistaken, 25)."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Haha my feeling exactly"
                    },
                    {
                        "username": "furiousluckIsHere",
                        "content": "Leetcode this week be like: Graph goes brrrrrr"
                    },
                    {
                        "username": "arghyadas",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Everytime I feel a little confident.\\nDaily Challenge: May I come in?"
                    },
                    {
                        "username": "uprightclear",
                        "content": "There\\'s something wrong, I cannot change language for this question."
                    },
                    {
                        "username": "Msey",
                        "content": "leetcode allows us to study extremally"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "weird bug, have to refresh whilst you are on the Discussion tab"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "[@uprightclear](/uprightclear) No, it doesn\\'t"
                    },
                    {
                        "username": "Cornelious",
                        "content": "It was working for me earlier.... now there\\'s nothing"
                    },
                    {
                        "username": "uprightclear",
                        "content": "[@some_dude_2020](/some_dude_2020) It works now."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "seems only this question has a problem - the author didn\\'t feel the need to include any programming language for submission :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Need to study graph😵"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@mk1352002](/mk1352002) Disjoint set is a topic of graph too. It keeps track of the components of a graph"
                    },
                    {
                        "username": "mayankK135",
                        "content": "[@faisalirfan2502](/faisalirfan2502) Try Disjoint set instead of graph to solve this problem"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "same bro leetcode loves graph"
                    },
                    {
                        "username": "leokwo",
                        "content": "Refresh this page while on Discussion to see programming language options again...lol"
                    },
                    {
                        "username": "Sowired73",
                        "content": "Yes, that temporarily works for me, too, and if you then go back to the problem list and click it again, or else click on the daily challenge calendar, it once again fails to show the language list, and if you put your mouse pointer over the \"Auto\" button to the right of where the list would be, I get the message, \"The language is not supported by our platform.\"\\n\\nHopefully, the fine people at LeetCode are already hard at work addressing the issue.  I\\'d submitted a support request for it, as mentioned [elsewhere](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3047467/daily-leetcoding-challenge-january-day-14/comments/1756664/) a while ago, just in case. "
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "oh, that works! thank you!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Finally, not a tree problem again \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@Panda_2397](/Panda_2397) yes a little graphish, but union-find doesn\\'t give proper essence of graph algorithms "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "but graph lol"
                    },
                    {
                        "username": "azat-reason",
                        "content": "Why do we need `baseStr`?"
                    },
                    {
                        "username": "azat-reason",
                        "content": "[@calm27](/calm27) `r = k`, according to `s1[3] = s2[3]`. `r = s` also, according to `s1[5] == s2[5]`. `r = k = s`."
                    },
                    {
                        "username": "calm27",
                        "content": "[@luihsuan](/luihsuan) \\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\\nOutput: \"makkek\"\\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\\n\\nHow is this group [k,r,s] formed? "
                    },
                    {
                        "username": "user4517",
                        "content": "[@luihsuan](/luihsuan) Thank you for the explanation. I was SO confused by the problem description."
                    },
                    {
                        "username": "luihsuan",
                        "content": "I was confused in the first place as well. \nWe need to use the equivalency relationships to find the lexicographically smaller order for the `baseStr`\n\nLet's say we are given `abc` and `xyz`\nwhich means `a == x; b == y; c == z`\n\nSo if the `baseStr` is given `xxz`, then we should return `aac` since `a` is smaller than its equivalent `x` in terms of the lexicographical order, and the same logic applies to `c` and `z`"
                    },
                    {
                        "username": "Cornelious",
                        "content": "Why is the daily a premium problem?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Finesse](/Finesse) Sadly, no once the contest is over or daily challenge refreshes, you loose the access to that problem, which seems fair, otherwise no one would buy subscriptions anymore."
                    },
                    {
                        "username": "Finesse",
                        "content": "[@jayesh_menghani](/jayesh_menghani), are they kept open forever for those who participated?"
                    },
                    {
                        "username": "jayesh_menghani",
                        "content": "[@Cornelious](/Cornelious) Premium weekly meant, just like daily you have a weekly challenge which non subscriber won\\'t get, it never meant that the problems were going be premium.\\nLeetcode has always kept premium problems open in contest/challenges for everyone."
                    },
                    {
                        "username": "yunusmo",
                        "content": "[@72engineers](/72engineers) They got me lol \\uD83D\\uDE2D"
                    },
                    {
                        "username": "1229093498",
                        "content": "I think they just free this problem. I couldn\\'t work on it but now I can after 1 hour."
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@72engineers](/72engineers) I thought that\\'s what the premium weeklys were for."
                    },
                    {
                        "username": "72engineers",
                        "content": "to make people subscribe"
                    }
                ]
            },
            {
                "id": 1757036,
                "content": [
                    {
                        "username": "vivekrajsundar",
                        "content": "Just learn how to implement \"UnionFind\" data structure and this question will become easy"
                    },
                    {
                        "username": "jay-dharamshi",
                        "content": "I solved this question by using a map and set data structure, the brute force solution, and was surprised to see the answer was accepted.\\n\\nLater I looked at the discussions tab and saw that this question can also be solved by using Union Find and that\\'s the most beautiful part about this question. This question is a beautiful way of thinking about data structures while solving problems. I never thought a concept used in graphs could also be applied to a string question."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "It is actually common in Computer Science to apply graph theory techniques to string problems.\\nI am very glad to see that you made that insight on your own!\\nGood luck using union find, it can help solve all sorts of problems."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "that\\'s how leetcode forces(helps) you to learning\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "Auto suggestion update?"
                    },
                    {
                        "username": "dongvt",
                        "content": "I have a bunch of friends with a great streak that will be completely lost because of this challenge. Why premium. They won't be able to get the monthly badges or anything. Is this a strategy to make them buy premium?"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I was worried about this at first as well.\nI actually wrote a whole blog post about why I stopped my XXX day-long LeetCode streak.\nRight before I was about to publish it, I checked LeetCode again and the saw that the problem was now free!\nOh well, I guess I'll save the draft of that blog post for later when I finally do end my streak 🤦"
                    },
                    {
                        "username": "dongvt",
                        "content": "[@KTBMedia](/KTBMedia) I already did."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "Before it\\'s too late, tell your friends not to worry - it\\'s free for everyone now."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@some_dude_2020](/some_dude_2020) \\nstreaks are motivation to practice, $35 is quite a lot for most people"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "I don\\'t see anything wrong with it - people spend effort and time to create these. \\n\\nThose who don\\'t pay can still try other questions - I don\\'t think you should consider the monthly streak as an entitlement that everyone should have. It doesn\\'t cost that much to subscribe and support the site."
                    },
                    {
                        "username": "swati_bothra",
                        "content": "```class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n=s1.length();\\n        UnionFind uf=new UnionFind();\\n        for(int i=0;i<n;i++)uf.union(s1.charAt(i),s2.charAt(i));\\n        StringBuilder ans=new StringBuilder();\\n        for(char c:baseStr.toCharArray()){\\n            ans.append(uf.find(c));\\n        }\\n        return ans.toString(); \\n    }\\n}\\nclass UnionFind{\\n    char[] arr;\\n    public UnionFind(){\\n        arr=new char[26];\\n        char c=\\'a\\';\\n        for(int i=0;i<26;i++){\\n            arr[i]=c++;\\n        }\\n    }\\n    void union(char a,char b){\\n        char c1=find(a);\\n        char c2=find(b);\\n        if(c1<c2){\\n            arr[c2-\\'a\\']=c1;\\n        }else{\\n            arr[c1-\\'a\\']=c2;\\n        }\\n    }\\n    char find(char c){\\n        if(arr[c-\\'a\\']==c)return c;\\n        arr[c-\\'a\\']=find(arr[c-\\'a\\']);\\n        return arr[c-\\'a\\'];\\n    }\\n    char[] get(){\\n        return arr;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "denkochev",
                        "content": "I start losing my vision trying to find out the bug in my program on test 113. \\uD83E\\uDEE3"
                    },
                    {
                        "username": "sun_a463",
                        "content": "By looking at the problem I have a good sense of how to work it but when it comes to coding it out my brain is hitting the breaks. I need to practice more mock interviews. "
                    },
                    {
                        "username": "Joald",
                        "content": "idk why people say this is a graph problem when it\\'s just disjoint set structure on arrays"
                    },
                    {
                        "username": "bej9038",
                        "content": "I\\'m glad I took graph theory last semester"
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union find."
                    }
                ]
            },
            {
                "id": 1757220,
                "content": [
                    {
                        "username": "vivekrajsundar",
                        "content": "Just learn how to implement \"UnionFind\" data structure and this question will become easy"
                    },
                    {
                        "username": "jay-dharamshi",
                        "content": "I solved this question by using a map and set data structure, the brute force solution, and was surprised to see the answer was accepted.\\n\\nLater I looked at the discussions tab and saw that this question can also be solved by using Union Find and that\\'s the most beautiful part about this question. This question is a beautiful way of thinking about data structures while solving problems. I never thought a concept used in graphs could also be applied to a string question."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "It is actually common in Computer Science to apply graph theory techniques to string problems.\\nI am very glad to see that you made that insight on your own!\\nGood luck using union find, it can help solve all sorts of problems."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "that\\'s how leetcode forces(helps) you to learning\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "Auto suggestion update?"
                    },
                    {
                        "username": "dongvt",
                        "content": "I have a bunch of friends with a great streak that will be completely lost because of this challenge. Why premium. They won't be able to get the monthly badges or anything. Is this a strategy to make them buy premium?"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I was worried about this at first as well.\nI actually wrote a whole blog post about why I stopped my XXX day-long LeetCode streak.\nRight before I was about to publish it, I checked LeetCode again and the saw that the problem was now free!\nOh well, I guess I'll save the draft of that blog post for later when I finally do end my streak 🤦"
                    },
                    {
                        "username": "dongvt",
                        "content": "[@KTBMedia](/KTBMedia) I already did."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "Before it\\'s too late, tell your friends not to worry - it\\'s free for everyone now."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@some_dude_2020](/some_dude_2020) \\nstreaks are motivation to practice, $35 is quite a lot for most people"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "I don\\'t see anything wrong with it - people spend effort and time to create these. \\n\\nThose who don\\'t pay can still try other questions - I don\\'t think you should consider the monthly streak as an entitlement that everyone should have. It doesn\\'t cost that much to subscribe and support the site."
                    },
                    {
                        "username": "swati_bothra",
                        "content": "```class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n=s1.length();\\n        UnionFind uf=new UnionFind();\\n        for(int i=0;i<n;i++)uf.union(s1.charAt(i),s2.charAt(i));\\n        StringBuilder ans=new StringBuilder();\\n        for(char c:baseStr.toCharArray()){\\n            ans.append(uf.find(c));\\n        }\\n        return ans.toString(); \\n    }\\n}\\nclass UnionFind{\\n    char[] arr;\\n    public UnionFind(){\\n        arr=new char[26];\\n        char c=\\'a\\';\\n        for(int i=0;i<26;i++){\\n            arr[i]=c++;\\n        }\\n    }\\n    void union(char a,char b){\\n        char c1=find(a);\\n        char c2=find(b);\\n        if(c1<c2){\\n            arr[c2-\\'a\\']=c1;\\n        }else{\\n            arr[c1-\\'a\\']=c2;\\n        }\\n    }\\n    char find(char c){\\n        if(arr[c-\\'a\\']==c)return c;\\n        arr[c-\\'a\\']=find(arr[c-\\'a\\']);\\n        return arr[c-\\'a\\'];\\n    }\\n    char[] get(){\\n        return arr;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "denkochev",
                        "content": "I start losing my vision trying to find out the bug in my program on test 113. \\uD83E\\uDEE3"
                    },
                    {
                        "username": "sun_a463",
                        "content": "By looking at the problem I have a good sense of how to work it but when it comes to coding it out my brain is hitting the breaks. I need to practice more mock interviews. "
                    },
                    {
                        "username": "Joald",
                        "content": "idk why people say this is a graph problem when it\\'s just disjoint set structure on arrays"
                    },
                    {
                        "username": "bej9038",
                        "content": "I\\'m glad I took graph theory last semester"
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union find."
                    }
                ]
            },
            {
                "id": 1756933,
                "content": [
                    {
                        "username": "vivekrajsundar",
                        "content": "Just learn how to implement \"UnionFind\" data structure and this question will become easy"
                    },
                    {
                        "username": "jay-dharamshi",
                        "content": "I solved this question by using a map and set data structure, the brute force solution, and was surprised to see the answer was accepted.\\n\\nLater I looked at the discussions tab and saw that this question can also be solved by using Union Find and that\\'s the most beautiful part about this question. This question is a beautiful way of thinking about data structures while solving problems. I never thought a concept used in graphs could also be applied to a string question."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "It is actually common in Computer Science to apply graph theory techniques to string problems.\\nI am very glad to see that you made that insight on your own!\\nGood luck using union find, it can help solve all sorts of problems."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "that\\'s how leetcode forces(helps) you to learning\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "Auto suggestion update?"
                    },
                    {
                        "username": "dongvt",
                        "content": "I have a bunch of friends with a great streak that will be completely lost because of this challenge. Why premium. They won't be able to get the monthly badges or anything. Is this a strategy to make them buy premium?"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I was worried about this at first as well.\nI actually wrote a whole blog post about why I stopped my XXX day-long LeetCode streak.\nRight before I was about to publish it, I checked LeetCode again and the saw that the problem was now free!\nOh well, I guess I'll save the draft of that blog post for later when I finally do end my streak 🤦"
                    },
                    {
                        "username": "dongvt",
                        "content": "[@KTBMedia](/KTBMedia) I already did."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "Before it\\'s too late, tell your friends not to worry - it\\'s free for everyone now."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@some_dude_2020](/some_dude_2020) \\nstreaks are motivation to practice, $35 is quite a lot for most people"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "I don\\'t see anything wrong with it - people spend effort and time to create these. \\n\\nThose who don\\'t pay can still try other questions - I don\\'t think you should consider the monthly streak as an entitlement that everyone should have. It doesn\\'t cost that much to subscribe and support the site."
                    },
                    {
                        "username": "swati_bothra",
                        "content": "```class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n=s1.length();\\n        UnionFind uf=new UnionFind();\\n        for(int i=0;i<n;i++)uf.union(s1.charAt(i),s2.charAt(i));\\n        StringBuilder ans=new StringBuilder();\\n        for(char c:baseStr.toCharArray()){\\n            ans.append(uf.find(c));\\n        }\\n        return ans.toString(); \\n    }\\n}\\nclass UnionFind{\\n    char[] arr;\\n    public UnionFind(){\\n        arr=new char[26];\\n        char c=\\'a\\';\\n        for(int i=0;i<26;i++){\\n            arr[i]=c++;\\n        }\\n    }\\n    void union(char a,char b){\\n        char c1=find(a);\\n        char c2=find(b);\\n        if(c1<c2){\\n            arr[c2-\\'a\\']=c1;\\n        }else{\\n            arr[c1-\\'a\\']=c2;\\n        }\\n    }\\n    char find(char c){\\n        if(arr[c-\\'a\\']==c)return c;\\n        arr[c-\\'a\\']=find(arr[c-\\'a\\']);\\n        return arr[c-\\'a\\'];\\n    }\\n    char[] get(){\\n        return arr;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "denkochev",
                        "content": "I start losing my vision trying to find out the bug in my program on test 113. \\uD83E\\uDEE3"
                    },
                    {
                        "username": "sun_a463",
                        "content": "By looking at the problem I have a good sense of how to work it but when it comes to coding it out my brain is hitting the breaks. I need to practice more mock interviews. "
                    },
                    {
                        "username": "Joald",
                        "content": "idk why people say this is a graph problem when it\\'s just disjoint set structure on arrays"
                    },
                    {
                        "username": "bej9038",
                        "content": "I\\'m glad I took graph theory last semester"
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union find."
                    }
                ]
            },
            {
                "id": 1756722,
                "content": [
                    {
                        "username": "vivekrajsundar",
                        "content": "Just learn how to implement \"UnionFind\" data structure and this question will become easy"
                    },
                    {
                        "username": "jay-dharamshi",
                        "content": "I solved this question by using a map and set data structure, the brute force solution, and was surprised to see the answer was accepted.\\n\\nLater I looked at the discussions tab and saw that this question can also be solved by using Union Find and that\\'s the most beautiful part about this question. This question is a beautiful way of thinking about data structures while solving problems. I never thought a concept used in graphs could also be applied to a string question."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "It is actually common in Computer Science to apply graph theory techniques to string problems.\\nI am very glad to see that you made that insight on your own!\\nGood luck using union find, it can help solve all sorts of problems."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "that\\'s how leetcode forces(helps) you to learning\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "Auto suggestion update?"
                    },
                    {
                        "username": "dongvt",
                        "content": "I have a bunch of friends with a great streak that will be completely lost because of this challenge. Why premium. They won't be able to get the monthly badges or anything. Is this a strategy to make them buy premium?"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I was worried about this at first as well.\nI actually wrote a whole blog post about why I stopped my XXX day-long LeetCode streak.\nRight before I was about to publish it, I checked LeetCode again and the saw that the problem was now free!\nOh well, I guess I'll save the draft of that blog post for later when I finally do end my streak 🤦"
                    },
                    {
                        "username": "dongvt",
                        "content": "[@KTBMedia](/KTBMedia) I already did."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "Before it\\'s too late, tell your friends not to worry - it\\'s free for everyone now."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@some_dude_2020](/some_dude_2020) \\nstreaks are motivation to practice, $35 is quite a lot for most people"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "I don\\'t see anything wrong with it - people spend effort and time to create these. \\n\\nThose who don\\'t pay can still try other questions - I don\\'t think you should consider the monthly streak as an entitlement that everyone should have. It doesn\\'t cost that much to subscribe and support the site."
                    },
                    {
                        "username": "swati_bothra",
                        "content": "```class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n=s1.length();\\n        UnionFind uf=new UnionFind();\\n        for(int i=0;i<n;i++)uf.union(s1.charAt(i),s2.charAt(i));\\n        StringBuilder ans=new StringBuilder();\\n        for(char c:baseStr.toCharArray()){\\n            ans.append(uf.find(c));\\n        }\\n        return ans.toString(); \\n    }\\n}\\nclass UnionFind{\\n    char[] arr;\\n    public UnionFind(){\\n        arr=new char[26];\\n        char c=\\'a\\';\\n        for(int i=0;i<26;i++){\\n            arr[i]=c++;\\n        }\\n    }\\n    void union(char a,char b){\\n        char c1=find(a);\\n        char c2=find(b);\\n        if(c1<c2){\\n            arr[c2-\\'a\\']=c1;\\n        }else{\\n            arr[c1-\\'a\\']=c2;\\n        }\\n    }\\n    char find(char c){\\n        if(arr[c-\\'a\\']==c)return c;\\n        arr[c-\\'a\\']=find(arr[c-\\'a\\']);\\n        return arr[c-\\'a\\'];\\n    }\\n    char[] get(){\\n        return arr;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "denkochev",
                        "content": "I start losing my vision trying to find out the bug in my program on test 113. \\uD83E\\uDEE3"
                    },
                    {
                        "username": "sun_a463",
                        "content": "By looking at the problem I have a good sense of how to work it but when it comes to coding it out my brain is hitting the breaks. I need to practice more mock interviews. "
                    },
                    {
                        "username": "Joald",
                        "content": "idk why people say this is a graph problem when it\\'s just disjoint set structure on arrays"
                    },
                    {
                        "username": "bej9038",
                        "content": "I\\'m glad I took graph theory last semester"
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union find."
                    }
                ]
            },
            {
                "id": 1759947,
                "content": [
                    {
                        "username": "vivekrajsundar",
                        "content": "Just learn how to implement \"UnionFind\" data structure and this question will become easy"
                    },
                    {
                        "username": "jay-dharamshi",
                        "content": "I solved this question by using a map and set data structure, the brute force solution, and was surprised to see the answer was accepted.\\n\\nLater I looked at the discussions tab and saw that this question can also be solved by using Union Find and that\\'s the most beautiful part about this question. This question is a beautiful way of thinking about data structures while solving problems. I never thought a concept used in graphs could also be applied to a string question."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "It is actually common in Computer Science to apply graph theory techniques to string problems.\\nI am very glad to see that you made that insight on your own!\\nGood luck using union find, it can help solve all sorts of problems."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "that\\'s how leetcode forces(helps) you to learning\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "Auto suggestion update?"
                    },
                    {
                        "username": "dongvt",
                        "content": "I have a bunch of friends with a great streak that will be completely lost because of this challenge. Why premium. They won't be able to get the monthly badges or anything. Is this a strategy to make them buy premium?"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I was worried about this at first as well.\nI actually wrote a whole blog post about why I stopped my XXX day-long LeetCode streak.\nRight before I was about to publish it, I checked LeetCode again and the saw that the problem was now free!\nOh well, I guess I'll save the draft of that blog post for later when I finally do end my streak 🤦"
                    },
                    {
                        "username": "dongvt",
                        "content": "[@KTBMedia](/KTBMedia) I already did."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "Before it\\'s too late, tell your friends not to worry - it\\'s free for everyone now."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@some_dude_2020](/some_dude_2020) \\nstreaks are motivation to practice, $35 is quite a lot for most people"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "I don\\'t see anything wrong with it - people spend effort and time to create these. \\n\\nThose who don\\'t pay can still try other questions - I don\\'t think you should consider the monthly streak as an entitlement that everyone should have. It doesn\\'t cost that much to subscribe and support the site."
                    },
                    {
                        "username": "swati_bothra",
                        "content": "```class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n=s1.length();\\n        UnionFind uf=new UnionFind();\\n        for(int i=0;i<n;i++)uf.union(s1.charAt(i),s2.charAt(i));\\n        StringBuilder ans=new StringBuilder();\\n        for(char c:baseStr.toCharArray()){\\n            ans.append(uf.find(c));\\n        }\\n        return ans.toString(); \\n    }\\n}\\nclass UnionFind{\\n    char[] arr;\\n    public UnionFind(){\\n        arr=new char[26];\\n        char c=\\'a\\';\\n        for(int i=0;i<26;i++){\\n            arr[i]=c++;\\n        }\\n    }\\n    void union(char a,char b){\\n        char c1=find(a);\\n        char c2=find(b);\\n        if(c1<c2){\\n            arr[c2-\\'a\\']=c1;\\n        }else{\\n            arr[c1-\\'a\\']=c2;\\n        }\\n    }\\n    char find(char c){\\n        if(arr[c-\\'a\\']==c)return c;\\n        arr[c-\\'a\\']=find(arr[c-\\'a\\']);\\n        return arr[c-\\'a\\'];\\n    }\\n    char[] get(){\\n        return arr;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "denkochev",
                        "content": "I start losing my vision trying to find out the bug in my program on test 113. \\uD83E\\uDEE3"
                    },
                    {
                        "username": "sun_a463",
                        "content": "By looking at the problem I have a good sense of how to work it but when it comes to coding it out my brain is hitting the breaks. I need to practice more mock interviews. "
                    },
                    {
                        "username": "Joald",
                        "content": "idk why people say this is a graph problem when it\\'s just disjoint set structure on arrays"
                    },
                    {
                        "username": "bej9038",
                        "content": "I\\'m glad I took graph theory last semester"
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union find."
                    }
                ]
            },
            {
                "id": 1758046,
                "content": [
                    {
                        "username": "vivekrajsundar",
                        "content": "Just learn how to implement \"UnionFind\" data structure and this question will become easy"
                    },
                    {
                        "username": "jay-dharamshi",
                        "content": "I solved this question by using a map and set data structure, the brute force solution, and was surprised to see the answer was accepted.\\n\\nLater I looked at the discussions tab and saw that this question can also be solved by using Union Find and that\\'s the most beautiful part about this question. This question is a beautiful way of thinking about data structures while solving problems. I never thought a concept used in graphs could also be applied to a string question."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "It is actually common in Computer Science to apply graph theory techniques to string problems.\\nI am very glad to see that you made that insight on your own!\\nGood luck using union find, it can help solve all sorts of problems."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "that\\'s how leetcode forces(helps) you to learning\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "Auto suggestion update?"
                    },
                    {
                        "username": "dongvt",
                        "content": "I have a bunch of friends with a great streak that will be completely lost because of this challenge. Why premium. They won't be able to get the monthly badges or anything. Is this a strategy to make them buy premium?"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I was worried about this at first as well.\nI actually wrote a whole blog post about why I stopped my XXX day-long LeetCode streak.\nRight before I was about to publish it, I checked LeetCode again and the saw that the problem was now free!\nOh well, I guess I'll save the draft of that blog post for later when I finally do end my streak 🤦"
                    },
                    {
                        "username": "dongvt",
                        "content": "[@KTBMedia](/KTBMedia) I already did."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "Before it\\'s too late, tell your friends not to worry - it\\'s free for everyone now."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@some_dude_2020](/some_dude_2020) \\nstreaks are motivation to practice, $35 is quite a lot for most people"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "I don\\'t see anything wrong with it - people spend effort and time to create these. \\n\\nThose who don\\'t pay can still try other questions - I don\\'t think you should consider the monthly streak as an entitlement that everyone should have. It doesn\\'t cost that much to subscribe and support the site."
                    },
                    {
                        "username": "swati_bothra",
                        "content": "```class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n=s1.length();\\n        UnionFind uf=new UnionFind();\\n        for(int i=0;i<n;i++)uf.union(s1.charAt(i),s2.charAt(i));\\n        StringBuilder ans=new StringBuilder();\\n        for(char c:baseStr.toCharArray()){\\n            ans.append(uf.find(c));\\n        }\\n        return ans.toString(); \\n    }\\n}\\nclass UnionFind{\\n    char[] arr;\\n    public UnionFind(){\\n        arr=new char[26];\\n        char c=\\'a\\';\\n        for(int i=0;i<26;i++){\\n            arr[i]=c++;\\n        }\\n    }\\n    void union(char a,char b){\\n        char c1=find(a);\\n        char c2=find(b);\\n        if(c1<c2){\\n            arr[c2-\\'a\\']=c1;\\n        }else{\\n            arr[c1-\\'a\\']=c2;\\n        }\\n    }\\n    char find(char c){\\n        if(arr[c-\\'a\\']==c)return c;\\n        arr[c-\\'a\\']=find(arr[c-\\'a\\']);\\n        return arr[c-\\'a\\'];\\n    }\\n    char[] get(){\\n        return arr;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "denkochev",
                        "content": "I start losing my vision trying to find out the bug in my program on test 113. \\uD83E\\uDEE3"
                    },
                    {
                        "username": "sun_a463",
                        "content": "By looking at the problem I have a good sense of how to work it but when it comes to coding it out my brain is hitting the breaks. I need to practice more mock interviews. "
                    },
                    {
                        "username": "Joald",
                        "content": "idk why people say this is a graph problem when it\\'s just disjoint set structure on arrays"
                    },
                    {
                        "username": "bej9038",
                        "content": "I\\'m glad I took graph theory last semester"
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union find."
                    }
                ]
            },
            {
                "id": 1758041,
                "content": [
                    {
                        "username": "vivekrajsundar",
                        "content": "Just learn how to implement \"UnionFind\" data structure and this question will become easy"
                    },
                    {
                        "username": "jay-dharamshi",
                        "content": "I solved this question by using a map and set data structure, the brute force solution, and was surprised to see the answer was accepted.\\n\\nLater I looked at the discussions tab and saw that this question can also be solved by using Union Find and that\\'s the most beautiful part about this question. This question is a beautiful way of thinking about data structures while solving problems. I never thought a concept used in graphs could also be applied to a string question."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "It is actually common in Computer Science to apply graph theory techniques to string problems.\\nI am very glad to see that you made that insight on your own!\\nGood luck using union find, it can help solve all sorts of problems."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "that\\'s how leetcode forces(helps) you to learning\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "Auto suggestion update?"
                    },
                    {
                        "username": "dongvt",
                        "content": "I have a bunch of friends with a great streak that will be completely lost because of this challenge. Why premium. They won't be able to get the monthly badges or anything. Is this a strategy to make them buy premium?"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I was worried about this at first as well.\nI actually wrote a whole blog post about why I stopped my XXX day-long LeetCode streak.\nRight before I was about to publish it, I checked LeetCode again and the saw that the problem was now free!\nOh well, I guess I'll save the draft of that blog post for later when I finally do end my streak 🤦"
                    },
                    {
                        "username": "dongvt",
                        "content": "[@KTBMedia](/KTBMedia) I already did."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "Before it\\'s too late, tell your friends not to worry - it\\'s free for everyone now."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@some_dude_2020](/some_dude_2020) \\nstreaks are motivation to practice, $35 is quite a lot for most people"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "I don\\'t see anything wrong with it - people spend effort and time to create these. \\n\\nThose who don\\'t pay can still try other questions - I don\\'t think you should consider the monthly streak as an entitlement that everyone should have. It doesn\\'t cost that much to subscribe and support the site."
                    },
                    {
                        "username": "swati_bothra",
                        "content": "```class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n=s1.length();\\n        UnionFind uf=new UnionFind();\\n        for(int i=0;i<n;i++)uf.union(s1.charAt(i),s2.charAt(i));\\n        StringBuilder ans=new StringBuilder();\\n        for(char c:baseStr.toCharArray()){\\n            ans.append(uf.find(c));\\n        }\\n        return ans.toString(); \\n    }\\n}\\nclass UnionFind{\\n    char[] arr;\\n    public UnionFind(){\\n        arr=new char[26];\\n        char c=\\'a\\';\\n        for(int i=0;i<26;i++){\\n            arr[i]=c++;\\n        }\\n    }\\n    void union(char a,char b){\\n        char c1=find(a);\\n        char c2=find(b);\\n        if(c1<c2){\\n            arr[c2-\\'a\\']=c1;\\n        }else{\\n            arr[c1-\\'a\\']=c2;\\n        }\\n    }\\n    char find(char c){\\n        if(arr[c-\\'a\\']==c)return c;\\n        arr[c-\\'a\\']=find(arr[c-\\'a\\']);\\n        return arr[c-\\'a\\'];\\n    }\\n    char[] get(){\\n        return arr;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "denkochev",
                        "content": "I start losing my vision trying to find out the bug in my program on test 113. \\uD83E\\uDEE3"
                    },
                    {
                        "username": "sun_a463",
                        "content": "By looking at the problem I have a good sense of how to work it but when it comes to coding it out my brain is hitting the breaks. I need to practice more mock interviews. "
                    },
                    {
                        "username": "Joald",
                        "content": "idk why people say this is a graph problem when it\\'s just disjoint set structure on arrays"
                    },
                    {
                        "username": "bej9038",
                        "content": "I\\'m glad I took graph theory last semester"
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union find."
                    }
                ]
            },
            {
                "id": 1757983,
                "content": [
                    {
                        "username": "vivekrajsundar",
                        "content": "Just learn how to implement \"UnionFind\" data structure and this question will become easy"
                    },
                    {
                        "username": "jay-dharamshi",
                        "content": "I solved this question by using a map and set data structure, the brute force solution, and was surprised to see the answer was accepted.\\n\\nLater I looked at the discussions tab and saw that this question can also be solved by using Union Find and that\\'s the most beautiful part about this question. This question is a beautiful way of thinking about data structures while solving problems. I never thought a concept used in graphs could also be applied to a string question."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "It is actually common in Computer Science to apply graph theory techniques to string problems.\\nI am very glad to see that you made that insight on your own!\\nGood luck using union find, it can help solve all sorts of problems."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "that\\'s how leetcode forces(helps) you to learning\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "Auto suggestion update?"
                    },
                    {
                        "username": "dongvt",
                        "content": "I have a bunch of friends with a great streak that will be completely lost because of this challenge. Why premium. They won't be able to get the monthly badges or anything. Is this a strategy to make them buy premium?"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I was worried about this at first as well.\nI actually wrote a whole blog post about why I stopped my XXX day-long LeetCode streak.\nRight before I was about to publish it, I checked LeetCode again and the saw that the problem was now free!\nOh well, I guess I'll save the draft of that blog post for later when I finally do end my streak 🤦"
                    },
                    {
                        "username": "dongvt",
                        "content": "[@KTBMedia](/KTBMedia) I already did."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "Before it\\'s too late, tell your friends not to worry - it\\'s free for everyone now."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@some_dude_2020](/some_dude_2020) \\nstreaks are motivation to practice, $35 is quite a lot for most people"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "I don\\'t see anything wrong with it - people spend effort and time to create these. \\n\\nThose who don\\'t pay can still try other questions - I don\\'t think you should consider the monthly streak as an entitlement that everyone should have. It doesn\\'t cost that much to subscribe and support the site."
                    },
                    {
                        "username": "swati_bothra",
                        "content": "```class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n=s1.length();\\n        UnionFind uf=new UnionFind();\\n        for(int i=0;i<n;i++)uf.union(s1.charAt(i),s2.charAt(i));\\n        StringBuilder ans=new StringBuilder();\\n        for(char c:baseStr.toCharArray()){\\n            ans.append(uf.find(c));\\n        }\\n        return ans.toString(); \\n    }\\n}\\nclass UnionFind{\\n    char[] arr;\\n    public UnionFind(){\\n        arr=new char[26];\\n        char c=\\'a\\';\\n        for(int i=0;i<26;i++){\\n            arr[i]=c++;\\n        }\\n    }\\n    void union(char a,char b){\\n        char c1=find(a);\\n        char c2=find(b);\\n        if(c1<c2){\\n            arr[c2-\\'a\\']=c1;\\n        }else{\\n            arr[c1-\\'a\\']=c2;\\n        }\\n    }\\n    char find(char c){\\n        if(arr[c-\\'a\\']==c)return c;\\n        arr[c-\\'a\\']=find(arr[c-\\'a\\']);\\n        return arr[c-\\'a\\'];\\n    }\\n    char[] get(){\\n        return arr;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "denkochev",
                        "content": "I start losing my vision trying to find out the bug in my program on test 113. \\uD83E\\uDEE3"
                    },
                    {
                        "username": "sun_a463",
                        "content": "By looking at the problem I have a good sense of how to work it but when it comes to coding it out my brain is hitting the breaks. I need to practice more mock interviews. "
                    },
                    {
                        "username": "Joald",
                        "content": "idk why people say this is a graph problem when it\\'s just disjoint set structure on arrays"
                    },
                    {
                        "username": "bej9038",
                        "content": "I\\'m glad I took graph theory last semester"
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union find."
                    }
                ]
            },
            {
                "id": 1757791,
                "content": [
                    {
                        "username": "vivekrajsundar",
                        "content": "Just learn how to implement \"UnionFind\" data structure and this question will become easy"
                    },
                    {
                        "username": "jay-dharamshi",
                        "content": "I solved this question by using a map and set data structure, the brute force solution, and was surprised to see the answer was accepted.\\n\\nLater I looked at the discussions tab and saw that this question can also be solved by using Union Find and that\\'s the most beautiful part about this question. This question is a beautiful way of thinking about data structures while solving problems. I never thought a concept used in graphs could also be applied to a string question."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "It is actually common in Computer Science to apply graph theory techniques to string problems.\\nI am very glad to see that you made that insight on your own!\\nGood luck using union find, it can help solve all sorts of problems."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "that\\'s how leetcode forces(helps) you to learning\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "Auto suggestion update?"
                    },
                    {
                        "username": "dongvt",
                        "content": "I have a bunch of friends with a great streak that will be completely lost because of this challenge. Why premium. They won't be able to get the monthly badges or anything. Is this a strategy to make them buy premium?"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I was worried about this at first as well.\nI actually wrote a whole blog post about why I stopped my XXX day-long LeetCode streak.\nRight before I was about to publish it, I checked LeetCode again and the saw that the problem was now free!\nOh well, I guess I'll save the draft of that blog post for later when I finally do end my streak 🤦"
                    },
                    {
                        "username": "dongvt",
                        "content": "[@KTBMedia](/KTBMedia) I already did."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "Before it\\'s too late, tell your friends not to worry - it\\'s free for everyone now."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@some_dude_2020](/some_dude_2020) \\nstreaks are motivation to practice, $35 is quite a lot for most people"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "I don\\'t see anything wrong with it - people spend effort and time to create these. \\n\\nThose who don\\'t pay can still try other questions - I don\\'t think you should consider the monthly streak as an entitlement that everyone should have. It doesn\\'t cost that much to subscribe and support the site."
                    },
                    {
                        "username": "swati_bothra",
                        "content": "```class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n=s1.length();\\n        UnionFind uf=new UnionFind();\\n        for(int i=0;i<n;i++)uf.union(s1.charAt(i),s2.charAt(i));\\n        StringBuilder ans=new StringBuilder();\\n        for(char c:baseStr.toCharArray()){\\n            ans.append(uf.find(c));\\n        }\\n        return ans.toString(); \\n    }\\n}\\nclass UnionFind{\\n    char[] arr;\\n    public UnionFind(){\\n        arr=new char[26];\\n        char c=\\'a\\';\\n        for(int i=0;i<26;i++){\\n            arr[i]=c++;\\n        }\\n    }\\n    void union(char a,char b){\\n        char c1=find(a);\\n        char c2=find(b);\\n        if(c1<c2){\\n            arr[c2-\\'a\\']=c1;\\n        }else{\\n            arr[c1-\\'a\\']=c2;\\n        }\\n    }\\n    char find(char c){\\n        if(arr[c-\\'a\\']==c)return c;\\n        arr[c-\\'a\\']=find(arr[c-\\'a\\']);\\n        return arr[c-\\'a\\'];\\n    }\\n    char[] get(){\\n        return arr;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "denkochev",
                        "content": "I start losing my vision trying to find out the bug in my program on test 113. \\uD83E\\uDEE3"
                    },
                    {
                        "username": "sun_a463",
                        "content": "By looking at the problem I have a good sense of how to work it but when it comes to coding it out my brain is hitting the breaks. I need to practice more mock interviews. "
                    },
                    {
                        "username": "Joald",
                        "content": "idk why people say this is a graph problem when it\\'s just disjoint set structure on arrays"
                    },
                    {
                        "username": "bej9038",
                        "content": "I\\'m glad I took graph theory last semester"
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union find."
                    }
                ]
            },
            {
                "id": 1757665,
                "content": [
                    {
                        "username": "vivekrajsundar",
                        "content": "Just learn how to implement \"UnionFind\" data structure and this question will become easy"
                    },
                    {
                        "username": "jay-dharamshi",
                        "content": "I solved this question by using a map and set data structure, the brute force solution, and was surprised to see the answer was accepted.\\n\\nLater I looked at the discussions tab and saw that this question can also be solved by using Union Find and that\\'s the most beautiful part about this question. This question is a beautiful way of thinking about data structures while solving problems. I never thought a concept used in graphs could also be applied to a string question."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "It is actually common in Computer Science to apply graph theory techniques to string problems.\\nI am very glad to see that you made that insight on your own!\\nGood luck using union find, it can help solve all sorts of problems."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "that\\'s how leetcode forces(helps) you to learning\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "Auto suggestion update?"
                    },
                    {
                        "username": "dongvt",
                        "content": "I have a bunch of friends with a great streak that will be completely lost because of this challenge. Why premium. They won't be able to get the monthly badges or anything. Is this a strategy to make them buy premium?"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I was worried about this at first as well.\nI actually wrote a whole blog post about why I stopped my XXX day-long LeetCode streak.\nRight before I was about to publish it, I checked LeetCode again and the saw that the problem was now free!\nOh well, I guess I'll save the draft of that blog post for later when I finally do end my streak 🤦"
                    },
                    {
                        "username": "dongvt",
                        "content": "[@KTBMedia](/KTBMedia) I already did."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "Before it\\'s too late, tell your friends not to worry - it\\'s free for everyone now."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@some_dude_2020](/some_dude_2020) \\nstreaks are motivation to practice, $35 is quite a lot for most people"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "I don\\'t see anything wrong with it - people spend effort and time to create these. \\n\\nThose who don\\'t pay can still try other questions - I don\\'t think you should consider the monthly streak as an entitlement that everyone should have. It doesn\\'t cost that much to subscribe and support the site."
                    },
                    {
                        "username": "swati_bothra",
                        "content": "```class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n=s1.length();\\n        UnionFind uf=new UnionFind();\\n        for(int i=0;i<n;i++)uf.union(s1.charAt(i),s2.charAt(i));\\n        StringBuilder ans=new StringBuilder();\\n        for(char c:baseStr.toCharArray()){\\n            ans.append(uf.find(c));\\n        }\\n        return ans.toString(); \\n    }\\n}\\nclass UnionFind{\\n    char[] arr;\\n    public UnionFind(){\\n        arr=new char[26];\\n        char c=\\'a\\';\\n        for(int i=0;i<26;i++){\\n            arr[i]=c++;\\n        }\\n    }\\n    void union(char a,char b){\\n        char c1=find(a);\\n        char c2=find(b);\\n        if(c1<c2){\\n            arr[c2-\\'a\\']=c1;\\n        }else{\\n            arr[c1-\\'a\\']=c2;\\n        }\\n    }\\n    char find(char c){\\n        if(arr[c-\\'a\\']==c)return c;\\n        arr[c-\\'a\\']=find(arr[c-\\'a\\']);\\n        return arr[c-\\'a\\'];\\n    }\\n    char[] get(){\\n        return arr;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "denkochev",
                        "content": "I start losing my vision trying to find out the bug in my program on test 113. \\uD83E\\uDEE3"
                    },
                    {
                        "username": "sun_a463",
                        "content": "By looking at the problem I have a good sense of how to work it but when it comes to coding it out my brain is hitting the breaks. I need to practice more mock interviews. "
                    },
                    {
                        "username": "Joald",
                        "content": "idk why people say this is a graph problem when it\\'s just disjoint set structure on arrays"
                    },
                    {
                        "username": "bej9038",
                        "content": "I\\'m glad I took graph theory last semester"
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union find."
                    }
                ]
            },
            {
                "id": 1757289,
                "content": [
                    {
                        "username": "Msey",
                        "content": "I though that it's wonderful I escaped a tree garden, but leetcode says \"hang on\""
                    },
                    {
                        "username": "quan_mai",
                        "content": "This problem sounds medium, but I would classify it hard as I get lost even after reading others solutions lol. If you have difficulty with the given solutions in Solutions Section, I found this one the most helpful with very detailed explanation\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2915992/python-very-detailed-union-find/"
                    },
                    {
                        "username": "suraj__k",
                        "content": "String lengths can be increased up to 1e5 and this should still qualify as medium problem."
                    },
                    {
                        "username": "solarshao1006",
                        "content": "is this a new problem? "
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "no, afaik the latest problem is 2532"
                    },
                    {
                        "username": "code__HARD",
                        "content": "A classical question to under DSU indepth."
                    },
                    {
                        "username": "District_12",
                        "content": "This one was really kinda hard. I solved it, but solution is slow."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This problem was a nightmare for me, but I finally solved it!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach Using Union Find Algorithm:-\\n\\nWe can start by initializing an array called \"graph\" of size 26, where each element initially points to itself. This array will represent the connected components of the equivalency relation, where each index represents a character in the alphabet and the value at each index represents the root of the connected component.\\n\\nNext, we can iterate through the characters of strings A and B and apply the union-find operation. Specifically, for each character pair (a, b), we need to find the roots of their respective connected components (i.e., the equivalent characters). We can use the find operation to do this, which recursively follows the parent pointers until it reaches the root of the connected component. If the roots of the two connected components are different, we can make one of them a child of the other. This step essentially merges the connected components and updates their roots in the \"graph\" array.\\n\\nFinally, we can iterate through the characters of the input string S and replace each character with its equivalent character found by the union-find algorithm. To do this, we can again use the find operation to find the root of the connected component for each character and replace it with the corresponding character in string B. The result is the smallest equivalent string for the given input string S."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/_VwY74IOR3w"
                    },
                    {
                        "username": "chaudharisuresh997",
                        "content": "how the third case where Sourcecode is not having any lexographic char u it is replaced with a"
                    }
                ]
            },
            {
                "id": 1756981,
                "content": [
                    {
                        "username": "Msey",
                        "content": "I though that it's wonderful I escaped a tree garden, but leetcode says \"hang on\""
                    },
                    {
                        "username": "quan_mai",
                        "content": "This problem sounds medium, but I would classify it hard as I get lost even after reading others solutions lol. If you have difficulty with the given solutions in Solutions Section, I found this one the most helpful with very detailed explanation\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2915992/python-very-detailed-union-find/"
                    },
                    {
                        "username": "suraj__k",
                        "content": "String lengths can be increased up to 1e5 and this should still qualify as medium problem."
                    },
                    {
                        "username": "solarshao1006",
                        "content": "is this a new problem? "
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "no, afaik the latest problem is 2532"
                    },
                    {
                        "username": "code__HARD",
                        "content": "A classical question to under DSU indepth."
                    },
                    {
                        "username": "District_12",
                        "content": "This one was really kinda hard. I solved it, but solution is slow."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This problem was a nightmare for me, but I finally solved it!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach Using Union Find Algorithm:-\\n\\nWe can start by initializing an array called \"graph\" of size 26, where each element initially points to itself. This array will represent the connected components of the equivalency relation, where each index represents a character in the alphabet and the value at each index represents the root of the connected component.\\n\\nNext, we can iterate through the characters of strings A and B and apply the union-find operation. Specifically, for each character pair (a, b), we need to find the roots of their respective connected components (i.e., the equivalent characters). We can use the find operation to do this, which recursively follows the parent pointers until it reaches the root of the connected component. If the roots of the two connected components are different, we can make one of them a child of the other. This step essentially merges the connected components and updates their roots in the \"graph\" array.\\n\\nFinally, we can iterate through the characters of the input string S and replace each character with its equivalent character found by the union-find algorithm. To do this, we can again use the find operation to find the root of the connected component for each character and replace it with the corresponding character in string B. The result is the smallest equivalent string for the given input string S."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/_VwY74IOR3w"
                    },
                    {
                        "username": "chaudharisuresh997",
                        "content": "how the third case where Sourcecode is not having any lexographic char u it is replaced with a"
                    }
                ]
            },
            {
                "id": 1756903,
                "content": [
                    {
                        "username": "Msey",
                        "content": "I though that it's wonderful I escaped a tree garden, but leetcode says \"hang on\""
                    },
                    {
                        "username": "quan_mai",
                        "content": "This problem sounds medium, but I would classify it hard as I get lost even after reading others solutions lol. If you have difficulty with the given solutions in Solutions Section, I found this one the most helpful with very detailed explanation\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2915992/python-very-detailed-union-find/"
                    },
                    {
                        "username": "suraj__k",
                        "content": "String lengths can be increased up to 1e5 and this should still qualify as medium problem."
                    },
                    {
                        "username": "solarshao1006",
                        "content": "is this a new problem? "
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "no, afaik the latest problem is 2532"
                    },
                    {
                        "username": "code__HARD",
                        "content": "A classical question to under DSU indepth."
                    },
                    {
                        "username": "District_12",
                        "content": "This one was really kinda hard. I solved it, but solution is slow."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This problem was a nightmare for me, but I finally solved it!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach Using Union Find Algorithm:-\\n\\nWe can start by initializing an array called \"graph\" of size 26, where each element initially points to itself. This array will represent the connected components of the equivalency relation, where each index represents a character in the alphabet and the value at each index represents the root of the connected component.\\n\\nNext, we can iterate through the characters of strings A and B and apply the union-find operation. Specifically, for each character pair (a, b), we need to find the roots of their respective connected components (i.e., the equivalent characters). We can use the find operation to do this, which recursively follows the parent pointers until it reaches the root of the connected component. If the roots of the two connected components are different, we can make one of them a child of the other. This step essentially merges the connected components and updates their roots in the \"graph\" array.\\n\\nFinally, we can iterate through the characters of the input string S and replace each character with its equivalent character found by the union-find algorithm. To do this, we can again use the find operation to find the root of the connected component for each character and replace it with the corresponding character in string B. The result is the smallest equivalent string for the given input string S."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/_VwY74IOR3w"
                    },
                    {
                        "username": "chaudharisuresh997",
                        "content": "how the third case where Sourcecode is not having any lexographic char u it is replaced with a"
                    }
                ]
            },
            {
                "id": 1756590,
                "content": [
                    {
                        "username": "Msey",
                        "content": "I though that it's wonderful I escaped a tree garden, but leetcode says \"hang on\""
                    },
                    {
                        "username": "quan_mai",
                        "content": "This problem sounds medium, but I would classify it hard as I get lost even after reading others solutions lol. If you have difficulty with the given solutions in Solutions Section, I found this one the most helpful with very detailed explanation\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2915992/python-very-detailed-union-find/"
                    },
                    {
                        "username": "suraj__k",
                        "content": "String lengths can be increased up to 1e5 and this should still qualify as medium problem."
                    },
                    {
                        "username": "solarshao1006",
                        "content": "is this a new problem? "
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "no, afaik the latest problem is 2532"
                    },
                    {
                        "username": "code__HARD",
                        "content": "A classical question to under DSU indepth."
                    },
                    {
                        "username": "District_12",
                        "content": "This one was really kinda hard. I solved it, but solution is slow."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This problem was a nightmare for me, but I finally solved it!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach Using Union Find Algorithm:-\\n\\nWe can start by initializing an array called \"graph\" of size 26, where each element initially points to itself. This array will represent the connected components of the equivalency relation, where each index represents a character in the alphabet and the value at each index represents the root of the connected component.\\n\\nNext, we can iterate through the characters of strings A and B and apply the union-find operation. Specifically, for each character pair (a, b), we need to find the roots of their respective connected components (i.e., the equivalent characters). We can use the find operation to do this, which recursively follows the parent pointers until it reaches the root of the connected component. If the roots of the two connected components are different, we can make one of them a child of the other. This step essentially merges the connected components and updates their roots in the \"graph\" array.\\n\\nFinally, we can iterate through the characters of the input string S and replace each character with its equivalent character found by the union-find algorithm. To do this, we can again use the find operation to find the root of the connected component for each character and replace it with the corresponding character in string B. The result is the smallest equivalent string for the given input string S."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/_VwY74IOR3w"
                    },
                    {
                        "username": "chaudharisuresh997",
                        "content": "how the third case where Sourcecode is not having any lexographic char u it is replaced with a"
                    }
                ]
            },
            {
                "id": 2072625,
                "content": [
                    {
                        "username": "Msey",
                        "content": "I though that it's wonderful I escaped a tree garden, but leetcode says \"hang on\""
                    },
                    {
                        "username": "quan_mai",
                        "content": "This problem sounds medium, but I would classify it hard as I get lost even after reading others solutions lol. If you have difficulty with the given solutions in Solutions Section, I found this one the most helpful with very detailed explanation\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2915992/python-very-detailed-union-find/"
                    },
                    {
                        "username": "suraj__k",
                        "content": "String lengths can be increased up to 1e5 and this should still qualify as medium problem."
                    },
                    {
                        "username": "solarshao1006",
                        "content": "is this a new problem? "
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "no, afaik the latest problem is 2532"
                    },
                    {
                        "username": "code__HARD",
                        "content": "A classical question to under DSU indepth."
                    },
                    {
                        "username": "District_12",
                        "content": "This one was really kinda hard. I solved it, but solution is slow."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This problem was a nightmare for me, but I finally solved it!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach Using Union Find Algorithm:-\\n\\nWe can start by initializing an array called \"graph\" of size 26, where each element initially points to itself. This array will represent the connected components of the equivalency relation, where each index represents a character in the alphabet and the value at each index represents the root of the connected component.\\n\\nNext, we can iterate through the characters of strings A and B and apply the union-find operation. Specifically, for each character pair (a, b), we need to find the roots of their respective connected components (i.e., the equivalent characters). We can use the find operation to do this, which recursively follows the parent pointers until it reaches the root of the connected component. If the roots of the two connected components are different, we can make one of them a child of the other. This step essentially merges the connected components and updates their roots in the \"graph\" array.\\n\\nFinally, we can iterate through the characters of the input string S and replace each character with its equivalent character found by the union-find algorithm. To do this, we can again use the find operation to find the root of the connected component for each character and replace it with the corresponding character in string B. The result is the smallest equivalent string for the given input string S."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/_VwY74IOR3w"
                    },
                    {
                        "username": "chaudharisuresh997",
                        "content": "how the third case where Sourcecode is not having any lexographic char u it is replaced with a"
                    }
                ]
            },
            {
                "id": 2037210,
                "content": [
                    {
                        "username": "Msey",
                        "content": "I though that it's wonderful I escaped a tree garden, but leetcode says \"hang on\""
                    },
                    {
                        "username": "quan_mai",
                        "content": "This problem sounds medium, but I would classify it hard as I get lost even after reading others solutions lol. If you have difficulty with the given solutions in Solutions Section, I found this one the most helpful with very detailed explanation\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2915992/python-very-detailed-union-find/"
                    },
                    {
                        "username": "suraj__k",
                        "content": "String lengths can be increased up to 1e5 and this should still qualify as medium problem."
                    },
                    {
                        "username": "solarshao1006",
                        "content": "is this a new problem? "
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "no, afaik the latest problem is 2532"
                    },
                    {
                        "username": "code__HARD",
                        "content": "A classical question to under DSU indepth."
                    },
                    {
                        "username": "District_12",
                        "content": "This one was really kinda hard. I solved it, but solution is slow."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This problem was a nightmare for me, but I finally solved it!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach Using Union Find Algorithm:-\\n\\nWe can start by initializing an array called \"graph\" of size 26, where each element initially points to itself. This array will represent the connected components of the equivalency relation, where each index represents a character in the alphabet and the value at each index represents the root of the connected component.\\n\\nNext, we can iterate through the characters of strings A and B and apply the union-find operation. Specifically, for each character pair (a, b), we need to find the roots of their respective connected components (i.e., the equivalent characters). We can use the find operation to do this, which recursively follows the parent pointers until it reaches the root of the connected component. If the roots of the two connected components are different, we can make one of them a child of the other. This step essentially merges the connected components and updates their roots in the \"graph\" array.\\n\\nFinally, we can iterate through the characters of the input string S and replace each character with its equivalent character found by the union-find algorithm. To do this, we can again use the find operation to find the root of the connected component for each character and replace it with the corresponding character in string B. The result is the smallest equivalent string for the given input string S."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/_VwY74IOR3w"
                    },
                    {
                        "username": "chaudharisuresh997",
                        "content": "how the third case where Sourcecode is not having any lexographic char u it is replaced with a"
                    }
                ]
            },
            {
                "id": 1989585,
                "content": [
                    {
                        "username": "Msey",
                        "content": "I though that it's wonderful I escaped a tree garden, but leetcode says \"hang on\""
                    },
                    {
                        "username": "quan_mai",
                        "content": "This problem sounds medium, but I would classify it hard as I get lost even after reading others solutions lol. If you have difficulty with the given solutions in Solutions Section, I found this one the most helpful with very detailed explanation\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2915992/python-very-detailed-union-find/"
                    },
                    {
                        "username": "suraj__k",
                        "content": "String lengths can be increased up to 1e5 and this should still qualify as medium problem."
                    },
                    {
                        "username": "solarshao1006",
                        "content": "is this a new problem? "
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "no, afaik the latest problem is 2532"
                    },
                    {
                        "username": "code__HARD",
                        "content": "A classical question to under DSU indepth."
                    },
                    {
                        "username": "District_12",
                        "content": "This one was really kinda hard. I solved it, but solution is slow."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This problem was a nightmare for me, but I finally solved it!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach Using Union Find Algorithm:-\\n\\nWe can start by initializing an array called \"graph\" of size 26, where each element initially points to itself. This array will represent the connected components of the equivalency relation, where each index represents a character in the alphabet and the value at each index represents the root of the connected component.\\n\\nNext, we can iterate through the characters of strings A and B and apply the union-find operation. Specifically, for each character pair (a, b), we need to find the roots of their respective connected components (i.e., the equivalent characters). We can use the find operation to do this, which recursively follows the parent pointers until it reaches the root of the connected component. If the roots of the two connected components are different, we can make one of them a child of the other. This step essentially merges the connected components and updates their roots in the \"graph\" array.\\n\\nFinally, we can iterate through the characters of the input string S and replace each character with its equivalent character found by the union-find algorithm. To do this, we can again use the find operation to find the root of the connected component for each character and replace it with the corresponding character in string B. The result is the smallest equivalent string for the given input string S."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/_VwY74IOR3w"
                    },
                    {
                        "username": "chaudharisuresh997",
                        "content": "how the third case where Sourcecode is not having any lexographic char u it is replaced with a"
                    }
                ]
            },
            {
                "id": 1821046,
                "content": [
                    {
                        "username": "Msey",
                        "content": "I though that it's wonderful I escaped a tree garden, but leetcode says \"hang on\""
                    },
                    {
                        "username": "quan_mai",
                        "content": "This problem sounds medium, but I would classify it hard as I get lost even after reading others solutions lol. If you have difficulty with the given solutions in Solutions Section, I found this one the most helpful with very detailed explanation\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2915992/python-very-detailed-union-find/"
                    },
                    {
                        "username": "suraj__k",
                        "content": "String lengths can be increased up to 1e5 and this should still qualify as medium problem."
                    },
                    {
                        "username": "solarshao1006",
                        "content": "is this a new problem? "
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "no, afaik the latest problem is 2532"
                    },
                    {
                        "username": "code__HARD",
                        "content": "A classical question to under DSU indepth."
                    },
                    {
                        "username": "District_12",
                        "content": "This one was really kinda hard. I solved it, but solution is slow."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This problem was a nightmare for me, but I finally solved it!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach Using Union Find Algorithm:-\\n\\nWe can start by initializing an array called \"graph\" of size 26, where each element initially points to itself. This array will represent the connected components of the equivalency relation, where each index represents a character in the alphabet and the value at each index represents the root of the connected component.\\n\\nNext, we can iterate through the characters of strings A and B and apply the union-find operation. Specifically, for each character pair (a, b), we need to find the roots of their respective connected components (i.e., the equivalent characters). We can use the find operation to do this, which recursively follows the parent pointers until it reaches the root of the connected component. If the roots of the two connected components are different, we can make one of them a child of the other. This step essentially merges the connected components and updates their roots in the \"graph\" array.\\n\\nFinally, we can iterate through the characters of the input string S and replace each character with its equivalent character found by the union-find algorithm. To do this, we can again use the find operation to find the root of the connected component for each character and replace it with the corresponding character in string B. The result is the smallest equivalent string for the given input string S."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/_VwY74IOR3w"
                    },
                    {
                        "username": "chaudharisuresh997",
                        "content": "how the third case where Sourcecode is not having any lexographic char u it is replaced with a"
                    }
                ]
            },
            {
                "id": 1766910,
                "content": [
                    {
                        "username": "Msey",
                        "content": "I though that it's wonderful I escaped a tree garden, but leetcode says \"hang on\""
                    },
                    {
                        "username": "quan_mai",
                        "content": "This problem sounds medium, but I would classify it hard as I get lost even after reading others solutions lol. If you have difficulty with the given solutions in Solutions Section, I found this one the most helpful with very detailed explanation\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2915992/python-very-detailed-union-find/"
                    },
                    {
                        "username": "suraj__k",
                        "content": "String lengths can be increased up to 1e5 and this should still qualify as medium problem."
                    },
                    {
                        "username": "solarshao1006",
                        "content": "is this a new problem? "
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "no, afaik the latest problem is 2532"
                    },
                    {
                        "username": "code__HARD",
                        "content": "A classical question to under DSU indepth."
                    },
                    {
                        "username": "District_12",
                        "content": "This one was really kinda hard. I solved it, but solution is slow."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This problem was a nightmare for me, but I finally solved it!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach Using Union Find Algorithm:-\\n\\nWe can start by initializing an array called \"graph\" of size 26, where each element initially points to itself. This array will represent the connected components of the equivalency relation, where each index represents a character in the alphabet and the value at each index represents the root of the connected component.\\n\\nNext, we can iterate through the characters of strings A and B and apply the union-find operation. Specifically, for each character pair (a, b), we need to find the roots of their respective connected components (i.e., the equivalent characters). We can use the find operation to do this, which recursively follows the parent pointers until it reaches the root of the connected component. If the roots of the two connected components are different, we can make one of them a child of the other. This step essentially merges the connected components and updates their roots in the \"graph\" array.\\n\\nFinally, we can iterate through the characters of the input string S and replace each character with its equivalent character found by the union-find algorithm. To do this, we can again use the find operation to find the root of the connected component for each character and replace it with the corresponding character in string B. The result is the smallest equivalent string for the given input string S."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/_VwY74IOR3w"
                    },
                    {
                        "username": "chaudharisuresh997",
                        "content": "how the third case where Sourcecode is not having any lexographic char u it is replaced with a"
                    }
                ]
            },
            {
                "id": 1763614,
                "content": [
                    {
                        "username": "Msey",
                        "content": "I though that it's wonderful I escaped a tree garden, but leetcode says \"hang on\""
                    },
                    {
                        "username": "quan_mai",
                        "content": "This problem sounds medium, but I would classify it hard as I get lost even after reading others solutions lol. If you have difficulty with the given solutions in Solutions Section, I found this one the most helpful with very detailed explanation\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2915992/python-very-detailed-union-find/"
                    },
                    {
                        "username": "suraj__k",
                        "content": "String lengths can be increased up to 1e5 and this should still qualify as medium problem."
                    },
                    {
                        "username": "solarshao1006",
                        "content": "is this a new problem? "
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "no, afaik the latest problem is 2532"
                    },
                    {
                        "username": "code__HARD",
                        "content": "A classical question to under DSU indepth."
                    },
                    {
                        "username": "District_12",
                        "content": "This one was really kinda hard. I solved it, but solution is slow."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This problem was a nightmare for me, but I finally solved it!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach Using Union Find Algorithm:-\\n\\nWe can start by initializing an array called \"graph\" of size 26, where each element initially points to itself. This array will represent the connected components of the equivalency relation, where each index represents a character in the alphabet and the value at each index represents the root of the connected component.\\n\\nNext, we can iterate through the characters of strings A and B and apply the union-find operation. Specifically, for each character pair (a, b), we need to find the roots of their respective connected components (i.e., the equivalent characters). We can use the find operation to do this, which recursively follows the parent pointers until it reaches the root of the connected component. If the roots of the two connected components are different, we can make one of them a child of the other. This step essentially merges the connected components and updates their roots in the \"graph\" array.\\n\\nFinally, we can iterate through the characters of the input string S and replace each character with its equivalent character found by the union-find algorithm. To do this, we can again use the find operation to find the root of the connected component for each character and replace it with the corresponding character in string B. The result is the smallest equivalent string for the given input string S."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/_VwY74IOR3w"
                    },
                    {
                        "username": "chaudharisuresh997",
                        "content": "how the third case where Sourcecode is not having any lexographic char u it is replaced with a"
                    }
                ]
            },
            {
                "id": 1758091,
                "content": [
                    {
                        "username": "arizala13",
                        "content": "Happy weekend my leetcode friends"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "https://www.youtube.com/watch?v=rO6gPEmhGRQ Watch this and you'll be able to solve the problem"
                    },
                    {
                        "username": "noob-pika",
                        "content": "Lol, I found a better way to make use of graph without storing the character code. By initializing an empty map and not storing character code but the character itself as the value. I also did not stored the useless characters."
                    },
                    {
                        "username": "Yongbi",
                        "content": "In fact if you use a _for loop_ at the end, then it\\'s okay for your approach. But if you use join(map), then we need to define 26 lower case alphabets. "
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Anybody can paraphrase task more easy? And explain phrase:\\n> given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr."
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This is an excellent problem to learn the union-find algorithm, if you are not already familiar with it."
                    },
                    {
                        "username": "_191500199",
                        "content": "jan start with easy array now it comes to medium graph . \\nWhat comes next?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Leetcode be like: A day without Graph is wasted:)"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I realised it was a graph problem as soon as I read this:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\n\\nJust have to figure out what data structure to use. Once you do that, its an easy problem"
                    },
                    {
                        "username": "divb_",
                        "content": "Now that you mention it, it makes sense. These 3 represents edges and also connected vertices (components) right?\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Very neat union find problem :)\\nFor a while I was getting the wrong answer and couldn\\'t understand why - then I realized that I was returning the lexigraphically smallest equivalent string to s1 and s2, not to baseStr!"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "This is an intutive Graph Based Solution .\\nclass Solution {\\npublic:\\n\\n    char returnValue=\\'{\\';\\n    int vis[26]={0};\\n    void dfs(char node ,  map<char , set<char , greater<char>>> &G){\\n\\n        vis[node-\\'a\\']=true;\\n        returnValue=min(returnValue , node);\\n        for(auto child : G[node]){\\n            if(!vis[child-\\'a\\'])\\n            dfs(child , G);\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char , set<char , greater<char>>> G;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            char min_=min(s1[i] , s2[i]);\\n            char max_=max(s1[i] , s2[i]);\\n            G[max_].insert(min_);\\n            G[min_].insert(max_);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            dfs(baseStr[i] , G);\\n            cout<<returnValue<<endl;\\n            baseStr[i]=returnValue;\\n            returnValue=\\'{\\';\\n            memset(vis , 0 , sizeof(vis));\\n        }\\n        return baseStr;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1758079,
                "content": [
                    {
                        "username": "arizala13",
                        "content": "Happy weekend my leetcode friends"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "https://www.youtube.com/watch?v=rO6gPEmhGRQ Watch this and you'll be able to solve the problem"
                    },
                    {
                        "username": "noob-pika",
                        "content": "Lol, I found a better way to make use of graph without storing the character code. By initializing an empty map and not storing character code but the character itself as the value. I also did not stored the useless characters."
                    },
                    {
                        "username": "Yongbi",
                        "content": "In fact if you use a _for loop_ at the end, then it\\'s okay for your approach. But if you use join(map), then we need to define 26 lower case alphabets. "
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Anybody can paraphrase task more easy? And explain phrase:\\n> given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr."
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This is an excellent problem to learn the union-find algorithm, if you are not already familiar with it."
                    },
                    {
                        "username": "_191500199",
                        "content": "jan start with easy array now it comes to medium graph . \\nWhat comes next?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Leetcode be like: A day without Graph is wasted:)"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I realised it was a graph problem as soon as I read this:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\n\\nJust have to figure out what data structure to use. Once you do that, its an easy problem"
                    },
                    {
                        "username": "divb_",
                        "content": "Now that you mention it, it makes sense. These 3 represents edges and also connected vertices (components) right?\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Very neat union find problem :)\\nFor a while I was getting the wrong answer and couldn\\'t understand why - then I realized that I was returning the lexigraphically smallest equivalent string to s1 and s2, not to baseStr!"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "This is an intutive Graph Based Solution .\\nclass Solution {\\npublic:\\n\\n    char returnValue=\\'{\\';\\n    int vis[26]={0};\\n    void dfs(char node ,  map<char , set<char , greater<char>>> &G){\\n\\n        vis[node-\\'a\\']=true;\\n        returnValue=min(returnValue , node);\\n        for(auto child : G[node]){\\n            if(!vis[child-\\'a\\'])\\n            dfs(child , G);\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char , set<char , greater<char>>> G;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            char min_=min(s1[i] , s2[i]);\\n            char max_=max(s1[i] , s2[i]);\\n            G[max_].insert(min_);\\n            G[min_].insert(max_);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            dfs(baseStr[i] , G);\\n            cout<<returnValue<<endl;\\n            baseStr[i]=returnValue;\\n            returnValue=\\'{\\';\\n            memset(vis , 0 , sizeof(vis));\\n        }\\n        return baseStr;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757999,
                "content": [
                    {
                        "username": "arizala13",
                        "content": "Happy weekend my leetcode friends"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "https://www.youtube.com/watch?v=rO6gPEmhGRQ Watch this and you'll be able to solve the problem"
                    },
                    {
                        "username": "noob-pika",
                        "content": "Lol, I found a better way to make use of graph without storing the character code. By initializing an empty map and not storing character code but the character itself as the value. I also did not stored the useless characters."
                    },
                    {
                        "username": "Yongbi",
                        "content": "In fact if you use a _for loop_ at the end, then it\\'s okay for your approach. But if you use join(map), then we need to define 26 lower case alphabets. "
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Anybody can paraphrase task more easy? And explain phrase:\\n> given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr."
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This is an excellent problem to learn the union-find algorithm, if you are not already familiar with it."
                    },
                    {
                        "username": "_191500199",
                        "content": "jan start with easy array now it comes to medium graph . \\nWhat comes next?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Leetcode be like: A day without Graph is wasted:)"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I realised it was a graph problem as soon as I read this:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\n\\nJust have to figure out what data structure to use. Once you do that, its an easy problem"
                    },
                    {
                        "username": "divb_",
                        "content": "Now that you mention it, it makes sense. These 3 represents edges and also connected vertices (components) right?\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Very neat union find problem :)\\nFor a while I was getting the wrong answer and couldn\\'t understand why - then I realized that I was returning the lexigraphically smallest equivalent string to s1 and s2, not to baseStr!"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "This is an intutive Graph Based Solution .\\nclass Solution {\\npublic:\\n\\n    char returnValue=\\'{\\';\\n    int vis[26]={0};\\n    void dfs(char node ,  map<char , set<char , greater<char>>> &G){\\n\\n        vis[node-\\'a\\']=true;\\n        returnValue=min(returnValue , node);\\n        for(auto child : G[node]){\\n            if(!vis[child-\\'a\\'])\\n            dfs(child , G);\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char , set<char , greater<char>>> G;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            char min_=min(s1[i] , s2[i]);\\n            char max_=max(s1[i] , s2[i]);\\n            G[max_].insert(min_);\\n            G[min_].insert(max_);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            dfs(baseStr[i] , G);\\n            cout<<returnValue<<endl;\\n            baseStr[i]=returnValue;\\n            returnValue=\\'{\\';\\n            memset(vis , 0 , sizeof(vis));\\n        }\\n        return baseStr;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757965,
                "content": [
                    {
                        "username": "arizala13",
                        "content": "Happy weekend my leetcode friends"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "https://www.youtube.com/watch?v=rO6gPEmhGRQ Watch this and you'll be able to solve the problem"
                    },
                    {
                        "username": "noob-pika",
                        "content": "Lol, I found a better way to make use of graph without storing the character code. By initializing an empty map and not storing character code but the character itself as the value. I also did not stored the useless characters."
                    },
                    {
                        "username": "Yongbi",
                        "content": "In fact if you use a _for loop_ at the end, then it\\'s okay for your approach. But if you use join(map), then we need to define 26 lower case alphabets. "
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Anybody can paraphrase task more easy? And explain phrase:\\n> given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr."
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This is an excellent problem to learn the union-find algorithm, if you are not already familiar with it."
                    },
                    {
                        "username": "_191500199",
                        "content": "jan start with easy array now it comes to medium graph . \\nWhat comes next?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Leetcode be like: A day without Graph is wasted:)"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I realised it was a graph problem as soon as I read this:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\n\\nJust have to figure out what data structure to use. Once you do that, its an easy problem"
                    },
                    {
                        "username": "divb_",
                        "content": "Now that you mention it, it makes sense. These 3 represents edges and also connected vertices (components) right?\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Very neat union find problem :)\\nFor a while I was getting the wrong answer and couldn\\'t understand why - then I realized that I was returning the lexigraphically smallest equivalent string to s1 and s2, not to baseStr!"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "This is an intutive Graph Based Solution .\\nclass Solution {\\npublic:\\n\\n    char returnValue=\\'{\\';\\n    int vis[26]={0};\\n    void dfs(char node ,  map<char , set<char , greater<char>>> &G){\\n\\n        vis[node-\\'a\\']=true;\\n        returnValue=min(returnValue , node);\\n        for(auto child : G[node]){\\n            if(!vis[child-\\'a\\'])\\n            dfs(child , G);\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char , set<char , greater<char>>> G;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            char min_=min(s1[i] , s2[i]);\\n            char max_=max(s1[i] , s2[i]);\\n            G[max_].insert(min_);\\n            G[min_].insert(max_);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            dfs(baseStr[i] , G);\\n            cout<<returnValue<<endl;\\n            baseStr[i]=returnValue;\\n            returnValue=\\'{\\';\\n            memset(vis , 0 , sizeof(vis));\\n        }\\n        return baseStr;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757959,
                "content": [
                    {
                        "username": "arizala13",
                        "content": "Happy weekend my leetcode friends"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "https://www.youtube.com/watch?v=rO6gPEmhGRQ Watch this and you'll be able to solve the problem"
                    },
                    {
                        "username": "noob-pika",
                        "content": "Lol, I found a better way to make use of graph without storing the character code. By initializing an empty map and not storing character code but the character itself as the value. I also did not stored the useless characters."
                    },
                    {
                        "username": "Yongbi",
                        "content": "In fact if you use a _for loop_ at the end, then it\\'s okay for your approach. But if you use join(map), then we need to define 26 lower case alphabets. "
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Anybody can paraphrase task more easy? And explain phrase:\\n> given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr."
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This is an excellent problem to learn the union-find algorithm, if you are not already familiar with it."
                    },
                    {
                        "username": "_191500199",
                        "content": "jan start with easy array now it comes to medium graph . \\nWhat comes next?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Leetcode be like: A day without Graph is wasted:)"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I realised it was a graph problem as soon as I read this:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\n\\nJust have to figure out what data structure to use. Once you do that, its an easy problem"
                    },
                    {
                        "username": "divb_",
                        "content": "Now that you mention it, it makes sense. These 3 represents edges and also connected vertices (components) right?\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Very neat union find problem :)\\nFor a while I was getting the wrong answer and couldn\\'t understand why - then I realized that I was returning the lexigraphically smallest equivalent string to s1 and s2, not to baseStr!"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "This is an intutive Graph Based Solution .\\nclass Solution {\\npublic:\\n\\n    char returnValue=\\'{\\';\\n    int vis[26]={0};\\n    void dfs(char node ,  map<char , set<char , greater<char>>> &G){\\n\\n        vis[node-\\'a\\']=true;\\n        returnValue=min(returnValue , node);\\n        for(auto child : G[node]){\\n            if(!vis[child-\\'a\\'])\\n            dfs(child , G);\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char , set<char , greater<char>>> G;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            char min_=min(s1[i] , s2[i]);\\n            char max_=max(s1[i] , s2[i]);\\n            G[max_].insert(min_);\\n            G[min_].insert(max_);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            dfs(baseStr[i] , G);\\n            cout<<returnValue<<endl;\\n            baseStr[i]=returnValue;\\n            returnValue=\\'{\\';\\n            memset(vis , 0 , sizeof(vis));\\n        }\\n        return baseStr;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757879,
                "content": [
                    {
                        "username": "arizala13",
                        "content": "Happy weekend my leetcode friends"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "https://www.youtube.com/watch?v=rO6gPEmhGRQ Watch this and you'll be able to solve the problem"
                    },
                    {
                        "username": "noob-pika",
                        "content": "Lol, I found a better way to make use of graph without storing the character code. By initializing an empty map and not storing character code but the character itself as the value. I also did not stored the useless characters."
                    },
                    {
                        "username": "Yongbi",
                        "content": "In fact if you use a _for loop_ at the end, then it\\'s okay for your approach. But if you use join(map), then we need to define 26 lower case alphabets. "
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Anybody can paraphrase task more easy? And explain phrase:\\n> given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr."
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This is an excellent problem to learn the union-find algorithm, if you are not already familiar with it."
                    },
                    {
                        "username": "_191500199",
                        "content": "jan start with easy array now it comes to medium graph . \\nWhat comes next?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Leetcode be like: A day without Graph is wasted:)"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I realised it was a graph problem as soon as I read this:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\n\\nJust have to figure out what data structure to use. Once you do that, its an easy problem"
                    },
                    {
                        "username": "divb_",
                        "content": "Now that you mention it, it makes sense. These 3 represents edges and also connected vertices (components) right?\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Very neat union find problem :)\\nFor a while I was getting the wrong answer and couldn\\'t understand why - then I realized that I was returning the lexigraphically smallest equivalent string to s1 and s2, not to baseStr!"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "This is an intutive Graph Based Solution .\\nclass Solution {\\npublic:\\n\\n    char returnValue=\\'{\\';\\n    int vis[26]={0};\\n    void dfs(char node ,  map<char , set<char , greater<char>>> &G){\\n\\n        vis[node-\\'a\\']=true;\\n        returnValue=min(returnValue , node);\\n        for(auto child : G[node]){\\n            if(!vis[child-\\'a\\'])\\n            dfs(child , G);\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char , set<char , greater<char>>> G;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            char min_=min(s1[i] , s2[i]);\\n            char max_=max(s1[i] , s2[i]);\\n            G[max_].insert(min_);\\n            G[min_].insert(max_);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            dfs(baseStr[i] , G);\\n            cout<<returnValue<<endl;\\n            baseStr[i]=returnValue;\\n            returnValue=\\'{\\';\\n            memset(vis , 0 , sizeof(vis));\\n        }\\n        return baseStr;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757856,
                "content": [
                    {
                        "username": "arizala13",
                        "content": "Happy weekend my leetcode friends"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "https://www.youtube.com/watch?v=rO6gPEmhGRQ Watch this and you'll be able to solve the problem"
                    },
                    {
                        "username": "noob-pika",
                        "content": "Lol, I found a better way to make use of graph without storing the character code. By initializing an empty map and not storing character code but the character itself as the value. I also did not stored the useless characters."
                    },
                    {
                        "username": "Yongbi",
                        "content": "In fact if you use a _for loop_ at the end, then it\\'s okay for your approach. But if you use join(map), then we need to define 26 lower case alphabets. "
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Anybody can paraphrase task more easy? And explain phrase:\\n> given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr."
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This is an excellent problem to learn the union-find algorithm, if you are not already familiar with it."
                    },
                    {
                        "username": "_191500199",
                        "content": "jan start with easy array now it comes to medium graph . \\nWhat comes next?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Leetcode be like: A day without Graph is wasted:)"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I realised it was a graph problem as soon as I read this:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\n\\nJust have to figure out what data structure to use. Once you do that, its an easy problem"
                    },
                    {
                        "username": "divb_",
                        "content": "Now that you mention it, it makes sense. These 3 represents edges and also connected vertices (components) right?\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Very neat union find problem :)\\nFor a while I was getting the wrong answer and couldn\\'t understand why - then I realized that I was returning the lexigraphically smallest equivalent string to s1 and s2, not to baseStr!"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "This is an intutive Graph Based Solution .\\nclass Solution {\\npublic:\\n\\n    char returnValue=\\'{\\';\\n    int vis[26]={0};\\n    void dfs(char node ,  map<char , set<char , greater<char>>> &G){\\n\\n        vis[node-\\'a\\']=true;\\n        returnValue=min(returnValue , node);\\n        for(auto child : G[node]){\\n            if(!vis[child-\\'a\\'])\\n            dfs(child , G);\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char , set<char , greater<char>>> G;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            char min_=min(s1[i] , s2[i]);\\n            char max_=max(s1[i] , s2[i]);\\n            G[max_].insert(min_);\\n            G[min_].insert(max_);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            dfs(baseStr[i] , G);\\n            cout<<returnValue<<endl;\\n            baseStr[i]=returnValue;\\n            returnValue=\\'{\\';\\n            memset(vis , 0 , sizeof(vis));\\n        }\\n        return baseStr;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757730,
                "content": [
                    {
                        "username": "arizala13",
                        "content": "Happy weekend my leetcode friends"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "https://www.youtube.com/watch?v=rO6gPEmhGRQ Watch this and you'll be able to solve the problem"
                    },
                    {
                        "username": "noob-pika",
                        "content": "Lol, I found a better way to make use of graph without storing the character code. By initializing an empty map and not storing character code but the character itself as the value. I also did not stored the useless characters."
                    },
                    {
                        "username": "Yongbi",
                        "content": "In fact if you use a _for loop_ at the end, then it\\'s okay for your approach. But if you use join(map), then we need to define 26 lower case alphabets. "
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Anybody can paraphrase task more easy? And explain phrase:\\n> given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr."
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This is an excellent problem to learn the union-find algorithm, if you are not already familiar with it."
                    },
                    {
                        "username": "_191500199",
                        "content": "jan start with easy array now it comes to medium graph . \\nWhat comes next?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Leetcode be like: A day without Graph is wasted:)"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I realised it was a graph problem as soon as I read this:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\n\\nJust have to figure out what data structure to use. Once you do that, its an easy problem"
                    },
                    {
                        "username": "divb_",
                        "content": "Now that you mention it, it makes sense. These 3 represents edges and also connected vertices (components) right?\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Very neat union find problem :)\\nFor a while I was getting the wrong answer and couldn\\'t understand why - then I realized that I was returning the lexigraphically smallest equivalent string to s1 and s2, not to baseStr!"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "This is an intutive Graph Based Solution .\\nclass Solution {\\npublic:\\n\\n    char returnValue=\\'{\\';\\n    int vis[26]={0};\\n    void dfs(char node ,  map<char , set<char , greater<char>>> &G){\\n\\n        vis[node-\\'a\\']=true;\\n        returnValue=min(returnValue , node);\\n        for(auto child : G[node]){\\n            if(!vis[child-\\'a\\'])\\n            dfs(child , G);\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char , set<char , greater<char>>> G;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            char min_=min(s1[i] , s2[i]);\\n            char max_=max(s1[i] , s2[i]);\\n            G[max_].insert(min_);\\n            G[min_].insert(max_);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            dfs(baseStr[i] , G);\\n            cout<<returnValue<<endl;\\n            baseStr[i]=returnValue;\\n            returnValue=\\'{\\';\\n            memset(vis , 0 , sizeof(vis));\\n        }\\n        return baseStr;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757716,
                "content": [
                    {
                        "username": "arizala13",
                        "content": "Happy weekend my leetcode friends"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "https://www.youtube.com/watch?v=rO6gPEmhGRQ Watch this and you'll be able to solve the problem"
                    },
                    {
                        "username": "noob-pika",
                        "content": "Lol, I found a better way to make use of graph without storing the character code. By initializing an empty map and not storing character code but the character itself as the value. I also did not stored the useless characters."
                    },
                    {
                        "username": "Yongbi",
                        "content": "In fact if you use a _for loop_ at the end, then it\\'s okay for your approach. But if you use join(map), then we need to define 26 lower case alphabets. "
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Anybody can paraphrase task more easy? And explain phrase:\\n> given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr."
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This is an excellent problem to learn the union-find algorithm, if you are not already familiar with it."
                    },
                    {
                        "username": "_191500199",
                        "content": "jan start with easy array now it comes to medium graph . \\nWhat comes next?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Leetcode be like: A day without Graph is wasted:)"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I realised it was a graph problem as soon as I read this:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\n\\nJust have to figure out what data structure to use. Once you do that, its an easy problem"
                    },
                    {
                        "username": "divb_",
                        "content": "Now that you mention it, it makes sense. These 3 represents edges and also connected vertices (components) right?\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Very neat union find problem :)\\nFor a while I was getting the wrong answer and couldn\\'t understand why - then I realized that I was returning the lexigraphically smallest equivalent string to s1 and s2, not to baseStr!"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "This is an intutive Graph Based Solution .\\nclass Solution {\\npublic:\\n\\n    char returnValue=\\'{\\';\\n    int vis[26]={0};\\n    void dfs(char node ,  map<char , set<char , greater<char>>> &G){\\n\\n        vis[node-\\'a\\']=true;\\n        returnValue=min(returnValue , node);\\n        for(auto child : G[node]){\\n            if(!vis[child-\\'a\\'])\\n            dfs(child , G);\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char , set<char , greater<char>>> G;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            char min_=min(s1[i] , s2[i]);\\n            char max_=max(s1[i] , s2[i]);\\n            G[max_].insert(min_);\\n            G[min_].insert(max_);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            dfs(baseStr[i] , G);\\n            cout<<returnValue<<endl;\\n            baseStr[i]=returnValue;\\n            returnValue=\\'{\\';\\n            memset(vis , 0 , sizeof(vis));\\n        }\\n        return baseStr;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757699,
                "content": [
                    {
                        "username": "arizala13",
                        "content": "Happy weekend my leetcode friends"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "https://www.youtube.com/watch?v=rO6gPEmhGRQ Watch this and you'll be able to solve the problem"
                    },
                    {
                        "username": "noob-pika",
                        "content": "Lol, I found a better way to make use of graph without storing the character code. By initializing an empty map and not storing character code but the character itself as the value. I also did not stored the useless characters."
                    },
                    {
                        "username": "Yongbi",
                        "content": "In fact if you use a _for loop_ at the end, then it\\'s okay for your approach. But if you use join(map), then we need to define 26 lower case alphabets. "
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Anybody can paraphrase task more easy? And explain phrase:\\n> given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr."
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This is an excellent problem to learn the union-find algorithm, if you are not already familiar with it."
                    },
                    {
                        "username": "_191500199",
                        "content": "jan start with easy array now it comes to medium graph . \\nWhat comes next?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Leetcode be like: A day without Graph is wasted:)"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I realised it was a graph problem as soon as I read this:\\n\\nReflexivity: \\'a\\' == \\'a\\'.\\nSymmetry: \\'a\\' == \\'b\\' implies \\'b\\' == \\'a\\'.\\nTransitivity: \\'a\\' == \\'b\\' and \\'b\\' == \\'c\\' implies \\'a\\' == \\'c\\'.\\n\\nJust have to figure out what data structure to use. Once you do that, its an easy problem"
                    },
                    {
                        "username": "divb_",
                        "content": "Now that you mention it, it makes sense. These 3 represents edges and also connected vertices (components) right?\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Very neat union find problem :)\\nFor a while I was getting the wrong answer and couldn\\'t understand why - then I realized that I was returning the lexigraphically smallest equivalent string to s1 and s2, not to baseStr!"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "This is an intutive Graph Based Solution .\\nclass Solution {\\npublic:\\n\\n    char returnValue=\\'{\\';\\n    int vis[26]={0};\\n    void dfs(char node ,  map<char , set<char , greater<char>>> &G){\\n\\n        vis[node-\\'a\\']=true;\\n        returnValue=min(returnValue , node);\\n        for(auto child : G[node]){\\n            if(!vis[child-\\'a\\'])\\n            dfs(child , G);\\n        }\\n    }\\n\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        map<char , set<char , greater<char>>> G;\\n        int n=s1.length();\\n        for(int i=0;i<n;i++){\\n            char min_=min(s1[i] , s2[i]);\\n            char max_=max(s1[i] , s2[i]);\\n            G[max_].insert(min_);\\n            G[min_].insert(max_);\\n        }\\n        for(int i=0;i<baseStr.length();i++){\\n            dfs(baseStr[i] , G);\\n            cout<<returnValue<<endl;\\n            baseStr[i]=returnValue;\\n            returnValue=\\'{\\';\\n            memset(vis , 0 , sizeof(vis));\\n        }\\n        return baseStr;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757681,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem shook me up"
                    },
                    {
                        "username": "sepac",
                        "content": "I made a graph and used a DFS and beat 5.11%. Not sure why it\\'s so slow but I\\'m going to try Union Find."
                    },
                    {
                        "username": "sk03167",
                        "content": "if you run dfs for each character, won\\'t the worst time complexity be size(baseStr)*depth(tree) where the worst case depth could be 25 (a->b, b->c, ...... so on) and each character in baseStr is a. Do let me know if their is something wrong in my understanding. "
                    },
                    {
                        "username": "ajesk",
                        "content": "Not terrible. Had to remember how to union again, then it just worked."
                    },
                    {
                        "username": "OO7_O",
                        "content": "everyone is coder,untill this premium level comes in...\\n\\n~le this question : \"kyu hila dala naa\" "
                    },
                    {
                        "username": "monikabishnoi29",
                        "content": "guys mujhe problem samjh aa jati hai but approach guess nhi kar pati sometimes or jb approach mil jati hai to code nhi likh pati \\uD83D\\uDE25kabhi ke baar ye sb step kar lu to solution easa hota hai mera ki tle maar deta hai\\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14 han m yahi bolna chah rahi hu ki solve nhi kar pa rahi problems"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@colorfulpencil](/colorfulpencil) Yes! [@monikabishnoi29](/monikabishnoi29) Also, be very clear with your basics. If you think you're not, then watch a playlist in YT and solve problems related to it. If you're talking specifically about graphs then I'd recommend Striver's new playlist on it. Its good"
                    },
                    {
                        "username": "colorfulpencil",
                        "content": "practice practice practice! \\nif you are not able to think of approach then look in discussion tab, if you are not able to think of code then look at others solutions and then try to code it yourself. Do it for few weeks and you will start getting intuition to code on your own. don\\'t be hard on yourself. "
                    },
                    {
                        "username": "altafshaikhmd6",
                        "content": "Every Other Question is difficult to understand brrrr."
                    },
                    {
                        "username": "kal425",
                        "content": "Hint : use disjoint set union"
                    },
                    {
                        "username": "0icy",
                        "content": "Whats the problem not passing last case\n\n\n``````\nclass Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        res = [x for x in range(26)]\n\n        def parent(n): @\n            if res[n] == n:\n                return n\n            return parent(res[n])\n\n        for i in range(len(s1)):\n            c = max(ord(s1[i]),ord(s2[i]))-97\n            p = min(ord(s1[i]),ord(s2[i]))-97\n  \n            l = parent(c)\n            print(l,c,p)\n            if l < p:\n                res[p] = l\n            else:\n                res[c] = p\n                res[l] = p\n\n\n\n        a = ''\n        for e in baseStr:\n            a += chr(parent(ord(e)-97)+97)\n        return a\n`"
                    },
                    {
                        "username": "ezksdo",
                        "content": "It\\'s the most confusing problem I\\'ve ever seen."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "In Simple language,\\nEvery character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order."
                    }
                ]
            },
            {
                "id": 1757675,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem shook me up"
                    },
                    {
                        "username": "sepac",
                        "content": "I made a graph and used a DFS and beat 5.11%. Not sure why it\\'s so slow but I\\'m going to try Union Find."
                    },
                    {
                        "username": "sk03167",
                        "content": "if you run dfs for each character, won\\'t the worst time complexity be size(baseStr)*depth(tree) where the worst case depth could be 25 (a->b, b->c, ...... so on) and each character in baseStr is a. Do let me know if their is something wrong in my understanding. "
                    },
                    {
                        "username": "ajesk",
                        "content": "Not terrible. Had to remember how to union again, then it just worked."
                    },
                    {
                        "username": "OO7_O",
                        "content": "everyone is coder,untill this premium level comes in...\\n\\n~le this question : \"kyu hila dala naa\" "
                    },
                    {
                        "username": "monikabishnoi29",
                        "content": "guys mujhe problem samjh aa jati hai but approach guess nhi kar pati sometimes or jb approach mil jati hai to code nhi likh pati \\uD83D\\uDE25kabhi ke baar ye sb step kar lu to solution easa hota hai mera ki tle maar deta hai\\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14 han m yahi bolna chah rahi hu ki solve nhi kar pa rahi problems"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@colorfulpencil](/colorfulpencil) Yes! [@monikabishnoi29](/monikabishnoi29) Also, be very clear with your basics. If you think you're not, then watch a playlist in YT and solve problems related to it. If you're talking specifically about graphs then I'd recommend Striver's new playlist on it. Its good"
                    },
                    {
                        "username": "colorfulpencil",
                        "content": "practice practice practice! \\nif you are not able to think of approach then look in discussion tab, if you are not able to think of code then look at others solutions and then try to code it yourself. Do it for few weeks and you will start getting intuition to code on your own. don\\'t be hard on yourself. "
                    },
                    {
                        "username": "altafshaikhmd6",
                        "content": "Every Other Question is difficult to understand brrrr."
                    },
                    {
                        "username": "kal425",
                        "content": "Hint : use disjoint set union"
                    },
                    {
                        "username": "0icy",
                        "content": "Whats the problem not passing last case\n\n\n``````\nclass Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        res = [x for x in range(26)]\n\n        def parent(n): @\n            if res[n] == n:\n                return n\n            return parent(res[n])\n\n        for i in range(len(s1)):\n            c = max(ord(s1[i]),ord(s2[i]))-97\n            p = min(ord(s1[i]),ord(s2[i]))-97\n  \n            l = parent(c)\n            print(l,c,p)\n            if l < p:\n                res[p] = l\n            else:\n                res[c] = p\n                res[l] = p\n\n\n\n        a = ''\n        for e in baseStr:\n            a += chr(parent(ord(e)-97)+97)\n        return a\n`"
                    },
                    {
                        "username": "ezksdo",
                        "content": "It\\'s the most confusing problem I\\'ve ever seen."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "In Simple language,\\nEvery character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order."
                    }
                ]
            },
            {
                "id": 1757651,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem shook me up"
                    },
                    {
                        "username": "sepac",
                        "content": "I made a graph and used a DFS and beat 5.11%. Not sure why it\\'s so slow but I\\'m going to try Union Find."
                    },
                    {
                        "username": "sk03167",
                        "content": "if you run dfs for each character, won\\'t the worst time complexity be size(baseStr)*depth(tree) where the worst case depth could be 25 (a->b, b->c, ...... so on) and each character in baseStr is a. Do let me know if their is something wrong in my understanding. "
                    },
                    {
                        "username": "ajesk",
                        "content": "Not terrible. Had to remember how to union again, then it just worked."
                    },
                    {
                        "username": "OO7_O",
                        "content": "everyone is coder,untill this premium level comes in...\\n\\n~le this question : \"kyu hila dala naa\" "
                    },
                    {
                        "username": "monikabishnoi29",
                        "content": "guys mujhe problem samjh aa jati hai but approach guess nhi kar pati sometimes or jb approach mil jati hai to code nhi likh pati \\uD83D\\uDE25kabhi ke baar ye sb step kar lu to solution easa hota hai mera ki tle maar deta hai\\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14 han m yahi bolna chah rahi hu ki solve nhi kar pa rahi problems"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@colorfulpencil](/colorfulpencil) Yes! [@monikabishnoi29](/monikabishnoi29) Also, be very clear with your basics. If you think you're not, then watch a playlist in YT and solve problems related to it. If you're talking specifically about graphs then I'd recommend Striver's new playlist on it. Its good"
                    },
                    {
                        "username": "colorfulpencil",
                        "content": "practice practice practice! \\nif you are not able to think of approach then look in discussion tab, if you are not able to think of code then look at others solutions and then try to code it yourself. Do it for few weeks and you will start getting intuition to code on your own. don\\'t be hard on yourself. "
                    },
                    {
                        "username": "altafshaikhmd6",
                        "content": "Every Other Question is difficult to understand brrrr."
                    },
                    {
                        "username": "kal425",
                        "content": "Hint : use disjoint set union"
                    },
                    {
                        "username": "0icy",
                        "content": "Whats the problem not passing last case\n\n\n``````\nclass Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        res = [x for x in range(26)]\n\n        def parent(n): @\n            if res[n] == n:\n                return n\n            return parent(res[n])\n\n        for i in range(len(s1)):\n            c = max(ord(s1[i]),ord(s2[i]))-97\n            p = min(ord(s1[i]),ord(s2[i]))-97\n  \n            l = parent(c)\n            print(l,c,p)\n            if l < p:\n                res[p] = l\n            else:\n                res[c] = p\n                res[l] = p\n\n\n\n        a = ''\n        for e in baseStr:\n            a += chr(parent(ord(e)-97)+97)\n        return a\n`"
                    },
                    {
                        "username": "ezksdo",
                        "content": "It\\'s the most confusing problem I\\'ve ever seen."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "In Simple language,\\nEvery character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order."
                    }
                ]
            },
            {
                "id": 1757628,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem shook me up"
                    },
                    {
                        "username": "sepac",
                        "content": "I made a graph and used a DFS and beat 5.11%. Not sure why it\\'s so slow but I\\'m going to try Union Find."
                    },
                    {
                        "username": "sk03167",
                        "content": "if you run dfs for each character, won\\'t the worst time complexity be size(baseStr)*depth(tree) where the worst case depth could be 25 (a->b, b->c, ...... so on) and each character in baseStr is a. Do let me know if their is something wrong in my understanding. "
                    },
                    {
                        "username": "ajesk",
                        "content": "Not terrible. Had to remember how to union again, then it just worked."
                    },
                    {
                        "username": "OO7_O",
                        "content": "everyone is coder,untill this premium level comes in...\\n\\n~le this question : \"kyu hila dala naa\" "
                    },
                    {
                        "username": "monikabishnoi29",
                        "content": "guys mujhe problem samjh aa jati hai but approach guess nhi kar pati sometimes or jb approach mil jati hai to code nhi likh pati \\uD83D\\uDE25kabhi ke baar ye sb step kar lu to solution easa hota hai mera ki tle maar deta hai\\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14 han m yahi bolna chah rahi hu ki solve nhi kar pa rahi problems"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@colorfulpencil](/colorfulpencil) Yes! [@monikabishnoi29](/monikabishnoi29) Also, be very clear with your basics. If you think you're not, then watch a playlist in YT and solve problems related to it. If you're talking specifically about graphs then I'd recommend Striver's new playlist on it. Its good"
                    },
                    {
                        "username": "colorfulpencil",
                        "content": "practice practice practice! \\nif you are not able to think of approach then look in discussion tab, if you are not able to think of code then look at others solutions and then try to code it yourself. Do it for few weeks and you will start getting intuition to code on your own. don\\'t be hard on yourself. "
                    },
                    {
                        "username": "altafshaikhmd6",
                        "content": "Every Other Question is difficult to understand brrrr."
                    },
                    {
                        "username": "kal425",
                        "content": "Hint : use disjoint set union"
                    },
                    {
                        "username": "0icy",
                        "content": "Whats the problem not passing last case\n\n\n``````\nclass Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        res = [x for x in range(26)]\n\n        def parent(n): @\n            if res[n] == n:\n                return n\n            return parent(res[n])\n\n        for i in range(len(s1)):\n            c = max(ord(s1[i]),ord(s2[i]))-97\n            p = min(ord(s1[i]),ord(s2[i]))-97\n  \n            l = parent(c)\n            print(l,c,p)\n            if l < p:\n                res[p] = l\n            else:\n                res[c] = p\n                res[l] = p\n\n\n\n        a = ''\n        for e in baseStr:\n            a += chr(parent(ord(e)-97)+97)\n        return a\n`"
                    },
                    {
                        "username": "ezksdo",
                        "content": "It\\'s the most confusing problem I\\'ve ever seen."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "In Simple language,\\nEvery character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order."
                    }
                ]
            },
            {
                "id": 1757626,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem shook me up"
                    },
                    {
                        "username": "sepac",
                        "content": "I made a graph and used a DFS and beat 5.11%. Not sure why it\\'s so slow but I\\'m going to try Union Find."
                    },
                    {
                        "username": "sk03167",
                        "content": "if you run dfs for each character, won\\'t the worst time complexity be size(baseStr)*depth(tree) where the worst case depth could be 25 (a->b, b->c, ...... so on) and each character in baseStr is a. Do let me know if their is something wrong in my understanding. "
                    },
                    {
                        "username": "ajesk",
                        "content": "Not terrible. Had to remember how to union again, then it just worked."
                    },
                    {
                        "username": "OO7_O",
                        "content": "everyone is coder,untill this premium level comes in...\\n\\n~le this question : \"kyu hila dala naa\" "
                    },
                    {
                        "username": "monikabishnoi29",
                        "content": "guys mujhe problem samjh aa jati hai but approach guess nhi kar pati sometimes or jb approach mil jati hai to code nhi likh pati \\uD83D\\uDE25kabhi ke baar ye sb step kar lu to solution easa hota hai mera ki tle maar deta hai\\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14 han m yahi bolna chah rahi hu ki solve nhi kar pa rahi problems"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@colorfulpencil](/colorfulpencil) Yes! [@monikabishnoi29](/monikabishnoi29) Also, be very clear with your basics. If you think you're not, then watch a playlist in YT and solve problems related to it. If you're talking specifically about graphs then I'd recommend Striver's new playlist on it. Its good"
                    },
                    {
                        "username": "colorfulpencil",
                        "content": "practice practice practice! \\nif you are not able to think of approach then look in discussion tab, if you are not able to think of code then look at others solutions and then try to code it yourself. Do it for few weeks and you will start getting intuition to code on your own. don\\'t be hard on yourself. "
                    },
                    {
                        "username": "altafshaikhmd6",
                        "content": "Every Other Question is difficult to understand brrrr."
                    },
                    {
                        "username": "kal425",
                        "content": "Hint : use disjoint set union"
                    },
                    {
                        "username": "0icy",
                        "content": "Whats the problem not passing last case\n\n\n``````\nclass Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        res = [x for x in range(26)]\n\n        def parent(n): @\n            if res[n] == n:\n                return n\n            return parent(res[n])\n\n        for i in range(len(s1)):\n            c = max(ord(s1[i]),ord(s2[i]))-97\n            p = min(ord(s1[i]),ord(s2[i]))-97\n  \n            l = parent(c)\n            print(l,c,p)\n            if l < p:\n                res[p] = l\n            else:\n                res[c] = p\n                res[l] = p\n\n\n\n        a = ''\n        for e in baseStr:\n            a += chr(parent(ord(e)-97)+97)\n        return a\n`"
                    },
                    {
                        "username": "ezksdo",
                        "content": "It\\'s the most confusing problem I\\'ve ever seen."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "In Simple language,\\nEvery character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order."
                    }
                ]
            },
            {
                "id": 1757612,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem shook me up"
                    },
                    {
                        "username": "sepac",
                        "content": "I made a graph and used a DFS and beat 5.11%. Not sure why it\\'s so slow but I\\'m going to try Union Find."
                    },
                    {
                        "username": "sk03167",
                        "content": "if you run dfs for each character, won\\'t the worst time complexity be size(baseStr)*depth(tree) where the worst case depth could be 25 (a->b, b->c, ...... so on) and each character in baseStr is a. Do let me know if their is something wrong in my understanding. "
                    },
                    {
                        "username": "ajesk",
                        "content": "Not terrible. Had to remember how to union again, then it just worked."
                    },
                    {
                        "username": "OO7_O",
                        "content": "everyone is coder,untill this premium level comes in...\\n\\n~le this question : \"kyu hila dala naa\" "
                    },
                    {
                        "username": "monikabishnoi29",
                        "content": "guys mujhe problem samjh aa jati hai but approach guess nhi kar pati sometimes or jb approach mil jati hai to code nhi likh pati \\uD83D\\uDE25kabhi ke baar ye sb step kar lu to solution easa hota hai mera ki tle maar deta hai\\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14 han m yahi bolna chah rahi hu ki solve nhi kar pa rahi problems"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@colorfulpencil](/colorfulpencil) Yes! [@monikabishnoi29](/monikabishnoi29) Also, be very clear with your basics. If you think you're not, then watch a playlist in YT and solve problems related to it. If you're talking specifically about graphs then I'd recommend Striver's new playlist on it. Its good"
                    },
                    {
                        "username": "colorfulpencil",
                        "content": "practice practice practice! \\nif you are not able to think of approach then look in discussion tab, if you are not able to think of code then look at others solutions and then try to code it yourself. Do it for few weeks and you will start getting intuition to code on your own. don\\'t be hard on yourself. "
                    },
                    {
                        "username": "altafshaikhmd6",
                        "content": "Every Other Question is difficult to understand brrrr."
                    },
                    {
                        "username": "kal425",
                        "content": "Hint : use disjoint set union"
                    },
                    {
                        "username": "0icy",
                        "content": "Whats the problem not passing last case\n\n\n``````\nclass Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        res = [x for x in range(26)]\n\n        def parent(n): @\n            if res[n] == n:\n                return n\n            return parent(res[n])\n\n        for i in range(len(s1)):\n            c = max(ord(s1[i]),ord(s2[i]))-97\n            p = min(ord(s1[i]),ord(s2[i]))-97\n  \n            l = parent(c)\n            print(l,c,p)\n            if l < p:\n                res[p] = l\n            else:\n                res[c] = p\n                res[l] = p\n\n\n\n        a = ''\n        for e in baseStr:\n            a += chr(parent(ord(e)-97)+97)\n        return a\n`"
                    },
                    {
                        "username": "ezksdo",
                        "content": "It\\'s the most confusing problem I\\'ve ever seen."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "In Simple language,\\nEvery character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order."
                    }
                ]
            },
            {
                "id": 1757607,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem shook me up"
                    },
                    {
                        "username": "sepac",
                        "content": "I made a graph and used a DFS and beat 5.11%. Not sure why it\\'s so slow but I\\'m going to try Union Find."
                    },
                    {
                        "username": "sk03167",
                        "content": "if you run dfs for each character, won\\'t the worst time complexity be size(baseStr)*depth(tree) where the worst case depth could be 25 (a->b, b->c, ...... so on) and each character in baseStr is a. Do let me know if their is something wrong in my understanding. "
                    },
                    {
                        "username": "ajesk",
                        "content": "Not terrible. Had to remember how to union again, then it just worked."
                    },
                    {
                        "username": "OO7_O",
                        "content": "everyone is coder,untill this premium level comes in...\\n\\n~le this question : \"kyu hila dala naa\" "
                    },
                    {
                        "username": "monikabishnoi29",
                        "content": "guys mujhe problem samjh aa jati hai but approach guess nhi kar pati sometimes or jb approach mil jati hai to code nhi likh pati \\uD83D\\uDE25kabhi ke baar ye sb step kar lu to solution easa hota hai mera ki tle maar deta hai\\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14 han m yahi bolna chah rahi hu ki solve nhi kar pa rahi problems"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@colorfulpencil](/colorfulpencil) Yes! [@monikabishnoi29](/monikabishnoi29) Also, be very clear with your basics. If you think you're not, then watch a playlist in YT and solve problems related to it. If you're talking specifically about graphs then I'd recommend Striver's new playlist on it. Its good"
                    },
                    {
                        "username": "colorfulpencil",
                        "content": "practice practice practice! \\nif you are not able to think of approach then look in discussion tab, if you are not able to think of code then look at others solutions and then try to code it yourself. Do it for few weeks and you will start getting intuition to code on your own. don\\'t be hard on yourself. "
                    },
                    {
                        "username": "altafshaikhmd6",
                        "content": "Every Other Question is difficult to understand brrrr."
                    },
                    {
                        "username": "kal425",
                        "content": "Hint : use disjoint set union"
                    },
                    {
                        "username": "0icy",
                        "content": "Whats the problem not passing last case\n\n\n``````\nclass Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        res = [x for x in range(26)]\n\n        def parent(n): @\n            if res[n] == n:\n                return n\n            return parent(res[n])\n\n        for i in range(len(s1)):\n            c = max(ord(s1[i]),ord(s2[i]))-97\n            p = min(ord(s1[i]),ord(s2[i]))-97\n  \n            l = parent(c)\n            print(l,c,p)\n            if l < p:\n                res[p] = l\n            else:\n                res[c] = p\n                res[l] = p\n\n\n\n        a = ''\n        for e in baseStr:\n            a += chr(parent(ord(e)-97)+97)\n        return a\n`"
                    },
                    {
                        "username": "ezksdo",
                        "content": "It\\'s the most confusing problem I\\'ve ever seen."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "In Simple language,\\nEvery character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order."
                    }
                ]
            },
            {
                "id": 1757597,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem shook me up"
                    },
                    {
                        "username": "sepac",
                        "content": "I made a graph and used a DFS and beat 5.11%. Not sure why it\\'s so slow but I\\'m going to try Union Find."
                    },
                    {
                        "username": "sk03167",
                        "content": "if you run dfs for each character, won\\'t the worst time complexity be size(baseStr)*depth(tree) where the worst case depth could be 25 (a->b, b->c, ...... so on) and each character in baseStr is a. Do let me know if their is something wrong in my understanding. "
                    },
                    {
                        "username": "ajesk",
                        "content": "Not terrible. Had to remember how to union again, then it just worked."
                    },
                    {
                        "username": "OO7_O",
                        "content": "everyone is coder,untill this premium level comes in...\\n\\n~le this question : \"kyu hila dala naa\" "
                    },
                    {
                        "username": "monikabishnoi29",
                        "content": "guys mujhe problem samjh aa jati hai but approach guess nhi kar pati sometimes or jb approach mil jati hai to code nhi likh pati \\uD83D\\uDE25kabhi ke baar ye sb step kar lu to solution easa hota hai mera ki tle maar deta hai\\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14 han m yahi bolna chah rahi hu ki solve nhi kar pa rahi problems"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@colorfulpencil](/colorfulpencil) Yes! [@monikabishnoi29](/monikabishnoi29) Also, be very clear with your basics. If you think you're not, then watch a playlist in YT and solve problems related to it. If you're talking specifically about graphs then I'd recommend Striver's new playlist on it. Its good"
                    },
                    {
                        "username": "colorfulpencil",
                        "content": "practice practice practice! \\nif you are not able to think of approach then look in discussion tab, if you are not able to think of code then look at others solutions and then try to code it yourself. Do it for few weeks and you will start getting intuition to code on your own. don\\'t be hard on yourself. "
                    },
                    {
                        "username": "altafshaikhmd6",
                        "content": "Every Other Question is difficult to understand brrrr."
                    },
                    {
                        "username": "kal425",
                        "content": "Hint : use disjoint set union"
                    },
                    {
                        "username": "0icy",
                        "content": "Whats the problem not passing last case\n\n\n``````\nclass Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        res = [x for x in range(26)]\n\n        def parent(n): @\n            if res[n] == n:\n                return n\n            return parent(res[n])\n\n        for i in range(len(s1)):\n            c = max(ord(s1[i]),ord(s2[i]))-97\n            p = min(ord(s1[i]),ord(s2[i]))-97\n  \n            l = parent(c)\n            print(l,c,p)\n            if l < p:\n                res[p] = l\n            else:\n                res[c] = p\n                res[l] = p\n\n\n\n        a = ''\n        for e in baseStr:\n            a += chr(parent(ord(e)-97)+97)\n        return a\n`"
                    },
                    {
                        "username": "ezksdo",
                        "content": "It\\'s the most confusing problem I\\'ve ever seen."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "In Simple language,\\nEvery character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order."
                    }
                ]
            },
            {
                "id": 1757509,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem shook me up"
                    },
                    {
                        "username": "sepac",
                        "content": "I made a graph and used a DFS and beat 5.11%. Not sure why it\\'s so slow but I\\'m going to try Union Find."
                    },
                    {
                        "username": "sk03167",
                        "content": "if you run dfs for each character, won\\'t the worst time complexity be size(baseStr)*depth(tree) where the worst case depth could be 25 (a->b, b->c, ...... so on) and each character in baseStr is a. Do let me know if their is something wrong in my understanding. "
                    },
                    {
                        "username": "ajesk",
                        "content": "Not terrible. Had to remember how to union again, then it just worked."
                    },
                    {
                        "username": "OO7_O",
                        "content": "everyone is coder,untill this premium level comes in...\\n\\n~le this question : \"kyu hila dala naa\" "
                    },
                    {
                        "username": "monikabishnoi29",
                        "content": "guys mujhe problem samjh aa jati hai but approach guess nhi kar pati sometimes or jb approach mil jati hai to code nhi likh pati \\uD83D\\uDE25kabhi ke baar ye sb step kar lu to solution easa hota hai mera ki tle maar deta hai\\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14 han m yahi bolna chah rahi hu ki solve nhi kar pa rahi problems"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@colorfulpencil](/colorfulpencil) Yes! [@monikabishnoi29](/monikabishnoi29) Also, be very clear with your basics. If you think you're not, then watch a playlist in YT and solve problems related to it. If you're talking specifically about graphs then I'd recommend Striver's new playlist on it. Its good"
                    },
                    {
                        "username": "colorfulpencil",
                        "content": "practice practice practice! \\nif you are not able to think of approach then look in discussion tab, if you are not able to think of code then look at others solutions and then try to code it yourself. Do it for few weeks and you will start getting intuition to code on your own. don\\'t be hard on yourself. "
                    },
                    {
                        "username": "altafshaikhmd6",
                        "content": "Every Other Question is difficult to understand brrrr."
                    },
                    {
                        "username": "kal425",
                        "content": "Hint : use disjoint set union"
                    },
                    {
                        "username": "0icy",
                        "content": "Whats the problem not passing last case\n\n\n``````\nclass Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        res = [x for x in range(26)]\n\n        def parent(n): @\n            if res[n] == n:\n                return n\n            return parent(res[n])\n\n        for i in range(len(s1)):\n            c = max(ord(s1[i]),ord(s2[i]))-97\n            p = min(ord(s1[i]),ord(s2[i]))-97\n  \n            l = parent(c)\n            print(l,c,p)\n            if l < p:\n                res[p] = l\n            else:\n                res[c] = p\n                res[l] = p\n\n\n\n        a = ''\n        for e in baseStr:\n            a += chr(parent(ord(e)-97)+97)\n        return a\n`"
                    },
                    {
                        "username": "ezksdo",
                        "content": "It\\'s the most confusing problem I\\'ve ever seen."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "In Simple language,\\nEvery character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order."
                    }
                ]
            },
            {
                "id": 1757506,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem shook me up"
                    },
                    {
                        "username": "sepac",
                        "content": "I made a graph and used a DFS and beat 5.11%. Not sure why it\\'s so slow but I\\'m going to try Union Find."
                    },
                    {
                        "username": "sk03167",
                        "content": "if you run dfs for each character, won\\'t the worst time complexity be size(baseStr)*depth(tree) where the worst case depth could be 25 (a->b, b->c, ...... so on) and each character in baseStr is a. Do let me know if their is something wrong in my understanding. "
                    },
                    {
                        "username": "ajesk",
                        "content": "Not terrible. Had to remember how to union again, then it just worked."
                    },
                    {
                        "username": "OO7_O",
                        "content": "everyone is coder,untill this premium level comes in...\\n\\n~le this question : \"kyu hila dala naa\" "
                    },
                    {
                        "username": "monikabishnoi29",
                        "content": "guys mujhe problem samjh aa jati hai but approach guess nhi kar pati sometimes or jb approach mil jati hai to code nhi likh pati \\uD83D\\uDE25kabhi ke baar ye sb step kar lu to solution easa hota hai mera ki tle maar deta hai\\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14 han m yahi bolna chah rahi hu ki solve nhi kar pa rahi problems"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@colorfulpencil](/colorfulpencil) Yes! [@monikabishnoi29](/monikabishnoi29) Also, be very clear with your basics. If you think you're not, then watch a playlist in YT and solve problems related to it. If you're talking specifically about graphs then I'd recommend Striver's new playlist on it. Its good"
                    },
                    {
                        "username": "colorfulpencil",
                        "content": "practice practice practice! \\nif you are not able to think of approach then look in discussion tab, if you are not able to think of code then look at others solutions and then try to code it yourself. Do it for few weeks and you will start getting intuition to code on your own. don\\'t be hard on yourself. "
                    },
                    {
                        "username": "altafshaikhmd6",
                        "content": "Every Other Question is difficult to understand brrrr."
                    },
                    {
                        "username": "kal425",
                        "content": "Hint : use disjoint set union"
                    },
                    {
                        "username": "0icy",
                        "content": "Whats the problem not passing last case\n\n\n``````\nclass Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        res = [x for x in range(26)]\n\n        def parent(n): @\n            if res[n] == n:\n                return n\n            return parent(res[n])\n\n        for i in range(len(s1)):\n            c = max(ord(s1[i]),ord(s2[i]))-97\n            p = min(ord(s1[i]),ord(s2[i]))-97\n  \n            l = parent(c)\n            print(l,c,p)\n            if l < p:\n                res[p] = l\n            else:\n                res[c] = p\n                res[l] = p\n\n\n\n        a = ''\n        for e in baseStr:\n            a += chr(parent(ord(e)-97)+97)\n        return a\n`"
                    },
                    {
                        "username": "ezksdo",
                        "content": "It\\'s the most confusing problem I\\'ve ever seen."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "In Simple language,\\nEvery character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order."
                    }
                ]
            },
            {
                "id": 1757492,
                "content": [
                    {
                        "username": "Msey",
                        "content": "How to unsubscribe this section?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "wow I never thought I could understand wordy questions this easy!! "
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Got the 100% Faster solution using Java: https://youtu.be/A_4BOzdjcys"
                    },
                    {
                        "username": "abdullah_Nassar",
                        "content": "any one have solution rather than (DSU)?"
                    },
                    {
                        "username": "sk03167",
                        "content": "[@Mister_CK](/Mister_CK) If you want to do it like this, can we not store just the lexographically smallest equivalent of each character in a 26X2 matrix. Then all you need to do is replace a character with it's matrix counterpart. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think so. I tried to do it in the way the examples are explained, which worked:\nI create a decoder, which is an array of arrays, each containing all chars that are equivalent to each other. Then I iterate over it from back to front, if I find that there is a character in a group that is also in another group, I merge the groups (at the index of the smallest group). Lastly I keep iterating over the baseString, replacing chars with chars in a higher priority group until there is nothing left to change. I hope this is understandable (it's a bit tough to explain)\nI don't recommend this approach, the official solution are much much cleaner. But it did work and is even reasonably quick (128 ms) (and is has no recursion or graphs)"
                    },
                    {
                        "username": "rajugurjar",
                        "content": "great"
                    },
                    {
                        "username": "CGK2002",
                        "content": "Can anyone explain this problem statement in an understandable way please? I can\\'t understand from the description."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "every character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order. If understood , you can still ask me again. Thanks!!!!"
                    },
                    {
                        "username": "itsmeparag14",
                        "content": "This month dailies are killing me"
                    },
                    {
                        "username": "pan__",
                        "content": "You can look at algorithm4 for The one"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "here  who are saying that ```finally a non-graph problem``` . Lol , this problem easily can be solved using Disjoint set union concept.\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1061. Lexicographically smallest equivalent string.jpg](https://assets.leetcode.com/users/images/5c624c61-561f-4612-967c-c6400275674a_1673690827.9655392.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1757489,
                "content": [
                    {
                        "username": "Msey",
                        "content": "How to unsubscribe this section?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "wow I never thought I could understand wordy questions this easy!! "
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Got the 100% Faster solution using Java: https://youtu.be/A_4BOzdjcys"
                    },
                    {
                        "username": "abdullah_Nassar",
                        "content": "any one have solution rather than (DSU)?"
                    },
                    {
                        "username": "sk03167",
                        "content": "[@Mister_CK](/Mister_CK) If you want to do it like this, can we not store just the lexographically smallest equivalent of each character in a 26X2 matrix. Then all you need to do is replace a character with it's matrix counterpart. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think so. I tried to do it in the way the examples are explained, which worked:\nI create a decoder, which is an array of arrays, each containing all chars that are equivalent to each other. Then I iterate over it from back to front, if I find that there is a character in a group that is also in another group, I merge the groups (at the index of the smallest group). Lastly I keep iterating over the baseString, replacing chars with chars in a higher priority group until there is nothing left to change. I hope this is understandable (it's a bit tough to explain)\nI don't recommend this approach, the official solution are much much cleaner. But it did work and is even reasonably quick (128 ms) (and is has no recursion or graphs)"
                    },
                    {
                        "username": "rajugurjar",
                        "content": "great"
                    },
                    {
                        "username": "CGK2002",
                        "content": "Can anyone explain this problem statement in an understandable way please? I can\\'t understand from the description."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "every character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order. If understood , you can still ask me again. Thanks!!!!"
                    },
                    {
                        "username": "itsmeparag14",
                        "content": "This month dailies are killing me"
                    },
                    {
                        "username": "pan__",
                        "content": "You can look at algorithm4 for The one"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "here  who are saying that ```finally a non-graph problem``` . Lol , this problem easily can be solved using Disjoint set union concept.\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1061. Lexicographically smallest equivalent string.jpg](https://assets.leetcode.com/users/images/5c624c61-561f-4612-967c-c6400275674a_1673690827.9655392.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1757438,
                "content": [
                    {
                        "username": "Msey",
                        "content": "How to unsubscribe this section?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "wow I never thought I could understand wordy questions this easy!! "
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Got the 100% Faster solution using Java: https://youtu.be/A_4BOzdjcys"
                    },
                    {
                        "username": "abdullah_Nassar",
                        "content": "any one have solution rather than (DSU)?"
                    },
                    {
                        "username": "sk03167",
                        "content": "[@Mister_CK](/Mister_CK) If you want to do it like this, can we not store just the lexographically smallest equivalent of each character in a 26X2 matrix. Then all you need to do is replace a character with it's matrix counterpart. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think so. I tried to do it in the way the examples are explained, which worked:\nI create a decoder, which is an array of arrays, each containing all chars that are equivalent to each other. Then I iterate over it from back to front, if I find that there is a character in a group that is also in another group, I merge the groups (at the index of the smallest group). Lastly I keep iterating over the baseString, replacing chars with chars in a higher priority group until there is nothing left to change. I hope this is understandable (it's a bit tough to explain)\nI don't recommend this approach, the official solution are much much cleaner. But it did work and is even reasonably quick (128 ms) (and is has no recursion or graphs)"
                    },
                    {
                        "username": "rajugurjar",
                        "content": "great"
                    },
                    {
                        "username": "CGK2002",
                        "content": "Can anyone explain this problem statement in an understandable way please? I can\\'t understand from the description."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "every character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order. If understood , you can still ask me again. Thanks!!!!"
                    },
                    {
                        "username": "itsmeparag14",
                        "content": "This month dailies are killing me"
                    },
                    {
                        "username": "pan__",
                        "content": "You can look at algorithm4 for The one"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "here  who are saying that ```finally a non-graph problem``` . Lol , this problem easily can be solved using Disjoint set union concept.\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1061. Lexicographically smallest equivalent string.jpg](https://assets.leetcode.com/users/images/5c624c61-561f-4612-967c-c6400275674a_1673690827.9655392.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1757433,
                "content": [
                    {
                        "username": "Msey",
                        "content": "How to unsubscribe this section?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "wow I never thought I could understand wordy questions this easy!! "
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Got the 100% Faster solution using Java: https://youtu.be/A_4BOzdjcys"
                    },
                    {
                        "username": "abdullah_Nassar",
                        "content": "any one have solution rather than (DSU)?"
                    },
                    {
                        "username": "sk03167",
                        "content": "[@Mister_CK](/Mister_CK) If you want to do it like this, can we not store just the lexographically smallest equivalent of each character in a 26X2 matrix. Then all you need to do is replace a character with it's matrix counterpart. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think so. I tried to do it in the way the examples are explained, which worked:\nI create a decoder, which is an array of arrays, each containing all chars that are equivalent to each other. Then I iterate over it from back to front, if I find that there is a character in a group that is also in another group, I merge the groups (at the index of the smallest group). Lastly I keep iterating over the baseString, replacing chars with chars in a higher priority group until there is nothing left to change. I hope this is understandable (it's a bit tough to explain)\nI don't recommend this approach, the official solution are much much cleaner. But it did work and is even reasonably quick (128 ms) (and is has no recursion or graphs)"
                    },
                    {
                        "username": "rajugurjar",
                        "content": "great"
                    },
                    {
                        "username": "CGK2002",
                        "content": "Can anyone explain this problem statement in an understandable way please? I can\\'t understand from the description."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "every character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order. If understood , you can still ask me again. Thanks!!!!"
                    },
                    {
                        "username": "itsmeparag14",
                        "content": "This month dailies are killing me"
                    },
                    {
                        "username": "pan__",
                        "content": "You can look at algorithm4 for The one"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "here  who are saying that ```finally a non-graph problem``` . Lol , this problem easily can be solved using Disjoint set union concept.\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1061. Lexicographically smallest equivalent string.jpg](https://assets.leetcode.com/users/images/5c624c61-561f-4612-967c-c6400275674a_1673690827.9655392.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1757426,
                "content": [
                    {
                        "username": "Msey",
                        "content": "How to unsubscribe this section?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "wow I never thought I could understand wordy questions this easy!! "
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Got the 100% Faster solution using Java: https://youtu.be/A_4BOzdjcys"
                    },
                    {
                        "username": "abdullah_Nassar",
                        "content": "any one have solution rather than (DSU)?"
                    },
                    {
                        "username": "sk03167",
                        "content": "[@Mister_CK](/Mister_CK) If you want to do it like this, can we not store just the lexographically smallest equivalent of each character in a 26X2 matrix. Then all you need to do is replace a character with it's matrix counterpart. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think so. I tried to do it in the way the examples are explained, which worked:\nI create a decoder, which is an array of arrays, each containing all chars that are equivalent to each other. Then I iterate over it from back to front, if I find that there is a character in a group that is also in another group, I merge the groups (at the index of the smallest group). Lastly I keep iterating over the baseString, replacing chars with chars in a higher priority group until there is nothing left to change. I hope this is understandable (it's a bit tough to explain)\nI don't recommend this approach, the official solution are much much cleaner. But it did work and is even reasonably quick (128 ms) (and is has no recursion or graphs)"
                    },
                    {
                        "username": "rajugurjar",
                        "content": "great"
                    },
                    {
                        "username": "CGK2002",
                        "content": "Can anyone explain this problem statement in an understandable way please? I can\\'t understand from the description."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "every character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order. If understood , you can still ask me again. Thanks!!!!"
                    },
                    {
                        "username": "itsmeparag14",
                        "content": "This month dailies are killing me"
                    },
                    {
                        "username": "pan__",
                        "content": "You can look at algorithm4 for The one"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "here  who are saying that ```finally a non-graph problem``` . Lol , this problem easily can be solved using Disjoint set union concept.\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1061. Lexicographically smallest equivalent string.jpg](https://assets.leetcode.com/users/images/5c624c61-561f-4612-967c-c6400275674a_1673690827.9655392.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1757425,
                "content": [
                    {
                        "username": "Msey",
                        "content": "How to unsubscribe this section?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "wow I never thought I could understand wordy questions this easy!! "
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Got the 100% Faster solution using Java: https://youtu.be/A_4BOzdjcys"
                    },
                    {
                        "username": "abdullah_Nassar",
                        "content": "any one have solution rather than (DSU)?"
                    },
                    {
                        "username": "sk03167",
                        "content": "[@Mister_CK](/Mister_CK) If you want to do it like this, can we not store just the lexographically smallest equivalent of each character in a 26X2 matrix. Then all you need to do is replace a character with it's matrix counterpart. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think so. I tried to do it in the way the examples are explained, which worked:\nI create a decoder, which is an array of arrays, each containing all chars that are equivalent to each other. Then I iterate over it from back to front, if I find that there is a character in a group that is also in another group, I merge the groups (at the index of the smallest group). Lastly I keep iterating over the baseString, replacing chars with chars in a higher priority group until there is nothing left to change. I hope this is understandable (it's a bit tough to explain)\nI don't recommend this approach, the official solution are much much cleaner. But it did work and is even reasonably quick (128 ms) (and is has no recursion or graphs)"
                    },
                    {
                        "username": "rajugurjar",
                        "content": "great"
                    },
                    {
                        "username": "CGK2002",
                        "content": "Can anyone explain this problem statement in an understandable way please? I can\\'t understand from the description."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "every character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order. If understood , you can still ask me again. Thanks!!!!"
                    },
                    {
                        "username": "itsmeparag14",
                        "content": "This month dailies are killing me"
                    },
                    {
                        "username": "pan__",
                        "content": "You can look at algorithm4 for The one"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "here  who are saying that ```finally a non-graph problem``` . Lol , this problem easily can be solved using Disjoint set union concept.\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1061. Lexicographically smallest equivalent string.jpg](https://assets.leetcode.com/users/images/5c624c61-561f-4612-967c-c6400275674a_1673690827.9655392.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1757419,
                "content": [
                    {
                        "username": "Msey",
                        "content": "How to unsubscribe this section?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "wow I never thought I could understand wordy questions this easy!! "
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Got the 100% Faster solution using Java: https://youtu.be/A_4BOzdjcys"
                    },
                    {
                        "username": "abdullah_Nassar",
                        "content": "any one have solution rather than (DSU)?"
                    },
                    {
                        "username": "sk03167",
                        "content": "[@Mister_CK](/Mister_CK) If you want to do it like this, can we not store just the lexographically smallest equivalent of each character in a 26X2 matrix. Then all you need to do is replace a character with it's matrix counterpart. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think so. I tried to do it in the way the examples are explained, which worked:\nI create a decoder, which is an array of arrays, each containing all chars that are equivalent to each other. Then I iterate over it from back to front, if I find that there is a character in a group that is also in another group, I merge the groups (at the index of the smallest group). Lastly I keep iterating over the baseString, replacing chars with chars in a higher priority group until there is nothing left to change. I hope this is understandable (it's a bit tough to explain)\nI don't recommend this approach, the official solution are much much cleaner. But it did work and is even reasonably quick (128 ms) (and is has no recursion or graphs)"
                    },
                    {
                        "username": "rajugurjar",
                        "content": "great"
                    },
                    {
                        "username": "CGK2002",
                        "content": "Can anyone explain this problem statement in an understandable way please? I can\\'t understand from the description."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "every character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order. If understood , you can still ask me again. Thanks!!!!"
                    },
                    {
                        "username": "itsmeparag14",
                        "content": "This month dailies are killing me"
                    },
                    {
                        "username": "pan__",
                        "content": "You can look at algorithm4 for The one"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "here  who are saying that ```finally a non-graph problem``` . Lol , this problem easily can be solved using Disjoint set union concept.\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1061. Lexicographically smallest equivalent string.jpg](https://assets.leetcode.com/users/images/5c624c61-561f-4612-967c-c6400275674a_1673690827.9655392.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1757411,
                "content": [
                    {
                        "username": "Msey",
                        "content": "How to unsubscribe this section?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "wow I never thought I could understand wordy questions this easy!! "
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Got the 100% Faster solution using Java: https://youtu.be/A_4BOzdjcys"
                    },
                    {
                        "username": "abdullah_Nassar",
                        "content": "any one have solution rather than (DSU)?"
                    },
                    {
                        "username": "sk03167",
                        "content": "[@Mister_CK](/Mister_CK) If you want to do it like this, can we not store just the lexographically smallest equivalent of each character in a 26X2 matrix. Then all you need to do is replace a character with it's matrix counterpart. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think so. I tried to do it in the way the examples are explained, which worked:\nI create a decoder, which is an array of arrays, each containing all chars that are equivalent to each other. Then I iterate over it from back to front, if I find that there is a character in a group that is also in another group, I merge the groups (at the index of the smallest group). Lastly I keep iterating over the baseString, replacing chars with chars in a higher priority group until there is nothing left to change. I hope this is understandable (it's a bit tough to explain)\nI don't recommend this approach, the official solution are much much cleaner. But it did work and is even reasonably quick (128 ms) (and is has no recursion or graphs)"
                    },
                    {
                        "username": "rajugurjar",
                        "content": "great"
                    },
                    {
                        "username": "CGK2002",
                        "content": "Can anyone explain this problem statement in an understandable way please? I can\\'t understand from the description."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "every character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order. If understood , you can still ask me again. Thanks!!!!"
                    },
                    {
                        "username": "itsmeparag14",
                        "content": "This month dailies are killing me"
                    },
                    {
                        "username": "pan__",
                        "content": "You can look at algorithm4 for The one"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "here  who are saying that ```finally a non-graph problem``` . Lol , this problem easily can be solved using Disjoint set union concept.\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1061. Lexicographically smallest equivalent string.jpg](https://assets.leetcode.com/users/images/5c624c61-561f-4612-967c-c6400275674a_1673690827.9655392.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1757385,
                "content": [
                    {
                        "username": "Msey",
                        "content": "How to unsubscribe this section?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "wow I never thought I could understand wordy questions this easy!! "
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Got the 100% Faster solution using Java: https://youtu.be/A_4BOzdjcys"
                    },
                    {
                        "username": "abdullah_Nassar",
                        "content": "any one have solution rather than (DSU)?"
                    },
                    {
                        "username": "sk03167",
                        "content": "[@Mister_CK](/Mister_CK) If you want to do it like this, can we not store just the lexographically smallest equivalent of each character in a 26X2 matrix. Then all you need to do is replace a character with it's matrix counterpart. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think so. I tried to do it in the way the examples are explained, which worked:\nI create a decoder, which is an array of arrays, each containing all chars that are equivalent to each other. Then I iterate over it from back to front, if I find that there is a character in a group that is also in another group, I merge the groups (at the index of the smallest group). Lastly I keep iterating over the baseString, replacing chars with chars in a higher priority group until there is nothing left to change. I hope this is understandable (it's a bit tough to explain)\nI don't recommend this approach, the official solution are much much cleaner. But it did work and is even reasonably quick (128 ms) (and is has no recursion or graphs)"
                    },
                    {
                        "username": "rajugurjar",
                        "content": "great"
                    },
                    {
                        "username": "CGK2002",
                        "content": "Can anyone explain this problem statement in an understandable way please? I can\\'t understand from the description."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "every character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order. If understood , you can still ask me again. Thanks!!!!"
                    },
                    {
                        "username": "itsmeparag14",
                        "content": "This month dailies are killing me"
                    },
                    {
                        "username": "pan__",
                        "content": "You can look at algorithm4 for The one"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "here  who are saying that ```finally a non-graph problem``` . Lol , this problem easily can be solved using Disjoint set union concept.\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1061. Lexicographically smallest equivalent string.jpg](https://assets.leetcode.com/users/images/5c624c61-561f-4612-967c-c6400275674a_1673690827.9655392.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1757382,
                "content": [
                    {
                        "username": "Msey",
                        "content": "How to unsubscribe this section?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "wow I never thought I could understand wordy questions this easy!! "
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Got the 100% Faster solution using Java: https://youtu.be/A_4BOzdjcys"
                    },
                    {
                        "username": "abdullah_Nassar",
                        "content": "any one have solution rather than (DSU)?"
                    },
                    {
                        "username": "sk03167",
                        "content": "[@Mister_CK](/Mister_CK) If you want to do it like this, can we not store just the lexographically smallest equivalent of each character in a 26X2 matrix. Then all you need to do is replace a character with it's matrix counterpart. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think so. I tried to do it in the way the examples are explained, which worked:\nI create a decoder, which is an array of arrays, each containing all chars that are equivalent to each other. Then I iterate over it from back to front, if I find that there is a character in a group that is also in another group, I merge the groups (at the index of the smallest group). Lastly I keep iterating over the baseString, replacing chars with chars in a higher priority group until there is nothing left to change. I hope this is understandable (it's a bit tough to explain)\nI don't recommend this approach, the official solution are much much cleaner. But it did work and is even reasonably quick (128 ms) (and is has no recursion or graphs)"
                    },
                    {
                        "username": "rajugurjar",
                        "content": "great"
                    },
                    {
                        "username": "CGK2002",
                        "content": "Can anyone explain this problem statement in an understandable way please? I can\\'t understand from the description."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "every character from s1 is mapping to every corresponding character in s2. You are given a string baseStr and you have to form a answer string with the help of baseStr such that if replace each character from the baseStr by the equivalent mapping if obtain from string s1 and s2 it should form our answer string with lexicographically smallest order. If understood , you can still ask me again. Thanks!!!!"
                    },
                    {
                        "username": "itsmeparag14",
                        "content": "This month dailies are killing me"
                    },
                    {
                        "username": "pan__",
                        "content": "You can look at algorithm4 for The one"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "here  who are saying that ```finally a non-graph problem``` . Lol , this problem easily can be solved using Disjoint set union concept.\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1061. Lexicographically smallest equivalent string.jpg](https://assets.leetcode.com/users/images/5c624c61-561f-4612-967c-c6400275674a_1673690827.9655392.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1757306,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "what"
                    },
                    {
                        "username": "ashok1903",
                        "content": "Passes 84/116 Testcase have to find bug in code\\uD83D\\uDE2A Does any one facing this issue let me know!!!\\uD83E\\uDEE0\\n"
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Was just going through union find concept  yesterday and leetcode wanted to test it.\\n"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "I thought I will hit TLE, but still able to achieve it using HashMap and TreeSet and beats 100% lol.\\n\\n1. Create a graph mapping \\n   - `s1[i]` to `s2[i]` \\n   - `s2[i]` to `s1[i]`\\n2. DFS through all the characters and pass all their equivalents to parent\\n3. Keep track of the visited character as we don\\'t want to revisit them to avoid infinite loop\\n4. If the set has more than one value (size>1), means it is a mapping / equivalent set\\n5. Going through the set, assign each character in the set as map key, and set its value to the set \\n```\\nFor example, {k,r,s}, \\nk=>{k,r,s}, \\nr=>{k,r,s}, \\ns=>{k,r,s}\\n```\\n6. Lastly, loop each character in `baseStr` and get its minimum equivalent from the map we created in step 5. We can always get the first character from the map since we are using a `TreeSet` here and the characters are sorted automatically.\\n\\nPlease upvote if this is helpful :)\\nMy Kotlin [solution ](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049019/kotlin-solution-using-dfs-and-treeset-100/?languageTags=kotlin)\\n"
                    },
                    {
                        "username": "Real-Supreme",
                        "content": "aauaaaaada lol\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "For tomorrow, be prepared for the same type of problem - Union Find/Disjoint Set"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<vector<int>> graph(26);\\n        for(int i = 0 ; i < n ; i++){\\n            graph[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            graph[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        string res;\\n\\n        vector<int> marker(26,-1);\\n\\n        function<void(int , vector<int> , int)> dfs = [&](int node , vector<int> visited , int val){\\n            visited[node] = 1;\\n            marker[node] = val;\\n            for(auto &child : graph[node]){\\n                if(visited[child] != 1){\\n                    dfs(child , visited , val);\\n                }\\n            }\\n        };\\n\\n        for(int i = 0 ; i < s1.size(); i++){\\n            vector<int> visited(26,0);\\n            int val = s1[i] - \\'a\\';\\n            if(marker[val] == -1) dfs(val , visited , val);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.size(); i++){\\n            int val = marker[baseStr[i] - \\'a\\']; \\n            if(val == -1){\\n                res += baseStr[i];\\n                continue;\\n            }\\n            int ans = 27;\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(marker[j] == val){\\n                    ans = min(ans , j);\\n                }\\n            }\\n            res += ans + \\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nWhy TLE plese Explain..."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "I decided to make a video explaining my solution to this problem. Let me know if you like the style and I\\'ll make more!\\n\\n[https://youtu.be/bETKbaNl0pk](https://youtu.be/bETKbaNl0pk)"
                    },
                    {
                        "username": "sanjaysekaren",
                        "content": "Tip: \\nAvoid unwanted iterations as possible.\\n\\n\\nEasy approach , Check my below solution (Not best but understandable):\\n\\nRuns less than 100ms.\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3048507/beats-100-less-100ms-easy-understanding-solution-with-explanation-js-ts/"
                    },
                    {
                        "username": "dsk2",
                        "content": "C++ Disjoint Solution can be found here: [Solution Walkthrough](https://medium.com/@kapoordeepjyotsingh29/leetcode-solution-for-lexicographically-smallest-equivalent-string-d8db35961b4c)"
                    }
                ]
            },
            {
                "id": 1757303,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "what"
                    },
                    {
                        "username": "ashok1903",
                        "content": "Passes 84/116 Testcase have to find bug in code\\uD83D\\uDE2A Does any one facing this issue let me know!!!\\uD83E\\uDEE0\\n"
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Was just going through union find concept  yesterday and leetcode wanted to test it.\\n"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "I thought I will hit TLE, but still able to achieve it using HashMap and TreeSet and beats 100% lol.\\n\\n1. Create a graph mapping \\n   - `s1[i]` to `s2[i]` \\n   - `s2[i]` to `s1[i]`\\n2. DFS through all the characters and pass all their equivalents to parent\\n3. Keep track of the visited character as we don\\'t want to revisit them to avoid infinite loop\\n4. If the set has more than one value (size>1), means it is a mapping / equivalent set\\n5. Going through the set, assign each character in the set as map key, and set its value to the set \\n```\\nFor example, {k,r,s}, \\nk=>{k,r,s}, \\nr=>{k,r,s}, \\ns=>{k,r,s}\\n```\\n6. Lastly, loop each character in `baseStr` and get its minimum equivalent from the map we created in step 5. We can always get the first character from the map since we are using a `TreeSet` here and the characters are sorted automatically.\\n\\nPlease upvote if this is helpful :)\\nMy Kotlin [solution ](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049019/kotlin-solution-using-dfs-and-treeset-100/?languageTags=kotlin)\\n"
                    },
                    {
                        "username": "Real-Supreme",
                        "content": "aauaaaaada lol\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "For tomorrow, be prepared for the same type of problem - Union Find/Disjoint Set"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<vector<int>> graph(26);\\n        for(int i = 0 ; i < n ; i++){\\n            graph[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            graph[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        string res;\\n\\n        vector<int> marker(26,-1);\\n\\n        function<void(int , vector<int> , int)> dfs = [&](int node , vector<int> visited , int val){\\n            visited[node] = 1;\\n            marker[node] = val;\\n            for(auto &child : graph[node]){\\n                if(visited[child] != 1){\\n                    dfs(child , visited , val);\\n                }\\n            }\\n        };\\n\\n        for(int i = 0 ; i < s1.size(); i++){\\n            vector<int> visited(26,0);\\n            int val = s1[i] - \\'a\\';\\n            if(marker[val] == -1) dfs(val , visited , val);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.size(); i++){\\n            int val = marker[baseStr[i] - \\'a\\']; \\n            if(val == -1){\\n                res += baseStr[i];\\n                continue;\\n            }\\n            int ans = 27;\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(marker[j] == val){\\n                    ans = min(ans , j);\\n                }\\n            }\\n            res += ans + \\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nWhy TLE plese Explain..."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "I decided to make a video explaining my solution to this problem. Let me know if you like the style and I\\'ll make more!\\n\\n[https://youtu.be/bETKbaNl0pk](https://youtu.be/bETKbaNl0pk)"
                    },
                    {
                        "username": "sanjaysekaren",
                        "content": "Tip: \\nAvoid unwanted iterations as possible.\\n\\n\\nEasy approach , Check my below solution (Not best but understandable):\\n\\nRuns less than 100ms.\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3048507/beats-100-less-100ms-easy-understanding-solution-with-explanation-js-ts/"
                    },
                    {
                        "username": "dsk2",
                        "content": "C++ Disjoint Solution can be found here: [Solution Walkthrough](https://medium.com/@kapoordeepjyotsingh29/leetcode-solution-for-lexicographically-smallest-equivalent-string-d8db35961b4c)"
                    }
                ]
            },
            {
                "id": 1757292,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "what"
                    },
                    {
                        "username": "ashok1903",
                        "content": "Passes 84/116 Testcase have to find bug in code\\uD83D\\uDE2A Does any one facing this issue let me know!!!\\uD83E\\uDEE0\\n"
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Was just going through union find concept  yesterday and leetcode wanted to test it.\\n"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "I thought I will hit TLE, but still able to achieve it using HashMap and TreeSet and beats 100% lol.\\n\\n1. Create a graph mapping \\n   - `s1[i]` to `s2[i]` \\n   - `s2[i]` to `s1[i]`\\n2. DFS through all the characters and pass all their equivalents to parent\\n3. Keep track of the visited character as we don\\'t want to revisit them to avoid infinite loop\\n4. If the set has more than one value (size>1), means it is a mapping / equivalent set\\n5. Going through the set, assign each character in the set as map key, and set its value to the set \\n```\\nFor example, {k,r,s}, \\nk=>{k,r,s}, \\nr=>{k,r,s}, \\ns=>{k,r,s}\\n```\\n6. Lastly, loop each character in `baseStr` and get its minimum equivalent from the map we created in step 5. We can always get the first character from the map since we are using a `TreeSet` here and the characters are sorted automatically.\\n\\nPlease upvote if this is helpful :)\\nMy Kotlin [solution ](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049019/kotlin-solution-using-dfs-and-treeset-100/?languageTags=kotlin)\\n"
                    },
                    {
                        "username": "Real-Supreme",
                        "content": "aauaaaaada lol\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "For tomorrow, be prepared for the same type of problem - Union Find/Disjoint Set"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<vector<int>> graph(26);\\n        for(int i = 0 ; i < n ; i++){\\n            graph[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            graph[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        string res;\\n\\n        vector<int> marker(26,-1);\\n\\n        function<void(int , vector<int> , int)> dfs = [&](int node , vector<int> visited , int val){\\n            visited[node] = 1;\\n            marker[node] = val;\\n            for(auto &child : graph[node]){\\n                if(visited[child] != 1){\\n                    dfs(child , visited , val);\\n                }\\n            }\\n        };\\n\\n        for(int i = 0 ; i < s1.size(); i++){\\n            vector<int> visited(26,0);\\n            int val = s1[i] - \\'a\\';\\n            if(marker[val] == -1) dfs(val , visited , val);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.size(); i++){\\n            int val = marker[baseStr[i] - \\'a\\']; \\n            if(val == -1){\\n                res += baseStr[i];\\n                continue;\\n            }\\n            int ans = 27;\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(marker[j] == val){\\n                    ans = min(ans , j);\\n                }\\n            }\\n            res += ans + \\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nWhy TLE plese Explain..."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "I decided to make a video explaining my solution to this problem. Let me know if you like the style and I\\'ll make more!\\n\\n[https://youtu.be/bETKbaNl0pk](https://youtu.be/bETKbaNl0pk)"
                    },
                    {
                        "username": "sanjaysekaren",
                        "content": "Tip: \\nAvoid unwanted iterations as possible.\\n\\n\\nEasy approach , Check my below solution (Not best but understandable):\\n\\nRuns less than 100ms.\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3048507/beats-100-less-100ms-easy-understanding-solution-with-explanation-js-ts/"
                    },
                    {
                        "username": "dsk2",
                        "content": "C++ Disjoint Solution can be found here: [Solution Walkthrough](https://medium.com/@kapoordeepjyotsingh29/leetcode-solution-for-lexicographically-smallest-equivalent-string-d8db35961b4c)"
                    }
                ]
            },
            {
                "id": 1757290,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "what"
                    },
                    {
                        "username": "ashok1903",
                        "content": "Passes 84/116 Testcase have to find bug in code\\uD83D\\uDE2A Does any one facing this issue let me know!!!\\uD83E\\uDEE0\\n"
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Was just going through union find concept  yesterday and leetcode wanted to test it.\\n"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "I thought I will hit TLE, but still able to achieve it using HashMap and TreeSet and beats 100% lol.\\n\\n1. Create a graph mapping \\n   - `s1[i]` to `s2[i]` \\n   - `s2[i]` to `s1[i]`\\n2. DFS through all the characters and pass all their equivalents to parent\\n3. Keep track of the visited character as we don\\'t want to revisit them to avoid infinite loop\\n4. If the set has more than one value (size>1), means it is a mapping / equivalent set\\n5. Going through the set, assign each character in the set as map key, and set its value to the set \\n```\\nFor example, {k,r,s}, \\nk=>{k,r,s}, \\nr=>{k,r,s}, \\ns=>{k,r,s}\\n```\\n6. Lastly, loop each character in `baseStr` and get its minimum equivalent from the map we created in step 5. We can always get the first character from the map since we are using a `TreeSet` here and the characters are sorted automatically.\\n\\nPlease upvote if this is helpful :)\\nMy Kotlin [solution ](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049019/kotlin-solution-using-dfs-and-treeset-100/?languageTags=kotlin)\\n"
                    },
                    {
                        "username": "Real-Supreme",
                        "content": "aauaaaaada lol\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "For tomorrow, be prepared for the same type of problem - Union Find/Disjoint Set"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<vector<int>> graph(26);\\n        for(int i = 0 ; i < n ; i++){\\n            graph[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            graph[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        string res;\\n\\n        vector<int> marker(26,-1);\\n\\n        function<void(int , vector<int> , int)> dfs = [&](int node , vector<int> visited , int val){\\n            visited[node] = 1;\\n            marker[node] = val;\\n            for(auto &child : graph[node]){\\n                if(visited[child] != 1){\\n                    dfs(child , visited , val);\\n                }\\n            }\\n        };\\n\\n        for(int i = 0 ; i < s1.size(); i++){\\n            vector<int> visited(26,0);\\n            int val = s1[i] - \\'a\\';\\n            if(marker[val] == -1) dfs(val , visited , val);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.size(); i++){\\n            int val = marker[baseStr[i] - \\'a\\']; \\n            if(val == -1){\\n                res += baseStr[i];\\n                continue;\\n            }\\n            int ans = 27;\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(marker[j] == val){\\n                    ans = min(ans , j);\\n                }\\n            }\\n            res += ans + \\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nWhy TLE plese Explain..."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "I decided to make a video explaining my solution to this problem. Let me know if you like the style and I\\'ll make more!\\n\\n[https://youtu.be/bETKbaNl0pk](https://youtu.be/bETKbaNl0pk)"
                    },
                    {
                        "username": "sanjaysekaren",
                        "content": "Tip: \\nAvoid unwanted iterations as possible.\\n\\n\\nEasy approach , Check my below solution (Not best but understandable):\\n\\nRuns less than 100ms.\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3048507/beats-100-less-100ms-easy-understanding-solution-with-explanation-js-ts/"
                    },
                    {
                        "username": "dsk2",
                        "content": "C++ Disjoint Solution can be found here: [Solution Walkthrough](https://medium.com/@kapoordeepjyotsingh29/leetcode-solution-for-lexicographically-smallest-equivalent-string-d8db35961b4c)"
                    }
                ]
            },
            {
                "id": 1757285,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "what"
                    },
                    {
                        "username": "ashok1903",
                        "content": "Passes 84/116 Testcase have to find bug in code\\uD83D\\uDE2A Does any one facing this issue let me know!!!\\uD83E\\uDEE0\\n"
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Was just going through union find concept  yesterday and leetcode wanted to test it.\\n"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "I thought I will hit TLE, but still able to achieve it using HashMap and TreeSet and beats 100% lol.\\n\\n1. Create a graph mapping \\n   - `s1[i]` to `s2[i]` \\n   - `s2[i]` to `s1[i]`\\n2. DFS through all the characters and pass all their equivalents to parent\\n3. Keep track of the visited character as we don\\'t want to revisit them to avoid infinite loop\\n4. If the set has more than one value (size>1), means it is a mapping / equivalent set\\n5. Going through the set, assign each character in the set as map key, and set its value to the set \\n```\\nFor example, {k,r,s}, \\nk=>{k,r,s}, \\nr=>{k,r,s}, \\ns=>{k,r,s}\\n```\\n6. Lastly, loop each character in `baseStr` and get its minimum equivalent from the map we created in step 5. We can always get the first character from the map since we are using a `TreeSet` here and the characters are sorted automatically.\\n\\nPlease upvote if this is helpful :)\\nMy Kotlin [solution ](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049019/kotlin-solution-using-dfs-and-treeset-100/?languageTags=kotlin)\\n"
                    },
                    {
                        "username": "Real-Supreme",
                        "content": "aauaaaaada lol\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "For tomorrow, be prepared for the same type of problem - Union Find/Disjoint Set"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<vector<int>> graph(26);\\n        for(int i = 0 ; i < n ; i++){\\n            graph[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            graph[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        string res;\\n\\n        vector<int> marker(26,-1);\\n\\n        function<void(int , vector<int> , int)> dfs = [&](int node , vector<int> visited , int val){\\n            visited[node] = 1;\\n            marker[node] = val;\\n            for(auto &child : graph[node]){\\n                if(visited[child] != 1){\\n                    dfs(child , visited , val);\\n                }\\n            }\\n        };\\n\\n        for(int i = 0 ; i < s1.size(); i++){\\n            vector<int> visited(26,0);\\n            int val = s1[i] - \\'a\\';\\n            if(marker[val] == -1) dfs(val , visited , val);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.size(); i++){\\n            int val = marker[baseStr[i] - \\'a\\']; \\n            if(val == -1){\\n                res += baseStr[i];\\n                continue;\\n            }\\n            int ans = 27;\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(marker[j] == val){\\n                    ans = min(ans , j);\\n                }\\n            }\\n            res += ans + \\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nWhy TLE plese Explain..."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "I decided to make a video explaining my solution to this problem. Let me know if you like the style and I\\'ll make more!\\n\\n[https://youtu.be/bETKbaNl0pk](https://youtu.be/bETKbaNl0pk)"
                    },
                    {
                        "username": "sanjaysekaren",
                        "content": "Tip: \\nAvoid unwanted iterations as possible.\\n\\n\\nEasy approach , Check my below solution (Not best but understandable):\\n\\nRuns less than 100ms.\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3048507/beats-100-less-100ms-easy-understanding-solution-with-explanation-js-ts/"
                    },
                    {
                        "username": "dsk2",
                        "content": "C++ Disjoint Solution can be found here: [Solution Walkthrough](https://medium.com/@kapoordeepjyotsingh29/leetcode-solution-for-lexicographically-smallest-equivalent-string-d8db35961b4c)"
                    }
                ]
            },
            {
                "id": 1757251,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "what"
                    },
                    {
                        "username": "ashok1903",
                        "content": "Passes 84/116 Testcase have to find bug in code\\uD83D\\uDE2A Does any one facing this issue let me know!!!\\uD83E\\uDEE0\\n"
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Was just going through union find concept  yesterday and leetcode wanted to test it.\\n"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "I thought I will hit TLE, but still able to achieve it using HashMap and TreeSet and beats 100% lol.\\n\\n1. Create a graph mapping \\n   - `s1[i]` to `s2[i]` \\n   - `s2[i]` to `s1[i]`\\n2. DFS through all the characters and pass all their equivalents to parent\\n3. Keep track of the visited character as we don\\'t want to revisit them to avoid infinite loop\\n4. If the set has more than one value (size>1), means it is a mapping / equivalent set\\n5. Going through the set, assign each character in the set as map key, and set its value to the set \\n```\\nFor example, {k,r,s}, \\nk=>{k,r,s}, \\nr=>{k,r,s}, \\ns=>{k,r,s}\\n```\\n6. Lastly, loop each character in `baseStr` and get its minimum equivalent from the map we created in step 5. We can always get the first character from the map since we are using a `TreeSet` here and the characters are sorted automatically.\\n\\nPlease upvote if this is helpful :)\\nMy Kotlin [solution ](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049019/kotlin-solution-using-dfs-and-treeset-100/?languageTags=kotlin)\\n"
                    },
                    {
                        "username": "Real-Supreme",
                        "content": "aauaaaaada lol\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "For tomorrow, be prepared for the same type of problem - Union Find/Disjoint Set"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<vector<int>> graph(26);\\n        for(int i = 0 ; i < n ; i++){\\n            graph[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            graph[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        string res;\\n\\n        vector<int> marker(26,-1);\\n\\n        function<void(int , vector<int> , int)> dfs = [&](int node , vector<int> visited , int val){\\n            visited[node] = 1;\\n            marker[node] = val;\\n            for(auto &child : graph[node]){\\n                if(visited[child] != 1){\\n                    dfs(child , visited , val);\\n                }\\n            }\\n        };\\n\\n        for(int i = 0 ; i < s1.size(); i++){\\n            vector<int> visited(26,0);\\n            int val = s1[i] - \\'a\\';\\n            if(marker[val] == -1) dfs(val , visited , val);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.size(); i++){\\n            int val = marker[baseStr[i] - \\'a\\']; \\n            if(val == -1){\\n                res += baseStr[i];\\n                continue;\\n            }\\n            int ans = 27;\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(marker[j] == val){\\n                    ans = min(ans , j);\\n                }\\n            }\\n            res += ans + \\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nWhy TLE plese Explain..."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "I decided to make a video explaining my solution to this problem. Let me know if you like the style and I\\'ll make more!\\n\\n[https://youtu.be/bETKbaNl0pk](https://youtu.be/bETKbaNl0pk)"
                    },
                    {
                        "username": "sanjaysekaren",
                        "content": "Tip: \\nAvoid unwanted iterations as possible.\\n\\n\\nEasy approach , Check my below solution (Not best but understandable):\\n\\nRuns less than 100ms.\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3048507/beats-100-less-100ms-easy-understanding-solution-with-explanation-js-ts/"
                    },
                    {
                        "username": "dsk2",
                        "content": "C++ Disjoint Solution can be found here: [Solution Walkthrough](https://medium.com/@kapoordeepjyotsingh29/leetcode-solution-for-lexicographically-smallest-equivalent-string-d8db35961b4c)"
                    }
                ]
            },
            {
                "id": 1757194,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "what"
                    },
                    {
                        "username": "ashok1903",
                        "content": "Passes 84/116 Testcase have to find bug in code\\uD83D\\uDE2A Does any one facing this issue let me know!!!\\uD83E\\uDEE0\\n"
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Was just going through union find concept  yesterday and leetcode wanted to test it.\\n"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "I thought I will hit TLE, but still able to achieve it using HashMap and TreeSet and beats 100% lol.\\n\\n1. Create a graph mapping \\n   - `s1[i]` to `s2[i]` \\n   - `s2[i]` to `s1[i]`\\n2. DFS through all the characters and pass all their equivalents to parent\\n3. Keep track of the visited character as we don\\'t want to revisit them to avoid infinite loop\\n4. If the set has more than one value (size>1), means it is a mapping / equivalent set\\n5. Going through the set, assign each character in the set as map key, and set its value to the set \\n```\\nFor example, {k,r,s}, \\nk=>{k,r,s}, \\nr=>{k,r,s}, \\ns=>{k,r,s}\\n```\\n6. Lastly, loop each character in `baseStr` and get its minimum equivalent from the map we created in step 5. We can always get the first character from the map since we are using a `TreeSet` here and the characters are sorted automatically.\\n\\nPlease upvote if this is helpful :)\\nMy Kotlin [solution ](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049019/kotlin-solution-using-dfs-and-treeset-100/?languageTags=kotlin)\\n"
                    },
                    {
                        "username": "Real-Supreme",
                        "content": "aauaaaaada lol\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "For tomorrow, be prepared for the same type of problem - Union Find/Disjoint Set"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<vector<int>> graph(26);\\n        for(int i = 0 ; i < n ; i++){\\n            graph[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            graph[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        string res;\\n\\n        vector<int> marker(26,-1);\\n\\n        function<void(int , vector<int> , int)> dfs = [&](int node , vector<int> visited , int val){\\n            visited[node] = 1;\\n            marker[node] = val;\\n            for(auto &child : graph[node]){\\n                if(visited[child] != 1){\\n                    dfs(child , visited , val);\\n                }\\n            }\\n        };\\n\\n        for(int i = 0 ; i < s1.size(); i++){\\n            vector<int> visited(26,0);\\n            int val = s1[i] - \\'a\\';\\n            if(marker[val] == -1) dfs(val , visited , val);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.size(); i++){\\n            int val = marker[baseStr[i] - \\'a\\']; \\n            if(val == -1){\\n                res += baseStr[i];\\n                continue;\\n            }\\n            int ans = 27;\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(marker[j] == val){\\n                    ans = min(ans , j);\\n                }\\n            }\\n            res += ans + \\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nWhy TLE plese Explain..."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "I decided to make a video explaining my solution to this problem. Let me know if you like the style and I\\'ll make more!\\n\\n[https://youtu.be/bETKbaNl0pk](https://youtu.be/bETKbaNl0pk)"
                    },
                    {
                        "username": "sanjaysekaren",
                        "content": "Tip: \\nAvoid unwanted iterations as possible.\\n\\n\\nEasy approach , Check my below solution (Not best but understandable):\\n\\nRuns less than 100ms.\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3048507/beats-100-less-100ms-easy-understanding-solution-with-explanation-js-ts/"
                    },
                    {
                        "username": "dsk2",
                        "content": "C++ Disjoint Solution can be found here: [Solution Walkthrough](https://medium.com/@kapoordeepjyotsingh29/leetcode-solution-for-lexicographically-smallest-equivalent-string-d8db35961b4c)"
                    }
                ]
            },
            {
                "id": 1757165,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "what"
                    },
                    {
                        "username": "ashok1903",
                        "content": "Passes 84/116 Testcase have to find bug in code\\uD83D\\uDE2A Does any one facing this issue let me know!!!\\uD83E\\uDEE0\\n"
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Was just going through union find concept  yesterday and leetcode wanted to test it.\\n"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "I thought I will hit TLE, but still able to achieve it using HashMap and TreeSet and beats 100% lol.\\n\\n1. Create a graph mapping \\n   - `s1[i]` to `s2[i]` \\n   - `s2[i]` to `s1[i]`\\n2. DFS through all the characters and pass all their equivalents to parent\\n3. Keep track of the visited character as we don\\'t want to revisit them to avoid infinite loop\\n4. If the set has more than one value (size>1), means it is a mapping / equivalent set\\n5. Going through the set, assign each character in the set as map key, and set its value to the set \\n```\\nFor example, {k,r,s}, \\nk=>{k,r,s}, \\nr=>{k,r,s}, \\ns=>{k,r,s}\\n```\\n6. Lastly, loop each character in `baseStr` and get its minimum equivalent from the map we created in step 5. We can always get the first character from the map since we are using a `TreeSet` here and the characters are sorted automatically.\\n\\nPlease upvote if this is helpful :)\\nMy Kotlin [solution ](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049019/kotlin-solution-using-dfs-and-treeset-100/?languageTags=kotlin)\\n"
                    },
                    {
                        "username": "Real-Supreme",
                        "content": "aauaaaaada lol\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "For tomorrow, be prepared for the same type of problem - Union Find/Disjoint Set"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<vector<int>> graph(26);\\n        for(int i = 0 ; i < n ; i++){\\n            graph[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            graph[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        string res;\\n\\n        vector<int> marker(26,-1);\\n\\n        function<void(int , vector<int> , int)> dfs = [&](int node , vector<int> visited , int val){\\n            visited[node] = 1;\\n            marker[node] = val;\\n            for(auto &child : graph[node]){\\n                if(visited[child] != 1){\\n                    dfs(child , visited , val);\\n                }\\n            }\\n        };\\n\\n        for(int i = 0 ; i < s1.size(); i++){\\n            vector<int> visited(26,0);\\n            int val = s1[i] - \\'a\\';\\n            if(marker[val] == -1) dfs(val , visited , val);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.size(); i++){\\n            int val = marker[baseStr[i] - \\'a\\']; \\n            if(val == -1){\\n                res += baseStr[i];\\n                continue;\\n            }\\n            int ans = 27;\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(marker[j] == val){\\n                    ans = min(ans , j);\\n                }\\n            }\\n            res += ans + \\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nWhy TLE plese Explain..."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "I decided to make a video explaining my solution to this problem. Let me know if you like the style and I\\'ll make more!\\n\\n[https://youtu.be/bETKbaNl0pk](https://youtu.be/bETKbaNl0pk)"
                    },
                    {
                        "username": "sanjaysekaren",
                        "content": "Tip: \\nAvoid unwanted iterations as possible.\\n\\n\\nEasy approach , Check my below solution (Not best but understandable):\\n\\nRuns less than 100ms.\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3048507/beats-100-less-100ms-easy-understanding-solution-with-explanation-js-ts/"
                    },
                    {
                        "username": "dsk2",
                        "content": "C++ Disjoint Solution can be found here: [Solution Walkthrough](https://medium.com/@kapoordeepjyotsingh29/leetcode-solution-for-lexicographically-smallest-equivalent-string-d8db35961b4c)"
                    }
                ]
            },
            {
                "id": 1757151,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "what"
                    },
                    {
                        "username": "ashok1903",
                        "content": "Passes 84/116 Testcase have to find bug in code\\uD83D\\uDE2A Does any one facing this issue let me know!!!\\uD83E\\uDEE0\\n"
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Was just going through union find concept  yesterday and leetcode wanted to test it.\\n"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "I thought I will hit TLE, but still able to achieve it using HashMap and TreeSet and beats 100% lol.\\n\\n1. Create a graph mapping \\n   - `s1[i]` to `s2[i]` \\n   - `s2[i]` to `s1[i]`\\n2. DFS through all the characters and pass all their equivalents to parent\\n3. Keep track of the visited character as we don\\'t want to revisit them to avoid infinite loop\\n4. If the set has more than one value (size>1), means it is a mapping / equivalent set\\n5. Going through the set, assign each character in the set as map key, and set its value to the set \\n```\\nFor example, {k,r,s}, \\nk=>{k,r,s}, \\nr=>{k,r,s}, \\ns=>{k,r,s}\\n```\\n6. Lastly, loop each character in `baseStr` and get its minimum equivalent from the map we created in step 5. We can always get the first character from the map since we are using a `TreeSet` here and the characters are sorted automatically.\\n\\nPlease upvote if this is helpful :)\\nMy Kotlin [solution ](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049019/kotlin-solution-using-dfs-and-treeset-100/?languageTags=kotlin)\\n"
                    },
                    {
                        "username": "Real-Supreme",
                        "content": "aauaaaaada lol\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "For tomorrow, be prepared for the same type of problem - Union Find/Disjoint Set"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<vector<int>> graph(26);\\n        for(int i = 0 ; i < n ; i++){\\n            graph[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            graph[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        string res;\\n\\n        vector<int> marker(26,-1);\\n\\n        function<void(int , vector<int> , int)> dfs = [&](int node , vector<int> visited , int val){\\n            visited[node] = 1;\\n            marker[node] = val;\\n            for(auto &child : graph[node]){\\n                if(visited[child] != 1){\\n                    dfs(child , visited , val);\\n                }\\n            }\\n        };\\n\\n        for(int i = 0 ; i < s1.size(); i++){\\n            vector<int> visited(26,0);\\n            int val = s1[i] - \\'a\\';\\n            if(marker[val] == -1) dfs(val , visited , val);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.size(); i++){\\n            int val = marker[baseStr[i] - \\'a\\']; \\n            if(val == -1){\\n                res += baseStr[i];\\n                continue;\\n            }\\n            int ans = 27;\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(marker[j] == val){\\n                    ans = min(ans , j);\\n                }\\n            }\\n            res += ans + \\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nWhy TLE plese Explain..."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "I decided to make a video explaining my solution to this problem. Let me know if you like the style and I\\'ll make more!\\n\\n[https://youtu.be/bETKbaNl0pk](https://youtu.be/bETKbaNl0pk)"
                    },
                    {
                        "username": "sanjaysekaren",
                        "content": "Tip: \\nAvoid unwanted iterations as possible.\\n\\n\\nEasy approach , Check my below solution (Not best but understandable):\\n\\nRuns less than 100ms.\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3048507/beats-100-less-100ms-easy-understanding-solution-with-explanation-js-ts/"
                    },
                    {
                        "username": "dsk2",
                        "content": "C++ Disjoint Solution can be found here: [Solution Walkthrough](https://medium.com/@kapoordeepjyotsingh29/leetcode-solution-for-lexicographically-smallest-equivalent-string-d8db35961b4c)"
                    }
                ]
            },
            {
                "id": 1757131,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "what"
                    },
                    {
                        "username": "ashok1903",
                        "content": "Passes 84/116 Testcase have to find bug in code\\uD83D\\uDE2A Does any one facing this issue let me know!!!\\uD83E\\uDEE0\\n"
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Was just going through union find concept  yesterday and leetcode wanted to test it.\\n"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "I thought I will hit TLE, but still able to achieve it using HashMap and TreeSet and beats 100% lol.\\n\\n1. Create a graph mapping \\n   - `s1[i]` to `s2[i]` \\n   - `s2[i]` to `s1[i]`\\n2. DFS through all the characters and pass all their equivalents to parent\\n3. Keep track of the visited character as we don\\'t want to revisit them to avoid infinite loop\\n4. If the set has more than one value (size>1), means it is a mapping / equivalent set\\n5. Going through the set, assign each character in the set as map key, and set its value to the set \\n```\\nFor example, {k,r,s}, \\nk=>{k,r,s}, \\nr=>{k,r,s}, \\ns=>{k,r,s}\\n```\\n6. Lastly, loop each character in `baseStr` and get its minimum equivalent from the map we created in step 5. We can always get the first character from the map since we are using a `TreeSet` here and the characters are sorted automatically.\\n\\nPlease upvote if this is helpful :)\\nMy Kotlin [solution ](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049019/kotlin-solution-using-dfs-and-treeset-100/?languageTags=kotlin)\\n"
                    },
                    {
                        "username": "Real-Supreme",
                        "content": "aauaaaaada lol\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "For tomorrow, be prepared for the same type of problem - Union Find/Disjoint Set"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        int n = s1.size();\\n        vector<vector<int>> graph(26);\\n        for(int i = 0 ; i < n ; i++){\\n            graph[s1[i] - \\'a\\'].push_back(s2[i] - \\'a\\');\\n            graph[s2[i] - \\'a\\'].push_back(s1[i] - \\'a\\');\\n        }\\n\\n        string res;\\n\\n        vector<int> marker(26,-1);\\n\\n        function<void(int , vector<int> , int)> dfs = [&](int node , vector<int> visited , int val){\\n            visited[node] = 1;\\n            marker[node] = val;\\n            for(auto &child : graph[node]){\\n                if(visited[child] != 1){\\n                    dfs(child , visited , val);\\n                }\\n            }\\n        };\\n\\n        for(int i = 0 ; i < s1.size(); i++){\\n            vector<int> visited(26,0);\\n            int val = s1[i] - \\'a\\';\\n            if(marker[val] == -1) dfs(val , visited , val);\\n        }\\n\\n        for(int i = 0 ; i < baseStr.size(); i++){\\n            int val = marker[baseStr[i] - \\'a\\']; \\n            if(val == -1){\\n                res += baseStr[i];\\n                continue;\\n            }\\n            int ans = 27;\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(marker[j] == val){\\n                    ans = min(ans , j);\\n                }\\n            }\\n            res += ans + \\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nWhy TLE plese Explain..."
                    },
                    {
                        "username": "KTBMedia",
                        "content": "I decided to make a video explaining my solution to this problem. Let me know if you like the style and I\\'ll make more!\\n\\n[https://youtu.be/bETKbaNl0pk](https://youtu.be/bETKbaNl0pk)"
                    },
                    {
                        "username": "sanjaysekaren",
                        "content": "Tip: \\nAvoid unwanted iterations as possible.\\n\\n\\nEasy approach , Check my below solution (Not best but understandable):\\n\\nRuns less than 100ms.\\n\\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3048507/beats-100-less-100ms-easy-understanding-solution-with-explanation-js-ts/"
                    },
                    {
                        "username": "dsk2",
                        "content": "C++ Disjoint Solution can be found here: [Solution Walkthrough](https://medium.com/@kapoordeepjyotsingh29/leetcode-solution-for-lexicographically-smallest-equivalent-string-d8db35961b4c)"
                    }
                ]
            },
            {
                "id": 1757123,
                "content": [
                    {
                        "username": "mayankK135",
                        "content": "ATTENTION!!!!\\nThis isn\\'t a graph problem use UNION FIND (disjoint set) and the problem will became quite simple"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Quite similar to [990. Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/). Good problem."
                    },
                    {
                        "username": "error44",
                        "content": "Did someone solve this one using maps."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Yes i have solved it using a map but it is not a optimised one..I will try to optimize it till then you can see my previous submission.  \n                                                                                    \nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877848569/\n\nEdit : after some optimistation solution \nTime complexity - -> appprox O(nlog(N))\n\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877906625/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "Pretty good Union Find problem.  Hint provided by leetcode says something about graph - but I would recommend doing this problem using the Disjoint Set data structure."
                    },
                    {
                        "username": "kaium_123",
                        "content": "Solve using Disjoint Set Union .  Make connection between s1[i] ans s2[i] . while make a connection , give priority to smallest character(s1[i], s2[i]) . Answer will be baseStr\\'s characters parents character."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Hints:\\n1. Make grouping\\n2. Make lexically smaller char as parent\\n\\nNo faang, no promotion, simple raw explanation here: https://youtu.be/J6NfkPSUecQ"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "finally not a tree"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "still a graph though, so you\\'re not getting away that easily ;)"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Can we solve this question without graph?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Yes by Disjoint set union concpts"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sorry, there are not enough accepted submissions to show data\\n2023-01-14 Golang"
                    },
                    {
                        "username": "sircodesalotOfTheRound",
                        "content": "Seems like I can\\'t turn off auto-completion?"
                    }
                ]
            },
            {
                "id": 1757122,
                "content": [
                    {
                        "username": "mayankK135",
                        "content": "ATTENTION!!!!\\nThis isn\\'t a graph problem use UNION FIND (disjoint set) and the problem will became quite simple"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Quite similar to [990. Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/). Good problem."
                    },
                    {
                        "username": "error44",
                        "content": "Did someone solve this one using maps."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Yes i have solved it using a map but it is not a optimised one..I will try to optimize it till then you can see my previous submission.  \n                                                                                    \nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877848569/\n\nEdit : after some optimistation solution \nTime complexity - -> appprox O(nlog(N))\n\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877906625/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "Pretty good Union Find problem.  Hint provided by leetcode says something about graph - but I would recommend doing this problem using the Disjoint Set data structure."
                    },
                    {
                        "username": "kaium_123",
                        "content": "Solve using Disjoint Set Union .  Make connection between s1[i] ans s2[i] . while make a connection , give priority to smallest character(s1[i], s2[i]) . Answer will be baseStr\\'s characters parents character."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Hints:\\n1. Make grouping\\n2. Make lexically smaller char as parent\\n\\nNo faang, no promotion, simple raw explanation here: https://youtu.be/J6NfkPSUecQ"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "finally not a tree"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "still a graph though, so you\\'re not getting away that easily ;)"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Can we solve this question without graph?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Yes by Disjoint set union concpts"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sorry, there are not enough accepted submissions to show data\\n2023-01-14 Golang"
                    },
                    {
                        "username": "sircodesalotOfTheRound",
                        "content": "Seems like I can\\'t turn off auto-completion?"
                    }
                ]
            },
            {
                "id": 1757120,
                "content": [
                    {
                        "username": "mayankK135",
                        "content": "ATTENTION!!!!\\nThis isn\\'t a graph problem use UNION FIND (disjoint set) and the problem will became quite simple"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Quite similar to [990. Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/). Good problem."
                    },
                    {
                        "username": "error44",
                        "content": "Did someone solve this one using maps."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Yes i have solved it using a map but it is not a optimised one..I will try to optimize it till then you can see my previous submission.  \n                                                                                    \nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877848569/\n\nEdit : after some optimistation solution \nTime complexity - -> appprox O(nlog(N))\n\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877906625/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "Pretty good Union Find problem.  Hint provided by leetcode says something about graph - but I would recommend doing this problem using the Disjoint Set data structure."
                    },
                    {
                        "username": "kaium_123",
                        "content": "Solve using Disjoint Set Union .  Make connection between s1[i] ans s2[i] . while make a connection , give priority to smallest character(s1[i], s2[i]) . Answer will be baseStr\\'s characters parents character."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Hints:\\n1. Make grouping\\n2. Make lexically smaller char as parent\\n\\nNo faang, no promotion, simple raw explanation here: https://youtu.be/J6NfkPSUecQ"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "finally not a tree"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "still a graph though, so you\\'re not getting away that easily ;)"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Can we solve this question without graph?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Yes by Disjoint set union concpts"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sorry, there are not enough accepted submissions to show data\\n2023-01-14 Golang"
                    },
                    {
                        "username": "sircodesalotOfTheRound",
                        "content": "Seems like I can\\'t turn off auto-completion?"
                    }
                ]
            },
            {
                "id": 1757117,
                "content": [
                    {
                        "username": "mayankK135",
                        "content": "ATTENTION!!!!\\nThis isn\\'t a graph problem use UNION FIND (disjoint set) and the problem will became quite simple"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Quite similar to [990. Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/). Good problem."
                    },
                    {
                        "username": "error44",
                        "content": "Did someone solve this one using maps."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Yes i have solved it using a map but it is not a optimised one..I will try to optimize it till then you can see my previous submission.  \n                                                                                    \nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877848569/\n\nEdit : after some optimistation solution \nTime complexity - -> appprox O(nlog(N))\n\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877906625/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "Pretty good Union Find problem.  Hint provided by leetcode says something about graph - but I would recommend doing this problem using the Disjoint Set data structure."
                    },
                    {
                        "username": "kaium_123",
                        "content": "Solve using Disjoint Set Union .  Make connection between s1[i] ans s2[i] . while make a connection , give priority to smallest character(s1[i], s2[i]) . Answer will be baseStr\\'s characters parents character."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Hints:\\n1. Make grouping\\n2. Make lexically smaller char as parent\\n\\nNo faang, no promotion, simple raw explanation here: https://youtu.be/J6NfkPSUecQ"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "finally not a tree"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "still a graph though, so you\\'re not getting away that easily ;)"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Can we solve this question without graph?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Yes by Disjoint set union concpts"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sorry, there are not enough accepted submissions to show data\\n2023-01-14 Golang"
                    },
                    {
                        "username": "sircodesalotOfTheRound",
                        "content": "Seems like I can\\'t turn off auto-completion?"
                    }
                ]
            },
            {
                "id": 1757076,
                "content": [
                    {
                        "username": "mayankK135",
                        "content": "ATTENTION!!!!\\nThis isn\\'t a graph problem use UNION FIND (disjoint set) and the problem will became quite simple"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Quite similar to [990. Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/). Good problem."
                    },
                    {
                        "username": "error44",
                        "content": "Did someone solve this one using maps."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Yes i have solved it using a map but it is not a optimised one..I will try to optimize it till then you can see my previous submission.  \n                                                                                    \nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877848569/\n\nEdit : after some optimistation solution \nTime complexity - -> appprox O(nlog(N))\n\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877906625/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "Pretty good Union Find problem.  Hint provided by leetcode says something about graph - but I would recommend doing this problem using the Disjoint Set data structure."
                    },
                    {
                        "username": "kaium_123",
                        "content": "Solve using Disjoint Set Union .  Make connection between s1[i] ans s2[i] . while make a connection , give priority to smallest character(s1[i], s2[i]) . Answer will be baseStr\\'s characters parents character."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Hints:\\n1. Make grouping\\n2. Make lexically smaller char as parent\\n\\nNo faang, no promotion, simple raw explanation here: https://youtu.be/J6NfkPSUecQ"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "finally not a tree"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "still a graph though, so you\\'re not getting away that easily ;)"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Can we solve this question without graph?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Yes by Disjoint set union concpts"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sorry, there are not enough accepted submissions to show data\\n2023-01-14 Golang"
                    },
                    {
                        "username": "sircodesalotOfTheRound",
                        "content": "Seems like I can\\'t turn off auto-completion?"
                    }
                ]
            },
            {
                "id": 1757067,
                "content": [
                    {
                        "username": "mayankK135",
                        "content": "ATTENTION!!!!\\nThis isn\\'t a graph problem use UNION FIND (disjoint set) and the problem will became quite simple"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Quite similar to [990. Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/). Good problem."
                    },
                    {
                        "username": "error44",
                        "content": "Did someone solve this one using maps."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Yes i have solved it using a map but it is not a optimised one..I will try to optimize it till then you can see my previous submission.  \n                                                                                    \nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877848569/\n\nEdit : after some optimistation solution \nTime complexity - -> appprox O(nlog(N))\n\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877906625/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "Pretty good Union Find problem.  Hint provided by leetcode says something about graph - but I would recommend doing this problem using the Disjoint Set data structure."
                    },
                    {
                        "username": "kaium_123",
                        "content": "Solve using Disjoint Set Union .  Make connection between s1[i] ans s2[i] . while make a connection , give priority to smallest character(s1[i], s2[i]) . Answer will be baseStr\\'s characters parents character."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Hints:\\n1. Make grouping\\n2. Make lexically smaller char as parent\\n\\nNo faang, no promotion, simple raw explanation here: https://youtu.be/J6NfkPSUecQ"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "finally not a tree"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "still a graph though, so you\\'re not getting away that easily ;)"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Can we solve this question without graph?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Yes by Disjoint set union concpts"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sorry, there are not enough accepted submissions to show data\\n2023-01-14 Golang"
                    },
                    {
                        "username": "sircodesalotOfTheRound",
                        "content": "Seems like I can\\'t turn off auto-completion?"
                    }
                ]
            },
            {
                "id": 1757011,
                "content": [
                    {
                        "username": "mayankK135",
                        "content": "ATTENTION!!!!\\nThis isn\\'t a graph problem use UNION FIND (disjoint set) and the problem will became quite simple"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Quite similar to [990. Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/). Good problem."
                    },
                    {
                        "username": "error44",
                        "content": "Did someone solve this one using maps."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Yes i have solved it using a map but it is not a optimised one..I will try to optimize it till then you can see my previous submission.  \n                                                                                    \nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877848569/\n\nEdit : after some optimistation solution \nTime complexity - -> appprox O(nlog(N))\n\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877906625/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "Pretty good Union Find problem.  Hint provided by leetcode says something about graph - but I would recommend doing this problem using the Disjoint Set data structure."
                    },
                    {
                        "username": "kaium_123",
                        "content": "Solve using Disjoint Set Union .  Make connection between s1[i] ans s2[i] . while make a connection , give priority to smallest character(s1[i], s2[i]) . Answer will be baseStr\\'s characters parents character."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Hints:\\n1. Make grouping\\n2. Make lexically smaller char as parent\\n\\nNo faang, no promotion, simple raw explanation here: https://youtu.be/J6NfkPSUecQ"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "finally not a tree"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "still a graph though, so you\\'re not getting away that easily ;)"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Can we solve this question without graph?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Yes by Disjoint set union concpts"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sorry, there are not enough accepted submissions to show data\\n2023-01-14 Golang"
                    },
                    {
                        "username": "sircodesalotOfTheRound",
                        "content": "Seems like I can\\'t turn off auto-completion?"
                    }
                ]
            },
            {
                "id": 1756931,
                "content": [
                    {
                        "username": "mayankK135",
                        "content": "ATTENTION!!!!\\nThis isn\\'t a graph problem use UNION FIND (disjoint set) and the problem will became quite simple"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Quite similar to [990. Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/). Good problem."
                    },
                    {
                        "username": "error44",
                        "content": "Did someone solve this one using maps."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Yes i have solved it using a map but it is not a optimised one..I will try to optimize it till then you can see my previous submission.  \n                                                                                    \nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877848569/\n\nEdit : after some optimistation solution \nTime complexity - -> appprox O(nlog(N))\n\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877906625/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "Pretty good Union Find problem.  Hint provided by leetcode says something about graph - but I would recommend doing this problem using the Disjoint Set data structure."
                    },
                    {
                        "username": "kaium_123",
                        "content": "Solve using Disjoint Set Union .  Make connection between s1[i] ans s2[i] . while make a connection , give priority to smallest character(s1[i], s2[i]) . Answer will be baseStr\\'s characters parents character."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Hints:\\n1. Make grouping\\n2. Make lexically smaller char as parent\\n\\nNo faang, no promotion, simple raw explanation here: https://youtu.be/J6NfkPSUecQ"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "finally not a tree"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "still a graph though, so you\\'re not getting away that easily ;)"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Can we solve this question without graph?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Yes by Disjoint set union concpts"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sorry, there are not enough accepted submissions to show data\\n2023-01-14 Golang"
                    },
                    {
                        "username": "sircodesalotOfTheRound",
                        "content": "Seems like I can\\'t turn off auto-completion?"
                    }
                ]
            },
            {
                "id": 1756910,
                "content": [
                    {
                        "username": "mayankK135",
                        "content": "ATTENTION!!!!\\nThis isn\\'t a graph problem use UNION FIND (disjoint set) and the problem will became quite simple"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Quite similar to [990. Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/). Good problem."
                    },
                    {
                        "username": "error44",
                        "content": "Did someone solve this one using maps."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Yes i have solved it using a map but it is not a optimised one..I will try to optimize it till then you can see my previous submission.  \n                                                                                    \nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877848569/\n\nEdit : after some optimistation solution \nTime complexity - -> appprox O(nlog(N))\n\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877906625/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "Pretty good Union Find problem.  Hint provided by leetcode says something about graph - but I would recommend doing this problem using the Disjoint Set data structure."
                    },
                    {
                        "username": "kaium_123",
                        "content": "Solve using Disjoint Set Union .  Make connection between s1[i] ans s2[i] . while make a connection , give priority to smallest character(s1[i], s2[i]) . Answer will be baseStr\\'s characters parents character."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Hints:\\n1. Make grouping\\n2. Make lexically smaller char as parent\\n\\nNo faang, no promotion, simple raw explanation here: https://youtu.be/J6NfkPSUecQ"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "finally not a tree"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "still a graph though, so you\\'re not getting away that easily ;)"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Can we solve this question without graph?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Yes by Disjoint set union concpts"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sorry, there are not enough accepted submissions to show data\\n2023-01-14 Golang"
                    },
                    {
                        "username": "sircodesalotOfTheRound",
                        "content": "Seems like I can\\'t turn off auto-completion?"
                    }
                ]
            },
            {
                "id": 1756885,
                "content": [
                    {
                        "username": "mayankK135",
                        "content": "ATTENTION!!!!\\nThis isn\\'t a graph problem use UNION FIND (disjoint set) and the problem will became quite simple"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Quite similar to [990. Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/). Good problem."
                    },
                    {
                        "username": "error44",
                        "content": "Did someone solve this one using maps."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Yes i have solved it using a map but it is not a optimised one..I will try to optimize it till then you can see my previous submission.  \n                                                                                    \nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877848569/\n\nEdit : after some optimistation solution \nTime complexity - -> appprox O(nlog(N))\n\nhttps://leetcode.com/problems/lexicographically-smallest-equivalent-string/submissions/877906625/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "Pretty good Union Find problem.  Hint provided by leetcode says something about graph - but I would recommend doing this problem using the Disjoint Set data structure."
                    },
                    {
                        "username": "kaium_123",
                        "content": "Solve using Disjoint Set Union .  Make connection between s1[i] ans s2[i] . while make a connection , give priority to smallest character(s1[i], s2[i]) . Answer will be baseStr\\'s characters parents character."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Hints:\\n1. Make grouping\\n2. Make lexically smaller char as parent\\n\\nNo faang, no promotion, simple raw explanation here: https://youtu.be/J6NfkPSUecQ"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "finally not a tree"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "still a graph though, so you\\'re not getting away that easily ;)"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Can we solve this question without graph?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Yes by Disjoint set union concpts"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sorry, there are not enough accepted submissions to show data\\n2023-01-14 Golang"
                    },
                    {
                        "username": "sircodesalotOfTheRound",
                        "content": "Seems like I can\\'t turn off auto-completion?"
                    }
                ]
            },
            {
                "id": 1756876,
                "content": [
                    {
                        "username": "BlueSharK_14",
                        "content": "Parent find..."
                    },
                    {
                        "username": "TuringJest",
                        "content": "Rephrased description with the curtesy of ChatGPT:\n\nYou are given two strings of the same length, `s1` and `s2`, and a base string, `baseStr`. The characters at every index `s1[i]` and `s2[i]` are considered equivalent, as defined by the following equivalence relation:\n\nReflexivity: A character is equivalent to itself (e.g. `'a' == 'a'`)\nSymmetry: If `'a' == 'b'`, then `'b' == 'a'`\nTransitivity: If `'a' == 'b'` and `'b' == 'c'`, then `'a' == 'c'`\n\nFor example, given the equivalency information from `s1 = \"abc\"` and `s2 = \"cde\"`, `\"acd\"` and `\"aab\"` are equivalent strings of `baseStr = \"eed\"`, with `\"aab\"` being the lexicographically smallest of the two.\n\nReturn the lexicographically smallest equivalent string of `baseStr` by using the equivalency relation given by `s1` and `s2`."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Again a Graph Question....."
                    },
                    {
                        "username": "smbody",
                        "content": "It can be solved without using a graph"
                    },
                    {
                        "username": "KTBMedia",
                        "content": "It looks like they realized the mistake and made this problem free for everyone. Whoops. :P"
                    },
                    {
                        "username": "user3607P",
                        "content": "Finally the question is unlocked for non premium users. Hopefully this is not a sign of things to come in the future."
                    },
                    {
                        "username": "omscode",
                        "content": "Not tree today cool , but graph ugh "
                    },
                    {
                        "username": "heg816",
                        "content": "This month they are grouping topics. They\\'re listed on https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge under \\'What topics will be covered in January\\'s challenge?\\'"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "actually, you can think of it as... a forest (many trees) :D "
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "finally leetcode fixed the issue"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Well, sh*t can happen, and they fixed it in a timely manner. Let's give them credit for that."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Still possible to comment without a premium? :D"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "i cant find error in this code, plz help\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> parent = vector<int>(26);\\n    int findp(int pos){\\n        if(parent[pos]==pos)return pos;\\n        return parent[pos]=findp(parent[pos]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        //\"abc\"  \"dgh\"\\n        for(int i=0;i<s1.size();i++){\\n            int ind1=findp(s1[i]-\\'a\\');\\n            int ind2=findp(s2[i]-\\'a\\');\\n            \\n            if(ind1<ind2){\\n                parent[ind2]=ind1;\\n                \\n            }\\n            else{\\n                parent[ind1]=ind2;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=parent[baseStr[i]-\\'a\\']+\\'a\\';\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Easiest solution in C++\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string A, string B, string S) {\n        \n        // we have possible 26 alphabets\n        int n=26;\n        vector<int> representative(n);\n            \n        for (int i = 0; i < n; i++) {\n            representative[i] = i;\n        }\n        \n        for(int i=0;i<A.length();i++)\n        {\n            combine(representative,A[i]-'a',B[i]-'a');\n        }\n        \n        string str = \"\";\n        \n        for(int i=0;i<S.length();i++)\n        {\n            str += (find(representative,S[i]-'a')+'a');\n        }\n        \n        return str;\n        \n    }\n    int find(vector<int> &representative, int vertex) {\n        if (vertex == representative[vertex]) {\n            return vertex;\n        }\n        \n        return representative[vertex] = find(representative, representative[vertex]);\n    }\n    \n    int combine(vector<int> &representative, int vertex1, int vertex2) {\n        vertex1 = find(representative, vertex1);\n        vertex2 = find(representative, vertex2);\n        \n        if (vertex1 == vertex2) {\n            return 0;\n        } else {\n            \n            if (vertex1 < vertex2) {\n                representative[vertex2] = vertex1;\n            } else {\n                representative[vertex1] = vertex2;\n            }\n            return 1;\n        }\n    }\n    \n};"
                    }
                ]
            },
            {
                "id": 1756850,
                "content": [
                    {
                        "username": "BlueSharK_14",
                        "content": "Parent find..."
                    },
                    {
                        "username": "TuringJest",
                        "content": "Rephrased description with the curtesy of ChatGPT:\n\nYou are given two strings of the same length, `s1` and `s2`, and a base string, `baseStr`. The characters at every index `s1[i]` and `s2[i]` are considered equivalent, as defined by the following equivalence relation:\n\nReflexivity: A character is equivalent to itself (e.g. `'a' == 'a'`)\nSymmetry: If `'a' == 'b'`, then `'b' == 'a'`\nTransitivity: If `'a' == 'b'` and `'b' == 'c'`, then `'a' == 'c'`\n\nFor example, given the equivalency information from `s1 = \"abc\"` and `s2 = \"cde\"`, `\"acd\"` and `\"aab\"` are equivalent strings of `baseStr = \"eed\"`, with `\"aab\"` being the lexicographically smallest of the two.\n\nReturn the lexicographically smallest equivalent string of `baseStr` by using the equivalency relation given by `s1` and `s2`."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Again a Graph Question....."
                    },
                    {
                        "username": "smbody",
                        "content": "It can be solved without using a graph"
                    },
                    {
                        "username": "KTBMedia",
                        "content": "It looks like they realized the mistake and made this problem free for everyone. Whoops. :P"
                    },
                    {
                        "username": "user3607P",
                        "content": "Finally the question is unlocked for non premium users. Hopefully this is not a sign of things to come in the future."
                    },
                    {
                        "username": "omscode",
                        "content": "Not tree today cool , but graph ugh "
                    },
                    {
                        "username": "heg816",
                        "content": "This month they are grouping topics. They\\'re listed on https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge under \\'What topics will be covered in January\\'s challenge?\\'"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "actually, you can think of it as... a forest (many trees) :D "
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "finally leetcode fixed the issue"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Well, sh*t can happen, and they fixed it in a timely manner. Let's give them credit for that."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Still possible to comment without a premium? :D"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "i cant find error in this code, plz help\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> parent = vector<int>(26);\\n    int findp(int pos){\\n        if(parent[pos]==pos)return pos;\\n        return parent[pos]=findp(parent[pos]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        //\"abc\"  \"dgh\"\\n        for(int i=0;i<s1.size();i++){\\n            int ind1=findp(s1[i]-\\'a\\');\\n            int ind2=findp(s2[i]-\\'a\\');\\n            \\n            if(ind1<ind2){\\n                parent[ind2]=ind1;\\n                \\n            }\\n            else{\\n                parent[ind1]=ind2;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=parent[baseStr[i]-\\'a\\']+\\'a\\';\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Easiest solution in C++\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string A, string B, string S) {\n        \n        // we have possible 26 alphabets\n        int n=26;\n        vector<int> representative(n);\n            \n        for (int i = 0; i < n; i++) {\n            representative[i] = i;\n        }\n        \n        for(int i=0;i<A.length();i++)\n        {\n            combine(representative,A[i]-'a',B[i]-'a');\n        }\n        \n        string str = \"\";\n        \n        for(int i=0;i<S.length();i++)\n        {\n            str += (find(representative,S[i]-'a')+'a');\n        }\n        \n        return str;\n        \n    }\n    int find(vector<int> &representative, int vertex) {\n        if (vertex == representative[vertex]) {\n            return vertex;\n        }\n        \n        return representative[vertex] = find(representative, representative[vertex]);\n    }\n    \n    int combine(vector<int> &representative, int vertex1, int vertex2) {\n        vertex1 = find(representative, vertex1);\n        vertex2 = find(representative, vertex2);\n        \n        if (vertex1 == vertex2) {\n            return 0;\n        } else {\n            \n            if (vertex1 < vertex2) {\n                representative[vertex2] = vertex1;\n            } else {\n                representative[vertex1] = vertex2;\n            }\n            return 1;\n        }\n    }\n    \n};"
                    }
                ]
            },
            {
                "id": 1756846,
                "content": [
                    {
                        "username": "BlueSharK_14",
                        "content": "Parent find..."
                    },
                    {
                        "username": "TuringJest",
                        "content": "Rephrased description with the curtesy of ChatGPT:\n\nYou are given two strings of the same length, `s1` and `s2`, and a base string, `baseStr`. The characters at every index `s1[i]` and `s2[i]` are considered equivalent, as defined by the following equivalence relation:\n\nReflexivity: A character is equivalent to itself (e.g. `'a' == 'a'`)\nSymmetry: If `'a' == 'b'`, then `'b' == 'a'`\nTransitivity: If `'a' == 'b'` and `'b' == 'c'`, then `'a' == 'c'`\n\nFor example, given the equivalency information from `s1 = \"abc\"` and `s2 = \"cde\"`, `\"acd\"` and `\"aab\"` are equivalent strings of `baseStr = \"eed\"`, with `\"aab\"` being the lexicographically smallest of the two.\n\nReturn the lexicographically smallest equivalent string of `baseStr` by using the equivalency relation given by `s1` and `s2`."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Again a Graph Question....."
                    },
                    {
                        "username": "smbody",
                        "content": "It can be solved without using a graph"
                    },
                    {
                        "username": "KTBMedia",
                        "content": "It looks like they realized the mistake and made this problem free for everyone. Whoops. :P"
                    },
                    {
                        "username": "user3607P",
                        "content": "Finally the question is unlocked for non premium users. Hopefully this is not a sign of things to come in the future."
                    },
                    {
                        "username": "omscode",
                        "content": "Not tree today cool , but graph ugh "
                    },
                    {
                        "username": "heg816",
                        "content": "This month they are grouping topics. They\\'re listed on https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge under \\'What topics will be covered in January\\'s challenge?\\'"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "actually, you can think of it as... a forest (many trees) :D "
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "finally leetcode fixed the issue"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Well, sh*t can happen, and they fixed it in a timely manner. Let's give them credit for that."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Still possible to comment without a premium? :D"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "i cant find error in this code, plz help\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> parent = vector<int>(26);\\n    int findp(int pos){\\n        if(parent[pos]==pos)return pos;\\n        return parent[pos]=findp(parent[pos]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        //\"abc\"  \"dgh\"\\n        for(int i=0;i<s1.size();i++){\\n            int ind1=findp(s1[i]-\\'a\\');\\n            int ind2=findp(s2[i]-\\'a\\');\\n            \\n            if(ind1<ind2){\\n                parent[ind2]=ind1;\\n                \\n            }\\n            else{\\n                parent[ind1]=ind2;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=parent[baseStr[i]-\\'a\\']+\\'a\\';\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Easiest solution in C++\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string A, string B, string S) {\n        \n        // we have possible 26 alphabets\n        int n=26;\n        vector<int> representative(n);\n            \n        for (int i = 0; i < n; i++) {\n            representative[i] = i;\n        }\n        \n        for(int i=0;i<A.length();i++)\n        {\n            combine(representative,A[i]-'a',B[i]-'a');\n        }\n        \n        string str = \"\";\n        \n        for(int i=0;i<S.length();i++)\n        {\n            str += (find(representative,S[i]-'a')+'a');\n        }\n        \n        return str;\n        \n    }\n    int find(vector<int> &representative, int vertex) {\n        if (vertex == representative[vertex]) {\n            return vertex;\n        }\n        \n        return representative[vertex] = find(representative, representative[vertex]);\n    }\n    \n    int combine(vector<int> &representative, int vertex1, int vertex2) {\n        vertex1 = find(representative, vertex1);\n        vertex2 = find(representative, vertex2);\n        \n        if (vertex1 == vertex2) {\n            return 0;\n        } else {\n            \n            if (vertex1 < vertex2) {\n                representative[vertex2] = vertex1;\n            } else {\n                representative[vertex1] = vertex2;\n            }\n            return 1;\n        }\n    }\n    \n};"
                    }
                ]
            },
            {
                "id": 1756809,
                "content": [
                    {
                        "username": "BlueSharK_14",
                        "content": "Parent find..."
                    },
                    {
                        "username": "TuringJest",
                        "content": "Rephrased description with the curtesy of ChatGPT:\n\nYou are given two strings of the same length, `s1` and `s2`, and a base string, `baseStr`. The characters at every index `s1[i]` and `s2[i]` are considered equivalent, as defined by the following equivalence relation:\n\nReflexivity: A character is equivalent to itself (e.g. `'a' == 'a'`)\nSymmetry: If `'a' == 'b'`, then `'b' == 'a'`\nTransitivity: If `'a' == 'b'` and `'b' == 'c'`, then `'a' == 'c'`\n\nFor example, given the equivalency information from `s1 = \"abc\"` and `s2 = \"cde\"`, `\"acd\"` and `\"aab\"` are equivalent strings of `baseStr = \"eed\"`, with `\"aab\"` being the lexicographically smallest of the two.\n\nReturn the lexicographically smallest equivalent string of `baseStr` by using the equivalency relation given by `s1` and `s2`."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Again a Graph Question....."
                    },
                    {
                        "username": "smbody",
                        "content": "It can be solved without using a graph"
                    },
                    {
                        "username": "KTBMedia",
                        "content": "It looks like they realized the mistake and made this problem free for everyone. Whoops. :P"
                    },
                    {
                        "username": "user3607P",
                        "content": "Finally the question is unlocked for non premium users. Hopefully this is not a sign of things to come in the future."
                    },
                    {
                        "username": "omscode",
                        "content": "Not tree today cool , but graph ugh "
                    },
                    {
                        "username": "heg816",
                        "content": "This month they are grouping topics. They\\'re listed on https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge under \\'What topics will be covered in January\\'s challenge?\\'"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "actually, you can think of it as... a forest (many trees) :D "
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "finally leetcode fixed the issue"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Well, sh*t can happen, and they fixed it in a timely manner. Let's give them credit for that."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Still possible to comment without a premium? :D"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "i cant find error in this code, plz help\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> parent = vector<int>(26);\\n    int findp(int pos){\\n        if(parent[pos]==pos)return pos;\\n        return parent[pos]=findp(parent[pos]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        //\"abc\"  \"dgh\"\\n        for(int i=0;i<s1.size();i++){\\n            int ind1=findp(s1[i]-\\'a\\');\\n            int ind2=findp(s2[i]-\\'a\\');\\n            \\n            if(ind1<ind2){\\n                parent[ind2]=ind1;\\n                \\n            }\\n            else{\\n                parent[ind1]=ind2;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=parent[baseStr[i]-\\'a\\']+\\'a\\';\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Easiest solution in C++\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string A, string B, string S) {\n        \n        // we have possible 26 alphabets\n        int n=26;\n        vector<int> representative(n);\n            \n        for (int i = 0; i < n; i++) {\n            representative[i] = i;\n        }\n        \n        for(int i=0;i<A.length();i++)\n        {\n            combine(representative,A[i]-'a',B[i]-'a');\n        }\n        \n        string str = \"\";\n        \n        for(int i=0;i<S.length();i++)\n        {\n            str += (find(representative,S[i]-'a')+'a');\n        }\n        \n        return str;\n        \n    }\n    int find(vector<int> &representative, int vertex) {\n        if (vertex == representative[vertex]) {\n            return vertex;\n        }\n        \n        return representative[vertex] = find(representative, representative[vertex]);\n    }\n    \n    int combine(vector<int> &representative, int vertex1, int vertex2) {\n        vertex1 = find(representative, vertex1);\n        vertex2 = find(representative, vertex2);\n        \n        if (vertex1 == vertex2) {\n            return 0;\n        } else {\n            \n            if (vertex1 < vertex2) {\n                representative[vertex2] = vertex1;\n            } else {\n                representative[vertex1] = vertex2;\n            }\n            return 1;\n        }\n    }\n    \n};"
                    }
                ]
            },
            {
                "id": 1756802,
                "content": [
                    {
                        "username": "BlueSharK_14",
                        "content": "Parent find..."
                    },
                    {
                        "username": "TuringJest",
                        "content": "Rephrased description with the curtesy of ChatGPT:\n\nYou are given two strings of the same length, `s1` and `s2`, and a base string, `baseStr`. The characters at every index `s1[i]` and `s2[i]` are considered equivalent, as defined by the following equivalence relation:\n\nReflexivity: A character is equivalent to itself (e.g. `'a' == 'a'`)\nSymmetry: If `'a' == 'b'`, then `'b' == 'a'`\nTransitivity: If `'a' == 'b'` and `'b' == 'c'`, then `'a' == 'c'`\n\nFor example, given the equivalency information from `s1 = \"abc\"` and `s2 = \"cde\"`, `\"acd\"` and `\"aab\"` are equivalent strings of `baseStr = \"eed\"`, with `\"aab\"` being the lexicographically smallest of the two.\n\nReturn the lexicographically smallest equivalent string of `baseStr` by using the equivalency relation given by `s1` and `s2`."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Again a Graph Question....."
                    },
                    {
                        "username": "smbody",
                        "content": "It can be solved without using a graph"
                    },
                    {
                        "username": "KTBMedia",
                        "content": "It looks like they realized the mistake and made this problem free for everyone. Whoops. :P"
                    },
                    {
                        "username": "user3607P",
                        "content": "Finally the question is unlocked for non premium users. Hopefully this is not a sign of things to come in the future."
                    },
                    {
                        "username": "omscode",
                        "content": "Not tree today cool , but graph ugh "
                    },
                    {
                        "username": "heg816",
                        "content": "This month they are grouping topics. They\\'re listed on https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge under \\'What topics will be covered in January\\'s challenge?\\'"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "actually, you can think of it as... a forest (many trees) :D "
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "finally leetcode fixed the issue"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Well, sh*t can happen, and they fixed it in a timely manner. Let's give them credit for that."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Still possible to comment without a premium? :D"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "i cant find error in this code, plz help\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> parent = vector<int>(26);\\n    int findp(int pos){\\n        if(parent[pos]==pos)return pos;\\n        return parent[pos]=findp(parent[pos]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        //\"abc\"  \"dgh\"\\n        for(int i=0;i<s1.size();i++){\\n            int ind1=findp(s1[i]-\\'a\\');\\n            int ind2=findp(s2[i]-\\'a\\');\\n            \\n            if(ind1<ind2){\\n                parent[ind2]=ind1;\\n                \\n            }\\n            else{\\n                parent[ind1]=ind2;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=parent[baseStr[i]-\\'a\\']+\\'a\\';\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Easiest solution in C++\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string A, string B, string S) {\n        \n        // we have possible 26 alphabets\n        int n=26;\n        vector<int> representative(n);\n            \n        for (int i = 0; i < n; i++) {\n            representative[i] = i;\n        }\n        \n        for(int i=0;i<A.length();i++)\n        {\n            combine(representative,A[i]-'a',B[i]-'a');\n        }\n        \n        string str = \"\";\n        \n        for(int i=0;i<S.length();i++)\n        {\n            str += (find(representative,S[i]-'a')+'a');\n        }\n        \n        return str;\n        \n    }\n    int find(vector<int> &representative, int vertex) {\n        if (vertex == representative[vertex]) {\n            return vertex;\n        }\n        \n        return representative[vertex] = find(representative, representative[vertex]);\n    }\n    \n    int combine(vector<int> &representative, int vertex1, int vertex2) {\n        vertex1 = find(representative, vertex1);\n        vertex2 = find(representative, vertex2);\n        \n        if (vertex1 == vertex2) {\n            return 0;\n        } else {\n            \n            if (vertex1 < vertex2) {\n                representative[vertex2] = vertex1;\n            } else {\n                representative[vertex1] = vertex2;\n            }\n            return 1;\n        }\n    }\n    \n};"
                    }
                ]
            },
            {
                "id": 1756771,
                "content": [
                    {
                        "username": "BlueSharK_14",
                        "content": "Parent find..."
                    },
                    {
                        "username": "TuringJest",
                        "content": "Rephrased description with the curtesy of ChatGPT:\n\nYou are given two strings of the same length, `s1` and `s2`, and a base string, `baseStr`. The characters at every index `s1[i]` and `s2[i]` are considered equivalent, as defined by the following equivalence relation:\n\nReflexivity: A character is equivalent to itself (e.g. `'a' == 'a'`)\nSymmetry: If `'a' == 'b'`, then `'b' == 'a'`\nTransitivity: If `'a' == 'b'` and `'b' == 'c'`, then `'a' == 'c'`\n\nFor example, given the equivalency information from `s1 = \"abc\"` and `s2 = \"cde\"`, `\"acd\"` and `\"aab\"` are equivalent strings of `baseStr = \"eed\"`, with `\"aab\"` being the lexicographically smallest of the two.\n\nReturn the lexicographically smallest equivalent string of `baseStr` by using the equivalency relation given by `s1` and `s2`."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Again a Graph Question....."
                    },
                    {
                        "username": "smbody",
                        "content": "It can be solved without using a graph"
                    },
                    {
                        "username": "KTBMedia",
                        "content": "It looks like they realized the mistake and made this problem free for everyone. Whoops. :P"
                    },
                    {
                        "username": "user3607P",
                        "content": "Finally the question is unlocked for non premium users. Hopefully this is not a sign of things to come in the future."
                    },
                    {
                        "username": "omscode",
                        "content": "Not tree today cool , but graph ugh "
                    },
                    {
                        "username": "heg816",
                        "content": "This month they are grouping topics. They\\'re listed on https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge under \\'What topics will be covered in January\\'s challenge?\\'"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "actually, you can think of it as... a forest (many trees) :D "
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "finally leetcode fixed the issue"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Well, sh*t can happen, and they fixed it in a timely manner. Let's give them credit for that."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Still possible to comment without a premium? :D"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "i cant find error in this code, plz help\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> parent = vector<int>(26);\\n    int findp(int pos){\\n        if(parent[pos]==pos)return pos;\\n        return parent[pos]=findp(parent[pos]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        //\"abc\"  \"dgh\"\\n        for(int i=0;i<s1.size();i++){\\n            int ind1=findp(s1[i]-\\'a\\');\\n            int ind2=findp(s2[i]-\\'a\\');\\n            \\n            if(ind1<ind2){\\n                parent[ind2]=ind1;\\n                \\n            }\\n            else{\\n                parent[ind1]=ind2;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=parent[baseStr[i]-\\'a\\']+\\'a\\';\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Easiest solution in C++\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string A, string B, string S) {\n        \n        // we have possible 26 alphabets\n        int n=26;\n        vector<int> representative(n);\n            \n        for (int i = 0; i < n; i++) {\n            representative[i] = i;\n        }\n        \n        for(int i=0;i<A.length();i++)\n        {\n            combine(representative,A[i]-'a',B[i]-'a');\n        }\n        \n        string str = \"\";\n        \n        for(int i=0;i<S.length();i++)\n        {\n            str += (find(representative,S[i]-'a')+'a');\n        }\n        \n        return str;\n        \n    }\n    int find(vector<int> &representative, int vertex) {\n        if (vertex == representative[vertex]) {\n            return vertex;\n        }\n        \n        return representative[vertex] = find(representative, representative[vertex]);\n    }\n    \n    int combine(vector<int> &representative, int vertex1, int vertex2) {\n        vertex1 = find(representative, vertex1);\n        vertex2 = find(representative, vertex2);\n        \n        if (vertex1 == vertex2) {\n            return 0;\n        } else {\n            \n            if (vertex1 < vertex2) {\n                representative[vertex2] = vertex1;\n            } else {\n                representative[vertex1] = vertex2;\n            }\n            return 1;\n        }\n    }\n    \n};"
                    }
                ]
            },
            {
                "id": 1756750,
                "content": [
                    {
                        "username": "BlueSharK_14",
                        "content": "Parent find..."
                    },
                    {
                        "username": "TuringJest",
                        "content": "Rephrased description with the curtesy of ChatGPT:\n\nYou are given two strings of the same length, `s1` and `s2`, and a base string, `baseStr`. The characters at every index `s1[i]` and `s2[i]` are considered equivalent, as defined by the following equivalence relation:\n\nReflexivity: A character is equivalent to itself (e.g. `'a' == 'a'`)\nSymmetry: If `'a' == 'b'`, then `'b' == 'a'`\nTransitivity: If `'a' == 'b'` and `'b' == 'c'`, then `'a' == 'c'`\n\nFor example, given the equivalency information from `s1 = \"abc\"` and `s2 = \"cde\"`, `\"acd\"` and `\"aab\"` are equivalent strings of `baseStr = \"eed\"`, with `\"aab\"` being the lexicographically smallest of the two.\n\nReturn the lexicographically smallest equivalent string of `baseStr` by using the equivalency relation given by `s1` and `s2`."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Again a Graph Question....."
                    },
                    {
                        "username": "smbody",
                        "content": "It can be solved without using a graph"
                    },
                    {
                        "username": "KTBMedia",
                        "content": "It looks like they realized the mistake and made this problem free for everyone. Whoops. :P"
                    },
                    {
                        "username": "user3607P",
                        "content": "Finally the question is unlocked for non premium users. Hopefully this is not a sign of things to come in the future."
                    },
                    {
                        "username": "omscode",
                        "content": "Not tree today cool , but graph ugh "
                    },
                    {
                        "username": "heg816",
                        "content": "This month they are grouping topics. They\\'re listed on https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge under \\'What topics will be covered in January\\'s challenge?\\'"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "actually, you can think of it as... a forest (many trees) :D "
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "finally leetcode fixed the issue"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Well, sh*t can happen, and they fixed it in a timely manner. Let's give them credit for that."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Still possible to comment without a premium? :D"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "i cant find error in this code, plz help\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> parent = vector<int>(26);\\n    int findp(int pos){\\n        if(parent[pos]==pos)return pos;\\n        return parent[pos]=findp(parent[pos]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        //\"abc\"  \"dgh\"\\n        for(int i=0;i<s1.size();i++){\\n            int ind1=findp(s1[i]-\\'a\\');\\n            int ind2=findp(s2[i]-\\'a\\');\\n            \\n            if(ind1<ind2){\\n                parent[ind2]=ind1;\\n                \\n            }\\n            else{\\n                parent[ind1]=ind2;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=parent[baseStr[i]-\\'a\\']+\\'a\\';\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Easiest solution in C++\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string A, string B, string S) {\n        \n        // we have possible 26 alphabets\n        int n=26;\n        vector<int> representative(n);\n            \n        for (int i = 0; i < n; i++) {\n            representative[i] = i;\n        }\n        \n        for(int i=0;i<A.length();i++)\n        {\n            combine(representative,A[i]-'a',B[i]-'a');\n        }\n        \n        string str = \"\";\n        \n        for(int i=0;i<S.length();i++)\n        {\n            str += (find(representative,S[i]-'a')+'a');\n        }\n        \n        return str;\n        \n    }\n    int find(vector<int> &representative, int vertex) {\n        if (vertex == representative[vertex]) {\n            return vertex;\n        }\n        \n        return representative[vertex] = find(representative, representative[vertex]);\n    }\n    \n    int combine(vector<int> &representative, int vertex1, int vertex2) {\n        vertex1 = find(representative, vertex1);\n        vertex2 = find(representative, vertex2);\n        \n        if (vertex1 == vertex2) {\n            return 0;\n        } else {\n            \n            if (vertex1 < vertex2) {\n                representative[vertex2] = vertex1;\n            } else {\n                representative[vertex1] = vertex2;\n            }\n            return 1;\n        }\n    }\n    \n};"
                    }
                ]
            },
            {
                "id": 1756624,
                "content": [
                    {
                        "username": "BlueSharK_14",
                        "content": "Parent find..."
                    },
                    {
                        "username": "TuringJest",
                        "content": "Rephrased description with the curtesy of ChatGPT:\n\nYou are given two strings of the same length, `s1` and `s2`, and a base string, `baseStr`. The characters at every index `s1[i]` and `s2[i]` are considered equivalent, as defined by the following equivalence relation:\n\nReflexivity: A character is equivalent to itself (e.g. `'a' == 'a'`)\nSymmetry: If `'a' == 'b'`, then `'b' == 'a'`\nTransitivity: If `'a' == 'b'` and `'b' == 'c'`, then `'a' == 'c'`\n\nFor example, given the equivalency information from `s1 = \"abc\"` and `s2 = \"cde\"`, `\"acd\"` and `\"aab\"` are equivalent strings of `baseStr = \"eed\"`, with `\"aab\"` being the lexicographically smallest of the two.\n\nReturn the lexicographically smallest equivalent string of `baseStr` by using the equivalency relation given by `s1` and `s2`."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Again a Graph Question....."
                    },
                    {
                        "username": "smbody",
                        "content": "It can be solved without using a graph"
                    },
                    {
                        "username": "KTBMedia",
                        "content": "It looks like they realized the mistake and made this problem free for everyone. Whoops. :P"
                    },
                    {
                        "username": "user3607P",
                        "content": "Finally the question is unlocked for non premium users. Hopefully this is not a sign of things to come in the future."
                    },
                    {
                        "username": "omscode",
                        "content": "Not tree today cool , but graph ugh "
                    },
                    {
                        "username": "heg816",
                        "content": "This month they are grouping topics. They\\'re listed on https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge under \\'What topics will be covered in January\\'s challenge?\\'"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "actually, you can think of it as... a forest (many trees) :D "
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "finally leetcode fixed the issue"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Well, sh*t can happen, and they fixed it in a timely manner. Let's give them credit for that."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Still possible to comment without a premium? :D"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "i cant find error in this code, plz help\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> parent = vector<int>(26);\\n    int findp(int pos){\\n        if(parent[pos]==pos)return pos;\\n        return parent[pos]=findp(parent[pos]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        //\"abc\"  \"dgh\"\\n        for(int i=0;i<s1.size();i++){\\n            int ind1=findp(s1[i]-\\'a\\');\\n            int ind2=findp(s2[i]-\\'a\\');\\n            \\n            if(ind1<ind2){\\n                parent[ind2]=ind1;\\n                \\n            }\\n            else{\\n                parent[ind1]=ind2;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=parent[baseStr[i]-\\'a\\']+\\'a\\';\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Easiest solution in C++\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string A, string B, string S) {\n        \n        // we have possible 26 alphabets\n        int n=26;\n        vector<int> representative(n);\n            \n        for (int i = 0; i < n; i++) {\n            representative[i] = i;\n        }\n        \n        for(int i=0;i<A.length();i++)\n        {\n            combine(representative,A[i]-'a',B[i]-'a');\n        }\n        \n        string str = \"\";\n        \n        for(int i=0;i<S.length();i++)\n        {\n            str += (find(representative,S[i]-'a')+'a');\n        }\n        \n        return str;\n        \n    }\n    int find(vector<int> &representative, int vertex) {\n        if (vertex == representative[vertex]) {\n            return vertex;\n        }\n        \n        return representative[vertex] = find(representative, representative[vertex]);\n    }\n    \n    int combine(vector<int> &representative, int vertex1, int vertex2) {\n        vertex1 = find(representative, vertex1);\n        vertex2 = find(representative, vertex2);\n        \n        if (vertex1 == vertex2) {\n            return 0;\n        } else {\n            \n            if (vertex1 < vertex2) {\n                representative[vertex2] = vertex1;\n            } else {\n                representative[vertex1] = vertex2;\n            }\n            return 1;\n        }\n    }\n    \n};"
                    }
                ]
            },
            {
                "id": 1757706,
                "content": [
                    {
                        "username": "BlueSharK_14",
                        "content": "Parent find..."
                    },
                    {
                        "username": "TuringJest",
                        "content": "Rephrased description with the curtesy of ChatGPT:\n\nYou are given two strings of the same length, `s1` and `s2`, and a base string, `baseStr`. The characters at every index `s1[i]` and `s2[i]` are considered equivalent, as defined by the following equivalence relation:\n\nReflexivity: A character is equivalent to itself (e.g. `'a' == 'a'`)\nSymmetry: If `'a' == 'b'`, then `'b' == 'a'`\nTransitivity: If `'a' == 'b'` and `'b' == 'c'`, then `'a' == 'c'`\n\nFor example, given the equivalency information from `s1 = \"abc\"` and `s2 = \"cde\"`, `\"acd\"` and `\"aab\"` are equivalent strings of `baseStr = \"eed\"`, with `\"aab\"` being the lexicographically smallest of the two.\n\nReturn the lexicographically smallest equivalent string of `baseStr` by using the equivalency relation given by `s1` and `s2`."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Again a Graph Question....."
                    },
                    {
                        "username": "smbody",
                        "content": "It can be solved without using a graph"
                    },
                    {
                        "username": "KTBMedia",
                        "content": "It looks like they realized the mistake and made this problem free for everyone. Whoops. :P"
                    },
                    {
                        "username": "user3607P",
                        "content": "Finally the question is unlocked for non premium users. Hopefully this is not a sign of things to come in the future."
                    },
                    {
                        "username": "omscode",
                        "content": "Not tree today cool , but graph ugh "
                    },
                    {
                        "username": "heg816",
                        "content": "This month they are grouping topics. They\\'re listed on https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge under \\'What topics will be covered in January\\'s challenge?\\'"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "actually, you can think of it as... a forest (many trees) :D "
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "finally leetcode fixed the issue"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Well, sh*t can happen, and they fixed it in a timely manner. Let's give them credit for that."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Still possible to comment without a premium? :D"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "i cant find error in this code, plz help\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> parent = vector<int>(26);\\n    int findp(int pos){\\n        if(parent[pos]==pos)return pos;\\n        return parent[pos]=findp(parent[pos]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        //\"abc\"  \"dgh\"\\n        for(int i=0;i<s1.size();i++){\\n            int ind1=findp(s1[i]-\\'a\\');\\n            int ind2=findp(s2[i]-\\'a\\');\\n            \\n            if(ind1<ind2){\\n                parent[ind2]=ind1;\\n                \\n            }\\n            else{\\n                parent[ind1]=ind2;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=parent[baseStr[i]-\\'a\\']+\\'a\\';\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Easiest solution in C++\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string A, string B, string S) {\n        \n        // we have possible 26 alphabets\n        int n=26;\n        vector<int> representative(n);\n            \n        for (int i = 0; i < n; i++) {\n            representative[i] = i;\n        }\n        \n        for(int i=0;i<A.length();i++)\n        {\n            combine(representative,A[i]-'a',B[i]-'a');\n        }\n        \n        string str = \"\";\n        \n        for(int i=0;i<S.length();i++)\n        {\n            str += (find(representative,S[i]-'a')+'a');\n        }\n        \n        return str;\n        \n    }\n    int find(vector<int> &representative, int vertex) {\n        if (vertex == representative[vertex]) {\n            return vertex;\n        }\n        \n        return representative[vertex] = find(representative, representative[vertex]);\n    }\n    \n    int combine(vector<int> &representative, int vertex1, int vertex2) {\n        vertex1 = find(representative, vertex1);\n        vertex2 = find(representative, vertex2);\n        \n        if (vertex1 == vertex2) {\n            return 0;\n        } else {\n            \n            if (vertex1 < vertex2) {\n                representative[vertex2] = vertex1;\n            } else {\n                representative[vertex1] = vertex2;\n            }\n            return 1;\n        }\n    }\n    \n};"
                    }
                ]
            },
            {
                "id": 1757262,
                "content": [
                    {
                        "username": "BlueSharK_14",
                        "content": "Parent find..."
                    },
                    {
                        "username": "TuringJest",
                        "content": "Rephrased description with the curtesy of ChatGPT:\n\nYou are given two strings of the same length, `s1` and `s2`, and a base string, `baseStr`. The characters at every index `s1[i]` and `s2[i]` are considered equivalent, as defined by the following equivalence relation:\n\nReflexivity: A character is equivalent to itself (e.g. `'a' == 'a'`)\nSymmetry: If `'a' == 'b'`, then `'b' == 'a'`\nTransitivity: If `'a' == 'b'` and `'b' == 'c'`, then `'a' == 'c'`\n\nFor example, given the equivalency information from `s1 = \"abc\"` and `s2 = \"cde\"`, `\"acd\"` and `\"aab\"` are equivalent strings of `baseStr = \"eed\"`, with `\"aab\"` being the lexicographically smallest of the two.\n\nReturn the lexicographically smallest equivalent string of `baseStr` by using the equivalency relation given by `s1` and `s2`."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Again a Graph Question....."
                    },
                    {
                        "username": "smbody",
                        "content": "It can be solved without using a graph"
                    },
                    {
                        "username": "KTBMedia",
                        "content": "It looks like they realized the mistake and made this problem free for everyone. Whoops. :P"
                    },
                    {
                        "username": "user3607P",
                        "content": "Finally the question is unlocked for non premium users. Hopefully this is not a sign of things to come in the future."
                    },
                    {
                        "username": "omscode",
                        "content": "Not tree today cool , but graph ugh "
                    },
                    {
                        "username": "heg816",
                        "content": "This month they are grouping topics. They\\'re listed on https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge under \\'What topics will be covered in January\\'s challenge?\\'"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "actually, you can think of it as... a forest (many trees) :D "
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "finally leetcode fixed the issue"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Well, sh*t can happen, and they fixed it in a timely manner. Let's give them credit for that."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Still possible to comment without a premium? :D"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "i cant find error in this code, plz help\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> parent = vector<int>(26);\\n    int findp(int pos){\\n        if(parent[pos]==pos)return pos;\\n        return parent[pos]=findp(parent[pos]);\\n    }\\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\\n        \\n        for(int i=0;i<26;i++){\\n            parent[i]=i;\\n        }\\n        //\"abc\"  \"dgh\"\\n        for(int i=0;i<s1.size();i++){\\n            int ind1=findp(s1[i]-\\'a\\');\\n            int ind2=findp(s2[i]-\\'a\\');\\n            \\n            if(ind1<ind2){\\n                parent[ind2]=ind1;\\n                \\n            }\\n            else{\\n                parent[ind1]=ind2;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<baseStr.size();i++){\\n            ans+=parent[baseStr[i]-\\'a\\']+\\'a\\';\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Easiest solution in C++\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string A, string B, string S) {\n        \n        // we have possible 26 alphabets\n        int n=26;\n        vector<int> representative(n);\n            \n        for (int i = 0; i < n; i++) {\n            representative[i] = i;\n        }\n        \n        for(int i=0;i<A.length();i++)\n        {\n            combine(representative,A[i]-'a',B[i]-'a');\n        }\n        \n        string str = \"\";\n        \n        for(int i=0;i<S.length();i++)\n        {\n            str += (find(representative,S[i]-'a')+'a');\n        }\n        \n        return str;\n        \n    }\n    int find(vector<int> &representative, int vertex) {\n        if (vertex == representative[vertex]) {\n            return vertex;\n        }\n        \n        return representative[vertex] = find(representative, representative[vertex]);\n    }\n    \n    int combine(vector<int> &representative, int vertex1, int vertex2) {\n        vertex1 = find(representative, vertex1);\n        vertex2 = find(representative, vertex2);\n        \n        if (vertex1 == vertex2) {\n            return 0;\n        } else {\n            \n            if (vertex1 < vertex2) {\n                representative[vertex2] = vertex1;\n            } else {\n                representative[vertex1] = vertex2;\n            }\n            return 1;\n        }\n    }\n    \n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Detect Cycles in 2D Grid",
        "question_content": "<p>Given a 2D array of characters <code>grid</code> of size <code>m x n</code>, you need to find if there exists any cycle consisting of the <strong>same value</strong> in <code>grid</code>.</p>\n\n<p>A cycle is a path of <strong>length 4 or more</strong> in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the <strong>same value</strong> of the current cell.</p>\n\n<p>Also, you cannot move to the cell that you visited in your last move. For example, the cycle <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code> is invalid because from <code>(1, 2)</code> we visited <code>(1, 1)</code> which was the last visited cell.</p>\n\n<p>Return <code>true</code> if any cycle of the same value exists in <code>grid</code>, otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/15/1.png\" style=\"width: 231px; height: 152px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]]\n<strong>Output:</strong> true\n<strong>Explanation: </strong>There are two valid cycles shown in different colors in the image below:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/15/11.png\" style=\"width: 225px; height: 163px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/15/22.png\" style=\"width: 236px; height: 154px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;d&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;c&quot;],[&quot;f&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]]\n<strong>Output:</strong> true\n<strong>Explanation: </strong>There is only one valid cycle highlighted in the image below:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/15/2.png\" style=\"width: 229px; height: 157px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/15/3.png\" style=\"width: 183px; height: 120px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;z&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;]]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>grid</code> consists only of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 805677,
                "title": "dfs-simple-explanation",
                "content": "At each point (i, j) in grid, do following:\\n* Start DFS from (i, j).\\n* Don\\'t visit the last visited point as stated in question.\\n* Only visit a point if it has same character as starting position\\n* If you still reach a visited point again, there is a cycle.\\n\\n```\\nclass Solution {\\n    int[] DIR_X = {1, -1, 0, 0};\\n    int[] DIR_Y = {0, 0, 1, -1};\\n\\t\\n    private boolean dfs(int curX, int curY, int lastX, int lastY, int n, int m, boolean[][] vis, char[][] grid, char startChar) {\\n        vis[curX][curY] = true;\\n        boolean hasCycle = false;\\n        // Visit all directions\\n        for (int i = 0; i < 4; ++i) {\\n            int newX = curX + DIR_X[i];\\n            int newY = curY + DIR_Y[i];\\n            // Valid point?\\n            if (newX >= 0 && newX < n && newY >= 0 && newY < m) {\\n                // Don\\'t visit last visited point\\n                if (!(newX == lastX && newY == lastY)) {\\n                    // Only visit nodes that equal start character\\n                    if (grid[newX][newY] == startChar) {\\n                        if (vis[newX][newY]) {\\n\\t\\t\\t\\t\\t\\t    // Still visited? There is a cycle.\\n                            return true;\\n                        } else {\\n                            hasCycle |= dfs(newX, newY, curX, curY, n, m, vis, grid, startChar);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return hasCycle;\\n    }\\n\\t\\n    public boolean containsCycle(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        boolean[][] vis = new boolean[n][m];\\n        boolean hasCycle = false;\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = 0; j < grid[i].length; ++j) {\\n                if (!vis[i][j]) {\\n                    hasCycle |= dfs(i, j, -1, -1, n, m, vis, grid, grid[i][j]);\\n                }\\n            }\\n        }\\n        return hasCycle;\\n    }\\n}\\n```\\nComplexity: ```O(n*m)```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] DIR_X = {1, -1, 0, 0};\\n    int[] DIR_Y = {0, 0, 1, -1};\\n\\t\\n    private boolean dfs(int curX, int curY, int lastX, int lastY, int n, int m, boolean[][] vis, char[][] grid, char startChar) {\\n        vis[curX][curY] = true;\\n        boolean hasCycle = false;\\n        // Visit all directions\\n        for (int i = 0; i < 4; ++i) {\\n            int newX = curX + DIR_X[i];\\n            int newY = curY + DIR_Y[i];\\n            // Valid point?\\n            if (newX >= 0 && newX < n && newY >= 0 && newY < m) {\\n                // Don\\'t visit last visited point\\n                if (!(newX == lastX && newY == lastY)) {\\n                    // Only visit nodes that equal start character\\n                    if (grid[newX][newY] == startChar) {\\n                        if (vis[newX][newY]) {\\n\\t\\t\\t\\t\\t\\t    // Still visited? There is a cycle.\\n                            return true;\\n                        } else {\\n                            hasCycle |= dfs(newX, newY, curX, curY, n, m, vis, grid, startChar);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return hasCycle;\\n    }\\n\\t\\n    public boolean containsCycle(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        boolean[][] vis = new boolean[n][m];\\n        boolean hasCycle = false;\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = 0; j < grid[i].length; ++j) {\\n                if (!vis[i][j]) {\\n                    hasCycle |= dfs(i, j, -1, -1, n, m, vis, grid, grid[i][j]);\\n                }\\n            }\\n        }\\n        return hasCycle;\\n    }\\n}\\n```\n```O(n*m)```",
                "codeTag": "Java"
            },
            {
                "id": 805673,
                "title": "c-bfs",
                "content": "**Intuition**\\nWe have a cycle if we arrive at the same cell from multiple directions during BFS.\\n\\nFor simplicity, I am marking a cell as \\'visited\\' by subtracting 26 from it. If needed, we can restore the grid to its prestine state in the end.\\n\\n```cpp\\nvector<int> d = {1, 0, -1, 0, 1};\\nbool containsCycle(vector<vector<char>>& g) {\\n    for (int i = 0; i < g.size(); ++i)\\n        for (int j = 0; j < g[i].size(); ++j) {\\n            if (g[i][j] >= \\'a\\') {\\n                char val = g[i][j];\\n                vector<pair<int, int>> q = {{i, j}};\\n                while (!q.empty()) {\\n                    vector<pair<int, int>> q1;\\n                    for (auto [x, y] : q) {\\n                        if (g[x][y] < \\'a\\')\\n                            return true;\\n                        g[x][y] -= 26;\\n                        for (auto k = 0; k < 4; ++k) {\\n                            int dx = x + d[k], dy = y + d[k + 1];\\n                            if (dx >= 0 && dy >= 0 && dx < g.size() && dy < g[dx].size() && g[dx][dy] == val)\\n                                q1.push_back({dx, dy});\\n                        }\\n                    }\\n                    swap(q, q1);\\n                }\\n            }\\n        }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> d = {1, 0, -1, 0, 1};\\nbool containsCycle(vector<vector<char>>& g) {\\n    for (int i = 0; i < g.size(); ++i)\\n        for (int j = 0; j < g[i].size(); ++j) {\\n            if (g[i][j] >= \\'a\\') {\\n                char val = g[i][j];\\n                vector<pair<int, int>> q = {{i, j}};\\n                while (!q.empty()) {\\n                    vector<pair<int, int>> q1;\\n                    for (auto [x, y] : q) {\\n                        if (g[x][y] < \\'a\\')\\n                            return true;\\n                        g[x][y] -= 26;\\n                        for (auto k = 0; k < 4; ++k) {\\n                            int dx = x + d[k], dy = y + d[k + 1];\\n                            if (dx >= 0 && dy >= 0 && dx < g.size() && dy < g[dx].size() && g[dx][dy] == val)\\n                                q1.push_back({dx, dy});\\n                        }\\n                    }\\n                    swap(q, q1);\\n                }\\n            }\\n        }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 805742,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\n    vector<int> dir = { 0, 1, 0, -1, 0 }; \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+dir[d];\\n            int b = j+dir[d+1];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<int> dir = { 0, 1, 0, -1, 0 }; \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+dir[d];\\n            int b = j+dir[d+1];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 806236,
                "title": "python-simple-dfs",
                "content": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        def dfs(node, parent):\\n            if node in visited: return True\\n            visited.add(node)\\n            nx,ny = node\\n            childs = [(cx,cy) for cx,cy in [[nx+1,ny],[nx-1, ny],[nx,ny+1],[nx,ny-1]] \\n                      if 0 <= cx < m and 0 <= cy < n \\n                      and grid[cx][cy] == grid[nx][ny] and (cx,cy) != parent]\\n            for x in childs:\\n                if dfs(x, node): return True \\n            return False  \\n    \\n        m, n = len(grid), len(grid[0])\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if (i,j) in visited: continue \\n                if dfs((i,j), None): return True\\n        return False \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        def dfs(node, parent):\\n            if node in visited: return True\\n            visited.add(node)\\n            nx,ny = node\\n            childs = [(cx,cy) for cx,cy in [[nx+1,ny],[nx-1, ny],[nx,ny+1],[nx,ny-1]] \\n                      if 0 <= cx < m and 0 <= cy < n \\n                      and grid[cx][cy] == grid[nx][ny] and (cx,cy) != parent]\\n            for x in childs:\\n                if dfs(x, node): return True \\n            return False  \\n    \\n        m, n = len(grid), len(grid[0])\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if (i,j) in visited: continue \\n                if dfs((i,j), None): return True\\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 824523,
                "title": "java-backtracking-explanation",
                "content": "Basically, when you backtrack, you\\'ll find that for any ```curr + bot + right``` that match characters:\\n\\nIf there is a cycle and you checked ```bot``` first, you\\'ll have visited the ```right```. \\nSince you backtracked, you\\'ll have recovered the character. Now when you come back and check ```right``` (because you checked ```bot``` before), it will be marked as visited ONLY if you had a cycle.\\n\\nAnd vice-versa for ```right``` before ```bot```.\\n\\n```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        boolean[][] seen = new boolean[grid.length][grid[0].length];\\n            \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (!seen[i][j] && search(grid, grid[i][j], i, j, seen)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean search(char[][] grid, char target, int i, int j, boolean[][] seen) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != target) {\\n            return false;\\n        }\\n        \\n        if (seen[i][j]) {\\n            return true;\\n        }\\n        \\n        seen[i][j] = true;\\n        grid[i][j] = \\'#\\';\\n        \\n        boolean found =  search(grid, target, i + 1, j, seen)\\n                    ||  search(grid, target, i - 1, j, seen)\\n                    ||  search(grid, target, i, j - 1, seen)\\n                    ||  search(grid, target, i, j + 1, seen);\\n\\n        grid[i][j] = target;\\n        \\n        return found;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```curr + bot + right```\n```bot```\n```right```\n```right```\n```bot```\n```right```\n```bot```\n```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        boolean[][] seen = new boolean[grid.length][grid[0].length];\\n            \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (!seen[i][j] && search(grid, grid[i][j], i, j, seen)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean search(char[][] grid, char target, int i, int j, boolean[][] seen) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != target) {\\n            return false;\\n        }\\n        \\n        if (seen[i][j]) {\\n            return true;\\n        }\\n        \\n        seen[i][j] = true;\\n        grid[i][j] = \\'#\\';\\n        \\n        boolean found =  search(grid, target, i + 1, j, seen)\\n                    ||  search(grid, target, i - 1, j, seen)\\n                    ||  search(grid, target, i, j - 1, seen)\\n                    ||  search(grid, target, i, j + 1, seen);\\n\\n        grid[i][j] = target;\\n        \\n        return found;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805691,
                "title": "clean-python-3-union-and-find",
                "content": "Once we found a cell is equal to its up and left cell, check their parents.\\nIf parents of up and left cells are in the same union, it means there must be a cycle.\\nTime: `O(MN)`\\nBecause we do path compression on `find` and union by rank on `union`, these two functions\\' time complexity are both almost O(1)\\nSpace: `O(MN)`\\n\\n```\\nimport collections\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        def find(pos):\\n            if parents[pos] != pos:\\n                parents[pos] = find(parents[pos])\\n            return parents[pos]\\n\\n        def union(pos1, pos2):\\n            parent1, parent2 = find(pos1), find(pos2)\\n            if parent1 != parent2:\\n                if ranks[parent2] > ranks[parent1]:\\n                    parents[parent1] = parent2\\n                else:\\n                    parents[parent2] = parent1\\n                    if ranks[parent1] == ranks[parent2]:\\n                        ranks[parent1] += 1\\n\\n        rows, cols = len(grid), len(grid[0])\\n        parents = {(i, j): (i, j) for i in range(rows) for j in range(cols)}\\n        ranks = collections.Counter()\\n        for i, row in enumerate(grid):\\n            for j, letter in enumerate(row):\\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == letter and find((i-1, j)) == find((i, j-1)):\\n                    return True\\n                for r, c in (i - 1, j), (i, j - 1):\\n                    if 0 <= r < rows and 0 <= c < cols and grid[r][c] == letter:\\n                        union((i, j), (r, c))\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        def find(pos):\\n            if parents[pos] != pos:\\n                parents[pos] = find(parents[pos])\\n            return parents[pos]\\n\\n        def union(pos1, pos2):\\n            parent1, parent2 = find(pos1), find(pos2)\\n            if parent1 != parent2:\\n                if ranks[parent2] > ranks[parent1]:\\n                    parents[parent1] = parent2\\n                else:\\n                    parents[parent2] = parent1\\n                    if ranks[parent1] == ranks[parent2]:\\n                        ranks[parent1] += 1\\n\\n        rows, cols = len(grid), len(grid[0])\\n        parents = {(i, j): (i, j) for i in range(rows) for j in range(cols)}\\n        ranks = collections.Counter()\\n        for i, row in enumerate(grid):\\n            for j, letter in enumerate(row):\\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == letter and find((i-1, j)) == find((i, j-1)):\\n                    return True\\n                for r, c in (i - 1, j), (i, j - 1):\\n                    if 0 <= r < rows and 0 <= c < cols and grid[r][c] == letter:\\n                        union((i, j), (r, c))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812038,
                "title": "java-simple-bfs",
                "content": "has circle iff:\\nmet visited points, and point is different than the last point;\\n\\nsay, point a, b, c :\\nit has circle iff \"a connect b, b connect c, c  != a\";\\nNote that, in a new BFS you will never meet a point from another finished BFS.\\n\\nBFS is iterative other than recursive, offerring higher readability and maintenability, which is alwats preferable to DFS.\\n\\n```\\nclass Solution {\\n    int m, n;\\n    boolean[][] vs;\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public boolean containsCycle(char[][] g) {\\n        m = g.length; n = g[0].length; vs = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!vs[i][j] && bfs(g, i, j, -1, -1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean bfs(char[][] g, int i, int j, int x, int y) {  // point curr [i, j], point prev [x, y];\\n        char c = g[i][j];\\n        Queue<int[]> q = new LinkedList<>();\\n        vs[i][j] = true;\\n        q.offer(new int[]{i, j, x, y});\\n        while (!q.isEmpty()) {\\n            for (int k = 0, l = q.size(); k < l; k++) {\\n                int curr[] = q.poll();\\n                for (int[] d : dir) {\\n                    int row = curr[0] + d[0], col = curr[1] + d[1];\\n                    if (row < 0 || row >= m || col < 0 || col >= n || g[row][col] != c) continue;\\n                    if (row == curr[2] && col == curr[3]) continue;  // a == c\\n                    if (vs[row][col]) return true;\\n                    q.offer(new int[]{row, col, curr[0], curr[1]});\\n                    vs[row][col] = true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    boolean[][] vs;\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public boolean containsCycle(char[][] g) {\\n        m = g.length; n = g[0].length; vs = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!vs[i][j] && bfs(g, i, j, -1, -1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean bfs(char[][] g, int i, int j, int x, int y) {  // point curr [i, j], point prev [x, y];\\n        char c = g[i][j];\\n        Queue<int[]> q = new LinkedList<>();\\n        vs[i][j] = true;\\n        q.offer(new int[]{i, j, x, y});\\n        while (!q.isEmpty()) {\\n            for (int k = 0, l = q.size(); k < l; k++) {\\n                int curr[] = q.poll();\\n                for (int[] d : dir) {\\n                    int row = curr[0] + d[0], col = curr[1] + d[1];\\n                    if (row < 0 || row >= m || col < 0 || col >= n || g[row][col] != c) continue;\\n                    if (row == curr[2] && col == curr[3]) continue;  // a == c\\n                    if (vs[row][col]) return true;\\n                    q.offer(new int[]{row, col, curr[0], curr[1]});\\n                    vs[row][col] = true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814850,
                "title": "java-simple-dfs-solution-97-runtime",
                "content": "The logic here is to let recursion do its work, we maintain a visited array of integers and if during dfs you find an integer where the difference in count between `visited[i][j]` and `visited[previ][prevj]` is greater or equal to 3 of which `grid[i][j]` is of same `character`, there exists a loop.\\nThe `previ` and `prevj` are the previous index of the recursion loop.\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    public boolean dfs(char[][] grid, int i,int j,int[][] visited, int previ,int prevj, char c){\\n        \\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]!=c)\\n            return false;\\n       \\n        if(visited[i][j]-visited[previ][prevj]>=3)\\n            return true;\\n\\n        if(visited[i][j]!=0)\\n            return false;\\n        \\n        visited[i][j]=count++;\\n        \\n        return dfs(grid,i+1,j,visited,i,j,c) || dfs(grid,i-1,j,visited,i,j,c) || dfs(grid,i,j+1,visited,i,j,c) || dfs(grid,i,j-1,visited,i,j,c);\\n    }\\n    public boolean containsCycle(char[][] grid) {\\n        \\n        int n = grid.length, m = grid[0].length;\\n        int[][]visited = new int[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j]==0 && dfs(grid,i,j,visited,i,j,grid[i][j]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public boolean dfs(char[][] grid, int i,int j,int[][] visited, int previ,int prevj, char c){\\n        \\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]!=c)\\n            return false;\\n       \\n        if(visited[i][j]-visited[previ][prevj]>=3)\\n            return true;\\n\\n        if(visited[i][j]!=0)\\n            return false;\\n        \\n        visited[i][j]=count++;\\n        \\n        return dfs(grid,i+1,j,visited,i,j,c) || dfs(grid,i-1,j,visited,i,j,c) || dfs(grid,i,j+1,visited,i,j,c) || dfs(grid,i,j-1,visited,i,j,c);\\n    }\\n    public boolean containsCycle(char[][] grid) {\\n        \\n        int n = grid.length, m = grid[0].length;\\n        int[][]visited = new int[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j]==0 && dfs(grid,i,j,visited,i,j,grid[i][j]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808917,
                "title": "true-simple-and-concise-implementation-of-dfs",
                "content": "The key point of this DFS is that we need to remember from which cell we have come to this cell to `avoid back and forth`.\\n\\nSpace: O(m*n) such that m=grid.length, n= grid[0].length.\\nTime: O(m*n): because every time we start DFS, one cell is marked as visited at least.\\n\\n```\\nclass Solution {\\n  public boolean containsCycle(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    boolean[][] isVisited = new boolean[m][n];\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (!isVisited[i][j]) {\\n          if (hasCycle(grid, 0, i, j, grid[i][j], isVisited)) return true; // 0 is dummy direction of move.\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // @param dir: direction of move. dummy:0, down:1,left:2,up:3,right:4 for each.\\n  private boolean hasCycle(char[][] grid, int dir, int i, int j, char c, boolean[][] isVisited) {\\n    if (i < 0 || grid.length <= i || j < 0 || grid[0].length <= j || grid[i][j] != c) return false;\\n    if (isVisited[i][j]) return true;\\n    isVisited[i][j] = true;\\n    return (dir != 3 && hasCycle(grid, 1, i + 1, j, c, isVisited)) // move `down` if previous move was not `up`.\\n        || (dir != 1 && hasCycle(grid, 3, i - 1, j, c, isVisited)) // move `up` if previous move was not `down`.\\n        || (dir != 2 && hasCycle(grid, 4, i, j + 1, c, isVisited)) // move `right` if previous move was not `left`.\\n        || (dir != 4 && hasCycle(grid, 2, i, j - 1, c, isVisited)); // move `left` if previous move was not `right`.\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  public boolean containsCycle(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    boolean[][] isVisited = new boolean[m][n];\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (!isVisited[i][j]) {\\n          if (hasCycle(grid, 0, i, j, grid[i][j], isVisited)) return true; // 0 is dummy direction of move.\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // @param dir: direction of move. dummy:0, down:1,left:2,up:3,right:4 for each.\\n  private boolean hasCycle(char[][] grid, int dir, int i, int j, char c, boolean[][] isVisited) {\\n    if (i < 0 || grid.length <= i || j < 0 || grid[0].length <= j || grid[i][j] != c) return false;\\n    if (isVisited[i][j]) return true;\\n    isVisited[i][j] = true;\\n    return (dir != 3 && hasCycle(grid, 1, i + 1, j, c, isVisited)) // move `down` if previous move was not `up`.\\n        || (dir != 1 && hasCycle(grid, 3, i - 1, j, c, isVisited)) // move `up` if previous move was not `down`.\\n        || (dir != 2 && hasCycle(grid, 4, i, j + 1, c, isVisited)) // move `right` if previous move was not `left`.\\n        || (dir != 4 && hasCycle(grid, 2, i, j - 1, c, isVisited)); // move `left` if previous move was not `right`.\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234761,
                "title": "java-clean-union-find",
                "content": "Union-find is a popular algorithm to find cycle in graph. The idea is to connect letters of the same value. If we connect and find they already have the same parent, we have found a cycle. Important thing to note here is that rather than connecting in 4 directions, we will connect only to the right and the bottom otherwise the union-find algorithm will wrongly declare a cycle.\\n\\n```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        UnionFind uf = new UnionFind(n*m);\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i+1 < n && grid[i+1][j] == grid[i][j]) { // connect to bottom\\n                    if (!uf.union(i*m +j, (i+1)*m + j)) return true;\\n                }\\n                if (j+1 < m && grid[i][j+1] == grid[i][j]) { // connect to right\\n                    if (!uf.union(i*m +j, i*m + (j+1))) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        UnionFind(int sz) {\\n            parent = new int[sz];\\n            for (int i = 0; i < sz; i++) parent[i] = i;\\n        }\\n        \\n        boolean union(int a, int b) {\\n            int par_a = find(a);\\n            int par_b = find(b);\\n            \\n            if (par_a == par_b) return false;\\n            parent[par_a] = par_b;\\n            return true;\\n        }\\n        \\n        int find(int a) {\\n            if (a == parent[a]) return a;\\n            return parent[a] = find(parent[a]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        UnionFind uf = new UnionFind(n*m);\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i+1 < n && grid[i+1][j] == grid[i][j]) { // connect to bottom\\n                    if (!uf.union(i*m +j, (i+1)*m + j)) return true;\\n                }\\n                if (j+1 < m && grid[i][j+1] == grid[i][j]) { // connect to right\\n                    if (!uf.union(i*m +j, i*m + (j+1))) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        UnionFind(int sz) {\\n            parent = new int[sz];\\n            for (int i = 0; i < sz; i++) parent[i] = i;\\n        }\\n        \\n        boolean union(int a, int b) {\\n            int par_a = find(a);\\n            int par_b = find(b);\\n            \\n            if (par_a == par_b) return false;\\n            parent[par_a] = par_b;\\n            return true;\\n        }\\n        \\n        int find(int a) {\\n            if (a == parent[a]) return a;\\n            return parent[a] = find(parent[a]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805969,
                "title": "union-find-solution-o-m-n-h",
                "content": "//Find the root of left cell and top cell, if they have the same root, we find the circle.\\n//Time complexity O(m*n*\\u03B1*(h)), where \\u03B1 is Ackermann function, h is height of the parent tree. \\u03B1*(h) is close to constant.\\n\\n```\\npublic class Solution\\n{\\n    public bool ContainsCycle(char[][] grid)\\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        var uf = new UF(m * n);\\n        int[] dirs = new int[] { 0, -1, 0 };\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                HashSet<int> roots = new HashSet<int>();\\n                for (int d = 0; d < 2; d++)\\n                {\\n                    int ni = i + dirs[d];\\n                    int nj = j + dirs[d + 1];\\n                    if (ni < 0 || nj < 0 || grid[i][j] != grid[ni][nj])\\n                        continue;\\n                    int root = uf.Find(ni * n + nj);\\n                    if (roots.Contains(root))\\n                        return true;\\n                    roots.Add(root);\\n                }\\n                foreach (int r in roots)\\n                    uf.Union(r, i * n + j);\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\npublic class UF\\n{\\n    private int[] parent;\\n    public UF(int n)\\n    {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int Find(int x)\\n    {\\n        if (x == parent[x])\\n            return x;\\n        return parent[x] = Find(parent[x]);\\n    }\\n\\n    public void Union(int x, int y)\\n    {\\n        int px = Find(x);\\n        int py = Find(y);\\n        if(px != py)\\n            parent[px] = py;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public bool ContainsCycle(char[][] grid)\\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        var uf = new UF(m * n);\\n        int[] dirs = new int[] { 0, -1, 0 };\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                HashSet<int> roots = new HashSet<int>();\\n                for (int d = 0; d < 2; d++)\\n                {\\n                    int ni = i + dirs[d];\\n                    int nj = j + dirs[d + 1];\\n                    if (ni < 0 || nj < 0 || grid[i][j] != grid[ni][nj])\\n                        continue;\\n                    int root = uf.Find(ni * n + nj);\\n                    if (roots.Contains(root))\\n                        return true;\\n                    roots.Add(root);\\n                }\\n                foreach (int r in roots)\\n                    uf.Union(r, i * n + j);\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\npublic class UF\\n{\\n    private int[] parent;\\n    public UF(int n)\\n    {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int Find(int x)\\n    {\\n        if (x == parent[x])\\n            return x;\\n        return parent[x] = Find(parent[x]);\\n    }\\n\\n    public void Union(int x, int y)\\n    {\\n        int px = Find(x);\\n        int py = Find(y);\\n        if(px != py)\\n            parent[px] = py;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805946,
                "title": "python3-dfs-concise-code",
                "content": "- The trick was to keep track of the previous element so that you don\\'t go back there wihle doing dfs (took me a long time to figure out)\\n- We just check that while doing dfs we reach a node that we have already seen or not\\n```python\\nclass Solution:\\n    def containsCycle(self, A: List[List[str]]) -> bool:\\n        R, C = len(A), len(A[0])\\n        visited = set()\\n        \\n        def neighbors(r, c):\\n            return [(i, j) for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)] if 0 <= i < R and 0 <= j < C and A[i][j] == A[r][c]]\\n        \\n        def dfs(r, c, x, prev, seen):\\n            if (r, c) in seen:\\n                return True\\n            seen.add((r, c))\\n            visited.add((r, c))\\n\\n            for i, j in neighbors(r, c):\\n                if not prev or prev != (i, j):\\n                    if dfs(i, j, x, (r, c), seen):\\n                        return True\\n            return False\\n            \\n        \\n        for r in range(R):\\n            for c in range(C):\\n                if (r, c) not in visited:\\n                    seen = set()\\n                    if dfs(r, c, A[r][c], None, seen):\\n                        return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def containsCycle(self, A: List[List[str]]) -> bool:\\n        R, C = len(A), len(A[0])\\n        visited = set()\\n        \\n        def neighbors(r, c):\\n            return [(i, j) for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)] if 0 <= i < R and 0 <= j < C and A[i][j] == A[r][c]]\\n        \\n        def dfs(r, c, x, prev, seen):\\n            if (r, c) in seen:\\n                return True\\n            seen.add((r, c))\\n            visited.add((r, c))\\n\\n            for i, j in neighbors(r, c):\\n                if not prev or prev != (i, j):\\n                    if dfs(i, j, x, (r, c), seen):\\n                        return True\\n            return False\\n            \\n        \\n        for r in range(R):\\n            for c in range(C):\\n                if (r, c) not in visited:\\n                    seen = set()\\n                    if dfs(r, c, A[r][c], None, seen):\\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799412,
                "title": "dfs-c-basic-dfs-implementation-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Cycle if a dfs find previously visited cell with same letter.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1.Run dfs from each unvisited cell\\n    2.Visit next cell if it is same letter to present cell\\n    3.Update cycle = true if there is a previously visited cell with same letter and Return.   \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m * n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(2 * (m * n ) )\\n\\n# Code\\n```\\nclass Solution {\\n    int n,m;\\n    bool vis[505][505];\\n    bool cycle=false;\\n    int fx[4] = {1, -1, 0, 0};\\n    int fy[4] = {0, 0, 1, -1};\\n    vector<vector<char>>g;\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        g = grid;\\n        memset(vis, false, sizeof(vis));\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]){\\n                    dfs(i,j);\\n                    if(cycle) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void dfs(int ux, int uy, int px=-1, int py=-1)\\n    {\\n        vis[ux][uy]=true;\\n        for(int i=0; i<4; i++)\\n        {\\n            int vx = ux+ fx[i];\\n            int vy = uy+ fy[i];\\n            if(vx==px && vy==py) continue;\\n            if(vx>=0 && vy>=0 && vx<n && vy<m && g[vx][vy]==g[ux][uy]){\\n                if(vis[vx][vy]) {cycle=true;return;}\\n                \\n                dfs(vx, vy, ux, uy);\\n            }  \\n        }\\n        return ;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int n,m;\\n    bool vis[505][505];\\n    bool cycle=false;\\n    int fx[4] = {1, -1, 0, 0};\\n    int fy[4] = {0, 0, 1, -1};\\n    vector<vector<char>>g;\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        g = grid;\\n        memset(vis, false, sizeof(vis));\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]){\\n                    dfs(i,j);\\n                    if(cycle) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void dfs(int ux, int uy, int px=-1, int py=-1)\\n    {\\n        vis[ux][uy]=true;\\n        for(int i=0; i<4; i++)\\n        {\\n            int vx = ux+ fx[i];\\n            int vy = uy+ fy[i];\\n            if(vx==px && vy==py) continue;\\n            if(vx>=0 && vy>=0 && vx<n && vy<m && g[vx][vy]==g[ux][uy]){\\n                if(vis[vx][vy]) {cycle=true;return;}\\n                \\n                dfs(vx, vy, ux, uy);\\n            }  \\n        }\\n        return ;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665360,
                "title": "java-simple-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};\\n    public boolean containsCycle(char[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(!visited[i][j]){\\n                    if(isCycle(grid, i, j, visited, -1, -1))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isCycle(char[][] grid, int i, int j, boolean[][] visited, int prevI, int prevJ)\\n    {\\n        visited[i][j] = true;\\n        \\n        for(int[] dir: dirs){\\n            int x = i+dir[0];\\n            int y = j+dir[1];\\n            \\n            if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y]!=grid[i][j])\\n                continue;\\n            \\n            if(x == prevI && y == prevJ)\\n                continue;\\n            \\n            if(visited[x][y])\\n                return true;\\n            \\n            if(isCycle(grid, x, y, visited, i, j))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};\\n    public boolean containsCycle(char[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(!visited[i][j]){\\n                    if(isCycle(grid, i, j, visited, -1, -1))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isCycle(char[][] grid, int i, int j, boolean[][] visited, int prevI, int prevJ)\\n    {\\n        visited[i][j] = true;\\n        \\n        for(int[] dir: dirs){\\n            int x = i+dir[0];\\n            int y = j+dir[1];\\n            \\n            if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y]!=grid[i][j])\\n                continue;\\n            \\n            if(x == prevI && y == prevJ)\\n                continue;\\n            \\n            if(visited[x][y])\\n                return true;\\n            \\n            if(isCycle(grid, x, y, visited, i, j))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036435,
                "title": "java-dfs-solution-o-m-n",
                "content": "\\n\\tpublic boolean containsCycle(char[][] grid) {\\n\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\tint[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\t\\tboolean[][] visited = new boolean[m][n];\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (!visited[i][j]) {\\n\\t\\t\\t\\t\\tboolean flag = dfs(grid, visited, i, j, m, n, dirs,-1 ,-1);\\n\\t\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tpublic boolean dfs(char[][] grid, boolean[][] visited, int i, int j, int m, int n, int[][] dirs,int lr,int lc) {\\n        \\n\\t\\tvisited[i][j] = true;\\n\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\tint r = i + dir[0];\\n\\t\\t\\tint c = j + dir[1];\\n\\t\\t\\tif (r < 0 || c < 0 || r >= m || c >= n || grid[i][j] != grid[r][c] || (r == lr && c == lc))\\n\\t\\t\\t\\tcontinue;\\n            \\n\\t\\t\\tif (visited[r][c])\\n\\t\\t\\t\\treturn true;\\n            \\n\\t\\t\\tboolean flag = dfs(grid, visited, r, c, m, n, dirs, i, j);\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\tpublic boolean containsCycle(char[][] grid) {\\n\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\tint[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\t\\tboolean[][] visited = new boolean[m][n];\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (!visited[i][j]) {\\n\\t\\t\\t\\t\\tboolean flag = dfs(grid, visited, i, j, m, n, dirs,-1 ,-1);\\n\\t\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tpublic boolean dfs(char[][] grid, boolean[][] visited, int i, int j, int m, int n, int[][] dirs,int lr,int lc) {\\n        \\n\\t\\tvisited[i][j] = true;\\n\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\tint r = i + dir[0];\\n\\t\\t\\tint c = j + dir[1];\\n\\t\\t\\tif (r < 0 || c < 0 || r >= m || c >= n || grid[i][j] != grid[r][c] || (r == lr && c == lc))\\n\\t\\t\\t\\tcontinue;\\n            \\n\\t\\t\\tif (visited[r][c])\\n\\t\\t\\t\\treturn true;\\n            \\n\\t\\t\\tboolean flag = dfs(grid, visited, r, c, m, n, dirs, i, j);\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 839365,
                "title": "java-dfs-concisely",
                "content": "``` \\nclass Solution {\\n    boolean[][] vis;\\n    boolean res; // Defalut false;\\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        vis = new boolean[m][n];\\n\\t\\t// We use DFS here.\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!res&&!vis[i][j])\\n                    dfs(grid, i, j,grid[i][j],0); // 0 is the default direction, which can go four directions in the next step.\\n            }\\n        }\\n        return res;\\n    }\\n\\t// Pre is to save the direction of our previous deep search, to ensure that the next step does not go in the opposite direction\\n    public void dfs(char[][] grid, int i, int j, char c, int pre) {\\n\\t\\t// Pruning\\n        if(res||i<0||i>=grid.length||j<0||j>=grid[0].length||grid[i][j]!=c) return;\\n        if(!vis[i][j]){\\n            vis[i][j] = true;\\n\\t\\t\\t// Here is the key to the problem\\n            if(pre!=1) dfs(grid, i+1, j, c, 2);\\n            if(pre!=2) dfs(grid, i-1, j, c, 1);\\n            if(pre!=3) dfs(grid, i, j+1, c, 4);\\n            if(pre!=4) dfs(grid, i, j-1, c, 3);\\n        }else {\\n\\t\\t// If we  reach the location where we have arrived, then there is a circle.\\n             res = true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\n    boolean[][] vis;\\n    boolean res; // Defalut false;\\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        vis = new boolean[m][n];\\n\\t\\t// We use DFS here.\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!res&&!vis[i][j])\\n                    dfs(grid, i, j,grid[i][j],0); // 0 is the default direction, which can go four directions in the next step.\\n            }\\n        }\\n        return res;\\n    }\\n\\t// Pre is to save the direction of our previous deep search, to ensure that the next step does not go in the opposite direction\\n    public void dfs(char[][] grid, int i, int j, char c, int pre) {\\n\\t\\t// Pruning\\n        if(res||i<0||i>=grid.length||j<0||j>=grid[0].length||grid[i][j]!=c) return;\\n        if(!vis[i][j]){\\n            vis[i][j] = true;\\n\\t\\t\\t// Here is the key to the problem\\n            if(pre!=1) dfs(grid, i+1, j, c, 2);\\n            if(pre!=2) dfs(grid, i-1, j, c, 1);\\n            if(pre!=3) dfs(grid, i, j+1, c, 4);\\n            if(pre!=4) dfs(grid, i, j-1, c, 3);\\n        }else {\\n\\t\\t// If we  reach the location where we have arrived, then there is a circle.\\n             res = true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806482,
                "title": "java-dfs-solution-with-detailed-but-simple-comments",
                "content": "```\\nclass Solution {\\n    int X;\\n    int[][] visited;\\n    char[][] grid;\\n    public boolean containsCycle(char[][] grid) {\\n        this.X = 0; // To mark the paths in visited matrix\\n        this.visited = new int[grid.length][grid[0].length]; // Keep track of visited points\\n        this.grid = grid;\\n        \\n        for (int r = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[r].length;c++) {\\n                if (visited[r][c] == 0) {\\n                    X++; // Increment so we don\\'t conflict paths. \\n                    // isCycle will mark all reachable nodes from our current point with X\\n                    if (isCycle(r,c,-1,-1, grid[r][c])) return true;                  \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isCycle(int r, int c, int prevR, int prevC, char orig) {\\n        //If out of range or not the same char as original (meaning can\\'t continue path), return false\\n        if (r < 0 || r >= grid.length || c < 0 || c >= grid[r].length || grid[r][c] != orig)\\n            return false;\\n        \\n        \\n        if (visited[r][c] == X) return true; // If we visited this already, that means theres a cycle.\\n        // We don\\'t need to check length because we make sure we don\\'t visit a previous one already.\\n        \\n        visited[r][c] = X; // All paths will now have the same X value.\\n        \\n        // For each one, visit the next point ONLY if its not a previous point.\\n        return (\\n            (r-1 != prevR && isCycle(r-1, c, r, c, orig)) || \\n            (c+1 != prevC && isCycle(r, c+1, r, c, orig)) ||\\n            (r+1 != prevR && isCycle(r+1, c, r, c, orig)) ||\\n            (c-1 != prevC && isCycle(r, c-1, r, c, orig))\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int X;\\n    int[][] visited;\\n    char[][] grid;\\n    public boolean containsCycle(char[][] grid) {\\n        this.X = 0; // To mark the paths in visited matrix\\n        this.visited = new int[grid.length][grid[0].length]; // Keep track of visited points\\n        this.grid = grid;\\n        \\n        for (int r = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[r].length;c++) {\\n                if (visited[r][c] == 0) {\\n                    X++; // Increment so we don\\'t conflict paths. \\n                    // isCycle will mark all reachable nodes from our current point with X\\n                    if (isCycle(r,c,-1,-1, grid[r][c])) return true;                  \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isCycle(int r, int c, int prevR, int prevC, char orig) {\\n        //If out of range or not the same char as original (meaning can\\'t continue path), return false\\n        if (r < 0 || r >= grid.length || c < 0 || c >= grid[r].length || grid[r][c] != orig)\\n            return false;\\n        \\n        \\n        if (visited[r][c] == X) return true; // If we visited this already, that means theres a cycle.\\n        // We don\\'t need to check length because we make sure we don\\'t visit a previous one already.\\n        \\n        visited[r][c] = X; // All paths will now have the same X value.\\n        \\n        // For each one, visit the next point ONLY if its not a previous point.\\n        return (\\n            (r-1 != prevR && isCycle(r-1, c, r, c, orig)) || \\n            (c+1 != prevC && isCycle(r, c+1, r, c, orig)) ||\\n            (r+1 != prevR && isCycle(r+1, c, r, c, orig)) ||\\n            (c-1 != prevC && isCycle(r, c-1, r, c, orig))\\n        );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806241,
                "title": "python-3-union-find-explanation-clean",
                "content": "### Intuition\\n- How to define a cycle in this matrix? \\n\\t- There is at least ONE point `(x, y)`, such that has at least 2 different neighbors (left, right, up, down) with same parent.\\n- How to implement the cycle detection?\\n\\t- Use union find, we traverse the matrix from left to right, from top to bottom. \\n\\t- At each point `(x, y)`, we check its up and left neighbors, which are 2 different paths. \\n\\t- A cycle will happen if `(x, y)` is connected with both left & up neighbors.\\n- Use tuple to implement union find parent dictionary `self.p`.\\n### Implementation\\n```\\nclass UF:\\n    def __init__(self, m, n):    \\n        self.p = {(i, j): (i, j) for i in range(m) for j in range(n)}\\n        \\n    def union(self, ti, tj):\\n        pi, pj = self.find(*ti), self.find(*tj)\\n        if pi != pj:\\n            self.p[pj] = pi\\n            return False\\n        return True\\n            \\n    def find(self, i, j):\\n        if (i, j) != self.p[i,j]:  \\n            self.p[i,j] = self.find(*self.p[i,j])\\n        return self.p[i,j]    \\n                \\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        uf = UF(m, n)\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0 and grid[i][j] == grid[i-1][j]:\\n                    uf.union((i-1, j), (i, j))\\n                if j > 0 and grid[i][j] == grid[i][j-1]:\\n                    if uf.union((i, j-1), (i, j)): return True\\n        return False            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass UF:\\n    def __init__(self, m, n):    \\n        self.p = {(i, j): (i, j) for i in range(m) for j in range(n)}\\n        \\n    def union(self, ti, tj):\\n        pi, pj = self.find(*ti), self.find(*tj)\\n        if pi != pj:\\n            self.p[pj] = pi\\n            return False\\n        return True\\n            \\n    def find(self, i, j):\\n        if (i, j) != self.p[i,j]:  \\n            self.p[i,j] = self.find(*self.p[i,j])\\n        return self.p[i,j]    \\n                \\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        uf = UF(m, n)\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0 and grid[i][j] == grid[i-1][j]:\\n                    uf.union((i-1, j), (i, j))\\n                if j > 0 and grid[i][j] == grid[i][j-1]:\\n                    if uf.union((i, j-1), (i, j)): return True\\n        return False            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 805944,
                "title": "c-dfs-with-explanation-simple-o-mn-solution-faster-than-80",
                "content": "**The main idea is:**\\n1. Visit every single cell in the grid, but keep in mind that do not visit the same cell twice.\\n2. We keep tracking of the last cell we\\'ve visited, do not visit the last cell visited, because 2 adjcent cells aren\\'t considered as a cycle.\\n3. Keep iterating until our current cell is already visited, then there is a cycle. Why? Because if we\\'ve followed idea 2, there must be a previous visit before the last iteration/visit, which means we\\'re back to the origin of the cycle again, in this case, we return true means we found a cycle.\\n\\nHere is my code in c++:\\n```\\nclass Solution {\\npublic:\\n    bool iscyclic(vector<vector<char>>& grid, vector<vector<bool>> &vis, int curi, int curj, int lasti, int lastj, int tar){\\n        if(curi < 0 || curj < 0 || curi > grid.size()-1 || curj > grid[0].size()-1 || grid[curi][curj] != tar) return false;\\n        if(vis[curi][curj]) return true;\\n        vis[curi][curj] = true;\\n        if((curi+1!=lasti||curj!=lastj) && iscyclic(grid,vis,curi+1,curj,curi,curj,tar)) return true;\\n        if((curi-1!=lasti||curj!=lastj) && iscyclic(grid,vis,curi-1,curj,curi,curj,tar)) return true;\\n        if((curi!=lasti||curj+1!=lastj) && iscyclic(grid,vis,curi,curj+1,curi,curj,tar)) return true;\\n        if((curi!=lasti||curj-1!=lastj) && iscyclic(grid,vis,curi,curj-1,curi,curj,tar)) return true;\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        vector<vector<bool>> vis(grid.size(),vector<bool>(grid[0].size(),false));\\n        for(int i=0;i<grid.size();++i){\\n            for(int j=0;j<grid[0].size();++j){\\n                if(!vis[i][j] && iscyclic(grid,vis,i,j,-1,-1,grid[i][j])) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool iscyclic(vector<vector<char>>& grid, vector<vector<bool>> &vis, int curi, int curj, int lasti, int lastj, int tar){\\n        if(curi < 0 || curj < 0 || curi > grid.size()-1 || curj > grid[0].size()-1 || grid[curi][curj] != tar) return false;\\n        if(vis[curi][curj]) return true;\\n        vis[curi][curj] = true;\\n        if((curi+1!=lasti||curj!=lastj) && iscyclic(grid,vis,curi+1,curj,curi,curj,tar)) return true;\\n        if((curi-1!=lasti||curj!=lastj) && iscyclic(grid,vis,curi-1,curj,curi,curj,tar)) return true;\\n        if((curi!=lasti||curj+1!=lastj) && iscyclic(grid,vis,curi,curj+1,curi,curj,tar)) return true;\\n        if((curi!=lasti||curj-1!=lastj) && iscyclic(grid,vis,curi,curj-1,curi,curj,tar)) return true;\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        vector<vector<bool>> vis(grid.size(),vector<bool>(grid[0].size(),false));\\n        for(int i=0;i<grid.size();++i){\\n            for(int j=0;j<grid[0].size();++j){\\n                if(!vis[i][j] && iscyclic(grid,vis,i,j,-1,-1,grid[i][j])) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805709,
                "title": "dfs-with-visited-matrix-no-steps-4-check-is-needed",
                "content": "as long as it is not the step parent, and the char is the same and that grid is visited before, it is a cycle. No step info needs to be recorded.\\n\\n![image](https://assets.leetcode.com/users/images/b299a84e-2489-44ec-9460-b15578901252_1598115033.1479466.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if(m*n <4)\\n            return false;\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n));\\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j) {\\n                if(dfs(i, j, i, j, grid, visited, grid[i][j], 0))\\n                    return true;\\n            }\\n        \\n        return false;\\n    }\\n    \\n    bool dfs(int i, int j, int sx, int sy, vector<vector<char>>& grid, vector<vector<bool>>& visited, char ch, int step) {\\n\\n        if(grid[i][j] != ch || visited[i][j])\\n            return false;\\n\\n        visited[i][j] = 1;\\n\\n        \\n        for(int d = 0; d < 4; ++d) {\\n            int nx = i + dirs[d];\\n            int ny = j + dirs[d+1];\\n\\t\\t\\t//for the new x and new y, it cann\\'t be the source x and source y otherwise it is not a cycle.\\n            if(nx < 0 || nx >= grid.size() || ny < 0 || ny >= grid[0].size() || grid[nx][ny] != ch)\\n                continue;\\n            if(nx == sx && ny == sy)\\n                continue;\\n         //   if(visited[nx][ny] && step >= 3) { don\\'t need to check the step here, can remove from parameter list\\n\\t\\t      if(visited[nx][ny]) {\\n                return true;\\n            }\\n            if(dfs(nx, ny, i, j, grid, visited, ch, step+1)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<int> dirs = {0, 1, 0, -1, 0};\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if(m*n <4)\\n            return false;\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n));\\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j) {\\n                if(dfs(i, j, i, j, grid, visited, grid[i][j], 0))\\n                    return true;\\n            }\\n        \\n        return false;\\n    }\\n    \\n    bool dfs(int i, int j, int sx, int sy, vector<vector<char>>& grid, vector<vector<bool>>& visited, char ch, int step) {\\n\\n        if(grid[i][j] != ch || visited[i][j])\\n            return false;\\n\\n        visited[i][j] = 1;\\n\\n        \\n        for(int d = 0; d < 4; ++d) {\\n            int nx = i + dirs[d];\\n            int ny = j + dirs[d+1];\\n\\t\\t\\t//for the new x and new y, it cann\\'t be the source x and source y otherwise it is not a cycle.\\n            if(nx < 0 || nx >= grid.size() || ny < 0 || ny >= grid[0].size() || grid[nx][ny] != ch)\\n                continue;\\n            if(nx == sx && ny == sy)\\n                continue;\\n         //   if(visited[nx][ny] && step >= 3) { don\\'t need to check the step here, can remove from parameter list\\n\\t\\t      if(visited[nx][ny]) {\\n                return true;\\n            }\\n            if(dfs(nx, ny, i, j, grid, visited, ch, step+1)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<int> dirs = {0, 1, 0, -1, 0};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172685,
                "title": "bfs-c-simple",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool containsCycle(vector<vector<char>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), i, j, k;\\n        bool ans = false;\\n        queue<vector<int>> q;\\n        vector<int> tmp;\\n        char c;\\n        for (i = 0; i < m; i++)\\n        {\\n            for (j = 0; j < n; j++)\\n            {\\n\\n                if (grid[i][j] != \\'#\\')\\n                {\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    q.push({i, j});\\n                    c = grid[i][j];\\n                    while (!q.empty())\\n                    {\\n                        k = q.size();\\n                        while (k--)\\n                        {\\n                            tmp = q.front();\\n                            if (grid[tmp[0]][tmp[1]] == \\'#\\')\\n                            {\\n                                ans = true;\\n                            }\\n                            grid[tmp[0]][tmp[1]] = \\'#\\';\\n                            q.pop();\\n                            if (tmp[0] + 1 < m && grid[tmp[0] + 1][tmp[1]] == c)\\n                            {\\n                                q.push({tmp[0] + 1, tmp[1]});\\n                            }\\n                            if (tmp[0] - 1 >= 0 && grid[tmp[0] - 1][tmp[1]] == c)\\n                            {\\n                                q.push({tmp[0] - 1, tmp[1]});\\n                            }\\n                            if (tmp[1] + 1 < n && grid[tmp[0]][tmp[1] + 1] == c)\\n                            {\\n                                q.push({tmp[0], tmp[1] + 1});\\n                            }\\n                            if (tmp[1] - 1 >= 0 && grid[tmp[0]][tmp[1] - 1] == c)\\n                            {\\n                                q.push({tmp[0], tmp[1] - 1});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool containsCycle(vector<vector<char>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), i, j, k;\\n        bool ans = false;\\n        queue<vector<int>> q;\\n        vector<int> tmp;\\n        char c;\\n        for (i = 0; i < m; i++)\\n        {\\n            for (j = 0; j < n; j++)\\n            {\\n\\n                if (grid[i][j] != \\'#\\')\\n                {\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    q.push({i, j});\\n                    c = grid[i][j];\\n                    while (!q.empty())\\n                    {\\n                        k = q.size();\\n                        while (k--)\\n                        {\\n                            tmp = q.front();\\n                            if (grid[tmp[0]][tmp[1]] == \\'#\\')\\n                            {\\n                                ans = true;\\n                            }\\n                            grid[tmp[0]][tmp[1]] = \\'#\\';\\n                            q.pop();\\n                            if (tmp[0] + 1 < m && grid[tmp[0] + 1][tmp[1]] == c)\\n                            {\\n                                q.push({tmp[0] + 1, tmp[1]});\\n                            }\\n                            if (tmp[0] - 1 >= 0 && grid[tmp[0] - 1][tmp[1]] == c)\\n                            {\\n                                q.push({tmp[0] - 1, tmp[1]});\\n                            }\\n                            if (tmp[1] + 1 < n && grid[tmp[0]][tmp[1] + 1] == c)\\n                            {\\n                                q.push({tmp[0], tmp[1] + 1});\\n                            }\\n                            if (tmp[1] - 1 >= 0 && grid[tmp[0]][tmp[1] - 1] == c)\\n                            {\\n                                q.push({tmp[0], tmp[1] - 1});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2967209,
                "title": "c-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n\\n- Space complexity:(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(!v[i][j]){\\n                    v[i][j]=1;\\n                    char c=grid[i][j];\\n                    queue<pair<pair<int, int>, pair<int, int>>>q;\\n                    q.push({{i, j}, {-1, -1}});\\n                    while(!q.empty()){\\n                        int x=q.front().first.first, y=q.front().first.second;\\n                        int px=q.front().second.first, py=q.front().second.second;\\n                        //cout<<x<<\" \"<<y<<\" \"<<px<<\" \"<<py<<endl;\\n                        q.pop();\\n                        if(x<grid.size()-1 && grid[x+1][y]==c){\\n                            //cout<<\"H \"<<x+1<<\" \"<<y<<\" \"<<px<<\" \"<<py<<endl;\\n                            if(v[x+1][y] && (x+1!=px || y!=py)){return true;}\\n                            else if(!v[x+1][y]){\\n                                v[x+1][y]=1;\\n                                q.push({{x+1, y}, {x, y}});\\n                            }\\n                        }\\n                        if(x>0 && grid[x-1][y]==c){\\n                            //cout<<\"A \"<<x-1<<\" \"<<y<<\" \"<<px<<\" \"<<py<<endl;\\n                            if(v[x-1][y] && (x-1!=px || y!=py)){return true;}\\n                            else if(!v[x-1][y]){\\n                                v[x-1][y]=1;\\n                                q.push({{x-1, y}, {x, y}});\\n                            }\\n                        }\\n                        if(y>0 && grid[x][y-1]==c){\\n                            //cout<<\"B \"<<x<<\" \"<<y-1<<\" \"<<px<<\" \"<<py<<endl;\\n                            if(v[x][y-1] && (x!=px || y-1!=py)){return true;}\\n                            else if(!v[x][y-1]){\\n                                v[x][y-1]=1;\\n                                q.push({{x, y-1}, {x, y}});\\n                            }\\n                        }\\n                        if(y<grid[0].size()-1 && grid[x][y+1]==c){\\n                            //cout<<\"C \"<<x<<\" \"<<y+1<<\" \"<<px<<\" \"<<py<<endl;\\n                            if(v[x][y+1] && (x!=px || y+1!=py)){return true;}\\n                            else if(!v[x][y+1]){\\n                                v[x][y+1]=1;\\n                                q.push({{x, y+1}, {x, y}});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(!v[i][j]){\\n                    v[i][j]=1;\\n                    char c=grid[i][j];\\n                    queue<pair<pair<int, int>, pair<int, int>>>q;\\n                    q.push({{i, j}, {-1, -1}});\\n                    while(!q.empty()){\\n                        int x=q.front().first.first, y=q.front().first.second;\\n                        int px=q.front().second.first, py=q.front().second.second;\\n                        //cout<<x<<\" \"<<y<<\" \"<<px<<\" \"<<py<<endl;\\n                        q.pop();\\n                        if(x<grid.size()-1 && grid[x+1][y]==c){\\n                            //cout<<\"H \"<<x+1<<\" \"<<y<<\" \"<<px<<\" \"<<py<<endl;\\n                            if(v[x+1][y] && (x+1!=px || y!=py)){return true;}\\n                            else if(!v[x+1][y]){\\n                                v[x+1][y]=1;\\n                                q.push({{x+1, y}, {x, y}});\\n                            }\\n                        }\\n                        if(x>0 && grid[x-1][y]==c){\\n                            //cout<<\"A \"<<x-1<<\" \"<<y<<\" \"<<px<<\" \"<<py<<endl;\\n                            if(v[x-1][y] && (x-1!=px || y!=py)){return true;}\\n                            else if(!v[x-1][y]){\\n                                v[x-1][y]=1;\\n                                q.push({{x-1, y}, {x, y}});\\n                            }\\n                        }\\n                        if(y>0 && grid[x][y-1]==c){\\n                            //cout<<\"B \"<<x<<\" \"<<y-1<<\" \"<<px<<\" \"<<py<<endl;\\n                            if(v[x][y-1] && (x!=px || y-1!=py)){return true;}\\n                            else if(!v[x][y-1]){\\n                                v[x][y-1]=1;\\n                                q.push({{x, y-1}, {x, y}});\\n                            }\\n                        }\\n                        if(y<grid[0].size()-1 && grid[x][y+1]==c){\\n                            //cout<<\"C \"<<x<<\" \"<<y+1<<\" \"<<px<<\" \"<<py<<endl;\\n                            if(v[x][y+1] && (x!=px || y+1!=py)){return true;}\\n                            else if(!v[x][y+1]){\\n                                v[x][y+1]=1;\\n                                q.push({{x, y+1}, {x, y}});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2459998,
                "title": "c-simple-c-code-100-time-97-space",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b) return;\\n        parents[b] = a;\\n        return;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                parents.push_back(i*m+j);\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i > 0 && grid[i][j] == grid[i-1][j])\\n                {\\n                    int x = i*m+j;\\n                    int y = x-m;\\n                    if(find_set(x) == find_set(y))\\n                        return true;\\n                    union_set(x,y);\\n                }\\n                if(j < m-1 && grid[i][j] == grid[i][j+1])\\n                {\\n                    int x = i*m+j;\\n                    int y = x+1;\\n                    if(find_set(x) == find_set(y))\\n                        return true;\\n                    union_set(x,y);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b) return;\\n        parents[b] = a;\\n        return;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                parents.push_back(i*m+j);\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i > 0 && grid[i][j] == grid[i-1][j])\\n                {\\n                    int x = i*m+j;\\n                    int y = x-m;\\n                    if(find_set(x) == find_set(y))\\n                        return true;\\n                    union_set(x,y);\\n                }\\n                if(j < m-1 && grid[i][j] == grid[i][j+1])\\n                {\\n                    int x = i*m+j;\\n                    int y = x+1;\\n                    if(find_set(x) == find_set(y))\\n                        return true;\\n                    union_set(x,y);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986152,
                "title": "c-dfs-easy-to-understand-by-counting-steps",
                "content": "Similar to other DFS solutions, but is more straightfoward by recording the steps when visit each cell.\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    bool hasCircle(vector<vector<char>>& grid, \\n                   vector<vector<int>>& moves, // record all moves on visited node\\n                   const char& startC,\\n                   int row,\\n                   int col,\\n                   int steps) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size()) {\\n            return false;\\n        }\\n        if (grid[row][col] == startC) {\\n            // No steps on the cell, means the cell has never been visited.\\n            if (moves[row][col] == 0) {     \\n                moves[row][col] = steps;\\n                for (const auto& [r, c] : dirs) {\\n                    if (hasCircle(grid, moves, startC, row + r, col + c, steps + 1)) {\\n                        return true;\\n                    }\\n                }\\n            } else {\\n                // If visited before and has moved over 2 steps from last visit, there is a cycle.\\n                return steps - moves[row][col] > 2;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // O(M * N), O(M * N)\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        if (grid.empty() || grid[0].empty()) {\\n            return false;\\n        }\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> moves(m, vector<int>(n));\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (!moves[i][j]) {\\n                    char startC = grid[i][j];\\n                    if (hasCircle(grid, moves, startC, i, j, 1)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    bool hasCircle(vector<vector<char>>& grid, \\n                   vector<vector<int>>& moves, // record all moves on visited node\\n                   const char& startC,\\n                   int row,\\n                   int col,\\n                   int steps) {\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size()) {\\n            return false;\\n        }\\n        if (grid[row][col] == startC) {\\n            // No steps on the cell, means the cell has never been visited.\\n            if (moves[row][col] == 0) {     \\n                moves[row][col] = steps;\\n                for (const auto& [r, c] : dirs) {\\n                    if (hasCircle(grid, moves, startC, row + r, col + c, steps + 1)) {\\n                        return true;\\n                    }\\n                }\\n            } else {\\n                // If visited before and has moved over 2 steps from last visit, there is a cycle.\\n                return steps - moves[row][col] > 2;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // O(M * N), O(M * N)\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        if (grid.empty() || grid[0].empty()) {\\n            return false;\\n        }\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> moves(m, vector<int>(n));\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (!moves[i][j]) {\\n                    char startC = grid[i][j];\\n                    if (hasCircle(grid, moves, startC, i, j, 1)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732770,
                "title": "detailed-bfs-python-c-solution-with-explanation",
                "content": "\\nThe basic idea is that if there is a cell that can be reached via more than one direction in BFS search, then there is a loop. What I mean directions are [[-1,0],[1,0],[0,-1],[0,1]], i.e, going up,down, left, right. Look at the figure below, cell (3,3) can be reached via direction right (0,1) and down (1,0), which means that there are two paths **intersecting** here. \\n![image](https://assets.leetcode.com/users/images/7dd75f42-620b-4258-b24a-a47f16068c18_1643588706.3372598.png)\\n\\nunlike regular BFS implementation in which we usually replace the element in visited cell with a dummy number in the grid so that we don\\'t go back into the visited cell again, or we use a set to record visited cells, but in this problem, it won\\'t work because **we have to visit visited cell again to reach a loop**. For example, cell (3,3) has to be visited twice. \\n\\nSo here I use a dictionary of dictionary to store visited cells and its enter direction, for example cell (1,0)\\'s enter direction is (1,0), thus we have visited[(1,0)] = {(1,0)}, for cell (3,3), visited[(3,3)] = {(0,1),(1,0)}. Meanwhile for inital cell, we can assign (0,0) as its enter direction. \\n\\n\\n````\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        visited = {} # visited cell: enter direction\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if (i,j) not in visited:\\n                    dq = deque([(i,j)])\\n                    visited[(i,j)] = {(0,0)}\\n                    while dq:\\n                        i,j = dq.pop()\\n                        for di, dj in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                            if (di*-1,dj*-1) not in visited[(i,j)]: # this makes sure that we don\\'t go back to the immediate cell where we left off \\n                                if 0<=i+di<len(grid) and 0<=j+dj<len(grid[0]) and grid[i+di][j+dj] == grid[i][j]:\\n                                    if (i+di,j+dj) not in visited:\\n                                        visited[(i+di,j+dj)] = set()\\n                                        visited[(i+di,j+dj)].add((di,dj))\\n                                        dq.append((i+di,j+dj))\\n                                    else:\\n                                        return True\\n        return False \\n````\\n\\n\\nC++ version \\n````\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        map<pair<int,int>, set<pair<int,int>>> visited;\\n        int directions[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\\n        deque<pair<int,int>> dq;\\n        for(int i=0;i<grid.size();i++){\\n            for (int j=0;j<grid[0].size();j++){\\n                if (!visited.count({i,j})){\\n                    visited[{i,j}] = {{0,0}};\\n                    dq = {{i,j}};\\n                    while (!dq.empty()){\\n                        auto [i,j] = dq.front();\\n                        dq.pop_front();\\n                        for (auto [di,dj]:directions){\\n                            if (!visited[{i,j}].count({-di,-dj})){\\n                                if (0<=i+di && i+di<grid.size() && 0<=j+dj && j+dj<grid[0].size() && grid[i+di][j+dj]==grid[i][j]){\\n                                    if (!visited.count({i+di,j+dj})){\\n                                        visited[{i+di,j+dj}] = {{di,dj}};\\n                                        dq.push_back({i+di,j+dj});\\n                                    }\\n                                    else\\n                                        return true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n````\\n\\nPlease **upvote** if it helps you",
                "solutionTags": [
                    "Python",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "````\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        visited = {} # visited cell: enter direction\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if (i,j) not in visited:\\n                    dq = deque([(i,j)])\\n                    visited[(i,j)] = {(0,0)}\\n                    while dq:\\n                        i,j = dq.pop()\\n                        for di, dj in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                            if (di*-1,dj*-1) not in visited[(i,j)]: # this makes sure that we don\\'t go back to the immediate cell where we left off \\n                                if 0<=i+di<len(grid) and 0<=j+dj<len(grid[0]) and grid[i+di][j+dj] == grid[i][j]:\\n                                    if (i+di,j+dj) not in visited:\\n                                        visited[(i+di,j+dj)] = set()\\n                                        visited[(i+di,j+dj)].add((di,dj))\\n                                        dq.append((i+di,j+dj))\\n                                    else:\\n                                        return True\\n        return False \\n```\n````\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        map<pair<int,int>, set<pair<int,int>>> visited;\\n        int directions[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\\n        deque<pair<int,int>> dq;\\n        for(int i=0;i<grid.size();i++){\\n            for (int j=0;j<grid[0].size();j++){\\n                if (!visited.count({i,j})){\\n                    visited[{i,j}] = {{0,0}};\\n                    dq = {{i,j}};\\n                    while (!dq.empty()){\\n                        auto [i,j] = dq.front();\\n                        dq.pop_front();\\n                        for (auto [di,dj]:directions){\\n                            if (!visited[{i,j}].count({-di,-dj})){\\n                                if (0<=i+di && i+di<grid.size() && 0<=j+dj && j+dj<grid[0].size() && grid[i+di][j+dj]==grid[i][j]){\\n                                    if (!visited.count({i+di,j+dj})){\\n                                        visited[{i+di,j+dj}] = {{di,dj}};\\n                                        dq.push_back({i+di,j+dj});\\n                                    }\\n                                    else\\n                                        return true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645645,
                "title": "c-concise-union-find",
                "content": "```\\nvector <int> f;\\nint find(int x) {\\n\\tif (f[x] != x)\\n\\t\\tf[x] = find(f[x]);\\n\\treturn f[x];\\n}\\nbool unify(int x, int y) {\\n\\tx = find(x);\\n\\ty = find(y);\\n\\tf[x] = y;\\n\\treturn x == y;\\n}\\nbool containsCycle(vector<vector<char>>& a) {\\n\\tint n = a.size(), m = a[0].size();\\n\\tf.resize(n * m);\\n\\tiota(f.begin(), f.end(), 0);\\n\\tint d[3] = {0, 1, 0};\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\tfor (int k = 0; k < 2; k++) {\\n\\t\\t\\t\\tint x = d[k] + i, y = d[k + 1] + j;\\n\\t\\t\\t\\tif (x == n || y == m || a[i][j] != a[x][y]) continue;\\n\\t\\t\\t\\tif (unify(i * m + j, x * m + y))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nvector <int> f;\\nint find(int x) {\\n\\tif (f[x] != x)\\n\\t\\tf[x] = find(f[x]);\\n\\treturn f[x];\\n}\\nbool unify(int x, int y) {\\n\\tx = find(x);\\n\\ty = find(y);\\n\\tf[x] = y;\\n\\treturn x == y;\\n}\\nbool containsCycle(vector<vector<char>>& a) {\\n\\tint n = a.size(), m = a[0].size();\\n\\tf.resize(n * m);\\n\\tiota(f.begin(), f.end(), 0);\\n\\tint d[3] = {0, 1, 0};\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\tfor (int k = 0; k < 2; k++) {\\n\\t\\t\\t\\tint x = d[k] + i, y = d[k + 1] + j;\\n\\t\\t\\t\\tif (x == n || y == m || a[i][j] != a[x][y]) continue;\\n\\t\\t\\t\\tif (unify(i * m + j, x * m + y))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1533122,
                "title": "1559-detect-cycles-in-2d-grid-c-dfs-solution-explained",
                "content": "## **Intuition behind solving this problem**\\nIf there exists a cycle, then all the cells of the cycle should have the same value, and they should be connected and also that the last and the first element should have different parents.\\n\\n**Approach-:**\\n***The idea is to use DFS Traversal on the grid to detect a cycle in it. Below are the steps:*** \\n\\n1. Pick every cell of the given matrix ((0, 0) to (N \\u2013 1, M \\u2013 1)) because there is no definite position of the cycle.\\n1. If there exists a cycle, then all the cells of the cycle should have the same value, and they should be connected and also check that the last and the first element should form a loop (they should have different parents).\\n1. Take a boolean variable that will store the result of the function isCycle() which will be a 1 or 0 respectively, indicating whether there is a cycle or not. If the function returns 1, then switch the ans variable to true, and break the loop else continue.\\n1. If the ans remains unmarked till the last then print No otherwise print Yes.\\n\\n**Below is the implementation of the above approach:**\\n\\n```\\nclass Solution {\\n    int n, m; // dimensions of the given grid.\\n    const int dx[4] = {-1,0,1,0}; // direction vector of x-axis.\\n    const int dy[4] = {0,1,0,-1}; // direction vector of y-axis.\\npublic:\\n    // Function to check if the current cell (x,y) is a valid cell or not.\\n    // A valid cell must lie on or inside the boundary of the grid.\\n    int isValid (int x, int y) {\\n        if (x < n and x >= 0 and y < m and y >= 0) return 1; // if the cell is valid, then return true.\\n        return 0; // otherwise return false.\\n    }\\n\\n    // DFS algorithm implementation to detect cycle in 2D - Grid. \\n    int dfs (int x, int y, vector<vector<char>>& grid, vector<vector<int>>& vis, int px, int py) {\\n        vis[x][y] = 1;\\n        for (int k = 0; k < 4; k++) {\\n            int nx = x + dx[k];\\n            int ny = y + dy[k];\\n            \\n            // checking if the next cell is valid or not.\\n            if (isValid(nx, ny) == 1 and grid[nx][ny] == grid[x][y] and !(px == nx and py == ny)) {\\n                if (vis[nx][ny] == 1) return 1;\\n                else {\\n                    bool ok = dfs (nx, ny, grid, vis, x, y); // recursively calling dfs on unvisited cells.\\n                    if (ok == 1) return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    //driver function\\n    bool containsCycle (vector<vector<char>>& grid) {\\n        n = grid.size(); // # of rows.\\n        m = grid[0].size(); // # of columns.\\n        vector<vector<int>> vis(n, vector<int>(m, 0)); // 2D visited array.\\n        int ok = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (ok == 1) break;\\n            for (int j = 0; j < m; j++) {\\n                if (vis[i][j] == 0) ok = dfs (i, j, grid, vis, -1, -1); // recursively calling for DFS to all the cells in the grid.\\n                if (ok) break; // if cycle is found, break out of recursion.\\n            }\\n        }\\n        return ok ? true : false; // return true if cycle exist otherwise false.\\n    }\\n};\\n```\\n\\n**Time Complexity-:** O(N * M)\\n**Auxiliary Space-:** O(N * M)\\n***N, M are dimensions of the grid.***",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int n, m; // dimensions of the given grid.\\n    const int dx[4] = {-1,0,1,0}; // direction vector of x-axis.\\n    const int dy[4] = {0,1,0,-1}; // direction vector of y-axis.\\npublic:\\n    // Function to check if the current cell (x,y) is a valid cell or not.\\n    // A valid cell must lie on or inside the boundary of the grid.\\n    int isValid (int x, int y) {\\n        if (x < n and x >= 0 and y < m and y >= 0) return 1; // if the cell is valid, then return true.\\n        return 0; // otherwise return false.\\n    }\\n\\n    // DFS algorithm implementation to detect cycle in 2D - Grid. \\n    int dfs (int x, int y, vector<vector<char>>& grid, vector<vector<int>>& vis, int px, int py) {\\n        vis[x][y] = 1;\\n        for (int k = 0; k < 4; k++) {\\n            int nx = x + dx[k];\\n            int ny = y + dy[k];\\n            \\n            // checking if the next cell is valid or not.\\n            if (isValid(nx, ny) == 1 and grid[nx][ny] == grid[x][y] and !(px == nx and py == ny)) {\\n                if (vis[nx][ny] == 1) return 1;\\n                else {\\n                    bool ok = dfs (nx, ny, grid, vis, x, y); // recursively calling dfs on unvisited cells.\\n                    if (ok == 1) return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    //driver function\\n    bool containsCycle (vector<vector<char>>& grid) {\\n        n = grid.size(); // # of rows.\\n        m = grid[0].size(); // # of columns.\\n        vector<vector<int>> vis(n, vector<int>(m, 0)); // 2D visited array.\\n        int ok = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (ok == 1) break;\\n            for (int j = 0; j < m; j++) {\\n                if (vis[i][j] == 0) ok = dfs (i, j, grid, vis, -1, -1); // recursively calling for DFS to all the cells in the grid.\\n                if (ok) break; // if cycle is found, break out of recursion.\\n            }\\n        }\\n        return ok ? true : false; // return true if cycle exist otherwise false.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380475,
                "title": "easy-java-code-union-find-clean-code-using-graph",
                "content": "```\\nclass Solution {\\n        int[] par;\\n        public int findPar(int u) {\\n                return par[u] == u ? u : (par[u] = findPar(par[u]));\\n        }\\n    public boolean containsCycle(char[][] grid) {\\n       \\n            int n = grid.length, m = grid[0].length;\\n             par = new int[n * m];\\n            for(int i = 0; i < n; i++) {\\n                    for(int j = 0; j < m; j++) {\\n                            par[i * m + j] = i * m + j;\\n                    }\\n            }\\n           \\n            int[][] dir = {{0, 1}, {1, 0}};\\n            \\n            for(int i = 0; i < n; i++) {\\n                    for(int j = 0; j < m; j++) {\\n                            char ch = grid[i][j];\\n                            \\n                            int p1 = findPar(i * m + j);\\n                            for(int d = 0; d < 2; d++) {\\n                                    int r = i + dir[d][0];\\n                                    int c = j + dir[d][1];\\n                                    \\n                                    if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == ch) {\\n                                           int p2 = findPar(r * m + c);\\n                                            \\n                                            if(p1 != p2) {\\n                                                    par[p2] = p1;\\n                                            }else return true;\\n                                    }\\n                            }\\n                    }\\n            }\\n            return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        int[] par;\\n        public int findPar(int u) {\\n                return par[u] == u ? u : (par[u] = findPar(par[u]));\\n        }\\n    public boolean containsCycle(char[][] grid) {\\n       \\n            int n = grid.length, m = grid[0].length;\\n             par = new int[n * m];\\n            for(int i = 0; i < n; i++) {\\n                    for(int j = 0; j < m; j++) {\\n                            par[i * m + j] = i * m + j;\\n                    }\\n            }\\n           \\n            int[][] dir = {{0, 1}, {1, 0}};\\n            \\n            for(int i = 0; i < n; i++) {\\n                    for(int j = 0; j < m; j++) {\\n                            char ch = grid[i][j];\\n                            \\n                            int p1 = findPar(i * m + j);\\n                            for(int d = 0; d < 2; d++) {\\n                                    int r = i + dir[d][0];\\n                                    int c = j + dir[d][1];\\n                                    \\n                                    if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == ch) {\\n                                           int p2 = findPar(r * m + c);\\n                                            \\n                                            if(p1 != p2) {\\n                                                    par[p2] = p1;\\n                                            }else return true;\\n                                    }\\n                            }\\n                    }\\n            }\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929853,
                "title": "python3-iterative-and-recursive-dfs",
                "content": "**Observations**\\n1. If we cannot move to the last node, the smallest length of cycle we can get will be 4\\n\\t* To get a cycle of length 3, we have to move diagonally\\n\\t* To get a cycle of length 2, we have to go back to the last node\\n\\t* To get a cycle of length 1, we have to move back to current node\\n\\t* All above operations are not allowed, so the shortest length we can get for a cycle is 4, which means we do not need to care about the length when looking for the cycle, because any cycle we can find will meet the length requirement\\n2. Do DFS on the graph by moving among connected node with same value, when we meet a visited node, it means there is a cycle\\n\\t* \\tHow do we know the visited node is from current searching path, not some path we visited earlier in a different path?\\n\\t\\t* \\tbecause the graph in this case is undirected, different searching paths will be disconnected from each other, so we won\\'t be able to reach a node that belongs to a different searching path\\n\\n**Recursive Solution**\\n```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if (i, j) not in visited:\\n                    res = self.helper(grid, None, None, i, j, visited)\\n                    if res:\\n                        return True\\n        return False\\n    \\n    def helper(self, grid, px, py, x, y, visited):\\n        if (x, y) in visited:\\n            return True\\n        \\n        visited.add((x, y))\\n        \\n        m, n = len(grid), len(grid[0])\\n        res = False\\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n            nx, ny = x + dx, y + dy\\n            if 0 <= nx < m and 0 <= ny < n and (nx, ny) != (px, py) and grid[nx][ny] == grid[x][y]:\\n                res = res or self.helper(grid, x, y, nx, ny, visited)\\n        return res\\n```\\n\\n**Iterative Solution**\\n```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        visited = set()\\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                if (i, j) in visited:\\n                    continue\\n                \\n                stack = [(i, j, None, None)]\\n                while stack:\\n                    x, y, px, py = stack.pop()\\n                    if (x, y) in visited:\\n                        return True\\n                    \\n                    visited.add((x, y))\\n                    \\n                    for dx, dy in dirs:\\n                        nx, ny = x + dx, y + dy\\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == grid[x][y] and (nx, ny) != (px, py):\\n                            stack.append((nx, ny, x, y))\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if (i, j) not in visited:\\n                    res = self.helper(grid, None, None, i, j, visited)\\n                    if res:\\n                        return True\\n        return False\\n    \\n    def helper(self, grid, px, py, x, y, visited):\\n        if (x, y) in visited:\\n            return True\\n        \\n        visited.add((x, y))\\n        \\n        m, n = len(grid), len(grid[0])\\n        res = False\\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n            nx, ny = x + dx, y + dy\\n            if 0 <= nx < m and 0 <= ny < n and (nx, ny) != (px, py) and grid[nx][ny] == grid[x][y]:\\n                res = res or self.helper(grid, x, y, nx, ny, visited)\\n        return res\\n```\n```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        visited = set()\\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                if (i, j) in visited:\\n                    continue\\n                \\n                stack = [(i, j, None, None)]\\n                while stack:\\n                    x, y, px, py = stack.pop()\\n                    if (x, y) in visited:\\n                        return True\\n                    \\n                    visited.add((x, y))\\n                    \\n                    for dx, dy in dirs:\\n                        nx, ny = x + dx, y + dy\\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == grid[x][y] and (nx, ny) != (px, py):\\n                            stack.append((nx, ny, x, y))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860842,
                "title": "javascript-dfs",
                "content": "```\\nconst dirs = [[-1,0],[1,0],[0,-1],[0,1]];\\n\\nvar containsCycle = function(grid) {\\n    const n=grid.length, m=grid[0].length;\\n    const dfs = function(type, i, j, previ, prevj){\\n        if(i<0 || j<0 || i==n || j==m) return false;\\n        if(grid[i][j]!=type) return grid[i][j]==type.toUpperCase();\\n        grid[i][j]=grid[i][j].toUpperCase();\\n        for(let dir of dirs){\\n            if(i+dir[0]==previ && j+dir[1]==prevj) continue;\\n            if(dfs(type,i+dir[0],j+dir[1],i,j)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    for(let i=0; i<n; i++)\\n        for(let j=0; j<m; j++){\\n            if(grid[i][j]==grid[i][j].toUpperCase()) continue;\\n            if(dfs(grid[i][j], i, j, -1, -1)) return true;\\n        }\\n    return false;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst dirs = [[-1,0],[1,0],[0,-1],[0,1]];\\n\\nvar containsCycle = function(grid) {\\n    const n=grid.length, m=grid[0].length;\\n    const dfs = function(type, i, j, previ, prevj){\\n        if(i<0 || j<0 || i==n || j==m) return false;\\n        if(grid[i][j]!=type) return grid[i][j]==type.toUpperCase();\\n        grid[i][j]=grid[i][j].toUpperCase();\\n        for(let dir of dirs){\\n            if(i+dir[0]==previ && j+dir[1]==prevj) continue;\\n            if(dfs(type,i+dir[0],j+dir[1],i,j)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    for(let i=0; i<n; i++)\\n        for(let j=0; j<m; j++){\\n            if(grid[i][j]==grid[i][j].toUpperCase()) continue;\\n            if(dfs(grid[i][j], i, j, -1, -1)) return true;\\n        }\\n    return false;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754663,
                "title": "c-dfs-easy-to-understand",
                "content": "## Please upvote it if you like this\\n# Code\\n```\\nclass Solution {\\n    bool dfs(int r, int c, int pr, int pc, vector<vector<char>>&grid, vector<vector<int>>& vis){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[r][c] = 1;\\n\\n        int dx[4] = {-1, 0, 1, 0};\\n        int dy[4] = {0, -1, 0, 1};\\n\\n        for(int i = 0;i < 4;i++){\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx < 0 || nx >= m || ny < 0 || ny >= n || grid[r][c] != grid[nx][ny]) continue;\\n            if(nx == pr && ny == pc) continue;\\n            if(vis[nx][ny]){\\n                return true;\\n            }\\n            else if(dfs(nx, ny, r, c, grid, vis)) \\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(!vis[i][j])\\n                    if(dfs(i, j, -1, -1, grid, vis))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(int r, int c, int pr, int pc, vector<vector<char>>&grid, vector<vector<int>>& vis){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[r][c] = 1;\\n\\n        int dx[4] = {-1, 0, 1, 0};\\n        int dy[4] = {0, -1, 0, 1};\\n\\n        for(int i = 0;i < 4;i++){\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx < 0 || nx >= m || ny < 0 || ny >= n || grid[r][c] != grid[nx][ny]) continue;\\n            if(nx == pr && ny == pc) continue;\\n            if(vis[nx][ny]){\\n                return true;\\n            }\\n            else if(dfs(nx, ny, r, c, grid, vis)) \\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(!vis[i][j])\\n                    if(dfs(i, j, -1, -1, grid, vis))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601003,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int i, int j, int n, int m){\\n        if(i>=0 && j>=0 && i<n && j<m ) return true;\\n        return false;\\n    }\\n    bool ans = false;\\n    void dfs(int i, int j, int parI, int parJ, vector<vector<char>>& grid, vector<vector<char>>&vis,int n, int m, char ch){\\n        vis[i][j] = 1;\\n        int a1[] = {1,-1,0,0};\\n        int a2[] = {0,0,1,-1};\\n        for(int k=0; k<4; k++){\\n            int r = i + a1[k];\\n            int c = j + a2[k];\\n            if(check(r,c,n,m) && vis[r][c] && grid[r][c] == ch && r != parI && c != parJ){\\n                ans = true;\\n            }\\n            else if(check(r,c,n,m) && !vis[r][c] && grid[r][c] == ch){\\n                dfs(r,c,i,j,grid,vis,n,m,ch);\\n            }\\n            \\n        }\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<char>>vis(n,vector<char>(m,0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]){\\n                    dfs(i,j,-1,-1,grid,vis,n,m,grid[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int i, int j, int n, int m){\\n        if(i>=0 && j>=0 && i<n && j<m ) return true;\\n        return false;\\n    }\\n    bool ans = false;\\n    void dfs(int i, int j, int parI, int parJ, vector<vector<char>>& grid, vector<vector<char>>&vis,int n, int m, char ch){\\n        vis[i][j] = 1;\\n        int a1[] = {1,-1,0,0};\\n        int a2[] = {0,0,1,-1};\\n        for(int k=0; k<4; k++){\\n            int r = i + a1[k];\\n            int c = j + a2[k];\\n            if(check(r,c,n,m) && vis[r][c] && grid[r][c] == ch && r != parI && c != parJ){\\n                ans = true;\\n            }\\n            else if(check(r,c,n,m) && !vis[r][c] && grid[r][c] == ch){\\n                dfs(r,c,i,j,grid,vis,n,m,ch);\\n            }\\n            \\n        }\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<char>>vis(n,vector<char>(m,0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]){\\n                    dfs(i,j,-1,-1,grid,vis,n,m,grid[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916044,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    int n, m;\\n    vector<vector<bool>> vis;\\n    vector<pair<int,int>> movements{{0,1},{0,-1},{1,0},{-1,0}};\\n\\n    bool isValid(int i,int j){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    bool dfs(int x,int y,int px,int py,char c,vector<vector<char>>& grid){\\n        vis[x][y] = true;\\n        bool isCycle = false;\\n        for(auto &movement: movements){\\n            int i = x + movement.first, j = y + movement.second;\\n            if(isValid(i,j) && grid[i][j] == c){\\n                if(!vis[i][j]) isCycle |= dfs(i,j,x,y,c,grid);\\n                else if(i != px && j != py) return true;\\n            }\\n        }\\n\\n        return isCycle;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vis.resize(n,vector<bool>(m,false));\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(!vis[i][j]){\\n                    if(dfs(i,j,-1,-1,grid[i][j],grid)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n, m;\\n    vector<vector<bool>> vis;\\n    vector<pair<int,int>> movements{{0,1},{0,-1},{1,0},{-1,0}};\\n\\n    bool isValid(int i,int j){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    bool dfs(int x,int y,int px,int py,char c,vector<vector<char>>& grid){\\n        vis[x][y] = true;\\n        bool isCycle = false;\\n        for(auto &movement: movements){\\n            int i = x + movement.first, j = y + movement.second;\\n            if(isValid(i,j) && grid[i][j] == c){\\n                if(!vis[i][j]) isCycle |= dfs(i,j,x,y,c,grid);\\n                else if(i != px && j != py) return true;\\n            }\\n        }\\n\\n        return isCycle;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vis.resize(n,vector<bool>(m,false));\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(!vis[i][j]){\\n                    if(dfs(i,j,-1,-1,grid[i][j],grid)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477975,
                "title": "c-depth-first-search",
                "content": "```\\nclass Solution\\n{\\n\\n    bool isCycle = false;\\n    vector<vector < bool>> visited;\\n    int row;\\n    int col;\\n    void depthFirstSearch(vector<vector < char>> &grid, int r, int c, int pr, int pc)\\n    {\\n        if (visited[r][c])\\n        {\\n            isCycle = true;\\n            return;\\n        }\\n        visited[r][c] = true;\\n        if (r + 1 < row and r + 1 != pr and grid[r + 1][c] == grid[r][c])\\n            depthFirstSearch(grid, r + 1, c, r, c);\\n        if (c + 1 < col and c + 1 != pc and grid[r][c + 1] == grid[r][c])\\n            depthFirstSearch(grid, r, c + 1, r, c);\\n        if (r - 1 >= 0 and r - 1 != pr and grid[r - 1][c] == grid[r][c])\\n            depthFirstSearch(grid, r - 1, c, r, c);\\n        if (c - 1 >= 0 and c - 1 != pc and grid[r][c - 1] == grid[r][c])\\n            depthFirstSearch(grid, r, c - 1, r, c);\\n    }\\n\\n    public:\\n        bool containsCycle(vector<vector < char>> &grid)\\n        {\\n            this->row = grid.size();\\n            this->col = grid[0].size();\\n\\n            std::vector<std::vector < bool>> matrix(row, std::vector<bool> (col, false));\\n            visited = matrix;\\n\\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                for (int j = 0; j < matrix[i].size(); j++)\\n                {\\n                    if (!visited[i][j])\\n                    {\\n                        depthFirstSearch(grid, i, j, -1, -1);\\n                    }\\n                }\\n            }\\n            return isCycle;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    bool isCycle = false;\\n    vector<vector < bool>> visited;\\n    int row;\\n    int col;\\n    void depthFirstSearch(vector<vector < char>> &grid, int r, int c, int pr, int pc)\\n    {\\n        if (visited[r][c])\\n        {\\n            isCycle = true;\\n            return;\\n        }\\n        visited[r][c] = true;\\n        if (r + 1 < row and r + 1 != pr and grid[r + 1][c] == grid[r][c])\\n            depthFirstSearch(grid, r + 1, c, r, c);\\n        if (c + 1 < col and c + 1 != pc and grid[r][c + 1] == grid[r][c])\\n            depthFirstSearch(grid, r, c + 1, r, c);\\n        if (r - 1 >= 0 and r - 1 != pr and grid[r - 1][c] == grid[r][c])\\n            depthFirstSearch(grid, r - 1, c, r, c);\\n        if (c - 1 >= 0 and c - 1 != pc and grid[r][c - 1] == grid[r][c])\\n            depthFirstSearch(grid, r, c - 1, r, c);\\n    }\\n\\n    public:\\n        bool containsCycle(vector<vector < char>> &grid)\\n        {\\n            this->row = grid.size();\\n            this->col = grid[0].size();\\n\\n            std::vector<std::vector < bool>> matrix(row, std::vector<bool> (col, false));\\n            visited = matrix;\\n\\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                for (int j = 0; j < matrix[i].size(); j++)\\n                {\\n                    if (!visited[i][j])\\n                    {\\n                        depthFirstSearch(grid, i, j, -1, -1);\\n                    }\\n                }\\n            }\\n            return isCycle;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303444,
                "title": "67-tc-and-56-sc-easy-python-solution",
                "content": "```\\ndef containsCycle(self, grid: List[List[str]]) -> bool:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\t@lru_cache(None)\\n\\tdef isCycle(i, j, par_i, par_j):\\n\\t\\tif (i, j) in vis:\\n\\t\\t\\treturn True\\n\\t\\tvis.add((i, j))\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == grid[i][j] and (i+x, j+y) != (par_i, par_j)):\\n\\t\\t\\t\\tif(isCycle(i+x, j+y, i, j)):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\tvis = set()\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif((i, j) not in vis and isCycle(i, j, -1, -1)):\\n\\t\\t\\t\\treturn 1\\n\\treturn 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\ndef containsCycle(self, grid: List[List[str]]) -> bool:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\t@lru_cache(None)\\n\\tdef isCycle(i, j, par_i, par_j):\\n\\t\\tif (i, j) in vis:\\n\\t\\t\\treturn True\\n\\t\\tvis.add((i, j))\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == grid[i][j] and (i+x, j+y) != (par_i, par_j)):\\n\\t\\t\\t\\tif(isCycle(i+x, j+y, i, j)):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\tvis = set()\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif((i, j) not in vis and isCycle(i, j, -1, -1)):\\n\\t\\t\\t\\treturn 1\\n\\treturn 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1815035,
                "title": "cpp-cheeky-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool fun(vector<vector<char>>&grid,int i,int j,char c)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(i<0||j<0||i>=m||j>=n)\\n            return false;\\n        char upper=toupper(c);\\n        \\n        if(grid[i][j]!=c&&grid[i][j]!=upper)\\n            return false;\\n        if(grid[i][j]==upper)\\n            return true;\\n\\n        grid[i][j]=upper;\\n        bool b1=fun(grid,i+1,j,c);\\n        bool b2=fun(grid,i-1,j,c);\\n        bool b3=fun(grid,i,j+1,c);\\n        bool b4=fun(grid,i,j-1,c);\\n        int count=0;\\n        if(b1)\\n            count++;\\n        if(b2)\\n            count++;\\n        if(b3)\\n            count++;\\n        if(b4)\\n            count++;\\n        ans=max(ans,count);\\n        return ans>=2;\\n      \\n    }\\n    bool containsCycle(vector<vector<char>>& grid)\\n    {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]<=\\'z\\'&&grid[i][j]>=\\'a\\')\\n                {\\n                    if(fun(grid,i,j,grid[i][j]))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool fun(vector<vector<char>>&grid,int i,int j,char c)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(i<0||j<0||i>=m||j>=n)\\n            return false;\\n        char upper=toupper(c);\\n        \\n        if(grid[i][j]!=c&&grid[i][j]!=upper)\\n            return false;\\n        if(grid[i][j]==upper)\\n            return true;\\n\\n        grid[i][j]=upper;\\n        bool b1=fun(grid,i+1,j,c);\\n        bool b2=fun(grid,i-1,j,c);\\n        bool b3=fun(grid,i,j+1,c);\\n        bool b4=fun(grid,i,j-1,c);\\n        int count=0;\\n        if(b1)\\n            count++;\\n        if(b2)\\n            count++;\\n        if(b3)\\n            count++;\\n        if(b4)\\n            count++;\\n        ans=max(ans,count);\\n        return ans>=2;\\n      \\n    }\\n    bool containsCycle(vector<vector<char>>& grid)\\n    {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]<=\\'z\\'&&grid[i][j]>=\\'a\\')\\n                {\\n                    if(fun(grid,i,j,grid[i][j]))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667217,
                "title": "dfs-java-most-simplest-easy-to-understand",
                "content": "This java soultion is easy to undestand and follows standard DFS algo, It is also easy to explain in interviews to the panel.\\nTC - O(N  * M) \\nSC - O(N  * M)\\nwhere,\\nN - graph.length, M = graph[0].length;\\n\\n**Math.abs(dist[x][y] - dist[r][c]) >= 3)** This checks if length of cycle is greater than or equal to 4.\\n***why then >=3*** in my code \\n\\n *Because,  I have passed starting path length as 1 and I am incrementing 1 each time and hence when it\\'s reaches the block which is adjacent to starting block the minimum dist value will be 4 in it, so the diff will be >=3.*\\n\\n```\\n\\nclass Solution {\\n    int[][] dir = { {0,-1}, {-1,0}, {0,1}, {1,0} };\\n    \\n    public boolean containsCycle(char[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] dist = new int[n][m];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(dist[i][j]==0){\\n                    if(dfs(1,i, j, n, m, grid, dist)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean dfs(int path, int r, int c,int n, int m, char[][] graph, int[][] dist){\\n        dist[r][c] = path;\\n        for(int d=0;d<4;d++){\\n            int x = r + dir[d][0];\\n            int y = c + dir[d][1];\\n            if(x>=0 && x<n && y>=0 && y<m && graph[r][c] == graph[x][y]){\\n                if(dist[x][y]==0){\\n                    if(dfs(path + 1, x, y, n, m, graph, dist)) return true;\\n                } else if(Math.abs(dist[x][y] - dist[r][c]) >= 3){\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution {\\n    int[][] dir = { {0,-1}, {-1,0}, {0,1}, {1,0} };\\n    \\n    public boolean containsCycle(char[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] dist = new int[n][m];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(dist[i][j]==0){\\n                    if(dfs(1,i, j, n, m, grid, dist)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean dfs(int path, int r, int c,int n, int m, char[][] graph, int[][] dist){\\n        dist[r][c] = path;\\n        for(int d=0;d<4;d++){\\n            int x = r + dir[d][0];\\n            int y = c + dir[d][1];\\n            if(x>=0 && x<n && y>=0 && y<m && graph[r][c] == graph[x][y]){\\n                if(dist[x][y]==0){\\n                    if(dfs(path + 1, x, y, n, m, graph, dist)) return true;\\n                } else if(Math.abs(dist[x][y] - dist[r][c]) >= 3){\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603709,
                "title": "c-intuitive-basics-of-graph-and-dfs",
                "content": "Its just like when you find a cycyle in undirected graph, by maintaing the ***parent*** and ***visited*** record. \\nIn the below code, it can be observed that I am just doing the same. \\n```\\nclass Solution {\\npublic:\\n\\t// For the movements\\n\\tint dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,1,0,-1};\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector <vector <int>> visited(m,vector<int>(n,0));\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(!visited[i][j]){\\n                    if(detect(i,j,-1,-1,m,n,grid,visited)) return true;      // iF we find a cycle of some character, only then return true\\n                }\\n            }\\n        }\\n\\t\\t// iF cycle of any character is not found!!\\n        return false;\\n    }\\nprotected:\\n\\t//Checking the validity of any cell\\n    bool isvalid(int x, int y, int m, int n, char c, vector <vector<char>>&grid){\\n        if(x<0 or x>=m or y<0 or y>=n) return false;\\n        if(grid[x][y]!=c) return false;\\n        return true;\\n    }\\n    bool detect(int x, int y, int px, int py, int m, int n,vector <vector <char>>&grid, vector<vector<int>>&visited){\\n       // iF we encounter a cell, which is already visited, then that means we have a cycle. Voila! Return TRUE!\\n\\t   if(visited[x][y]) return true;\\n\\t   \\n\\t   //iF visiting for the first time, mark it.\\n        visited[x][y] = 1;\\n       \\n\\t   for(int i = 0; i<4; i++){\\n            if(isvalid(x+dx[i],y+dy[i],m,n,grid[x][y],grid)){\\n\\t\\t\\t\\t// Check if we are not moving to the parent cell\\n                if((x+dx[i]!=px or y+dy[i]!=py) and detect(x+dx[i],y+dy[i],x,y,m,n,grid,visited)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// For the movements\\n\\tint dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,1,0,-1};\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector <vector <int>> visited(m,vector<int>(n,0));\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(!visited[i][j]){\\n                    if(detect(i,j,-1,-1,m,n,grid,visited)) return true;      // iF we find a cycle of some character, only then return true\\n                }\\n            }\\n        }\\n\\t\\t// iF cycle of any character is not found!!\\n        return false;\\n    }\\nprotected:\\n\\t//Checking the validity of any cell\\n    bool isvalid(int x, int y, int m, int n, char c, vector <vector<char>>&grid){\\n        if(x<0 or x>=m or y<0 or y>=n) return false;\\n        if(grid[x][y]!=c) return false;\\n        return true;\\n    }\\n    bool detect(int x, int y, int px, int py, int m, int n,vector <vector <char>>&grid, vector<vector<int>>&visited){\\n       // iF we encounter a cell, which is already visited, then that means we have a cycle. Voila! Return TRUE!\\n\\t   if(visited[x][y]) return true;\\n\\t   \\n\\t   //iF visiting for the first time, mark it.\\n        visited[x][y] = 1;\\n       \\n\\t   for(int i = 0; i<4; i++){\\n            if(isvalid(x+dx[i],y+dy[i],m,n,grid[x][y],grid)){\\n\\t\\t\\t\\t// Check if we are not moving to the parent cell\\n                if((x+dx[i]!=px or y+dy[i]!=py) and detect(x+dx[i],y+dy[i],x,y,m,n,grid,visited)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593310,
                "title": "python-46-time-75-space-clean-easy-readable-code-dfs-explained-10-20-lines",
                "content": "```\\nclass Solution(object):\\n    def containsCycle(self, grid):\\n        visited = dict()\\n        for i,j in product(range(len(grid)), range(len(grid[0]))):\\n            target = grid[i][j]\\n           \\n            stack = [(i,j,0)]\\n            while stack:\\n                x,y,moves = stack.pop()\\n                if not (0<=x<len(grid) and 0<=y<len(grid[0])):\\n                    continue\\n                if grid[x][y]!=target:\\n                    continue\\n                if (x,y) in visited:\\n                    if moves-visited[(x,y)]>3:\\n                        return True\\n                    continue\\n                visited[(x,y)] = moves\\n                for di,dj in ((-1,0), (1,0), (0,1), (0,-1)):\\n                    stack.append((di+x, dj+y, moves+1))\\n        return False\\n```\\n*using **stack** will be faster than recursion*\\n- we will do **dfs** on every grid point\\n- `moves`:  # of moves to reach gridpoint from starting point `(i,j)`\\n- `visited`: **key**: gridpoints **value**: `moves`\\n- we will **not** branch further if any of these 3 condition occur:\\n\\t1. out of bounds\\n\\t2. the value at grid point does not equal our `target` value\\n\\t3. we have visited this gridpoint the last 3 moves\\n- if we reach a gridpoint that\\'s already in `visited` and we\\'re **more than** 3 moves away,\\nwe have **satisfied** the same-value-cycle condition\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def containsCycle(self, grid):\\n        visited = dict()\\n        for i,j in product(range(len(grid)), range(len(grid[0]))):\\n            target = grid[i][j]\\n           \\n            stack = [(i,j,0)]\\n            while stack:\\n                x,y,moves = stack.pop()\\n                if not (0<=x<len(grid) and 0<=y<len(grid[0])):\\n                    continue\\n                if grid[x][y]!=target:\\n                    continue\\n                if (x,y) in visited:\\n                    if moves-visited[(x,y)]>3:\\n                        return True\\n                    continue\\n                visited[(x,y)] = moves\\n                for di,dj in ((-1,0), (1,0), (0,1), (0,-1)):\\n                    stack.append((di+x, dj+y, moves+1))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493666,
                "title": "bfs-solution-c",
                "content": "Similar to cyclic graph question \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool bfs(vector<vector<char>>& grid, int r, int c, vector<vector<bool>> &v,char curr){\\n        \\n        queue<pair<int,int>> q;\\n        \\n        q.push({r,c});\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        while(!q.empty()){\\n            \\n            auto rem = q.front();\\n            q.pop();\\n            \\n            r = rem.first;\\n            c = rem.second;\\n            \\n            if(v[r][c] == true)\\n                return true;\\n            \\n            v[r][c] = true;\\n            \\n            if(r-1>=0 && grid[r-1][c] == curr && !v[r-1][c])\\n                q.push({r-1,c});\\n            \\n            if(r+1<n && grid[r+1][c] == curr && !v[r+1][c])\\n                q.push({r+1,c});\\n            \\n            if(c-1>=0 && grid[r][c-1] == curr && !v[r][c-1])\\n                q.push({r,c-1});\\n            \\n            if(c+1<m && grid[r][c+1] == curr && !v[r][c+1])\\n                q.push({r,c+1});\\n            \\n        }\\n            \\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        vector<vector<bool>> v(n, vector<bool>(m, false));\\n        \\n        for(int i = 0 ; i < grid.size() ; i++){\\n            \\n            for(int j = 0 ; j < grid[0].size() ; j++){\\n                \\n                if(!v[i][j] && bfs(grid, i, j, v, grid[i][j]) )\\n                    return true;\\n                \\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool bfs(vector<vector<char>>& grid, int r, int c, vector<vector<bool>> &v,char curr){\\n        \\n        queue<pair<int,int>> q;\\n        \\n        q.push({r,c});\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        while(!q.empty()){\\n            \\n            auto rem = q.front();\\n            q.pop();\\n            \\n            r = rem.first;\\n            c = rem.second;\\n            \\n            if(v[r][c] == true)\\n                return true;\\n            \\n            v[r][c] = true;\\n            \\n            if(r-1>=0 && grid[r-1][c] == curr && !v[r-1][c])\\n                q.push({r-1,c});\\n            \\n            if(r+1<n && grid[r+1][c] == curr && !v[r+1][c])\\n                q.push({r+1,c});\\n            \\n            if(c-1>=0 && grid[r][c-1] == curr && !v[r][c-1])\\n                q.push({r,c-1});\\n            \\n            if(c+1<m && grid[r][c+1] == curr && !v[r][c+1])\\n                q.push({r,c+1});\\n            \\n        }\\n            \\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        vector<vector<bool>> v(n, vector<bool>(m, false));\\n        \\n        for(int i = 0 ; i < grid.size() ; i++){\\n            \\n            for(int j = 0 ; j < grid[0].size() ; j++){\\n                \\n                if(!v[i][j] && bfs(grid, i, j, v, grid[i][j]) )\\n                    return true;\\n                \\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443279,
                "title": "simple-dfs-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool cycle(vector<vector<char>>& grid ,vector<vector<bool>> &visited, char c,int i,int j,int row, int col,int len,int parrow,int parcol)\\n    {\\n        //boundary checks\\n        if(i<0||j<0||i>=row||j>=col)\\n            return false;\\n        //if different character return false\\n        if(grid[i][j]!=c)\\n            return false;\\n        //minimum length of cycle has to be 4\\n        if(visited[i][j] && len>=4 && grid[i][j]==c)\\n            return true;\\n        //discard if less than 4 and node visited\\n        if(visited[i][j]&& len<4 && grid[i][j]==c)\\n            return false;\\n        visited[i][j] =true;\\n        //we use parrow and parrcol to track that the cycle is not coming from parent \\n        bool  s = (cycle(grid,visited,c,i+1,j,row,col,len+1,i,j) && !( i+1 ==parrow && j==parcol)) || (cycle(grid,visited,c,i,j+1,row,col,len+1,i,j) &&!( i ==parrow && j+1==parcol))||(cycle(grid,visited,c,i-1,j,row,col,len+1,i,j) && !( i-1 ==parrow && j==parcol))||(cycle(grid,visited,c,i,j-1,row,col,len+1,i,j) &&  !( i ==parrow && j-1==parcol));\\n        return s;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) \\n    {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<bool>> visited(row,vector<bool>(col,false));\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(visited[i][j])\\n                    continue;\\n                //check for cycle if not visited yet\\n                if(cycle(grid,visited,grid[i][j],i,j,row,col,0,-1,-1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool cycle(vector<vector<char>>& grid ,vector<vector<bool>> &visited, char c,int i,int j,int row, int col,int len,int parrow,int parcol)\\n    {\\n        //boundary checks\\n        if(i<0||j<0||i>=row||j>=col)\\n            return false;\\n        //if different character return false\\n        if(grid[i][j]!=c)\\n            return false;\\n        //minimum length of cycle has to be 4\\n        if(visited[i][j] && len>=4 && grid[i][j]==c)\\n            return true;\\n        //discard if less than 4 and node visited\\n        if(visited[i][j]&& len<4 && grid[i][j]==c)\\n            return false;\\n        visited[i][j] =true;\\n        //we use parrow and parrcol to track that the cycle is not coming from parent \\n        bool  s = (cycle(grid,visited,c,i+1,j,row,col,len+1,i,j) && !( i+1 ==parrow && j==parcol)) || (cycle(grid,visited,c,i,j+1,row,col,len+1,i,j) &&!( i ==parrow && j+1==parcol))||(cycle(grid,visited,c,i-1,j,row,col,len+1,i,j) && !( i-1 ==parrow && j==parcol))||(cycle(grid,visited,c,i,j-1,row,col,len+1,i,j) &&  !( i ==parrow && j-1==parcol));\\n        return s;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) \\n    {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<bool>> visited(row,vector<bool>(col,false));\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(visited[i][j])\\n                    continue;\\n                //check for cycle if not visited yet\\n                if(cycle(grid,visited,grid[i][j],i,j,row,col,0,-1,-1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442437,
                "title": "simple-dfs-detect-cycle-in-undirected-graph-c",
                "content": "The idea is to check for back edges. If while doing DFS, a back edge is encountered(an edge leading from the current node to some of it\\'s ancestor node except it\\'s parent), return true else false.\\n\\n    bool incl[501][501];\\n    bool DFS(int i1,int j1,int x,int y,vector<vector<char>>&grid,char &ch){\\n        incl[x][y]=1;\\n        vector<pair<int,int>>v={{0,1},{1,0},{-1,0},{0,-1}};\\n        for(int i=0;i<v.size();i++){\\n            if(x+v[i].first<0 || x+v[i].first>=grid.size() || y+v[i].second<0 || y+v[i].second>=grid[0].size())\\n                continue;\\n            if(grid[x+v[i].first][y+v[i].second]!=ch)\\n                continue;\\n            if(x+v[i].first==i1 && y+v[i].second==j1)\\n                continue;\\n            \\n            if(incl[x+v[i].first][y+v[i].second])\\n                return true;\\n            if(DFS(x,y,x+v[i].first,y+v[i].second,grid,ch))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        if(grid.size()==0 || grid[0].size()==0)\\n            return 0;\\n        \\n        memset(incl,0,sizeof(incl));\\n        for(int i=0;i<grid.size()-1;i++)\\n            for(int j=0;j<grid[0].size()-1;j++){\\n               if(!incl[i][j]){ \\n                char ch=grid[i][j];   \\n                if(DFS(-1,-1,i,j,grid,ch))\\n                    return true;            //i j parent\\n               }\\n            }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "The idea is to check for back edges. If while doing DFS, a back edge is encountered(an edge leading from the current node to some of it\\'s ancestor node except it\\'s parent), return true else false.\\n\\n    bool incl[501][501];\\n    bool DFS(int i1,int j1,int x,int y,vector<vector<char>>&grid,char &ch){\\n        incl[x][y]=1;\\n        vector<pair<int,int>>v={{0,1},{1,0},{-1,0},{0,-1}};\\n        for(int i=0;i<v.size();i++){\\n            if(x+v[i].first<0 || x+v[i].first>=grid.size() || y+v[i].second<0 || y+v[i].second>=grid[0].size())\\n                continue;\\n            if(grid[x+v[i].first][y+v[i].second]!=ch)\\n                continue;\\n            if(x+v[i].first==i1 && y+v[i].second==j1)\\n                continue;\\n            \\n            if(incl[x+v[i].first][y+v[i].second])\\n                return true;\\n            if(DFS(x,y,x+v[i].first,y+v[i].second,grid,ch))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        if(grid.size()==0 || grid[0].size()==0)\\n            return 0;\\n        \\n        memset(incl,0,sizeof(incl));\\n        for(int i=0;i<grid.size()-1;i++)\\n            for(int j=0;j<grid[0].size()-1;j++){\\n               if(!incl[i][j]){ \\n                char ch=grid[i][j];   \\n                if(DFS(-1,-1,i,j,grid,ch))\\n                    return true;            //i j parent\\n               }\\n            }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1355695,
                "title": "faster-than-86-easy-dfs-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool vis[501][501];\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(!vis[i][j]){\\n                    if(solve(grid,i,j,-1,-1))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool solve(vector<vector<char>>& grid,int i,int j,int pi,int pj){\\n        if(i>=grid.size()||i<0||j>=grid[0].size()||j<0)\\n            return false;\\n        if(vis[i][j]==true)\\n            return true;\\n        \\n        vis[i][j]=true;\\n        if(i+1!=pi&&i+1<grid.size()&&grid[i+1][j]==grid[i][j]){\\n            if(solve(grid,i+1,j,i,j))\\n                return true;\\n        }\\n        if(i-1!=pi&&i-1>=0&&grid[i-1][j]==grid[i][j]){\\n            if(solve(grid,i-1,j,i,j))\\n                return true;\\n        }\\n        if(j+1!=pj&&j+1<grid[0].size()&&grid[i][j+1]==grid[i][j]){\\n            if(solve(grid,i,j+1,i,j))\\n                return true;\\n        }\\n        if(j-1!=pj&&j-1>=0&&grid[i][j-1]==grid[i][j]){\\n            if(solve(grid,i,j-1,i,j))\\n                return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool vis[501][501];\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(!vis[i][j]){\\n                    if(solve(grid,i,j,-1,-1))\\n                        return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1163139,
                "title": "java-straightforward-solution-using-union-find",
                "content": "I\\'m not sure why this is a hard problem on LC. It is a pretty straightforward problem using DFS or Union-Find. I solved it by implementing a full UF data structure. Traverse the matrix, and at each point, if its neighbors (only look right or down to avoid duplicates) are of the same letters, then check if they are already connected with the current point. If so a loop is detected, else connect the two points and continue with the loop.\\n\\n```java\\nclass Solution {\\n    private int m, n;\\n    \\n    public boolean containsCycle(char[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        int[] rowDir = {0, 1}, colDir = {1, 0};\\n        UF connectivity = new UF(m*n);\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                for (int d = 0; d < 2; d++) {\\n                    if (r + rowDir[d] < 0 || r + rowDir[d] == m || c + colDir[d] < 0 || c + colDir[d] == n) {\\n                        continue;\\n                    }\\n                    \\n                    if (grid[r][c] == grid[r + rowDir[d]][c + colDir[d]]) {\\n                        if (connectivity.find(coord2ind(r, c), coord2ind(r + rowDir[d], c + colDir[d]))) {\\n                            // System.out.printf(\"(%s, %s), (%s, %s)\", r, c, r + rowDir[d], c + colDir[d]);\\n                            return true;\\n                        }\\n                        \\n                        connectivity.union(coord2ind(r, c), coord2ind(r + rowDir[d], c + colDir[d]));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int coord2ind(int row, int col) {\\n        return row * n + col;\\n    }\\n    \\n    private class UF {\\n        private int[] parents, treeSizes;\\n        \\n        public UF(int size) {\\n            parents = new int[size];\\n            treeSizes = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                parents[i] = i;\\n                treeSizes[i] = 1;\\n            }\\n        }\\n        \\n        public void union(int node1, int node2) {\\n            int r1 = getRoot(node1), r2 = getRoot(node2);\\n            if (r1 == r2) {\\n                return;\\n            }\\n            \\n            if (treeSizes[r1] > treeSizes[r2]) {\\n                parents[r2] = r1;\\n                treeSizes[r1] += treeSizes[r2];\\n            } else {\\n                parents[r1] = r2;\\n                treeSizes[r2] += treeSizes[r1];\\n            }\\n        }\\n        \\n        public boolean find(int node1, int node2) {\\n            return getRoot(node1) == getRoot(node2);\\n        }\\n        \\n        private int getRoot(int node) {\\n            while (node != parents[node]) {\\n                parents[node] = parents[parents[node]];\\n                node = parents[node];\\n            }\\n            \\n            return node;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```java\\nclass Solution {\\n    private int m, n;\\n    \\n    public boolean containsCycle(char[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        int[] rowDir = {0, 1}, colDir = {1, 0};\\n        UF connectivity = new UF(m*n);\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                for (int d = 0; d < 2; d++) {\\n                    if (r + rowDir[d] < 0 || r + rowDir[d] == m || c + colDir[d] < 0 || c + colDir[d] == n) {\\n                        continue;\\n                    }\\n                    \\n                    if (grid[r][c] == grid[r + rowDir[d]][c + colDir[d]]) {\\n                        if (connectivity.find(coord2ind(r, c), coord2ind(r + rowDir[d], c + colDir[d]))) {\\n                            // System.out.printf(\"(%s, %s), (%s, %s)\", r, c, r + rowDir[d], c + colDir[d]);\\n                            return true;\\n                        }\\n                        \\n                        connectivity.union(coord2ind(r, c), coord2ind(r + rowDir[d], c + colDir[d]));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int coord2ind(int row, int col) {\\n        return row * n + col;\\n    }\\n    \\n    private class UF {\\n        private int[] parents, treeSizes;\\n        \\n        public UF(int size) {\\n            parents = new int[size];\\n            treeSizes = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                parents[i] = i;\\n                treeSizes[i] = 1;\\n            }\\n        }\\n        \\n        public void union(int node1, int node2) {\\n            int r1 = getRoot(node1), r2 = getRoot(node2);\\n            if (r1 == r2) {\\n                return;\\n            }\\n            \\n            if (treeSizes[r1] > treeSizes[r2]) {\\n                parents[r2] = r1;\\n                treeSizes[r1] += treeSizes[r2];\\n            } else {\\n                parents[r1] = r2;\\n                treeSizes[r2] += treeSizes[r1];\\n            }\\n        }\\n        \\n        public boolean find(int node1, int node2) {\\n            return getRoot(node1) == getRoot(node2);\\n        }\\n        \\n        private int getRoot(int node) {\\n            while (node != parents[node]) {\\n                parents[node] = parents[parents[node]];\\n                node = parents[node];\\n            }\\n            \\n            return node;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146166,
                "title": "java-dfs-3-color-traverse",
                "content": "We can use 3-color to detect whether there is a cycle in graph.\\n0 -> Never visited\\n1 -> Visiting\\n2 -> Visited\\n\\nLet\\'s say we are traversing in certain path, all node in this path before are colored 1, then \\nif we met a node colored 2, means there is a cycle in this path.\\nIf we met a node colored 1, this is the parent node we just visitied.\\n\\n```class Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int[][] M = new int[grid.length][grid[0].length];\\n        for(int i = 0; i < grid.length; i ++){\\n            for(int j = 0; j < grid[0].length; j ++){\\n                if(M[i][j] == 0 && dfs(grid, grid[i][j], i, j, M)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public boolean dfs(char[][] grid, char c, int i, int j, int[][] M){\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != c){\\n            return false;\\n        }\\n        if(M[i][j] == 2){\\n            return true;\\n        }\\n        if(M[i][j] == 1){\\n            return false;\\n        }\\n        M[i][j] = 1;\\n        for(int[] dir : dirs){\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            if(dfs(grid, c, ni, nj, M)){\\n                return true;\\n            }\\n        }\\n        M[i][j] = 2;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int[][] M = new int[grid.length][grid[0].length];\\n        for(int i = 0; i < grid.length; i ++){\\n            for(int j = 0; j < grid[0].length; j ++){\\n                if(M[i][j] == 0 && dfs(grid, grid[i][j], i, j, M)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public boolean dfs(char[][] grid, char c, int i, int j, int[][] M){\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != c){\\n            return false;\\n        }\\n        if(M[i][j] == 2){\\n            return true;\\n        }\\n        if(M[i][j] == 1){\\n            return false;\\n        }\\n        M[i][j] = 1;\\n        for(int[] dir : dirs){\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            if(dfs(grid, c, ni, nj, M)){\\n                return true;\\n            }\\n        }\\n        M[i][j] = 2;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815616,
                "title": "java-dfs-explained",
                "content": "It\\'s a pretty standard problem with traversing grid via Dfs approach, of course with few catches:\\nneed to track previous cell, otherwise if allway find the cycle if we check the cell we came from\\neasier to keep array of visited cells rather than mark cells in the grid itself - such solution wil no diffirenciate between visited on a previous iteration in scope of currenct Dfs session  and visited previously. \\n\\nO(rows x cols) time - visit every cell once\\nO(rows x cols) space - need to keep array of visited cells plus stack for the Dfs itself.\\n\\n```\\n    public boolean containsCycle(char[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n        boolean[][] visited = new boolean[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                if (!visited[r][c] && dfs(grid, r, c, grid[r][c], -1, -1, visited)) {\\n                    return true;\\n                } \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    boolean dfs(char[][] grid, int r, int c, char ch, int prevR, int prevC, boolean[][] visited) {\\n        visited[r][c] = true;\\n        boolean isCycle = false;\\n\\t\\t//for each possible next cell check following:\\n\\t\\t//if cell exists on grid, if its not the cell we came from, if it has the same character as one we started from \\n\\t\\t//if all above is true and we have visited it before - it\\'s a cycle\\n        if (!isCycle && r - 1 >= 0 && (r - 1 != prevR || c != prevC) && grid[r - 1][c] == ch) {\\n            if (visited[r - 1][c])\\n                return true;\\n            isCycle |= dfs(grid, r - 1, c, ch, r, c, visited);\\n        }\\n        if (!isCycle && c - 1 >= 0 && (r != prevR || c - 1 != prevC) && grid[r][c - 1] == ch) {\\n            if (visited[r][c - 1])\\n                return true;\\n            isCycle |= dfs(grid, r, c - 1, ch, r, c, visited);\\n        }\\n        if (!isCycle && r + 1 < grid.length && (r + 1 != prevR || c != prevC) && grid[r + 1][c] == ch) {\\n            if (visited[r + 1][c])\\n                return true;\\n            isCycle |= dfs(grid, r + 1, c, ch, r, c, visited);\\n        }\\n        if (!isCycle && c + 1 < grid[0].length && (r != prevR || c + 1 != prevC) && grid[r][c + 1] == ch) {\\n            if (visited[r][c + 1])\\n                return true;\\n            isCycle |= dfs(grid, r, c + 1, ch, r, c, visited);\\n        }\\n        return isCycle;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public boolean containsCycle(char[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n        boolean[][] visited = new boolean[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                if (!visited[r][c] && dfs(grid, r, c, grid[r][c], -1, -1, visited)) {\\n                    return true;\\n                } \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    boolean dfs(char[][] grid, int r, int c, char ch, int prevR, int prevC, boolean[][] visited) {\\n        visited[r][c] = true;\\n        boolean isCycle = false;\\n\\t\\t//for each possible next cell check following:\\n\\t\\t//if cell exists on grid, if its not the cell we came from, if it has the same character as one we started from \\n\\t\\t//if all above is true and we have visited it before - it\\'s a cycle\\n        if (!isCycle && r - 1 >= 0 && (r - 1 != prevR || c != prevC) && grid[r - 1][c] == ch) {\\n            if (visited[r - 1][c])\\n                return true;\\n            isCycle |= dfs(grid, r - 1, c, ch, r, c, visited);\\n        }\\n        if (!isCycle && c - 1 >= 0 && (r != prevR || c - 1 != prevC) && grid[r][c - 1] == ch) {\\n            if (visited[r][c - 1])\\n                return true;\\n            isCycle |= dfs(grid, r, c - 1, ch, r, c, visited);\\n        }\\n        if (!isCycle && r + 1 < grid.length && (r + 1 != prevR || c != prevC) && grid[r + 1][c] == ch) {\\n            if (visited[r + 1][c])\\n                return true;\\n            isCycle |= dfs(grid, r + 1, c, ch, r, c, visited);\\n        }\\n        if (!isCycle && c + 1 < grid[0].length && (r != prevR || c + 1 != prevC) && grid[r][c + 1] == ch) {\\n            if (visited[r][c + 1])\\n                return true;\\n            isCycle |= dfs(grid, r, c + 1, ch, r, c, visited);\\n        }\\n        return isCycle;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807464,
                "title": "python3-two-solutions-explained-dsu-3-state-dfs",
                "content": "This is a collection of two unique solutions/approaches that might help you to learn/study new concepts and use the templates in other problems.The idea of writing multiple solutions to a single problem is to become able to tackle many other similar problems but not to just simply solve the problem.Now,Into the solution :) =>>>\\n\\nMost prefered solution by many for some reason. DFS\\nSolution-1\\n```python\\nfrom collections import defaultdict\\ndirections = [(0,1),(1,0),(0,-1),(-1,0)]\\nclass Solution:\\n    def containsCycle(self, grid):\\n        WHITE,GRAY,BLACK = 0 ,1 ,2\\n        R,C = len(grid),len(grid[0])\\n        \\n        color = defaultdict(int)#default:WHITE\\n        #Through dfs if we visit a node thats GRAY or BLACK,then a cycle exists\\n        \\n        #3-state-DFS method, WHITE: unvisited GRAY:visited but not yet explored , BLACK:visited and completely explored\\n        #visited:touched,explored:visited all its neighbors\\n        #current_node:(r,c) , previous_node:(pr,pc)\\n        def dfs(r,c,pr=-1,pc=-1):\\n            color[r,c] = GRAY\\n            for x,y in directions:\\n                nr,nc = r+x,c+y\\n                if (0<=nr<R and\\n                    0<=nc<C and\\n                    grid[r][c] == grid[nr][nc] and\\n                    (nr,nc)!=(pr,pc)\\n                   ):\\n                    if color[nr,nc]==WHITE:#unvisited node,so do dfs first,then return the output of the dfs if True.\\n                        if dfs(nr,nc,r,c):\\n                            return True\\n                    elif color[nr,nc] == GRAY:#visiting a node that was already visited,=>cycle exists\\n                        return True\\n                    \\n            color[r,c] = BLACK\\n            return False\\n            \\n        for r in range(R):\\n            for c in range(C):\\n                if color[r,c] == WHITE:\\n                    if dfs(r,c):\\n                        return True\\n        return False\\n```\\nEasiest solution or solution-2\\n```\\nThe idea is to find existence of a cycle in the matrix with same characters.\\nThe simplest and straight-forward approach to find presence of cycles in a graph\\nis to use DSU(Disjoing Set Union).\\nUseful for representing a set of connected nodes as a single.\\nConnected Components.\\nHow this is useful in this problem?\\nIf there is a cycle,we definitely add edges between the nodes of an already connected\\ncomponent.\\n\\n1->2  a->a\\n   |  |  |\\n4<-3  a<-a\\n\\nHere,we start connecting. (1,2) (1,4) (2,3)=>Now 1,2,3,4 belong to same component.\\nThen when we try to union the (4,3) we know the both nodes belong to same component.\\nSo,there is a cycle as we can reach each node in 2 directions.\\n```\\n\\n```python\\nclass DSU:\\n    def __init__(self,m,n):\\n        self.par = {(i,j):(i,j) for i in range(m) for j in range(n)}\\n    \\n    def find(self,x):\\n        if self.par[x]!=x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    \\n    def union(self,x,y):\\n        xp,yp = self.find(x),self.find(y)\\n        if xp == yp:\\n            return False\\n        self.par[xp] = yp\\n        return True\\n\\ndirs = [(0,1),(1,0)]\\nclass Solution:\\n    def containsCycle(self, grid):\\n        R,C = len(grid),len(grid[0])\\n        dsu = DSU(R,C)        \\n        for r in range(R):\\n            for c in range(C):\\n                for x,y in dirs:\\n                    nr,nc = r+x,c+y\\n                    if 0<=nr<R and 0<=nc<C and grid[r][c] == grid[nr][nc]:\\n                        if dsu.union((r,c),(nr,nc)) == False:\\n                            return True\\n        return False\\n```\\nShow some love with upvotes if this helped you :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\nfrom collections import defaultdict\\ndirections = [(0,1),(1,0),(0,-1),(-1,0)]\\nclass Solution:\\n    def containsCycle(self, grid):\\n        WHITE,GRAY,BLACK = 0 ,1 ,2\\n        R,C = len(grid),len(grid[0])\\n        \\n        color = defaultdict(int)#default:WHITE\\n        #Through dfs if we visit a node thats GRAY or BLACK,then a cycle exists\\n        \\n        #3-state-DFS method, WHITE: unvisited GRAY:visited but not yet explored , BLACK:visited and completely explored\\n        #visited:touched,explored:visited all its neighbors\\n        #current_node:(r,c) , previous_node:(pr,pc)\\n        def dfs(r,c,pr=-1,pc=-1):\\n            color[r,c] = GRAY\\n            for x,y in directions:\\n                nr,nc = r+x,c+y\\n                if (0<=nr<R and\\n                    0<=nc<C and\\n                    grid[r][c] == grid[nr][nc] and\\n                    (nr,nc)!=(pr,pc)\\n                   ):\\n                    if color[nr,nc]==WHITE:#unvisited node,so do dfs first,then return the output of the dfs if True.\\n                        if dfs(nr,nc,r,c):\\n                            return True\\n                    elif color[nr,nc] == GRAY:#visiting a node that was already visited,=>cycle exists\\n                        return True\\n                    \\n            color[r,c] = BLACK\\n            return False\\n            \\n        for r in range(R):\\n            for c in range(C):\\n                if color[r,c] == WHITE:\\n                    if dfs(r,c):\\n                        return True\\n        return False\\n```\n```\\nThe idea is to find existence of a cycle in the matrix with same characters.\\nThe simplest and straight-forward approach to find presence of cycles in a graph\\nis to use DSU(Disjoing Set Union).\\nUseful for representing a set of connected nodes as a single.\\nConnected Components.\\nHow this is useful in this problem?\\nIf there is a cycle,we definitely add edges between the nodes of an already connected\\ncomponent.\\n\\n1->2  a->a\\n   |  |  |\\n4<-3  a<-a\\n\\nHere,we start connecting. (1,2) (1,4) (2,3)=>Now 1,2,3,4 belong to same component.\\nThen when we try to union the (4,3) we know the both nodes belong to same component.\\nSo,there is a cycle as we can reach each node in 2 directions.\\n```\n```python\\nclass DSU:\\n    def __init__(self,m,n):\\n        self.par = {(i,j):(i,j) for i in range(m) for j in range(n)}\\n    \\n    def find(self,x):\\n        if self.par[x]!=x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    \\n    def union(self,x,y):\\n        xp,yp = self.find(x),self.find(y)\\n        if xp == yp:\\n            return False\\n        self.par[xp] = yp\\n        return True\\n\\ndirs = [(0,1),(1,0)]\\nclass Solution:\\n    def containsCycle(self, grid):\\n        R,C = len(grid),len(grid[0])\\n        dsu = DSU(R,C)        \\n        for r in range(R):\\n            for c in range(C):\\n                for x,y in dirs:\\n                    nr,nc = r+x,c+y\\n                    if 0<=nr<R and 0<=nc<C and grid[r][c] == grid[nr][nc]:\\n                        if dsu.union((r,c),(nr,nc)) == False:\\n                            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806106,
                "title": "best-method-process-using-dfs-top-80-in-run-time-o-mn-complexity",
                "content": "The only way there is no cycle is if the cells form a tree. If there is more than one way to get from cell A to cell B, then there is a cycle.\\n\\n**Note**: We can disregard the \"*cycle length must be >=4*\" rule, there is no way to get a cycle of length 3.\\n\\nTime Complexity: **O(mn)**\\nSpace Complexity: **O(mn)**\\n\\n**Runtime**: 496 ms, faster than 80.00%.\\n\\n\\n\\n```\\nclass Solution\\n{\\n    const vector<vector<int>> possibleD = {{0, 1},\\n                                           {1, 0},\\n                                           {-1, 0},\\n                                           {0, -1}}; //Possible Directions\\n    int m, n;                                        //Grid Size\\n\\npublic:\\n    bool dfs(vector<vector<char>> &grid, int i, int j, char c, int dir)\\n    {\\n        if (i < 0 || i >= n || j < 0 || j >= m) // Checking borders\\n            return false;\\n        if (grid[i][j] == \\'0\\') // Checking for Cycle\\n            return true;\\n        if (grid[i][j] != c)\\n            return false;\\n\\n        grid[i][j] = \\'0\\';           // Marking current cell\\n        dir = 3 - dir;              // This is for not to traversing back/re-visit.\\n        for (int k = 0; k < 4; ++k) // Traversing all other three direction(which are not visited yet)\\n        {\\n            if (k != dir) // Unwanted/Visited direction\\n                if (dfs(grid, i + possibleD[k][0], j + possibleD[k][1], c, k))\\n                    return true;\\n        }\\n        grid[i][j] = \\' \\';\\n        return false;\\n    }\\n\\n    bool containsCycle(vector<vector<char>> &grid)\\n    {\\n        m = grid[0].size();\\n        n = grid.size();\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < m; ++j)\\n                if (grid[i][j] != \\' \\')\\n                    if (dfs(grid, i, j, grid[i][j], -1))\\n                        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    const vector<vector<int>> possibleD = {{0, 1},\\n                                           {1, 0},\\n                                           {-1, 0},\\n                                           {0, -1}}; //Possible Directions\\n    int m, n;                                        //Grid Size\\n\\npublic:\\n    bool dfs(vector<vector<char>> &grid, int i, int j, char c, int dir)\\n    {\\n        if (i < 0 || i >= n || j < 0 || j >= m) // Checking borders\\n            return false;\\n        if (grid[i][j] == \\'0\\') // Checking for Cycle\\n            return true;\\n        if (grid[i][j] != c)\\n            return false;\\n\\n        grid[i][j] = \\'0\\';           // Marking current cell\\n        dir = 3 - dir;              // This is for not to traversing back/re-visit.\\n        for (int k = 0; k < 4; ++k) // Traversing all other three direction(which are not visited yet)\\n        {\\n            if (k != dir) // Unwanted/Visited direction\\n                if (dfs(grid, i + possibleD[k][0], j + possibleD[k][1], c, k))\\n                    return true;\\n        }\\n        grid[i][j] = \\' \\';\\n        return false;\\n    }\\n\\n    bool containsCycle(vector<vector<char>> &grid)\\n    {\\n        m = grid[0].size();\\n        n = grid.size();\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < m; ++j)\\n                if (grid[i][j] != \\' \\')\\n                    if (dfs(grid, i, j, grid[i][j], -1))\\n                        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805857,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    vector<pair<int, int>> dirs = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\npublic:\\n    bool dfs(vector<vector<char>>& grid, vector<vector<int>>& isVisited, int row, int col, int dist, char cVal) {\\n        if(row < 0 || row >= grid.size() || col < 0 || col >= grid[row].size() || grid[row][col] != cVal) return false;\\n        \\n        if(isVisited[row][col]) {\\n            return (dist - isVisited[row][col]) >= 4 ? true: false;\\n        }\\n\\n        isVisited[row][col] = dist;\\n        int r, c;\\n        for(pair<int, int> dir: dirs) {\\n            r = row + dir.first;\\n            c = col + dir.second;\\n            if(dfs(grid, isVisited, r, c, dist+1, cVal)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        vector<vector<int>> isVisited(grid.size(), vector<int>(grid[0].size()));\\n        for(int row = 0; row < grid.size(); row++) {\\n            for(int col = 0; col < grid[row].size(); col++) {\\n                if(isVisited[row][col]) continue;\\n                if(dfs(grid, isVisited, row, col, 1, grid[row][col])) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<pair<int, int>> dirs = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\npublic:\\n    bool dfs(vector<vector<char>>& grid, vector<vector<int>>& isVisited, int row, int col, int dist, char cVal) {\\n        if(row < 0 || row >= grid.size() || col < 0 || col >= grid[row].size() || grid[row][col] != cVal) return false;\\n        \\n        if(isVisited[row][col]) {\\n            return (dist - isVisited[row][col]) >= 4 ? true: false;\\n        }\\n\\n        isVisited[row][col] = dist;\\n        int r, c;\\n        for(pair<int, int> dir: dirs) {\\n            r = row + dir.first;\\n            c = col + dir.second;\\n            if(dfs(grid, isVisited, r, c, dist+1, cVal)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        vector<vector<int>> isVisited(grid.size(), vector<int>(grid[0].size()));\\n        for(int row = 0; row < grid.size(); row++) {\\n            for(int col = 0; col < grid[row].size(); col++) {\\n                if(isVisited[row][col]) continue;\\n                if(dfs(grid, isVisited, row, col, 1, grid[row][col])) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805806,
                "title": "java-simple-dfs",
                "content": "Use DFS to find if there is a cycle.\\nThings to care: \\n1. What\\'s the previous position because we shouldn\\'t go backwards.\\n2. Out of bound or the adjacent cell contains different character.\\n3. if we encounter an already visited cell, we find a cycle.\\n```\\nclass Solution {\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = new int[m][n];\\n        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) {\\n            if (visited[i][j] == 0) {\\n                if (dfs(grid, i, j, visited, -1, -1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(char[][] g, int r, int c, int[][] visited, int prevR, int prevC) {\\n        visited[r][c] = 1;\\n        \\n        for (int[] d : dirs) {\\n            int nr = r + d[0];\\n            int nc = c + d[1];\\n            \\n            if (nr < 0 || nr >= g.length || nc < 0 || nc >= g[0].length || g[nr][nc] != g[r][c]) continue;\\n            if (nr == prevR && nc == prevC) continue;\\n            if (visited[nr][nc] == 1) return true;\\n            else if (dfs(g, nr, nc, visited, r, c)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = new int[m][n];\\n        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) {\\n            if (visited[i][j] == 0) {\\n                if (dfs(grid, i, j, visited, -1, -1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(char[][] g, int r, int c, int[][] visited, int prevR, int prevC) {\\n        visited[r][c] = 1;\\n        \\n        for (int[] d : dirs) {\\n            int nr = r + d[0];\\n            int nc = c + d[1];\\n            \\n            if (nr < 0 || nr >= g.length || nc < 0 || nc >= g[0].length || g[nr][nc] != g[r][c]) continue;\\n            if (nr == prevR && nc == prevC) continue;\\n            if (visited[nr][nc] == 1) return true;\\n            else if (dfs(g, nr, nc, visited, r, c)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805703,
                "title": "c-dfs-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. DFS\\n\\nWe can use DFS for each `A[x][y]` to see if we can form a circle from `A[x][y]`.\\n\\nLet `seen[x][y]` be the length of the sequence containing the same character ending with `A[x][y]`.\\n\\nIn the DFS, assume the next location we want to visit is `<a, b>`.\\n\\nWe shouldn\\'t visit `a, b` if either of these is true:\\n* `a, b` are out-of-bound.\\n* `A[a][b] != A[x][y]`\\n* `seen[a][b] != 0` and `seen[x][y] - seen[a][b] < 3`, meaning that we\\'ve visited `A[a][b]` in the sequence and the distance between `A[a][b]` and `A[x][y]` is too small to form a valid circle.\\n\\nOnce we find a `<a, b>` pair satisfying `seen[a][b] && seen[x][y] - seen[a][b] >= 3`, we\\'ve found a valid circle from `A[a][b]` to `A[x][y]` with length more than or equal to 4, and we can return `true`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-33/problems/detect-cycles-in-2d-grid/\\n// Author: github.com/lzl124631x\\n// Time: O(MN)\\n// Space: O(MN)\\nclass Solution {\\n    int M, N, seen[500][500] = {}, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n    bool dfs(vector<vector<char>>&A, int x, int y, int len) {\\n        seen[x][y] = len;\\n        for (auto &dir : dirs) {\\n            int a = x + dir[0], b = y + dir[1];\\n            if (a < 0 || b < 0 || a >= M || b >= N || A[a][b] != A[x][y] || (seen[a][b] && seen[x][y] - seen[a][b] < 3)) continue;\\n            if (seen[a][b] && seen[x][y] - seen[a][b] >= 3) return true;\\n            if (dfs(A, a, b, len + 1)) return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& A) {\\n        M = A.size(), N = A[0].size();\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (seen[i][j]) continue;\\n                if (dfs(A, i, j, 1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-33/problems/detect-cycles-in-2d-grid/\\n// Author: github.com/lzl124631x\\n// Time: O(MN)\\n// Space: O(MN)\\nclass Solution {\\n    int M, N, seen[500][500] = {}, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n    bool dfs(vector<vector<char>>&A, int x, int y, int len) {\\n        seen[x][y] = len;\\n        for (auto &dir : dirs) {\\n            int a = x + dir[0], b = y + dir[1];\\n            if (a < 0 || b < 0 || a >= M || b >= N || A[a][b] != A[x][y] || (seen[a][b] && seen[x][y] - seen[a][b] < 3)) continue;\\n            if (seen[a][b] && seen[x][y] - seen[a][b] >= 3) return true;\\n            if (dfs(A, a, b, len + 1)) return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& A) {\\n        M = A.size(), N = A[0].size();\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (seen[i][j]) continue;\\n                if (dfs(A, i, j, 1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805696,
                "title": "c-simple-dfs-with-explanation",
                "content": "#### Intuition\\nThe only way there is no cycle is if the cells form a tree. If there is more than one way to get from cell A to cell B, then there is a cycle.\\n\\nNote: We can disregard the \"cycle length must be >=4\" rule, there is no way to get a cycle of length 3.\\n\\n  Time: O(N*M)\\n```\\nclass Solution {\\npublic:\\n  int n,m;\\n  vector<vector<char>> grid;\\n  vector<vector<bool>> vis;\\n  char c; // tracks the current letter while DFS\\'ing\\n  const int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n  bool containsCycle(vector<vector<char>>& grid) {\\n    this->grid=grid;\\n    n=grid.size(), m=grid[0].size();\\n    vis.resize(n,vector<bool>(m));\\n    for(int i=0; i!=n; ++i){\\n      for(int j=0; j!=m; ++j){\\n        if(vis[i][j]) continue;\\n        c= grid[i][j];\\n        if(dfs(i,j,-1,-1)) return true;\\n      }\\n    }\\n    return false;\\n  } \\n  bool dfs(int i,int j,int pi,int pj){\\n    if(out(i,j) || grid[i][j]!=c) return false;\\n    if(vis[i][j]) return true;\\n    vis[i][j]= true;\\n    for(auto d:dir){\\n      int ni=i+d[0], nj=j+d[1];\\n      if(ni==pi && nj==pj) continue; // need to ensure we don\\'t go back to the parent\\n      if(dfs(ni,nj,i,j)) return true;\\n    }\\n    return false;\\n  }\\n  bool out(int i,int j){\\n    return i<0||i>=n||j<0||j>=m;\\n  }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int n,m;\\n  vector<vector<char>> grid;\\n  vector<vector<bool>> vis;\\n  char c; // tracks the current letter while DFS\\'ing\\n  const int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n  bool containsCycle(vector<vector<char>>& grid) {\\n    this->grid=grid;\\n    n=grid.size(), m=grid[0].size();\\n    vis.resize(n,vector<bool>(m));\\n    for(int i=0; i!=n; ++i){\\n      for(int j=0; j!=m; ++j){\\n        if(vis[i][j]) continue;\\n        c= grid[i][j];\\n        if(dfs(i,j,-1,-1)) return true;\\n      }\\n    }\\n    return false;\\n  } \\n  bool dfs(int i,int j,int pi,int pj){\\n    if(out(i,j) || grid[i][j]!=c) return false;\\n    if(vis[i][j]) return true;\\n    vis[i][j]= true;\\n    for(auto d:dir){\\n      int ni=i+d[0], nj=j+d[1];\\n      if(ni==pi && nj==pj) continue; // need to ensure we don\\'t go back to the parent\\n      if(dfs(ni,nj,i,j)) return true;\\n    }\\n    return false;\\n  }\\n  bool out(int i,int j){\\n    return i<0||i>=n||j<0||j>=m;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805678,
                "title": "python-detect-cycle-in-a-undirected-graph",
                "content": "Intuition:\\n1. We want to detect cycle in a graph. union-find is a common algorithm for this purpose.\\n2. It is not necessary to build a real graph as we may only connect to `above` and `left` vertices while scanning the matrix.\\n\\n```python\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        uf = {}\\n        def find(x):\\n            uf.setdefault(x, x)\\n            if x != uf[x]:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        def union(x, y): # y->x\\n            uf[find(y)] = find(x)\\n    \\n        def check(r, c):\\n            for rr, cc in [(0, -1), (-1, 0)]:\\n                x, y = r+rr, c+cc\\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == grid[r][c]:\\n                    if find((x, y)) == find((r, c)):\\n                        return True\\n                    union((r, c), (x, y))\\n            return False\\n        \\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if check(i, j):\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        uf = {}\\n        def find(x):\\n            uf.setdefault(x, x)\\n            if x != uf[x]:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        def union(x, y): # y->x\\n            uf[find(y)] = find(x)\\n    \\n        def check(r, c):\\n            for rr, cc in [(0, -1), (-1, 0)]:\\n                x, y = r+rr, c+cc\\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == grid[r][c]:\\n                    if find((x, y)) == find((r, c)):\\n                        return True\\n                    union((r, c), (x, y))\\n            return False\\n        \\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if check(i, j):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805676,
                "title": "easy-c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> direction={0, -1, 0, 1, 0};\\n    vector<vector<bool>> visited;\\n    bool DFS(vector<vector<char>>& grid, int i, int j, int pi, int pj){\\n        \\n        for(int d=0; d<4; d++){\\n            int row=i+direction[d];\\n            int col=j+direction[d+1];\\n            \\n            if(row>=0 && row<grid.size() && col>=0 && col<grid[0].size()){\\n                if(visited[row][col] && pi!=row && pj!=col && grid[row][col]==grid[i][j])\\n                    return true;\\n                \\n                if(visited[row][col] || grid[row][col]!=grid[i][j]) continue;\\n                \\n                visited[row][col]=true;\\n                if(DFS(grid, row, col, i, j))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        visited = vector<vector<bool>> (m, vector<bool>(n, false));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(!visited[i][j]){\\n                    visited[i][j]=true;\\n                    if(DFS(grid, i, j, -1, -1))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> direction={0, -1, 0, 1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 3982195,
                "title": "easy-to-understand-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,unordered_set<int>>adj;\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    void fill(int i,int j,vector<vector<char>>&grid){\\n        int n=grid.size(),m=grid[0].size();\\n        int u=i*m+j;\\n\\n        for(int ind=0;ind<4;ind++){\\n            int a=i+dir[ind][0];\\n            int b=j+dir[ind][1];\\n\\n            if(a>=0 and b>=0 and a<n and b<m and grid[a][b]==grid[i][j]){\\n                int v=a*m+b;\\n\\n                adj[u].insert(v);\\n            }\\n        }\\n\\n        return;\\n    }\\n     bool dfsCycle(int node,int par,bool viss[]){\\n        viss[node]=true;\\n        \\n        for(auto it:adj[node]){\\n            if(!viss[it]){\\n                if(dfsCycle(it,node,viss)) return true;\\n            }\\n            else if(viss[it] and it!=par) return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        adj.clear();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                fill(i,j,grid);\\n            }\\n        }\\n\\n        bool viss[n*m+1];\\n        memset(viss,false,sizeof(viss));\\n\\n        for(int i=0;i<n*m;i++){\\n            if(!viss[i] and dfsCycle(i,-1,viss)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,unordered_set<int>>adj;\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    void fill(int i,int j,vector<vector<char>>&grid){\\n        int n=grid.size(),m=grid[0].size();\\n        int u=i*m+j;\\n\\n        for(int ind=0;ind<4;ind++){\\n            int a=i+dir[ind][0];\\n            int b=j+dir[ind][1];\\n\\n            if(a>=0 and b>=0 and a<n and b<m and grid[a][b]==grid[i][j]){\\n                int v=a*m+b;\\n\\n                adj[u].insert(v);\\n            }\\n        }\\n\\n        return;\\n    }\\n     bool dfsCycle(int node,int par,bool viss[]){\\n        viss[node]=true;\\n        \\n        for(auto it:adj[node]){\\n            if(!viss[it]){\\n                if(dfsCycle(it,node,viss)) return true;\\n            }\\n            else if(viss[it] and it!=par) return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        adj.clear();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                fill(i,j,grid);\\n            }\\n        }\\n\\n        bool viss[n*m+1];\\n        memset(viss,false,sizeof(viss));\\n\\n        for(int i=0;i<n*m;i++){\\n            if(!viss[i] and dfsCycle(i,-1,viss)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628523,
                "title": "bfs-c-very-simple-approach",
                "content": "# if it Helps you, Please Upvote Me....!\\n\\n---\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is Same as **\"detecte Cycle in Undirected Graph\"** here i apply **BFS Traversal** to Travers the **Adjacent Cell** if Cell is already visited then i **check the parent cell** if **parent cell is not same** then **return true**.\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n,m;\\n    vector<vector<int>> dp;\\n    bool BFS(vector<vector<char>> &mat,int i,int j,char c)\\n    {\\n        int X[] = {+1,-1,0,0};\\n        int Y[] = {0,0,+1,-1};\\n\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        dp[i][j] = 1;\\n        map<pair<int,int>,pair<int,int>> parent;\\n\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n\\n            for(int i = 0;i<4;i++)\\n            { \\n                int nx = x+X[i];\\n                int ny = y+Y[i];\\n\\n                if(nx>=0 && ny>=0 && nx<n && ny<m)\\n                {\\n                    if(mat[nx][ny]==c && dp[nx][ny]==1 && (parent[{x,y}].first!=nx || parent[{x,y}].second!=ny))\\n                    return true;\\n                    else if(mat[nx][ny]==c && dp[nx][ny]==0)\\n                    {\\n                        q.push({nx,ny});\\n                        dp[nx][ny] = 1;\\n                        parent[{nx,ny}] = {x,y};\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& mat) {\\n\\n        n = mat.size(),m = mat[0].size();\\n        dp = vector<vector<int>>(n,vector<int>(m,0));\\n        if(m==1||n==1) return false;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                if(!dp[i][j])\\n                if(BFS(mat,i,j,mat[i][j])) return true;\\n            }\\n        }\\n        return  false;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/281244c0-5dc6-4e67-b8e3-099fc75a5ad4_1686558830.2419586.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n,m;\\n    vector<vector<int>> dp;\\n    bool BFS(vector<vector<char>> &mat,int i,int j,char c)\\n    {\\n        int X[] = {+1,-1,0,0};\\n        int Y[] = {0,0,+1,-1};\\n\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        dp[i][j] = 1;\\n        map<pair<int,int>,pair<int,int>> parent;\\n\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n\\n            for(int i = 0;i<4;i++)\\n            { \\n                int nx = x+X[i];\\n                int ny = y+Y[i];\\n\\n                if(nx>=0 && ny>=0 && nx<n && ny<m)\\n                {\\n                    if(mat[nx][ny]==c && dp[nx][ny]==1 && (parent[{x,y}].first!=nx || parent[{x,y}].second!=ny))\\n                    return true;\\n                    else if(mat[nx][ny]==c && dp[nx][ny]==0)\\n                    {\\n                        q.push({nx,ny});\\n                        dp[nx][ny] = 1;\\n                        parent[{nx,ny}] = {x,y};\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& mat) {\\n\\n        n = mat.size(),m = mat[0].size();\\n        dp = vector<vector<int>>(n,vector<int>(m,0));\\n        if(m==1||n==1) return false;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                if(!dp[i][j])\\n                if(BFS(mat,i,j,mat[i][j])) return true;\\n            }\\n        }\\n        return  false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485940,
                "title": "c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool iscycle(int i, int j, vector<vector<char>> &grid, vector<vector<int>> &visited, vector<vector<pair<int, int>>> &parent, int n, int m)\\n{\\n    char ch = grid[i][j];\\n    int rr[] = {-1, 0, 1, 0};\\n    int cc[] = {0, 1, 0, -1};\\n\\n    queue<pair<pair<int, int>, pair<int, int>>> q;\\n    q.push({{i, j}, {-1, -1}});\\n    visited[i][j] = 1;\\n\\n    while (!q.empty())\\n    {\\n        int row = q.front().first.first;\\n        int col = q.front().first.second;\\n        int parx = q.front().second.first;\\n        int pary = q.front().second.second;\\n        q.pop();\\n\\n        for (int k = 0; k < 4; k++)\\n        {\\n            int r = row + rr[k];\\n            int c = col + cc[k];\\n\\n            if (r < n and r >= 0 and c < m and c >= 0 and grid[r][c] == ch)\\n            {\\n                if (!visited[r][c])\\n                {\\n                    q.push({{r, c}, {row, col}});\\n                    visited[r][c] = 1;\\n                }\\n                else if (parx != r or pary != c)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\nbool containsCycle(vector<vector<char>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    vector<vector<pair<int, int>>> parent(n, vector<pair<int, int>>(m, {-1, -1}));\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            if (!visited[i][j])\\n            {\\n                bool res = iscycle(i, j, grid, visited, parent, n, m);\\n                if (res)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool iscycle(int i, int j, vector<vector<char>> &grid, vector<vector<int>> &visited, vector<vector<pair<int, int>>> &parent, int n, int m)\\n{\\n    char ch = grid[i][j];\\n    int rr[] = {-1, 0, 1, 0};\\n    int cc[] = {0, 1, 0, -1};\\n\\n    queue<pair<pair<int, int>, pair<int, int>>> q;\\n    q.push({{i, j}, {-1, -1}});\\n    visited[i][j] = 1;\\n\\n    while (!q.empty())\\n    {\\n        int row = q.front().first.first;\\n        int col = q.front().first.second;\\n        int parx = q.front().second.first;\\n        int pary = q.front().second.second;\\n        q.pop();\\n\\n        for (int k = 0; k < 4; k++)\\n        {\\n            int r = row + rr[k];\\n            int c = col + cc[k];\\n\\n            if (r < n and r >= 0 and c < m and c >= 0 and grid[r][c] == ch)\\n            {\\n                if (!visited[r][c])\\n                {\\n                    q.push({{r, c}, {row, col}});\\n                    visited[r][c] = 1;\\n                }\\n                else if (parx != r or pary != c)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\nbool containsCycle(vector<vector<char>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    vector<vector<pair<int, int>>> parent(n, vector<pair<int, int>>(m, {-1, -1}));\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            if (!visited[i][j])\\n            {\\n                bool res = iscycle(i, j, grid, visited, parent, n, m);\\n                if (res)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372465,
                "title": "dfs-union-find-java-self-explained-code",
                "content": "# Code\\n```\\nclass DisjointSet {\\n    private final int[] root;\\n    private final int[] rank;\\n    DisjointSet(int size) {\\n        root = new int[size];\\n        rank = new int[size];\\n        for (int i=0; i<size; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    private int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public void union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 != root2) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n            } else if(rank[root1] < rank[root2]) {\\n                root[root1] = root2;\\n            } else {\\n                root[root1] = root2;\\n                rank[root2]++;\\n            }\\n        }\\n    }\\n\\n    public boolean isConnected(int vertex1, int vertex2) {\\n        return find(vertex1) == find(vertex2);\\n    }\\n}\\n\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{1, 0},\\n            new Integer[]{-1, 0},\\n            new Integer[]{0, 1},\\n            new Integer[]{0, -1}\\n    );\\n    public boolean containsCycle(char[][] grid) {\\n        Set<Integer> visited = new HashSet<>();\\n        int m = grid.length, n = grid[0].length;\\n        DisjointSet set = new DisjointSet(m*n);\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                int cellId = i * n + j;\\n                if(!visited.contains(cellId)) {\\n                    if(dfs(i, j, grid[i][j], grid, visited, set))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfs(int i, int j, char c, char[][] grid, Set<Integer> visited, DisjointSet set) {\\n        int cellId = i * grid[0].length + j;\\n        visited.add(cellId);\\n        for (Integer[] neighbour: getNeighbours(i, j, c, grid)) {\\n            int id = neighbour[0] * grid[0].length + neighbour[1];\\n            if (!visited.contains(id)) {\\n                if(set.isConnected(cellId, id)) return true;\\n                set.union(cellId, id);\\n            }\\n        }\\n        for (Integer[] neighbour: getNeighbours(i, j, c, grid)) {\\n            int id = neighbour[0] * grid[0].length + neighbour[1];\\n            if (!visited.contains(id))\\n                return dfs(neighbour[0], neighbour[1], c, grid, visited, set);\\n        }\\n        return false;\\n    }\\n\\n    private List<Integer[]> getNeighbours(int i, int j, char c, char[][] grid) {\\n        List<Integer[]> neighbours = new ArrayList<>();\\n        for (Integer[] direction: directions) {\\n            int x = i + direction[0], y = j + direction[1];\\n            if(isValidCoordinate(grid, x, y) && grid[x][y] == c)\\n                neighbours.add(new Integer[]{x, y});\\n        }\\n        return neighbours;\\n    }\\n\\n    private boolean isValidCoordinate(char[][] grid, int i, int j) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\nclass DisjointSet {\\n    private final int[] root;\\n    private final int[] rank;\\n    DisjointSet(int size) {\\n        root = new int[size];\\n        rank = new int[size];\\n        for (int i=0; i<size; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    private int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public void union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 != root2) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n            } else if(rank[root1] < rank[root2]) {\\n                root[root1] = root2;\\n            } else {\\n                root[root1] = root2;\\n                rank[root2]++;\\n            }\\n        }\\n    }\\n\\n    public boolean isConnected(int vertex1, int vertex2) {\\n        return find(vertex1) == find(vertex2);\\n    }\\n}\\n\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{1, 0},\\n            new Integer[]{-1, 0},\\n            new Integer[]{0, 1},\\n            new Integer[]{0, -1}\\n    );\\n    public boolean containsCycle(char[][] grid) {\\n        Set<Integer> visited = new HashSet<>();\\n        int m = grid.length, n = grid[0].length;\\n        DisjointSet set = new DisjointSet(m*n);\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                int cellId = i * n + j;\\n                if(!visited.contains(cellId)) {\\n                    if(dfs(i, j, grid[i][j], grid, visited, set))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfs(int i, int j, char c, char[][] grid, Set<Integer> visited, DisjointSet set) {\\n        int cellId = i * grid[0].length + j;\\n        visited.add(cellId);\\n        for (Integer[] neighbour: getNeighbours(i, j, c, grid)) {\\n            int id = neighbour[0] * grid[0].length + neighbour[1];\\n            if (!visited.contains(id)) {\\n                if(set.isConnected(cellId, id)) return true;\\n                set.union(cellId, id);\\n            }\\n        }\\n        for (Integer[] neighbour: getNeighbours(i, j, c, grid)) {\\n            int id = neighbour[0] * grid[0].length + neighbour[1];\\n            if (!visited.contains(id))\\n                return dfs(neighbour[0], neighbour[1], c, grid, visited, set);\\n        }\\n        return false;\\n    }\\n\\n    private List<Integer[]> getNeighbours(int i, int j, char c, char[][] grid) {\\n        List<Integer[]> neighbours = new ArrayList<>();\\n        for (Integer[] direction: directions) {\\n            int x = i + direction[0], y = j + direction[1];\\n            if(isValidCoordinate(grid, x, y) && grid[x][y] == c)\\n                neighbours.add(new Integer[]{x, y});\\n        }\\n        return neighbours;\\n    }\\n\\n    private boolean isValidCoordinate(char[][] grid, int i, int j) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840881,
                "title": "python-3-dfs-fast-solution-with-comments",
                "content": "![image.png](https://assets.leetcode.com/users/images/a0bce628-7dd7-472d-978d-4545bce3409f_1669175709.1120996.png)\\n\\n\\n# Approach\\n1. start with one cell, add it to temporal set\\n2. add neighbours with same letter (except previous cell) to stack\\n3. repeat these steps\\n\\nif current cell is already in temporal set, it means that we found cycle\\nit is a cycle because:\\n- we were in this cell before\\n- we weren\\'t in this cell on prev. step (we can\\'t come back to prev. cell)\\n\\n# Code\\n```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        \\n        visited, visited_cur = set(), set()\\n        stack = deque()\\n\\n        row_n = len(grid)\\n        col_n = len(grid[0])\\n\\n        for row, row_g in enumerate(grid):\\n            for col, val in enumerate(row_g):\\n                if (row, col) not in visited:   # if new cell\\n                    \\n                    # add to stack current cell and previous cell\\n                    # we don\\'t have previous cell, so replace it to -1, -1\\n                    stack.append([row, col, -1, -1]) \\n                    visited_cur.clear()              \\n                    while stack:\\n                        \\n                        r, c, r_prv, c_prv = stack.pop()\\n                        if (r, c) in visited_cur:   return True   # we saw this cell before -> cycle\\n                        visited_cur.add((r, c))\\n\\n                        for d_r, d_c in [[-1, 0], [0, -1], [1, 0], [0, 1]]:\\n                            # we exclude previous cell from addition to stack\\n                            if 0 <= r + d_r < row_n   and (r + d_r, c + d_c) != (r_prv, c_prv)  and   \\\\\\n                               0 <= c + d_c < col_n   and grid[r + d_r][c + d_c] == val:\\n                                    stack.append([r + d_r, c + d_c, r, c])\\n\\n                    visited.update(visited_cur) # add current set to general set\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        \\n        visited, visited_cur = set(), set()\\n        stack = deque()\\n\\n        row_n = len(grid)\\n        col_n = len(grid[0])\\n\\n        for row, row_g in enumerate(grid):\\n            for col, val in enumerate(row_g):\\n                if (row, col) not in visited:   # if new cell\\n                    \\n                    # add to stack current cell and previous cell\\n                    # we don\\'t have previous cell, so replace it to -1, -1\\n                    stack.append([row, col, -1, -1]) \\n                    visited_cur.clear()              \\n                    while stack:\\n                        \\n                        r, c, r_prv, c_prv = stack.pop()\\n                        if (r, c) in visited_cur:   return True   # we saw this cell before -> cycle\\n                        visited_cur.add((r, c))\\n\\n                        for d_r, d_c in [[-1, 0], [0, -1], [1, 0], [0, 1]]:\\n                            # we exclude previous cell from addition to stack\\n                            if 0 <= r + d_r < row_n   and (r + d_r, c + d_c) != (r_prv, c_prv)  and   \\\\\\n                               0 <= c + d_c < col_n   and grid[r + d_r][c + d_c] == val:\\n                                    stack.append([r + d_r, c + d_c, r, c])\\n\\n                    visited.update(visited_cur) # add current set to general set\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704621,
                "title": "c-82-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+dir[d];\\n            int b = j+dir[d+1];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+dir[d];\\n            int b = j+dir[d+1];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491797,
                "title": "python-dfs",
                "content": "\\n```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        nrows, ncols = len(grid), len(grid[0])\\n        dist = []\\n        for _ in range(nrows):\\n            dist.append([None for _ in range(ncols)])\\n        \\n        def dfs(r, c):\\n            letter = grid[r][c]\\n            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                rr, cc = r + dr, c + dc\\n                if 0 <= rr < nrows and 0 <= cc < ncols and grid[rr][cc] == letter:\\n                    if dist[rr][cc] is None:\\n                        dist[rr][cc] = dist[r][c] + 1\\n                        if dfs(rr, cc):\\n                            return True\\n                    elif abs(dist[rr][cc] - dist[r][c]) >= 3:\\n                        return True\\n            return False\\n        \\n        for r in range(nrows):\\n            for c in range(ncols):\\n                if dist[r][c] is None:\\n                    dist[r][c] = 0\\n                    status = dfs(r, c)\\n                    if status:\\n                        return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        nrows, ncols = len(grid), len(grid[0])\\n        dist = []\\n        for _ in range(nrows):\\n            dist.append([None for _ in range(ncols)])\\n        \\n        def dfs(r, c):\\n            letter = grid[r][c]\\n            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                rr, cc = r + dr, c + dc\\n                if 0 <= rr < nrows and 0 <= cc < ncols and grid[rr][cc] == letter:\\n                    if dist[rr][cc] is None:\\n                        dist[rr][cc] = dist[r][c] + 1\\n                        if dfs(rr, cc):\\n                            return True\\n                    elif abs(dist[rr][cc] - dist[r][c]) >= 3:\\n                        return True\\n            return False\\n        \\n        for r in range(nrows):\\n            for c in range(ncols):\\n                if dist[r][c] is None:\\n                    dist[r][c] = 0\\n                    status = dfs(r, c)\\n                    if status:\\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297384,
                "title": "very-easy-to-understand-sol-n-in-java-faster-than-90-less-than-93",
                "content": "A simple and easy-to-understand Depth First Search impelmentation. More efficient than similar solutions since we never go backwards in our search. In order to achieve this, we keep track of our previous `(i, j)` and determine the only directions that are necessary to be searched. This helps prune unnecessary branches early on.\\n\\n```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n\\n\\t\\t// Create a boolean array of same dimensions to keep track of visited cells\\n        boolean[][] visited = new boolean[rows][cols];\\n        \\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (!visited[i][j] && dfs(grid, visited, i, j, 0, 0, grid[i][j])) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n    \\n    public boolean dfs(\\n        char[][] grid,\\n        boolean[][] visited,\\n        int i,\\n        int j,\\n        int prevI,\\n        int prevJ,\\n        char c\\n    ) {\\n\\t\\t// Check for out of bounds\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) return false;\\n\\n\\t\\t// Check whether the current char matches the previous char\\n        if (grid[i][j] != c) return false;\\n\\t\\t\\n\\t\\t// If we stumble upon the same cell, we\\'re guaranteed to have found a cycle!\\n        if (visited[i][j]) {\\n            return true;\\n        }\\n        \\n\\t\\t// Mark the cell as visited\\n        visited[i][j] = true;\\n        \\n\\t\\t// We want to search in the south direction ONLY IF we didn\\'t come from north\\n\\t\\t// Do the same for all four directions\\n        boolean south = i - prevI != -1;\\n        boolean north = i - prevI != 1;\\n        boolean east = j - prevJ != -1;\\n        boolean west = j - prevJ != 1;\\n        return\\n            (south && dfs(grid, visited, i + 1, j, i, j, c)) ||\\n            (north && dfs(grid, visited, i - 1, j, i, j, c)) ||\\n            (east && dfs(grid, visited, i, j + 1, i, j, c)) ||\\n            (west && dfs(grid, visited, i, j - 1, i, j, c));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n\\n\\t\\t// Create a boolean array of same dimensions to keep track of visited cells\\n        boolean[][] visited = new boolean[rows][cols];\\n        \\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (!visited[i][j] && dfs(grid, visited, i, j, 0, 0, grid[i][j])) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n    \\n    public boolean dfs(\\n        char[][] grid,\\n        boolean[][] visited,\\n        int i,\\n        int j,\\n        int prevI,\\n        int prevJ,\\n        char c\\n    ) {\\n\\t\\t// Check for out of bounds\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) return false;\\n\\n\\t\\t// Check whether the current char matches the previous char\\n        if (grid[i][j] != c) return false;\\n\\t\\t\\n\\t\\t// If we stumble upon the same cell, we\\'re guaranteed to have found a cycle!\\n        if (visited[i][j]) {\\n            return true;\\n        }\\n        \\n\\t\\t// Mark the cell as visited\\n        visited[i][j] = true;\\n        \\n\\t\\t// We want to search in the south direction ONLY IF we didn\\'t come from north\\n\\t\\t// Do the same for all four directions\\n        boolean south = i - prevI != -1;\\n        boolean north = i - prevI != 1;\\n        boolean east = j - prevJ != -1;\\n        boolean west = j - prevJ != 1;\\n        return\\n            (south && dfs(grid, visited, i + 1, j, i, j, c)) ||\\n            (north && dfs(grid, visited, i - 1, j, i, j, c)) ||\\n            (east && dfs(grid, visited, i, j + 1, i, j, c)) ||\\n            (west && dfs(grid, visited, i, j - 1, i, j, c));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274028,
                "title": "cycle-detection-dfs-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    bool dfs(int i,int j,int previ,int prevj,vector<vector<char>>& grid, vector<vector<int>>& vis,int n,int m){\\n        \\n        vis[i][j] = 1;\\n        for(auto it:dir){\\n            int x = it[0]+i;\\n            int y = it[1]+j;\\n            \\n            if(x<0 || y<0 || x>=n || y>=m || grid[i][j]!=grid[x][y]) continue;\\n            \\n            if(!vis[x][y]){\\n                if(dfs(x,y,i,j,grid,vis,n,m)) return true;\\n            }\\n            else{\\n               if(x!=previ && y!=prevj) return true; \\n            }\\n        }\\n        \\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]){\\n                    if(dfs(i,j,-1,-1,grid,vis,n,m)) return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    bool dfs(int i,int j,int previ,int prevj,vector<vector<char>>& grid, vector<vector<int>>& vis,int n,int m){\\n        \\n        vis[i][j] = 1;\\n        for(auto it:dir){\\n            int x = it[0]+i;\\n            int y = it[1]+j;\\n            \\n            if(x<0 || y<0 || x>=n || y>=m || grid[i][j]!=grid[x][y]) continue;\\n            \\n            if(!vis[x][y]){\\n                if(dfs(x,y,i,j,grid,vis,n,m)) return true;\\n            }\\n            else{\\n               if(x!=previ && y!=prevj) return true; \\n            }\\n        }\\n        \\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]){\\n                    if(dfs(i,j,-1,-1,grid,vis,n,m)) return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236670,
                "title": "dfs-faster-the-99-of-the-c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool IsVisited[501][501] = {false};\\n    bool flag = false;\\n    vector<pair<int , int>> moves = {{0,1} , {0,-1} , {1,0} , {-1,0}};\\n    void dfs(int x , int y , int par_x , int par_y , vector<vector<char>> &grid)\\n    {\\n        for(auto z : moves)\\n        {\\n            int x_new = x + z.first;\\n            int y_new = y + z.second;\\n            if(x_new < 0 || y_new < 0 || x_new >= grid.size() || y_new >= grid[0].size() || grid[x][y] != grid[x_new][y_new])continue;\\n            if(par_x == x_new && par_y == y_new)continue;\\n            if(IsVisited[x_new][y_new]){flag = true;return;}\\n            IsVisited[x_new][y_new] = true;\\n            dfs(x_new , y_new , x , y, grid);\\n        }\\n        return;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(!IsVisited[i][j])\\n                {\\n                    IsVisited[i][j] = true;\\n                    dfs(i , j ,  -1 , -1 , grid);\\n                    if(flag)return true;\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool IsVisited[501][501] = {false};\\n    bool flag = false;\\n    vector<pair<int , int>> moves = {{0,1} , {0,-1} , {1,0} , {-1,0}};\\n    void dfs(int x , int y , int par_x , int par_y , vector<vector<char>> &grid)\\n    {\\n        for(auto z : moves)\\n        {\\n            int x_new = x + z.first;\\n            int y_new = y + z.second;\\n            if(x_new < 0 || y_new < 0 || x_new >= grid.size() || y_new >= grid[0].size() || grid[x][y] != grid[x_new][y_new])continue;\\n            if(par_x == x_new && par_y == y_new)continue;\\n            if(IsVisited[x_new][y_new]){flag = true;return;}\\n            IsVisited[x_new][y_new] = true;\\n            dfs(x_new , y_new , x , y, grid);\\n        }\\n        return;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(!IsVisited[i][j])\\n                {\\n                    IsVisited[i][j] = true;\\n                    dfs(i , j ,  -1 , -1 , grid);\\n                    if(flag)return true;\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153705,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nvar containsCycle = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = [...Array(m)].map(i => Array(n).fill(0));\\n    const dir = [[-1,0],[1,0],[0,-1],[0,1]];\\n    \\n    const dfs = (x,y,lx,ly) => {        \\n        visited[x][y] = 1;\\n        for (const [a, b] of dir) {\\n            const nx = x + a;\\n            const ny = y + b;\\n            \\n            if (nx < 0 || nx > m - 1 || ny < 0 || ny > n - 1)\\n                continue;\\n            \\n            if (visited[nx][ny] === 1 && (nx !== lx || ny !== ly) && grid[x][y] === grid[nx][ny]) { // !!! grid[nx][ny] === grid[x][y]\\n                return true;\\n            }\\n            \\n            if (visited[nx][ny] === 0 && grid[x][y] === grid[nx][ny]) {\\n                if (dfs(nx,ny,x,y))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (visited[i][j] === 0 && dfs(i,j,-1,-1)) // !!!\\n                return true;\\n        }\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nvar containsCycle = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = [...Array(m)].map(i => Array(n).fill(0));\\n    const dir = [[-1,0],[1,0],[0,-1],[0,1]];\\n    \\n    const dfs = (x,y,lx,ly) => {        \\n        visited[x][y] = 1;\\n        for (const [a, b] of dir) {\\n            const nx = x + a;\\n            const ny = y + b;\\n            \\n            if (nx < 0 || nx > m - 1 || ny < 0 || ny > n - 1)\\n                continue;\\n            \\n            if (visited[nx][ny] === 1 && (nx !== lx || ny !== ly) && grid[x][y] === grid[nx][ny]) { // !!! grid[nx][ny] === grid[x][y]\\n                return true;\\n            }\\n            \\n            if (visited[nx][ny] === 0 && grid[x][y] === grid[nx][ny]) {\\n                if (dfs(nx,ny,x,y))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (visited[i][j] === 0 && dfs(i,j,-1,-1)) // !!!\\n                return true;\\n        }\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150395,
                "title": "java-dfs-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                if(!visited[i][j] && isCycleDetected(grid, i, j, visited, i, j)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isCycleDetected(char[][] grid, int x, int y, \\n                              boolean[][] visited, int prevX, int prevY) {\\n        visited[x][y] = true;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] dir : directions) {\\n            int newX = x+dir[0];\\n            int newY = y+dir[1];\\n            if(isSafe(grid, newX, newY, visited, prevX, prevY)) {\\n                if(visited[newX][newY]) {\\n                    return true;\\n                } else {\\n                    if(isCycleDetected(grid,newX, newY,visited,x, y)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isSafe(char[][] grid, int x, int y, \\n                          boolean[][] visited, int prevX, int prevY) {\\n        if(x < 0 || x >= grid.length || y<0 || y >= grid[x].length \\n           || (x==prevX && y==prevY) || grid[x][y] != grid[prevX][prevY]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                if(!visited[i][j] && isCycleDetected(grid, i, j, visited, i, j)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isCycleDetected(char[][] grid, int x, int y, \\n                              boolean[][] visited, int prevX, int prevY) {\\n        visited[x][y] = true;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] dir : directions) {\\n            int newX = x+dir[0];\\n            int newY = y+dir[1];\\n            if(isSafe(grid, newX, newY, visited, prevX, prevY)) {\\n                if(visited[newX][newY]) {\\n                    return true;\\n                } else {\\n                    if(isCycleDetected(grid,newX, newY,visited,x, y)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isSafe(char[][] grid, int x, int y, \\n                          boolean[][] visited, int prevX, int prevY) {\\n        if(x < 0 || x >= grid.length || y<0 || y >= grid[x].length \\n           || (x==prevX && y==prevY) || grid[x][y] != grid[prevX][prevY]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115787,
                "title": "dfs-easiest-and-understandable",
                "content": "```\\nclass Solution {\\n    boolean[][] visited;\\n    public boolean containsCycle(char[][] grid) {\\n        \\n        visited = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0; i < grid.length; i++)\\n            for(int j = 0; j < grid[0].length; j++)\\n                if(!visited[i][j] && check(grid, i, j, -1, -1))\\n                    return true;\\n        \\n        return false;\\n    }\\n    \\n    int[] x = {1, -1, 0, 0};\\n    int[] y = {0, 0, -1, 1};\\n    \\n    //DFS\\n    private boolean check(char[][] grid, int row, int col, int lastRow, int lastCol) {\\n        \\n        if(visited[row][col]) return false;\\n        visited[row][col] = true;\\n\\n        for(int i = 0; i < 4; i++){\\n            int newRow = row + x[i];\\n            int newCol = col + y[i];\\n            \\n            // if index is in range and the character is also same then only in that case check further\\n            if(isSafe(grid, newRow, newCol) && grid[row][col] == grid[newRow][newCol]){\\n                \\n                // if we encountered the already visited index and it is not come from the previous Call then we have found the cycle \\n                if(visited[newRow][newCol] && newRow != lastRow && newCol != lastCol) return true;\\n                // otherwise do dfs\\n                if(check(grid, newRow, newCol, row, col)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n    private boolean isSafe(char[][] grid, int i, int j) {\\n        return 0 <= i && i < grid.length && 0 <= j && j < grid[0].length; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean[][] visited;\\n    public boolean containsCycle(char[][] grid) {\\n        \\n        visited = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0; i < grid.length; i++)\\n            for(int j = 0; j < grid[0].length; j++)\\n                if(!visited[i][j] && check(grid, i, j, -1, -1))\\n                    return true;\\n        \\n        return false;\\n    }\\n    \\n    int[] x = {1, -1, 0, 0};\\n    int[] y = {0, 0, -1, 1};\\n    \\n    //DFS\\n    private boolean check(char[][] grid, int row, int col, int lastRow, int lastCol) {\\n        \\n        if(visited[row][col]) return false;\\n        visited[row][col] = true;\\n\\n        for(int i = 0; i < 4; i++){\\n            int newRow = row + x[i];\\n            int newCol = col + y[i];\\n            \\n            // if index is in range and the character is also same then only in that case check further\\n            if(isSafe(grid, newRow, newCol) && grid[row][col] == grid[newRow][newCol]){\\n                \\n                // if we encountered the already visited index and it is not come from the previous Call then we have found the cycle \\n                if(visited[newRow][newCol] && newRow != lastRow && newCol != lastCol) return true;\\n                // otherwise do dfs\\n                if(check(grid, newRow, newCol, row, col)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n    private boolean isSafe(char[][] grid, int i, int j) {\\n        return 0 <= i && i < grid.length && 0 <= j && j < grid[0].length; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998375,
                "title": "c-dfs-union-find-2-simple-solution-with-explanation",
                "content": "# Solution 1 - dfs\\nWe use simple dfs to traverse `grid` and mark all visited nodes by `^32`, which means make them uppercase.\\nFirst, we make current posistion as uppercase: `grid[r][c] ^= 32`.\\n\\nSo inorder to find a cycle, if the next point is the uppercase of current point, then we find a cycle. Note that next point is not the point where we from to the current point. So we need `(px,py)` to denote the source position to current position `(x,y)`.\\n\\n* `time: O(mn)`\\n* `space: O(mn)`\\n```\\nclass Solution {\\npublic:\\n    int row, col;\\n    vector<vector<int>> dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        row = grid.size(), col = grid[0].size();\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (islower(grid[i][j])) {\\n                    if (dfs(i, j, -1, -1, grid)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool dfs(int r, int c, int pr, int pc, vector<vector<char>> &grid) {\\n        grid[r][c] ^= 32;\\n        for (auto &dir: dirs) {\\n            int nr = r+dir[0];\\n            int nc = c+dir[1];\\n            if (nr < 0 || nr >= row || nc < 0 || nc >= col) {\\n                continue;\\n            }\\n            if (grid[nr][nc] == grid[r][c] && (nr != pr || nc != pc)) {\\n                return true;\\n            }\\n            if ((grid[nr][nc]^32) == grid[r][c]) {\\n                if (dfs(nr, nc, r, c, grid)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# Solution 2 - union find\\nFor every position, if root of current left and top is same, and left, top value are same as current possition, then we find a cycle.\\nAlso, we group current node with its left and top if they have same value.\\n\\n* time: `O(mn)`using path compression & union by size\\n* space: `O(mn)`\\n```\\nclass Solution {\\npublic:\\n    int row, col;\\n    vector<int> parent;\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        row = grid.size(), col = grid[0].size();\\n        parent.resize(row*col, -1);\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (i && j && findp((i-1)*col+j) == findp(i*col+j-1) \\n                    && grid[i-1][j] == grid[i][j-1] && grid[i-1][j] == grid[i][j]) {\\n                    return true;\\n                }\\n                if (i && grid[i-1][j] == grid[i][j]) {\\n                    int ap = findp((i-1)*col+j);\\n                    int bp = findp(i*col+j);\\n                    if (ap != bp) {\\n                        if (-parent[ap] > -parent[bp]) {\\n                            swap(ap, bp);\\n                        }\\n                        parent[bp] += parent[ap];\\n                        parent[ap] = bp;\\n                    }\\n                }\\n                if (j && grid[i][j-1] == grid[i][j]) {\\n                    int ap = findp(i*col+j-1);\\n                    int bp = findp(i*col+j);\\n                    if (ap != bp) {\\n                        if (-parent[ap] > -parent[bp]) {\\n                            swap(ap, bp);\\n                        }\\n                        parent[bp] += parent[ap];\\n                        parent[ap] = bp;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int findp(int now) {\\n        if (parent[now] == now) {\\n            return now;\\n        } else if (parent[now] < 0) {\\n            return now;\\n        } else {\\n            return parent[now] = findp(parent[now]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int row, col;\\n    vector<vector<int>> dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        row = grid.size(), col = grid[0].size();\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (islower(grid[i][j])) {\\n                    if (dfs(i, j, -1, -1, grid)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool dfs(int r, int c, int pr, int pc, vector<vector<char>> &grid) {\\n        grid[r][c] ^= 32;\\n        for (auto &dir: dirs) {\\n            int nr = r+dir[0];\\n            int nc = c+dir[1];\\n            if (nr < 0 || nr >= row || nc < 0 || nc >= col) {\\n                continue;\\n            }\\n            if (grid[nr][nc] == grid[r][c] && (nr != pr || nc != pc)) {\\n                return true;\\n            }\\n            if ((grid[nr][nc]^32) == grid[r][c]) {\\n                if (dfs(nr, nc, r, c, grid)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int row, col;\\n    vector<int> parent;\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        row = grid.size(), col = grid[0].size();\\n        parent.resize(row*col, -1);\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (i && j && findp((i-1)*col+j) == findp(i*col+j-1) \\n                    && grid[i-1][j] == grid[i][j-1] && grid[i-1][j] == grid[i][j]) {\\n                    return true;\\n                }\\n                if (i && grid[i-1][j] == grid[i][j]) {\\n                    int ap = findp((i-1)*col+j);\\n                    int bp = findp(i*col+j);\\n                    if (ap != bp) {\\n                        if (-parent[ap] > -parent[bp]) {\\n                            swap(ap, bp);\\n                        }\\n                        parent[bp] += parent[ap];\\n                        parent[ap] = bp;\\n                    }\\n                }\\n                if (j && grid[i][j-1] == grid[i][j]) {\\n                    int ap = findp(i*col+j-1);\\n                    int bp = findp(i*col+j);\\n                    if (ap != bp) {\\n                        if (-parent[ap] > -parent[bp]) {\\n                            swap(ap, bp);\\n                        }\\n                        parent[bp] += parent[ap];\\n                        parent[ap] = bp;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int findp(int now) {\\n        if (parent[now] == now) {\\n            return now;\\n        } else if (parent[now] < 0) {\\n            return now;\\n        } else {\\n            return parent[now] = findp(parent[now]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991724,
                "title": "java-union-find-explained",
                "content": "## Idea\\nGeneral way for Union Find to detect cycle:\\n+ Get all edges `int[][] edges`.\\n+ Union each node `u` and `v` in `int[] edge`. Before union `u` and `v`, if they are already in the same component, we find a cycle.\\n\\nCustomized for this problem:\\n+ No need to get all edges. The graph of this grid is **bi-directional**.  So we can only go **downward and rightward** to traverse all edges. This also avoids adding duplicate edges which might cause false cycle.\\n## Code\\n```\\nclass Solution {\\n    class UF {\\n        int[] root;\\n        int[] size;\\n        \\n        public UF(int n) {\\n            this.root = new int[n];\\n            this.size = new int[n];\\n            \\n            Arrays.fill(this.size, 1);\\n            for(int i = 0; i < n; i++){\\n                this.root[i] = i;\\n            }\\n        }\\n        \\n        public int find(int x){\\n            while(x != root[x]){\\n                root[x] = root[root[x]];\\n                x = root[x];\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int x, int y){\\n            int rx = find(x);\\n            int ry = find(y);\\n            \\n            if(rx == ry) return;\\n            \\n            if(size[rx] > size[ry]){\\n                root[ry] = rx;\\n                size[rx] += size[ry];\\n            }else{\\n                root[rx] = ry;\\n                size[ry] += size[rx];\\n            }\\n        }\\n        \\n        public boolean isConnected(int x, int y){\\n            return find(x) == find(y);\\n        }\\n    }\\n    \\n    public boolean containsCycle(char[][] grid) {\\n        // union find : detecting cycle, go over all edges\\n        // if for new edge, already find (u,v) in same party, cycle detected\\n        \\n        // 1. get edges(cannot have duplicate edges)\\n        // no need to get\\n        \\n        // 2. union and check\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        UF uf = new UF(n * m);\\n        \\n        // go over downward and rightward to get all edges\\n        for(int i = 0; i < n - 1; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == grid[i + 1][j]){\\n                    if(uf.isConnected(i * m + j, (i + 1) * m + j)) return true;\\n                    \\n                    uf.union(i * m + j, (i + 1) * m + j);\\n                }\\n            }\\n        }\\n        \\n        // rightward\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m - 1; j++){\\n                if(grid[i][j] == grid[i][j + 1]){\\n                    if(uf.isConnected(i * m + j, i * m + j + 1)) return true;\\n                    uf.union(i * m + j, i * m + j + 1);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class UF {\\n        int[] root;\\n        int[] size;\\n        \\n        public UF(int n) {\\n            this.root = new int[n];\\n            this.size = new int[n];\\n            \\n            Arrays.fill(this.size, 1);\\n            for(int i = 0; i < n; i++){\\n                this.root[i] = i;\\n            }\\n        }\\n        \\n        public int find(int x){\\n            while(x != root[x]){\\n                root[x] = root[root[x]];\\n                x = root[x];\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int x, int y){\\n            int rx = find(x);\\n            int ry = find(y);\\n            \\n            if(rx == ry) return;\\n            \\n            if(size[rx] > size[ry]){\\n                root[ry] = rx;\\n                size[rx] += size[ry];\\n            }else{\\n                root[rx] = ry;\\n                size[ry] += size[rx];\\n            }\\n        }\\n        \\n        public boolean isConnected(int x, int y){\\n            return find(x) == find(y);\\n        }\\n    }\\n    \\n    public boolean containsCycle(char[][] grid) {\\n        // union find : detecting cycle, go over all edges\\n        // if for new edge, already find (u,v) in same party, cycle detected\\n        \\n        // 1. get edges(cannot have duplicate edges)\\n        // no need to get\\n        \\n        // 2. union and check\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        UF uf = new UF(n * m);\\n        \\n        // go over downward and rightward to get all edges\\n        for(int i = 0; i < n - 1; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == grid[i + 1][j]){\\n                    if(uf.isConnected(i * m + j, (i + 1) * m + j)) return true;\\n                    \\n                    uf.union(i * m + j, (i + 1) * m + j);\\n                }\\n            }\\n        }\\n        \\n        // rightward\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m - 1; j++){\\n                if(grid[i][j] == grid[i][j + 1]){\\n                    if(uf.isConnected(i * m + j, i * m + j + 1)) return true;\\n                    uf.union(i * m + j, i * m + j + 1);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919965,
                "title": "c-dfs-simple-to-understand",
                "content": "Simple Guranted \\n```\\nclass Solution\\n{\\npublic:\\n    bool checker(int r,int c,int m,int n,int pr,int pc)\\n    {\\n        return r>=0 && r < m && c >=0 && c < n && !(r==pr && c == pc);\\n    }\\n\\n    bool dfs(int rSize,int cSize,vector<vector<char>> &grid, vector<vector<bool>> &visited,int i,int j,int pr,int pc)\\n    {\\n        if(visited[i][j])\\n        {\\n            return true;\\n        }\\n        visited[i][j] = true;\\n        vector<int> rowDir = {0,-1,0,1};\\n        vector<int> colDir = {-1,0,1,0};\\n        for(int k = 0; k < 4; k++)\\n        {\\n            int cr = i+rowDir[k],cc=j+colDir[k];\\n            if(checker(cr,cc,rSize,cSize,pr,pc))\\n            {\\n                if(grid[cr][cc] == grid[i][j])\\n                {\\n                    if(dfs(rSize,cSize,grid,visited,cr,cc,i,j))\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n    bool containsCycle(vector<vector<char>>& grid)\\n    {\\n        int r = grid.size(),c = grid[0].size();\\n\\n        vector<vector<bool>> visited(r,vector<bool>(c,false));\\n\\n        //now i need to run a dfs\\n        for(int i = 0; i < r; i++)\\n        {\\n            for(int j = 0; j < c; j++)\\n            {\\n                if(!visited[i][j] && dfs(r,c,grid,visited,i,j,-1,-1)) //current parent is -1-1\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool checker(int r,int c,int m,int n,int pr,int pc)\\n    {\\n        return r>=0 && r < m && c >=0 && c < n && !(r==pr && c == pc);\\n    }\\n\\n    bool dfs(int rSize,int cSize,vector<vector<char>> &grid, vector<vector<bool>> &visited,int i,int j,int pr,int pc)\\n    {\\n        if(visited[i][j])\\n        {\\n            return true;\\n        }\\n        visited[i][j] = true;\\n        vector<int> rowDir = {0,-1,0,1};\\n        vector<int> colDir = {-1,0,1,0};\\n        for(int k = 0; k < 4; k++)\\n        {\\n            int cr = i+rowDir[k],cc=j+colDir[k];\\n            if(checker(cr,cc,rSize,cSize,pr,pc))\\n            {\\n                if(grid[cr][cc] == grid[i][j])\\n                {\\n                    if(dfs(rSize,cSize,grid,visited,cr,cc,i,j))\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n    bool containsCycle(vector<vector<char>>& grid)\\n    {\\n        int r = grid.size(),c = grid[0].size();\\n\\n        vector<vector<bool>> visited(r,vector<bool>(c,false));\\n\\n        //now i need to run a dfs\\n        for(int i = 0; i < r; i++)\\n        {\\n            for(int j = 0; j < c; j++)\\n            {\\n                if(!visited[i][j] && dfs(r,c,grid,visited,i,j,-1,-1)) //current parent is -1-1\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883776,
                "title": "java-dfs",
                "content": "class Solution {\\n    private boolean[][] visited;\\n    private final int[] dx = {0, 1, 0, -1};\\n    private final int[] dy = {1, 0, -1, 0};\\n   \\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        visited = new boolean[m][n];\\n        \\n        for (int i = 0; i < m; i ++) {\\n            for (int j = 0; j < n; j ++) {\\n                if (!visited[i][j]){\\n                    if (dfs(grid, i, j, i, j)) return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean dfs(char[][] grid, int x, int y, int lastX, int lastY) {\\n        \\n        visited[x][y] = true;\\n        \\n        for (int i = 0; i < 4; i ++) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (inArea(grid, xx, yy) && grid[xx][yy] == grid[x][y]) {\\n                if (!visited[xx][yy]) {\\n                    if (dfs(grid, xx, yy, x, y))\\n                        return true;\\n                } else if (xx != lastX || yy != lastY) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean inArea(char[][] grid, int x, int y) {\\n        return !(x < 0 || x >= grid.length || y < 0 || y >= grid[0].length);\\n    }  \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private boolean[][] visited;\\n    private final int[] dx = {0, 1, 0, -1}",
                "codeTag": "Java"
            },
            {
                "id": 1756725,
                "title": "python-disjoint-sets-amortized-o-m-n-time",
                "content": "```\\nclass DisjointSets:\\n    def __init__(self):\\n        self.parent = dict()\\n    def makeSet(self, u):\\n        self.parent[u] = u\\n    def find(self, u):\\n        if u not in self.parent:\\n            self.parent[u] = u\\n            return u\\n        elif u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])\\n            return self.parent[u]\\n        else:\\n            return u\\n    def union(self, u, v):\\n        up = self.find(u)\\n        vp = self.find(v)\\n        if up != vp:\\n            self.parent[vp] = up\\n            return False\\n        else:\\n            return True\\n\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        ds = DisjointSets()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                ds.makeSet((i, j))\\n                if i-1 >= 0 and grid[i-1][j] == grid[i][j]:\\n                    if ds.union((i-1, j), (i, j)):\\n                        return True\\n                if j-1 >= 0 and grid[i][j-1] == grid[i][j]:\\n                    if ds.union((i, j-1), (i, j)):\\n                        return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSets:\\n    def __init__(self):\\n        self.parent = dict()\\n    def makeSet(self, u):\\n        self.parent[u] = u\\n    def find(self, u):\\n        if u not in self.parent:\\n            self.parent[u] = u\\n            return u\\n        elif u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])\\n            return self.parent[u]\\n        else:\\n            return u\\n    def union(self, u, v):\\n        up = self.find(u)\\n        vp = self.find(v)\\n        if up != vp:\\n            self.parent[vp] = up\\n            return False\\n        else:\\n            return True\\n\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        ds = DisjointSets()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                ds.makeSet((i, j))\\n                if i-1 >= 0 and grid[i-1][j] == grid[i][j]:\\n                    if ds.union((i-1, j), (i, j)):\\n                        return True\\n                if j-1 >= 0 and grid[i][j-1] == grid[i][j]:\\n                    if ds.union((i, j-1), (i, j)):\\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671052,
                "title": "java-bfs-code",
                "content": "A great Question for understanding BFS algo ::\\n\\'\\'\\'\\n    public boolean containsCycle(char[][] grid) {\\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n        boolean vis[][] =new boolean[n][m];\\n        Queue<int[]> q =new LinkedList<>();\\n        int b[][]={{0,1},{1,0},{-1,0},{0,-1}};\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(vis[i][j]==false)\\n                {\\n                   char ch = grid[i][j]; \\n                   q.add(new int[]{i,j});\\n                    \\n                   while(!q.isEmpty())\\n                   {\\n                       \\n                      int a[] = q.remove(); \\n                      int row = a[0];\\n                      int col = a[1]; \\n                      \\n                      if(vis[row][col])  return true;\\n                        \\n                      vis[row][col]=true; \\n                       \\n                     for(int c[] : b)  \\n                       {\\n                           int nrow = row + c[0];\\n                           int ncol = col + c[1];\\n                            \\n                           if(nrow<0 || ncol<0 || nrow >=n || ncol >= m || vis[nrow][ncol] || grid[nrow][ncol]!=ch ) continue;\\n                         \\n                            q.add(new int[]{nrow,ncol});\\n                       }\\n                       \\n                       \\n                   } \\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "A great Question for understanding BFS algo ::\\n\\'\\'\\'\\n    public boolean containsCycle(char[][] grid) {\\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n        boolean vis[][] =new boolean[n][m];\\n        Queue<int[]> q =new LinkedList<>();\\n        int b[][]={{0,1},{1,0},{-1,0},{0,-1}};\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(vis[i][j]==false)\\n                {\\n                   char ch = grid[i][j]; \\n                   q.add(new int[]{i,j});\\n                    \\n                   while(!q.isEmpty())\\n                   {\\n                       \\n                      int a[] = q.remove(); \\n                      int row = a[0];\\n                      int col = a[1]; \\n                      \\n                      if(vis[row][col])  return true;\\n                        \\n                      vis[row][col]=true; \\n                       \\n                     for(int c[] : b)  \\n                       {\\n                           int nrow = row + c[0];\\n                           int ncol = col + c[1];\\n                            \\n                           if(nrow<0 || ncol<0 || nrow >=n || ncol >= m || vis[nrow][ncol] || grid[nrow][ncol]!=ch ) continue;\\n                         \\n                            q.add(new int[]{nrow,ncol});\\n                       }\\n                       \\n                       \\n                   } \\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1652266,
                "title": "c-dfs-from-unvisited-nodes-in-the-matrix",
                "content": "<ins>Update:</ins>\\n\\nWe are going to do a dfs from every point and keep a track of visited nodes. From each starting point, we know that we need the same character in the whole chain, so we will be looking for the same character from where we started the dfs. And if at any point in time, we get to a point which we already visited then we know we found the cycle.\\n\\nWhile doing this, we need to also keep track of the parent cell from where we did come here so that we don\\'t consider the cycle of only two nodes. :)\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<bool>> visited;\\n    vector<vector<char>> mat;\\n    bool dfs(int x, int y, char need, pair<int, int> parent) {\\n        auto isValid = [&](const int &A, const int &B) {\\n            return (A >= 0 && B >= 0 && A < n && B < m);  \\n        };\\n        if (visited[x][y])  return true;\\n        visited[x][y] = true;\\n        int dir[] = {-1, 0, 1, 0, -1};\\n        for (int k = 0; k < 4; ++k) {\\n            int X = x + dir[k];\\n            int Y = y + dir[k + 1];\\n            if (X == parent.first && Y == parent.second)    continue;\\n            if (isValid(X, Y) && need == mat[X][Y]) {\\n                if (dfs(X, Y, need, {x, y})) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        visited.resize(n, vector<bool>(m, false));\\n        mat = grid;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (!visited[i][j]) {\\n                    bool haveFound = dfs(i, j, grid[i][j], {-1, -1});\\n                    if (haveFound)  return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<bool>> visited;\\n    vector<vector<char>> mat;\\n    bool dfs(int x, int y, char need, pair<int, int> parent) {\\n        auto isValid = [&](const int &A, const int &B) {\\n            return (A >= 0 && B >= 0 && A < n && B < m);  \\n        };\\n        if (visited[x][y])  return true;\\n        visited[x][y] = true;\\n        int dir[] = {-1, 0, 1, 0, -1};\\n        for (int k = 0; k < 4; ++k) {\\n            int X = x + dir[k];\\n            int Y = y + dir[k + 1];\\n            if (X == parent.first && Y == parent.second)    continue;\\n            if (isValid(X, Y) && need == mat[X][Y]) {\\n                if (dfs(X, Y, need, {x, y})) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        visited.resize(n, vector<bool>(m, false));\\n        mat = grid;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (!visited[i][j]) {\\n                    bool haveFound = dfs(i, j, grid[i][j], {-1, -1});\\n                    if (haveFound)  return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632757,
                "title": "java-simple-recursive-approach-using-dfs",
                "content": "```\\nclass Solution {\\n    boolean status;  // whether contains cycle\\n    boolean[][] visited; // keeps track of visited cell\\n    \\n    public boolean containsCycle(char[][] grid) {\\n        visited = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0 ; i < grid.length ; i++) {\\n            for(int j = 0 ; j < grid[0].length ; j++) {\\n\\t\\t\\t\\t// No need to check further cell if cycle found i.e. status = true.\\n                if(!status) {\\n                    if(!visited[i][j]) {\\n                        dfs(grid, i, j, -1, -1);\\n                    }\\n                } else {\\n                    return status;\\n                }\\n            }\\n        }\\n        \\n        return status;\\n    }\\n    \\n\\t// prow = parent row, pcol = parent col \\n    public void dfs(char[][] grid, int row, int col, int prow, int pcol) {\\n        if(visited[row][col]) {\\n            status = true;\\n            return;\\n        }\\n        visited[row][col] = true;\\n\\t\\t\\n        // Condition 1: Check whether it is with in range(row and col) or not.\\n\\t\\t// Condition 2: Check whether the new range does not belongs to parent row and col.\\n\\t\\t// Condition 3: Check whether the new range have the same data value.\\n\\t\\t\\n        if(row > 0 && row-1 != prow && grid[row-1][col] == grid[row][col]) {\\n            dfs(grid, row-1, col, row, col);\\n        }\\n        if(col+1 < grid[0].length && col+1 != pcol && grid[row][col+1] == grid[row][col]) {\\n            dfs(grid, row, col+1, row, col);\\n        }\\n        if(row+1 < grid.length && row+1 != prow && grid[row+1][col] == grid[row][col]) {\\n            dfs(grid, row+1, col, row, col);\\n        }\\n        if(col > 0 && col-1 != pcol && grid[row][col-1] == grid[row][col]) {\\n            dfs(grid, row, col-1, row, col);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean status;  // whether contains cycle\\n    boolean[][] visited; // keeps track of visited cell\\n    \\n    public boolean containsCycle(char[][] grid) {\\n        visited = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0 ; i < grid.length ; i++) {\\n            for(int j = 0 ; j < grid[0].length ; j++) {\\n\\t\\t\\t\\t// No need to check further cell if cycle found i.e. status = true.\\n                if(!status) {\\n                    if(!visited[i][j]) {\\n                        dfs(grid, i, j, -1, -1);\\n                    }\\n                } else {\\n                    return status;\\n                }\\n            }\\n        }\\n        \\n        return status;\\n    }\\n    \\n\\t// prow = parent row, pcol = parent col \\n    public void dfs(char[][] grid, int row, int col, int prow, int pcol) {\\n        if(visited[row][col]) {\\n            status = true;\\n            return;\\n        }\\n        visited[row][col] = true;\\n\\t\\t\\n        // Condition 1: Check whether it is with in range(row and col) or not.\\n\\t\\t// Condition 2: Check whether the new range does not belongs to parent row and col.\\n\\t\\t// Condition 3: Check whether the new range have the same data value.\\n\\t\\t\\n        if(row > 0 && row-1 != prow && grid[row-1][col] == grid[row][col]) {\\n            dfs(grid, row-1, col, row, col);\\n        }\\n        if(col+1 < grid[0].length && col+1 != pcol && grid[row][col+1] == grid[row][col]) {\\n            dfs(grid, row, col+1, row, col);\\n        }\\n        if(row+1 < grid.length && row+1 != prow && grid[row+1][col] == grid[row][col]) {\\n            dfs(grid, row+1, col, row, col);\\n        }\\n        if(col > 0 && col-1 != pcol && grid[row][col-1] == grid[row][col]) {\\n            dfs(grid, row, col-1, row, col);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632556,
                "title": "swift-simple-dfs",
                "content": "```\\n// Main Idea: https://tinyurl.com/y4dtahmr\\nclass Solution {\\n    func containsCycle(_ grid: [[Character]]) -> Bool {\\n        var visited = Array(repeating: Array(repeating: false, count: grid[0].count), count: grid.count)\\n        for i in 0..<grid.count {\\n            for j in 0..<grid[0].count {\\n                if !visited[i][j] {\\n                    if containsCycleHelperDFS(grid, i, j, &visited, -1, -1) {\\n                        return true\\n                    }\\n                }\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func containsCycleHelperDFS(_ grid: [[Character]], _ row: Int, _ col: Int, _ visited: inout [[Bool]], _ prevRow: Int, _ prevCol: Int) -> Bool {\\n        for (r, c) in [(0, -1), (-1, 0), (0, 1), (1, 0)] {\\n            let (newR, newC) = (row + r, col + c)\\n            if newR < 0 || newR >= grid.count || newC < 0 || newC >= grid[0].count {\\n                continue\\n            }\\n            if newR == prevRow && newC == prevCol {\\n                continue\\n            }\\n            if grid[newR][newC] == grid[row][col] {\\n                if visited[newR][newC] {\\n                    return true\\n                } else {\\n                    visited[newR][newC] = true\\n                    if containsCycleHelperDFS(grid, newR, newC, &visited, row, col) {\\n                        return true\\n                    }\\n                }\\n            }\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\n// Main Idea: https://tinyurl.com/y4dtahmr\\nclass Solution {\\n    func containsCycle(_ grid: [[Character]]) -> Bool {\\n        var visited = Array(repeating: Array(repeating: false, count: grid[0].count), count: grid.count)\\n        for i in 0..<grid.count {\\n            for j in 0..<grid[0].count {\\n                if !visited[i][j] {\\n                    if containsCycleHelperDFS(grid, i, j, &visited, -1, -1) {\\n                        return true\\n                    }\\n                }\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func containsCycleHelperDFS(_ grid: [[Character]], _ row: Int, _ col: Int, _ visited: inout [[Bool]], _ prevRow: Int, _ prevCol: Int) -> Bool {\\n        for (r, c) in [(0, -1), (-1, 0), (0, 1), (1, 0)] {\\n            let (newR, newC) = (row + r, col + c)\\n            if newR < 0 || newR >= grid.count || newC < 0 || newC >= grid[0].count {\\n                continue\\n            }\\n            if newR == prevRow && newC == prevCol {\\n                continue\\n            }\\n            if grid[newR][newC] == grid[row][col] {\\n                if visited[newR][newC] {\\n                    return true\\n                } else {\\n                    visited[newR][newC] = true\\n                    if containsCycleHelperDFS(grid, newR, newC, &visited, row, col) {\\n                        return true\\n                    }\\n                }\\n            }\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605949,
                "title": "c-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int dir[3] = {0, 1, 0}, m = grid.size(), n = grid[0].size();\\n        \\n        vector<int> ds(m * n, - 1);\\n        function<int(int)> find = [&ds, &find] (int i) {\\n            return ds[i] < 0 ? i : ds[i] = find(ds[i]);\\n        };\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int a = find(i * n + j);\\n                for (int k = 0; k < 2; k++) {\\n                    int ni = i + dir[k], nj = j + dir[k + 1];\\n                    if (ni >= m || nj >= n || grid[i][j] != grid[ni][nj])\\n                        continue;\\n                    int b = find(ni * n + nj);\\n                    if (a == b) return true;\\n                    ds[b] = a;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int dir[3] = {0, 1, 0}, m = grid.size(), n = grid[0].size();\\n        \\n        vector<int> ds(m * n, - 1);\\n        function<int(int)> find = [&ds, &find] (int i) {\\n            return ds[i] < 0 ? i : ds[i] = find(ds[i]);\\n        };\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int a = find(i * n + j);\\n                for (int k = 0; k < 2; k++) {\\n                    int ni = i + dir[k], nj = j + dir[k + 1];\\n                    if (ni >= m || nj >= n || grid[i][j] != grid[ni][nj])\\n                        continue;\\n                    int b = find(ni * n + nj);\\n                    if (a == b) return true;\\n                    ds[b] = a;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522190,
                "title": "python-dfs-o-nm-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        # For each character component of the grid, DFS to see if there\\'s a cycle.\\n        # The constraints are that we can\\'t travel backwards from where we came from.\\n        # No need to check if the path contains more than 4 elements, because 4 elements is the bare minimum to generate a\\n        # cycle with these contraints.\\n        \\n        visited = set()\\n        \\n        def hasCycle(y, x, path, prevY, prevX):\\n            if (y,x) in path:\\n                return True\\n            \\n            path.add((y,x))\\n            visited.add((y,x))\\n                        \\n            for dy, dx in ((-1,0),(1,0),(0,-1),(0,1)):\\n                if not (0 <= y+dy < len(grid)) or not (0 <= x+dx < len(grid[0])):\\n                    continue\\n                if y+dy == prevY and x+dx == prevX:\\n                    continue\\n                if grid[y+dy][x+dx] != grid[y][x]:\\n                    continue\\n                if hasCycle(y+dy, x+dx, path, y, x):\\n                    return True\\n            \\n            return False\\n        \\n        for y in range(len(grid)):\\n            for x in range(len(grid[0])):\\n                if (y,x) in visited:\\n                    continue\\n                if hasCycle(y,x,set(), None, None):\\n                    return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        # For each character component of the grid, DFS to see if there\\'s a cycle.\\n        # The constraints are that we can\\'t travel backwards from where we came from.\\n        # No need to check if the path contains more than 4 elements, because 4 elements is the bare minimum to generate a\\n        # cycle with these contraints.\\n        \\n        visited = set()\\n        \\n        def hasCycle(y, x, path, prevY, prevX):\\n            if (y,x) in path:\\n                return True\\n            \\n            path.add((y,x))\\n            visited.add((y,x))\\n                        \\n            for dy, dx in ((-1,0),(1,0),(0,-1),(0,1)):\\n                if not (0 <= y+dy < len(grid)) or not (0 <= x+dx < len(grid[0])):\\n                    continue\\n                if y+dy == prevY and x+dx == prevX:\\n                    continue\\n                if grid[y+dy][x+dx] != grid[y][x]:\\n                    continue\\n                if hasCycle(y+dy, x+dx, path, y, x):\\n                    return True\\n            \\n            return False\\n        \\n        for y in range(len(grid)):\\n            for x in range(len(grid[0])):\\n                if (y,x) in visited:\\n                    continue\\n                if hasCycle(y,x,set(), None, None):\\n                    return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500112,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        #BFS for same character\\n        #if find a neighbor node that has been visited before but not previous node, there is a cycle\\n        \\n        #O(n) time and space\\n        \\n        m, n = len(grid), len(grid[0])\\n        seen = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if (i, j) not in seen:\\n                    if self.bfs(i, j, grid, seen):\\n                        return True\\n        return False\\n    \\n    def bfs(self, i, j, grid, seen):\\n        m, n = len(grid), len(grid[0])\\n        q = deque([(i,j,None, None)])\\n        char = grid[i][j]\\n        seen.add((i,j))\\n        while q:\\n            i, j, pi, pj = q.pop()\\n            for x, y  in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                ni, nj = i + x, j + y\\n                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == char:\\n                    if (ni, nj) in seen:\\n                        if (ni, nj) != (pi, pj):\\n                            return True\\n                    else:\\n                        q.appendleft((ni, nj, i, j))\\n                        seen.add((ni, nj))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        #BFS for same character\\n        #if find a neighbor node that has been visited before but not previous node, there is a cycle\\n        \\n        #O(n) time and space\\n        \\n        m, n = len(grid), len(grid[0])\\n        seen = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if (i, j) not in seen:\\n                    if self.bfs(i, j, grid, seen):\\n                        return True\\n        return False\\n    \\n    def bfs(self, i, j, grid, seen):\\n        m, n = len(grid), len(grid[0])\\n        q = deque([(i,j,None, None)])\\n        char = grid[i][j]\\n        seen.add((i,j))\\n        while q:\\n            i, j, pi, pj = q.pop()\\n            for x, y  in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                ni, nj = i + x, j + y\\n                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == char:\\n                    if (ni, nj) in seen:\\n                        if (ni, nj) != (pi, pj):\\n                            return True\\n                    else:\\n                        q.appendleft((ni, nj, i, j))\\n                        seen.add((ni, nj))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488767,
                "title": "c-simple-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<vector<char>>& g,int u,int v,int prex,int prey){\\n        if (u < 0 || u >= g.size() || v < 0 || v >= g[0].size() || g[u][v] != g[prex][prey]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool bfs(vector<vector<char>>& g,int r,int c,vector<vector<bool>>&vi){\\n        int offsets[] = {0, 1, 0, -1, 0};\\n        queue<pair<pair<int,int>,pair<int,int>>>q;\\n        q.push({{-1,-1},{r,c}});\\n        vi[r][c]=true;\\n        while(!q.empty()){\\n            int prex=q.front().first.first;\\n            int prey=q.front().first.second;\\n            int x = q.front().second.first;\\n            int y = q.front().second.second;\\n            q.pop();\\n            for (int k = 0; k < 4; k++) {\\n                int u = x + offsets[k], v = y + offsets[k + 1];\\n                if (isValid(g,u,v,x,y)) {\\n                    if(vi[u][v]){\\n                        if(prex!=u or prey!=v){\\n                            return true;\\n                        } \\n                    }else{\\n                        vi[u][v] = true;\\n                        q.push({{x,y},{u, v}});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j]){\\n                    if(bfs(grid,i,j,vis)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<vector<char>>& g,int u,int v,int prex,int prey){\\n        if (u < 0 || u >= g.size() || v < 0 || v >= g[0].size() || g[u][v] != g[prex][prey]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool bfs(vector<vector<char>>& g,int r,int c,vector<vector<bool>>&vi){\\n        int offsets[] = {0, 1, 0, -1, 0};\\n        queue<pair<pair<int,int>,pair<int,int>>>q;\\n        q.push({{-1,-1},{r,c}});\\n        vi[r][c]=true;\\n        while(!q.empty()){\\n            int prex=q.front().first.first;\\n            int prey=q.front().first.second;\\n            int x = q.front().second.first;\\n            int y = q.front().second.second;\\n            q.pop();\\n            for (int k = 0; k < 4; k++) {\\n                int u = x + offsets[k], v = y + offsets[k + 1];\\n                if (isValid(g,u,v,x,y)) {\\n                    if(vi[u][v]){\\n                        if(prex!=u or prey!=v){\\n                            return true;\\n                        } \\n                    }else{\\n                        vi[u][v] = true;\\n                        q.push({{x,y},{u, v}});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j]){\\n                    if(bfs(grid,i,j,vis)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480766,
                "title": "c-solution-for-1559-detect-cycles-in-2d-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkCycle(int i, int j, int prev_i, int prev_j, vector<vector<char>>& grid, vector<vector<bool>>& vis)\\n    {\\n        if(i<0 || i>= grid.size() || j<0 || j>= grid[0].size())\\n        {return false;}\\n        \\n        if(vis[i][j] == true){return true;}\\n        vis[i][j] = true;\\n        \\n        if( i+1 != prev_i && i+1 < grid.size() && grid[i+1][j] == grid[i][j] )\\n        {\\n            if(checkCycle(i+1, j, i, j, grid, vis)){return true ;}\\n        }\\n        if( i-1 != prev_i && i-1 >= 0 && grid[i-1][j] == grid[i][j] )\\n        {\\n            if(checkCycle(i-1, j, i, j, grid, vis)){return true ;}\\n        }\\n        if( j+1 != prev_j && j+1 < grid[0].size() && grid[i][j+1] == grid[i][j] )\\n        {\\n            if(checkCycle(i, j+1, i, j, grid, vis)){return true ;}\\n        }\\n        if( j-1 != prev_j && j-1 >= 0 && grid[i][j-1] == grid[i][j] )\\n        {\\n            if(checkCycle(i, j-1, i, j, grid, vis)){return true ;}\\n        }\\n\\n        return false ;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) \\n    {   \\n        int rsz = grid.size(); int csz = grid[0].size();\\n        vector<vector<bool>> vis(rsz, vector<bool>(csz, false));\\n        for(int m = 0; m<rsz; m++)\\n        {\\n            for(int n = 0; n<csz; n++)\\n            {\\n                if(!vis[m][n])\\n                {   \\n                    if(checkCycle(m,n,-1,-1,grid, vis)){return true;}\\n                }\\n            }   \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkCycle(int i, int j, int prev_i, int prev_j, vector<vector<char>>& grid, vector<vector<bool>>& vis)\\n    {\\n        if(i<0 || i>= grid.size() || j<0 || j>= grid[0].size())\\n        {return false;}\\n        \\n        if(vis[i][j] == true){return true;}\\n        vis[i][j] = true;\\n        \\n        if( i+1 != prev_i && i+1 < grid.size() && grid[i+1][j] == grid[i][j] )\\n        {\\n            if(checkCycle(i+1, j, i, j, grid, vis)){return true ;}\\n        }\\n        if( i-1 != prev_i && i-1 >= 0 && grid[i-1][j] == grid[i][j] )\\n        {\\n            if(checkCycle(i-1, j, i, j, grid, vis)){return true ;}\\n        }\\n        if( j+1 != prev_j && j+1 < grid[0].size() && grid[i][j+1] == grid[i][j] )\\n        {\\n            if(checkCycle(i, j+1, i, j, grid, vis)){return true ;}\\n        }\\n        if( j-1 != prev_j && j-1 >= 0 && grid[i][j-1] == grid[i][j] )\\n        {\\n            if(checkCycle(i, j-1, i, j, grid, vis)){return true ;}\\n        }\\n\\n        return false ;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) \\n    {   \\n        int rsz = grid.size(); int csz = grid[0].size();\\n        vector<vector<bool>> vis(rsz, vector<bool>(csz, false));\\n        for(int m = 0; m<rsz; m++)\\n        {\\n            for(int n = 0; n<csz; n++)\\n            {\\n                if(!vis[m][n])\\n                {   \\n                    if(checkCycle(m,n,-1,-1,grid, vis)){return true;}\\n                }\\n            }   \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447203,
                "title": "python-dfs-solution",
                "content": "```\\ndef getAdjNodes(grid, r, c):\\n    return [(i, j) for i, j in [(r-1, c),  (r+1,c), (r,c-1), (r,c+1)]\\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) ]\\n\\ndef isCycle(grid, r, c, prev, letter):\\n    grid[r][c] = ord(letter) # set to seen\\n    \\n    for i, j in getAdjNodes(grid, r, c):\\n        if prev != (i, j):\\n            adjNodeVal = grid[i][j]\\n            if adjNodeVal == letter:\\n                if isCycle(grid, i, j, (r, c), letter):\\n                    return True \\n            elif adjNodeVal == ord(letter):\\n                return True\\n\\n    return False\\n\\n\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        for r in range(len(grid)):\\n            for c in range(len(grid[0])):\\n                if type(grid[r][c]) is str:\\n                    if isCycle(grid, r, c, (\\'tmp\\', \\'tmp\\'), grid[r][c]):\\n                        return True \\n        return False\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef getAdjNodes(grid, r, c):\\n    return [(i, j) for i, j in [(r-1, c),  (r+1,c), (r,c-1), (r,c+1)]\\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) ]\\n\\ndef isCycle(grid, r, c, prev, letter):\\n    grid[r][c] = ord(letter) # set to seen\\n    \\n    for i, j in getAdjNodes(grid, r, c):\\n        if prev != (i, j):\\n            adjNodeVal = grid[i][j]\\n            if adjNodeVal == letter:\\n                if isCycle(grid, i, j, (r, c), letter):\\n                    return True \\n            elif adjNodeVal == ord(letter):\\n                return True\\n\\n    return False\\n\\n\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        for r in range(len(grid)):\\n            for c in range(len(grid[0])):\\n                if type(grid[r][c]) is str:\\n                    if isCycle(grid, r, c, (\\'tmp\\', \\'tmp\\'), grid[r][c]):\\n                        return True \\n        return False\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410135,
                "title": "java-simple-dfs-solution",
                "content": "```\\nclass Solution {\\n    int[][] dirs = {{-1,0},{1,0},{0,1},{0,-1}};\\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(!visited[i][j]&&dfs(grid, i, j, -1, -1, visited, m, n, grid[i][j]))\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] grid, int i, int j, int prei, int prej, boolean[][] visited, int m, int n, int color)\\n    {\\n        if(i<0||j<0||i>=m||j>=n||grid[i][j]!=color)return false;\\n        if(visited[i][j])return true;\\n        visited[i][j] = true;\\n        for(int[] dir : dirs)\\n        {\\n            int ni = i + dir[0], nj = j + dir[1];\\n            if(ni==prei&&nj==prej)continue;\\n            if(dfs(grid, ni, nj, i, j, visited, m, n, color))return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{-1,0},{1,0},{0,1},{0,-1}};\\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(!visited[i][j]&&dfs(grid, i, j, -1, -1, visited, m, n, grid[i][j]))\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] grid, int i, int j, int prei, int prej, boolean[][] visited, int m, int n, int color)\\n    {\\n        if(i<0||j<0||i>=m||j>=n||grid[i][j]!=color)return false;\\n        if(visited[i][j])return true;\\n        visited[i][j] = true;\\n        for(int[] dir : dirs)\\n        {\\n            int ni = i + dir[0], nj = j + dir[1];\\n            if(ni==prei&&nj==prej)continue;\\n            if(dfs(grid, ni, nj, i, j, visited, m, n, color))return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391066,
                "title": "typical-dfs-post-this-question-should-be-medium-easy",
                "content": "I am usually the one who finds certain Medium/Easy questions should be labelled as HARD\\nThis is one of those rare cases where a HARD question should be Easy/Medium \":D\\n\\n```python\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        visited=set([])\\n        \\n        moveset=((0,1),(1,0),(-1,0),(0,-1))\\n        \\n        R,C=len(grid),len(grid[0])\\n        \\n        is_cyclic=False\\n        \\n        def traverse(r,c,l,prev_move):\\n            \\n            nonlocal visited,R,C,is_cyclic\\n            \\n            visited.add((r,c))\\n            \\n            if is_cyclic:\\n                return\\n            \\n            for nextmove in moveset:\\n                nr=r+nextmove[0]\\n                nc=c+nextmove[1]\\n                if 0<=nr<R and 0<=nc<C and grid[nr][nc] == l:\\n                    if not (nr,nc) in visited and (nr,nc) != prev_move:\\n                        traverse(nr,nc,l,(r,c))\\n                    elif  (nr,nc) in visited and (nr,nc) != prev_move:\\n                        is_cyclic=True\\n                        return\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                if not (r,c) in visited:\\n                    traverse(r,c,grid[r][c],None)\\n                    if is_cyclic:\\n                        return True\\n        \\n        return is_cyclic\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        visited=set([])\\n        \\n        moveset=((0,1),(1,0),(-1,0),(0,-1))\\n        \\n        R,C=len(grid),len(grid[0])\\n        \\n        is_cyclic=False\\n        \\n        def traverse(r,c,l,prev_move):\\n            \\n            nonlocal visited,R,C,is_cyclic\\n            \\n            visited.add((r,c))\\n            \\n            if is_cyclic:\\n                return\\n            \\n            for nextmove in moveset:\\n                nr=r+nextmove[0]\\n                nc=c+nextmove[1]\\n                if 0<=nr<R and 0<=nc<C and grid[nr][nc] == l:\\n                    if not (nr,nc) in visited and (nr,nc) != prev_move:\\n                        traverse(nr,nc,l,(r,c))\\n                    elif  (nr,nc) in visited and (nr,nc) != prev_move:\\n                        is_cyclic=True\\n                        return\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                if not (r,c) in visited:\\n                    traverse(r,c,grid[r][c],None)\\n                    if is_cyclic:\\n                        return True\\n        \\n        return is_cyclic\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374065,
                "title": "c-dfs-clean-code",
                "content": "```\\nclass Solution {\\n    \\n    void dfs(int n, int m, int x, int y, vector<vector<char>>& grid, vector<vector<int> > &vis, vector<vector<int> > &dis, int len, int prev_len, char ch, bool &ans){\\n        if(x < 0 || x >= n || y < 0 || y >= m || grid[x][y] != ch){\\n            return;\\n        }\\n        \\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, 1, -1};\\n        \\n        if(vis[x][y] == 1){\\n            if(abs(dis[x][y] - prev_len) >= 3){\\n                ans = true;\\n            }\\n            return;\\n        }\\n        vis[x][y] = 1;\\n        dis[x][y] = len;\\n        \\n        for(int i = 0; i < 4; i++){\\n            dfs(n ,m, x + dx[i], y + dy[i], grid, vis, dis, len + 1, dis[x][y], ch, ans);\\n        }\\n    }\\n    \\n    \\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int> > vis(n, vector<int> (m, 0));\\n        vector<vector<int> > dis(n, vector<int> (m, 0));\\n        \\n        bool ans = false;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(vis[i][j] == 0){\\n                    dfs(n ,m, i, j, grid, vis, dis, 1, 1, grid[i][j], ans);\\n                    if(ans == true){\\n                        return ans;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void dfs(int n, int m, int x, int y, vector<vector<char>>& grid, vector<vector<int> > &vis, vector<vector<int> > &dis, int len, int prev_len, char ch, bool &ans){\\n        if(x < 0 || x >= n || y < 0 || y >= m || grid[x][y] != ch){\\n            return;\\n        }\\n        \\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, 1, -1};\\n        \\n        if(vis[x][y] == 1){\\n            if(abs(dis[x][y] - prev_len) >= 3){\\n                ans = true;\\n            }\\n            return;\\n        }\\n        vis[x][y] = 1;\\n        dis[x][y] = len;\\n        \\n        for(int i = 0; i < 4; i++){\\n            dfs(n ,m, x + dx[i], y + dy[i], grid, vis, dis, len + 1, dis[x][y], ch, ans);\\n        }\\n    }\\n    \\n    \\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int> > vis(n, vector<int> (m, 0));\\n        vector<vector<int> > dis(n, vector<int> (m, 0));\\n        \\n        bool ans = false;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(vis[i][j] == 0){\\n                    dfs(n ,m, i, j, grid, vis, dis, 1, 1, grid[i][j], ans);\\n                    if(ans == true){\\n                        return ans;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257605,
                "title": "simple-dfs-solution-c-commented",
                "content": "**Please upvote if you like it**\\n```\\nclass Solution {\\npublic:\\n\\t// Coordinates to be added to current node coordinates to get new coordinates in four directions\\n    int xPos[4] = {-1, 0, 1, 0};\\n    int yPos[4] = {0, 1, 0, -1};\\n\\t// DFS function returns true if a cycle is present otherwise false\\n\\t// Parameters :\\n\\t//  - visit : boolean 2d matrix where true means the node is already visited\\n\\t//  - x, y : current node coordinates\\n\\t//  - m, n : column size and row size\\n\\t//  - ch : character value of the current connected graph \\n\\t//  - parX, parY : These are the parent node coordinates\\n    bool DFS(vector<vector<char>>& grid, vector<vector<bool>>& visit, int x, int y, int m, int n, char ch, int parX, int parY){\\n\\t\\t// Mark current node as visited\\n        visit[x][y] = true;\\n        int newX, newY;\\n\\t\\t// iterate over neighbouring nodes coordinates\\n        for(int i=0; i<4; i++){\\n            newX = x + xPos[i];\\n            newY = y + yPos[i];\\n\\t\\t\\t// checking wheather newX and newY coordinates are valid, also the new node\\n\\t\\t\\t// should have the same character value of the current connected graph\\n            if(newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == ch){\\n                // Now the new Node is a valid one, so we do a DFS traversal if it is not visited already.\\n\\t\\t\\t    //  Also the DFS function returns true if it found a cycle. So in that case we immediately return true\\n\\t\\t\\t\\tif(!visit[newX][newY]){\\n                    if(DFS(grid, visit, newX, newY, m, n, ch, x, y))\\n                        return true;\\n                }\\n                else if((parX != newX) || (parY != newY))   \\n                    return true;\\n\\t\\t\\t\\t // If the node is already visited and the new Node is not equal to the \\n\\t\\t\\t\\t // parent node(parent node means the previous node in the current DFS path), \\n\\t\\t\\t\\t // then we can confirm the presence of a cycle\\n            }\\n        }\\n\\t\\t// If we can\\'t find cycles after completing the DFS of it\\'s neighbours\\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<bool>> visit(m, vector<bool>(n, false));\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(!visit[i][j]){\\n                    if(DFS(grid, visit, i, j, m, n, grid[i][j], -1, -1))\\n                       return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Please upvote if you like it**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// Coordinates to be added to current node coordinates to get new coordinates in four directions\\n    int xPos[4] = {-1, 0, 1, 0};\\n    int yPos[4] = {0, 1, 0, -1};\\n\\t// DFS function returns true if a cycle is present otherwise false\\n\\t// Parameters :\\n\\t//  - visit : boolean 2d matrix where true means the node is already visited\\n\\t//  - x, y : current node coordinates\\n\\t//  - m, n : column size and row size\\n\\t//  - ch : character value of the current connected graph \\n\\t//  - parX, parY : These are the parent node coordinates\\n    bool DFS(vector<vector<char>>& grid, vector<vector<bool>>& visit, int x, int y, int m, int n, char ch, int parX, int parY){\\n\\t\\t// Mark current node as visited\\n        visit[x][y] = true;\\n        int newX, newY;\\n\\t\\t// iterate over neighbouring nodes coordinates\\n        for(int i=0; i<4; i++){\\n            newX = x + xPos[i];\\n            newY = y + yPos[i];\\n\\t\\t\\t// checking wheather newX and newY coordinates are valid, also the new node\\n\\t\\t\\t// should have the same character value of the current connected graph\\n            if(newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == ch){\\n                // Now the new Node is a valid one, so we do a DFS traversal if it is not visited already.\\n\\t\\t\\t    //  Also the DFS function returns true if it found a cycle. So in that case we immediately return true\\n\\t\\t\\t\\tif(!visit[newX][newY]){\\n                    if(DFS(grid, visit, newX, newY, m, n, ch, x, y))\\n                        return true;\\n                }\\n                else if((parX != newX) || (parY != newY))   \\n                    return true;\\n\\t\\t\\t\\t // If the node is already visited and the new Node is not equal to the \\n\\t\\t\\t\\t // parent node(parent node means the previous node in the current DFS path), \\n\\t\\t\\t\\t // then we can confirm the presence of a cycle\\n            }\\n        }\\n\\t\\t// If we can\\'t find cycles after completing the DFS of it\\'s neighbours\\n        return false;\\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<bool>> visit(m, vector<bool>(n, false));\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(!visit[i][j]){\\n                    if(DFS(grid, visit, i, j, m, n, grid[i][j], -1, -1))\\n                       return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245708,
                "title": "bfs-cycle-detection",
                "content": "First generate connected blocks and form it as a undirected graph. By construction, there will not be cycle as length 3. The proble reduces to detect cycle in the unidrected graph. As we know it is connected, there is a cycle iff numEdge >= numNode. \\n```\\nconst int go_x[4] = {1, -1, 0, 0};\\nconst int go_y[4] = {0, 0, 1, -1};\\n\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<bool>> isVisited(n, vector<bool>(m, false));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (isVisited[i][j]) continue;\\n                isVisited[i][j] = true;\\n                queue<pair<int, int>> myQueue;\\n                myQueue.push(make_pair(i, j));\\n                int numNode = 0;\\n                int numEdge = 0;\\n                while (!myQueue.empty()) {\\n                    numNode++;\\n                    int cx = myQueue.front().first;\\n                    int cy = myQueue.front().second;\\n                    myQueue.pop();\\n                    for (int d = 0; d < 4; d++) {\\n                        int tx = cx + go_x[d];\\n                        int ty = cy + go_y[d];\\n                        if (tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == grid[i][j]) {\\n                            numEdge++;\\n                            if (!isVisited[tx][ty]) {\\n                                isVisited[tx][ty] = true;\\n                                myQueue.push(make_pair(tx, ty));\\n                            }\\n                        } \\n                    }\\n                }\\n                numEdge /= 2;\\n                if (numEdge >= numNode) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int go_x[4] = {1, -1, 0, 0};\\nconst int go_y[4] = {0, 0, 1, -1};\\n\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<bool>> isVisited(n, vector<bool>(m, false));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (isVisited[i][j]) continue;\\n                isVisited[i][j] = true;\\n                queue<pair<int, int>> myQueue;\\n                myQueue.push(make_pair(i, j));\\n                int numNode = 0;\\n                int numEdge = 0;\\n                while (!myQueue.empty()) {\\n                    numNode++;\\n                    int cx = myQueue.front().first;\\n                    int cy = myQueue.front().second;\\n                    myQueue.pop();\\n                    for (int d = 0; d < 4; d++) {\\n                        int tx = cx + go_x[d];\\n                        int ty = cy + go_y[d];\\n                        if (tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == grid[i][j]) {\\n                            numEdge++;\\n                            if (!isVisited[tx][ty]) {\\n                                isVisited[tx][ty] = true;\\n                                myQueue.push(make_pair(tx, ty));\\n                            }\\n                        } \\n                    }\\n                }\\n                numEdge /= 2;\\n                if (numEdge >= numNode) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141084,
                "title": "python-solution-with-comments",
                "content": "Start with a cell. Then check if any of its neighbors contain the same value. If so, check those neighbors to see if they also contain the same value. Continue checking neighbors until:\\n* a) we end up back at a cell we\\'ve already seen -> return True.\\n* b) we come across a cell whose only neighbor is the one we\\'d just seen right before this one -> exit this local visit and start again with another cell we haven\\'t visited yet (globally).\\n\\nIf we\\'ve checked all possible cells and still haven\\'t found a cycle, then return False.\\n\\n```\\nclass Solution():\\n    def containsCycle(self, grid):\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        visited_global = set()\\n        \\n        def get_neighbors(row, col):\\n            \"\"\"\\n            Returns a list of neighbors containing same value as the input\\n            cell.\\n            \"\"\"\\n            return [(i, j) for i, j in [(row - 1, col),\\n                                        (row + 1, col),\\n                                        (row, col - 1),\\n                                        (row, col + 1)]\\n                    if 0 <= i < rows and 0 <= j < cols\\n                    and grid[i][j] == grid[row][col]]\\n\\n        \\n        def dfs(row, col, value, prev, visited_locally):\\n\\n            # If we\\'ve already seen this cell on this local visit, then we\\n            # know we\\'ve completed a cycle.\\n            if (row, col) in visited_locally:\\n                return True\\n\\n            # Otherwise, add the cell to our local and global visit logs.\\n            visited_locally.add((row, col))\\n            visited_global.add((row, col))\\n\\n            # Continue visiting new neighbors on this local visit until\\n            # we either complete the cycle or run out of neighbors to check.\\n            for i, j in get_neighbors(row, col):\\n\\n                # If the only neighbor we have is the previously visited\\n                # cell, then there is no cycle.\\n                if not prev or prev != (i, j):\\n                    if dfs(i, j, value, (row, col), visited_locally):\\n                        return True\\n            return False\\n\\n        # Keep running dfs on (globally) unvisited cells until we either\\n        #   a) find a valid cycle and return True, or\\n        #   b) run out of cells to (globally) visit.\\n        for r in range(rows):\\n            for c in range(cols):\\n\\n                # If we haven\\'t (globally) visited this cell yet, start\\n                # a new (local) visit.\\n                if (r, c) not in visited_global:\\n                    visited_locally = set()\\n                    if dfs(r, c, grid[r][c], None, visited_locally):\\n                        return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution():\\n    def containsCycle(self, grid):\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        visited_global = set()\\n        \\n        def get_neighbors(row, col):\\n            \"\"\"\\n            Returns a list of neighbors containing same value as the input\\n            cell.\\n            \"\"\"\\n            return [(i, j) for i, j in [(row - 1, col),\\n                                        (row + 1, col),\\n                                        (row, col - 1),\\n                                        (row, col + 1)]\\n                    if 0 <= i < rows and 0 <= j < cols\\n                    and grid[i][j] == grid[row][col]]\\n\\n        \\n        def dfs(row, col, value, prev, visited_locally):\\n\\n            # If we\\'ve already seen this cell on this local visit, then we\\n            # know we\\'ve completed a cycle.\\n            if (row, col) in visited_locally:\\n                return True\\n\\n            # Otherwise, add the cell to our local and global visit logs.\\n            visited_locally.add((row, col))\\n            visited_global.add((row, col))\\n\\n            # Continue visiting new neighbors on this local visit until\\n            # we either complete the cycle or run out of neighbors to check.\\n            for i, j in get_neighbors(row, col):\\n\\n                # If the only neighbor we have is the previously visited\\n                # cell, then there is no cycle.\\n                if not prev or prev != (i, j):\\n                    if dfs(i, j, value, (row, col), visited_locally):\\n                        return True\\n            return False\\n\\n        # Keep running dfs on (globally) unvisited cells until we either\\n        #   a) find a valid cycle and return True, or\\n        #   b) run out of cells to (globally) visit.\\n        for r in range(rows):\\n            for c in range(cols):\\n\\n                # If we haven\\'t (globally) visited this cell yet, start\\n                # a new (local) visit.\\n                if (r, c) not in visited_global:\\n                    visited_locally = set()\\n                    if dfs(r, c, grid[r][c], None, visited_locally):\\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092175,
                "title": "c-312ms-66-dfs",
                "content": "Runtime: 312 ms, faster than 66.26% of C++ online submissions for Detect Cycles in 2D Grid.\\nMemory Usage: 269.3 MB, less than 5.16% of C++ online submissions for Detect Cycles in 2D Grid.\\n\\nGeneral idea for DFS - move in grid only right and down direction from cell that have both neighbours (lower and right) and each DFS will have mark into grid with unique level;\\n\\n```\\nclass Solution {\\npublic:\\n  bool containsCycle(vector<vector<char>>& grid){\\n    int y = grid.size(), x = grid[0].size();\\n    int yend = y - 1, xend = x - 1, level = 0;\\n    if(!yend || !xend) return false;\\n    vector<vector<int>> table(y, vector<int>(x,0));\\n    \\n    for(int yy = 0; yy != yend; yy++)\\n      for(int xx = 0; xx != xend; xx++){\\n        if(table[yy][xx]) continue;\\n        char let = grid[yy][xx];\\n  \\n        stack<pair<int, int>> st;\\n        table[yy][xx] = ++level;\\n        \\n        if(xx == xend || grid[yy][xx+1] != let || yy == yend || grid[yy+1][xx] != let) continue;\\n        \\n        st.push({yy+1,xx});\\n        st.push({yy,xx+1});\\n        \\n        while(!st.empty()){\\n          auto [ty, tx] = st.top(); st.pop();\\n          table[ty][tx] = level;\\n          \\n          if(ty != yend)\\n            if(table[ty+1][tx] == level) return true;\\n            else if(grid[ty+1][tx] == let) st.push({ty+1,tx});\\n          \\n          if(tx != xend)\\n            if(table[ty][tx+1] == level) return true;\\n            else if(grid[ty][tx+1] == let) st.push({ty,tx+1});\\n        }\\n      }\\n    \\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool containsCycle(vector<vector<char>>& grid){\\n    int y = grid.size(), x = grid[0].size();\\n    int yend = y - 1, xend = x - 1, level = 0;\\n    if(!yend || !xend) return false;\\n    vector<vector<int>> table(y, vector<int>(x,0));\\n    \\n    for(int yy = 0; yy != yend; yy++)\\n      for(int xx = 0; xx != xend; xx++){\\n        if(table[yy][xx]) continue;\\n        char let = grid[yy][xx];\\n  \\n        stack<pair<int, int>> st;\\n        table[yy][xx] = ++level;\\n        \\n        if(xx == xend || grid[yy][xx+1] != let || yy == yend || grid[yy+1][xx] != let) continue;\\n        \\n        st.push({yy+1,xx});\\n        st.push({yy,xx+1});\\n        \\n        while(!st.empty()){\\n          auto [ty, tx] = st.top(); st.pop();\\n          table[ty][tx] = level;\\n          \\n          if(ty != yend)\\n            if(table[ty+1][tx] == level) return true;\\n            else if(grid[ty+1][tx] == let) st.push({ty+1,tx});\\n          \\n          if(tx != xend)\\n            if(table[ty][tx+1] == level) return true;\\n            else if(grid[ty][tx+1] == let) st.push({ty,tx+1});\\n        }\\n      }\\n    \\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058846,
                "title": "need-to-adjust-difficulty-level",
                "content": "this is just a straight forward dfs, at most medium, please adjust the difficulty level",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 989926,
                "title": "java-best-concise-dfs",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n    int m,n;\\n    boolean[][] v;\\n    public boolean containsCycle(char[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        this.v = new boolean[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!v[i][j]){\\n                    boolean res = dfs(grid, i, j, grid[i][j], -1, -1);\\n                    if(res) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(char[][] grid, int i, int j, char target, int oi, int oj){\\n        if(i < 0 || i >= m || j < 0 || j >= n) return false;\\n        if(grid[i][j] != target) return false;\\n        if(v[i][j]) return true;\\n        v[i][j] = true;\\n        boolean cur = false;\\n        for(int[] d : dirs){\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            if(oi != -1 && oj != -1){\\n                if(x == oi && y == oj){\\n                    continue;\\n                }\\n            }\\n            cur |= dfs(grid, x, y, target, i, j);\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n    int m,n;\\n    boolean[][] v;\\n    public boolean containsCycle(char[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        this.v = new boolean[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!v[i][j]){\\n                    boolean res = dfs(grid, i, j, grid[i][j], -1, -1);\\n                    if(res) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(char[][] grid, int i, int j, char target, int oi, int oj){\\n        if(i < 0 || i >= m || j < 0 || j >= n) return false;\\n        if(grid[i][j] != target) return false;\\n        if(v[i][j]) return true;\\n        v[i][j] = true;\\n        boolean cur = false;\\n        for(int[] d : dirs){\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            if(oi != -1 && oj != -1){\\n                if(x == oi && y == oj){\\n                    continue;\\n                }\\n            }\\n            cur |= dfs(grid, x, y, target, i, j);\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887890,
                "title": "c-dfs-98-runtime-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int dfs(int parentX, int parentY, int x, int y, vector<vector<int>>& visited, vector<vector<char>>& grid){\\n        //if(x <0 || x >= grid.size() || y < 0 || y >= grid[0].size()) return 0;\\n        //else if(!(parentX == -1 && parentY == -1)){if(grid[x][y] != grid[parentX][parentY]) return 0;} \\n        visited[x][y] = 1;\\n        int x1 = x>0 && (grid[x][y] == grid[x-1][y] && (parentX != x-1 || parentY != y)) && (visited[x-1][y] || dfs(x, y, x-1, y, visited, grid));\\n        if(x1) return 1;\\n        int x2 = y>0 && (grid[x][y] == grid[x][y-1] && (parentX != x || parentY != y-1)) && (visited[x][y-1] || dfs(x, y, x, y-1, visited, grid));\\n         if(x2) return 1;\\n        int x3 = x<grid.size()-1 && (grid[x][y] == grid[x+1][y] && (parentX != x+1 || parentY != y)) && (visited[x+1][y] || dfs(x, y, x+1, y, visited, grid));\\n         if(x3) return 1;\\n        int x4 = y<grid[0].size()-1 && (grid[x][y] == grid[x][y+1] && (parentX != x || parentY != y+1)) && (visited[x][y+1] || dfs(x, y, x, y+1, visited, grid));\\n        if(x4) return 1;\\n        return 0;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i = 0; i<grid.size(); i++){\\n            for(int j = 0; j<grid[0].size(); j++){\\n                if(!visited[i][j]) if(dfs(-1, -1, i, j, visited, grid)) return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dfs(int parentX, int parentY, int x, int y, vector<vector<int>>& visited, vector<vector<char>>& grid){\\n        //if(x <0 || x >= grid.size() || y < 0 || y >= grid[0].size()) return 0;\\n        //else if(!(parentX == -1 && parentY == -1)){if(grid[x][y] != grid[parentX][parentY]) return 0;} \\n        visited[x][y] = 1;\\n        int x1 = x>0 && (grid[x][y] == grid[x-1][y] && (parentX != x-1 || parentY != y)) && (visited[x-1][y] || dfs(x, y, x-1, y, visited, grid));\\n        if(x1) return 1;\\n        int x2 = y>0 && (grid[x][y] == grid[x][y-1] && (parentX != x || parentY != y-1)) && (visited[x][y-1] || dfs(x, y, x, y-1, visited, grid));\\n         if(x2) return 1;\\n        int x3 = x<grid.size()-1 && (grid[x][y] == grid[x+1][y] && (parentX != x+1 || parentY != y)) && (visited[x+1][y] || dfs(x, y, x+1, y, visited, grid));\\n         if(x3) return 1;\\n        int x4 = y<grid[0].size()-1 && (grid[x][y] == grid[x][y+1] && (parentX != x || parentY != y+1)) && (visited[x][y+1] || dfs(x, y, x, y+1, visited, grid));\\n        if(x4) return 1;\\n        return 0;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i = 0; i<grid.size(); i++){\\n            for(int j = 0; j<grid[0].size(); j++){\\n                if(!visited[i][j]) if(dfs(-1, -1, i, j, visited, grid)) return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875968,
                "title": "c-3-colors-with-dfs",
                "content": "Learn this technique from our veteran @votrubac. We do DFS to find cycles, each cell in the grid will have three state:\\n\\n- Not visited - 0\\n- Visited and currently in our exploring path - 1\\n- Visited and completely explored - 2\\n\\nSo while doing DFS, if we see cell with `visited = 1` means we have a cycle. We should also keep track of parent node to avoid false cycles.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> const d = {{-1,0},{1,0},{0,-1},{0,1}};\\n    bool dfs(vector<vector<char>>& grid, vector<vector<int>>& visited, int x, int y, int px, int py) {\\n        if (visited[x][y] > 0) {\\n            return visited[x][y] == 1;\\n        }\\n        visited[x][y] = 1;\\n        int m = grid.size(), n = grid[0].size();\\n        for (auto &[dx,dy] : d) {\\n            if (x+dx < 0 || x+dx >= m || y+dy < 0 || y+dy >= n) continue;\\n            if (grid[x+dx][y+dy] != grid[x][y]) continue;\\n            if (x+dx == px && y+dy == py) continue;\\n            if (dfs(grid,visited,x+dx,y+dy,x,y)) return true;\\n        }\\n        visited[x][y] = 2;\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> visited(m,vector<int>(n,0));\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (dfs(grid,visited, i, j, -1, -1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> const d = {{-1,0},{1,0},{0,-1},{0,1}};\\n    bool dfs(vector<vector<char>>& grid, vector<vector<int>>& visited, int x, int y, int px, int py) {\\n        if (visited[x][y] > 0) {\\n            return visited[x][y] == 1;\\n        }\\n        visited[x][y] = 1;\\n        int m = grid.size(), n = grid[0].size();\\n        for (auto &[dx,dy] : d) {\\n            if (x+dx < 0 || x+dx >= m || y+dy < 0 || y+dy >= n) continue;\\n            if (grid[x+dx][y+dy] != grid[x][y]) continue;\\n            if (x+dx == px && y+dy == py) continue;\\n            if (dfs(grid,visited,x+dx,y+dy,x,y)) return true;\\n        }\\n        visited[x][y] = 2;\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> visited(m,vector<int>(n,0));\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (dfs(grid,visited, i, j, -1, -1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829849,
                "title": "cpp-dfs-with-explanation",
                "content": "[Solution] Just simple dfs, with some points.\\n1. skip some positions which can\\'t make cycle path, by counting neighbor four positions with the same value, which are not visited.\\nThe count must greater than or equal to number 2 (in and out)\\ne.g.   \\n          a b b\\n          a a a\\n\\t\\t  a a a\\n\\t\\t  the first \\'a\\' can\\'t make cycle path, we should label it to visited, and skip. \\n2. use only one \\'visited\\' matrix to solve\\n```\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n        for(int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[0].size(); ++j) {\\n                if (getcount(grid, i, j, visited) < 2) {\\n                    visited[i][j] = true;\\n                    continue;\\n                }\\n                if (!visited[i][j]) {\\n                    bool flag = dfs(grid, visited, 1, i + 1, j, i, j) || \\n                                dfs(grid, visited, 1, i - 1, j, i, j) ||\\n                                dfs(grid, visited, 1, i, j + 1, i, j) || \\n                                dfs(grid, visited, 1, i, j - 1, i, j);\\n                    if (flag) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int getcount(vector<vector<char>>& grid, int x, int y, vector<vector<bool>> &visited) {\\n        int count = 0;\\n        if (x - 1 >= 0 && !visited[x-1][y]) {\\n            count += (grid[x-1][y] == grid[x][y] ? 1 : 0);\\n        }\\n        if (x + 1 < grid.size() && !visited[x+1][y]) {\\n            count += (grid[x+1][y] == grid[x][y] ? 1 : 0);\\n        }\\n        if (y - 1 >= 0 && !visited[x][y-1]) {\\n            count += (grid[x][y-1] == grid[x][y] ? 1 : 0);\\n        }\\n        if (y + 1 < grid[0].size() && !visited[x][y+1]) {\\n            count += (grid[x][y+1] == grid[x][y] ? 1 : 0);\\n        }\\n        return count;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& grid, vector<vector<bool>> &visited, int length, int x, int y, int start_x, int start_y) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] != grid[start_x][start_y]) {\\n            return false;\\n        }\\n        if (start_x == x && start_y == y) {\\n            if (length >= 4) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (visited[x][y]) {\\n            return false;\\n        }\\n        visited[x][y] = true;\\n        return \\n        dfs(grid, visited, length + 1, x + 1, y, start_x, start_y) || \\n        dfs(grid, visited, length + 1, x - 1, y, start_x, start_y) ||\\n        dfs(grid, visited, length + 1, x, y - 1, start_x, start_y) ||\\n        dfs(grid, visited, length + 1, x, y + 1, start_x, start_y);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n        for(int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[0].size(); ++j) {\\n                if (getcount(grid, i, j, visited) < 2) {\\n                    visited[i][j] = true;\\n                    continue;\\n                }\\n                if (!visited[i][j]) {\\n                    bool flag = dfs(grid, visited, 1, i + 1, j, i, j) || \\n                                dfs(grid, visited, 1, i - 1, j, i, j) ||\\n                                dfs(grid, visited, 1, i, j + 1, i, j) || \\n                                dfs(grid, visited, 1, i, j - 1, i, j);\\n                    if (flag) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int getcount(vector<vector<char>>& grid, int x, int y, vector<vector<bool>> &visited) {\\n        int count = 0;\\n        if (x - 1 >= 0 && !visited[x-1][y]) {\\n            count += (grid[x-1][y] == grid[x][y] ? 1 : 0);\\n        }\\n        if (x + 1 < grid.size() && !visited[x+1][y]) {\\n            count += (grid[x+1][y] == grid[x][y] ? 1 : 0);\\n        }\\n        if (y - 1 >= 0 && !visited[x][y-1]) {\\n            count += (grid[x][y-1] == grid[x][y] ? 1 : 0);\\n        }\\n        if (y + 1 < grid[0].size() && !visited[x][y+1]) {\\n            count += (grid[x][y+1] == grid[x][y] ? 1 : 0);\\n        }\\n        return count;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& grid, vector<vector<bool>> &visited, int length, int x, int y, int start_x, int start_y) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] != grid[start_x][start_y]) {\\n            return false;\\n        }\\n        if (start_x == x && start_y == y) {\\n            if (length >= 4) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (visited[x][y]) {\\n            return false;\\n        }\\n        visited[x][y] = true;\\n        return \\n        dfs(grid, visited, length + 1, x + 1, y, start_x, start_y) || \\n        dfs(grid, visited, length + 1, x - 1, y, start_x, start_y) ||\\n        dfs(grid, visited, length + 1, x, y - 1, start_x, start_y) ||\\n        dfs(grid, visited, length + 1, x, y + 1, start_x, start_y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820414,
                "title": "java-space-effecient-union-find-solution-beats-100",
                "content": "The basic idea is to travel through the matrix, in the meantime check the upper item and the left item for the current one. \\n\\nIf \\n1. the current, the upper and the left items are all the same, and \\n2. the upper and the left has already been connected,\\n\\nwe find a circle.\\n```\\npublic boolean containsCycle(char[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tint[] root = new int[m * n];\\n\\tfor (int i = 0; i < m * n; i++) root[i] = i;\\n\\tfor (int i = 0; i < m; i++)\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint id1 = i * n + j, id2 = id1, id3 = id1;\\n\\t\\t\\tif (i >= 1 && grid[i][j] == grid[i - 1][j]) {\\n\\t\\t\\t\\tid2 = find(root, (i - 1) * n + j);\\n\\t\\t\\t\\tif (id1 != id2) {\\n\\t\\t\\t\\t\\troot[id1] = id2;\\n\\t\\t\\t\\t\\tid1 = id2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (j >= 1 && grid[i][j] == grid[i][j - 1]) {\\n\\t\\t\\t\\tid3 = find(root, i * n + j - 1);\\n\\t\\t\\t\\tif (i >= 1 && grid[i][j] == grid[i - 1][j] && id2 == id3) return true;\\n\\t\\t\\t\\tif (id1 != id3) root[id1] = id3;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn false;\\n}\\n\\nprivate int find(int[] root, int i) {\\n\\treturn root[i] == i ? i : (root[i] = find(root, root[i]));\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic boolean containsCycle(char[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tint[] root = new int[m * n];\\n\\tfor (int i = 0; i < m * n; i++) root[i] = i;\\n\\tfor (int i = 0; i < m; i++)\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint id1 = i * n + j, id2 = id1, id3 = id1;\\n\\t\\t\\tif (i >= 1 && grid[i][j] == grid[i - 1][j]) {\\n\\t\\t\\t\\tid2 = find(root, (i - 1) * n + j);\\n\\t\\t\\t\\tif (id1 != id2) {\\n\\t\\t\\t\\t\\troot[id1] = id2;\\n\\t\\t\\t\\t\\tid1 = id2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (j >= 1 && grid[i][j] == grid[i][j - 1]) {\\n\\t\\t\\t\\tid3 = find(root, i * n + j - 1);\\n\\t\\t\\t\\tif (i >= 1 && grid[i][j] == grid[i - 1][j] && id2 == id3) return true;\\n\\t\\t\\t\\tif (id1 != id3) root[id1] = id3;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn false;\\n}\\n\\nprivate int find(int[] root, int i) {\\n\\treturn root[i] == i ? i : (root[i] = find(root, root[i]));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 814370,
                "title": "python-3-simplest-union-find-solution",
                "content": "We traverse the grid in row-col order.\\nIn a cycle, let the top-left(the first we meet) element be the first ancestor of the set, and the bottom-right element be the ending element. We start from the top-left, when we encounter the bottom-right ending element, we find a cycle. \\nThe only situation where a cycle ends is:\\n............\\n..........X\\n.......XX\\nWhich means the elements to its left and top are the same char as it, and they share the same ancestor(belong to the same union-set)\\n\\nThere are two conditions when we try to merge a new element to a cycle candidate(a union set):\\n1. .....XX, the left char is the same as current element\\n2. .......X\\n    .......X     Current char is the same as the one to its top.\\nWe merge merge two sets where the two chars respectively belong to.\\n\\n```\\nimport collections\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        rows, cols = len(grid), len(grid[0])\\n        ancestors = dict()\\n        for r in range(rows):\\n            for c in range(cols):\\n                ancestors[(r, c)] = (r, c)\\n        def find(x, y):\\n            if ancestors[(x, y)] != (x, y):\\n                xx, yy = ancestors[(x, y)] \\n                ancestors[(x, y)] = find(xx, yy)\\n            return ancestors[(x, y)]\\n        \\n        def union(x1, y1, x2, y2):\\n\\t\\t\\t# merge two sets where (x1, y1) and (x2, y2) respectively belong to\\n            ancestors[find(x2, y2)] = find(x1, y1)\\n            \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r == 0 and c == 0:\\n                    continue\\n                if r > 0 and c > 0 and grid[r - 1][c] == grid[r][c - 1] == grid[r][c] and find(r - 1, c) == find(r, c - 1):\\n                    return True\\n                if c > 0 and grid[r][c - 1] == grid[r][c]:\\n                    union(r, c - 1, r, c)\\n                if r > 0 and grid[r - 1][c] == grid[r][c]:\\n                    union(r, c, r - 1, c)\\n        return False        \\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        rows, cols = len(grid), len(grid[0])\\n        ancestors = dict()\\n        for r in range(rows):\\n            for c in range(cols):\\n                ancestors[(r, c)] = (r, c)\\n        def find(x, y):\\n            if ancestors[(x, y)] != (x, y):\\n                xx, yy = ancestors[(x, y)] \\n                ancestors[(x, y)] = find(xx, yy)\\n            return ancestors[(x, y)]\\n        \\n        def union(x1, y1, x2, y2):\\n\\t\\t\\t# merge two sets where (x1, y1) and (x2, y2) respectively belong to\\n            ancestors[find(x2, y2)] = find(x1, y1)\\n            \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r == 0 and c == 0:\\n                    continue\\n                if r > 0 and c > 0 and grid[r - 1][c] == grid[r][c - 1] == grid[r][c] and find(r - 1, c) == find(r, c - 1):\\n                    return True\\n                if c > 0 and grid[r][c - 1] == grid[r][c]:\\n                    union(r, c - 1, r, c)\\n                if r > 0 and grid[r - 1][c] == grid[r][c]:\\n                    union(r, c, r - 1, c)\\n        return False        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 812555,
                "title": "dfs-undirected-graph-cycle-detection-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> visited;\\n   \\n    bool cycle=false;\\n    \\n    bool isSafe(int i, int j, vector<vector<char>>& grid, char c, int pi, int pj){\\n        if(i>=0 && j>=0 && i<grid.size() && j<grid[0].size() && grid[i][j]==c){\\n            if(visited[i][j]==true){\\n                if(pi==i && pj==j){\\n                    return false;\\n                }\\n                cycle=true;\\n                \\n                return false;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    void dfs(int i, int j, vector<vector<char>>& grid, int px, int py){\\n        visited[i][j]=true;\\n     \\n        \\n        if(isSafe(i+1, j, grid, grid[i][j], px, py)) dfs(i+1, j, grid, i, j);\\n        if(cycle) return;\\n        \\n        if(isSafe(i, j+1, grid, grid[i][j], px, py)) dfs(i, j+1, grid, i, j);\\n        if(cycle) return;\\n        \\n        if(isSafe(i, j-1, grid, grid[i][j], px, py)) dfs(i, j-1, grid, i, j);\\n        if(cycle) return;\\n        \\n        if(isSafe(i-1, j, grid, grid[i][j], px, py)) dfs(i-1, j, grid, i, j);\\n        if(cycle) return;\\n        \\n      \\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        visited.resize(m);\\n   \\n        for(int i=0;i<m;i++){\\n            visited[i].resize(n,0);\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visited[i][j]==false){\\n                    dfs(i,j,grid, -1, -1);\\n                    if(cycle)\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n      /*  \\n        a b b\\n        b z b\\n        b b a\\n        */\\n            \\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> visited;\\n   \\n    bool cycle=false;\\n    \\n    bool isSafe(int i, int j, vector<vector<char>>& grid, char c, int pi, int pj){\\n        if(i>=0 && j>=0 && i<grid.size() && j<grid[0].size() && grid[i][j]==c){\\n            if(visited[i][j]==true){\\n                if(pi==i && pj==j){\\n                    return false;\\n                }\\n                cycle=true;\\n                \\n                return false;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    void dfs(int i, int j, vector<vector<char>>& grid, int px, int py){\\n        visited[i][j]=true;\\n     \\n        \\n        if(isSafe(i+1, j, grid, grid[i][j], px, py)) dfs(i+1, j, grid, i, j);\\n        if(cycle) return;\\n        \\n        if(isSafe(i, j+1, grid, grid[i][j], px, py)) dfs(i, j+1, grid, i, j);\\n        if(cycle) return;\\n        \\n        if(isSafe(i, j-1, grid, grid[i][j], px, py)) dfs(i, j-1, grid, i, j);\\n        if(cycle) return;\\n        \\n        if(isSafe(i-1, j, grid, grid[i][j], px, py)) dfs(i-1, j, grid, i, j);\\n        if(cycle) return;\\n        \\n      \\n    }\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        visited.resize(m);\\n   \\n        for(int i=0;i<m;i++){\\n            visited[i].resize(n,0);\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visited[i][j]==false){\\n                    dfs(i,j,grid, -1, -1);\\n                    if(cycle)\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n      /*  \\n        a b b\\n        b z b\\n        b b a\\n        */\\n            \\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810235,
                "title": "ruby-dfs-with-explanation",
                "content": "1. Using DFS. But don\\'t use recursion because recursion causes stack overflow\\n2. For current visiting node,  never connects back to its father node. (the key is here )\\n3. When a visited node occurs, cycle detected \\n```\\ndef contains_cycle(grid)\\n    row, col = grid.length, grid[0].length\\n    \\n    visited = Array.new(row) {Array.new(col, false)}\\n    \\n\\n    (0...row).each do |i|\\n        (0...col).each do |j|\\n            if not visited[i][j]\\n                return true if dfs(i, j, grid, visited )\\n            end \\n            \\n        end \\n    end \\n    \\n    return false \\nend\\n\\ndef dfs(start_i, start_j, grid, visited)\\n    stack = []\\n    stack << [start_i, start_j, nil, nil]\\n    \\n    \\n    while stack.length > 0 \\n        cur = stack.pop \\n        cur_i, cur_j, father_i, father_j = cur[0],cur[1],cur[2],cur[3]\\n        visited[cur_i][cur_j] = true \\n        edges = next_edges(cur_i, cur_j, grid, father_i, father_j )\\n        edges.each do |(next_i, next_j)|\\n            if visited[next_i][next_j]\\n                return true \\n            else\\n                stack << [next_i, next_j, cur_i, cur_j]\\n            end \\n            \\n        end \\n        \\n    end \\n    \\n    \\n    return false \\n    \\nend \\n\\n\\ndef next_edges(cur_i, cur_j, grid, father_i, father_j)   \\n    row, col = grid.length, grid[0].length \\n    \\n    nodes = []\\n    [[-1, 0], [1, 0], [0, -1], [0, 1]].each do |(dir_i, dir_j)|\\n        next_i, next_j = cur_i + dir_i, cur_j + dir_j\\n        \\n        nodes << [next_i, next_j] if next_i < row && next_i >= 0 && next_j < col && next_j >=0 && grid[next_i][next_j] == grid[cur_i][cur_j]\\n        \\n    end \\n    \\n    nodes.delete_if {|(i, j)| i == father_i && j == father_j}\\n    \\nend \\n```",
                "solutionTags": [],
                "code": "```\\ndef contains_cycle(grid)\\n    row, col = grid.length, grid[0].length\\n    \\n    visited = Array.new(row) {Array.new(col, false)}\\n    \\n\\n    (0...row).each do |i|\\n        (0...col).each do |j|\\n            if not visited[i][j]\\n                return true if dfs(i, j, grid, visited )\\n            end \\n            \\n        end \\n    end \\n    \\n    return false \\nend\\n\\ndef dfs(start_i, start_j, grid, visited)\\n    stack = []\\n    stack << [start_i, start_j, nil, nil]\\n    \\n    \\n    while stack.length > 0 \\n        cur = stack.pop \\n        cur_i, cur_j, father_i, father_j = cur[0],cur[1],cur[2],cur[3]\\n        visited[cur_i][cur_j] = true \\n        edges = next_edges(cur_i, cur_j, grid, father_i, father_j )\\n        edges.each do |(next_i, next_j)|\\n            if visited[next_i][next_j]\\n                return true \\n            else\\n                stack << [next_i, next_j, cur_i, cur_j]\\n            end \\n            \\n        end \\n        \\n    end \\n    \\n    \\n    return false \\n    \\nend \\n\\n\\ndef next_edges(cur_i, cur_j, grid, father_i, father_j)   \\n    row, col = grid.length, grid[0].length \\n    \\n    nodes = []\\n    [[-1, 0], [1, 0], [0, -1], [0, 1]].each do |(dir_i, dir_j)|\\n        next_i, next_j = cur_i + dir_i, cur_j + dir_j\\n        \\n        nodes << [next_i, next_j] if next_i < row && next_i >= 0 && next_j < col && next_j >=0 && grid[next_i][next_j] == grid[cur_i][cur_j]\\n        \\n    end \\n    \\n    nodes.delete_if {|(i, j)| i == father_i && j == father_j}\\n    \\nend \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 806630,
                "title": "python3-memoized-dfs-with-a-direction-parameter-16-line",
                "content": "Standard dfs with an extra parameter indicating \"direction\"\\n\\n```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache(None)\\n        def fn(i, j, d): \\n            \"\"\"Traverse the grid to find cycle via backtracking.\"\"\"\\n            if grid[i][j] != \"BLACK\": \\n                val = grid[i][j]\\n                grid[i][j] = \"GRAY\" # mark visited in this trial\\n                for ii, jj, dd in ((i-1, j, -2), (i, j-1, -1), (i, j+1, 1), (i+1, j, 2)):\\n                    if 0 <= ii < m and 0 <= jj < n and d + dd != 0: # in range & not going back \\n                        if grid[ii][jj] == \"GRAY\": return True #cycle found \\n                        if grid[ii][jj] == val: fn(ii, jj, dd)\\n                grid[i][j] = val \\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if fn(i, j, 0): return True\\n                grid[i][j] = \"BLACK\" # mark \"no cycle\"\\n        return False \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache(None)\\n        def fn(i, j, d): \\n            \"\"\"Traverse the grid to find cycle via backtracking.\"\"\"\\n            if grid[i][j] != \"BLACK\": \\n                val = grid[i][j]\\n                grid[i][j] = \"GRAY\" # mark visited in this trial\\n                for ii, jj, dd in ((i-1, j, -2), (i, j-1, -1), (i, j+1, 1), (i+1, j, 2)):\\n                    if 0 <= ii < m and 0 <= jj < n and d + dd != 0: # in range & not going back \\n                        if grid[ii][jj] == \"GRAY\": return True #cycle found \\n                        if grid[ii][jj] == val: fn(ii, jj, dd)\\n                grid[i][j] = val \\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if fn(i, j, 0): return True\\n                grid[i][j] = \"BLACK\" # mark \"no cycle\"\\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 805823,
                "title": "c-dfs-clear-and-concise-solution-approach-explained",
                "content": "Start dfs with the element present at top left corner and keep track of visited elements and parent element.\\n1.)If i and j are not in bounds,return.\\n2.)If character at i and j is not equal to the character you started the dfs with,then return.\\n3.)If the node is visited,check whether it is parent,if so return.\\n4.)if the visited node is not parent,then you have found the cycle.\\n5.)If node is not visited,call dfs to all its adjacent nodes.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<bool>>vis;\\n    vector<vector<pair<int,int>>>parent;\\n    \\n    bool dfs(int i,int j,int m,int n,vector<vector<char>>& grid,char c,int x,int y)\\n    {\\n        if(i<0||i>=m||j<0||j>=n)\\n            return false;\\n        if(grid[i][j]!=c)\\n            return false;\\n        if(vis[i][j]&&i==parent[x][y].first&&j==parent[x][y].second)\\n            return false;\\n        if(vis[i][j])\\n            return true;\\n        \\n        vis[i][j]=true;\\n        parent[i][j]={x,y};\\n        bool a=dfs(i+1,j,m,n,grid,c,i,j);\\n        bool b=dfs(i-1,j,m,n,grid,c,i,j);\\n        bool e=dfs(i,j+1,m,n,grid,c,i,j);\\n        bool d=dfs(i,j-1,m,n,grid,c,i,j);\\n        \\n        return (a||b)||(e||d);        \\n    }\\n    bool containsCycle(vector<vector<char>>& grid) \\n    {\\n        int m=grid.size();\\n        if(m==0)return false;\\n        int n=grid[0].size();\\n        vis=vector<vector<bool>>(m,vector<bool>(n));\\n        parent=vector<vector<pair<int,int>>>(m,vector<pair<int,int>>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    if(dfs(i,j,m,n,grid,grid[i][j],-1,-1))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>>vis;\\n    vector<vector<pair<int,int>>>parent;\\n    \\n    bool dfs(int i,int j,int m,int n,vector<vector<char>>& grid,char c,int x,int y)\\n    {\\n        if(i<0||i>=m||j<0||j>=n)\\n            return false;\\n        if(grid[i][j]!=c)\\n            return false;\\n        if(vis[i][j]&&i==parent[x][y].first&&j==parent[x][y].second)\\n            return false;\\n        if(vis[i][j])\\n            return true;\\n        \\n        vis[i][j]=true;\\n        parent[i][j]={x,y};\\n        bool a=dfs(i+1,j,m,n,grid,c,i,j);\\n        bool b=dfs(i-1,j,m,n,grid,c,i,j);\\n        bool e=dfs(i,j+1,m,n,grid,c,i,j);\\n        bool d=dfs(i,j-1,m,n,grid,c,i,j);\\n        \\n        return (a||b)||(e||d);        \\n    }\\n    bool containsCycle(vector<vector<char>>& grid) \\n    {\\n        int m=grid.size();\\n        if(m==0)return false;\\n        int n=grid[0].size();\\n        vis=vector<vector<bool>>(m,vector<bool>(n));\\n        parent=vector<vector<pair<int,int>>>(m,vector<pair<int,int>>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    if(dfs(i,j,m,n,grid,grid[i][j],-1,-1))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805816,
                "title": "bfs-c-video",
                "content": "https://youtu.be/eawXdMoWzH0\\n\\nAs soon as two neighbours are visited stop! thats it thats a cycle\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<vector<char>> grid; int n , m;\\n        \\n    vector<vector<bool>> vis;\\n    \\n    \\n    bool rddr(int x , int y ){\\n        \\n        queue<int> xs, ys;\\n        \\n        vis[x][y]=1;\\n        \\n        \\n        if(same(x,y+1,grid[x][y])){\\n            \\n            xs.push(x); \\n            ys.push(y+1);\\n            \\n            while(!xs.empty()){\\n                int i = xs.front()  , j = ys.front() ;\\n            \\n                xs.pop();ys.pop();\\n\\n                // if(vis[i][j])return true;\\n\\n                vis[i][j] = true;\\n                \\n                int vc = 0;\\n                \\n                if(same(i,j+1,grid[i][j]) ){\\n                    if(!vis[i][j+1])\\n                        {xs.push(i);ys.push(j+1);}\\n                    else vc++;\\n                }\\n                   \\n                if(same(i+1, j, grid[i][j])){\\n                    if(!vis[i+1][j])\\n                        {xs.push(i+1);ys.push(j);}\\n                    else vc++;\\n                }\\n                if(same(i,j-1,grid[i][j])){\\n                    if(!vis[i][j-1])\\n                        {xs.push(i);ys.push(j-1);}\\n                    else vc++;\\n                }\\n                   \\n                if(same(i-1, j, grid[i][j])){\\n                    if(!vis[i-1][j])\\n                        {xs.push(i-1);ys.push(j);}\\n                    else vc++;\\n                }\\n                if (vc>1)return true;\\n            }\\n        \\n        }//start a right -> down from here!\\n        \\n        \\n        if(same(x+1,y,grid[x][y])){\\n        \\n            xs.push(x+1); \\n            ys.push(y);\\n            \\n            while(!xs.empty()){\\n                int i = xs.front()  , j = ys.front() ;\\n            \\n                xs.pop();ys.pop();\\n\\n                if(vis[i][j])return true;\\n\\n                vis[i][j] = true;\\n                \\n                int vc = 0;\\n                \\n                if(same(i,j+1,grid[i][j]) ){\\n                    if(!vis[i][j+1])\\n                        {xs.push(i);ys.push(j+1);}\\n                    else vc++;\\n                }\\n                   \\n                if(same(i+1, j, grid[i][j])){\\n                    if(!vis[i+1][j])\\n                        {xs.push(i+1);ys.push(j);}\\n                    else vc++;\\n                }\\n                if(same(i,j-1,grid[i][j])){\\n                    if(!vis[i][j-1])\\n                        {xs.push(i);ys.push(j-1);}\\n                    else vc++;\\n                }\\n                   \\n                if(same(i-1, j, grid[i][j])){\\n                    if(!vis[i-1][j])\\n                        {xs.push(i-1);ys.push(j);}\\n                    else vc++;\\n                }\\n                if (vc>1)return true;\\n            }\\n        \\n        }\\n                   \\n        return false;\\n    }\\n    \\n\\n    \\n        \\n    bool same(int x , int y , char old){\\n        \\n        return (x>=0 && x<n && y>=0 && y<m && grid[x][y]==old);\\n        \\n        \\n    }\\n    \\n\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        \\n        this->grid = grid;\\n        n = grid.size(); m = grid[0].size();\\n        vis.resize(n, vector<bool> (m,0));\\n        \\n  \\n        for(int x = 0 ; x< n ; x ++){\\n            for(int y = 0 ; y< m ; y++){\\n                \\n                \\n                    //can be possible!\\n                    if(!vis[x][y] && same(x,y+1,grid[x][y]) && same(x+1,y,grid[x][y]) ){\\n                        \\n                        //he can be a top left corner!!!!!!!!!\\n                        if(rddr(x,y)){\\n                            cout<<\"intersections of two dfs at \"<<x<<\" \"<<y<<\"\\\\n\";\\n                            return true;\\n                        }\\n                        \\n                    }\\n                \\n                \\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<vector<char>> grid; int n , m;\\n        \\n    vector<vector<bool>> vis;\\n    \\n    \\n    bool rddr(int x , int y ){\\n        \\n        queue<int> xs, ys;\\n        \\n        vis[x][y]=1;\\n        \\n        \\n        if(same(x,y+1,grid[x][y])){\\n            \\n            xs.push(x); \\n            ys.push(y+1);\\n            \\n            while(!xs.empty()){\\n                int i = xs.front()  , j = ys.front() ;\\n            \\n                xs.pop();ys.pop();\\n\\n                // if(vis[i][j])return true;\\n\\n                vis[i][j] = true;\\n                \\n                int vc = 0;\\n                \\n                if(same(i,j+1,grid[i][j]) ){\\n                    if(!vis[i][j+1])\\n                        {xs.push(i);ys.push(j+1);}\\n                    else vc++;\\n                }\\n                   \\n                if(same(i+1, j, grid[i][j])){\\n                    if(!vis[i+1][j])\\n                        {xs.push(i+1);ys.push(j);}\\n                    else vc++;\\n                }\\n                if(same(i,j-1,grid[i][j])){\\n                    if(!vis[i][j-1])\\n                        {xs.push(i);ys.push(j-1);}\\n                    else vc++;\\n                }\\n                   \\n                if(same(i-1, j, grid[i][j])){\\n                    if(!vis[i-1][j])\\n                        {xs.push(i-1);ys.push(j);}\\n                    else vc++;\\n                }\\n                if (vc>1)return true;\\n            }\\n        \\n        }//start a right -> down from here!\\n        \\n        \\n        if(same(x+1,y,grid[x][y])){\\n        \\n            xs.push(x+1); \\n            ys.push(y);\\n            \\n            while(!xs.empty()){\\n                int i = xs.front()  , j = ys.front() ;\\n            \\n                xs.pop();ys.pop();\\n\\n                if(vis[i][j])return true;\\n\\n                vis[i][j] = true;\\n                \\n                int vc = 0;\\n                \\n                if(same(i,j+1,grid[i][j]) ){\\n                    if(!vis[i][j+1])\\n                        {xs.push(i);ys.push(j+1);}\\n                    else vc++;\\n                }\\n                   \\n                if(same(i+1, j, grid[i][j])){\\n                    if(!vis[i+1][j])\\n                        {xs.push(i+1);ys.push(j);}\\n                    else vc++;\\n                }\\n                if(same(i,j-1,grid[i][j])){\\n                    if(!vis[i][j-1])\\n                        {xs.push(i);ys.push(j-1);}\\n                    else vc++;\\n                }\\n                   \\n                if(same(i-1, j, grid[i][j])){\\n                    if(!vis[i-1][j])\\n                        {xs.push(i-1);ys.push(j);}\\n                    else vc++;\\n                }\\n                if (vc>1)return true;\\n            }\\n        \\n        }\\n                   \\n        return false;\\n    }\\n    \\n\\n    \\n        \\n    bool same(int x , int y , char old){\\n        \\n        return (x>=0 && x<n && y>=0 && y<m && grid[x][y]==old);\\n        \\n        \\n    }\\n    \\n\\n    \\n    bool containsCycle(vector<vector<char>>& grid) {\\n        \\n        this->grid = grid;\\n        n = grid.size(); m = grid[0].size();\\n        vis.resize(n, vector<bool> (m,0));\\n        \\n  \\n        for(int x = 0 ; x< n ; x ++){\\n            for(int y = 0 ; y< m ; y++){\\n                \\n                \\n                    //can be possible!\\n                    if(!vis[x][y] && same(x,y+1,grid[x][y]) && same(x+1,y,grid[x][y]) ){\\n                        \\n                        //he can be a top left corner!!!!!!!!!\\n                        if(rddr(x,y)){\\n                            cout<<\"intersections of two dfs at \"<<x<<\" \"<<y<<\"\\\\n\";\\n                            return true;\\n                        }\\n                        \\n                    }\\n                \\n                \\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 805718,
                "title": "c-easy-to-understand-dfs-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool ans;\\n\\t\\tvector<int> dir{1,0,-1,0,1};\\n\\t\\tvoid dfs(vector<vector<char>>& grid, vector<vector<int>>& visited, int x,int y,int lastX,int lastY,char cur,int color){\\n\\t\\t\\tvisited[x][y]=color;\\n\\t\\t\\tfor(int i=0;i<4;i++){\\n\\t\\t\\t\\tint a=x+dir[i];\\n\\t\\t\\t\\tint b=y+dir[i+1];\\n\\t\\t\\t\\tif(a<0 || b<0 || a>=grid.size() || b>=grid[0].size()) continue;\\n\\t\\t\\t\\tif(!(a==lastX && b==lastY) && grid[a][b]==cur && visited[a][b]==color){\\n\\t\\t\\t\\t\\tans=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(visited[a][b]==0 && !(a==lastX && b==lastY) && grid[a][b]==cur){\\n\\t\\t\\t\\t\\tdfs(grid,visited,a,b,x,y,cur,color);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbool containsCycle(vector<vector<char>>& grid) {\\n\\t\\t\\tans=false;\\n\\t\\t\\tint m=grid.size();\\n\\t\\t\\tint n=grid[0].size();\\n\\t\\t\\tvector<vector<int>> visited(m,vector<int>(n));\\n\\t\\t\\tint color=1;\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tif(visited[i][j] ==0){\\n\\t\\t\\t\\t\\t\\tdfs(grid,visited,i,j,-1,-1,grid[i][j],color);\\n\\t\\t\\t\\t\\t\\tcolor++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool ans;\\n\\t\\tvector<int> dir{1,0,-1,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 805675,
                "title": "c-concise-dfs-solution-o-n-m-with-brief-comments",
                "content": "\\nI put comments in the code, hopefully it helps. the only thing we need to care is that, we need to avoid to re-visit the previous point.  \\n```\\nclass Solution {\\npublic:\\n    bool vis[500][500];  //for detecting cycle.\\n    bool vis2[500][500];//avoid to re-visit non-cycle point.\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        for(int i = 0; i < grid.size(); ++i)\\n            for(int j = 0; j < grid[0].size(); ++j)\\n                if(dfs(grid, i, j, -1, -1, grid[i][j]))\\n                    return true;\\n        return false;\\n    }\\n    //px ===> previousX, py =====> previousY\\n    bool dfs(vector<vector<char>>& grid, int x, int y, int px, int py, int c) {\\n        if(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] != c) return false;\\n        if(vis[x][y]) return true;   //detecting cycle.\\n        if(vis2[x][y]) return false;//avoid to re-visit non-cycle point.\\n        vis[x][y] = true;\\n        vis2[x][y] = true;\\n        int d[5] = {0, 1, 0, -1, 0};\\n        bool res = false;\\n        for(int i = 0; i < 4; ++i) {\\n            int nx = d[i] + x;\\n            int ny = d[i + 1] + y;\\n            if(nx == px && ny == py) continue; //avoid to go into previous point.\\n            res |= dfs(grid, nx, ny, x, y, c);\\n            if(res) break;\\n        }\\n        if(res) return true;\\n        vis[x][y] = false;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool vis[500][500];  //for detecting cycle.\\n    bool vis2[500][500];//avoid to re-visit non-cycle point.\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        for(int i = 0; i < grid.size(); ++i)\\n            for(int j = 0; j < grid[0].size(); ++j)\\n                if(dfs(grid, i, j, -1, -1, grid[i][j]))\\n                    return true;\\n        return false;\\n    }\\n    //px ===> previousX, py =====> previousY\\n    bool dfs(vector<vector<char>>& grid, int x, int y, int px, int py, int c) {\\n        if(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] != c) return false;\\n        if(vis[x][y]) return true;   //detecting cycle.\\n        if(vis2[x][y]) return false;//avoid to re-visit non-cycle point.\\n        vis[x][y] = true;\\n        vis2[x][y] = true;\\n        int d[5] = {0, 1, 0, -1, 0};\\n        bool res = false;\\n        for(int i = 0; i < 4; ++i) {\\n            int nx = d[i] + x;\\n            int ny = d[i + 1] + y;\\n            if(nx == px && ny == py) continue; //avoid to go into previous point.\\n            res |= dfs(grid, nx, ny, x, y, c);\\n            if(res) break;\\n        }\\n        if(res) return true;\\n        vis[x][y] = false;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4107386,
                "title": "java-records-enums-dfs",
                "content": "# Intuition\\nSimilar approach to other, but use meaningful enums to indicate which direction you came from. \\n\\nIf you are making a move South of your current square, then your next recursion depth you should not be allowed to move North, so add a boolean check to avoid going back on yourself. \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n\\n        var visited = new HashSet<Point>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (!visited.contains(new Point(i, j))) {\\n                    boolean dfs = dfs(i, j, grid, visited, grid[i][j], Dir.START);\\n                    if (dfs) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return false;\\n    }\\n\\n    private boolean dfs(int i, int j, char[][] grid, HashSet<Point> visited, char c, Dir prevDir) {\\n\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != c) {\\n            return false;\\n        }\\n\\n        if (visited.contains(new Point(i, j))) {\\n            return true;\\n        }\\n\\n        visited.add(new Point(i, j));\\n\\n        boolean moveNorth = prevDir != Dir.S;\\n        boolean moveSouth = prevDir != Dir.N;\\n        boolean moveEast = prevDir != Dir.W;\\n        boolean moveWest = prevDir != Dir.E;\\n\\n        return (moveSouth && dfs(i + 1, j, grid, visited, c, Dir.S)) ||\\n                (moveEast && dfs(i, j + 1, grid, visited, c, Dir.E)) ||\\n                (moveNorth && dfs(i - 1, j, grid, visited, c, Dir.N)) ||\\n                (moveWest && dfs(i, j - 1, grid, visited, c, Dir.W));\\n    }\\n\\n    public enum Dir {N, S, E, W, START}\\n\\n    public record Point(int i, int j) {\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n\\n        var visited = new HashSet<Point>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (!visited.contains(new Point(i, j))) {\\n                    boolean dfs = dfs(i, j, grid, visited, grid[i][j], Dir.START);\\n                    if (dfs) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return false;\\n    }\\n\\n    private boolean dfs(int i, int j, char[][] grid, HashSet<Point> visited, char c, Dir prevDir) {\\n\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != c) {\\n            return false;\\n        }\\n\\n        if (visited.contains(new Point(i, j))) {\\n            return true;\\n        }\\n\\n        visited.add(new Point(i, j));\\n\\n        boolean moveNorth = prevDir != Dir.S;\\n        boolean moveSouth = prevDir != Dir.N;\\n        boolean moveEast = prevDir != Dir.W;\\n        boolean moveWest = prevDir != Dir.E;\\n\\n        return (moveSouth && dfs(i + 1, j, grid, visited, c, Dir.S)) ||\\n                (moveEast && dfs(i, j + 1, grid, visited, c, Dir.E)) ||\\n                (moveNorth && dfs(i - 1, j, grid, visited, c, Dir.N)) ||\\n                (moveWest && dfs(i, j - 1, grid, visited, c, Dir.W));\\n    }\\n\\n    public enum Dir {N, S, E, W, START}\\n\\n    public record Point(int i, int j) {\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088648,
                "title": "union-find-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass disjointset\\n{\\n\\tvector<int>rank,parent,size;\\npublic:\\n    disjointset(int n)\\n    {\\n    \\trank.resize(n+1,0);\\n    \\tparent.resize(n+1);\\n    \\tsize.resize(n+1);\\n    \\tfor(int i=0;i<n+1;i++)\\n    \\t{\\n    \\t\\tparent[i]=i;\\n    \\t\\tsize[i]=1;\\n    \\t}\\n    }\\n    int findupar(int node)\\n    {\\n    \\tif(node==parent[node]){return node;}\\n    \\treturn parent[node]=findupar(parent[node]);  //path compression\\n    }\\n    void unionbyrank(int u,int v)\\n    {\\n    \\tint ulp_u=findupar(u);\\n    \\tint ulp_v=findupar(v);\\n    \\tif(ulp_u==ulp_v){return;}\\n    \\tif(rank[ulp_u]<rank[ulp_v]){parent[ulp_u]=ulp_v;}\\n    \\telse if(rank[ulp_v]<rank[ulp_u]){parent[ulp_v]=ulp_u;}\\n    \\telse\\n    \\t\\t{\\n    \\t\\t\\tparent[ulp_v]=ulp_u;\\n    \\t\\t\\trank[ulp_u]++;\\n    \\t\\t}\\n\\n    }\\n    void unionbysize(int u,int v)\\n    {\\n    \\tint ulp_u=findupar(u);\\n    \\tint ulp_v=findupar(v);\\n    \\tif(ulp_u==ulp_v){return;}\\n    \\tif(size[ulp_u]<size[ulp_v])\\n    \\t\\t{\\n    \\t\\t\\tparent[ulp_u]=ulp_v;\\n    \\t\\t\\tsize[ulp_v]+=size[ulp_u];\\n    \\t\\t}\\n    \\telse\\n    \\t\\t{\\n    \\t\\t\\tparent[ulp_v]=ulp_u;\\n    \\t\\t\\tsize[ulp_u]+=size[ulp_v];\\n    \\t\\t}\\n\\n    }\\t\\n};\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        disjointset ds(m*n);  \\n        //vector<vector<int>>vis(m,vector<int>(n,0));\\n        int dr[4]={1,0};\\n        int dc[4]={0,1};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {   \\n                int nodeno=i*n+j;\\n                for(int k=0;k<2;k++)\\n                {\\n                    int nr=i+dr[k];\\n                    int nc=j+dc[k];\\n                    if(nr>=0&&nr<m&&nc>=0&&nc<n&&grid[i][j]==grid[nr][nc])\\n                    {\\n                        int adjnodeno=nr*n+nc;\\n                        if(ds.findupar(nodeno)==ds.findupar(adjnodeno))\\n                        {\\n                            return true;\\n                        }\\n                        else\\n                        {\\n                            ds.unionbyrank(nodeno,adjnodeno);\\n                        }\\n                    }\\n                }\\n            }\\n        } \\n        return false;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass disjointset\\n{\\n\\tvector<int>rank,parent,size;\\npublic:\\n    disjointset(int n)\\n    {\\n    \\trank.resize(n+1,0);\\n    \\tparent.resize(n+1);\\n    \\tsize.resize(n+1);\\n    \\tfor(int i=0;i<n+1;i++)\\n    \\t{\\n    \\t\\tparent[i]=i;\\n    \\t\\tsize[i]=1;\\n    \\t}\\n    }\\n    int findupar(int node)\\n    {\\n    \\tif(node==parent[node]){return node;}\\n    \\treturn parent[node]=findupar(parent[node]);  //path compression\\n    }\\n    void unionbyrank(int u,int v)\\n    {\\n    \\tint ulp_u=findupar(u);\\n    \\tint ulp_v=findupar(v);\\n    \\tif(ulp_u==ulp_v){return;}\\n    \\tif(rank[ulp_u]<rank[ulp_v]){parent[ulp_u]=ulp_v;}\\n    \\telse if(rank[ulp_v]<rank[ulp_u]){parent[ulp_v]=ulp_u;}\\n    \\telse\\n    \\t\\t{\\n    \\t\\t\\tparent[ulp_v]=ulp_u;\\n    \\t\\t\\trank[ulp_u]++;\\n    \\t\\t}\\n\\n    }\\n    void unionbysize(int u,int v)\\n    {\\n    \\tint ulp_u=findupar(u);\\n    \\tint ulp_v=findupar(v);\\n    \\tif(ulp_u==ulp_v){return;}\\n    \\tif(size[ulp_u]<size[ulp_v])\\n    \\t\\t{\\n    \\t\\t\\tparent[ulp_u]=ulp_v;\\n    \\t\\t\\tsize[ulp_v]+=size[ulp_u];\\n    \\t\\t}\\n    \\telse\\n    \\t\\t{\\n    \\t\\t\\tparent[ulp_v]=ulp_u;\\n    \\t\\t\\tsize[ulp_u]+=size[ulp_v];\\n    \\t\\t}\\n\\n    }\\t\\n};\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        disjointset ds(m*n);  \\n        //vector<vector<int>>vis(m,vector<int>(n,0));\\n        int dr[4]={1,0};\\n        int dc[4]={0,1};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {   \\n                int nodeno=i*n+j;\\n                for(int k=0;k<2;k++)\\n                {\\n                    int nr=i+dr[k];\\n                    int nc=j+dc[k];\\n                    if(nr>=0&&nr<m&&nc>=0&&nc<n&&grid[i][j]==grid[nr][nc])\\n                    {\\n                        int adjnodeno=nr*n+nc;\\n                        if(ds.findupar(nodeno)==ds.findupar(adjnodeno))\\n                        {\\n                            return true;\\n                        }\\n                        else\\n                        {\\n                            ds.unionbyrank(nodeno,adjnodeno);\\n                        }\\n                    }\\n                }\\n            }\\n        } \\n        return false;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058578,
                "title": "dfs",
                "content": "# Approach\\nRun DFS and pass coordinates and 2 sets\\npath - which will be tracked current path with backtracking\\nseen - overall seen coordinates\\n\\n# Complexity\\n- Time complexity:\\n$$O(nxm)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar containsCycle = function(grid) {\\n\\n    const visited=new Set();    \\n    const dirs=[[0,1],[1,0],[-1,0],[0,-1]];\\n    const dfs=(pr,pc,r,c,parent,path,seen)=>{\\n        const key = `${r}_${c}`;\\n        if(!(pr===r && pc===c) && path.has(key) && grid[r][c]===parent && path.size>=4) return true;\\n        if(r<0 || c<0 || r>=grid.length || c>=grid[r].length || (pr===r && pc===c) || grid[r][c]!==parent || path.has(key)) return false;\\n\\n        seen.add(key);\\n        path.add(key);\\n        for(const [rr,cc] of dirs){\\n            const nextR=rr+r, nextC=cc+c;\\n            if(!(nextR===pr && nextC===pc) && dfs(r,c,nextR, nextC,parent,path,seen)) return true;\\n        }\\n        path.delete(key);\\n        return false;\\n    }\\n\\n    for(let r=0;r<grid.length;r++){\\n        for(let c=0;c<grid[r].length;c++){\\n            if(!visited.has(`${r}_${c}`) && dfs(-1,-1,r,c,grid[r][c],new Set(),visited)){\\n                return true;\\n            }\\n        }    \\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containsCycle = function(grid) {\\n\\n    const visited=new Set();    \\n    const dirs=[[0,1],[1,0],[-1,0],[0,-1]];\\n    const dfs=(pr,pc,r,c,parent,path,seen)=>{\\n        const key = `${r}_${c}`;\\n        if(!(pr===r && pc===c) && path.has(key) && grid[r][c]===parent && path.size>=4) return true;\\n        if(r<0 || c<0 || r>=grid.length || c>=grid[r].length || (pr===r && pc===c) || grid[r][c]!==parent || path.has(key)) return false;\\n\\n        seen.add(key);\\n        path.add(key);\\n        for(const [rr,cc] of dirs){\\n            const nextR=rr+r, nextC=cc+c;\\n            if(!(nextR===pr && nextC===pc) && dfs(r,c,nextR, nextC,parent,path,seen)) return true;\\n        }\\n        path.delete(key);\\n        return false;\\n    }\\n\\n    for(let r=0;r<grid.length;r++){\\n        for(let c=0;c<grid[r].length;c++){\\n            if(!visited.has(`${r}_${c}`) && dfs(-1,-1,r,c,grid[r][c],new Set(),visited)){\\n                return true;\\n            }\\n        }    \\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014187,
                "title": "c-using-floodfill",
                "content": "# Intuition\\nusing floodfill and make sure not to go back\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int n;\\n    bool bRet = false;\\n    void floodfill(vector<vector<char>>& grid, vector<vector<int>>& path, int i, int j, int parent_i, int parent_j, char target)\\n    {\\n        if(bRet) return;\\n        if(path[i][j] == 1) bRet = true;\\n\\n        path[i][j]=1;\\n        \\n        if(i-1>=0 && grid[i-1][j] ==target && (i-1!=parent_i))floodfill(grid, path, i-1, j, i, j, target);\\n        if(i+1<m && grid[i+1][j] ==target && (i+1 != parent_i))floodfill(grid, path, i+1, j, i, j, target);\\n        if(j-1>=0 && grid[i][j-1] ==target && (j-1 !=parent_j))floodfill(grid, path, i, j-1, i, j, target);\\n        if(j+1<n && grid[i][j+1] ==target && (j+1 !=parent_j))floodfill(grid, path, i, j+1, i, j, target);\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        vector<vector<int>> path(m, vector<int>(n, 0));\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                bRet = false;\\n                if(path[i][j]==0) floodfill(grid, path, i, j, -1, -1, grid[i][j]);\\n                if(bRet) return true;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m;\\n    int n;\\n    bool bRet = false;\\n    void floodfill(vector<vector<char>>& grid, vector<vector<int>>& path, int i, int j, int parent_i, int parent_j, char target)\\n    {\\n        if(bRet) return;\\n        if(path[i][j] == 1) bRet = true;\\n\\n        path[i][j]=1;\\n        \\n        if(i-1>=0 && grid[i-1][j] ==target && (i-1!=parent_i))floodfill(grid, path, i-1, j, i, j, target);\\n        if(i+1<m && grid[i+1][j] ==target && (i+1 != parent_i))floodfill(grid, path, i+1, j, i, j, target);\\n        if(j-1>=0 && grid[i][j-1] ==target && (j-1 !=parent_j))floodfill(grid, path, i, j-1, i, j, target);\\n        if(j+1<n && grid[i][j+1] ==target && (j+1 !=parent_j))floodfill(grid, path, i, j+1, i, j, target);\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        vector<vector<int>> path(m, vector<int>(n, 0));\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                bRet = false;\\n                if(path[i][j]==0) floodfill(grid, path, i, j, -1, -1, grid[i][j]);\\n                if(bRet) return true;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011134,
                "title": "java-soln-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        boolean res = false;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!visited[i][j]){\\n                    res = res || dfs(i, j, grid, visited, m, n, -1, -1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    boolean dfs(int i, int j, char[][] grid, boolean[][] visited, int m, int n, int pi, int pj){\\n        if(visited[i][j]) return true;\\n        visited[i][j] = true;\\n        boolean res = false;\\n        if(i>0 && grid[i-1][j]==grid[i][j] && i-1!=pi){\\n            res = res || dfs(i-1, j, grid, visited, m ,n, i, j);\\n        }\\n        if(i<m-1 && grid[i+1][j]==grid[i][j] && i+1!=pi){\\n            res = res || dfs(i+1, j, grid, visited, m ,n, i, j);\\n        }\\n        if(j>0 && grid[i][j-1]==grid[i][j] && j-1!=pj){\\n            res = res || dfs(i, j-1, grid, visited, m ,n, i, j);\\n        }\\n        if(j<n-1 && grid[i][j+1]==grid[i][j] && j+1!=pj){\\n            res = res || dfs(i, j+1, grid, visited, m ,n, i, j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        boolean res = false;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!visited[i][j]){\\n                    res = res || dfs(i, j, grid, visited, m, n, -1, -1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    boolean dfs(int i, int j, char[][] grid, boolean[][] visited, int m, int n, int pi, int pj){\\n        if(visited[i][j]) return true;\\n        visited[i][j] = true;\\n        boolean res = false;\\n        if(i>0 && grid[i-1][j]==grid[i][j] && i-1!=pi){\\n            res = res || dfs(i-1, j, grid, visited, m ,n, i, j);\\n        }\\n        if(i<m-1 && grid[i+1][j]==grid[i][j] && i+1!=pi){\\n            res = res || dfs(i+1, j, grid, visited, m ,n, i, j);\\n        }\\n        if(j>0 && grid[i][j-1]==grid[i][j] && j-1!=pj){\\n            res = res || dfs(i, j-1, grid, visited, m ,n, i, j);\\n        }\\n        if(j<n-1 && grid[i][j+1]==grid[i][j] && j+1!=pj){\\n            res = res || dfs(i, j+1, grid, visited, m ,n, i, j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001964,
                "title": "bfs-python3",
                "content": "\\n# Complexity  (correct me if i\\'m wrong :)   )\\n- Time complexity:\\n    O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        s={}\\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n\\n        def helper(i,j):\\n            char=grid[i][j]\\n            q=deque()\\n            q.append((i,j,-1,-1))\\n            while(q):\\n                x,y,c,d=q.popleft()\\n                if(0<=x<m and 0<=y<n and grid[x][y]==char):\\n                    if((x,y) not in s):\\n                        s[(x,y)]=(c,d)\\n                        if(x-1,y)!=(c,d):\\n                            q.append((x-1,y,x,y))\\n                        if(x,y+1)!=(c,d):\\n                            q.append((x,y+1,x,y))\\n                        if(x+1,y)!=(c,d):\\n                            q.append((x+1,y,x,y))\\n                        if(x,y-1)!=(c,d):\\n                            q.append((x,y-1,x,y))\\n                    elif(s[(x,y)]!=(c,d)):\\n                        return True\\n            return False\\n            \\n\\n\\n        for i in range(0,m):\\n            for j in range(0,n):\\n                if((i,j) not in s):\\n                    if(helper(i,j)):\\n                        return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        s={}\\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n\\n        def helper(i,j):\\n            char=grid[i][j]\\n            q=deque()\\n            q.append((i,j,-1,-1))\\n            while(q):\\n                x,y,c,d=q.popleft()\\n                if(0<=x<m and 0<=y<n and grid[x][y]==char):\\n                    if((x,y) not in s):\\n                        s[(x,y)]=(c,d)\\n                        if(x-1,y)!=(c,d):\\n                            q.append((x-1,y,x,y))\\n                        if(x,y+1)!=(c,d):\\n                            q.append((x,y+1,x,y))\\n                        if(x+1,y)!=(c,d):\\n                            q.append((x+1,y,x,y))\\n                        if(x,y-1)!=(c,d):\\n                            q.append((x,y-1,x,y))\\n                    elif(s[(x,y)]!=(c,d)):\\n                        return True\\n            return False\\n            \\n\\n\\n        for i in range(0,m):\\n            for j in range(0,n):\\n                if((i,j) not in s):\\n                    if(helper(i,j)):\\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984089,
                "title": "easy-to-understand-code-using-bfs-and-dfs",
                "content": "# Intuition\\nThis Question is a Graph travesal with a special case where we need to consider if we are again going to parent node.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can solve this question using DFS and BFS.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code for BFS\\n```\\n\\nbool detectCycleBFS(vector<vector<int>>& vis, vector<vector<char>>& grid, int row, int col){\\n    vis[row][col] = 1;\\n    // current_node {} parent_node {}\\n    queue<pair<pair<int,int>, pair<int,int>>> q;\\n    q.push({{row,col},{-1,-1}});\\n    while(!q.empty()){\\n        int row = q.front().first.first;\\n        int col = q.front().first.second;\\n        int Prow = q.front().second.first;\\n        int Pcol = q.front().second.second;\\n        q.pop();\\n\\n        for(int drow = -1; drow<=1; drow++){\\n            for(int dcol = -1; dcol<=1; dcol++){\\n                if(drow!=0 && dcol!=0 || (drow==0 && dcol==0)){\\n                    continue;\\n                }\\n                int nrow = drow + row;\\n                int ncol = dcol + col;\\n\\n                if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[nrow][ncol] == grid[row][col]){\\n                    if(!vis[nrow][ncol]){\\n                        vis[nrow][ncol] = 1;\\n                        q.push({{nrow,ncol},{row,col}});\\n                    }else if(nrow != Prow && ncol != Pcol){ // visited and NOT parent\\n                    return true;\\n                    }\\n                }\\n            }\\n        } \\n    }\\n    return false;\\n}\\n```\\n\\n# Code for DFS\\n```\\nbool flag = false;\\nbool detectCycleDFS(vector<vector<int>>& vis, vector<vector<char>>& grid, int row, int col, int Prow, int Pcol){\\n    vis[row][col] = 1;\\n\\n    for(int drow = -1; drow<=1; drow++){\\n            for(int dcol = -1; dcol<=1; dcol++){\\n                if((drow!=0 && dcol!=0) || (drow==0 && dcol==0)){\\n                    continue;\\n                }\\n                int nrow = drow + row;\\n                int ncol = dcol + col;\\n                if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[nrow][ncol] == grid[row][col]){\\n                    if(!vis[nrow][ncol]){\\n                        flag |= detectCycleDFS(vis, grid, nrow, ncol, row, col);\\n                    }else if(vis[nrow][ncol] == 1 && nrow != Prow && ncol != Pcol){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n    return flag;\\n}\\n```\\n# Main Code for Each point\\n```\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m,0));\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(!vis[i][j]){\\n                    // run bfs to detect c ycle\\n                    // detectCycleBFS(vis, grid, i, j)\\n                    // detectCycleDFS(vis, grid)\\n                    if(detectCycleDFS(vis, grid, i, j, -1, -1)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nbool detectCycleBFS(vector<vector<int>>& vis, vector<vector<char>>& grid, int row, int col){\\n    vis[row][col] = 1;\\n    // current_node {} parent_node {}\\n    queue<pair<pair<int,int>, pair<int,int>>> q;\\n    q.push({{row,col},{-1,-1}});\\n    while(!q.empty()){\\n        int row = q.front().first.first;\\n        int col = q.front().first.second;\\n        int Prow = q.front().second.first;\\n        int Pcol = q.front().second.second;\\n        q.pop();\\n\\n        for(int drow = -1; drow<=1; drow++){\\n            for(int dcol = -1; dcol<=1; dcol++){\\n                if(drow!=0 && dcol!=0 || (drow==0 && dcol==0)){\\n                    continue;\\n                }\\n                int nrow = drow + row;\\n                int ncol = dcol + col;\\n\\n                if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[nrow][ncol] == grid[row][col]){\\n                    if(!vis[nrow][ncol]){\\n                        vis[nrow][ncol] = 1;\\n                        q.push({{nrow,ncol},{row,col}});\\n                    }else if(nrow != Prow && ncol != Pcol){ // visited and NOT parent\\n                    return true;\\n                    }\\n                }\\n            }\\n        } \\n    }\\n    return false;\\n}\\n```\n```\\nbool flag = false;\\nbool detectCycleDFS(vector<vector<int>>& vis, vector<vector<char>>& grid, int row, int col, int Prow, int Pcol){\\n    vis[row][col] = 1;\\n\\n    for(int drow = -1; drow<=1; drow++){\\n            for(int dcol = -1; dcol<=1; dcol++){\\n                if((drow!=0 && dcol!=0) || (drow==0 && dcol==0)){\\n                    continue;\\n                }\\n                int nrow = drow + row;\\n                int ncol = dcol + col;\\n                if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[nrow][ncol] == grid[row][col]){\\n                    if(!vis[nrow][ncol]){\\n                        flag |= detectCycleDFS(vis, grid, nrow, ncol, row, col);\\n                    }else if(vis[nrow][ncol] == 1 && nrow != Prow && ncol != Pcol){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n    return flag;\\n}\\n```\n```\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m,0));\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(!vis[i][j]){\\n                    // run bfs to detect c ycle\\n                    // detectCycleBFS(vis, grid, i, j)\\n                    // detectCycleDFS(vis, grid)\\n                    if(detectCycleDFS(vis, grid, i, j, -1, -1)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976446,
                "title": "easy-bfs-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust a normal BFS traversal with small tweeks (count >= 4)...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool bfs(int row, int col, vector<vector<char>>& grid, vector<vector<int>>& vis, int& count, char c){\\n        queue<vector<int>> q;\\n        q.push({row, col, row, col});\\n        int n = grid.size(), m = grid[0].size();\\n        vis[row][col] = 1;\\n        int dx[] = {-1, 0, 1, 0};\\n        int dy[] = {0, 1, 0, -1};\\n        while(!q.empty()){\\n            auto vec = q.front();q.pop();\\n            int row = vec[0];\\n            int col = vec[1];\\n            int rp = vec[2];\\n            int cp = vec[3];\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row + dx[i];\\n                int ncol = col + dy[i];\\n                if(nrow >= 0 and nrow < n and ncol >= 0 and ncol < m and grid[nrow][ncol] == c){\\n                    if(vis[nrow][ncol] and nrow != rp and ncol != cp) return true;\\n                    else if(!vis[nrow][ncol]){\\n                        vis[nrow][ncol] = 1;\\n                        q.push({nrow, ncol, row, col});\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]){\\n                    int count = 1;\\n                    if(bfs(i, j, grid, vis, count, grid[i][j]) == true and count >= 4) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bfs(int row, int col, vector<vector<char>>& grid, vector<vector<int>>& vis, int& count, char c){\\n        queue<vector<int>> q;\\n        q.push({row, col, row, col});\\n        int n = grid.size(), m = grid[0].size();\\n        vis[row][col] = 1;\\n        int dx[] = {-1, 0, 1, 0};\\n        int dy[] = {0, 1, 0, -1};\\n        while(!q.empty()){\\n            auto vec = q.front();q.pop();\\n            int row = vec[0];\\n            int col = vec[1];\\n            int rp = vec[2];\\n            int cp = vec[3];\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row + dx[i];\\n                int ncol = col + dy[i];\\n                if(nrow >= 0 and nrow < n and ncol >= 0 and ncol < m and grid[nrow][ncol] == c){\\n                    if(vis[nrow][ncol] and nrow != rp and ncol != cp) return true;\\n                    else if(!vis[nrow][ncol]){\\n                        vis[nrow][ncol] = 1;\\n                        q.push({nrow, ncol, row, col});\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]){\\n                    int count = 1;\\n                    if(bfs(i, j, grid, vis, count, grid[i][j]) == true and count >= 4) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969096,
                "title": "2-ways-bfs-dfs-easy-cpp-matrix-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n// 1.DFS(Recursion)\\nclass Solution {\\n    bool isvalid(int i,int j,int n,int m){\\n        if(i>=0 && i<n && j>=0 && j<m){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    bool find(int r,int c,vector<vector<char>>& grid,vector<vector<int>>&vis,int pi,int pj){\\n        vis[r][c]=1;\\n        int row[4]={0,0,-1,1};\\n        int col[4]={-1,1,0,0};\\n            for(int i=0;i<4;i++){\\n                int nr=r+row[i];\\n                int nc=c+col[i];\\n                if(isvalid(nr,nc,grid.size(),grid[0].size()) && grid[nr][nc]==grid[r][c]){\\n                    if(vis[nr][nc]==0){\\n                        if(find(nr,nc,grid,vis,r,c)){\\n                            return 1;\\n                        };\\n                    }\\n                    else if(pi!=nr || pj!=nc){\\n                        return 1;\\n                    }\\n                    \\n                }\\n            }\\n        \\n            return 0;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0){\\n                    if(find(i,j,grid,vis,-1,-1)){\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n//2. BFS(Queue)\\nclass Solution {\\n    bool isvalid(int i,int j,int n,int m){\\n        if(i>=0 && i<n && j>=0 && j<m){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    bool find(int i,int j,vector<vector<char>>& grid,vector<vector<int>>&vis){\\n        queue<pair<pair<int,int>,pair<int,int>>>q;\\n        q.push({{i,j},{-1,-1}});\\n        vis[i][j]=1;\\n        int row[4]={0,0,-1,1};\\n        int col[4]={-1,1,0,0};\\n        while(q.empty()==0){\\n            pair<int,int>p=q.front().first;\\n            pair<int,int> parent=q.front().second;\\n            q.pop();\\n            int r=p.first;\\n            int c=p.second;\\n            int pi=parent.first;\\n            int pj=parent.second;\\n\\n            for(int i=0;i<4;i++){\\n                int nr=r+row[i];\\n                int nc=c+col[i];\\n                if(isvalid(nr,nc,grid.size(),grid[0].size()) && grid[nr][nc]==grid[r][c]){\\n                    if(vis[nr][nc]==0){\\n                        vis[nr][nc]=1;\\n                        q.push({{nr,nc},{r,c}});\\n                    }\\n                    else if(pi!=nr || pj!=nc){\\n                        return 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n            return 0;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0){\\n                    if(find(i,j,grid,vis)){\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\n// 1.DFS(Recursion)\\nclass Solution {\\n    bool isvalid(int i,int j,int n,int m){\\n        if(i>=0 && i<n && j>=0 && j<m){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    bool find(int r,int c,vector<vector<char>>& grid,vector<vector<int>>&vis,int pi,int pj){\\n        vis[r][c]=1;\\n        int row[4]={0,0,-1,1};\\n        int col[4]={-1,1,0,0};\\n            for(int i=0;i<4;i++){\\n                int nr=r+row[i];\\n                int nc=c+col[i];\\n                if(isvalid(nr,nc,grid.size(),grid[0].size()) && grid[nr][nc]==grid[r][c]){\\n                    if(vis[nr][nc]==0){\\n                        if(find(nr,nc,grid,vis,r,c)){\\n                            return 1;\\n                        };\\n                    }\\n                    else if(pi!=nr || pj!=nc){\\n                        return 1;\\n                    }\\n                    \\n                }\\n            }\\n        \\n            return 0;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0){\\n                    if(find(i,j,grid,vis,-1,-1)){\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n//2. BFS(Queue)\\nclass Solution {\\n    bool isvalid(int i,int j,int n,int m){\\n        if(i>=0 && i<n && j>=0 && j<m){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    bool find(int i,int j,vector<vector<char>>& grid,vector<vector<int>>&vis){\\n        queue<pair<pair<int,int>,pair<int,int>>>q;\\n        q.push({{i,j},{-1,-1}});\\n        vis[i][j]=1;\\n        int row[4]={0,0,-1,1};\\n        int col[4]={-1,1,0,0};\\n        while(q.empty()==0){\\n            pair<int,int>p=q.front().first;\\n            pair<int,int> parent=q.front().second;\\n            q.pop();\\n            int r=p.first;\\n            int c=p.second;\\n            int pi=parent.first;\\n            int pj=parent.second;\\n\\n            for(int i=0;i<4;i++){\\n                int nr=r+row[i];\\n                int nc=c+col[i];\\n                if(isvalid(nr,nc,grid.size(),grid[0].size()) && grid[nr][nc]==grid[r][c]){\\n                    if(vis[nr][nc]==0){\\n                        vis[nr][nc]=1;\\n                        q.push({{nr,nc},{r,c}});\\n                    }\\n                    else if(pi!=nr || pj!=nc){\\n                        return 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n            return 0;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0){\\n                    if(find(i,j,grid,vis)){\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951708,
                "title": "dfs-coloring-python3-solution",
                "content": "```\\nclass Solution:\\n    \\n    def inBound(self, row: int, col: int, grid: List[List[int]]) -> bool:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        if row < 0 or row >= ROWS:\\n            return False\\n        \\n        if col < 0 or col >= COLS:\\n            return False\\n        \\n        return True\\n    \\n    \\n    def getNeighbors(self, row: int, col: int, grid: List[List[int]]) -> List[Tuple[int]]:\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        nbrs = []\\n        \\n        for x, y in directions:\\n            new_row, new_col = row+x, col+y\\n            if self.inBound(new_row, new_col, grid) and grid[row][col] == grid[new_row][new_col]:\\n                nbrs.append((new_row, new_col))\\n                \\n        return nbrs\\n    \\n    \\n    def hasCycle(self, row: int, col: int, parent: Tuple[int], grid: List[List[int]], color: List[List[int]]) -> bool:\\n        \\n        if color[row][col] == 1:\\n            return True\\n        \\n        if color[row][col] == 2:\\n            return False\\n        \\n        color[row][col] = 1\\n        for nbr in self.getNeighbors(row, col, grid):\\n            if nbr == parent:\\n                continue\\n            nbr_row, nbr_col = nbr\\n            if self.hasCycle(nbr_row, nbr_col, (row, col), grid, color):\\n                return True\\n        \\n        color[row][col] = 2\\n        return False\\n    \\n    \\n    # O(n*m) time,\\n    # O(n*m) space,\\n    # Approach: dfs coloring, \\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        n, m = len(grid), len(grid[0])\\n        color = [[0 for _ in range(m)] for _ in range(n)]\\n        \\n        for row in range(n):\\n            for col in range(m):\\n                if color[row][col]:\\n                    continue\\n                if self.hasCycle(row, col, (-1, -1), grid, color):\\n                    return True\\n                \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def inBound(self, row: int, col: int, grid: List[List[int]]) -> bool:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        if row < 0 or row >= ROWS:\\n            return False\\n        \\n        if col < 0 or col >= COLS:\\n            return False\\n        \\n        return True\\n    \\n    \\n    def getNeighbors(self, row: int, col: int, grid: List[List[int]]) -> List[Tuple[int]]:\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        nbrs = []\\n        \\n        for x, y in directions:\\n            new_row, new_col = row+x, col+y\\n            if self.inBound(new_row, new_col, grid) and grid[row][col] == grid[new_row][new_col]:\\n                nbrs.append((new_row, new_col))\\n                \\n        return nbrs\\n    \\n    \\n    def hasCycle(self, row: int, col: int, parent: Tuple[int], grid: List[List[int]], color: List[List[int]]) -> bool:\\n        \\n        if color[row][col] == 1:\\n            return True\\n        \\n        if color[row][col] == 2:\\n            return False\\n        \\n        color[row][col] = 1\\n        for nbr in self.getNeighbors(row, col, grid):\\n            if nbr == parent:\\n                continue\\n            nbr_row, nbr_col = nbr\\n            if self.hasCycle(nbr_row, nbr_col, (row, col), grid, color):\\n                return True\\n        \\n        color[row][col] = 2\\n        return False\\n    \\n    \\n    # O(n*m) time,\\n    # O(n*m) space,\\n    # Approach: dfs coloring, \\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        n, m = len(grid), len(grid[0])\\n        color = [[0 for _ in range(m)] for _ in range(n)]\\n        \\n        for row in range(n):\\n            for col in range(m):\\n                if color[row][col]:\\n                    continue\\n                if self.hasCycle(row, col, (-1, -1), grid, color):\\n                    return True\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935464,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "# Complexity\\n- Time complexity:\\n$$O(mn)$$\\n\\n- Space complexity:\\n$$O(mn)$$\\n\\n# Code\\n```\\nvar containsCycle = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const vistied = new Set();\\n    const isCycle = ({ row, col, value, preRow, preCol }) => {\\n        if (row < 0 || col < 0 || row >= m || col >= n) return false;\\n        const current = grid[row][col];\\n\\n        if (current !== value) return false;\\n        if (vistied.has(`${row}_${col}`)) return true;\\n        vistied.add(`${row}_${col}`);\\n\\n        for (const move of [-1, 1]) {\\n            if (row + move !== preRow) {\\n                if (isCycle({ row: row + move, col, value, preRow: row, preCol: col })) return true;;\\n            }\\n            if (col + move !== preCol) {\\n                if (isCycle({ row, col: col + move, value, preRow: row, preCol: col })) return true;\\n            }\\n        }\\n        return false;\\n    };\\n\\n    for (let row = 0; row < m; row++) {\\n        for (let col = 0; col < n; col++) {\\n            if (vistied.has(`${row}_${col}`)) continue;\\n            const value = grid[row][col]\\n\\n            if (isCycle({ row, col, value, preRow: -1, preCol: -1 })) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containsCycle = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const vistied = new Set();\\n    const isCycle = ({ row, col, value, preRow, preCol }) => {\\n        if (row < 0 || col < 0 || row >= m || col >= n) return false;\\n        const current = grid[row][col];\\n\\n        if (current !== value) return false;\\n        if (vistied.has(`${row}_${col}`)) return true;\\n        vistied.add(`${row}_${col}`);\\n\\n        for (const move of [-1, 1]) {\\n            if (row + move !== preRow) {\\n                if (isCycle({ row: row + move, col, value, preRow: row, preCol: col })) return true;;\\n            }\\n            if (col + move !== preCol) {\\n                if (isCycle({ row, col: col + move, value, preRow: row, preCol: col })) return true;\\n            }\\n        }\\n        return false;\\n    };\\n\\n    for (let row = 0; row < m; row++) {\\n        for (let col = 0; col < n; col++) {\\n            if (vistied.has(`${row}_${col}`)) continue;\\n            const value = grid[row][col]\\n\\n            if (isCycle({ row, col, value, preRow: -1, preCol: -1 })) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931319,
                "title": "easy-to-understand-solution-in-java-using-bfs-and-dfs-in-o-mn-with-explanation-and-intuition",
                "content": "# Intuition\\nIn order to form a cycle 2 paths merge at a same node. This is the whole crux of the problem.\\nif a point is already visited and another path visits it again then there exist a cycle.\\n\\nPoints to be noted for algo\\n1. There are 4 directions possible to go from a cell. but we should not go to cell we have came from in a path.\\n2. Also go to only same character cells\\n\\n# Approach\\nOn the matrix\\n2. 1. In the grid start performing the BFS or DFS. if it is not visited.\\n2. perform this until you find a cycle or the 2d array is traversed completely.\\n\\n DFS:\\nsee the code self explanatory\\n\\nInside BFS:\\nsee the code self explanatory\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n// keep a visited array to prevent the cell from visiting again.\\n//Also it will help to detect if we have visited a cell again to form a cycle.\\n        int[][] visited = new int[n][m];\\n        \\n        for( int i =0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n//if unvisited then perform BFS or DFS\\n                if(visited[i][j]==0)\\n                    // if(DFS(i,j,grid,visited,-1 , -1))\\n                    //     return true;\\n                    if(BFS(i,j,grid,visited))\\n                        return true;\\n            }\\n        return false;\\n    }\\n\\n    boolean DFS(int i, int j, char[][] grid,int[][] visited, int parentx, int parenty)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n// to traverse in all 4 directions\\n        int[]  x = new int[]{1,-1,0,0};\\n        int[] y = new int[]{0,0,1,-1};\\n\\n// if it is visited by other path then return true it forms a cycle\\n        if(visited[i][j]==1) return true;\\n\\n// mark visited and continue dfs\\n        visited[i][j] =1;\\n        for(int k=0;k<4;k++)\\n        {\\n            int xc = i+x[k];\\n            int yc = j+y[k];\\n\\n// visit only those grid cells which has same character\\n            if( xc>=0 && xc<n && yc>=0 && yc<m && grid[i][j]==grid[xc][yc])\\n            {   \\n// check if it is not the same cell it has came from and if DFS returns true return true;\\n                if((xc!=parentx || yc!=parenty) && DFS(xc,yc,grid,visited,i,j))\\n                    return true;\\n\\n                    // OR\\n\\n                    // if(xc==parentx && yc==parenty)\\n                    //     continue;\\n                    // else\\n                    //     if(DFS(xc,yc,grid,visited,i,j))\\n                    //         return true;\\n            }\\n        }\\n            \\n        return false;\\n    }\\n        \\n\\n\\n    boolean BFS(int i, int j, char[][] grid , int[][] visited)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Queue<int[]>  q = new LinkedList();\\n        q.add(new int[]{i,j,-1,-1});\\n        int[]  x = new int[]{1,-1,0,0};\\n        int[] y = new int[]{0,0,1,-1};\\n    \\n        while(!q.isEmpty())\\n        {\\n            int siz = q.size();\\n            for(int l=0;l<siz;l++)\\n            {\\n                int[] temp = q.poll();\\n                visited[temp[0]][temp[1]] =1;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int xc = temp[0]+x[k];\\n                    int yc = temp[1]+y[k];\\n\\n\\n// visit only those grid cells which has same character\\n                    if(xc>=0 && xc<n && yc>=0 && yc<m && grid[temp[0]][temp[1]]==grid[xc][yc])\\n\\n// check if it is not the same cell it has came from a\\n                        if( temp[2]!=xc || temp[3]!=yc )\\n                        {\\n//if it is already visited then cycle exists return true\\n                            if(visited[xc][yc]==1)\\n                                return true;\\n\\n// otherwise add it to the queue\\n                            q.add(new int[]{xc,yc,temp[0],temp[1]});       \\n                        }\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n// keep a visited array to prevent the cell from visiting again.\\n//Also it will help to detect if we have visited a cell again to form a cycle.\\n        int[][] visited = new int[n][m];\\n        \\n        for( int i =0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n//if unvisited then perform BFS or DFS\\n                if(visited[i][j]==0)\\n                    // if(DFS(i,j,grid,visited,-1 , -1))\\n                    //     return true;\\n                    if(BFS(i,j,grid,visited))\\n                        return true;\\n            }\\n        return false;\\n    }\\n\\n    boolean DFS(int i, int j, char[][] grid,int[][] visited, int parentx, int parenty)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n// to traverse in all 4 directions\\n        int[]  x = new int[]{1,-1,0,0};\\n        int[] y = new int[]{0,0,1,-1};\\n\\n// if it is visited by other path then return true it forms a cycle\\n        if(visited[i][j]==1) return true;\\n\\n// mark visited and continue dfs\\n        visited[i][j] =1;\\n        for(int k=0;k<4;k++)\\n        {\\n            int xc = i+x[k];\\n            int yc = j+y[k];\\n\\n// visit only those grid cells which has same character\\n            if( xc>=0 && xc<n && yc>=0 && yc<m && grid[i][j]==grid[xc][yc])\\n            {   \\n// check if it is not the same cell it has came from and if DFS returns true return true;\\n                if((xc!=parentx || yc!=parenty) && DFS(xc,yc,grid,visited,i,j))\\n                    return true;\\n\\n                    // OR\\n\\n                    // if(xc==parentx && yc==parenty)\\n                    //     continue;\\n                    // else\\n                    //     if(DFS(xc,yc,grid,visited,i,j))\\n                    //         return true;\\n            }\\n        }\\n            \\n        return false;\\n    }\\n        \\n\\n\\n    boolean BFS(int i, int j, char[][] grid , int[][] visited)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Queue<int[]>  q = new LinkedList();\\n        q.add(new int[]{i,j,-1,-1});\\n        int[]  x = new int[]{1,-1,0,0};\\n        int[] y = new int[]{0,0,1,-1};\\n    \\n        while(!q.isEmpty())\\n        {\\n            int siz = q.size();\\n            for(int l=0;l<siz;l++)\\n            {\\n                int[] temp = q.poll();\\n                visited[temp[0]][temp[1]] =1;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int xc = temp[0]+x[k];\\n                    int yc = temp[1]+y[k];\\n\\n\\n// visit only those grid cells which has same character\\n                    if(xc>=0 && xc<n && yc>=0 && yc<m && grid[temp[0]][temp[1]]==grid[xc][yc])\\n\\n// check if it is not the same cell it has came from a\\n                        if( temp[2]!=xc || temp[3]!=yc )\\n                        {\\n//if it is already visited then cycle exists return true\\n                            if(visited[xc][yc]==1)\\n                                return true;\\n\\n// otherwise add it to the queue\\n                            q.add(new int[]{xc,yc,temp[0],temp[1]});       \\n                        }\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925930,
                "title": "c-cpp-easy-dfs-code",
                "content": "# Intuition\\nDFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDFS\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool dfs(int r, int c, int pr, int pc, vector<vector<char>>&grid, vector<vector<int>>& vis){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[r][c] = 1;\\n\\n        int dx[4] = {-1, 0, 1, 0};\\n        int dy[4] = {0, -1, 0, 1};\\n\\n        for(int i = 0;i < 4;i++){\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx < 0 || nx >= m || ny < 0 || ny >= n || grid[r][c] != grid[nx][ny]) continue;\\n            if(nx == pr && ny == pc) continue;\\n            if(vis[nx][ny]){\\n                return true;\\n            }\\n            else if(dfs(nx, ny, r, c, grid, vis)) \\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(!vis[i][j]){\\n                    if(dfs(i, j, -1, -1, grid, vis))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(int r, int c, int pr, int pc, vector<vector<char>>&grid, vector<vector<int>>& vis){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[r][c] = 1;\\n\\n        int dx[4] = {-1, 0, 1, 0};\\n        int dy[4] = {0, -1, 0, 1};\\n\\n        for(int i = 0;i < 4;i++){\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx < 0 || nx >= m || ny < 0 || ny >= n || grid[r][c] != grid[nx][ny]) continue;\\n            if(nx == pr && ny == pc) continue;\\n            if(vis[nx][ny]){\\n                return true;\\n            }\\n            else if(dfs(nx, ny, r, c, grid, vis)) \\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(!vis[i][j]){\\n                    if(dfs(i, j, -1, -1, grid, vis))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858442,
                "title": "c-soln-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n         int n = grid.size();\\n         int m =grid[0].size();\\n         vector<vector<int>>vis(n,vector<int>(m,0));\\n       int x[]={-1,0,+1,0};\\n        int y[]={0,+1,0,-1};\\n\\n       for (int i=0;i<n;i++){\\n           for (int j=0;j<m;j++){\\n               if (vis[i][j]==0){\\n                   vis[i][j]=1;\\n                queue <pair<pair<int,int>,pair<int,int>>>q;\\n                char  node = grid[i][j];\\n                q.push({{i,j},{-1,-1}});\\n          while (!q.empty()){\\n              int row = q.front().first.first;\\n                int col = q.front().first.second;\\n                  int p1 = q.front().second.first;\\n                    int p2 = q.front().second.second;\\n                    q.pop();\\n     \\n       for (int i=0;i<4;i++){\\n           int nrow = row +x[i];\\n           int ncol = col +y[i];\\n          if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0 && grid[nrow][ncol]==node ){\\n              vis[nrow][ncol]=1;\\n              q.push({{nrow,ncol},{row,col}});\\n          }\\n  else if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==1 && nrow!=p1\\n   && ncol!=p2 && grid[nrow][ncol]==node ) {\\n                   return true ;\\n      }\\n       }\\n          }   \\n               }\\n           }\\n       }\\n\\n    return false ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n         int n = grid.size();\\n         int m =grid[0].size();\\n         vector<vector<int>>vis(n,vector<int>(m,0));\\n       int x[]={-1,0,+1,0};\\n        int y[]={0,+1,0,-1};\\n\\n       for (int i=0;i<n;i++){\\n           for (int j=0;j<m;j++){\\n               if (vis[i][j]==0){\\n                   vis[i][j]=1;\\n                queue <pair<pair<int,int>,pair<int,int>>>q;\\n                char  node = grid[i][j];\\n                q.push({{i,j},{-1,-1}});\\n          while (!q.empty()){\\n              int row = q.front().first.first;\\n                int col = q.front().first.second;\\n                  int p1 = q.front().second.first;\\n                    int p2 = q.front().second.second;\\n                    q.pop();\\n     \\n       for (int i=0;i<4;i++){\\n           int nrow = row +x[i];\\n           int ncol = col +y[i];\\n          if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0 && grid[nrow][ncol]==node ){\\n              vis[nrow][ncol]=1;\\n              q.push({{nrow,ncol},{row,col}});\\n          }\\n  else if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==1 && nrow!=p1\\n   && ncol!=p2 && grid[nrow][ncol]==node ) {\\n                   return true ;\\n      }\\n       }\\n          }   \\n               }\\n           }\\n       }\\n\\n    return false ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850112,
                "title": "solution-can-be-understand-just-by-seeing-the-code",
                "content": "\\nclass Solution {\\npublic:\\nbool f(int i,int j,int px,int py,vector<vector<char>>& grid,vector<vector<int>>&vis)\\n{\\n    vis[i][j]=1;\\n    if(i+1<grid.size()&&grid[i][j]==grid[i+1][j])\\n    {\\n        if(vis[i+1][j]==1&&(i+1!=px||j!=py))\\n        return true;\\n        else if(vis[i+1][j]==0)\\n        {\\n          if(f(i+1,j,i,j,grid,vis)==true)\\n          return true;\\n        }\\n    }\\n    if(i-1>=0&&grid[i][j]==grid[i-1][j])\\n    {\\n        if(vis[i-1][j]==1&&(i-1!=px||j!=py))\\n        return true;\\n        else if(vis[i-1][j]==0)\\n        {\\n            if(f(i-1,j,i,j,grid,vis)==true)\\n          return true;\\n        }\\n    }\\n    if(j-1>=0&&grid[i][j]==grid[i][j-1])\\n    {\\n        if(vis[i][j-1]==1&&(i!=px||(j-1)!=py))\\n        return true;\\n        else if(vis[i][j-1]==0)\\n        {\\n            if(f(i,j-1,i,j,grid,vis)==true)\\n          return true;\\n        }\\n    }\\n    if(j+1<grid[0].size()&&grid[i][j]==grid[i][j+1])\\n    {\\n        if(vis[i][j+1]==1&&(i!=px||(j+1)!=py))\\n        return true;\\n        else if(vis[i][j+1]==0)\\n        {\\n            if(f(i,j+1,i,j,grid,vis)==true)\\n          return true;\\n        }\\n    }\\n    return false;\\n\\n}\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(vis[i][j]==0)\\n                {\\n                    if(f(i,j,i,j,grid,vis)==true)\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\nbool f(int i,int j,int px,int py,vector<vector<char>>& grid,vector<vector<int>>&vis)\\n{\\n    vis[i][j]=1;\\n    if(i+1<grid.size()&&grid[i][j]==grid[i+1][j])\\n    {\\n        if(vis[i+1][j]==1&&(i+1!=px||j!=py))\\n        return true;\\n        else if(vis[i+1][j]==0)\\n        {\\n          if(f(i+1,j,i,j,grid,vis)==true)\\n          return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3839428,
                "title": "python-approach-with-dfs",
                "content": "# Approach\\nInitialise a matrix to store DFS state per `grid` cell (has/has not already been visited by a DFS).\\n\\nIterate over the `grid` cells, if corresponding DFS state is unvisited, begin a DFS at that cell for cycles. Otherwise, do nothing.\\n\\nIn `dfs`, traverse children that have not yet been subject to DFS. If the same cell is visited twice in the same search, we have a cycle.\\n\\n# Complexity\\nTime and space complexity of $$O(nm)$$\\n\\nRuntime beats 100.00%\\nMemory beats 88.56%\\n\\n# Code\\n```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n\\n        def dfs(start_cell, ch):\\n            visited = set()\\n            s = [start_cell]\\n            while len(s) > 0:\\n                cell = s.pop()\\n                if cell in visited:\\n                    return True\\n                visited.add(cell)\\n                i, j = cell\\n                dp[i][j] = 1\\n                if i > 0 and dp[i - 1][j] == 0 and grid[i - 1][j] == ch:\\n                    s.append((i - 1, j))\\n                if i < m - 1 and dp[i + 1][j] == 0 and grid[i + 1][j] == ch:\\n                    s.append((i + 1, j))\\n                if j > 0 and dp[i][j - 1] == 0 and grid[i][j - 1] == ch:\\n                    s.append((i, j - 1))\\n                if j < n - 1 and dp[i][j + 1] == 0 and grid[i][j + 1] == ch:\\n                    s.append((i, j + 1))\\n            return False\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if dp[i][j] == 0:\\n                    ch = grid[i][j]\\n                    if dfs((i, j), ch):\\n                        return True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n\\n        def dfs(start_cell, ch):\\n            visited = set()\\n            s = [start_cell]\\n            while len(s) > 0:\\n                cell = s.pop()\\n                if cell in visited:\\n                    return True\\n                visited.add(cell)\\n                i, j = cell\\n                dp[i][j] = 1\\n                if i > 0 and dp[i - 1][j] == 0 and grid[i - 1][j] == ch:\\n                    s.append((i - 1, j))\\n                if i < m - 1 and dp[i + 1][j] == 0 and grid[i + 1][j] == ch:\\n                    s.append((i + 1, j))\\n                if j > 0 and dp[i][j - 1] == 0 and grid[i][j - 1] == ch:\\n                    s.append((i, j - 1))\\n                if j < n - 1 and dp[i][j + 1] == 0 and grid[i][j + 1] == ch:\\n                    s.append((i, j + 1))\\n            return False\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if dp[i][j] == 0:\\n                    ch = grid[i][j]\\n                    if dfs((i, j), ch):\\n                        return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832793,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbasic DFS \\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool insideGrid(int i,int j,int m,int n){\\n        return i>=0 and i<m and j>=0 and j<n;\\n    }\\n    bool dfs(vector<vector<char>>& grid, vector<vector<bool>>& vis, int row, int col,int pr,int pc) {\\n        \\n        char c = grid[row][col];\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if (vis[row][col] ) {\\n            return true;\\n        }\\n\\n        vis[row][col] = true;\\n\\n        int pos[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n\\n        for (int i = 0; i < 4; i++) {\\n            int childI = row + pos[i][0];\\n            int childJ = col + pos[i][1];\\n\\n            if (insideGrid(childI,childJ,m,n) and grid[childI][childJ] == c and(childI!= pr or childJ!=pc)) {\\n                if(dfs(grid,vis,childI,childJ,row,col)){\\n                    return true;\\n                }\\n            }\\n        }\\n    \\n\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!vis[i][j]) {\\n                    if (dfs(grid, vis, i, j,-1,-1)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool insideGrid(int i,int j,int m,int n){\\n        return i>=0 and i<m and j>=0 and j<n;\\n    }\\n    bool dfs(vector<vector<char>>& grid, vector<vector<bool>>& vis, int row, int col,int pr,int pc) {\\n        \\n        char c = grid[row][col];\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if (vis[row][col] ) {\\n            return true;\\n        }\\n\\n        vis[row][col] = true;\\n\\n        int pos[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n\\n        for (int i = 0; i < 4; i++) {\\n            int childI = row + pos[i][0];\\n            int childJ = col + pos[i][1];\\n\\n            if (insideGrid(childI,childJ,m,n) and grid[childI][childJ] == c and(childI!= pr or childJ!=pc)) {\\n                if(dfs(grid,vis,childI,childJ,row,col)){\\n                    return true;\\n                }\\n            }\\n        }\\n    \\n\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!vis[i][j]) {\\n                    if (dfs(grid, vis, i, j,-1,-1)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812861,
                "title": "easy-to-understand-c-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,char a,vector<vector<char>>& grid,vector<vector<int>>& vis,int pari,int parj){\\n      vis[i][j]=1;\\n      int delr[]={0,0,-1,1};\\n      int delc[]={1,-1,0,0};\\n      for(int k=0;k<4;k++){\\n          int nr=delr[k]+i;\\n          int nc=delc[k]+j;\\n          if(pari==nr&&parj==nc) continue;\\n          if(nr>=0&&nr<grid.size()&&nc>=0&&nc<grid[0].size()&&grid[nr][nc]==a&&vis[nr][nc]==1){\\n              return true;\\n          }\\n          else if(nr>=0&&nr<grid.size()&&nc>=0&&nc<grid[0].size()&&grid[nr][nc]==a&&vis[nr][nc]==0){\\n              if(solve(nr,nc,a,grid,vis,i,j)==true) return true;\\n          }\\n      }\\n      return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                char ch=grid[i][j];\\n                if(vis[i][j]==0&&solve(i,j,ch,grid,vis,-1,-1)==true){\\n                 return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,char a,vector<vector<char>>& grid,vector<vector<int>>& vis,int pari,int parj){\\n      vis[i][j]=1;\\n      int delr[]={0,0,-1,1};\\n      int delc[]={1,-1,0,0};\\n      for(int k=0;k<4;k++){\\n          int nr=delr[k]+i;\\n          int nc=delc[k]+j;\\n          if(pari==nr&&parj==nc) continue;\\n          if(nr>=0&&nr<grid.size()&&nc>=0&&nc<grid[0].size()&&grid[nr][nc]==a&&vis[nr][nc]==1){\\n              return true;\\n          }\\n          else if(nr>=0&&nr<grid.size()&&nc>=0&&nc<grid[0].size()&&grid[nr][nc]==a&&vis[nr][nc]==0){\\n              if(solve(nr,nc,a,grid,vis,i,j)==true) return true;\\n          }\\n      }\\n      return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                char ch=grid[i][j];\\n                if(vis[i][j]==0&&solve(i,j,ch,grid,vis,-1,-1)==true){\\n                 return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788574,
                "title": "c-dfs-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    bool dfs(int row, int col, vector<vector<int>> &vis, vector<vector<char>> &grid, int prow, int pcol){\\n        int n = grid.size(), m = grid[0].size();\\n        vis[row][col] = 1;\\n        int delrow[] = {-1, 0, +1, 0};\\n        int delcol[] = {0, +1, 0, -1};\\n\\n        for(int i=0;i<4;i++){\\n            int nrow = row+delrow[i];\\n            int ncol = col+delcol[i];\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==grid[row][col] && vis[nrow][ncol]==0){\\n                if(dfs(nrow, ncol, vis, grid, row, col)) return true;\\n            }\\n            else if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==grid[row][col] && vis[nrow][ncol]==1){\\n                if(prow!=nrow && pcol!=ncol) return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0){\\n                    if(dfs(i, j, vis, grid, -1, -1)==true) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    bool dfs(int row, int col, vector<vector<int>> &vis, vector<vector<char>> &grid, int prow, int pcol){\\n        int n = grid.size(), m = grid[0].size();\\n        vis[row][col] = 1;\\n        int delrow[] = {-1, 0, +1, 0};\\n        int delcol[] = {0, +1, 0, -1};\\n\\n        for(int i=0;i<4;i++){\\n            int nrow = row+delrow[i];\\n            int ncol = col+delcol[i];\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==grid[row][col] && vis[nrow][ncol]==0){\\n                if(dfs(nrow, ncol, vis, grid, row, col)) return true;\\n            }\\n            else if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==grid[row][col] && vis[nrow][ncol]==1){\\n                if(prow!=nrow && pcol!=ncol) return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0){\\n                    if(dfs(i, j, vis, grid, -1, -1)==true) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782066,
                "title": "c-easy-optimized-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mXn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mXn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,vector<vector<char>>& grid, vector<vector<int>> &visit,pair<int,int> parent){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int row[] = {1,-1,0,0};\\n        int col[] = {0,0,1,-1};\\n        visit[i][j] = 1;\\n        for(int k = 0 ; k<4 ; k++){\\n            int nrow = row[k]+i;\\n            int ncol = col[k]+j;\\n            pair<int,int> p = {nrow,ncol};\\n            if(nrow<n && ncol<m && nrow>=0 && ncol>=0 && grid[nrow][ncol]==grid[i][j]){\\n                if(!visit[nrow][ncol] ){ if(dfs(nrow,ncol,grid,visit,{i,j})) return true;}\\n                else if(p!= parent) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> visit(n,vector<int> (m,0));\\n        for(int i = 0 ; i< n ; i++){\\n            for(int j = 0 ; j<m ; j++){\\n                if(!visit[i][j]){\\n                    if(dfs(i,j,grid,visit,{-1,-1})) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,vector<vector<char>>& grid, vector<vector<int>> &visit,pair<int,int> parent){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int row[] = {1,-1,0,0};\\n        int col[] = {0,0,1,-1};\\n        visit[i][j] = 1;\\n        for(int k = 0 ; k<4 ; k++){\\n            int nrow = row[k]+i;\\n            int ncol = col[k]+j;\\n            pair<int,int> p = {nrow,ncol};\\n            if(nrow<n && ncol<m && nrow>=0 && ncol>=0 && grid[nrow][ncol]==grid[i][j]){\\n                if(!visit[nrow][ncol] ){ if(dfs(nrow,ncol,grid,visit,{i,j})) return true;}\\n                else if(p!= parent) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> visit(n,vector<int> (m,0));\\n        for(int i = 0 ; i< n ; i++){\\n            for(int j = 0 ; j<m ; j++){\\n                if(!visit[i][j]){\\n                    if(dfs(i,j,grid,visit,{-1,-1})) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778607,
                "title": "easy-java-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n      public static class pair\\n    {\\n        private int key;\\n        private int value;\\n        private int key1;\\n        private int key2;\\n        public pair(int key,int value,int key1,int key2)\\n        {\\n            this.key=key;\\n            this.value=value;\\n            this.key1=key1;\\n            this.key2=key2;\\n        }\\n    }\\n    public static boolean bfs(char[][]grid,int[][]vis,int i,int j,char ma)\\n    {\\n        Queue<pair>q=new LinkedList<>();\\n       boolean flag=true;\\n        q.add(new pair(i,j,-1,-1));\\n        vis[i][j]=1;\\n        while(!q.isEmpty())\\n        {\\n            \\n            int in=q.peek().key;\\n            int jn=q.peek().value;\\n            int pi=q.peek().key1;\\n            int pj=q.poll().key2;\\n         \\n            if(in>0 && grid[in-1][jn]==ma && vis[in-1][jn]==0)\\n            {\\n                vis[in-1][jn]=1;\\n                q.add(new pair(in-1,jn,in,jn));\\n               \\n            }\\n            else if((pi!=in-1 && jn!=pj) &&in>0 && grid[in-1][jn]==ma&& vis[in-1][jn]==1)\\n            {\\n               \\n                flag=false;\\n            }\\n           \\n            if(jn>0 && grid[in][jn-1]==ma && vis[in][jn-1]==0)\\n            {\\n                vis[in][jn-1]=1;\\n                q.add(new pair(in,jn-1,in,jn));\\n                \\n            }\\n            else if((pi!=in || pj!=jn-1)&&jn>0 && grid[in][jn-1]==ma && vis[in][jn-1]==1)\\n            {\\n                flag=false;\\n               \\n            }\\n            \\n            if(in<grid.length-1 && grid[in+1][jn]==ma && vis[in+1][jn]==0)\\n            {\\n                vis[in+1][jn]=1;\\n                q.add(new pair(in+1,jn,in,jn));\\n                \\n            }\\n            else if((pi!=in+1 || jn!=pj)&&in<grid.length-1 && grid[in+1][jn]==ma && vis[in+1][jn]==1)\\n            {\\n                flag=false;\\n               \\n            }\\n            if(jn<grid[0].length -1&& grid[in][jn+1]==ma && vis[in][jn+1]==0)\\n            {\\n                vis[in][jn+1]=1;\\n                q.add(new pair(in,jn+1,in,jn));\\n                \\n            }\\n            else if((pi!=in || pj!=jn+1)&&jn<grid[0].length -1&& grid[in][jn+1]==ma && vis[in][jn+1]==1)\\n            {\\n                flag=false;\\n                \\n            }\\n\\n        }\\n        return flag;\\n    }\\n    public boolean containsCycle(char[][] grid) {\\n         int n=grid.length;\\n        int m=grid[0].length;\\n        int[][]vis=new int[n][m];\\n        \\n        int fmax=0;\\n     \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                 \\n                if(vis[i][j]==0)\\n                {\\n                   \\n                    \\n                   if(!bfs(grid,vis,i,j,grid[i][j]))\\n                   {\\n                      \\n                       return true;\\n                   }\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n      public static class pair\\n    {\\n        private int key;\\n        private int value;\\n        private int key1;\\n        private int key2;\\n        public pair(int key,int value,int key1,int key2)\\n        {\\n            this.key=key;\\n            this.value=value;\\n            this.key1=key1;\\n            this.key2=key2;\\n        }\\n    }\\n    public static boolean bfs(char[][]grid,int[][]vis,int i,int j,char ma)\\n    {\\n        Queue<pair>q=new LinkedList<>();\\n       boolean flag=true;\\n        q.add(new pair(i,j,-1,-1));\\n        vis[i][j]=1;\\n        while(!q.isEmpty())\\n        {\\n            \\n            int in=q.peek().key;\\n            int jn=q.peek().value;\\n            int pi=q.peek().key1;\\n            int pj=q.poll().key2;\\n         \\n            if(in>0 && grid[in-1][jn]==ma && vis[in-1][jn]==0)\\n            {\\n                vis[in-1][jn]=1;\\n                q.add(new pair(in-1,jn,in,jn));\\n               \\n            }\\n            else if((pi!=in-1 && jn!=pj) &&in>0 && grid[in-1][jn]==ma&& vis[in-1][jn]==1)\\n            {\\n               \\n                flag=false;\\n            }\\n           \\n            if(jn>0 && grid[in][jn-1]==ma && vis[in][jn-1]==0)\\n            {\\n                vis[in][jn-1]=1;\\n                q.add(new pair(in,jn-1,in,jn));\\n                \\n            }\\n            else if((pi!=in || pj!=jn-1)&&jn>0 && grid[in][jn-1]==ma && vis[in][jn-1]==1)\\n            {\\n                flag=false;\\n               \\n            }\\n            \\n            if(in<grid.length-1 && grid[in+1][jn]==ma && vis[in+1][jn]==0)\\n            {\\n                vis[in+1][jn]=1;\\n                q.add(new pair(in+1,jn,in,jn));\\n                \\n            }\\n            else if((pi!=in+1 || jn!=pj)&&in<grid.length-1 && grid[in+1][jn]==ma && vis[in+1][jn]==1)\\n            {\\n                flag=false;\\n               \\n            }\\n            if(jn<grid[0].length -1&& grid[in][jn+1]==ma && vis[in][jn+1]==0)\\n            {\\n                vis[in][jn+1]=1;\\n                q.add(new pair(in,jn+1,in,jn));\\n                \\n            }\\n            else if((pi!=in || pj!=jn+1)&&jn<grid[0].length -1&& grid[in][jn+1]==ma && vis[in][jn+1]==1)\\n            {\\n                flag=false;\\n                \\n            }\\n\\n        }\\n        return flag;\\n    }\\n    public boolean containsCycle(char[][] grid) {\\n         int n=grid.length;\\n        int m=grid[0].length;\\n        int[][]vis=new int[n][m];\\n        \\n        int fmax=0;\\n     \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                 \\n                if(vis[i][j]==0)\\n                {\\n                   \\n                    \\n                   if(!bfs(grid,vis,i,j,grid[i][j]))\\n                   {\\n                      \\n                       return true;\\n                   }\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778002,
                "title": "java-dfs-solution-explained-with-figure-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We need to find a cycle (of length >= 4) within a cluster of identical cells within matrix grid[][].\\n- We will examine each such cluster using dfs algorithm, and simultaneously maintaining a visited matrix.\\n- It is important to note that only identical cells will be visited and a cycle may not neccessarily originate from the the first cell in the cluster, but any cell inside it. \\n- So we will check each previously visited cell to see if it forms a valid cycle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Create a visited matrix vis[][], which stores the steps taken to arrive at each cell.\\n2. If vis[i][j] == 0, that represents an unvisited cell.\\n3. From each such unvisited cell we need to start a DFS traversal to find a cycle.\\n4. Since every identical cell within a cluster will be visited by the dfs function, we need only call dfs function for an un-visited cell.\\n5. Before dfs starts, number of steps are 0.\\n6. In each dfs call, only proceed if the current cell has a value identical to the destination cell (grid[destr][destc]).\\n7. Before updating the value of steps, check whether the current cell has been already been visited.\\n8. If so, then by taking (steps + 1) steps from the starting cell, we would have arrived back at this current cell. \\n9. So check if (steps + 1) - vis[r][c] >= 4, i.e if the steps needed to come back to current cell are >= 4.\\n10. If none of the base conditions are fulfilled: update the value of steps, and mark visited in the vis[][] matrix.\\n11. Now call dfs for neighbours on the right, down, left, up.\\n\\n![Capture.PNG](https://assets.leetcode.com/users/images/d7b66ec4-945a-487b-b73b-44d48cf9446b_1689591483.4657118.png)\\n*Characters in red represent the cluster of identical cells, numbers in subscript are the steps taken to reach individial cells starting from the beginning*\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int R = grid.length;\\n        int C = grid[0].length;\\n\\n\\n        int[][] vis = new int[R][C];\\n        for(int i = 0; i < R; i ++) {\\n            \\n            for(int j = 0; j < C; j++) {\\n            \\n                boolean found = false;\\n                if(vis[i][j] == 0) {\\n                    int steps = 0;\\n                    found = dfs(i, j, i, j, grid, vis, steps);\\n                }\\n                if(found) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n    \\n    int[] delR = {0, 1, 0, -1};\\n    int[] delC = {1, 0, -1, 0};\\n\\n    public boolean dfs(int r, int c, int destr, int destc, char[][] grid, int[][] vis, int steps) {\\n        int R = grid.length;\\n        int C = grid[0].length;\\n\\n        // check range\\n        if(r >= R || r < 0 || c >= C || c < 0) return false;\\n        \\n        // check identical character\\n        if(grid[destr][destc] != grid[r][c]) return false;\\n\\n        // check if reached a visited cell with valid steps\\n        if(vis[r][c] != 0) {\\n            if((steps+1) - vis[r][c] >= 4) return true;\\n            else return false;\\n        }        \\n\\n        // mark visited with the current number of steps\\n        vis[r][c] = ++steps;        \\n\\n        for(int i = 0; i < 4; i++) {\\n            int nbrR = r + delR[i];\\n            int nbrC = c + delC[i];\\n\\n            boolean found = false;\\n            found = found || dfs(nbrR, nbrC, destr, destc, grid, vis, steps);\\n            if(found) return true;\\n        }\\n\\n        return false;\\n\\n    }    \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int R = grid.length;\\n        int C = grid[0].length;\\n\\n\\n        int[][] vis = new int[R][C];\\n        for(int i = 0; i < R; i ++) {\\n            \\n            for(int j = 0; j < C; j++) {\\n            \\n                boolean found = false;\\n                if(vis[i][j] == 0) {\\n                    int steps = 0;\\n                    found = dfs(i, j, i, j, grid, vis, steps);\\n                }\\n                if(found) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n    \\n    int[] delR = {0, 1, 0, -1};\\n    int[] delC = {1, 0, -1, 0};\\n\\n    public boolean dfs(int r, int c, int destr, int destc, char[][] grid, int[][] vis, int steps) {\\n        int R = grid.length;\\n        int C = grid[0].length;\\n\\n        // check range\\n        if(r >= R || r < 0 || c >= C || c < 0) return false;\\n        \\n        // check identical character\\n        if(grid[destr][destc] != grid[r][c]) return false;\\n\\n        // check if reached a visited cell with valid steps\\n        if(vis[r][c] != 0) {\\n            if((steps+1) - vis[r][c] >= 4) return true;\\n            else return false;\\n        }        \\n\\n        // mark visited with the current number of steps\\n        vis[r][c] = ++steps;        \\n\\n        for(int i = 0; i < 4; i++) {\\n            int nbrR = r + delR[i];\\n            int nbrC = c + delC[i];\\n\\n            boolean found = false;\\n            found = found || dfs(nbrR, nbrC, destr, destc, grid, vis, steps);\\n            if(found) return true;\\n        }\\n\\n        return false;\\n\\n    }    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767639,
                "title": "dfs-easily-undersatable-you-can-also-modify",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool solvedfs(vector<vector<char>> &grid,vector<vector<int>> &visited,int i,int j,int p_r,int p_c,int n,int m,int len)\\n    {\\n        \\n        visited[i][j] = true;\\n        len++;\\n        \\n        int ar[4]={0,-1,0,1};\\n        int br[4]={-1,0,1,0};\\n\\n        for(int k=0;k<4;k++)\\n        {\\n            int r = i+ar[k];\\n            int c = j+br[k];\\n\\n            if(r <0 || c<0 ||r>=n ||c>=m || grid[r][c] != grid[i][j])\\n            {\\n                continue;\\n            }\\n            if(r==p_r && c==p_c)\\n                continue;\\n\\n            if(!visited[r][c])\\n            {\\n                bool ans = solvedfs(grid,visited,r,c,i,j,n,m,len);\\n                if(ans)\\n                    return true;\\n            }\\n            else\\n            {\\n                if( (r != p_r || c!=p_c) && len >= 4)\\n                    return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n\\n    bool containsCycle(vector<vector<char>>& grid) {\\n\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int len = 0;\\n                bool ans = solvedfs(grid,visited,i,j,-1,-1,n,m,len);\\n                if(ans)\\n                    return true;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool solvedfs(vector<vector<char>> &grid,vector<vector<int>> &visited,int i,int j,int p_r,int p_c,int n,int m,int len)\\n    {\\n        \\n        visited[i][j] = true;\\n        len++;\\n        \\n        int ar[4]={0,-1,0,1};\\n        int br[4]={-1,0,1,0};\\n\\n        for(int k=0;k<4;k++)\\n        {\\n            int r = i+ar[k];\\n            int c = j+br[k];\\n\\n            if(r <0 || c<0 ||r>=n ||c>=m || grid[r][c] != grid[i][j])\\n            {\\n                continue;\\n            }\\n            if(r==p_r && c==p_c)\\n                continue;\\n\\n            if(!visited[r][c])\\n            {\\n                bool ans = solvedfs(grid,visited,r,c,i,j,n,m,len);\\n                if(ans)\\n                    return true;\\n            }\\n            else\\n            {\\n                if( (r != p_r || c!=p_c) && len >= 4)\\n                    return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n\\n    bool containsCycle(vector<vector<char>>& grid) {\\n\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int len = 0;\\n                bool ans = solvedfs(grid,visited,i,j,-1,-1,n,m,len);\\n                if(ans)\\n                    return true;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767317,
                "title": "c-easy-to-understand-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m * n * 4^k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& grid, vector<vector<bool>>& vis, pair<int, int> parent, pair<int, int> grandparent, int m, int n, int i, int j, int depth) {\\n        if (vis[i][j]) {\\n            if (depth >= 4) {\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        vis[i][j] = true;\\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, -1, 1};\\n\\n        for (int k = 0; k < 4; k++) {\\n            int ni = i + dx[k];\\n            int nj = j + dy[k];\\n\\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && grid[ni][nj] == grid[i][j] && !check({ni, nj}, parent) && !check({ni, nj}, grandparent)) {\\n                if (dfs(grid, vis, {i, j}, parent, m, n, ni, nj, depth + 1)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!vis[i][j]) {\\n                    if (dfs(grid, vis, {-1, -1}, {-1, -1}, m, n, i, j, 1)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool check(pair<int, int> a, pair<int, int> b) {\\n        return a.first == b.first && a.second == b.second;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& grid, vector<vector<bool>>& vis, pair<int, int> parent, pair<int, int> grandparent, int m, int n, int i, int j, int depth) {\\n        if (vis[i][j]) {\\n            if (depth >= 4) {\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        vis[i][j] = true;\\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, -1, 1};\\n\\n        for (int k = 0; k < 4; k++) {\\n            int ni = i + dx[k];\\n            int nj = j + dy[k];\\n\\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && grid[ni][nj] == grid[i][j] && !check({ni, nj}, parent) && !check({ni, nj}, grandparent)) {\\n                if (dfs(grid, vis, {i, j}, parent, m, n, ni, nj, depth + 1)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!vis[i][j]) {\\n                    if (dfs(grid, vis, {-1, -1}, {-1, -1}, m, n, i, j, 1)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool check(pair<int, int> a, pair<int, int> b) {\\n        return a.first == b.first && a.second == b.second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751069,
                "title": "python-solution-using-dfs-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDuring the dfs traversal from the given symbol, if we reach a node which has already been visited and it is not its parent, then we have found a cycle in the grid.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each element in the grid, we will do a dfs traversal with the given symbol and starting parent as [-1, -1 ]. We store the current arguement of the dfs function as the parent of each possible newRow and newColumn. In each traversal, if the grid element is not parent and has been visited then we must have visited it during the current traversal. We return from there. Otherwise, we start a new dfs traversal with the newRow and newCol\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n\\n        numRows, numCols = len(grid), len(grid[0])\\n\\n        visited = [[False for i in range(numCols)] for j in range(numRows)]\\n\\n        dirs = [[-1,0], [1, 0], [0, -1], [0, 1]]\\n        flag = False\\n\\n        def dfs(row, col, parent, symb):\\n            nonlocal flag\\n            visited[row][col] = True\\n            for d in dirs:\\n                newRow = row + d[0]\\n                newCol = col + d[1]\\n\\n                if 0 <= newRow < numRows and 0 <= newCol < numCols:\\n                    if grid[newRow][newCol] == symb:\\n                        if (parent[0] != newRow or parent[1] != newCol) and visited[newRow][newCol] == True:\\n                            flag = True\\n                            return\\n                        if not visited[newRow][newCol]:\\n                            dfs(newRow, newCol,[row, col], symb)\\n        \\n        \\n        for i in range(numRows):\\n            for j in range(numCols):\\n                if not visited[i][j]:\\n                    dfs(i, j, [-1,-1], grid[i][j])\\n\\n        return flag\\n\\n```\\n\\n\\nUpvote if you liked the answer",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n\\n        numRows, numCols = len(grid), len(grid[0])\\n\\n        visited = [[False for i in range(numCols)] for j in range(numRows)]\\n\\n        dirs = [[-1,0], [1, 0], [0, -1], [0, 1]]\\n        flag = False\\n\\n        def dfs(row, col, parent, symb):\\n            nonlocal flag\\n            visited[row][col] = True\\n            for d in dirs:\\n                newRow = row + d[0]\\n                newCol = col + d[1]\\n\\n                if 0 <= newRow < numRows and 0 <= newCol < numCols:\\n                    if grid[newRow][newCol] == symb:\\n                        if (parent[0] != newRow or parent[1] != newCol) and visited[newRow][newCol] == True:\\n                            flag = True\\n                            return\\n                        if not visited[newRow][newCol]:\\n                            dfs(newRow, newCol,[row, col], symb)\\n        \\n        \\n        for i in range(numRows):\\n            for j in range(numCols):\\n                if not visited[i][j]:\\n                    dfs(i, j, [-1,-1], grid[i][j])\\n\\n        return flag\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732815,
                "title": "bfs-100-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def containsCycle(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        m,n=len(grid),len(grid[0])\\n        #print(mask)\\n        mask=[[0]*n for j in range(m)]\\n        def bfs(grid,row,column,prev_r,prev_c,k):\\n                start_index=[row,column,prev_r,prev_c]\\n                queue=[start_index]\\n                #res=[]\\n                while queue:\\n                    i,j,r,c=queue.pop(0)\\n                    if i+1>=0 and i+1<len(grid) and grid[i+1][j]==k and [i+1,j]!=[r,c]:\\n                        queue.append([i+1,j,i,j])\\n              \\n                    if i-1>=0 and i-1<len(grid) and grid[i-1][j]==k and [i-1,j]!=[r,c]:\\n                        queue.append([i-1,j,i,j])\\n                    if j+1>=0 and j+1<len(grid[0]) and grid[i][j+1]==k and [i,j+1]!=[r,c]:\\n                        queue.append([i,j+1,i,j])\\n                    if j-1>=0 and j-1<len(grid[0]) and grid[i][j-1]==k and [i,j-1]!=[r,c]:\\n                        \\n                        queue.append([i,j-1,i,j])\\n                    if mask[i][j]==1:\\n                        return True\\n                    \\n                    #res.append([i,j])\\n                    mask[i][j]=1\\n\\n                return False\\n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if mask[i][j]==0 and bfs(grid,i,j,-1,-1,grid[i][j]):\\n                    return True\\n        return False\\n\\n\\n\\n   \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def containsCycle(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        m,n=len(grid),len(grid[0])\\n        #print(mask)\\n        mask=[[0]*n for j in range(m)]\\n        def bfs(grid,row,column,prev_r,prev_c,k):\\n                start_index=[row,column,prev_r,prev_c]\\n                queue=[start_index]\\n                #res=[]\\n                while queue:\\n                    i,j,r,c=queue.pop(0)\\n                    if i+1>=0 and i+1<len(grid) and grid[i+1][j]==k and [i+1,j]!=[r,c]:\\n                        queue.append([i+1,j,i,j])\\n              \\n                    if i-1>=0 and i-1<len(grid) and grid[i-1][j]==k and [i-1,j]!=[r,c]:\\n                        queue.append([i-1,j,i,j])\\n                    if j+1>=0 and j+1<len(grid[0]) and grid[i][j+1]==k and [i,j+1]!=[r,c]:\\n                        queue.append([i,j+1,i,j])\\n                    if j-1>=0 and j-1<len(grid[0]) and grid[i][j-1]==k and [i,j-1]!=[r,c]:\\n                        \\n                        queue.append([i,j-1,i,j])\\n                    if mask[i][j]==1:\\n                        return True\\n                    \\n                    #res.append([i,j])\\n                    mask[i][j]=1\\n\\n                return False\\n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if mask[i][j]==0 and bfs(grid,i,j,-1,-1,grid[i][j]):\\n                    return True\\n        return False\\n\\n\\n\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732812,
                "title": "bfs-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def containsCycle(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        m,n=len(grid),len(grid[0])\\n        #print(mask)\\n        mask=[[0]*n for j in range(m)]\\n        def bfs(grid,row,column,prev_r,prev_c,k):\\n                start_index=[row,column,prev_r,prev_c]\\n                queue=[start_index]\\n                res=[]\\n                while queue:\\n                    i,j,r,c=queue.pop(0)\\n                    if i+1>=0 and i+1<len(grid) and grid[i+1][j]==k and [i+1,j]!=[r,c]:\\n                        queue.append([i+1,j,i,j])\\n              \\n                    if i-1>=0 and i-1<len(grid) and grid[i-1][j]==k and [i-1,j]!=[r,c]:\\n                        queue.append([i-1,j,i,j])\\n                    if j+1>=0 and j+1<len(grid[0]) and grid[i][j+1]==k and [i,j+1]!=[r,c]:\\n                        queue.append([i,j+1,i,j])\\n                    if j-1>=0 and j-1<len(grid[0]) and grid[i][j-1]==k and [i,j-1]!=[r,c]:\\n                        \\n                        queue.append([i,j-1,i,j])\\n                    if mask[i][j]==1:\\n                        return True\\n                    \\n                    res.append([i,j])\\n                    mask[i][j]=1\\n\\n                return False\\n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if mask[i][j]==0 and bfs(grid,i,j,-1,-1,grid[i][j]):\\n                    return True\\n        return False\\n\\n\\n\\n   \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def containsCycle(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        m,n=len(grid),len(grid[0])\\n        #print(mask)\\n        mask=[[0]*n for j in range(m)]\\n        def bfs(grid,row,column,prev_r,prev_c,k):\\n                start_index=[row,column,prev_r,prev_c]\\n                queue=[start_index]\\n                res=[]\\n                while queue:\\n                    i,j,r,c=queue.pop(0)\\n                    if i+1>=0 and i+1<len(grid) and grid[i+1][j]==k and [i+1,j]!=[r,c]:\\n                        queue.append([i+1,j,i,j])\\n              \\n                    if i-1>=0 and i-1<len(grid) and grid[i-1][j]==k and [i-1,j]!=[r,c]:\\n                        queue.append([i-1,j,i,j])\\n                    if j+1>=0 and j+1<len(grid[0]) and grid[i][j+1]==k and [i,j+1]!=[r,c]:\\n                        queue.append([i,j+1,i,j])\\n                    if j-1>=0 and j-1<len(grid[0]) and grid[i][j-1]==k and [i,j-1]!=[r,c]:\\n                        \\n                        queue.append([i,j-1,i,j])\\n                    if mask[i][j]==1:\\n                        return True\\n                    \\n                    res.append([i,j])\\n                    mask[i][j]=1\\n\\n                return False\\n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if mask[i][j]==0 and bfs(grid,i,j,-1,-1,grid[i][j]):\\n                    return True\\n        return False\\n\\n\\n\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712334,
                "title": "python-bfs-o-n2",
                "content": "```\\nfrom queue import SimpleQueue\\n\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n\\n        rows, cols = len(grid), len(grid[0])\\n        visited = [[False] * cols for _ in range(0, rows)]\\n\\n        q = SimpleQueue()\\n\\n        for i in range(0, rows):\\n            for j in range(0, cols):\\n                if not visited[i][j]:\\n                    visited[i][j] = True\\n                    q.put((i, j, -1, -1))\\n                    if self.dfs(q, rows, cols, visited, grid):\\n                        return True\\n\\n    def dfs(self, q, rows, cols, visited, grid):\\n        while q.qsize() > 0:\\n            row, col, src_row, src_col = q.get()\\n\\n            for i in range(-1, 2):\\n                for j in range(-1, 2):\\n                    nrow, ncol = row + i, col + j\\n                    if(\\n                        abs(i) != abs(j) and\\n                        nrow >= 0 and \\n                        ncol >= 0 and \\n                        nrow < rows and \\n                        ncol < cols and\\n                        grid[nrow][ncol] == grid[row][col]\\n                    ):\\n                        if not visited[nrow][ncol]:\\n                            q.put((nrow, ncol, row, col))\\n                            visited[nrow][ncol] = True\\n                        elif visited[nrow][ncol] and (nrow, ncol) != (src_row, src_col):\\n                            return True \\n\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom queue import SimpleQueue\\n\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n\\n        rows, cols = len(grid), len(grid[0])\\n        visited = [[False] * cols for _ in range(0, rows)]\\n\\n        q = SimpleQueue()\\n\\n        for i in range(0, rows):\\n            for j in range(0, cols):\\n                if not visited[i][j]:\\n                    visited[i][j] = True\\n                    q.put((i, j, -1, -1))\\n                    if self.dfs(q, rows, cols, visited, grid):\\n                        return True\\n\\n    def dfs(self, q, rows, cols, visited, grid):\\n        while q.qsize() > 0:\\n            row, col, src_row, src_col = q.get()\\n\\n            for i in range(-1, 2):\\n                for j in range(-1, 2):\\n                    nrow, ncol = row + i, col + j\\n                    if(\\n                        abs(i) != abs(j) and\\n                        nrow >= 0 and \\n                        ncol >= 0 and \\n                        nrow < rows and \\n                        ncol < cols and\\n                        grid[nrow][ncol] == grid[row][col]\\n                    ):\\n                        if not visited[nrow][ncol]:\\n                            q.put((nrow, ncol, row, col))\\n                            visited[nrow][ncol] = True\\n                        elif visited[nrow][ncol] and (nrow, ncol) != (src_row, src_col):\\n                            return True \\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697551,
                "title": "python-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(mn)\\r\\n\\r\\n- Space complexity:\\r\\nO(mn)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\r\\n        rows = len(grid)\\r\\n        cols = len(grid[0])\\r\\n        visited = [[False for i in range(cols)] for j in range(rows)]\\r\\n        for i in range(rows):\\r\\n            for j in range(cols):\\r\\n                if not visited[i][j]:\\r\\n                    if self.is_cycle(grid, i, j, visited, grid[i][j], -1, -1):\\r\\n                        return True\\r\\n        return False\\r\\n    \\r\\n    def is_cycle(self, grid, x, y, visited, start_char, prev_x, prev_y):\\r\\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\\r\\n            return False\\r\\n        if grid[x][y] != start_char:\\r\\n            return False\\r\\n        \\r\\n        if visited[x][y]:\\r\\n            return True\\r\\n        \\r\\n        visited[x][y] = True\\r\\n\\r\\n        if x + 1 != prev_x and self.is_cycle(grid, x + 1, y, visited, start_char, x, y):\\r\\n            return True\\r\\n        if x - 1 != prev_x and self.is_cycle(grid, x - 1, y, visited, start_char, x, y):\\r\\n            return True\\r\\n        if y + 1 != prev_y and self.is_cycle(grid, x, y + 1, visited, start_char, x, y):\\r\\n            return True\\r\\n        if y - 1 != prev_y and self.is_cycle(grid, x, y - 1, visited, start_char, x, y):\\r\\n            return True\\r\\n        \\r\\n        return False\\r\\n    \\r\\n    #O(mn) T, O(mn) S\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\r\\n        rows = len(grid)\\r\\n        cols = len(grid[0])\\r\\n        visited = [[False for i in range(cols)] for j in range(rows)]\\r\\n        for i in range(rows):\\r\\n            for j in range(cols):\\r\\n                if not visited[i][j]:\\r\\n                    if self.is_cycle(grid, i, j, visited, grid[i][j], -1, -1):\\r\\n                        return True\\r\\n        return False\\r\\n    \\r\\n    def is_cycle(self, grid, x, y, visited, start_char, prev_x, prev_y):\\r\\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\\r\\n            return False\\r\\n        if grid[x][y] != start_char:\\r\\n            return False\\r\\n        \\r\\n        if visited[x][y]:\\r\\n            return True\\r\\n        \\r\\n        visited[x][y] = True\\r\\n\\r\\n        if x + 1 != prev_x and self.is_cycle(grid, x + 1, y, visited, start_char, x, y):\\r\\n            return True\\r\\n        if x - 1 != prev_x and self.is_cycle(grid, x - 1, y, visited, start_char, x, y):\\r\\n            return True\\r\\n        if y + 1 != prev_y and self.is_cycle(grid, x, y + 1, visited, start_char, x, y):\\r\\n            return True\\r\\n        if y - 1 != prev_y and self.is_cycle(grid, x, y - 1, visited, start_char, x, y):\\r\\n            return True\\r\\n        \\r\\n        return False\\r\\n    \\r\\n    #O(mn) T, O(mn) S\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696619,
                "title": "simple-dfs-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool dfs(int x,int y,vector<vector<char>>& grid,vector<vector<int>>&vis,int px,int py){\\n        vis[x][y] = 1;\\n        int dir[5] = {0,-1,0,1,0};\\n        for(int i=0; i<4; i++){\\n            int nx = x + dir[i];\\n            int ny = y + dir[i+1];\\n            if(nx>=0 && nx<grid.size() && ny>=0 && ny<grid[0].size()&& grid[nx][ny] == grid[x][y] && (nx!=px || ny!=py)){\\n                if(vis[nx][ny]==1){\\n                    return true;\\n                }\\n                if(dfs(nx,ny,grid,vis,x,y)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]){\\n                    if(dfs(i,j,grid,vis,-1,-1)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(int x,int y,vector<vector<char>>& grid,vector<vector<int>>&vis,int px,int py){\\n        vis[x][y] = 1;\\n        int dir[5] = {0,-1,0,1,0};\\n        for(int i=0; i<4; i++){\\n            int nx = x + dir[i];\\n            int ny = y + dir[i+1];\\n            if(nx>=0 && nx<grid.size() && ny>=0 && ny<grid[0].size()&& grid[nx][ny] == grid[x][y] && (nx!=px || ny!=py)){\\n                if(vis[nx][ny]==1){\\n                    return true;\\n                }\\n                if(dfs(nx,ny,grid,vis,x,y)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]){\\n                    if(dfs(i,j,grid,vis,-1,-1)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694441,
                "title": "explanation-with-pictures",
                "content": "\\n```\\nIn the dfs function dfs going by left, up, right, bottom.\\nBelow with a picture with marking a cycle :\\n```\\n\\n![t0.png](https://assets.leetcode.com/users/images/516e8d8d-dfff-45f2-b406-81a6805e3dab_1687985045.7242498.png)\\n\\n![lalal.png](https://assets.leetcode.com/users/images/8ea2fd7e-0fa1-4d21-9964-4c26ea4eda15_1687988785.1160505.png)\\n\\n![lalal.png](https://assets.leetcode.com/users/images/c275d6d2-5c4d-4457-a739-5fd4c52361c4_1687989070.597575.png)\\n\\n![t0.png](https://assets.leetcode.com/users/images/907320c6-8adb-4f82-9894-d4d07bc7fb1d_1687989116.325129.png)\\n\\n```\\nWe straight went from grid[0][1] to grid[1][1] (blue marked) because TO COMPLETE A CYCLE\\nWE CAN NEVER GO BACK (grid[0][0]), WE ONLY HAVE TO GO FORWARD (grid[1][1]). Then from\\ngrid[1][0] we went to grid[0][0] and grid[0][0] already visited means CYCLE COMPLETED. \\n\\nSo if the current row and colomn has visited - will be true only when a cycle completed.\\n```\\n#### The main logic : \\n```\\nFrom PARENT (grid[0][0]) when we go to it\\'s right CHILD (grid[0][1]), now from that right CHILD\\nwe\\'ve to make sure we don\\'t go back to it\\'s PARENT (grid[0][0]), we\\'ve to go straight to\\ndown (blue marked).\\n\\n         C++                                          Python\\nfor(auto &d : diff)                            for (x,y) in ((0, -1), (-1, 0), (0, 1), (1, 0)):            \\n{                                                  tr, tc = r+x, c+y\\n    tr = r+d[0], tc = c+d[1];                      if tr == pr and tc == pc:\\n    if(tr == pr && tc == pc)                           continue\\n        continue;                                  dfs(tr, tc, oldcolor, r, c)\\n    dfs(grid, visited, tr, tc, oldcolor, r, c);\\n}\\n\\n\\nThis part making sure RIGHT AFTER GOING FROM THE PARENT CELL TO IT\\'S CHILD, THE CHILD WON\\'T\\nGO BACK TO IT\\'S PARENT.\\n```\\n\\n![ohho.png](https://assets.leetcode.com/users/images/97fab1f6-a920-478d-a909-fceb511658ee_1687995432.9378693.png)\\n\\n```\\nAfter coming to red circle cell, in normal dfs we would call a dfs on the left cell of the\\nred circle cell, then as grid[0][0] visited already so it would go back to its caller,\\nthen we go to down cell as up doesn\\'t exist for grid[0][1].\\n\\nBut here we straight go to down. \\n```\\n\\n```CPP []\\nclass Solution {\\npublic:\\n    vector<vector<int>> diff = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; // left up right down\\n    bool cycle = false;\\n    int i, tr, tc;\\n\\n    bool dfs(vector<vector<char>>& grid, vector<vector<bool>> &visited, int r, int c, char oldcolor, int pr = -1, int pc = -1)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] != oldcolor || cycle == true)\\n            return true; // True or False doesn\\'t matter cause dfs is not storing any value\\n        if(visited[r][c] == true){\\n            cycle = true;\\n            return true; // same here, True or False doesn\\'t matter\\n        }\\n\\n        visited[r][c] = true;\\n        for(auto &d : diff)\\n        {\\n            tr = r+d[0], tc = c+d[1];\\n            if(tr == pr && tc == pc)\\n                continue;\\n            dfs(grid, visited, tr, tc, oldcolor, r, c);\\n        }\\n        return cycle == true ? true : false; // only this one matter, it will happen at the very end \\n    }\\n\\n    bool containsCycle(vector<vector<char>>& grid) \\n    {\\n        vector<vector<bool>> visited( grid.size(), vector<bool>(grid[0].size()) );\\n\\n        for(int r=0; r<grid.size(); r++)\\n            for(int c=0; c<grid[0].size(); c++)\\n                if(!visited[r][c] && dfs(grid, visited, r, c, grid[r][c]) == true)\\n                    return true;\\n\\n        return false;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        row, col, cycle = len(grid), len(grid[0]), False\\n        visited = [ [False for _ in range(col)] for _ in range(row) ]\\n\\n        def dfs(r:int, c:int, oldcolor:str, pr:int = -1, pc:int = -1):\\n            nonlocal cycle\\n            if r<0 or r>=row or c<0 or c>=col or grid[r][c] != oldcolor or cycle == True:\\n                return True # True or False doesn\\'t matter cause dfs is not storing any value\\n            if visited[r][c] == True:\\n                cycle = True; return True # same here, True or False doesn\\'t matter\\n\\n            visited[r][c] = True\\n            for (x,y) in ((0, -1), (-1, 0), (0, 1), (1, 0)):\\n                tr, tc = r+x, c+y\\n                if tr == pr and tc == pc:\\n                    continue\\n                dfs(tr, tc, oldcolor, r, c)\\n\\n            return True if cycle == True else False # only this one matter, it will happen at the end\\n\\n        return next((True for r in range(row) for c in range(col) if visited[r][c] == 0 and dfs(r,c,grid[r][c]) == True), False)\\n```\\n```\\nTime  complexity : O(mn)\\nSpace complexity : O(1)\\n```\\n### If the post was helpful, an upvote will be appreciated.",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nIn the dfs function dfs going by left, up, right, bottom.\\nBelow with a picture with marking a cycle :\\n```\n```\\nWe straight went from grid[0][1] to grid[1][1] (blue marked) because TO COMPLETE A CYCLE\\nWE CAN NEVER GO BACK (grid[0][0]), WE ONLY HAVE TO GO FORWARD (grid[1][1]). Then from\\ngrid[1][0] we went to grid[0][0] and grid[0][0] already visited means CYCLE COMPLETED. \\n\\nSo if the current row and colomn has visited - will be true only when a cycle completed.\\n```\n```\\nFrom PARENT (grid[0][0]) when we go to it\\'s right CHILD (grid[0][1]), now from that right CHILD\\nwe\\'ve to make sure we don\\'t go back to it\\'s PARENT (grid[0][0]), we\\'ve to go straight to\\ndown (blue marked).\\n\\n         C++                                          Python\\nfor(auto &d : diff)                            for (x,y) in ((0, -1), (-1, 0), (0, 1), (1, 0)):            \\n{                                                  tr, tc = r+x, c+y\\n    tr = r+d[0], tc = c+d[1];                      if tr == pr and tc == pc:\\n    if(tr == pr && tc == pc)                           continue\\n        continue;                                  dfs(tr, tc, oldcolor, r, c)\\n    dfs(grid, visited, tr, tc, oldcolor, r, c);\\n}\\n\\n\\nThis part making sure RIGHT AFTER GOING FROM THE PARENT CELL TO IT\\'S CHILD, THE CHILD WON\\'T\\nGO BACK TO IT\\'S PARENT.\\n```\n```\\nAfter coming to red circle cell, in normal dfs we would call a dfs on the left cell of the\\nred circle cell, then as grid[0][0] visited already so it would go back to its caller,\\nthen we go to down cell as up doesn\\'t exist for grid[0][1].\\n\\nBut here we straight go to down. \\n```\n```CPP []\\nclass Solution {\\npublic:\\n    vector<vector<int>> diff = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; // left up right down\\n    bool cycle = false;\\n    int i, tr, tc;\\n\\n    bool dfs(vector<vector<char>>& grid, vector<vector<bool>> &visited, int r, int c, char oldcolor, int pr = -1, int pc = -1)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] != oldcolor || cycle == true)\\n            return true; // True or False doesn\\'t matter cause dfs is not storing any value\\n        if(visited[r][c] == true){\\n            cycle = true;\\n            return true; // same here, True or False doesn\\'t matter\\n        }\\n\\n        visited[r][c] = true;\\n        for(auto &d : diff)\\n        {\\n            tr = r+d[0], tc = c+d[1];\\n            if(tr == pr && tc == pc)\\n                continue;\\n            dfs(grid, visited, tr, tc, oldcolor, r, c);\\n        }\\n        return cycle == true ? true : false; // only this one matter, it will happen at the very end \\n    }\\n\\n    bool containsCycle(vector<vector<char>>& grid) \\n    {\\n        vector<vector<bool>> visited( grid.size(), vector<bool>(grid[0].size()) );\\n\\n        for(int r=0; r<grid.size(); r++)\\n            for(int c=0; c<grid[0].size(); c++)\\n                if(!visited[r][c] && dfs(grid, visited, r, c, grid[r][c]) == true)\\n                    return true;\\n\\n        return false;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        row, col, cycle = len(grid), len(grid[0]), False\\n        visited = [ [False for _ in range(col)] for _ in range(row) ]\\n\\n        def dfs(r:int, c:int, oldcolor:str, pr:int = -1, pc:int = -1):\\n            nonlocal cycle\\n            if r<0 or r>=row or c<0 or c>=col or grid[r][c] != oldcolor or cycle == True:\\n                return True # True or False doesn\\'t matter cause dfs is not storing any value\\n            if visited[r][c] == True:\\n                cycle = True; return True # same here, True or False doesn\\'t matter\\n\\n            visited[r][c] = True\\n            for (x,y) in ((0, -1), (-1, 0), (0, 1), (1, 0)):\\n                tr, tc = r+x, c+y\\n                if tr == pr and tc == pc:\\n                    continue\\n                dfs(tr, tc, oldcolor, r, c)\\n\\n            return True if cycle == True else False # only this one matter, it will happen at the end\\n\\n        return next((True for r in range(row) for c in range(col) if visited[r][c] == 0 and dfs(r,c,grid[r][c]) == True), False)\\n```\n```\\nTime  complexity : O(mn)\\nSpace complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694356,
                "title": "java-solution-using-bfs",
                "content": "# Intuition\\nusing BFS\\n# Approach\\nstore 4 values\\n(current row,currwnt column,previous row, previous column)\\n in Pair class and pair class in Queue. \\n\\nif not visited : \\nadd in queue \\nmark visited\\nelse if: visited \\ncheck parent row ,column is same as visited\\nif same then continue\\nif parent row parent column not same as current row,column \\nthen return true.\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Pair{\\n    int a;\\n    int b;\\n    int c;\\n    int d;\\n    Pair(int a,int b,int c,int d){\\n        this.a=a;\\n        this.b=b;\\n        this.c=c;\\n        this.d=d;\\n\\n    }\\n}\\n\\nclass Solution {\\n\\n\\n    public boolean bfs(char [][] grid,boolean [][] visited ,int row,int col,int prerow,int precol){\\n        visited[row][col]=true;\\n\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        Queue<Pair> q=new LinkedList<>();\\n        q.add(new Pair(row,col,prerow,precol));\\n\\n        while(!q.isEmpty()){\\n            int ro=q.peek().a;\\n            int co=q.peek().b;\\n            int prow=q.peek().c;\\n            int pcol=q.peek().d;\\n            q.remove();\\n\\n\\n            int []r={1,-1,0,0};\\n            int []c= {0,0,1,-1};\\n\\n            for(int i=0;i<4;i++){\\n                int nrow=ro+r[i];\\n                int ncol=co+c[i];\\n\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==grid[ro][co] ) {\\n\\n                 if(visited[nrow][ncol]==false){\\n                     visited[nrow][ncol]=true;\\n                     q.add(new Pair(nrow,ncol,ro,co));\\n\\n\\n\\n                }\\n                else if(visited[nrow][ncol]==true){\\n                    if(nrow!=prow || ncol!=pcol) return true;\\n\\n                }\\n                }\\n\\n            }\\n\\n\\n        }\\n    return false;\\n  \\n    }\\n\\n    public boolean containsCycle(char[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        boolean [][] visited=new boolean [n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j]==false){\\n                   if(bfs(grid,visited,i,j,i,j)) return true;\\n\\n                }\\n            }\\n        }\\n\\n    return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int a;\\n    int b;\\n    int c;\\n    int d;\\n    Pair(int a,int b,int c,int d){\\n        this.a=a;\\n        this.b=b;\\n        this.c=c;\\n        this.d=d;\\n\\n    }\\n}\\n\\nclass Solution {\\n\\n\\n    public boolean bfs(char [][] grid,boolean [][] visited ,int row,int col,int prerow,int precol){\\n        visited[row][col]=true;\\n\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        Queue<Pair> q=new LinkedList<>();\\n        q.add(new Pair(row,col,prerow,precol));\\n\\n        while(!q.isEmpty()){\\n            int ro=q.peek().a;\\n            int co=q.peek().b;\\n            int prow=q.peek().c;\\n            int pcol=q.peek().d;\\n            q.remove();\\n\\n\\n            int []r={1,-1,0,0};\\n            int []c= {0,0,1,-1};\\n\\n            for(int i=0;i<4;i++){\\n                int nrow=ro+r[i];\\n                int ncol=co+c[i];\\n\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==grid[ro][co] ) {\\n\\n                 if(visited[nrow][ncol]==false){\\n                     visited[nrow][ncol]=true;\\n                     q.add(new Pair(nrow,ncol,ro,co));\\n\\n\\n\\n                }\\n                else if(visited[nrow][ncol]==true){\\n                    if(nrow!=prow || ncol!=pcol) return true;\\n\\n                }\\n                }\\n\\n            }\\n\\n\\n        }\\n    return false;\\n  \\n    }\\n\\n    public boolean containsCycle(char[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        boolean [][] visited=new boolean [n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j]==false){\\n                   if(bfs(grid,visited,i,j,i,j)) return true;\\n\\n                }\\n            }\\n        }\\n\\n    return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675333,
                "title": "dfs-easy-solution-hai-check-this-out",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<pair<int,int>>movements = { {-1,0},{0,-1},{0,1},{1,0}  } ;\\n     bool IsCycle = false ; \\n\\n      void dfs( int x , int y , int px , int py ,  vector<vector<bool>>&visited ,vector<vector<char>>& grid, int nr , int nc  , char initialchar ){\\n            visited[x][y] = true ;\\n            for( auto movement : movements ) {\\n                int childx = movement.first + x ;\\n                int childy = movement.second + y ;\\n                if( childx >= 0 and childx <= nr-1 and childy >= 0 and childy <= nc-1 and  grid[childx][childy] == initialchar  ){\\n                    // valid cell hai \\n                    if( visited[childx][childy] == true and (childx == px and childy == py)  ) continue ; \\n                    if( visited[childx][childy] == true  ) { IsCycle = true ;  continue ; }\\n                     dfs( childx , childy , x , y , visited , grid , nr , nc , initialchar ) ;\\n                }\\n            }\\n            return ;   \\n      }\\n\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        // you can convert it into adjacency list \\n        int nr = grid.size() ;\\n        int nc = grid[0].size() ;\\n        vector<vector<bool>>visited( nr , vector<bool>(nc , false ) ) ;\\n         bool ans = false ;\\n         \\n         for( int i = 0 ; i < nr ; i++ ){\\n             for( int j = 0 ; j < nc ; j++ ){\\n                 if( visited[i][j] == true ) {continue ;}\\n                 cout << i <<\" \" << j <<\"\\\\n\" ; \\n                 dfs( i , j , -1 , -1 , visited , grid , nr , nc , grid[i][j] ) ;\\n                 if( IsCycle == true ) break ; \\n             }\\n                 if( IsCycle == true ) break ; \\n         }\\n         ans = IsCycle ;\\n         IsCycle = false ;\\n         return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<pair<int,int>>movements = { {-1,0},{0,-1},{0,1},{1,0}  } ;\\n     bool IsCycle = false ; \\n\\n      void dfs( int x , int y , int px , int py ,  vector<vector<bool>>&visited ,vector<vector<char>>& grid, int nr , int nc  , char initialchar ){\\n            visited[x][y] = true ;\\n            for( auto movement : movements ) {\\n                int childx = movement.first + x ;\\n                int childy = movement.second + y ;\\n                if( childx >= 0 and childx <= nr-1 and childy >= 0 and childy <= nc-1 and  grid[childx][childy] == initialchar  ){\\n                    // valid cell hai \\n                    if( visited[childx][childy] == true and (childx == px and childy == py)  ) continue ; \\n                    if( visited[childx][childy] == true  ) { IsCycle = true ;  continue ; }\\n                     dfs( childx , childy , x , y , visited , grid , nr , nc , initialchar ) ;\\n                }\\n            }\\n            return ;   \\n      }\\n\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        // you can convert it into adjacency list \\n        int nr = grid.size() ;\\n        int nc = grid[0].size() ;\\n        vector<vector<bool>>visited( nr , vector<bool>(nc , false ) ) ;\\n         bool ans = false ;\\n         \\n         for( int i = 0 ; i < nr ; i++ ){\\n             for( int j = 0 ; j < nc ; j++ ){\\n                 if( visited[i][j] == true ) {continue ;}\\n                 cout << i <<\" \" << j <<\"\\\\n\" ; \\n                 dfs( i , j , -1 , -1 , visited , grid , nr , nc , grid[i][j] ) ;\\n                 if( IsCycle == true ) break ; \\n             }\\n                 if( IsCycle == true ) break ; \\n         }\\n         ans = IsCycle ;\\n         IsCycle = false ;\\n         return ans ; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3672906,
                "title": "detect-cycles-in-2d-grid-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N+2E)+O(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        int drow[]={+1,0,-1,0};\\n        int dcol[]={0,+1,0,-1};\\n           for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+drow[d];\\n            int b = j+dcol[d];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }\\n};\\n\\n\\n\\n// class Solution {\\n// public:\\n//    vector<int> dir = { 0, 1, 0, -1, 0 }; \\n//     bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n//     {\\n//         visited[i][j] = true;\\n//         for(int d = 0; d < 4; ++d)\\n//         {\\n//             int a = i+dir[d];\\n//             int b = j+dir[d+1];\\n//             if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n//                 if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n//                     return true;\\n//         }\\n//         return false;\\n//     }\\n//     bool containsCycle(vector<vector<char>>& grid) {\\n//         int n = grid.size(), m = grid[0].size();\\n//         vector<vector<bool>> visited(n, vector<bool>(m, false));\\n//         for(int i = 0; i < n; ++i)\\n//             for(int j = 0; j < m; ++j)\\n//                 if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n//                     return true;\\n//         return false;\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        int drow[]={+1,0,-1,0};\\n        int dcol[]={0,+1,0,-1};\\n           for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+drow[d];\\n            int b = j+dcol[d];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }\\n};\\n\\n\\n\\n// class Solution {\\n// public:\\n//    vector<int> dir = { 0, 1, 0, -1, 0 }; \\n//     bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n//     {\\n//         visited[i][j] = true;\\n//         for(int d = 0; d < 4; ++d)\\n//         {\\n//             int a = i+dir[d];\\n//             int b = j+dir[d+1];\\n//             if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n//                 if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n//                     return true;\\n//         }\\n//         return false;\\n//     }\\n//     bool containsCycle(vector<vector<char>>& grid) {\\n//         int n = grid.size(), m = grid[0].size();\\n//         vector<vector<bool>> visited(n, vector<bool>(m, false));\\n//         for(int i = 0; i < n; ++i)\\n//             for(int j = 0; j < m; ++j)\\n//                 if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n//                     return true;\\n//         return false;\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658324,
                "title": "c-dfs-beats-97-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe go across every block and check if there is a cycle starting from there\\nwe keep a vector which stores what all points we have already covered\\nif we have covered a point we dont check for cycle starting from there\\n\\nif not covered we do dfs from there\\nin the dfs we check all options and we also keep track of previous block\\nif a visited block is encountered and its not the previous block then there exists a cycle so we return 1\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n,m;\\n    vector<pair<int,int>>dirn={{0,1},{0,-1},{1,0},{-1,0}};\\n    bool safe(int i,int j)\\n    {\\n        if(i>=0 && j>=0 && j<m && i <n)return 1;\\n        return 0;\\n    }\\n    bool dfs(int i,int j,vector<vector<char>>& grid,vector<vector<bool>>& v,int ii,int jj,int len)\\n    {\\n        v[i][j]=1;   \\n        for(const auto  k:dirn)\\n        {\\n            auto[a,b]=k;\\n            a+=i;\\n            b+=j;\\n            if(safe(a,b) && grid[a][b]==grid[i][j] && (ii!=a || jj!=b))\\n            {\\n                if(!v[a][b])\\n                {if(dfs(a,b,grid,v,i,j,len+1))return 1;} \\n                else if(len>3)return 1;\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) \\n    {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>>v(n,vector<bool>(m,0));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(!v[i][j] && dfs(i,j,grid,v,-1,-1,1))return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int n,m;\\n    vector<pair<int,int>>dirn={{0,1},{0,-1},{1,0},{-1,0}};\\n    bool safe(int i,int j)\\n    {\\n        if(i>=0 && j>=0 && j<m && i <n)return 1;\\n        return 0;\\n    }\\n    bool dfs(int i,int j,vector<vector<char>>& grid,vector<vector<bool>>& v,int ii,int jj,int len)\\n    {\\n        v[i][j]=1;   \\n        for(const auto  k:dirn)\\n        {\\n            auto[a,b]=k;\\n            a+=i;\\n            b+=j;\\n            if(safe(a,b) && grid[a][b]==grid[i][j] && (ii!=a || jj!=b))\\n            {\\n                if(!v[a][b])\\n                {if(dfs(a,b,grid,v,i,j,len+1))return 1;} \\n                else if(len>3)return 1;\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) \\n    {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>>v(n,vector<bool>(m,0));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(!v[i][j] && dfs(i,j,grid,v,-1,-1,1))return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3657692,
                "title": "python-beats-100-simple-beginner-algo",
                "content": "```\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        visited = [[False for _ in range(cols)] for _ in range(rows)]\\n        def is_cycle(orig_value, i, j, prev_i, prev_j):\\n          \\n            if i<0 or j<0 or i>= rows or j>= cols:\\n                return False\\n            if orig_value != grid[i][j]:\\n                return False\\n            if visited[i][j]:\\n                return True\\n            visited[i][j] = True\\n            \\n            if i-1 != prev_i and is_cycle(orig_value, i-1, j, i, j):\\n                return True\\n            if i+1 != prev_i and is_cycle(orig_value, i+1, j, i, j):\\n                return True\\n            if j-1 != prev_j and is_cycle(orig_value, i, j-1, i, j):\\n                return True\\n            if j+1 != prev_j and is_cycle(orig_value, i, j+1, i, j):\\n                return True\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                orig_value = grid[i][j]\\n                if not visited[i][j] and is_cycle(orig_value, i, j,-1,-1):\\n                    return True\\n        return False",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        visited = [[False for _ in range(cols)] for _ in range(rows)]\\n        def is_cycle(orig_value, i, j, prev_i, prev_j):\\n          \\n            if i<0 or j<0 or i>= rows or j>= cols:\\n                return False\\n            if orig_value != grid[i][j]:\\n                return False\\n            if visited[i][j]:\\n                return True\\n            visited[i][j] = True\\n            \\n            if i-1 != prev_i and is_cycle(orig_value, i-1, j, i, j):\\n                return True\\n            if i+1 != prev_i and is_cycle(orig_value, i+1, j, i, j):\\n                return True\\n            if j-1 != prev_j and is_cycle(orig_value, i, j-1, i, j):\\n                return True\\n            if j+1 != prev_j and is_cycle(orig_value, i, j+1, i, j):\\n                return True\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                orig_value = grid[i][j]\\n                if not visited[i][j] and is_cycle(orig_value, i, j,-1,-1):\\n                    return True\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 3653135,
                "title": "simple-bfs-approach-like-detecting-the-cycle-in-graph",
                "content": "# Intuition\\n<!-- Simple bfs solution like detecting the cycle in undirected graph -->\\n\\n# Approach\\n<!-- simple bfs approach -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Tc: in worest case scenario O(2n^2)..-->\\n\\n- Space complexity:\\n<!-- O(n) -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int r;\\n        int c;\\n        Pair(int r, int c)\\n        {\\n            this.r=r;\\n            this.c=c;\\n        }\\n    }\\n    public boolean containsCycle(char[][] grid) {\\n\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        boolean visited[][] = new boolean[n][m];\\n     \\n     int row[]={-1, 0, 1, 0};\\n     int col[]={0, 1, 0, -1};\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n               if(visited[i][j]) continue;\\n\\n               Queue<Pair> q = new LinkedList<>(); \\n                q.add(new Pair(i, j));\\n                char c=grid[i][j];\\n               while(q.size()>0)\\n               {\\n                   Pair rpair = q.remove();\\n                   int r1=rpair.r;\\n                   int c1=rpair.c;\\n                     \\n                   if(visited[r1][c1])\\n                   {\\n                     \\n                     return true;\\n                   }\\n                     \\n                     visited[r1][c1]=true;\\n                   \\n                    for(int k=0; k<4; k++)\\n                    {\\n                        int dr=r1+row[k];\\n                        int dc=c1+col[k];\\n\\n                        if(dr<0||dc<0||dr==n||dc==m||visited[dr][dc]||grid[dr][dc]!=c) continue;\\n                          q.add(new Pair(dr,dc)); \\n                    }\\n               }\\n            }\\n\\n           \\n        }\\n         return false;\\n    }\\n\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int r;\\n        int c;\\n        Pair(int r, int c)\\n        {\\n            this.r=r;\\n            this.c=c;\\n        }\\n    }\\n    public boolean containsCycle(char[][] grid) {\\n\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        boolean visited[][] = new boolean[n][m];\\n     \\n     int row[]={-1, 0, 1, 0};\\n     int col[]={0, 1, 0, -1};\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n               if(visited[i][j]) continue;\\n\\n               Queue<Pair> q = new LinkedList<>(); \\n                q.add(new Pair(i, j));\\n                char c=grid[i][j];\\n               while(q.size()>0)\\n               {\\n                   Pair rpair = q.remove();\\n                   int r1=rpair.r;\\n                   int c1=rpair.c;\\n                     \\n                   if(visited[r1][c1])\\n                   {\\n                     \\n                     return true;\\n                   }\\n                     \\n                     visited[r1][c1]=true;\\n                   \\n                    for(int k=0; k<4; k++)\\n                    {\\n                        int dr=r1+row[k];\\n                        int dc=c1+col[k];\\n\\n                        if(dr<0||dc<0||dr==n||dc==m||visited[dr][dc]||grid[dr][dc]!=c) continue;\\n                          q.add(new Pair(dr,dc)); \\n                    }\\n               }\\n            }\\n\\n           \\n        }\\n         return false;\\n    }\\n\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635435,
                "title": "cpp-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dr[4]={1,0,-1,0};\\nint dc[4]={0,1,0,-1};\\nbool dfs(vector<vector<int>> &vis,int i,int j,int pi,int pj,vector<vector<char>>& grid,char ch){\\n    vis[i][j]=1;\\n    for(int k=0;k<4;k++)\\n    {\\n        int ni=dr[k]+i,nj=dc[k]+j;\\nif(ni>=grid.size() or nj>=grid[0].size() or ni<0 or nj<0 or grid[ni][nj]!=grid[i][j]) continue;\\n    if(!vis[ni][nj]){\\n    if(dfs(vis,ni,nj,i,j,grid,ch)) return true;\\n    } else { if(ni!=pi and nj!=pj)  return true;\\n    }\\n    } \\n    return false;\\n}\\n    bool containsCycle(vector<vector<char>>& grid) {\\n    vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),0));\\n\\n    for(int i=0;i<grid.size();i++){\\n        for(int j=0;j<grid[0].size();j++){\\n            if(!vis[i][j])\\n            {\\n            if(dfs(vis,i,j,-1,-1,grid,grid[i][j])) return true;\\n            }\\n        }\\n    }\\n    return false;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dr[4]={1,0,-1,0};\\nint dc[4]={0,1,0,-1};\\nbool dfs(vector<vector<int>> &vis,int i,int j,int pi,int pj,vector<vector<char>>& grid,char ch){\\n    vis[i][j]=1;\\n    for(int k=0;k<4;k++)\\n    {\\n        int ni=dr[k]+i,nj=dc[k]+j;\\nif(ni>=grid.size() or nj>=grid[0].size() or ni<0 or nj<0 or grid[ni][nj]!=grid[i][j]) continue;\\n    if(!vis[ni][nj]){\\n    if(dfs(vis,ni,nj,i,j,grid,ch)) return true;\\n    } else { if(ni!=pi and nj!=pj)  return true;\\n    }\\n    } \\n    return false;\\n}\\n    bool containsCycle(vector<vector<char>>& grid) {\\n    vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),0));\\n\\n    for(int i=0;i<grid.size();i++){\\n        for(int j=0;j<grid[0].size();j++){\\n            if(!vis[i][j])\\n            {\\n            if(dfs(vis,i,j,-1,-1,grid,grid[i][j])) return true;\\n            }\\n        }\\n    }\\n    return false;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630776,
                "title": "dfs-python-solution-beats-90",
                "content": "# Intuition\\nFrom any unseen location, try 4 directions and skip any new location with different alphabet and also no go back. If we touch a location which has been seen and has the same alphabet, we return True\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        wide = len(grid)\\n        length = len(grid[0])\\n        seen = [[False]*length for _ in range(wide)]\\n        def dfs(x,y,alpha,previous):\\n            if seen[x][y]:\\n                return True\\n            seen[x][y]= True\\n            re = False\\n            direct = [(0,-1),(0,1),(1,0),(-1,0)]\\n            for i,j in direct:\\n                n_x, n_y = x+i, y+j\\n                \\n                if previous and -1*i==previous[0] and -1*j ==previous[1]:\\n                    continue\\n                if n_x<0 or n_x>=wide or n_y<0 or n_y>=length:\\n                    continue\\n                if grid[n_x][n_y]!=alpha:\\n                    continue \\n                if seen[n_x][n_y] and grid[n_x][n_y]==alpha:\\n                \\n                    return True\\n                re = re or dfs(n_x,n_y,alpha,(i,j))\\n                if re:\\n                    return re\\n                seen[n_x][n_y]= True\\n            return re\\n        for i in range(wide):\\n            for j in range(length):\\n                if not seen[i][j]:\\n                    if dfs(i,j,grid[i][j],None):\\n                        return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        wide = len(grid)\\n        length = len(grid[0])\\n        seen = [[False]*length for _ in range(wide)]\\n        def dfs(x,y,alpha,previous):\\n            if seen[x][y]:\\n                return True\\n            seen[x][y]= True\\n            re = False\\n            direct = [(0,-1),(0,1),(1,0),(-1,0)]\\n            for i,j in direct:\\n                n_x, n_y = x+i, y+j\\n                \\n                if previous and -1*i==previous[0] and -1*j ==previous[1]:\\n                    continue\\n                if n_x<0 or n_x>=wide or n_y<0 or n_y>=length:\\n                    continue\\n                if grid[n_x][n_y]!=alpha:\\n                    continue \\n                if seen[n_x][n_y] and grid[n_x][n_y]==alpha:\\n                \\n                    return True\\n                re = re or dfs(n_x,n_y,alpha,(i,j))\\n                if re:\\n                    return re\\n                seen[n_x][n_y]= True\\n            return re\\n        for i in range(wide):\\n            for j in range(length):\\n                if not seen[i][j]:\\n                    if dfs(i,j,grid[i][j],None):\\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616329,
                "title": "python-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def dfs(self, i, j, parent, grid, visited, count):\\n        visited.add((i, j))\\n        prev_row, prev_col = parent[0], parent[1]\\n        dirs = [[0,-1], [-1,0], [1,0], [0,1]]\\n\\n        for d in dirs:\\n            row = i + d[0]\\n            col = j + d[1]\\n\\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] == grid[i][j] and (row,col) != parent:\\n                if (row,col) not in visited:\\n                    if self.dfs(row, col, (i, j), grid, visited, count + 1):\\n                        return True\\n                elif (row,col) in visited and count >= 4:  #Check for parent and cycle detection (Striver)\\n                    return True\\n        return False\\n        \\n\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        visited = set()\\n        count = 0\\n        m,n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if (i, j) not in visited:\\n                    #visited.add((i, j))\\n                    if self.dfs(i, j, (-1,-1), grid, visited, 1):\\n                        return True\\n                    \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n\\n    def dfs(self, i, j, parent, grid, visited, count):\\n        visited.add((i, j))\\n        prev_row, prev_col = parent[0], parent[1]\\n        dirs = [[0,-1], [-1,0], [1,0], [0,1]]\\n\\n        for d in dirs:\\n            row = i + d[0]\\n            col = j + d[1]\\n\\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] == grid[i][j] and (row,col) != parent:\\n                if (row,col) not in visited:\\n                    if self.dfs(row, col, (i, j), grid, visited, count + 1):\\n                        return True\\n                elif (row,col) in visited and count >= 4:  #Check for parent and cycle detection (Striver)\\n                    return True\\n        return False\\n        \\n\\n    def containsCycle(self, grid: List[List[str]]) -> bool:\\n        visited = set()\\n        count = 0\\n        m,n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if (i, j) not in visited:\\n                    #visited.add((i, j))\\n                    if self.dfs(i, j, (-1,-1), grid, visited, 1):\\n                        return True\\n                    \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605399,
                "title": "simple-c-solution-using-dfs-ilanbitan",
                "content": "# Intuition\\nThe problem requires determining whether there exists a cycle in a 2D grid of characters. A cycle is defined as a path starting from a cell and ending at the same cell while traversing neighboring cells that have the same character value. The goal is to check if any such cycle exists in the given grid.\\n\\n# Approach\\nThe approach used to solve the problem is a depth-first search (DFS) algorithm. The main idea is to iterate through each cell of the grid and perform a DFS on unvisited cells to check if a cycle exists starting from that cell.\\n\\nThe ContainsCycle function initializes a boolean array visited to keep track of visited cells. It then iterates over each cell in the grid using two nested loops. If a cell is not visited, it invokes the DFS function to check if a cycle exists starting from that cell. If a cycle is found, the function returns true.\\n\\nThe DFS function performs the depth-first search starting from a given cell (row, col). It first checks if the cell is out of bounds or if it has already been visited. If either of these conditions is true, it returns false (indicating that no cycle is found).\\n\\nNext, the function marks the current cell as visited by setting visited[row, col] to true. It then defines an array of directions to represent the possible neighboring cells: right, down, left, and up.\\n\\nFor each direction, the function calculates the coordinates of the neighboring cell (newRow, newCol). It checks if the neighboring cell is out of bounds, if it is the previous cell (prevRow, prevCol), or if its character value is different from the current cell. If any of these conditions are met, the function continues to the next direction.\\n\\nIf none of the conditions are met, the function recursively invokes DFS on the neighboring cell (newRow, newCol) with the current cell (row, col) as the previous cell. If a cycle is found during the recursive call, the function returns true.\\n\\nIf all the directions have been explored and no cycle is found, the function returns false.\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(m * n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ContainsCycle(char[][] grid) {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        bool[,] visited = new bool[m, n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!visited[i, j]) {\\n                    if (DFS(grid, i, j, -1, -1, visited)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private bool DFS(char[][] grid, int row, int col, int prevRow, int prevCol, bool[,] visited) {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n\\n        if (row < 0 || row >= m || col < 0 || col >= n) {\\n            return false;\\n        }\\n\\n        if (visited[row, col]) {\\n            return true;\\n        }\\n\\n        visited[row, col] = true;\\n\\n        int[][] directions = { new int[] {0, 1}, new int[] {1, 0}, new int[] {0, -1}, new int[] {-1, 0} };\\n\\n        foreach (var direction in directions) {\\n            int newRow = row + direction[0];\\n            int newCol = col + direction[1];\\n\\n            if (newRow < 0 || newRow >= m || newCol < 0 || newCol >= n || (newRow == prevRow && newCol == prevCol) || grid[newRow][newCol] != grid[row][col]) {\\n                continue;\\n            }\\n\\n            if (DFS(grid, newRow, newCol, row, col, visited)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ContainsCycle(char[][] grid) {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        bool[,] visited = new bool[m, n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!visited[i, j]) {\\n                    if (DFS(grid, i, j, -1, -1, visited)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private bool DFS(char[][] grid, int row, int col, int prevRow, int prevCol, bool[,] visited) {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n\\n        if (row < 0 || row >= m || col < 0 || col >= n) {\\n            return false;\\n        }\\n\\n        if (visited[row, col]) {\\n            return true;\\n        }\\n\\n        visited[row, col] = true;\\n\\n        int[][] directions = { new int[] {0, 1}, new int[] {1, 0}, new int[] {0, -1}, new int[] {-1, 0} };\\n\\n        foreach (var direction in directions) {\\n            int newRow = row + direction[0];\\n            int newCol = col + direction[1];\\n\\n            if (newRow < 0 || newRow >= m || newCol < 0 || newCol >= n || (newRow == prevRow && newCol == prevCol) || grid[newRow][newCol] != grid[row][col]) {\\n                continue;\\n            }\\n\\n            if (DFS(grid, newRow, newCol, row, col, visited)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602535,
                "title": "simple-solution-using-bfs-in-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n  O(NxM)\\n- Space complexity:\\n  O(NxM)\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ContainsCycle(char[][] grid) {\\n        bool[,] visited = new bool[grid.Length, grid[0].Length];\\n        for(int i=0;i<grid.Length;i++){\\n            for(int j=0;j<grid[0].Length;j++){\\n                if(visited[i,j]) continue;      \\n                char curr = grid[i][j];\\n                Queue<int[]> q = new Queue<int[]>();\\n                q.Enqueue(new int[]{i,j,-1,-1});\\n                while(q.Count > 0){\\n                    int[] rem = q.Dequeue();\\n                    int row = rem[0];\\n                    int col = rem[1];\\n                    int prow = rem[2];\\n                    int pcol = rem[3];\\n                    \\n                    \\n                    if(visited[row, col]) return true;\\n                    visited[row, col] = true;\\n                    \\n                    //up\\n                    if(row-1 >= 0 && grid[row-1][col] == curr){\\n                        bool isNotValid = (row-1 == prow && col == pcol);\\n                        if(!isNotValid)\\n                            q.Enqueue(new int[]{row-1, col, row, col});\\n                    }\\n                    \\n                    //down\\n                    if(row + 1 < grid.Length && grid[row+1][col] == curr){\\n                       bool isNotValid = (row+1 == prow && col == pcol);\\n                        if(!isNotValid)\\n                            q.Enqueue(new int[]{row+1, col, row, col});\\n                    }\\n                    //left\\n                    if(col - 1 >= 0 && grid[row][col-1] == curr){\\n                       bool isNotValid = (row == prow && col-1 == pcol);\\n                        if(!isNotValid)\\n                            q.Enqueue(new int[]{row, col-1, row, col});\\n                    }\\n                    //right\\n                    if(col + 1 < grid[0].Length && grid[row][col+1] == curr){\\n                      bool isNotValid = (row == prow && col + 1 == pcol);\\n                      if(!isNotValid)\\n                        q.Enqueue(new int[]{row, col+1, row ,col});\\n                    }\\n                        \\n                               \\n                }\\n                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ContainsCycle(char[][] grid) {\\n        bool[,] visited = new bool[grid.Length, grid[0].Length];\\n        for(int i=0;i<grid.Length;i++){\\n            for(int j=0;j<grid[0].Length;j++){\\n                if(visited[i,j]) continue;      \\n                char curr = grid[i][j];\\n                Queue<int[]> q = new Queue<int[]>();\\n                q.Enqueue(new int[]{i,j,-1,-1});\\n                while(q.Count > 0){\\n                    int[] rem = q.Dequeue();\\n                    int row = rem[0];\\n                    int col = rem[1];\\n                    int prow = rem[2];\\n                    int pcol = rem[3];\\n                    \\n                    \\n                    if(visited[row, col]) return true;\\n                    visited[row, col] = true;\\n                    \\n                    //up\\n                    if(row-1 >= 0 && grid[row-1][col] == curr){\\n                        bool isNotValid = (row-1 == prow && col == pcol);\\n                        if(!isNotValid)\\n                            q.Enqueue(new int[]{row-1, col, row, col});\\n                    }\\n                    \\n                    //down\\n                    if(row + 1 < grid.Length && grid[row+1][col] == curr){\\n                       bool isNotValid = (row+1 == prow && col == pcol);\\n                        if(!isNotValid)\\n                            q.Enqueue(new int[]{row+1, col, row, col});\\n                    }\\n                    //left\\n                    if(col - 1 >= 0 && grid[row][col-1] == curr){\\n                       bool isNotValid = (row == prow && col-1 == pcol);\\n                        if(!isNotValid)\\n                            q.Enqueue(new int[]{row, col-1, row, col});\\n                    }\\n                    //right\\n                    if(col + 1 < grid[0].Length && grid[row][col+1] == curr){\\n                      bool isNotValid = (row == prow && col + 1 == pcol);\\n                      if(!isNotValid)\\n                        q.Enqueue(new int[]{row, col+1, row ,col});\\n                    }\\n                        \\n                               \\n                }\\n                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566381,
                "title": "cycle-detection-using-dsu-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass disjointset{\\n    vector<int> parent;\\n    vector<int> rank;\\n    public:\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i] = i;\\n        rank.resize(n+1,0);\\n    }\\n    int findUpar(int node){\\n        if(parent[node] == node)return node;\\n        return parent[node] = findUpar(parent[node]);\\n    }\\n    void make_union(int u,int v){\\n        int ulp_u = findUpar(u);\\n        int ulp_v = findUpar(v);\\n        if(rank[ulp_u] > rank[ulp_v]){\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else{\\n            parent[ulp_u] = ulp_v;\\n            rank[ulp_v]++;\\n        }\\n    }\\n    bool isconnected(int u,int v){\\n        int ulp_u = findUpar(u);\\n        int ulp_v = findUpar(v);\\n        return ulp_u == ulp_v;\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>(n,vector<int>(m,0));\\n        set<pair<int,int>>st;\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        disjointset ds(n*m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                char c = grid[i][j];\\n                for(int k=0;k<4;k++){\\n                    int nrow = i + delrow[k];\\n                    int ncol = j + delcol[k];\\n                    if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                     && grid[nrow][ncol] == grid[i][j]){\\n                    int node1 = i*m + j;\\n                    int node2 = nrow*m + ncol;\\n                    pair<int,int>p1 = {node1,node2};\\n                    pair<int,int> p2 = {node2,node1};\\n                    if(st.count(p1) == 0 && st.count(p2)==0 \\n                     && ds.findUpar(node1) == ds.findUpar(node2)){\\n                        return true;\\n                     }\\n                     else{\\n                         ds.make_union(node1,node2);\\n                         st.insert(p1);\\n                         st.insert(p2);\\n                     }\\n                }\\n            }\\n        }           \\n        }\\n        return false;      \\n    }\\n\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass disjointset{\\n    vector<int> parent;\\n    vector<int> rank;\\n    public:\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i] = i;\\n        rank.resize(n+1,0);\\n    }\\n    int findUpar(int node){\\n        if(parent[node] == node)return node;\\n        return parent[node] = findUpar(parent[node]);\\n    }\\n    void make_union(int u,int v){\\n        int ulp_u = findUpar(u);\\n        int ulp_v = findUpar(v);\\n        if(rank[ulp_u] > rank[ulp_v]){\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else{\\n            parent[ulp_u] = ulp_v;\\n            rank[ulp_v]++;\\n        }\\n    }\\n    bool isconnected(int u,int v){\\n        int ulp_u = findUpar(u);\\n        int ulp_v = findUpar(v);\\n        return ulp_u == ulp_v;\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool containsCycle(vector<vector<char>>& grid) {\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>(n,vector<int>(m,0));\\n        set<pair<int,int>>st;\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        disjointset ds(n*m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                char c = grid[i][j];\\n                for(int k=0;k<4;k++){\\n                    int nrow = i + delrow[k];\\n                    int ncol = j + delcol[k];\\n                    if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                     && grid[nrow][ncol] == grid[i][j]){\\n                    int node1 = i*m + j;\\n                    int node2 = nrow*m + ncol;\\n                    pair<int,int>p1 = {node1,node2};\\n                    pair<int,int> p2 = {node2,node1};\\n                    if(st.count(p1) == 0 && st.count(p2)==0 \\n                     && ds.findUpar(node1) == ds.findUpar(node2)){\\n                        return true;\\n                     }\\n                     else{\\n                         ds.make_union(node1,node2);\\n                         st.insert(p1);\\n                         st.insert(p2);\\n                     }\\n                }\\n            }\\n        }           \\n        }\\n        return false;      \\n    }\\n\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557611,
                "title": "detect-cycles-in-2d-grid-easy-approach-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>drom = {0,-1,0,1};\\n    vector<int>dcol = {-1,0,1,0};\\n    bool detect(int i, int j,vector<vector<int>>&vis, vector<vector<char>>&grid, int x, int y )\\n    {\\n        vis[i][j] = 1;\\n        for(int l = 0; l<4; l++)\\n        {\\n            long long int a = i+drom[l];\\n            long long int b = j+dcol[l];\\n            if(a>=0 and a<grid.size() and b>=0 and b<grid[0].size() and grid[a][b] == grid[i][j] and !(x == a and y == b))\\n            {\\n                if(vis[a][b] or detect(a,b,vis,grid,i,j))return true;\\n            }\\n        }\\n            \\n        return false;\\n\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    if(detect(i,j,vis,grid, -1, -1)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>drom = {0,-1,0,1};\\n    vector<int>dcol = {-1,0,1,0};\\n    bool detect(int i, int j,vector<vector<int>>&vis, vector<vector<char>>&grid, int x, int y )\\n    {\\n        vis[i][j] = 1;\\n        for(int l = 0; l<4; l++)\\n        {\\n            long long int a = i+drom[l];\\n            long long int b = j+dcol[l];\\n            if(a>=0 and a<grid.size() and b>=0 and b<grid[0].size() and grid[a][b] == grid[i][j] and !(x == a and y == b))\\n            {\\n                if(vis[a][b] or detect(a,b,vis,grid,i,j))return true;\\n            }\\n        }\\n            \\n        return false;\\n\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    if(detect(i,j,vis,grid, -1, -1)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545938,
                "title": "simple-readable-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    boolean[][] seen = new boolean[501][501];\\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        for(int row = 0; row < m; row++){\\n            for(int col = 0; col < n; col++){\\n                if(!seen[row][col] && containsCycle(grid, row, col, grid[row][col], row, col)){\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean containsCycle(char[][] grid, int startRow, int startCol, char search,\\n     int row, int col){\\n        int m = grid.length, n = grid[0].length;\\n        \\n        if(row >= m || col >= n || row < 0 || col < 0 || grid[row][col] != search)\\n            return false;\\n\\n        if(seen[row][col]) return seen[row][col];  \\n        \\n        seen[row][col] = true;\\n\\n        char temp = grid[row][col];  \\n        grid[row][col] = \\'*\\';\\n        boolean result =  containsCycle(grid, startRow, startCol, search, row, col + 1) \\n            || containsCycle(grid, startRow, startCol, search, row, col - 1)\\n            || containsCycle(grid, startRow, startCol, search, row + 1, col)\\n            || containsCycle(grid, startRow, startCol, search, row - 1, col);\\n        grid[row][col] = temp;\\n        return result;\\n    }\\n}\\n\\n/**\\n\\n[\\n    [\"c\",\"a\",\"d\"],\\n    [\"a\",\"a\",\"a\"],\\n    [\"a\",\"a\",\"d\"],\\n    [\"a\",\"c\",\"d\"],\\n    [\"a\",\"b\",\"c\"]\\n]\\n\\n\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    boolean[][] seen = new boolean[501][501];\\n    public boolean containsCycle(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        for(int row = 0; row < m; row++){\\n            for(int col = 0; col < n; col++){\\n                if(!seen[row][col] && containsCycle(grid, row, col, grid[row][col], row, col)){\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean containsCycle(char[][] grid, int startRow, int startCol, char search,\\n     int row, int col){\\n        int m = grid.length, n = grid[0].length;\\n        \\n        if(row >= m || col >= n || row < 0 || col < 0 || grid[row][col] != search)\\n            return false;\\n\\n        if(seen[row][col]) return seen[row][col];  \\n        \\n        seen[row][col] = true;\\n\\n        char temp = grid[row][col];  \\n        grid[row][col] = \\'*\\';\\n        boolean result =  containsCycle(grid, startRow, startCol, search, row, col + 1) \\n            || containsCycle(grid, startRow, startCol, search, row, col - 1)\\n            || containsCycle(grid, startRow, startCol, search, row + 1, col)\\n            || containsCycle(grid, startRow, startCol, search, row - 1, col);\\n        grid[row][col] = temp;\\n        return result;\\n    }\\n}\\n\\n/**\\n\\n[\\n    [\"c\",\"a\",\"d\"],\\n    [\"a\",\"a\",\"a\"],\\n    [\"a\",\"a\",\"d\"],\\n    [\"a\",\"c\",\"d\"],\\n    [\"a\",\"b\",\"c\"]\\n]\\n\\n\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517794,
                "title": "java-bfs-beats-99-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSafe(int r, int c, int rows, int cols) {\\n        return r>=0 && r<rows && c>=0 && c<cols;\\n    }\\n    public boolean containsCycle(char[][] grid) {\\n        int rows=grid.length,cols=grid[0].length;\\n        int[][] dirs={{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int i=0;i<rows;i++) {\\n            for(int j=0;j<cols;j++) {\\n                if(grid[i][j]>=\\'a\\') {\\n                    Queue<int[]> qu=new LinkedList<>();\\n                    qu.add(new int[] {i,j});\\n                    char ch=grid[i][j];\\n                    while(!qu.isEmpty()) {\\n                        int[] rc=qu.poll();\\n                        int r=rc[0],c=rc[1];\\n                        if(grid[r][c]<\\'a\\') {\\n                            return true;\\n                        }\\n                        grid[r][c]-=26;\\n                        for(int[] dir:dirs) {\\n                            int r1=r+dir[0],c1=c+dir[1];\\n                            if(isSafe(r1,c1,rows,cols) && grid[r1][c1]==ch) {\\n                                qu.add(new int[] {r1,c1});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSafe(int r, int c, int rows, int cols) {\\n        return r>=0 && r<rows && c>=0 && c<cols;\\n    }\\n    public boolean containsCycle(char[][] grid) {\\n        int rows=grid.length,cols=grid[0].length;\\n        int[][] dirs={{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int i=0;i<rows;i++) {\\n            for(int j=0;j<cols;j++) {\\n                if(grid[i][j]>=\\'a\\') {\\n                    Queue<int[]> qu=new LinkedList<>();\\n                    qu.add(new int[] {i,j});\\n                    char ch=grid[i][j];\\n                    while(!qu.isEmpty()) {\\n                        int[] rc=qu.poll();\\n                        int r=rc[0],c=rc[1];\\n                        if(grid[r][c]<\\'a\\') {\\n                            return true;\\n                        }\\n                        grid[r][c]-=26;\\n                        for(int[] dir:dirs) {\\n                            int r1=r+dir[0],c1=c+dir[1];\\n                            if(isSafe(r1,c1,rows,cols) && grid[r1][c1]==ch) {\\n                                qu.add(new int[] {r1,c1});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517745,
                "title": "c-bfs-easy-to-understand-straight-forward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSafe(int r, int c, int rows, int cols) {\\n        return r>=0 && r<rows && c>=0 && c<cols;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int rows=grid.size(),cols=grid[0].size();\\n        vector<vector<int>> dirs={{0,1},{0,-1},{1,0},{-1,0}};\\n        for(int i=0;i<rows;i++) {\\n            for(int j=0;j<cols;j++) {\\n                if(grid[i][j]>=\\'a\\') {\\n                    queue<pair<int,int>> qu;\\n                    qu.push({i,j});\\n                    char ch=grid[i][j];\\n                    while(!qu.empty()) {\\n                        int qs=qu.size();\\n                        while(qs--) {\\n                            int r=qu.front().first,c=qu.front().second;\\n                            if(grid[r][c]<\\'a\\') {\\n                                return true;\\n                            }\\n                            grid[r][c]-=26;\\n                            qu.pop();\\n                            for(auto dir:dirs) {\\n                                int r1=r+dir[0],c1=c+dir[1];\\n                                if(isSafe(r1,c1,rows,cols) && grid[r1][c1]==ch) {\\n                                    qu.push({r1,c1});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int r, int c, int rows, int cols) {\\n        return r>=0 && r<rows && c>=0 && c<cols;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int rows=grid.size(),cols=grid[0].size();\\n        vector<vector<int>> dirs={{0,1},{0,-1},{1,0},{-1,0}};\\n        for(int i=0;i<rows;i++) {\\n            for(int j=0;j<cols;j++) {\\n                if(grid[i][j]>=\\'a\\') {\\n                    queue<pair<int,int>> qu;\\n                    qu.push({i,j});\\n                    char ch=grid[i][j];\\n                    while(!qu.empty()) {\\n                        int qs=qu.size();\\n                        while(qs--) {\\n                            int r=qu.front().first,c=qu.front().second;\\n                            if(grid[r][c]<\\'a\\') {\\n                                return true;\\n                            }\\n                            grid[r][c]-=26;\\n                            qu.pop();\\n                            for(auto dir:dirs) {\\n                                int r1=r+dir[0],c1=c+dir[1];\\n                                if(isSafe(r1,c1,rows,cols) && grid[r1][c1]==ch) {\\n                                    qu.push({r1,c1});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568430,
                "content": [
                    {
                        "username": "SleepyFarmer",
                        "content": "I suppose it might be if the min path length > 4"
                    },
                    {
                        "username": "Dhruvee",
                        "content": "but , then it will include min \"straight\" path of length > 4 as well "
                    },
                    {
                        "username": "Lewis0511",
                        "content": "In BFS, keep the distance of the current cell from the source. If there exists a cycle, you will encounter the same cell twice with a same distance. "
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "WIll DP work in this question"
                    },
                    {
                        "username": "chrisperezlebron",
                        "content": "The question should clarify if you can return to a position you\\'ve previously visited (Other than the position just before the current) because that changes the architecture of the solution pretty drastically. "
                    }
                ]
            },
            {
                "id": 1897912,
                "content": [
                    {
                        "username": "SleepyFarmer",
                        "content": "I suppose it might be if the min path length > 4"
                    },
                    {
                        "username": "Dhruvee",
                        "content": "but , then it will include min \"straight\" path of length > 4 as well "
                    },
                    {
                        "username": "Lewis0511",
                        "content": "In BFS, keep the distance of the current cell from the source. If there exists a cycle, you will encounter the same cell twice with a same distance. "
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "WIll DP work in this question"
                    },
                    {
                        "username": "chrisperezlebron",
                        "content": "The question should clarify if you can return to a position you\\'ve previously visited (Other than the position just before the current) because that changes the architecture of the solution pretty drastically. "
                    }
                ]
            },
            {
                "id": 1848142,
                "content": [
                    {
                        "username": "SleepyFarmer",
                        "content": "I suppose it might be if the min path length > 4"
                    },
                    {
                        "username": "Dhruvee",
                        "content": "but , then it will include min \"straight\" path of length > 4 as well "
                    },
                    {
                        "username": "Lewis0511",
                        "content": "In BFS, keep the distance of the current cell from the source. If there exists a cycle, you will encounter the same cell twice with a same distance. "
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "WIll DP work in this question"
                    },
                    {
                        "username": "chrisperezlebron",
                        "content": "The question should clarify if you can return to a position you\\'ve previously visited (Other than the position just before the current) because that changes the architecture of the solution pretty drastically. "
                    }
                ]
            },
            {
                "id": 1837760,
                "content": [
                    {
                        "username": "SleepyFarmer",
                        "content": "I suppose it might be if the min path length > 4"
                    },
                    {
                        "username": "Dhruvee",
                        "content": "but , then it will include min \"straight\" path of length > 4 as well "
                    },
                    {
                        "username": "Lewis0511",
                        "content": "In BFS, keep the distance of the current cell from the source. If there exists a cycle, you will encounter the same cell twice with a same distance. "
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "WIll DP work in this question"
                    },
                    {
                        "username": "chrisperezlebron",
                        "content": "The question should clarify if you can return to a position you\\'ve previously visited (Other than the position just before the current) because that changes the architecture of the solution pretty drastically. "
                    }
                ]
            }
        ]
    }
]