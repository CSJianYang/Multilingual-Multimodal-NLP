[
    {
        "title": "K Highest Ranked Items Within a Price Range",
        "question_content": "You are given a 0-indexed 2D integer array grid of size m x n that represents a map of the items in a shop. The integers in the grid represent the following:\n\n\t0 represents a wall that you cannot pass through.\n\t1 represents an empty cell that you can freely move to and from.\n\tAll other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.\n\nIt takes 1 step to travel between adjacent grid cells.\nYou are also given integer arrays pricing and start where pricing = [low, high] and start = [row, col] indicates that you start at the position (row, col) and are interested only in items with a price in the range of [low, high] (inclusive). You are further given an integer k.\nYou are interested in the positions of the k highest-ranked items whose prices are within the given price range. The rank is determined by the first of these criteria that is different:\n\n\tDistance, defined as the length of the shortest path from the start (shorter distance has a higher rank).\n\tPrice (lower price has a higher rank, but it must be in the price range).\n\tThe row number (smaller row number has a higher rank).\n\tThe column number (smaller column number has a higher rank).\n\nReturn the k highest-ranked items within the price range sorted by their rank (highest to lowest). If there are fewer than k reachable items within the price range, return all of them.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3\nOutput: [[0,1],[1,1],[2,1]]\nExplanation: You start at (0,0).\nWith a price range of [2,5], we can take items from (0,1), (1,1), (2,1) and (2,2).\nThe ranks of these items are:\n- (0,1) with distance 1\n- (1,1) with distance 2\n- (2,1) with distance 3\n- (2,2) with distance 4\nThus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1).\n\nExample 2:\n\nInput: grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2\nOutput: [[2,1],[1,2]]\nExplanation: You start at (2,3).\nWith a price range of [2,3], we can take items from (0,1), (1,1), (1,2) and (2,1).\nThe ranks of these items are:\n- (2,1) with distance 2, price 2\n- (1,2) with distance 2, price 3\n- (1,1) with distance 3\n- (0,1) with distance 4\nThus, the 2 highest ranked items in the price range are (2,1) and (1,2).\n\nExample 3:\n\nInput: grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3\nOutput: [[2,1],[2,0]]\nExplanation: You start at (0,0).\nWith a price range of [2,3], we can take items from (2,0) and (2,1). \nThe ranks of these items are: \n- (2,1) with distance 5\n- (2,0) with distance 6\nThus, the 2 highest ranked items in the price range are (2,1) and (2,0). \nNote that k = 3 but there are only 2 reachable items within the price range.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 105\n\t1 <= m * n <= 105\n\t0 <= grid[i][j] <= 105\n\tpricing.length == 2\n\t2 <= low <= high <= 105\n\tstart.length == 2\n\t0 <= row <= m - 1\n\t0 <= col <= n - 1\n\tgrid[row][col] > 0\n\t1 <= k <= m * n",
        "solutions": [
            {
                "id": 1709671,
                "title": "python-classical-bfs-solution-explained",
                "content": "Nothing very difficult here, all you need is to perform bfs accurately. Also notice, that you can have elements with value `0`, so when we have `0`, do not travere it (a bit countreintuitive for me and I spend some time trying to catch an error). In the end sort our answer: that is only elements with good price and return first `k` of them.\\n\\n#### Complexity\\nIt is `O(nm log(mn)` for time and `O(mn)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def highestRankedKItems(self, G, pricing, start, k):\\n        m, n = len(G), len(G[0])\\n        row, col = start\\n        node = (0, G[row][col], row, col)\\n        visited = set()\\n        visited.add((row, col))\\n        d = deque([node])\\n        ans = []\\n        \\n        while d:\\n            dist, cost, row, col = d.popleft()\\n            if pricing[0] <= cost <= pricing[1]:\\n                ans += [(dist, cost, row, col)]\\n            \\n            for x, y in (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1):\\n                if 0 <= x <= m-1 and 0 <= y <= n-1 and (x, y) not in visited and G[x][y] != 0:\\n                    d.append((dist + 1, G[x][y], x, y))\\n                    visited.add((x, y))\\n        \\n        ans = sorted(ans)\\n        \\n        return [[x, y] for _, _, x, y in ans[:k]]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def highestRankedKItems(self, G, pricing, start, k):\\n        m, n = len(G), len(G[0])\\n        row, col = start\\n        node = (0, G[row][col], row, col)\\n        visited = set()\\n        visited.add((row, col))\\n        d = deque([node])\\n        ans = []\\n        \\n        while d:\\n            dist, cost, row, col = d.popleft()\\n            if pricing[0] <= cost <= pricing[1]:\\n                ans += [(dist, cost, row, col)]\\n            \\n            for x, y in (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1):\\n                if 0 <= x <= m-1 and 0 <= y <= n-1 and (x, y) not in visited and G[x][y] != 0:\\n                    d.append((dist + 1, G[x][y], x, y))\\n                    visited.add((x, y))\\n        \\n        ans = sorted(ans)\\n        \\n        return [[x, y] for _, _, x, y in ans[:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709722,
                "title": "python-explanation-with-pictures-bfs",
                "content": "Use BFS on the matrix. Start from the starting cell. \\n\\n![image](https://assets.leetcode.com/users/images/7a4340da-392f-4565-a0ae-e2d4270eac9c_1642867324.5064807.png)\\n\\nFind the valid neighbors of the current cell, and let their distance to starting cell increment by 1. (From 0 to 1 in the picture below)\\n\\n![image](https://assets.leetcode.com/users/images/5568363a-1e41-434e-8987-05fd2a9c5f3a_1642867329.3827238.png)\\n\\nThen find the valid **unvisited** neighbors of the cells of distance 1.\\n\\n![image](https://assets.leetcode.com/users/images/00588e17-f338-48eb-8d59-a256fcda9923_1642867333.3151906.png)\\n\\n Notice that we have to find the valid neighbors, these bold arrows indicate **invalid** neighbors:\\n\\n- out of the boundary.\\n- run into a wall.\\n- a neigbor that has been visited before. \\n\\n![image](https://assets.leetcode.com/users/images/b8240953-59ba-4136-aa52-40e4eb94b683_1642867336.9174762.png)\\n\\nAll visited cells after the BFS.\\n\\n![image](https://assets.leetcode.com/users/images/88f7eb1b-0b76-470f-85af-6642048dc46d_1642867340.2224655.png)\\n\\nThen sort all the **valid** neighbors by these four factors, return the first **k** of them.\\n\\n**Python**\\n\\n```\\ndef highestRankedKItems(self, A: List[List[int]], price: List[int], start: List[int], k: int) -> List[List[int]]:\\n        ans = []\\n\\t\\t\\n\\t\\t# Deque dq for BFS, hashtable seen for visited cells. \\n        dq = collections.deque([(start[0], start[1], 0)])\\n        seen = set([(start[0], start[1])])\\n        \\n        dirs = ((1, 0), (0, 1), (-1, 0), (0, -1))\\n        m, n = len(A), len(A[0])\\n\\n        while dq:\\n\\t\\t\\n\\t\\t\\t# Current visited cell\\n            cx, cy, dist = dq.popleft()\\n\\t\\t\\t\\n\\t\\t\\t# If the value of the current cell is within the range, add it to the candidate list with four factors. \\n            if price[0] <= A[cx][cy] <= price[1]:\\n                ans.append([dist, A[cx][cy], cx, cy])\\n\\t\\t\\t\\t\\n\\t\\t\\t# Find the 4-directional connected neighbors of the current cell.\\n            for dx, dy in dirs:\\n                nx, ny = cx + dx, cy + dy\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# If the neighbor is valid:\\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in seen and A[nx][ny] > 0:\\n                    seen.add((nx, ny))\\n                    dq.append((nx, ny, dist + 1))\\n        \\n\\t\\t# Sort all the candidates by the four factors.\\n        ans.sort()\\n        \\n\\t\\t# Return the first k of them.\\n        return [x[2:] for x in ans[:k]]\\n```",
                "solutionTags": [],
                "code": "```\\ndef highestRankedKItems(self, A: List[List[int]], price: List[int], start: List[int], k: int) -> List[List[int]]:\\n        ans = []\\n\\t\\t\\n\\t\\t# Deque dq for BFS, hashtable seen for visited cells. \\n        dq = collections.deque([(start[0], start[1], 0)])\\n        seen = set([(start[0], start[1])])\\n        \\n        dirs = ((1, 0), (0, 1), (-1, 0), (0, -1))\\n        m, n = len(A), len(A[0])\\n\\n        while dq:\\n\\t\\t\\n\\t\\t\\t# Current visited cell\\n            cx, cy, dist = dq.popleft()\\n\\t\\t\\t\\n\\t\\t\\t# If the value of the current cell is within the range, add it to the candidate list with four factors. \\n            if price[0] <= A[cx][cy] <= price[1]:\\n                ans.append([dist, A[cx][cy], cx, cy])\\n\\t\\t\\t\\t\\n\\t\\t\\t# Find the 4-directional connected neighbors of the current cell.\\n            for dx, dy in dirs:\\n                nx, ny = cx + dx, cy + dy\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# If the neighbor is valid:\\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in seen and A[nx][ny] > 0:\\n                    seen.add((nx, ny))\\n                    dq.append((nx, ny, dist + 1))\\n        \\n\\t\\t# Sort all the candidates by the four factors.\\n        ans.sort()\\n        \\n\\t\\t# Return the first k of them.\\n        return [x[2:] for x in ans[:k]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1709654,
                "title": "with-explanation-bfs-c",
                "content": "**Explanation:-**\\n1. Start BFS from ```start```.\\n2. Whenever you reach ```cell``` with value other than ```0``` and ```1``` value,then insert ```{dist,price,row,col}``` into a\\n       ```array``` or ```min-heap``` whatever you want.\\n\\n **I have used vector but you can use min-heap also and can do early termination if you reach k value**\\n\\n\\t \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& price, vector<int>& start, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>ans,res;\\n        // visited array\\n        vector<vector<bool>>seen(m,vector<bool>(n,false));\\n        // queue for BFS\\n        queue<pair<int,int>>q;\\n        q.push({start[0],start[1]});\\n        //directions\\n        vector<vector<int>>dirs={{-1,0},{0,-1},{0,1},{1,0}};\\n        // distance\\n        int dist=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto p=q.front();\\n                    q.pop();\\n                // already visited cell\\n                if(seen[p.first][p.second])\\n                    continue;\\n                // found wall\\n                if(grid[p.first][p.second]==0)\\n                    continue;\\n                // make the cell visited ,if visiting first time\\n                seen[p.first][p.second]=true;\\n                // if the value is 1 then it is empty cell so first check it\\n                if(grid[p.first][p.second]!=1){\\n                    int val=grid[p.first][p.second];\\n                    // cell value should be in the range of price,if yes then push it to array or min-heap\\n                    if(val>=price[0] && val<=price[1])\\n                       res.push_back({dist,val,p.first,p.second});\\n                }\\n                // check other cells which you can reach from current cell\\n                for(auto & dir:dirs){\\n                    int row=p.first+dir[0],col=dir[1]+p.second;\\n                    if(row>=0 && row<m && col>=0 && col<n)\\n                        q.push({row,col});\\n                }      \\n            }\\n            dist++;\\n        }\\n        // sort the array, if you have used min-heap,then obviously there is no need\\n        sort(res.begin(),res.end());\\n        // first k values or whole vector,whatever is minimum\\n        for(int i=0;i<min(int(k),int(res.size()));i++)\\n            ans.push_back({res[i][2],res[i][3]});\\n        return ans;\\n        \\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)\\t   \\n\\t",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```start```\n```cell```\n```0```\n```1```\n```{dist,price,row,col}```\n```array```\n```min-heap```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& price, vector<int>& start, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>ans,res;\\n        // visited array\\n        vector<vector<bool>>seen(m,vector<bool>(n,false));\\n        // queue for BFS\\n        queue<pair<int,int>>q;\\n        q.push({start[0],start[1]});\\n        //directions\\n        vector<vector<int>>dirs={{-1,0},{0,-1},{0,1},{1,0}};\\n        // distance\\n        int dist=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto p=q.front();\\n                    q.pop();\\n                // already visited cell\\n                if(seen[p.first][p.second])\\n                    continue;\\n                // found wall\\n                if(grid[p.first][p.second]==0)\\n                    continue;\\n                // make the cell visited ,if visiting first time\\n                seen[p.first][p.second]=true;\\n                // if the value is 1 then it is empty cell so first check it\\n                if(grid[p.first][p.second]!=1){\\n                    int val=grid[p.first][p.second];\\n                    // cell value should be in the range of price,if yes then push it to array or min-heap\\n                    if(val>=price[0] && val<=price[1])\\n                       res.push_back({dist,val,p.first,p.second});\\n                }\\n                // check other cells which you can reach from current cell\\n                for(auto & dir:dirs){\\n                    int row=p.first+dir[0],col=dir[1]+p.second;\\n                    if(row>=0 && row<m && col>=0 && col<n)\\n                        q.push({row,col});\\n                }      \\n            }\\n            dist++;\\n        }\\n        // sort the array, if you have used min-heap,then obviously there is no need\\n        sort(res.begin(),res.end());\\n        // first k values or whole vector,whatever is minimum\\n        for(int i=0;i<min(int(k),int(res.size()));i++)\\n            ans.push_back({res[i][2],res[i][3]});\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710065,
                "title": "java-python-3-bfs-using-priorityqueue-heap-w-brief-explanation-and-analysis",
                "content": "**Q & A**\\n\\nQ1: Why do you have `ans.size() < k` in the `while` condition?\\nA1: The `PriorityQueue/heap` is sorted according to the rank specified in the problem. Therefore, the `ans` always holds highest ranked items within the given price range, and once it reaches the size of `k`, the loop does NOT need to iterate any more.\\n\\n**End of Q & A**\\n\\n----\\n\\nUse a `PriorityQueue/heap` to store (distance, price, row, col) and a HashSet to prune duplicates.\\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int R = grid.length, C = grid[0].length;\\n        int x = start[0], y = start[1], low = pricing[0], high = pricing[1];\\n        Set<String> seen = new HashSet<>(); // Set used to prune duplicates.\\n        seen.add(x + \",\" + y);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        // PriorityQueue sorted by (distance, price, row, col).\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] == b[1] ? a[2] == b[2] ? a[3] - b[3] : a[2] - b[2] : a[1] - b[1] : a[0] - b[0]);\\n        pq.offer(new int[]{0, grid[x][y], x, y}); // BFS starting point.\\n        while (!pq.isEmpty() && ans.size() < k) {\\n            int[] cur = pq.poll();\\n            int distance = cur[0], price = cur[1], r = cur[2], c = cur[3]; // distance, price, row & column.\\n            if (low <= price && price <= high) { // price in range?\\n                ans.add(Arrays.asList(r, c));\\n            }\\n            for (int m = 0; m < 4; ++m) { // traverse 4 neighbors.\\n                int i = r + d[m], j = c + d[m + 1];\\n                // in boundary, not wall, and not visited yet?\\n                if (0 <= i && i < R && 0 <= j && j < C && grid[i][j] > 0 && seen.add(i + \",\" + j)) {\\n                    pq.offer(new int[]{distance + 1, grid[i][j], i, j});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        R, C = map(len, (grid, grid[0]))\\n        ans, (x, y), (low, high) = [], start, pricing\\n        heap = [(0, grid[x][y], x, y)]\\n        seen = {(x, y)}\\n        while heap and len(ans) < k:\\n            distance, price, r, c = heapq.heappop(heap)\\n            if low <= price <= high:\\n                ans.append([r, c])\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if R > i >= 0 <= j < C and grid[i][j] > 0 and (i, j) not in seen: \\n                    seen.add((i, j))\\n                    heapq.heappush(heap, (distance + 1, grid[i][j], i, j))\\n        return ans\\n```\\n\\nIn case you prefer negating the `grid` values to using HashSet, please refer to the following codes.\\nOf course, the input is modified.\\n\\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int R = grid.length, C = grid[0].length;\\n        int x = start[0], y = start[1], low = pricing[0], high = pricing[1];\\n        List<List<Integer>> ans = new ArrayList<>();\\n        // PriorityQueue sorted by (distance, price, row, col).\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] == b[1] ? a[2] == b[2] ? a[3] - b[3] : a[2] - b[2] : a[1] - b[1] : a[0] - b[0]);\\n        pq.offer(new int[]{0, grid[x][y], x, y}); // BFS starting point.\\n        grid[x][y] *= -1;\\n        while (!pq.isEmpty() && ans.size() < k) {\\n            int[] cur = pq.poll();\\n            int distance = cur[0], price = cur[1], r = cur[2], c = cur[3]; // distance, price, row & column.\\n            if (low <= price && price <= high) { // price in range?\\n                ans.add(Arrays.asList(r, c));\\n            }\\n            for (int m = 0; m < 4; ++m) { // traverse 4 neighbors.\\n                int i = r + d[m], j = c + d[m + 1];\\n                // in boundary, not wall, and not visited yet?\\n                if (0 <= i && i < R && 0 <= j && j < C && grid[i][j] > 0) {\\n                    pq.offer(new int[]{distance + 1, grid[i][j], i, j});\\n                    grid[i][j] *= -1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        R, C = map(len, (grid, grid[0]))\\n        ans, (x, y), (low, high) = [], start, pricing\\n        heap = [(0, grid[x][y], x, y)]\\n        grid[x][y] *= -1\\n        while heap and len(ans) < k:\\n            distance, price, r, c = heapq.heappop(heap)\\n            if low <= price <= high:\\n                ans.append([r, c])\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if R > i >= 0 <= j < C and grid[i][j] > 0: \\n                    heapq.heappush(heap, (distance + 1, grid[i][j], i, j))\\n                    grid[i][j] *= -1\\n        return ans\\n```\\n**Analysis:**\\n\\nTime: `O(R * C * log(R * C))`, space: `O(R * C)`, where `R = grid.length, C = grid[0].length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int R = grid.length, C = grid[0].length;\\n        int x = start[0], y = start[1], low = pricing[0], high = pricing[1];\\n        Set<String> seen = new HashSet<>(); // Set used to prune duplicates.\\n        seen.add(x + \",\" + y);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        // PriorityQueue sorted by (distance, price, row, col).\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] == b[1] ? a[2] == b[2] ? a[3] - b[3] : a[2] - b[2] : a[1] - b[1] : a[0] - b[0]);\\n        pq.offer(new int[]{0, grid[x][y], x, y}); // BFS starting point.\\n        while (!pq.isEmpty() && ans.size() < k) {\\n            int[] cur = pq.poll();\\n            int distance = cur[0], price = cur[1], r = cur[2], c = cur[3]; // distance, price, row & column.\\n            if (low <= price && price <= high) { // price in range?\\n                ans.add(Arrays.asList(r, c));\\n            }\\n            for (int m = 0; m < 4; ++m) { // traverse 4 neighbors.\\n                int i = r + d[m], j = c + d[m + 1];\\n                // in boundary, not wall, and not visited yet?\\n                if (0 <= i && i < R && 0 <= j && j < C && grid[i][j] > 0 && seen.add(i + \",\" + j)) {\\n                    pq.offer(new int[]{distance + 1, grid[i][j], i, j});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        R, C = map(len, (grid, grid[0]))\\n        ans, (x, y), (low, high) = [], start, pricing\\n        heap = [(0, grid[x][y], x, y)]\\n        seen = {(x, y)}\\n        while heap and len(ans) < k:\\n            distance, price, r, c = heapq.heappop(heap)\\n            if low <= price <= high:\\n                ans.append([r, c])\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if R > i >= 0 <= j < C and grid[i][j] > 0 and (i, j) not in seen: \\n                    seen.add((i, j))\\n                    heapq.heappush(heap, (distance + 1, grid[i][j], i, j))\\n        return ans\\n```\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int R = grid.length, C = grid[0].length;\\n        int x = start[0], y = start[1], low = pricing[0], high = pricing[1];\\n        List<List<Integer>> ans = new ArrayList<>();\\n        // PriorityQueue sorted by (distance, price, row, col).\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] == b[1] ? a[2] == b[2] ? a[3] - b[3] : a[2] - b[2] : a[1] - b[1] : a[0] - b[0]);\\n        pq.offer(new int[]{0, grid[x][y], x, y}); // BFS starting point.\\n        grid[x][y] *= -1;\\n        while (!pq.isEmpty() && ans.size() < k) {\\n            int[] cur = pq.poll();\\n            int distance = cur[0], price = cur[1], r = cur[2], c = cur[3]; // distance, price, row & column.\\n            if (low <= price && price <= high) { // price in range?\\n                ans.add(Arrays.asList(r, c));\\n            }\\n            for (int m = 0; m < 4; ++m) { // traverse 4 neighbors.\\n                int i = r + d[m], j = c + d[m + 1];\\n                // in boundary, not wall, and not visited yet?\\n                if (0 <= i && i < R && 0 <= j && j < C && grid[i][j] > 0) {\\n                    pq.offer(new int[]{distance + 1, grid[i][j], i, j});\\n                    grid[i][j] *= -1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        R, C = map(len, (grid, grid[0]))\\n        ans, (x, y), (low, high) = [], start, pricing\\n        heap = [(0, grid[x][y], x, y)]\\n        grid[x][y] *= -1\\n        while heap and len(ans) < k:\\n            distance, price, r, c = heapq.heappop(heap)\\n            if low <= price <= high:\\n                ans.append([r, c])\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if R > i >= 0 <= j < C and grid[i][j] > 0: \\n                    heapq.heappush(heap, (distance + 1, grid[i][j], i, j))\\n                    grid[i][j] *= -1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1714345,
                "title": "bfs-with-heap-or-sorting",
                "content": "Since the shortest distance matters, we need to use BFS. We have several options:\\n- Collect distances, prices and coordinates for all reachable cells within the price range, then sort and return top-k elements.\\n- Use a hash set to enumerate cells in the right order. We can populate our result as we go and exit when we have k elements there.\\n\\nIntuitivelly, using a hash set should be faster, though the OJ runtime varies a lot so it\\'s hard to tell.\\n\\nAs an additional optimization, we can use a \"local\" heap where we sort by price and coordinates **within** the same distance. See approach 3 below.\\n\\n#### Approach 1: Sort\\n**C++**\\n```cpp\\nint dir[5] = {0, -1, 0, 1, 0};\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    vector<array<int, 4>> q{{0, grid[start[0]][start[1]], start[0], start[1]}};\\n    vector<vector<int>> res;\\n    grid[start[0]][start[1]] = 0;\\n    int i = 0;\\n    for (int i = 0; i < q.size(); ++i) {\\n        auto [dist, price, x, y] = q[i];\\n        for (int d = 0; d < 4; ++d) {\\n            int x1 = x + dir[d], y1 = y + dir[d + 1];\\n            if (min(x1, y1) >= 0 && x1 < grid.size() && y1 < grid[x1].size() && grid[x1][y1] != 0) {\\n                q.push_back({dist + 1, grid[x1][y1], x1, y1});\\n                grid[x1][y1] = 0;\\n            }\\n        }\\n    }\\n    sort(begin(q), end(q));\\n    for (auto [dist, price, x, y] : q) {\\n        if (price >= pricing[0] && price <= pricing[1])\\n            res.push_back({x, y});\\n        if (res.size() == k)\\n            break;\\n    }\\n    return res;\\n}\\n```\\n#### Approach 2: Heap\\n**C++**\\n```cpp\\nint dir[5] = {0, -1, 0, 1, 0};\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    priority_queue<array<int, 4>, vector<array<int, 4>>, greater<array<int, 4>>> pq;\\n    vector<vector<int>> res;\\n    pq.push({0, grid[start[0]][start[1]], start[0], start[1]});\\n    grid[start[0]][start[1]] = 0;\\n    while (!pq.empty() && res.size() < k) {\\n        auto [dist, price, x, y] = pq.top(); pq.pop();\\n        if (price >= pricing[0] && price <= pricing[1])\\n            res.push_back({x, y});\\n        for (int d = 0; d < 4; ++d) {\\n            int x1 = x + dir[d], y1 = y + dir[d + 1];\\n            if (min(x1, y1) >= 0 && x1 < grid.size() && y1 < grid[x1].size() && grid[x1][y1] != 0) {\\n                pq.push({dist + 1, grid[x1][y1], x1, y1});\\n                grid[x1][y1] = 0;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```\\n#### Approach 3: Local Heap\\n**C++**\\n```cpp\\nint dir[5] = {0, -1, 0, 1, 0};\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> pq;\\n    vector<vector<int>> res;\\n    pq.push({grid[start[0]][start[1]], start[0], start[1]});\\n    grid[start[0]][start[1]] = 0;\\n    while (!pq.empty() && res.size() < k) {\\n        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> pq1;\\n        while (!pq.empty() && res.size() < k) {\\n            auto [price, x, y] = pq.top(); pq.pop();\\n            if (price >= pricing[0] && price <= pricing[1])\\n                res.push_back({x, y});\\n            for (int d = 0; d < 4; ++d) {\\n                int x1 = x + dir[d], y1 = y + dir[d + 1];\\n                if (min(x1, y1) >= 0 && x1 < grid.size() && y1 < grid[x1].size() && grid[x1][y1] != 0) {\\n                    pq1.push({grid[x1][y1], x1, y1});\\n                    grid[x1][y1] = 0;\\n                }\\n            }\\n        }\\n        swap(pq, pq1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dir[5] = {0, -1, 0, 1, 0};\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    vector<array<int, 4>> q{{0, grid[start[0]][start[1]], start[0], start[1]}};\\n    vector<vector<int>> res;\\n    grid[start[0]][start[1]] = 0;\\n    int i = 0;\\n    for (int i = 0; i < q.size(); ++i) {\\n        auto [dist, price, x, y] = q[i];\\n        for (int d = 0; d < 4; ++d) {\\n            int x1 = x + dir[d], y1 = y + dir[d + 1];\\n            if (min(x1, y1) >= 0 && x1 < grid.size() && y1 < grid[x1].size() && grid[x1][y1] != 0) {\\n                q.push_back({dist + 1, grid[x1][y1], x1, y1});\\n                grid[x1][y1] = 0;\\n            }\\n        }\\n    }\\n    sort(begin(q), end(q));\\n    for (auto [dist, price, x, y] : q) {\\n        if (price >= pricing[0] && price <= pricing[1])\\n            res.push_back({x, y});\\n        if (res.size() == k)\\n            break;\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint dir[5] = {0, -1, 0, 1, 0};\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    priority_queue<array<int, 4>, vector<array<int, 4>>, greater<array<int, 4>>> pq;\\n    vector<vector<int>> res;\\n    pq.push({0, grid[start[0]][start[1]], start[0], start[1]});\\n    grid[start[0]][start[1]] = 0;\\n    while (!pq.empty() && res.size() < k) {\\n        auto [dist, price, x, y] = pq.top(); pq.pop();\\n        if (price >= pricing[0] && price <= pricing[1])\\n            res.push_back({x, y});\\n        for (int d = 0; d < 4; ++d) {\\n            int x1 = x + dir[d], y1 = y + dir[d + 1];\\n            if (min(x1, y1) >= 0 && x1 < grid.size() && y1 < grid[x1].size() && grid[x1][y1] != 0) {\\n                pq.push({dist + 1, grid[x1][y1], x1, y1});\\n                grid[x1][y1] = 0;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint dir[5] = {0, -1, 0, 1, 0};\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> pq;\\n    vector<vector<int>> res;\\n    pq.push({grid[start[0]][start[1]], start[0], start[1]});\\n    grid[start[0]][start[1]] = 0;\\n    while (!pq.empty() && res.size() < k) {\\n        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> pq1;\\n        while (!pq.empty() && res.size() < k) {\\n            auto [price, x, y] = pq.top(); pq.pop();\\n            if (price >= pricing[0] && price <= pricing[1])\\n                res.push_back({x, y});\\n            for (int d = 0; d < 4; ++d) {\\n                int x1 = x + dir[d], y1 = y + dir[d + 1];\\n                if (min(x1, y1) >= 0 && x1 < grid.size() && y1 < grid[x1].size() && grid[x1][y1] != 0) {\\n                    pq1.push({grid[x1][y1], x1, y1});\\n                    grid[x1][y1] = 0;\\n                }\\n            }\\n        }\\n        swap(pq, pq1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709689,
                "title": "c-bfs-sorting-o-mnlog-mn-or-heap-o-mnlogk",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. BFS + Sorting\\n\\nBFS to visit all the cells reachable. If the price of the cell is within the range, add this cell into the answer array.\\n\\nSort the answer array using the criteria specified, and only keep the first `k` cells.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-70/problems/k-highest-ranked-items-within-a-price-range/\\n// Author: github.com/lzl124631x\\n// Time: O(MNlog(MN))\\n// Space: O(MN)\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& A, vector<int>& P, vector<int>& start, int k) {\\n        int M = A.size(), N = A[0].size(), step = 0, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n        queue<pair<int, int>> q{{{start[0], start[1]}}};\\n        vector<vector<int>> dist(M, vector<int>(N, INT_MAX)), ans; // dist[x][y] is the shortest distance from (x,y) to `start`.\\n        dist[start[0]][start[1]] = 0;\\n        while (q.size()) {\\n            int cnt = q.size();\\n            while (cnt--) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                if (A[x][y] >= P[0] && A[x][y] <= P[1]) ans.push_back({x, y});\\n                for (auto &[dx, dy] : dirs) {\\n                    int a = x + dx, b = y + dy;\\n                    if (a < 0 || b < 0 || a >= M || b >= N || A[a][b] == 0 || dist[a][b] != INT_MAX) continue;\\n                    dist[a][b] = step + 1;\\n                    q.emplace(a, b);\\n                }\\n            }\\n            ++step;\\n        }\\n        sort(begin(ans), end(ans), [&](auto &a, auto &b) {\\n            int x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1];\\n            int d1 = dist[x1][y1], d2 = dist[x2][y2];\\n            if (d1 != d2) return d1 < d2;\\n            int p1 = A[x1][y1], p2 = A[x2][y2];\\n            if (p1 != p2) return p1 < p2;\\n            return a < b;\\n        });\\n        if (ans.size() > k) ans.resize(k);\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. BFS + Heap\\n\\nInstead of keeping all the reachable cells in `ans`, we can use a heap to keep only the optimal `k` cells.\\n\\nSince we are doing BFS, we are already visiting the cells in ascending order of distance layer by layer, so we don\\'t need to sort by distance.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/k-highest-ranked-items-within-a-price-range/\\n// Author: github.com/lzl124631x\\n// Time: O(MNlogK)\\n// Space: O(MN)\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& A, vector<int>& P, vector<int>& start, int k) {\\n        int M = A.size(), N = A[0].size(), step = 0, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n        queue<pair<int, int>> q{{{start[0], start[1]}}};\\n        vector<vector<int>> ans;\\n        vector<vector<bool>> seen(M, vector<bool>(N));\\n        seen[start[0]][start[1]] = true;\\n        while (q.size() && ans.size() < k) {\\n            int cnt = q.size();\\n            vector<vector<int>> tmp;\\n            while (cnt--) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                if (A[x][y] >= P[0] && A[x][y] <= P[1]) tmp.push_back({A[x][y], x, y});\\n                for (auto &[dx, dy] : dirs) {\\n                    int a = x + dx, b = y + dy;\\n                    if (a < 0 || b < 0 || a >= M || b >= N || A[a][b] == 0 || seen[a][b]) continue;\\n                    seen[a][b] = true;\\n                    q.emplace(a, b);\\n                }\\n            }\\n            sort(begin(tmp), end(tmp));\\n            ++step;\\n            for (auto c : tmp) {\\n                ans.push_back({c[1], c[2]});\\n                if (ans.size() == k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-70/problems/k-highest-ranked-items-within-a-price-range/\\n// Author: github.com/lzl124631x\\n// Time: O(MNlog(MN))\\n// Space: O(MN)\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& A, vector<int>& P, vector<int>& start, int k) {\\n        int M = A.size(), N = A[0].size(), step = 0, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n        queue<pair<int, int>> q{{{start[0], start[1]}}};\\n        vector<vector<int>> dist(M, vector<int>(N, INT_MAX)), ans; // dist[x][y] is the shortest distance from (x,y) to `start`.\\n        dist[start[0]][start[1]] = 0;\\n        while (q.size()) {\\n            int cnt = q.size();\\n            while (cnt--) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                if (A[x][y] >= P[0] && A[x][y] <= P[1]) ans.push_back({x, y});\\n                for (auto &[dx, dy] : dirs) {\\n                    int a = x + dx, b = y + dy;\\n                    if (a < 0 || b < 0 || a >= M || b >= N || A[a][b] == 0 || dist[a][b] != INT_MAX) continue;\\n                    dist[a][b] = step + 1;\\n                    q.emplace(a, b);\\n                }\\n            }\\n            ++step;\\n        }\\n        sort(begin(ans), end(ans), [&](auto &a, auto &b) {\\n            int x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1];\\n            int d1 = dist[x1][y1], d2 = dist[x2][y2];\\n            if (d1 != d2) return d1 < d2;\\n            int p1 = A[x1][y1], p2 = A[x2][y2];\\n            if (p1 != p2) return p1 < p2;\\n            return a < b;\\n        });\\n        if (ans.size() > k) ans.resize(k);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/k-highest-ranked-items-within-a-price-range/\\n// Author: github.com/lzl124631x\\n// Time: O(MNlogK)\\n// Space: O(MN)\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& A, vector<int>& P, vector<int>& start, int k) {\\n        int M = A.size(), N = A[0].size(), step = 0, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n        queue<pair<int, int>> q{{{start[0], start[1]}}};\\n        vector<vector<int>> ans;\\n        vector<vector<bool>> seen(M, vector<bool>(N));\\n        seen[start[0]][start[1]] = true;\\n        while (q.size() && ans.size() < k) {\\n            int cnt = q.size();\\n            vector<vector<int>> tmp;\\n            while (cnt--) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                if (A[x][y] >= P[0] && A[x][y] <= P[1]) tmp.push_back({A[x][y], x, y});\\n                for (auto &[dx, dy] : dirs) {\\n                    int a = x + dx, b = y + dy;\\n                    if (a < 0 || b < 0 || a >= M || b >= N || A[a][b] == 0 || seen[a][b]) continue;\\n                    seen[a][b] = true;\\n                    q.emplace(a, b);\\n                }\\n            }\\n            sort(begin(tmp), end(tmp));\\n            ++step;\\n            for (auto c : tmp) {\\n                ans.push_back({c[1], c[2]});\\n                if (ans.size() == k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709757,
                "title": "java-solution-bfs-priorityqueue",
                "content": "```\\nclass Solution {\\n    static class Quad\\n    {\\n        int x,y,price,dist;\\n        Quad(int x,int y,int price,int dist)\\n        {\\n            this.x=x;\\n            this.y=y;\\n            this.price=price;\\n            this.dist=dist;\\n        }\\n    }\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>> ans=new LinkedList<>();\\n        PriorityQueue<Quad> pq=new PriorityQueue<>((a,b)->{\\n            if(a.dist!=b.dist)\\n                return a.dist-b.dist;\\n            if(a.price!=b.price)\\n                return a.price-b.price;\\n            if(a.x!=b.x)\\n                return a.x-b.x;\\n            return a.y-b.y;\\n        });\\n        bfs(grid,start[0],start[1],pricing[0],pricing[1],pq);\\n        while(!pq.isEmpty()&&k-->0)\\n        {\\n            Quad quad=pq.poll();\\n            List<Integer> temp=new LinkedList<>();\\n            temp.add(quad.x);\\n            temp.add(quad.y);\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n    void bfs(int[][] grid,int i,int j,int low,int high,PriorityQueue<Quad> pq)\\n    {\\n        Queue<int[]> queue=new LinkedList<>();\\n        int m=grid.length,n=grid[0].length;\\n        if(grid[i][j]>=low&&grid[i][j]<=high)\\n            pq.add(new Quad(i,j,grid[i][j],0));\\n        grid[i][j]=0;\\n        queue.add(new int[]{i,j});\\n        int dist=0;\\n        int dirs[][]={{1,0},{-1,0},{0,1},{0,-1}};\\n        while(!queue.isEmpty())\\n        {\\n            ++dist;\\n            int size=queue.size();\\n            while(size-->0)\\n            {\\n                int[] p=queue.poll();\\n                for(int[] dir:dirs)\\n                {\\n                    int newX=dir[0]+p[0];\\n                    int newY=dir[1]+p[1];\\n                    if(newX>=0&&newY>=0&&newX<m&&newY<n&&grid[newX][newY]!=0)\\n                    {\\n                        if(grid[newX][newY]>=low&&grid[newX][newY]<=high)\\n                            pq.add(new Quad(newX,newY,grid[newX][newY],dist));\\n                        queue.add(new int[]{newX,newY});\\n                        grid[newX][newY]=0;\\n                    }\\n                }\\n            }\\n            \\n        }\\n    }\\n   \\n\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    static class Quad\\n    {\\n        int x,y,price,dist;\\n        Quad(int x,int y,int price,int dist)\\n        {\\n            this.x=x;\\n            this.y=y;\\n            this.price=price;\\n            this.dist=dist;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1716922,
                "title": "bfs-heap-c-comments",
                "content": "Use **array<int,3>** instead of **vectors**, because vectors have an extra overhead.\\n\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, 1, 0, -1};\\n    int dy[4] = {1, 0, -1, 0};\\n        \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& ar, vector<int>& pr, vector<int>& st, int k) {\\n        // Base Case\\n        if(ar[st[0]][st[1]] == 0)\\n            return {{}};\\n        \\n        // heap params: {dis, price, row, col} in sorted order\\n        priority_queue<array<int,4>, vector<array<int,4> >, greater<array<int,4> > > pq;\\n        \\n        // queue params: {row, col, dis}\\n        queue<array<int,3> > q;\\n        \\n        int row = ar.size(), col = ar[0].size();\\n    \\n        // visited matrix\\n        vector<vector<int> > vis(row, vector<int> (col, 0));\\n        \\n        // starting point\\n        q.push({st[0], st[1], 0});\\n        \\n        // Is start point valid?\\n        if(ar[st[0]][st[1]] >= pr[0] && ar[st[0]][st[1]] <= pr[1]){\\n            pq.push({0, ar[st[0]][st[1]], st[0], st[1]});\\n        }\\n        \\n        // mark it visited\\n        vis[st[0]][st[1]] = 1;\\n        \\n        while(!q.empty()){\\n            auto cur = q.front();\\n            q.pop();\\n            \\n            for(int i = 0; i < 4; i++){\\n                \\n                // next point\\'s coordinates\\n                int nx = cur[0] + dx[i];\\n                int ny = cur[1] + dy[i];\\n                int dis = cur[2];\\n                \\n                // check validity\\n                if(nx >= 0 && nx < row && ny >= 0 && ny < col && !vis[nx][ny] && ar[nx][ny] != 0){\\n                    \\n                    // can be one of the K possible points\\n                    if(ar[nx][ny] >= pr[0] && ar[nx][ny] <= pr[1]){\\n                        pq.push({dis+1, ar[nx][ny], nx, ny});\\n                        q.push({nx, ny, dis+1});\\n                        vis[nx][ny] = 1;\\n                    }\\n                    \\n                    // else just push & continue\\n                    else{\\n                        q.push({nx, ny, dis+1});\\n                        vis[nx][ny] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int> > ans;\\n        \\n        // storing k resultant points \\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            ans.push_back({cur[2], cur[3]});\\n            k--;\\n            if(k == 0)\\n                break;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nDo **upvote**, if the solution helped you!\\nThanks",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, 1, 0, -1};\\n    int dy[4] = {1, 0, -1, 0};\\n        \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& ar, vector<int>& pr, vector<int>& st, int k) {\\n        // Base Case\\n        if(ar[st[0]][st[1]] == 0)\\n            return {{}};\\n        \\n        // heap params: {dis, price, row, col} in sorted order\\n        priority_queue<array<int,4>, vector<array<int,4> >, greater<array<int,4> > > pq;\\n        \\n        // queue params: {row, col, dis}\\n        queue<array<int,3> > q;\\n        \\n        int row = ar.size(), col = ar[0].size();\\n    \\n        // visited matrix\\n        vector<vector<int> > vis(row, vector<int> (col, 0));\\n        \\n        // starting point\\n        q.push({st[0], st[1], 0});\\n        \\n        // Is start point valid?\\n        if(ar[st[0]][st[1]] >= pr[0] && ar[st[0]][st[1]] <= pr[1]){\\n            pq.push({0, ar[st[0]][st[1]], st[0], st[1]});\\n        }\\n        \\n        // mark it visited\\n        vis[st[0]][st[1]] = 1;\\n        \\n        while(!q.empty()){\\n            auto cur = q.front();\\n            q.pop();\\n            \\n            for(int i = 0; i < 4; i++){\\n                \\n                // next point\\'s coordinates\\n                int nx = cur[0] + dx[i];\\n                int ny = cur[1] + dy[i];\\n                int dis = cur[2];\\n                \\n                // check validity\\n                if(nx >= 0 && nx < row && ny >= 0 && ny < col && !vis[nx][ny] && ar[nx][ny] != 0){\\n                    \\n                    // can be one of the K possible points\\n                    if(ar[nx][ny] >= pr[0] && ar[nx][ny] <= pr[1]){\\n                        pq.push({dis+1, ar[nx][ny], nx, ny});\\n                        q.push({nx, ny, dis+1});\\n                        vis[nx][ny] = 1;\\n                    }\\n                    \\n                    // else just push & continue\\n                    else{\\n                        q.push({nx, ny, dis+1});\\n                        vis[nx][ny] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int> > ans;\\n        \\n        // storing k resultant points \\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            ans.push_back({cur[2], cur[3]});\\n            k--;\\n            if(k == 0)\\n                break;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710983,
                "title": "dijkstra-algorithm-and-a-list-of-similar-questions",
                "content": "If you are new to Dijkstra, see my other posts with graph explanations. https://leetcode.com/problems/the-maze-ii/discuss/1377876/improved-dijkstra-based-on-the-most-voted-solution/1208402\\n\\nFor such matrix-like problem, can always think about coverting it to a graph problem: each cell represents a node in graph and is connected to its for different neighbors. The number of the cell represent the the weight.\\n\\nThen the question is then translated to: starting from the start point, find k nodes (meaing that the cell\\'s value should not be 0 according to the question) according to the **rule** provided.\\n\\nThinking about the Dijkstra Algorithm, it can rank the nodes accoding a **rule** of measuing the accumulated weights of edges from the starting point to the nodes. In this sense, we can just use the Dikstra Algorithm and replace its classical rule with the rule provided here. Bingo!\\n\\nSimilar Leetcode problems can be solved with the same paradigm:\\nhttps://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/\\nhttps://leetcode.com/problems/swim-in-rising-water/\\n\\n```\\nimport heapq\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        row, col = len(grid), len(grid[0])\\n        q = [(0, grid[start[0]][start[1]], start[0], start[1])]\\n        visit = set()\\n        result = []\\n        while q:\\n            dis, price, x, y = heapq.heappop(q)\\n            if (x, y) in visit:\\n                continue\\n            visit.add((x, y))\\n            if price != 1 and price >= pricing[0] and price <= pricing[1]:\\n                result.append([x, y])\\n            if len(result) == k:\\n                return result\\n            for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < row and 0 <= new_y < col and (new_x, new_y) not in visit:\\n                    temp = grid[new_x][new_y]\\n                    if temp == 0:\\n                        continue\\n                    elif temp == 1:\\n                        heapq.heappush(q, (dis + 1, 1, new_x, new_y))\\n                    else:\\n                        heapq.heappush(q, (dis + 1, temp, new_x, new_y))\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        row, col = len(grid), len(grid[0])\\n        q = [(0, grid[start[0]][start[1]], start[0], start[1])]\\n        visit = set()\\n        result = []\\n        while q:\\n            dis, price, x, y = heapq.heappop(q)\\n            if (x, y) in visit:\\n                continue\\n            visit.add((x, y))\\n            if price != 1 and price >= pricing[0] and price <= pricing[1]:\\n                result.append([x, y])\\n            if len(result) == k:\\n                return result\\n            for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < row and 0 <= new_y < col and (new_x, new_y) not in visit:\\n                    temp = grid[new_x][new_y]\\n                    if temp == 0:\\n                        continue\\n                    elif temp == 1:\\n                        heapq.heappush(q, (dis + 1, 1, new_x, new_y))\\n                    else:\\n                        heapq.heappush(q, (dis + 1, temp, new_x, new_y))\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710682,
                "title": "bfs-cpp-commented",
                "content": "\\n```\\nint n,m; \\nbool bounds(int x,int y)    // this will check whether we are in bounds or not\\n{\\n\\tif(x>=n || x<0 || y>=m || y<0)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n\\tn = (int)grid.size();\\n\\tm = (int)grid[0].size();\\n\\tint l = start[0];\\n\\tint r = start[1];\\n\\tmultiset<pair<pair<int,int>,pair<int,int>>>ms;\\n\\t/*  {{{Distance,Price},{Row,Column}}}\\n\\t\\t1. The states are sorted first by distance\\n\\t\\t2. If two states have the same distance then they will be sorted by price\\n\\t\\t3. Two states having same distance and same price will be sorted by row\\n\\t\\t4.  Two states having same distance, same price and same row will be sorted by column\\n\\t*/\\n\\tms.insert({{0,grid[l][r]},{l,r}});\\n\\n\\tint dp[n][m];           // using dp to handle subproblems\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tdp[i][j] = -1;\\n\\t\\t}\\n\\t}\\n\\tdp[l][r] = 1;\\n\\n\\tint dir[5] = {1,0,-1,0,1};\\n\\tvector<vector<int>>ans;\\n\\t//BFS for every level \\n\\twhile((int)ms.size()>0)\\n\\t{\\n\\t\\tint sz = (int)ms.size();\\n\\t\\t// exhaust all the states at this level (or distance)\\n\\t\\twhile(sz>0)\\n\\t\\t{\\n\\t\\t\\tint d = (*ms.begin()).first.first;\\n\\t\\t\\tint p = (*ms.begin()).first.second;\\n\\t\\t\\tint x = (*ms.begin()).second.first;\\n\\t\\t\\tint y = (*ms.begin()).second.second;\\n\\t\\t\\tms.erase(*ms.begin());\\n\\t\\t\\tif(p>=pricing[0] && p<=pricing[1])     // if price is in range then take\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back({x,y});\\n\\t\\t\\t}\\n\\t\\t\\tif((int)ans.size()==k)          // job done return\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<4;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint new_x = x + dir[i];\\n\\t\\t\\t\\tint new_y = y + dir[i+1];\\n\\t\\t\\t\\tif(bounds(new_x,new_y))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint new_price = grid[new_x][new_y];\\n\\t\\t\\t\\t\\tif(new_price==0)       // since we cant pass through a 0 so dont insert in multiset\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(dp[new_x][new_y]==-1)   // if this node is not visited\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tms.insert({{d+1,new_price},{new_x,new_y}});\\n\\t\\t\\t\\t\\t\\tdp[new_x][new_y] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsz--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nint n,m; \\nbool bounds(int x,int y)    // this will check whether we are in bounds or not\\n{\\n\\tif(x>=n || x<0 || y>=m || y<0)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n\\tn = (int)grid.size();\\n\\tm = (int)grid[0].size();\\n\\tint l = start[0];\\n\\tint r = start[1];\\n\\tmultiset<pair<pair<int,int>,pair<int,int>>>ms;\\n\\t/*  {{{Distance,Price},{Row,Column}}}\\n\\t\\t1. The states are sorted first by distance\\n\\t\\t2. If two states have the same distance then they will be sorted by price\\n\\t\\t3. Two states having same distance and same price will be sorted by row\\n\\t\\t4.  Two states having same distance, same price and same row will be sorted by column\\n\\t*/\\n\\tms.insert({{0,grid[l][r]},{l,r}});\\n\\n\\tint dp[n][m];           // using dp to handle subproblems\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tdp[i][j] = -1;\\n\\t\\t}\\n\\t}\\n\\tdp[l][r] = 1;\\n\\n\\tint dir[5] = {1,0,-1,0,1};\\n\\tvector<vector<int>>ans;\\n\\t//BFS for every level \\n\\twhile((int)ms.size()>0)\\n\\t{\\n\\t\\tint sz = (int)ms.size();\\n\\t\\t// exhaust all the states at this level (or distance)\\n\\t\\twhile(sz>0)\\n\\t\\t{\\n\\t\\t\\tint d = (*ms.begin()).first.first;\\n\\t\\t\\tint p = (*ms.begin()).first.second;\\n\\t\\t\\tint x = (*ms.begin()).second.first;\\n\\t\\t\\tint y = (*ms.begin()).second.second;\\n\\t\\t\\tms.erase(*ms.begin());\\n\\t\\t\\tif(p>=pricing[0] && p<=pricing[1])     // if price is in range then take\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back({x,y});\\n\\t\\t\\t}\\n\\t\\t\\tif((int)ans.size()==k)          // job done return\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<4;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint new_x = x + dir[i];\\n\\t\\t\\t\\tint new_y = y + dir[i+1];\\n\\t\\t\\t\\tif(bounds(new_x,new_y))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint new_price = grid[new_x][new_y];\\n\\t\\t\\t\\t\\tif(new_price==0)       // since we cant pass through a 0 so dont insert in multiset\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(dp[new_x][new_y]==-1)   // if this node is not visited\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tms.insert({{d+1,new_price},{new_x,new_y}});\\n\\t\\t\\t\\t\\t\\tdp[new_x][new_y] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsz--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1710325,
                "title": "c-using-bfs-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    struct cell\\n    {\\n        int dist;\\n        int cost;\\n        int row;\\n        int col;\\n    };\\n    struct compare\\n    {\\n        bool operator()(const cell &a, const cell &b)\\n        {\\n            if(a.dist != b.dist) \\n                return a.dist < b.dist;\\n            else if(a.cost != b.cost) \\n                return a.cost < b.cost;\\n            else if(a.row != b.row) \\n                return a.row < b.row;\\n            else\\n                return a.col < b.col;\\n        }\\n    };\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<pair<int,int>>q;\\n        q.push({start[0],start[1]});\\n        \\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        vis[start[0]][start[1]]=true;\\n        \\n        int dx[4]={-1,0,1,0};\\n        int dy[4]={0,-1,0,1};\\n        int dist=0;\\n        \\n        priority_queue<cell,vector<cell>,compare> pq;\\n         while(!q.empty())\\n         {\\n             int size=q.size();\\n             while(size--)\\n             {\\n                 pair<int,int> p=q.front(); q.pop();\\n                 if(grid[p.first][p.second]!=1 && grid[p.first][p.second]>=pricing[0] && grid[p.first][p.second]<=pricing[1])\\n                 {\\n                     pq.push({dist,grid[p.first][p.second],p.first,p.second});\\n                     \\n                     if(pq.size()>k)\\n                         pq.pop();\\n                }\\n                for(int k=0;k<4;k++)\\n                {\\n                    int x=p.first+dx[k];\\n                    int y=p.second+dy[k];\\n\\n                    if(x>=0 && x<m && y>=0 && y<n && vis[x][y]==false && grid[x][y]!=0)\\n                    {\\n                        vis[x][y]=true;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n        dist++;\\n        }\\n        \\n        vector<vector<int>> ans;\\n        while(!pq.empty())\\n        {\\n        ans.push_back({pq.top().row,pq.top().col});\\n        pq.pop();\\n        }\\n        \\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct cell\\n    {\\n        int dist;\\n        int cost;\\n        int row;\\n        int col;\\n    };\\n    struct compare\\n    {\\n        bool operator()(const cell &a, const cell &b)\\n        {\\n            if(a.dist != b.dist) \\n                return a.dist < b.dist;\\n            else if(a.cost != b.cost) \\n                return a.cost < b.cost;\\n            else if(a.row != b.row) \\n                return a.row < b.row;\\n            else\\n                return a.col < b.col;\\n        }\\n    };\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<pair<int,int>>q;\\n        q.push({start[0],start[1]});\\n        \\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        vis[start[0]][start[1]]=true;\\n        \\n        int dx[4]={-1,0,1,0};\\n        int dy[4]={0,-1,0,1};\\n        int dist=0;\\n        \\n        priority_queue<cell,vector<cell>,compare> pq;\\n         while(!q.empty())\\n         {\\n             int size=q.size();\\n             while(size--)\\n             {\\n                 pair<int,int> p=q.front(); q.pop();\\n                 if(grid[p.first][p.second]!=1 && grid[p.first][p.second]>=pricing[0] && grid[p.first][p.second]<=pricing[1])\\n                 {\\n                     pq.push({dist,grid[p.first][p.second],p.first,p.second});\\n                     \\n                     if(pq.size()>k)\\n                         pq.pop();\\n                }\\n                for(int k=0;k<4;k++)\\n                {\\n                    int x=p.first+dx[k];\\n                    int y=p.second+dy[k];\\n\\n                    if(x>=0 && x<m && y>=0 && y<n && vis[x][y]==false && grid[x][y]!=0)\\n                    {\\n                        vis[x][y]=true;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n        dist++;\\n        }\\n        \\n        vector<vector<int>> ans;\\n        while(!pq.empty())\\n        {\\n        ans.push_back({pq.top().row,pq.top().col});\\n        pq.pop();\\n        }\\n        \\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710698,
                "title": "c-2-solutions-bfs-sorting-priority-queue-o-n-m-logk-time",
                "content": "**BFS WITHOUT QUEUE USING SORTING-**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int lb = pricing[0], ub = pricing[1];\\n        int i = start[0], j = start[1];\\n        vector<vector<int>>temp;\\n        queue<pair<pair<int,int>,int>>q; // <<i,j>,steps>\\n        q.push({{i,j}, 0});\\n        if(grid[i][j]>=lb && grid[i][j]<=ub) temp.push_back({i,j,0});    \\n        int dirX[]={0, 0, 1, -1};\\n        int dirY[]={1, -1, 0, 0};\\n        vector<vector<bool>>vis(n, vector<bool>(m, 0));\\n        vis[i][j] = 1;\\n        while(!q.empty()){\\n            int curi = q.front().first.first;\\n            int curj = q.front().first.second;\\n            int step = q.front().second;\\n            q.pop();\\n            for(int k = 0 ; k < 4 ; k++){\\n                int ni = curi + dirX[k];\\n                int nj = curj + dirY[k];\\n                if(ni>=0 && nj>=0 && ni<n && nj<m && !vis[ni][nj] && grid[ni][nj]!=0){\\n                    q.push({{ni, nj}, step+1});\\n                    if(grid[ni][nj]>=lb && grid[ni][nj]<=ub)\\n                        temp.push_back({ni,nj,step+1});\\n                    vis[ni][nj]=1;\\n                }   \\n            }\\n        }\\n        sort(temp.begin(), temp.end(), [&grid](const auto &a, const auto &b){\\n            return std::tie(a[2],grid[a[0]][a[1]],a[0],a[1]) < std::tie(b[2],grid[b[0]][b[1]],b[0],b[1]);\\n        });\\n        for(auto &i:temp)\\n            i.pop_back();\\n        while(temp.size()>k)\\n            temp.pop_back();\\n        return temp;\\n    }\\n};\\n```\\n**BFS + PRIORITY QUEUE OF TUPLE-**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int lb = pricing[0], ub = pricing[1];\\n        int i = start[0], j = start[1];\\n        queue<pair<pair<int,int>,int>>q; // <<i,j>,steps>\\n        q.push({{i,j},0});\\n        priority_queue<tuple<int,int,int,int>>pq; // <steps, price, i, j>\\n        int dirX[]={0, 0, 1, -1};\\n        int dirY[]={1, -1, 0, 0};\\n        vector<vector<bool>>vis(n, vector<bool>(m, 0));\\n        vis[i][j] = 1;\\n        while(!q.empty()){\\n            int curi = q.front().first.first;\\n            int curj = q.front().first.second;\\n            int step = q.front().second;\\n            q.pop();\\n            if(grid[curi][curj]>=lb && grid[curi][curj]<=ub){\\n                pq.push(make_tuple(step, grid[curi][curj], curi, curj));\\n                if(pq.size()>k) pq.pop();\\n            }\\n            for(int k = 0 ; k < 4 ; k++){\\n                int ni = curi + dirX[k];\\n                int nj = curj + dirY[k];\\n                if(ni>=0 && nj>=0 && ni<n && nj<m && !vis[ni][nj] && grid[ni][nj]!=0){\\n                    q.push({{ni, nj}, step+1});\\n                    vis[ni][nj]=1;\\n                }   \\n            }\\n        }\\n        vector<vector<int>>ans;\\n        while(!pq.empty()){\\n            auto [step, t, curi, curj] = pq.top();\\n            ans.push_back({curi, curj});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int lb = pricing[0], ub = pricing[1];\\n        int i = start[0], j = start[1];\\n        vector<vector<int>>temp;\\n        queue<pair<pair<int,int>,int>>q; // <<i,j>,steps>\\n        q.push({{i,j}, 0});\\n        if(grid[i][j]>=lb && grid[i][j]<=ub) temp.push_back({i,j,0});    \\n        int dirX[]={0, 0, 1, -1};\\n        int dirY[]={1, -1, 0, 0};\\n        vector<vector<bool>>vis(n, vector<bool>(m, 0));\\n        vis[i][j] = 1;\\n        while(!q.empty()){\\n            int curi = q.front().first.first;\\n            int curj = q.front().first.second;\\n            int step = q.front().second;\\n            q.pop();\\n            for(int k = 0 ; k < 4 ; k++){\\n                int ni = curi + dirX[k];\\n                int nj = curj + dirY[k];\\n                if(ni>=0 && nj>=0 && ni<n && nj<m && !vis[ni][nj] && grid[ni][nj]!=0){\\n                    q.push({{ni, nj}, step+1});\\n                    if(grid[ni][nj]>=lb && grid[ni][nj]<=ub)\\n                        temp.push_back({ni,nj,step+1});\\n                    vis[ni][nj]=1;\\n                }   \\n            }\\n        }\\n        sort(temp.begin(), temp.end(), [&grid](const auto &a, const auto &b){\\n            return std::tie(a[2],grid[a[0]][a[1]],a[0],a[1]) < std::tie(b[2],grid[b[0]][b[1]],b[0],b[1]);\\n        });\\n        for(auto &i:temp)\\n            i.pop_back();\\n        while(temp.size()>k)\\n            temp.pop_back();\\n        return temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int lb = pricing[0], ub = pricing[1];\\n        int i = start[0], j = start[1];\\n        queue<pair<pair<int,int>,int>>q; // <<i,j>,steps>\\n        q.push({{i,j},0});\\n        priority_queue<tuple<int,int,int,int>>pq; // <steps, price, i, j>\\n        int dirX[]={0, 0, 1, -1};\\n        int dirY[]={1, -1, 0, 0};\\n        vector<vector<bool>>vis(n, vector<bool>(m, 0));\\n        vis[i][j] = 1;\\n        while(!q.empty()){\\n            int curi = q.front().first.first;\\n            int curj = q.front().first.second;\\n            int step = q.front().second;\\n            q.pop();\\n            if(grid[curi][curj]>=lb && grid[curi][curj]<=ub){\\n                pq.push(make_tuple(step, grid[curi][curj], curi, curj));\\n                if(pq.size()>k) pq.pop();\\n            }\\n            for(int k = 0 ; k < 4 ; k++){\\n                int ni = curi + dirX[k];\\n                int nj = curj + dirY[k];\\n                if(ni>=0 && nj>=0 && ni<n && nj<m && !vis[ni][nj] && grid[ni][nj]!=0){\\n                    q.push({{ni, nj}, step+1});\\n                    vis[ni][nj]=1;\\n                }   \\n            }\\n        }\\n        vector<vector<int>>ans;\\n        while(!pq.empty()){\\n            auto [step, t, curi, curj] = pq.top();\\n            ans.push_back({curi, curj});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709870,
                "title": "simple-bfs-sorting-c",
                "content": "```\\n\\nThsi question is base on BSF and sorting according to the given conditions\\n\\n`\\nclass Solution {\\npublic:\\n  vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    queue<pair<int,int> > Q;\\n    vector<vector<int>> dis(n, vector<int>(m, -1));\\n    dis[start[0]][start[1]] = 0;\\n    Q.push({start[0], start[1]});\\n    int dx[4] = {0, 0, -1, 1};\\n    int dy[4] ={1, -1, 0, 0};\\n      \\n      // BFS\\n    while (!Q.empty()){\\n      auto [x,y] = Q.front();\\n      Q.pop();\\n      for(int dir = 0; dir < 4; dir++){\\n        int nx = x + dx[dir];\\n        int ny = y + dy[dir];\\n        if(nx>=0 and ny>=0 and nx<n and ny<m and grid[nx][ny] != 0 and dis[nx][ny] == -1){\\n          dis[nx][ny] = 1 + dis[x][y];\\n          Q.push({nx, ny});\\n        }\\n      }\\n    }\\n      \\n    vector<vector<int>> answers;\\n    for(int i = 0; i < n ; i++){\\n      for(int j = 0; j < m ; j++){\\n        if(grid[i][j] >= pricing[0] and grid[i][j] <= pricing[1] and dis[i][j] != -1){\\n          vector<int> v = {i, j,grid[i][j],dis[i][j]};\\n          answers.push_back(v);\\n        }\\n      }\\n    }\\n      \\n    // Sort according to given conditions\\n    sort(begin(answers), end(answers), [&](vector<int>&a, vector<int>&b){\\n        // if distnces equal\\n      if(a[3] == b[3]){\\n          // distance and price equal\\n        if(a[2] == b[2]){\\n            // distance and price and row number equal\\n          if(a[0] == b[0]) {\\n            return a[1] < b[1];\\n          }\\n            //distance, price, row and colum number equal\\n          return a[0] < b[0];\\n        }\\n        return a[2] < b[2];\\n      }\\n      return a[3] < b[3];\\n    });\\n    vector<vector<int>> ans;\\n      \\n      // take first K elements from answers in ans\\n    for(int i = 0; i < answers.size() and k ; i++){\\n      ans.push_back({answers[i][0], answers[i][1]});\\n      k--;\\n    }\\n    return ans;\\n  }\\n};\\n``\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nThsi question is base on BSF and sorting according to the given conditions\\n\\n`\\nclass Solution {\\npublic:\\n  vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    queue<pair<int,int> > Q;\\n    vector<vector<int>> dis(n, vector<int>(m, -1));\\n    dis[start[0]][start[1]] = 0;\\n    Q.push({start[0], start[1]});\\n    int dx[4] = {0, 0, -1, 1};\\n    int dy[4] ={1, -1, 0, 0};\\n      \\n      // BFS\\n    while (!Q.empty()){\\n      auto [x,y] = Q.front();\\n      Q.pop();\\n      for(int dir = 0; dir < 4; dir++){\\n        int nx = x + dx[dir];\\n        int ny = y + dy[dir];\\n        if(nx>=0 and ny>=0 and nx<n and ny<m and grid[nx][ny] != 0 and dis[nx][ny] == -1){\\n          dis[nx][ny] = 1 + dis[x][y];\\n          Q.push({nx, ny});\\n        }\\n      }\\n    }\\n      \\n    vector<vector<int>> answers;\\n    for(int i = 0; i < n ; i++){\\n      for(int j = 0; j < m ; j++){\\n        if(grid[i][j] >= pricing[0] and grid[i][j] <= pricing[1] and dis[i][j] != -1){\\n          vector<int> v = {i, j,grid[i][j],dis[i][j]};\\n          answers.push_back(v);\\n        }\\n      }\\n    }\\n      \\n    // Sort according to given conditions\\n    sort(begin(answers), end(answers), [&](vector<int>&a, vector<int>&b){\\n        // if distnces equal\\n      if(a[3] == b[3]){\\n          // distance and price equal\\n        if(a[2] == b[2]){\\n            // distance and price and row number equal\\n          if(a[0] == b[0]) {\\n            return a[1] < b[1];\\n          }\\n            //distance, price, row and colum number equal\\n          return a[0] < b[0];\\n        }\\n        return a[2] < b[2];\\n      }\\n      return a[3] < b[3];\\n    });\\n    vector<vector<int>> ans;\\n      \\n      // take first K elements from answers in ans\\n    for(int i = 0; i < answers.size() and k ; i++){\\n      ans.push_back({answers[i][0], answers[i][1]});\\n      k--;\\n    }\\n    return ans;\\n  }\\n};\\n``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709742,
                "title": "c-o-nmlog-k-priority-queue-bfs",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    struct node{\\n        int dist; // distance of current cell from start\\n        int cost; // price at current cell\\n        int r, c; // row and column of current cell\\n    };\\n\\t\\n\\t// storing least desired cell at top (max. Heap)\\n    struct compare{\\n        bool operator()(const node &a, const node &b){\\n            if(a.dist != b.dist){\\n                return a.dist < b.dist;\\n            }else if(a.cost != b.cost){\\n                return a.cost < b.cost;\\n            }else if(a.r != b.r){\\n                return a.r < b.r;\\n            }\\n            return a.c < b.c;\\n        }\\n    };\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>> &grid, vector<int> &price, vector<int> &start, int k) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int dxy[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\\n        \\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        int len=0;\\n        \\n        set<pair<int,int>> visited; // to keep track of visited cells\\n        visited.insert({start[0],start[1]});\\n        \\n        int lb=price[0], ub=price[1];\\n        \\n        priority_queue<node,vector<node>,compare> pq;\\n        \\n        while(q.size()>0){\\n            int size=q.size();\\n            while(size--){\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                \\n                int i=p.first, j=p.second;\\n                if(grid[i][j]!=1){\\n                    int curCost=grid[i][j];\\n                    if(curCost>=lb && curCost<=ub){\\n                        if(pq.size()<k){\\n                            pq.push({len,curCost,i,j});\\n                        }else if(pq.size()==k){ // checking if possible to replace with better ranked cell\\n                            struct node tp=pq.top();\\n                            if(tp.dist > len){\\n                                pq.pop();\\n                                pq.push({len,curCost,i,j});\\n                            }else if(tp.dist==len){\\n                                if(tp.cost > curCost){\\n                                    pq.pop();\\n                                    pq.push({len,curCost,i,j});\\n                                }else if(tp.cost==curCost){\\n                                    if(tp.r > i){\\n                                        pq.pop();\\n                                        pq.push({len,curCost,i,j});\\n                                    }else if(tp.r==i && tp.c > j){\\n                                        pq.pop();\\n                                        pq.push({len,curCost,i,j});\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// moving in adjecent cells\\n                for(int k=0;k<4;k++){\\n                    int x=i+dxy[k][0], y=j+dxy[k][1];\\n                    if(x>=0 && y>=0 && x<n && y<m && visited.find({x,y})==visited.end() && grid[x][y]!=0){\\n                        visited.insert({x,y});\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            len++;\\n        }\\n        vector<vector<int>> ans;\\n        while(pq.size()>0){\\n            struct node cur=pq.top();\\n            pq.pop();\\n            \\n            ans.push_back({cur.r,cur.c});\\n            k--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do Upvote If It Helps**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct node{\\n        int dist; // distance of current cell from start\\n        int cost; // price at current cell\\n        int r, c; // row and column of current cell\\n    };\\n\\t\\n\\t// storing least desired cell at top (max. Heap)\\n    struct compare{\\n        bool operator()(const node &a, const node &b){\\n            if(a.dist != b.dist){\\n                return a.dist < b.dist;\\n            }else if(a.cost != b.cost){\\n                return a.cost < b.cost;\\n            }else if(a.r != b.r){\\n                return a.r < b.r;\\n            }\\n            return a.c < b.c;\\n        }\\n    };\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>> &grid, vector<int> &price, vector<int> &start, int k) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int dxy[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\\n        \\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        int len=0;\\n        \\n        set<pair<int,int>> visited; // to keep track of visited cells\\n        visited.insert({start[0],start[1]});\\n        \\n        int lb=price[0], ub=price[1];\\n        \\n        priority_queue<node,vector<node>,compare> pq;\\n        \\n        while(q.size()>0){\\n            int size=q.size();\\n            while(size--){\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                \\n                int i=p.first, j=p.second;\\n                if(grid[i][j]!=1){\\n                    int curCost=grid[i][j];\\n                    if(curCost>=lb && curCost<=ub){\\n                        if(pq.size()<k){\\n                            pq.push({len,curCost,i,j});\\n                        }else if(pq.size()==k){ // checking if possible to replace with better ranked cell\\n                            struct node tp=pq.top();\\n                            if(tp.dist > len){\\n                                pq.pop();\\n                                pq.push({len,curCost,i,j});\\n                            }else if(tp.dist==len){\\n                                if(tp.cost > curCost){\\n                                    pq.pop();\\n                                    pq.push({len,curCost,i,j});\\n                                }else if(tp.cost==curCost){\\n                                    if(tp.r > i){\\n                                        pq.pop();\\n                                        pq.push({len,curCost,i,j});\\n                                    }else if(tp.r==i && tp.c > j){\\n                                        pq.pop();\\n                                        pq.push({len,curCost,i,j});\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// moving in adjecent cells\\n                for(int k=0;k<4;k++){\\n                    int x=i+dxy[k][0], y=j+dxy[k][1];\\n                    if(x>=0 && y>=0 && x<n && y<m && visited.find({x,y})==visited.end() && grid[x][y]!=0){\\n                        visited.insert({x,y});\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            len++;\\n        }\\n        vector<vector<int>> ans;\\n        while(pq.size()>0){\\n            struct node cur=pq.top();\\n            pq.pop();\\n            \\n            ans.push_back({cur.r,cur.c});\\n            k--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693658,
                "title": "python-3-dijkstra-algorithm-easy-to-understand",
                "content": "# Intuition\\n- First we can recognize that we should find the shortest path from start to all the cells -> Dijkstra\\n- then we after we have the shortest path from the start cell to all other cells, we may sort it and take k highest one with value in range pricing (we can do this better utilize the properites in dijkstra)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m * n log(m * n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        sx, sy = start\\n        pl, ph = pricing\\n        q = [(0, grid[sx][sy], sx, sy)]\\n        visited = set()\\n        res = []\\n\\n        while q:\\n            dis, price, x, y = heapq.heappop(q)\\n            if (x, y) in visited: continue\\n            \\n            visited.add((x, y))\\n            \\n            if price != 1 and pl <= price <= ph: res.append([x, y])\\n            if len(res) == k: return res\\n\\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < m and 0 <= new_y < n:\\n                    val = grid[new_x][new_y]\\n                    if val == 0: continue\\n                    else: heapq.heappush(q, (dis + 1, val, new_x, new_y))\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        sx, sy = start\\n        pl, ph = pricing\\n        q = [(0, grid[sx][sy], sx, sy)]\\n        visited = set()\\n        res = []\\n\\n        while q:\\n            dis, price, x, y = heapq.heappop(q)\\n            if (x, y) in visited: continue\\n            \\n            visited.add((x, y))\\n            \\n            if price != 1 and pl <= price <= ph: res.append([x, y])\\n            if len(res) == k: return res\\n\\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < m and 0 <= new_y < n:\\n                    val = grid[new_x][new_y]\\n                    if val == 0: continue\\n                    else: heapq.heappush(q, (dis + 1, val, new_x, new_y))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715834,
                "title": "ez-python-heap-bfs",
                "content": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n            mall matrix : 0=wall, 1=move space, 2-n=price of item+move space\\n            price = [low, high]\\n            \\n            return top k ranked items within price range, sorted by rank(high to low)\\n            rank of item = \\n                1. distance (short distance = high rank)\\n                2. if dist is same, next we choose price (low price in range is high rank)\\n                3. if above 2 are same, row number (small row = high rank)\\n                4. if above 3 are same, col number (small col = high rank)\\n                \\n                sort seems to be on : [<dist, price, row, col>]\\n                \\n            above cond. makes clear to run bfs and solve\\n            \\n              v\\n            1 2 2\\n            1 2 0\\n            0 2 5\\n        \"\"\" \\n        \\n        \\n        pq = []\\n        ans = []\\n        heapq.heappush(pq, (0, 0, start[0], start[1])) # dist, price, row, col\\n        seen = set()\\n        M = len(grid)\\n        N = len(grid[0])\\n        \\n        while pq and k > 0:\\n            \\n            dist, price, cx, cy = heapq.heappop(pq)\\n            \\n            if (cx, cy) in seen:\\n                continue\\n            \\n            seen.add((cx, cy))\\n            \\n            if pricing[0] <= grid[cx][cy] <= pricing[1]:\\n                k -= 1\\n                ans.append([cx, cy])\\n            \\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                nx = dx + cx\\n                ny = dy + cy\\n                \\n                if nx < 0 or nx >= M or ny < 0 or ny >= N or grid[nx][ny] == 0 or (nx, ny) in seen:\\n                    continue\\n                \\n                heapq.heappush(pq, (dist+1,  grid[nx][ny], nx, ny))\\n                \\n            \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n            mall matrix : 0=wall, 1=move space, 2-n=price of item+move space\\n            price = [low, high]\\n            \\n            return top k ranked items within price range, sorted by rank(high to low)\\n            rank of item = \\n                1. distance (short distance = high rank)\\n                2. if dist is same, next we choose price (low price in range is high rank)\\n                3. if above 2 are same, row number (small row = high rank)\\n                4. if above 3 are same, col number (small col = high rank)\\n                \\n                sort seems to be on : [<dist, price, row, col>]\\n                \\n            above cond. makes clear to run bfs and solve\\n            \\n              v\\n            1 2 2\\n            1 2 0\\n            0 2 5\\n        \"\"\" \\n        \\n        \\n        pq = []\\n        ans = []\\n        heapq.heappush(pq, (0, 0, start[0], start[1])) # dist, price, row, col\\n        seen = set()\\n        M = len(grid)\\n        N = len(grid[0])\\n        \\n        while pq and k > 0:\\n            \\n            dist, price, cx, cy = heapq.heappop(pq)\\n            \\n            if (cx, cy) in seen:\\n                continue\\n            \\n            seen.add((cx, cy))\\n            \\n            if pricing[0] <= grid[cx][cy] <= pricing[1]:\\n                k -= 1\\n                ans.append([cx, cy])\\n            \\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                nx = dx + cx\\n                ny = dy + cy\\n                \\n                if nx < 0 or nx >= M or ny < 0 or ny >= N or grid[nx][ny] == 0 or (nx, ny) in seen:\\n                    continue\\n                \\n                heapq.heappush(pq, (dist+1,  grid[nx][ny], nx, ny))\\n                \\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710535,
                "title": "c-clean-bfs-custom-sort-comparator",
                "content": "```\\nclass Solution {\\npublic:\\n    int arr[4]={1,-1,0,0};\\n    int b[4]={0,0,1,-1};\\n    bool isValid(vector<vector<int>>& grid,int x,int y)  // checking if cell is valid or not\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(x<0||x>=n||y<0||y>=m||grid[x][y]==0)\\n            return false;\\n        return true;\\n    }\\n    static bool comp(pair<int,pair<int,pair<int,int>>> a,pair<int,pair<int,pair<int,int>>> b)  custom sorting according to question\\n    {\\n        \\n        int row1=a.first,row2=b.first;\\n        int col1=a.second.first,col2=b.second.first;\\n        int dist1=a.second.second.first;\\n        int dist2=b.second.second.first;\\n        int val1=a.second.second.second;\\n        int val2=b.second.second.second;\\n        \\n        if(dist1!=dist2)\\n        {\\n            return dist1<dist2;\\n        }\\n        if(val1!=val2)\\n        {\\n            return val1<val2;\\n        }\\n        if(row1!=row2)\\n        {\\n            return row1<row2;\\n        }\\n        return col1<col2; \\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        \\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int visited[n][m];\\n        \\n        memset(visited,0,sizeof visited);\\n        \\n        queue<pair<int,pair<int,int>>> q;   // { x, { y, distance } }\\n        q.push({start[0],{start[1],0}});\\n        \\n        int left=pricing[0],right=pricing[1];\\n        \\n        vector<pair<int,pair<int,pair<int,int>>>> v;\\n        \\n        while(!q.empty())\\n        {  \\n            auto ok=q.front();\\n            q.pop();\\n            \\n            int x=ok.first;\\n            int y=ok.second.first;\\n            int dist=ok.second.second;\\n            \\n            visited[x][y]=1; \\n            if(grid[x][y]>=left&&grid[x][y]<=right)  // checking if cell value falls in given range\\n            {\\n                v.push_back({x,{y,{dist,grid[x][y]}}});\\n            }\\n            \\n            for(int i=0;i<4;i++)   // iterating over 4 directions\\n            {\\n                int x1=arr[i]+x;\\n                int y1=b[i]+y;\\n                if(isValid(grid,x1,y1)&&visited[x1][y1]==0)\\n                {\\n                    visited[x1][y1]=1;\\n                    q.push({x1,{y1,dist+1}});\\n                }\\n            }\\n        }\\n        sort(v.begin(),v.end(),comp);    // Custom sorting according to given priority in question\\n        vector<vector<int>> ans;\\n        for(int i=0;i<v.size()&&i<k;i++)\\n        {\\n            ans.push_back({v[i].first,v[i].second.first});      \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arr[4]={1,-1,0,0};\\n    int b[4]={0,0,1,-1};\\n    bool isValid(vector<vector<int>>& grid,int x,int y)  // checking if cell is valid or not\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(x<0||x>=n||y<0||y>=m||grid[x][y]==0)\\n            return false;\\n        return true;\\n    }\\n    static bool comp(pair<int,pair<int,pair<int,int>>> a,pair<int,pair<int,pair<int,int>>> b)  custom sorting according to question\\n    {\\n        \\n        int row1=a.first,row2=b.first;\\n        int col1=a.second.first,col2=b.second.first;\\n        int dist1=a.second.second.first;\\n        int dist2=b.second.second.first;\\n        int val1=a.second.second.second;\\n        int val2=b.second.second.second;\\n        \\n        if(dist1!=dist2)\\n        {\\n            return dist1<dist2;\\n        }\\n        if(val1!=val2)\\n        {\\n            return val1<val2;\\n        }\\n        if(row1!=row2)\\n        {\\n            return row1<row2;\\n        }\\n        return col1<col2; \\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        \\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int visited[n][m];\\n        \\n        memset(visited,0,sizeof visited);\\n        \\n        queue<pair<int,pair<int,int>>> q;   // { x, { y, distance } }\\n        q.push({start[0],{start[1],0}});\\n        \\n        int left=pricing[0],right=pricing[1];\\n        \\n        vector<pair<int,pair<int,pair<int,int>>>> v;\\n        \\n        while(!q.empty())\\n        {  \\n            auto ok=q.front();\\n            q.pop();\\n            \\n            int x=ok.first;\\n            int y=ok.second.first;\\n            int dist=ok.second.second;\\n            \\n            visited[x][y]=1; \\n            if(grid[x][y]>=left&&grid[x][y]<=right)  // checking if cell value falls in given range\\n            {\\n                v.push_back({x,{y,{dist,grid[x][y]}}});\\n            }\\n            \\n            for(int i=0;i<4;i++)   // iterating over 4 directions\\n            {\\n                int x1=arr[i]+x;\\n                int y1=b[i]+y;\\n                if(isValid(grid,x1,y1)&&visited[x1][y1]==0)\\n                {\\n                    visited[x1][y1]=1;\\n                    q.push({x1,{y1,dist+1}});\\n                }\\n            }\\n        }\\n        sort(v.begin(),v.end(),comp);    // Custom sorting according to given priority in question\\n        vector<vector<int>> ans;\\n        for(int i=0;i<v.size()&&i<k;i++)\\n        {\\n            ans.push_back({v[i].first,v[i].second.first});      \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710400,
                "title": "c-simple-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(const vector<int>& a, const vector<int>& b)\\n    {\\n        if(a[0]==b[0])\\n        {\\n            \\n            if(a[1]==b[1])\\n            {\\n                return a[2]<b[2];\\n            }\\n            return a[1]<b[1];\\n        }\\n        \\n        return a[0]<b[0];\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        visited[start[0]][start[1]]=true;\\n        vector<vector<int>> res;\\n        if(grid[start[0]][start[1]]>=pricing[0] && grid[start[0]][start[1]]<=pricing[1])\\n            res.push_back(vector<int>({start[0],start[1]}));\\n        queue<pair<int,int>> q;\\n        q.push(make_pair(start[0],start[1]));\\n        int dist=0;\\n        while(!q.empty())\\n        {\\n            vector<vector<int>> temp;\\n            for(int i=q.size()-1;i>=0;i--)\\n            {\\n                pair<int,int> k = q.front();\\n                q.pop();\\n                int x = k.first,y=k.second;\\n                \\n                if(x-1>=0 && visited[x-1][y]==false && grid[x-1][y]!=0)\\n                {\\n                    visited[x-1][y]=true;\\n                    if(grid[x-1][y]>=pricing[0] && grid[x-1][y]<=pricing[1])\\n                    {\\n                        temp.push_back(vector<int>({grid[x-1][y],x-1,y}));\\n                    }\\n                    q.push(make_pair(x-1,y));\\n                }\\n                if(x+1<n && visited[x+1][y]==false && grid[x+1][y]!=0)\\n                {\\n                    visited[x+1][y]=true;\\n                    if(grid[x+1][y]>=pricing[0] && grid[x+1][y]<=pricing[1])\\n                    {\\n                        temp.push_back(vector<int>({grid[x+1][y],x+1,y}));\\n                    }\\n                    q.push(make_pair(x+1,y));\\n                }\\n                if(y-1>=0 && visited[x][y-1]==false && grid[x][y-1]!=0)\\n                {\\n                    visited[x][y-1]=true;\\n                    if(grid[x][y-1]>=pricing[0] && grid[x][y-1]<=pricing[1])\\n                    {\\n                        temp.push_back(vector<int>({grid[x][y-1],x,y-1}));\\n                    }\\n                    q.push(make_pair(x,y-1));\\n                }\\n                if(y+1<m && visited[x][y+1]==false && grid[x][y+1]!=0)\\n                {\\n                    visited[x][y+1]=true;\\n                    if(grid[x][y+1]>=pricing[0] && grid[x][y+1]<=pricing[1])\\n                    {\\n                        temp.push_back(vector<int>({grid[x][y+1],x,y+1}));\\n                    }\\n                    q.push(make_pair(x,y+1));\\n                }\\n                \\n                \\n            }\\n            sort(temp.begin(),temp.end(),comp);\\n            for(auto j:temp)\\n                res.push_back(vector<int>{j[1],j[2]});\\n        }\\n        vector<vector<int>> kres;\\n        for(int i=0;i<k && i<res.size();i++)\\n            kres.push_back(res[i]);\\n        return kres;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(const vector<int>& a, const vector<int>& b)\\n    {\\n        if(a[0]==b[0])\\n        {\\n            \\n            if(a[1]==b[1])\\n            {\\n                return a[2]<b[2];\\n            }\\n            return a[1]<b[1];\\n        }\\n        \\n        return a[0]<b[0];\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        visited[start[0]][start[1]]=true;\\n        vector<vector<int>> res;\\n        if(grid[start[0]][start[1]]>=pricing[0] && grid[start[0]][start[1]]<=pricing[1])\\n            res.push_back(vector<int>({start[0],start[1]}));\\n        queue<pair<int,int>> q;\\n        q.push(make_pair(start[0],start[1]));\\n        int dist=0;\\n        while(!q.empty())\\n        {\\n            vector<vector<int>> temp;\\n            for(int i=q.size()-1;i>=0;i--)\\n            {\\n                pair<int,int> k = q.front();\\n                q.pop();\\n                int x = k.first,y=k.second;\\n                \\n                if(x-1>=0 && visited[x-1][y]==false && grid[x-1][y]!=0)\\n                {\\n                    visited[x-1][y]=true;\\n                    if(grid[x-1][y]>=pricing[0] && grid[x-1][y]<=pricing[1])\\n                    {\\n                        temp.push_back(vector<int>({grid[x-1][y],x-1,y}));\\n                    }\\n                    q.push(make_pair(x-1,y));\\n                }\\n                if(x+1<n && visited[x+1][y]==false && grid[x+1][y]!=0)\\n                {\\n                    visited[x+1][y]=true;\\n                    if(grid[x+1][y]>=pricing[0] && grid[x+1][y]<=pricing[1])\\n                    {\\n                        temp.push_back(vector<int>({grid[x+1][y],x+1,y}));\\n                    }\\n                    q.push(make_pair(x+1,y));\\n                }\\n                if(y-1>=0 && visited[x][y-1]==false && grid[x][y-1]!=0)\\n                {\\n                    visited[x][y-1]=true;\\n                    if(grid[x][y-1]>=pricing[0] && grid[x][y-1]<=pricing[1])\\n                    {\\n                        temp.push_back(vector<int>({grid[x][y-1],x,y-1}));\\n                    }\\n                    q.push(make_pair(x,y-1));\\n                }\\n                if(y+1<m && visited[x][y+1]==false && grid[x][y+1]!=0)\\n                {\\n                    visited[x][y+1]=true;\\n                    if(grid[x][y+1]>=pricing[0] && grid[x][y+1]<=pricing[1])\\n                    {\\n                        temp.push_back(vector<int>({grid[x][y+1],x,y+1}));\\n                    }\\n                    q.push(make_pair(x,y+1));\\n                }\\n                \\n                \\n            }\\n            sort(temp.begin(),temp.end(),comp);\\n            for(auto j:temp)\\n                res.push_back(vector<int>{j[1],j[2]});\\n        }\\n        vector<vector<int>> kres;\\n        for(int i=0;i<k && i<res.size();i++)\\n            kres.push_back(res[i]);\\n        return kres;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710006,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n   static bool cmp(vector<int>&v1,vector<int>&v2)\\n   {\\n       if(v1[3]!=v2[3]) return v1[3]<v2[3];\\n       if(v1[2]!=v2[2]) return v1[2]<v2[2];\\n       if(v1[0]!=v2[0]) return v1[0]<v2[0];\\n       return v1[1]<v2[1];\\n   }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>&mat, vector<int>& p, vector<int>& start, int k) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<pair<int,int>>dir={{-1,0},{1,0},{0,-1},{0,1}};\\n        queue<pair<int,int>>q;\\n        q.push({start[0],start[1]});\\n        int level=1;\\n        int dis[n][m];\\n        memset(dis,-1,sizeof(dis));\\n        int vis[n][m];\\n        memset(vis,-1,sizeof(vis));\\n        if(mat[start[0]][start[1]]>=p[0]&&mat[start[0]][start[1]]<=p[1])\\n        {\\n            dis[start[0]][start[1]]=0;\\n        }\\n        vis[start[0]][start[1]]=1;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                for(auto it:dir)\\n                {\\n                    int nx=temp.first+it.first;\\n                    int ny=temp.second+it.second;\\n                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&dis[nx][ny]==-1&&vis[nx][ny]==-1&&mat[nx][ny]!=0)\\n                    {\\n                        q.push({nx,ny});\\n                        if(mat[nx][ny]>=p[0]&&mat[nx][ny]<=p[1])\\n                        dis[nx][ny]=level;\\n                        else\\n                        {\\n                            vis[nx][ny]=1;\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        vector<vector<int>>ans,ans1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dis[i][j]!=-1)\\n                {\\n                    ans.push_back({i,j,mat[i][j],dis[i][j]});\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end(),cmp);\\n        for(auto it:ans)\\n        {\\n            ans1.push_back({it[0],it[1]});\\n            if(ans1.size()==k)\\n            {\\n                break;\\n            }\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool cmp(vector<int>&v1,vector<int>&v2)\\n   {\\n       if(v1[3]!=v2[3]) return v1[3]<v2[3];\\n       if(v1[2]!=v2[2]) return v1[2]<v2[2];\\n       if(v1[0]!=v2[0]) return v1[0]<v2[0];\\n       return v1[1]<v2[1];\\n   }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>&mat, vector<int>& p, vector<int>& start, int k) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<pair<int,int>>dir={{-1,0},{1,0},{0,-1},{0,1}};\\n        queue<pair<int,int>>q;\\n        q.push({start[0],start[1]});\\n        int level=1;\\n        int dis[n][m];\\n        memset(dis,-1,sizeof(dis));\\n        int vis[n][m];\\n        memset(vis,-1,sizeof(vis));\\n        if(mat[start[0]][start[1]]>=p[0]&&mat[start[0]][start[1]]<=p[1])\\n        {\\n            dis[start[0]][start[1]]=0;\\n        }\\n        vis[start[0]][start[1]]=1;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                for(auto it:dir)\\n                {\\n                    int nx=temp.first+it.first;\\n                    int ny=temp.second+it.second;\\n                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&dis[nx][ny]==-1&&vis[nx][ny]==-1&&mat[nx][ny]!=0)\\n                    {\\n                        q.push({nx,ny});\\n                        if(mat[nx][ny]>=p[0]&&mat[nx][ny]<=p[1])\\n                        dis[nx][ny]=level;\\n                        else\\n                        {\\n                            vis[nx][ny]=1;\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        vector<vector<int>>ans,ans1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dis[i][j]!=-1)\\n                {\\n                    ans.push_back({i,j,mat[i][j],dis[i][j]});\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end(),cmp);\\n        for(auto it:ans)\\n        {\\n            ans1.push_back({it[0],it[1]});\\n            if(ans1.size()==k)\\n            {\\n                break;\\n            }\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709752,
                "title": "bfs-sort-javasript",
                "content": "// It is better use heap hear instead sort.\\n\\n```\\nvar highestRankedKItems = function(grid, pricing, start, k) {\\n    let allReacheableItems = []\\n    \\n    let n = grid.length\\n    let m = grid[0].length\\n    \\n    let queue = [start]\\n    let visited = getVisited(grid)\\n    \\n    let dist = 0\\n    while(queue.length){\\n        let newQ = []\\n        for(let i = 0; i < queue.length; i++){\\n            let c = queue[i]\\n            if(visited[c[0]][c[1]]){\\n                continue;\\n            }\\n            visited[c[0]][c[1]] = true\\n            let val = grid[c[0]][c[1]]\\n            if(val > 1 && isInRange(pricing, val)){\\n                allReacheableItems.push([c[0], c[1], val, dist])\\n            }\\n\\n            const nextMoves = getNextMoves(grid, c)\\n            nextMoves.forEach(nm => {\\n                newQ.push(nm)\\n            })\\n        }\\n        dist++\\n        queue = newQ\\n    }\\n    allReacheableItems.sort((s1, s2) => {\\n        if(s1[3] !== s2[3]){\\n            return s1[3] - s2[3]\\n        }\\n        if(s1[2] !== s2[2]){\\n            return s1[2]- s2[2]\\n        }\\n        if(s1[0] !== s2[0]){\\n            return s1[0]-s2[0]\\n        }\\n        return s1[1]-s2[1]\\n    })\\n    allReacheableItems = allReacheableItems.map(i => [i[0], i[1]])\\n    \\n    \\n\\n    \\n    if(allReacheableItems.length < k){\\n        return allReacheableItems\\n    }\\n    \\n    return allReacheableItems.slice(0, k)\\n};\\n\\nfunction getVisited(grid){\\n    let n = grid.length\\n    let m = grid[0].length\\n    let visited = new Array(n)\\n    for(let i = 0; i < n; i++){\\n        visited[i] = new Array(m).fill(false)\\n    }\\n    \\n    return visited\\n}\\n\\nfunction isInRange(pricing, value){\\n    return value <= pricing[1] && value >= pricing[0] \\n}\\n\\nconst moves = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n\\nfunction getNextMoves(grid, c){\\n    let r = grid.length\\n    let col = grid[0].length\\n    \\n    return moves.map(m => [m[0] + c[0], m[1] + c[1]]).filter(m => {\\n        return m[0] < r && m[0] >= 0 && m[1] < col && m[1] >=0 && grid[m[0]][m[1]] !== 0\\n    })\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar highestRankedKItems = function(grid, pricing, start, k) {\\n    let allReacheableItems = []\\n    \\n    let n = grid.length\\n    let m = grid[0].length\\n    \\n    let queue = [start]\\n    let visited = getVisited(grid)\\n    \\n    let dist = 0\\n    while(queue.length){\\n        let newQ = []\\n        for(let i = 0; i < queue.length; i++){\\n            let c = queue[i]\\n            if(visited[c[0]][c[1]]){\\n                continue;\\n            }\\n            visited[c[0]][c[1]] = true\\n            let val = grid[c[0]][c[1]]\\n            if(val > 1 && isInRange(pricing, val)){\\n                allReacheableItems.push([c[0], c[1], val, dist])\\n            }\\n\\n            const nextMoves = getNextMoves(grid, c)\\n            nextMoves.forEach(nm => {\\n                newQ.push(nm)\\n            })\\n        }\\n        dist++\\n        queue = newQ\\n    }\\n    allReacheableItems.sort((s1, s2) => {\\n        if(s1[3] !== s2[3]){\\n            return s1[3] - s2[3]\\n        }\\n        if(s1[2] !== s2[2]){\\n            return s1[2]- s2[2]\\n        }\\n        if(s1[0] !== s2[0]){\\n            return s1[0]-s2[0]\\n        }\\n        return s1[1]-s2[1]\\n    })\\n    allReacheableItems = allReacheableItems.map(i => [i[0], i[1]])\\n    \\n    \\n\\n    \\n    if(allReacheableItems.length < k){\\n        return allReacheableItems\\n    }\\n    \\n    return allReacheableItems.slice(0, k)\\n};\\n\\nfunction getVisited(grid){\\n    let n = grid.length\\n    let m = grid[0].length\\n    let visited = new Array(n)\\n    for(let i = 0; i < n; i++){\\n        visited[i] = new Array(m).fill(false)\\n    }\\n    \\n    return visited\\n}\\n\\nfunction isInRange(pricing, value){\\n    return value <= pricing[1] && value >= pricing[0] \\n}\\n\\nconst moves = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n\\nfunction getNextMoves(grid, c){\\n    let r = grid.length\\n    let col = grid[0].length\\n    \\n    return moves.map(m => [m[0] + c[0], m[1] + c[1]]).filter(m => {\\n        return m[0] < r && m[0] >= 0 && m[1] < col && m[1] >=0 && grid[m[0]][m[1]] !== 0\\n    })\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709732,
                "title": "bfs-solution-in-python",
                "content": "This is a BFS problem.\\nFirst, you want to calculate the distance from the start position for every reachable grid. After getting the distance, you just put the tuple data (distance, price, row, col) into a list, and just sort. This automatically sorts the data into desirable order. Note that the (distance == infinity) means that the cell in not reachable from the start position and you don\\'t want to include that in the answer.\\n\\nTime: O(NlogN) (N = R * C)\\nSpace: O(N)\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        def in_range(i, j):\\n            return 0 <= i < R and 0 <= j < C and grid[i][j] != 0\\n        \\n        R, C = len(grid), len(grid[0])\\n        dist = [[float(\\'inf\\') for _ in range(C)] for _ in range(R)]\\n        \\n        queue = deque()\\n        queue.append((0, start))\\n        dist[start[0]][start[1]] = 0\\n        moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        \\n        while queue:\\n            curr_dist, (i, j) = queue.popleft()\\n            for move_i, move_j in moves:\\n                new_i, new_j = i + move_i, j + move_j\\n                if in_range(new_i, new_j) and dist[new_i][new_j] == math.inf:\\n                    dist[new_i][new_j] = curr_dist + 1\\n                    queue.append((curr_dist + 1, (new_i, new_j)))\\n        \\n        data = []\\n        for i in range(R):\\n            for j in range(C):\\n                if pricing[0] <= grid[i][j] <= pricing[1] and dist[i][j] != math.inf:\\n                    data.append((dist[i][j], grid[i][j], i, j))\\n        \\n        return [[i, j] for (_, _, i, j) in sorted(data)[:k]]\\n```\\n\\nBelow is a bit efficient version because it stops processing when you get k data.\\n```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        def in_range(i, j):\\n            return 0 <= i < R and 0 <= j < C and grid[i][j] != 0\\n        \\n        R, C = len(grid), len(grid[0])\\n        dist = [[float(\\'inf\\') for _ in range(C)] for _ in range(R)]\\n        \\n        queue = deque()\\n        queue.append((0, start))\\n        dist[start[0]][start[1]] = 0\\n        moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        get_items = 0\\n        farthest_dist = 0\\n        dist_dict = defaultdict(list)\\n        low, high = pricing\\n        \\n        while queue:\\n            curr_dist, (i, j) = queue.popleft()\\n            if grid[i][j] != 1 and low <= grid[i][j] <= high:\\n                get_items += 1\\n                dist_dict[curr_dist].append((grid[i][j], i, j))\\n                if get_items == k:\\n                    farthest_dist = curr_dist\\n            if farthest_dist != 0 and curr_dist > farthest_dist:\\n                break\\n            for move_i, move_j in moves:\\n                new_i, new_j = i + move_i, j + move_j\\n                if in_range(new_i, new_j) and dist[new_i][new_j] == math.inf:\\n                    dist[new_i][new_j] = curr_dist + 1\\n                    queue.append((curr_dist + 1, (new_i, new_j)))\\n        \\n        res = []\\n        cnt = 0\\n        \\n        for d in sorted(dist_dict.keys()):\\n            data = dist_dict[d]\\n            for price, i, j in sorted(data):\\n                res.append([i, j])\\n                cnt += 1\\n                if cnt == k:\\n                    return res\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        def in_range(i, j):\\n            return 0 <= i < R and 0 <= j < C and grid[i][j] != 0\\n        \\n        R, C = len(grid), len(grid[0])\\n        dist = [[float(\\'inf\\') for _ in range(C)] for _ in range(R)]\\n        \\n        queue = deque()\\n        queue.append((0, start))\\n        dist[start[0]][start[1]] = 0\\n        moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        \\n        while queue:\\n            curr_dist, (i, j) = queue.popleft()\\n            for move_i, move_j in moves:\\n                new_i, new_j = i + move_i, j + move_j\\n                if in_range(new_i, new_j) and dist[new_i][new_j] == math.inf:\\n                    dist[new_i][new_j] = curr_dist + 1\\n                    queue.append((curr_dist + 1, (new_i, new_j)))\\n        \\n        data = []\\n        for i in range(R):\\n            for j in range(C):\\n                if pricing[0] <= grid[i][j] <= pricing[1] and dist[i][j] != math.inf:\\n                    data.append((dist[i][j], grid[i][j], i, j))\\n        \\n        return [[i, j] for (_, _, i, j) in sorted(data)[:k]]\\n```\n```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        def in_range(i, j):\\n            return 0 <= i < R and 0 <= j < C and grid[i][j] != 0\\n        \\n        R, C = len(grid), len(grid[0])\\n        dist = [[float(\\'inf\\') for _ in range(C)] for _ in range(R)]\\n        \\n        queue = deque()\\n        queue.append((0, start))\\n        dist[start[0]][start[1]] = 0\\n        moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        get_items = 0\\n        farthest_dist = 0\\n        dist_dict = defaultdict(list)\\n        low, high = pricing\\n        \\n        while queue:\\n            curr_dist, (i, j) = queue.popleft()\\n            if grid[i][j] != 1 and low <= grid[i][j] <= high:\\n                get_items += 1\\n                dist_dict[curr_dist].append((grid[i][j], i, j))\\n                if get_items == k:\\n                    farthest_dist = curr_dist\\n            if farthest_dist != 0 and curr_dist > farthest_dist:\\n                break\\n            for move_i, move_j in moves:\\n                new_i, new_j = i + move_i, j + move_j\\n                if in_range(new_i, new_j) and dist[new_i][new_j] == math.inf:\\n                    dist[new_i][new_j] = curr_dist + 1\\n                    queue.append((curr_dist + 1, (new_i, new_j)))\\n        \\n        res = []\\n        cnt = 0\\n        \\n        for d in sorted(dist_dict.keys()):\\n            data = dist_dict[d]\\n            for price, i, j in sorted(data):\\n                res.append([i, j])\\n                cnt += 1\\n                if cnt == k:\\n                    return res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709674,
                "title": "multiset-of-vector-bfs",
                "content": "Starting BFS from the starting cell, \\nPush the rank determining factors in a multiset/Priority Queue.\\n\\n```\\nconstexpr int INF = 1e9;\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& p, vector<int>& s, int k) {\\n      int dx[4] = {1,-1,0,0};\\n      int dy[4] = {0,0,-1,1};\\n      queue<pair<int,int>> q;\\n\\t  \\n\\t  // does the sorting part automatically \\n      multiset<vector<int>> ms;\\n\\t  \\n\\t  //starting cell pushed in BFS queue\\n      q.push({s[0],s[1]});\\n\\t  \\n      int n = grid.size();\\n      int m = grid[0].size();\\n\\t  // distance vector to store minimum distance of every cell from starting cell\\n      vector<vector<int>> dis(n,vector<int> (m,INF));\\n\\t  // lower and upper bounds on pricing\\n      int l = p[0];\\n      int r = p[1];\\n\\t  \\n\\t  // starting cell has distance 0 \\n      dis[s[0]][s[1]] = 0;\\n\\t  \\n\\t  // if the starting cell meets the condition to be in the potential answer vector\\n      if(grid[s[0]][s[1]]!=0 and grid[s[0]][s[1]]>=l and grid[s[0]][s[1]]<=r) ms.insert(vector<int>{0,grid[s[0]][s[1]],s[0],s[1]});\\n\\t  \\n\\t  // bfs\\n\\t  \\n      while(!q.empty()){\\n            auto [x,y] = q.front();\\n            q.pop();\\n            for(int i =0; i < 4 ;i ++){\\n              int xx = x+dx[i];\\n              int yy = y+dy[i];\\n              if(xx>=0 and xx<n and yy>=0 and yy<m and dis[xx][yy]==INF and grid[xx][yy]!=0 ){\\n                dis[xx][yy] = 1 + dis[x][y];\\n                q.push({xx,yy});\\n                if(grid[xx][yy]>=l and grid[xx][yy] <=r ){\\n                  ms.insert(vector<int>{dis[xx][yy],grid[xx][yy],xx,yy});\\n                 } \\n                }\\n              }\\n          }\\n      vector<vector<int>> ans;\\n        for(auto x:ms){\\n          {\\n            ans.push_back({x[2],x[3]});   /* push min(total,k) cordinates in the answer vector*/\\n            if(ans.size()==k) break;\\n          }\\n        }\\n        return ans;\\n     } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconstexpr int INF = 1e9;\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& p, vector<int>& s, int k) {\\n      int dx[4] = {1,-1,0,0};\\n      int dy[4] = {0,0,-1,1};\\n      queue<pair<int,int>> q;\\n\\t  \\n\\t  // does the sorting part automatically \\n      multiset<vector<int>> ms;\\n\\t  \\n\\t  //starting cell pushed in BFS queue\\n      q.push({s[0],s[1]});\\n\\t  \\n      int n = grid.size();\\n      int m = grid[0].size();\\n\\t  // distance vector to store minimum distance of every cell from starting cell\\n      vector<vector<int>> dis(n,vector<int> (m,INF));\\n\\t  // lower and upper bounds on pricing\\n      int l = p[0];\\n      int r = p[1];\\n\\t  \\n\\t  // starting cell has distance 0 \\n      dis[s[0]][s[1]] = 0;\\n\\t  \\n\\t  // if the starting cell meets the condition to be in the potential answer vector\\n      if(grid[s[0]][s[1]]!=0 and grid[s[0]][s[1]]>=l and grid[s[0]][s[1]]<=r) ms.insert(vector<int>{0,grid[s[0]][s[1]],s[0],s[1]});\\n\\t  \\n\\t  // bfs\\n\\t  \\n      while(!q.empty()){\\n            auto [x,y] = q.front();\\n            q.pop();\\n            for(int i =0; i < 4 ;i ++){\\n              int xx = x+dx[i];\\n              int yy = y+dy[i];\\n              if(xx>=0 and xx<n and yy>=0 and yy<m and dis[xx][yy]==INF and grid[xx][yy]!=0 ){\\n                dis[xx][yy] = 1 + dis[x][y];\\n                q.push({xx,yy});\\n                if(grid[xx][yy]>=l and grid[xx][yy] <=r ){\\n                  ms.insert(vector<int>{dis[xx][yy],grid[xx][yy],xx,yy});\\n                 } \\n                }\\n              }\\n          }\\n      vector<vector<int>> ans;\\n        for(auto x:ms){\\n          {\\n            ans.push_back({x[2],x[3]});   /* push min(total,k) cordinates in the answer vector*/\\n            if(ans.size()==k) break;\\n          }\\n        }\\n        return ans;\\n     } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908917,
                "title": "java-accepted-solution-priorityqueue-bfs",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        \\n        PriorityQueue<node> pq=new PriorityQueue<>((a,b)->{\\n            if(a.steps!=b.steps){\\n                return b.steps-a.steps;\\n            }\\n            else{\\n                int val1=grid[a.i][a.j];\\n                int val2=grid[b.i][b.j];\\n                if(val1!=val2){\\n                    return val2-val1;\\n                }\\n                else{\\n                    if(a.i!=b.i){\\n                        return b.i-a.i;\\n                    }\\n                    else{\\n                        return b.j-a.j;\\n                    }\\n                }\\n                \\n            }\\n        });\\n        \\n        LinkedList<node> q=new LinkedList<>();\\n        q.add(new node(start[0],start[1],0));\\n        boolean[][] visited=new boolean[m][n];\\n        visited[start[0]][start[1]]=true;\\n        int[][] dir={{-1,0},{1,0},{0,-1},{0,1}};\\n        \\n        while(!q.isEmpty()){\\n            node temp=q.removeFirst();\\n            int price=grid[temp.i][temp.j];\\n            if(price!=1 && pricing[0]<=price && price<=pricing[1]){\\n                pq.add(temp);\\n                if(pq.size()>k){\\n                    pq.remove();\\n                }\\n            }\\n            \\n            for(int i=0;i<4;i++){\\n                int x=dir[i][0]+temp.i;\\n                int y=dir[i][1]+temp.j;\\n                \\n                if(x<0 || y<0 || x==m || y==n || visited[x][y] || grid[x][y]==0){\\n                    continue;\\n                }\\n                \\n                visited[x][y]=true;\\n                q.add(new node(x,y,temp.steps+1));\\n            }\\n        }\\n        \\n        while(pq.size()>0){\\n            node temp=pq.remove();\\n            List<Integer> l=new LinkedList<>();\\n            l.add(temp.i);\\n            l.add(temp.j);\\n            res.add(l);\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n    \\n}\\n\\nclass node{\\n        int steps;\\n        int i;\\n        int j;\\n        public node(int i,int j,int steps){\\n            this.i=i;\\n            this.j=j;\\n            this.steps=steps;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        \\n        PriorityQueue<node> pq=new PriorityQueue<>((a,b)->{\\n            if(a.steps!=b.steps){\\n                return b.steps-a.steps;\\n            }\\n            else{\\n                int val1=grid[a.i][a.j];\\n                int val2=grid[b.i][b.j];\\n                if(val1!=val2){\\n                    return val2-val1;\\n                }\\n                else{\\n                    if(a.i!=b.i){\\n                        return b.i-a.i;\\n                    }\\n                    else{\\n                        return b.j-a.j;\\n                    }\\n                }\\n                \\n            }\\n        });\\n        \\n        LinkedList<node> q=new LinkedList<>();\\n        q.add(new node(start[0],start[1],0));\\n        boolean[][] visited=new boolean[m][n];\\n        visited[start[0]][start[1]]=true;\\n        int[][] dir={{-1,0},{1,0},{0,-1},{0,1}};\\n        \\n        while(!q.isEmpty()){\\n            node temp=q.removeFirst();\\n            int price=grid[temp.i][temp.j];\\n            if(price!=1 && pricing[0]<=price && price<=pricing[1]){\\n                pq.add(temp);\\n                if(pq.size()>k){\\n                    pq.remove();\\n                }\\n            }\\n            \\n            for(int i=0;i<4;i++){\\n                int x=dir[i][0]+temp.i;\\n                int y=dir[i][1]+temp.j;\\n                \\n                if(x<0 || y<0 || x==m || y==n || visited[x][y] || grid[x][y]==0){\\n                    continue;\\n                }\\n                \\n                visited[x][y]=true;\\n                q.add(new node(x,y,temp.steps+1));\\n            }\\n        }\\n        \\n        while(pq.size()>0){\\n            node temp=pq.remove();\\n            List<Integer> l=new LinkedList<>();\\n            l.add(temp.i);\\n            l.add(temp.j);\\n            res.add(l);\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n    \\n}\\n\\nclass node{\\n        int steps;\\n        int i;\\n        int j;\\n        public node(int i,int j,int steps){\\n            this.i=i;\\n            this.j=j;\\n            this.steps=steps;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549708,
                "title": "well-explained-commented-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& p, vector<int>& s, int k)\\n{\\n     vector<vector<int>> res;\\n     vector<vector<int>> ans;\\n     int n = grid.size() , m  = grid[0].size(); \\n     vector<vector<int>> v(n,vector<int>(m,0)); // visited array \\n\\n     int l = p[0] , u = p[1] ; // range of price \\n      if(grid[s[0]][s[1]]<=u && grid[s[0]][s[1]]>=l) // if the starting point is in the price range \\n      {\\n          res.push_back({0,grid[s[0]][s[1]],s[0],s[1]});\\n      }\\n     queue<pair<int,pair<int,int>>> q; // {step,{row,col}}\\n     q.push({0,{s[0],s[1]}});\\n     v[s[0]][s[1]] = 1; \\n     int dr[]  = {1,-1,0,0};\\n     int dc[]  = {0,0,1,-1};// both array for adjacent traversal in matrix \\n\\n     while(q.size())\\n     {\\n         int step = q.front().first;\\n         int row = q.front().second.first;\\n         int col = q.front().second.second;\\n         q.pop();\\n         for(int i = 0 ; i<4;i++)\\n         {\\n             int nr = row + dr[i];\\n             int nc = col + dc[i];\\n             if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]!=0 && v[nr][nc]==0)\\n             {\\n                 q.push({step+1,{nr,nc}});\\n                 v[nr][nc] =1; \\n                 if(grid[nr][nc]!=1 && grid[nr][nc]>=l && grid[nr][nc]<=u ) // we only push if price is under \\n//limit and for price outside limit we just traverse across to go to other cell\\n                 {\\n                     res.push_back({step+1,grid[nr][nc],nr,nc});//{step,price,row,col}\\n                 }\\n             }\\n         }\\n      }\\n\\n      sort(res.begin(),res.end());\\n      for(int i = 0; i<res.size() && k; i++,k--)\\n      ans.push_back({res[i][2],res[i][3]});\\n      return ans; \\n\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& p, vector<int>& s, int k)\\n{\\n     vector<vector<int>> res;\\n     vector<vector<int>> ans;\\n     int n = grid.size() , m  = grid[0].size(); \\n     vector<vector<int>> v(n,vector<int>(m,0)); // visited array \\n\\n     int l = p[0] , u = p[1] ; // range of price \\n      if(grid[s[0]][s[1]]<=u && grid[s[0]][s[1]]>=l) // if the starting point is in the price range \\n      {\\n          res.push_back({0,grid[s[0]][s[1]],s[0],s[1]});\\n      }\\n     queue<pair<int,pair<int,int>>> q; // {step,{row,col}}\\n     q.push({0,{s[0],s[1]}});\\n     v[s[0]][s[1]] = 1; \\n     int dr[]  = {1,-1,0,0};\\n     int dc[]  = {0,0,1,-1};// both array for adjacent traversal in matrix \\n\\n     while(q.size())\\n     {\\n         int step = q.front().first;\\n         int row = q.front().second.first;\\n         int col = q.front().second.second;\\n         q.pop();\\n         for(int i = 0 ; i<4;i++)\\n         {\\n             int nr = row + dr[i];\\n             int nc = col + dc[i];\\n             if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]!=0 && v[nr][nc]==0)\\n             {\\n                 q.push({step+1,{nr,nc}});\\n                 v[nr][nc] =1; \\n                 if(grid[nr][nc]!=1 && grid[nr][nc]>=l && grid[nr][nc]<=u ) // we only push if price is under \\n//limit and for price outside limit we just traverse across to go to other cell\\n                 {\\n                     res.push_back({step+1,grid[nr][nc],nr,nc});//{step,price,row,col}\\n                 }\\n             }\\n         }\\n      }\\n\\n      sort(res.begin(),res.end());\\n      for(int i = 0; i<res.size() && k; i++,k--)\\n      ans.push_back({res[i][2],res[i][3]});\\n      return ans; \\n\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162614,
                "title": "c-bfs-well-commented",
                "content": "class Solution\\n{\\npublic:\\n    //       USING BFS\\n\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>> &grid, vector<int> &pricing, vector<int> &start, int k)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //          MAKE DP TO CHECK THAT WE DO NOT REVISIT THE SAME INDEX\\n        //          IF WE VISIT THAT  INDEX WE MAKE IT TRUE\\n        vector<vector<int>> dp(n, vector<int>(m, 0));\\n\\n        int array1[4] = {0, 0, 1, -1};\\n        int array2[4] = {1, -1, 0, 0};\\n\\n        //         IN THIS ARRAY WE STORE\\n        //      ({DISTANCE , PRICE , ROW INDEX , COLUM INDEX })\\n        vector<vector<int>> v;\\n        int distance = 0;\\n        queue<pair<int, int>> q;\\n        //         PUSH STARTING INDEX IN QUEUE\\n        q.push(make_pair(start[0], start[1]));\\n        int xx = start[0];\\n        int yy = start[1];\\n        //         CHECKING IF WE PUSH STARING INDEX IN OUR VECTOR\\n        if (xx >= 0 && yy >= 0 && xx < n && yy < m && dp[xx][yy] == 0 && grid[xx][yy] >= pricing[0] && grid[xx][yy] <= pricing[1])\\n        {\\n\\n            v.push_back({0, grid[xx][yy], xx, yy});\\n        }\\n        //         MAKING OUR STARTING INDEX TRUE IN OUT DP ARRAY\\n        dp[start[0]][start[1]] = 1;\\n\\n        //          SIMPLE BFS AND CHECKING THE SAME CONDITION THAT WE CHECK FOR OUR STARTING INDEX\\n        while (!q.empty())\\n        {\\n            distance += 1;\\n\\n            int size = q.size();\\n            for (int i = 0; i < size; i++)\\n            {\\n                int a = q.front().first;\\n                int b = q.front().second;\\n                q.pop();\\n\\n                for (int j = 0; j < 4; j++)\\n                {\\n                    int x = a + array1[j];\\n                    int y = b + array2[j];\\n                    //                   CONDTION CHECK\\n                    if (x >= 0 && y >= 0 && x < n && y < m && dp[x][y] == 0 && grid[x][y] >= pricing[0] && grid[x][y] <= pricing[1])\\n                    {\\n\\n                        q.push(make_pair(x, y));\\n                        dp[x][y] = 1;\\n                        v.push_back({distance, grid[x][y], x, y});\\n\\n                        //       IF OUR CONDITION IS FAIL\\n                        //          IF NOT VISITED  AND GRID[X][Y] IS NOT EQUAL TO ZERO THAN WE MOVE TO THAT INDEX, THAT\\'S WHY WE PUSH IT IN QUEUE BUT NOT IN OUR VECTOR v\\n                    }\\n                    else if (x >= 0 && y >= 0 && x < n && y < m && grid[x][y] != 0 && dp[x][y] == 0)\\n                    {\\n\\n                        dp[x][y] = 1;\\n                        q.push(make_pair(x, y));\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n        //          sort our vector v to get our minimum ans  according to question conditions\\n        sort(v.begin(), v.end());\\n\\n        int tt = v.size();\\n\\n        int p = min(k, tt);\\n        for (int i = 0; i < p; i++)\\n        {\\n            ans.push_back({v[i][2], v[i][3]});\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution\\n{\\npublic:\\n    //       USING BFS\\n\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>> &grid, vector<int> &pricing, vector<int> &start, int k)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //          MAKE DP TO CHECK THAT WE DO NOT REVISIT THE SAME INDEX\\n        //          IF WE VISIT THAT  INDEX WE MAKE IT TRUE\\n        vector<vector<int>> dp(n, vector<int>(m, 0));\\n\\n        int array1[4] = {0, 0, 1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 1842158,
                "title": "c-detailed-bfs-solution-2146",
                "content": "**Why using BFS -->**\\nWe need to choose atmost K valid points from the given grid and the final result must be sorted first according to the distance from the starting position given, so if we do BFS we will get the points in order of increasing distance into the queue hence if we got atleast K valid points then we can stop the BFS process so that run time becomes optimal.\\n**Sorting process -->**\\nThe final points must be sorted as per given rules \\n1. distance\\n2. price\\n3. row\\n4. col\\n\\n\\nSo if we store all valid points in a vector in this order it will be easier to sort the array. So while storing each valid point we store in the the form of [distance,price,i,j].\\n**After Storing -->**\\nWe need atmost K points in the result and we may have more than or less than K valid points sorted as per given conditions\\n```K = min(K,number of valid points we got);```\\nalso we have the distance and price values for each point in the sorted array. We create a new array then store the required result.\\n```res[i] = {validPoints[2],validPoints[3]};```\\n\\n```\\nclass Solution {\\npublic:\\n    int rows,cols,low,high;\\n    bool isValid(int price){\\n        return (price>=low && price<=high);\\n    }\\n    bool isInside(int i,int j){\\n        return (i>=0 && j>=0 && i<rows && j<cols);\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        rows = grid.size(); cols = grid[0].size(); low = pricing[0]; high = pricing[1];\\n        int startR = start[0],startC = start[1];\\n        queue<pair<int,int>>q;\\n        vector<vector<int>>valid;\\n        int x = startR,y = startC,distance = 0,price = grid[x][y];\\n        q.push({x,y});\\n        if(isValid(price)){valid.push_back({distance,price,x,y});}\\n        grid[x][y] = 0;\\n        int size;\\n        int dir[] = {-1,0,1,0,-1};\\n        while(!q.empty() && valid.size()<k){\\n            size = q.size(); distance++;\\n            while(size--){\\n                auto [i,j] = q.front();\\n                for(int k=0;k<4;k++){\\n                    x = i + dir[k]; y = j + dir[k+1];\\n                    if(isInside(x,y) && grid[x][y]>0){\\n                        q.push({x,y});\\n                        price = grid[x][y];\\n                        if(isValid(price)){valid.push_back({distance,price,x,y});}\\n                        grid[x][y] = 0;\\n                    }\\n                }\\n                q.pop();\\n            }\\n        }\\n        sort(valid.begin(),valid.end());\\n        k = min(k,(int)valid.size());\\n        vector<vector<int>>res(k);\\n        for(int i=0;i<k;i++){res[i] = {valid[i][2],valid[i][3]};}\\n        return res;\\n    }\\n};\\n```\\n\\nFeel free to comment your queries if any\\n**Upvote** if found useful\\n**Thank You :)**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```K = min(K,number of valid points we got);```\n```res[i] = {validPoints[2],validPoints[3]};```\n```\\nclass Solution {\\npublic:\\n    int rows,cols,low,high;\\n    bool isValid(int price){\\n        return (price>=low && price<=high);\\n    }\\n    bool isInside(int i,int j){\\n        return (i>=0 && j>=0 && i<rows && j<cols);\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        rows = grid.size(); cols = grid[0].size(); low = pricing[0]; high = pricing[1];\\n        int startR = start[0],startC = start[1];\\n        queue<pair<int,int>>q;\\n        vector<vector<int>>valid;\\n        int x = startR,y = startC,distance = 0,price = grid[x][y];\\n        q.push({x,y});\\n        if(isValid(price)){valid.push_back({distance,price,x,y});}\\n        grid[x][y] = 0;\\n        int size;\\n        int dir[] = {-1,0,1,0,-1};\\n        while(!q.empty() && valid.size()<k){\\n            size = q.size(); distance++;\\n            while(size--){\\n                auto [i,j] = q.front();\\n                for(int k=0;k<4;k++){\\n                    x = i + dir[k]; y = j + dir[k+1];\\n                    if(isInside(x,y) && grid[x][y]>0){\\n                        q.push({x,y});\\n                        price = grid[x][y];\\n                        if(isValid(price)){valid.push_back({distance,price,x,y});}\\n                        grid[x][y] = 0;\\n                    }\\n                }\\n                q.pop();\\n            }\\n        }\\n        sort(valid.begin(),valid.end());\\n        k = min(k,(int)valid.size());\\n        vector<vector<int>>res(k);\\n        for(int i=0;i<k;i++){res[i] = {valid[i][2],valid[i][3]};}\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725444,
                "title": "please-help-in-debugging",
                "content": "So when we have to find k max elements we implement a min heap and keep on adding elements to the heap, and when we have more than k elenents in the heap we pop from the heap. I am implementing same concept here but with custom priority. \\nBut I am getting **TLE** on the corner case of m*n=1e5 with all cells 2; k=m*n.\\nI think time complexity of my solution is **O(m * n * logk)**\\n\\n```\\nclass Solution {\\npublic:\\n    struct cmp{ // comparator for priority queue\\n        bool operator()(vector<int> &a, vector<int> &b){\\n            if(a[0]<b[0])return true;\\n            if(a[0]==b[0]){\\n                if(a[1]<b[1])return true;\\n                if(a[1]==b[1]){\\n                    if(a[2]<b[2])return true;\\n                    if(a[2]==b[2]){\\n                        return a[3]<b[3];\\n                    }\\n                    return false;\\n                }\\n                return false;\\n            }\\n            return false;\\n        }  \\n    };\\n    \\n    vector<int> X={0,0,1,-1}, Y={1,-1,0,0};\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& g, vector<int>& pricing, vector<int>& start, int k) {\\n        int lo=pricing[0], hi=pricing[1];\\n        priority_queue<vector<int>, vector<vector<int>>, cmp> pq;\\n        int n=g.size(), m=g[0].size();\\n        queue<vector<int>> q;\\n        q.push({0,g[start[0]][start[1]], start[0], start[1]});\\n        g[start[0]][start[1]]*=-1;\\n        while(!q.empty()){ // BFS\\n            auto t=q.front();\\n            q.pop();\\n            int dist=t[0], val=t[1], x=t[2], y=t[3];\\n            if(val>=lo && val<=hi)pq.push({dist,val,x,y});\\n            if(pq.size()>k)pq.pop(); // if there are more than k elements in the pq, pop from it\\n            for(int i=0; i<4; i++){\\n                int newx=x+X[i], newy=y+Y[i];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && g[newx][newy]!=0){\\n                    q.push({dist+1,g[newx][newy],newx,newy});\\n                    g[newx][newy]=0;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty()){\\n            auto t= pq.top();\\n            pq.pop();\\n            ans.push_back({t[2],t[3]});\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\nThanks in advance !",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct cmp{ // comparator for priority queue\\n        bool operator()(vector<int> &a, vector<int> &b){\\n            if(a[0]<b[0])return true;\\n            if(a[0]==b[0]){\\n                if(a[1]<b[1])return true;\\n                if(a[1]==b[1]){\\n                    if(a[2]<b[2])return true;\\n                    if(a[2]==b[2]){\\n                        return a[3]<b[3];\\n                    }\\n                    return false;\\n                }\\n                return false;\\n            }\\n            return false;\\n        }  \\n    };\\n    \\n    vector<int> X={0,0,1,-1}, Y={1,-1,0,0};\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& g, vector<int>& pricing, vector<int>& start, int k) {\\n        int lo=pricing[0], hi=pricing[1];\\n        priority_queue<vector<int>, vector<vector<int>>, cmp> pq;\\n        int n=g.size(), m=g[0].size();\\n        queue<vector<int>> q;\\n        q.push({0,g[start[0]][start[1]], start[0], start[1]});\\n        g[start[0]][start[1]]*=-1;\\n        while(!q.empty()){ // BFS\\n            auto t=q.front();\\n            q.pop();\\n            int dist=t[0], val=t[1], x=t[2], y=t[3];\\n            if(val>=lo && val<=hi)pq.push({dist,val,x,y});\\n            if(pq.size()>k)pq.pop(); // if there are more than k elements in the pq, pop from it\\n            for(int i=0; i<4; i++){\\n                int newx=x+X[i], newy=y+Y[i];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && g[newx][newy]!=0){\\n                    q.push({dist+1,g[newx][newy],newx,newy});\\n                    g[newx][newy]=0;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty()){\\n            auto t= pq.top();\\n            pq.pop();\\n            ans.push_back({t[2],t[3]});\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710113,
                "title": "bfs-solution-by-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pr, vector<int>& start, int k) {\\n        vector<vector<int>> v1,vis;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> v;\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                v.push_back(0);\\n            }\\n            vis.push_back(v);\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        vis[start[0]][start[1]]=1;\\n        if(grid[start[0]][start[1]]>=pr[0]&&grid[start[0]][start[1]]<=pr[1])\\n        {\\n            v1.push_back({start[0],start[1]});\\n        }\\n        int n=grid.size(),m=grid[0].size();\\n        while(q.size()>0&&v1.size()<k)\\n        {\\n            int a=q.size();\\n            vector<vector<int>> v2;\\n            while(a>0&&v1.size()<k)\\n            {\\n                a--;\\n                int x=q.front().first,y=q.front().second;\\n                q.pop();\\n                if(x+1<n&&vis[x+1][y]==0)\\n                {\\n                    vis[x+1][y]=1;\\n                    if(grid[x+1][y]!=0)\\n                    {\\n                        q.push({x+1,y});\\n                        if(grid[x+1][y]>=pr[0]&&grid[x+1][y]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x+1][y],x+1,y});\\n                        }\\n                    }\\n                }\\n                if(y+1<m&&vis[x][y+1]==0)\\n                {\\n                    vis[x][y+1]=1;\\n                    if(grid[x][y+1]!=0)\\n                    {\\n                        q.push({x,y+1});\\n                        if(grid[x][y+1]>=pr[0]&&grid[x][y+1]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x][y+1],x,y+1});\\n                        }\\n                    }\\n                }\\n                if(x-1>=0&&vis[x-1][y]==0)\\n                {\\n                    vis[x-1][y]=1;\\n                    if(grid[x-1][y]!=0)\\n                    {\\n                        q.push({x-1,y});\\n                        if(grid[x-1][y]>=pr[0]&&grid[x-1][y]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x-1][y],x-1,y});\\n                        }\\n                    }\\n                }\\n                if(y-1>=0&&vis[x][y-1]==0)\\n                {\\n                    vis[x][y-1]=1;\\n                    if(grid[x][y-1]!=0)\\n                    {\\n                        q.push({x,y-1});\\n                        if(grid[x][y-1]>=pr[0]&&grid[x][y-1]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x][y-1],x,y-1});\\n                        }\\n                    }\\n                }\\n            }\\n            sort(v2.begin(),v2.end());\\n            for(int i=0;i<v2.size()&&v1.size()<k;i++)\\n            {\\n                v1.push_back({v2[i][1],v2[i][2]});\\n            }\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pr, vector<int>& start, int k) {\\n        vector<vector<int>> v1,vis;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> v;\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                v.push_back(0);\\n            }\\n            vis.push_back(v);\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        vis[start[0]][start[1]]=1;\\n        if(grid[start[0]][start[1]]>=pr[0]&&grid[start[0]][start[1]]<=pr[1])\\n        {\\n            v1.push_back({start[0],start[1]});\\n        }\\n        int n=grid.size(),m=grid[0].size();\\n        while(q.size()>0&&v1.size()<k)\\n        {\\n            int a=q.size();\\n            vector<vector<int>> v2;\\n            while(a>0&&v1.size()<k)\\n            {\\n                a--;\\n                int x=q.front().first,y=q.front().second;\\n                q.pop();\\n                if(x+1<n&&vis[x+1][y]==0)\\n                {\\n                    vis[x+1][y]=1;\\n                    if(grid[x+1][y]!=0)\\n                    {\\n                        q.push({x+1,y});\\n                        if(grid[x+1][y]>=pr[0]&&grid[x+1][y]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x+1][y],x+1,y});\\n                        }\\n                    }\\n                }\\n                if(y+1<m&&vis[x][y+1]==0)\\n                {\\n                    vis[x][y+1]=1;\\n                    if(grid[x][y+1]!=0)\\n                    {\\n                        q.push({x,y+1});\\n                        if(grid[x][y+1]>=pr[0]&&grid[x][y+1]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x][y+1],x,y+1});\\n                        }\\n                    }\\n                }\\n                if(x-1>=0&&vis[x-1][y]==0)\\n                {\\n                    vis[x-1][y]=1;\\n                    if(grid[x-1][y]!=0)\\n                    {\\n                        q.push({x-1,y});\\n                        if(grid[x-1][y]>=pr[0]&&grid[x-1][y]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x-1][y],x-1,y});\\n                        }\\n                    }\\n                }\\n                if(y-1>=0&&vis[x][y-1]==0)\\n                {\\n                    vis[x][y-1]=1;\\n                    if(grid[x][y-1]!=0)\\n                    {\\n                        q.push({x,y-1});\\n                        if(grid[x][y-1]>=pr[0]&&grid[x][y-1]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x][y-1],x,y-1});\\n                        }\\n                    }\\n                }\\n            }\\n            sort(v2.begin(),v2.end());\\n            for(int i=0;i<v2.size()&&v1.size()<k;i++)\\n            {\\n                v1.push_back({v2[i][1],v2[i][2]});\\n            }\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710029,
                "title": "java-bfs-varitation-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public class pair{\\n        \\n        int dis;\\n        int price;\\n        int row;\\n        int col;\\n        \\n        pair(int dis,int price,int row,int col)\\n        {\\n            this.dis = dis;\\n            this.price = price;\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] dir = {{0,1},{1,0},{-1,0},{0,-1}};\\n            \\n        List<List<Integer>> ans = new ArrayList<>();\\n        PriorityQueue<pair> pque = new PriorityQueue<>((a,b)->{\\n            \\n            if(a.dis!=b.dis)\\n            {\\n                return a.dis - b.dis;\\n            }\\n            \\n            if(a.price!=b.price)\\n            {\\n                return a.price - b.price;\\n            }\\n            \\n            if(a.row!=b.row)\\n            {\\n                return a.row - b.row;\\n            }\\n            return a.col - b.col;\\n        });\\n        \\n        int val = grid[start[0]][start[1]];\\n        if(val<= pricing[1] && val>= pricing[0])\\n        {\\n            List<Integer> sans = new ArrayList<>();\\n            sans.add(start[0]);\\n            sans.add(start[1]);\\n            ans.add(new ArrayList<>(sans));\\n            k--;\\n        }\\n         if(k==0)\\n            return ans;\\n        \\n        grid[start[0]][start[1]] = 0;\\n        pque.add(new pair(-1,-1,start[0],start[1]));\\n        \\n        while(pque.size()!=0)\\n        {\\n            pair rp = pque.remove();\\n            \\n            if(rp.dis != -1)\\n            {\\n                if(rp.price<= pricing[1] && rp.price>= pricing[0])\\n                {\\n                    List<Integer> sans = new ArrayList<>();\\n                    sans.add(rp.row);\\n                    sans.add(rp.col);\\n                    ans.add(new ArrayList<>(sans));\\n                    k--;\\n                    if(k==0)\\n                        return ans;\\n                }\\n            }\\n           \\n            for(int d=0;d<dir.length;d++)\\n            {\\n                int nr = rp.row + dir[d][0];\\n                int nc = rp.col + dir[d][1];\\n                \\n                if(nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]!=0)\\n                {\\n                    int price = grid[nr][nc];\\n                    pque.add(new pair(rp.dis+1,price,nr,nc));\\n                    grid[nr][nc] = 0;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public class pair{\\n        \\n        int dis;\\n        int price;\\n        int row;\\n        int col;\\n        \\n        pair(int dis,int price,int row,int col)\\n        {\\n            this.dis = dis;\\n            this.price = price;\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] dir = {{0,1},{1,0},{-1,0},{0,-1}};\\n            \\n        List<List<Integer>> ans = new ArrayList<>();\\n        PriorityQueue<pair> pque = new PriorityQueue<>((a,b)->{\\n            \\n            if(a.dis!=b.dis)\\n            {\\n                return a.dis - b.dis;\\n            }\\n            \\n            if(a.price!=b.price)\\n            {\\n                return a.price - b.price;\\n            }\\n            \\n            if(a.row!=b.row)\\n            {\\n                return a.row - b.row;\\n            }\\n            return a.col - b.col;\\n        });\\n        \\n        int val = grid[start[0]][start[1]];\\n        if(val<= pricing[1] && val>= pricing[0])\\n        {\\n            List<Integer> sans = new ArrayList<>();\\n            sans.add(start[0]);\\n            sans.add(start[1]);\\n            ans.add(new ArrayList<>(sans));\\n            k--;\\n        }\\n         if(k==0)\\n            return ans;\\n        \\n        grid[start[0]][start[1]] = 0;\\n        pque.add(new pair(-1,-1,start[0],start[1]));\\n        \\n        while(pque.size()!=0)\\n        {\\n            pair rp = pque.remove();\\n            \\n            if(rp.dis != -1)\\n            {\\n                if(rp.price<= pricing[1] && rp.price>= pricing[0])\\n                {\\n                    List<Integer> sans = new ArrayList<>();\\n                    sans.add(rp.row);\\n                    sans.add(rp.col);\\n                    ans.add(new ArrayList<>(sans));\\n                    k--;\\n                    if(k==0)\\n                        return ans;\\n                }\\n            }\\n           \\n            for(int d=0;d<dir.length;d++)\\n            {\\n                int nr = rp.row + dir[d][0];\\n                int nc = rp.col + dir[d][1];\\n                \\n                if(nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]!=0)\\n                {\\n                    int price = grid[nr][nc];\\n                    pque.add(new pair(rp.dis+1,price,nr,nc));\\n                    grid[nr][nc] = 0;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709942,
                "title": "c-simple-bfs-with-queue",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> HighestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        var rows = grid.Length;\\n        var cols = grid[0].Length;\\n        \\n        var res = new List<IList<int>>();\\n        var queue = new Queue<(int row, int col)>();\\n        queue.Enqueue((start[0], start[1]));\\n        \\n        while(queue.Count > 0)\\n        {\\n            var list = new List<(int row, int col, int price)>();\\n            var qc = queue.Count;\\n            for(int i=0; i<qc; i++)\\n            {\\n                var e = queue.Dequeue();\\n\\n                var price = grid[e.row][e.col];\\n                if(price == 0)\\n                    continue;\\n                if(price > 1 && price >= pricing[0] && price <= pricing[1])\\n                    list.Add((e.row, e.col, price));\\n                grid[e.row][e.col] = 0;\\n\\n                if(e.row + 1 < rows && grid[e.row + 1][e.col] != 0)\\n                    queue.Enqueue((e.row + 1, e.col));\\n                if(e.row - 1 >= 0 && grid[e.row - 1][e.col] != 0)\\n                    queue.Enqueue((e.row - 1, e.col));\\n                if(e.col + 1 < cols && grid[e.row][e.col + 1] != 0)\\n                    queue.Enqueue((e.row, e.col + 1));\\n                if(e.col - 1 >= 0 && grid[e.row][e.col - 1] != 0)\\n                    queue.Enqueue((e.row, e.col - 1));\\n            }\\n            var sorted = list.OrderBy(e => e.price).ThenBy(e => e.row).ThenBy(e => e.col);\\n            foreach(var e in sorted)\\n                if(res.Count < k)\\n                    res.Add(new int[] {e.row, e.col});\\n                else\\n                    break;\\n            \\n            if(res.Count == k)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> HighestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        var rows = grid.Length;\\n        var cols = grid[0].Length;\\n        \\n        var res = new List<IList<int>>();\\n        var queue = new Queue<(int row, int col)>();\\n        queue.Enqueue((start[0], start[1]));\\n        \\n        while(queue.Count > 0)\\n        {\\n            var list = new List<(int row, int col, int price)>();\\n            var qc = queue.Count;\\n            for(int i=0; i<qc; i++)\\n            {\\n                var e = queue.Dequeue();\\n\\n                var price = grid[e.row][e.col];\\n                if(price == 0)\\n                    continue;\\n                if(price > 1 && price >= pricing[0] && price <= pricing[1])\\n                    list.Add((e.row, e.col, price));\\n                grid[e.row][e.col] = 0;\\n\\n                if(e.row + 1 < rows && grid[e.row + 1][e.col] != 0)\\n                    queue.Enqueue((e.row + 1, e.col));\\n                if(e.row - 1 >= 0 && grid[e.row - 1][e.col] != 0)\\n                    queue.Enqueue((e.row - 1, e.col));\\n                if(e.col + 1 < cols && grid[e.row][e.col + 1] != 0)\\n                    queue.Enqueue((e.row, e.col + 1));\\n                if(e.col - 1 >= 0 && grid[e.row][e.col - 1] != 0)\\n                    queue.Enqueue((e.row, e.col - 1));\\n            }\\n            var sorted = list.OrderBy(e => e.price).ThenBy(e => e.row).ThenBy(e => e.col);\\n            foreach(var e in sorted)\\n                if(res.Count < k)\\n                    res.Add(new int[] {e.row, e.col});\\n                else\\n                    break;\\n            \\n            if(res.Count == k)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709868,
                "title": "c-bfs-priority-queue-vector-vs-pair-vector-are-slow",
                "content": "**TLE CODE-**\\n```\\n#define fastio ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\nclass Solution {\\n    private:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) \\n        {\\n            if(p[2]!=q[2])\\n            {\\n                return p[2]<q[2];\\n            }\\n            else\\n            {\\n                if(p[3]!=q[3])\\n                    return p[3]<q[3];\\n                else\\n                {\\n                    if(p[0]!=q[0])\\n                    {\\n                        return p[0]<q[0];\\n                    }\\n                    else\\n                    {\\n                        return p[1]<q[1];\\n                    }\\n                }\\n            }\\n            return 1;\\n        }\\n    };\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        fastio\\n        vector<vector<int>>vc;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int X[4] = {1,-1,0,0};\\n        int Y[4] = {0,0,-1,1};\\n        queue<vector<int>>q;\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq;\\n        // co , dis , price;\\n        q.push({start[0],start[1],0,grid[start[0]][start[1]]});\\n        while(!q.empty())\\n        {\\n            vector<int>tp = q.front();q.pop();\\n            if(tp[3]>1 and tp[3]>=pricing[0] and tp[3]<=pricing[1])\\n            {\\n                // cout<<tp[0]<<\" \"<<tp[1]<<\" \"<<tp[2]<<\" \"<<tp[3]<<endl;\\n                pq.push(tp);\\n            }\\n            if(pq.size()>k)\\n                pq.pop();\\n            grid[tp[0]][tp[1]]=0;\\n            for(int i=0;i<4;i++)\\n            {\\n                int newX = tp[0]+X[i];\\n                int newY = tp[1]+Y[i];\\n                if(newX<n and newX>=0 and newY<m and newY>=0 and grid[newX][newY]!=0)\\n                {\\n                    q.push({newX,newY,tp[2]+1,grid[newX][newY]});\\n                    grid[newX][newY]=0;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>>ans;\\n        // cout<<endl;\\n        while(!pq.empty())\\n        {\\n            vector<int>tp = pq.top();pq.pop();\\n            // cout<<tp[0]<<\" \"<<tp[1]<<\" \"<<tp[2]<<\" \"<<tp[3]<<endl;\\n            ans.push_back({tp[0],tp[1]});            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n};\\n```\\n\\nI changed vector<int> to pair<pair<int,int>,pair<int,int>> and it AC\\n**AC CODE -**\\n```\\n#define fastio ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\nclass Solution {\\n    //custom comparator for PQ\\n    // first give priority to Distance , then price then row number then column number\\n    private:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) \\n        {\\n            if(p[2]!=q[2])\\n            {\\n                return p[2]<q[2];\\n            }\\n            else\\n            {\\n                if(p[3]!=q[3])\\n                    return p[3]<q[3];\\n                else\\n                {\\n                    if(p[0]!=q[0])\\n                    {\\n                        return p[0]<q[0];\\n                    }\\n                    else\\n                    {\\n                        return p[1]<q[1];\\n                    }\\n                }\\n            }\\n            return 1;\\n        }\\n    };\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        fastio\\n        vector<vector<int>>vc;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int X[4] = {1,-1,0,0};\\n        int Y[4] = {0,0,-1,1};\\n        queue< pair< pair<int,int>,pair<int,int> > >q;\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq;\\n        // co , dis , price;\\n        q.push({{start[0],start[1]},{0,grid[start[0]][start[1]]}});\\n        while(!q.empty())\\n        {\\n            pair<pair<int,int>,pair<int,int> > tp = q.front();q.pop();\\n            if(tp.second.second>1 and tp.second.second>=pricing[0] and tp.second.second<=pricing[1])\\n            {\\n                // cout<<tp[0]<<\" \"<<tp[1]<<\" \"<<tp[2]<<\" \"<<tp[3]<<endl;\\n                pq.push({tp.first.first , tp.first.second,tp.second.first,tp.second.second});\\n            }\\n            if(pq.size()>k)\\n                pq.pop();\\n            grid[tp.first.first][tp.first.second]=0;\\n            for(int i=0;i<4;i++)\\n            {\\n                int newX = tp.first.first+X[i];\\n                int newY = tp.first.second+Y[i];\\n                if(newX<n and newX>=0 and newY<m and newY>=0 and grid[newX][newY]!=0)\\n                {\\n                    q.push({{newX,newY},{tp.second.first+1,grid[newX][newY]}});\\n                    grid[newX][newY]=0;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>>ans;\\n        // cout<<endl;\\n        while(!pq.empty())\\n        {\\n            vector<int>tp = pq.top();pq.pop();\\n            // cout<<tp[0]<<\" \"<<tp[1]<<\" \"<<tp[2]<<\" \"<<tp[3]<<endl;\\n            ans.push_back({tp[0],tp[1]});            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define fastio ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\nclass Solution {\\n    private:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) \\n        {\\n            if(p[2]!=q[2])\\n            {\\n                return p[2]<q[2];\\n            }\\n            else\\n            {\\n                if(p[3]!=q[3])\\n                    return p[3]<q[3];\\n                else\\n                {\\n                    if(p[0]!=q[0])\\n                    {\\n                        return p[0]<q[0];\\n                    }\\n                    else\\n                    {\\n                        return p[1]<q[1];\\n                    }\\n                }\\n            }\\n            return 1;\\n        }\\n    };\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        fastio\\n        vector<vector<int>>vc;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int X[4] = {1,-1,0,0};\\n        int Y[4] = {0,0,-1,1};\\n        queue<vector<int>>q;\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq;\\n        // co , dis , price;\\n        q.push({start[0],start[1],0,grid[start[0]][start[1]]});\\n        while(!q.empty())\\n        {\\n            vector<int>tp = q.front();q.pop();\\n            if(tp[3]>1 and tp[3]>=pricing[0] and tp[3]<=pricing[1])\\n            {\\n                // cout<<tp[0]<<\" \"<<tp[1]<<\" \"<<tp[2]<<\" \"<<tp[3]<<endl;\\n                pq.push(tp);\\n            }\\n            if(pq.size()>k)\\n                pq.pop();\\n            grid[tp[0]][tp[1]]=0;\\n            for(int i=0;i<4;i++)\\n            {\\n                int newX = tp[0]+X[i];\\n                int newY = tp[1]+Y[i];\\n                if(newX<n and newX>=0 and newY<m and newY>=0 and grid[newX][newY]!=0)\\n                {\\n                    q.push({newX,newY,tp[2]+1,grid[newX][newY]});\\n                    grid[newX][newY]=0;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>>ans;\\n        // cout<<endl;\\n        while(!pq.empty())\\n        {\\n            vector<int>tp = pq.top();pq.pop();\\n            // cout<<tp[0]<<\" \"<<tp[1]<<\" \"<<tp[2]<<\" \"<<tp[3]<<endl;\\n            ans.push_back({tp[0],tp[1]});            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n};\\n```\n```\\n#define fastio ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\nclass Solution {\\n    //custom comparator for PQ\\n    // first give priority to Distance , then price then row number then column number\\n    private:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) \\n        {\\n            if(p[2]!=q[2])\\n            {\\n                return p[2]<q[2];\\n            }\\n            else\\n            {\\n                if(p[3]!=q[3])\\n                    return p[3]<q[3];\\n                else\\n                {\\n                    if(p[0]!=q[0])\\n                    {\\n                        return p[0]<q[0];\\n                    }\\n                    else\\n                    {\\n                        return p[1]<q[1];\\n                    }\\n                }\\n            }\\n            return 1;\\n        }\\n    };\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        fastio\\n        vector<vector<int>>vc;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int X[4] = {1,-1,0,0};\\n        int Y[4] = {0,0,-1,1};\\n        queue< pair< pair<int,int>,pair<int,int> > >q;\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq;\\n        // co , dis , price;\\n        q.push({{start[0],start[1]},{0,grid[start[0]][start[1]]}});\\n        while(!q.empty())\\n        {\\n            pair<pair<int,int>,pair<int,int> > tp = q.front();q.pop();\\n            if(tp.second.second>1 and tp.second.second>=pricing[0] and tp.second.second<=pricing[1])\\n            {\\n                // cout<<tp[0]<<\" \"<<tp[1]<<\" \"<<tp[2]<<\" \"<<tp[3]<<endl;\\n                pq.push({tp.first.first , tp.first.second,tp.second.first,tp.second.second});\\n            }\\n            if(pq.size()>k)\\n                pq.pop();\\n            grid[tp.first.first][tp.first.second]=0;\\n            for(int i=0;i<4;i++)\\n            {\\n                int newX = tp.first.first+X[i];\\n                int newY = tp.first.second+Y[i];\\n                if(newX<n and newX>=0 and newY<m and newY>=0 and grid[newX][newY]!=0)\\n                {\\n                    q.push({{newX,newY},{tp.second.first+1,grid[newX][newY]}});\\n                    grid[newX][newY]=0;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>>ans;\\n        // cout<<endl;\\n        while(!pq.empty())\\n        {\\n            vector<int>tp = pq.top();pq.pop();\\n            // cout<<tp[0]<<\" \"<<tp[1]<<\" \"<<tp[2]<<\" \"<<tp[3]<<endl;\\n            ans.push_back({tp[0],tp[1]});            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1709831,
                "title": "c-bfs-heap",
                "content": "<strong>Logical Thinking</strong>\\n<p>To sort the items with criteria, we can use a <strong>heap</strong> <code>pq</code>, then we use <strong>breadth first search</strong> to traverse all locations, and push the item into <code>pq</code> the first time we encounter it if its price satisfies the condition. Whenever there are more than <code>k</code> items in <code>pq</code>, pop them up until <code>pq.size() <= k</code>.</p>\\n\\n\\n<strong>C++</strong>\\n\\n```\\n//  Topic   : 2146. K Highest Ranked Items Within a Price Range\\n//  Author  : YCX\\n//  Time    : O(NlogK)\\n//  Space   : O(N)\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<int> dirs = {0, 1, 0, -1, 0};\\n        priority_queue<tuple<int, int, int, int>> pq;\\n        queue<pair<int, int>> q;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, INT_MAX));\\n        q.push({start[0], start[1]});\\n        visited[start[0]][start[1]] = 0;\\n        while (!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second, d = visited[x][y], v = grid[x][y];\\n            q.pop();\\n            if (v <= pricing[1] && v >= pricing[0])\\n            {\\n                pq.push({d, v, x, y});\\n                if (pq.size() > k)\\n                    pq.pop();\\n            }\\n            for (int i = 0; i < 4; i++)\\n            {\\n                int nx = x + dirs[i], ny = y + dirs[i + 1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == 0 || visited[nx][ny] <= d + 1)\\n                    continue;\\n                visited[nx][ny] = d + 1;\\n                q.push({nx, ny});\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while (!pq.empty())\\n        {\\n            auto t = pq.top();\\n            ans.push_back({get<2>(t), get<3>(t)});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//  Topic   : 2146. K Highest Ranked Items Within a Price Range\\n//  Author  : YCX\\n//  Time    : O(NlogK)\\n//  Space   : O(N)\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<int> dirs = {0, 1, 0, -1, 0};\\n        priority_queue<tuple<int, int, int, int>> pq;\\n        queue<pair<int, int>> q;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, INT_MAX));\\n        q.push({start[0], start[1]});\\n        visited[start[0]][start[1]] = 0;\\n        while (!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second, d = visited[x][y], v = grid[x][y];\\n            q.pop();\\n            if (v <= pricing[1] && v >= pricing[0])\\n            {\\n                pq.push({d, v, x, y});\\n                if (pq.size() > k)\\n                    pq.pop();\\n            }\\n            for (int i = 0; i < 4; i++)\\n            {\\n                int nx = x + dirs[i], ny = y + dirs[i + 1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == 0 || visited[nx][ny] <= d + 1)\\n                    continue;\\n                visited[nx][ny] = d + 1;\\n                q.push({nx, ny});\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while (!pq.empty())\\n        {\\n            auto t = pq.top();\\n            ans.push_back({get<2>(t), get<3>(t)});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709809,
                "title": "simple-java-solution-bfs-priorityqueue",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        //bfs to find distances and add to priority queue to sort based on criteria\\n        // Real estate problem - distance from school :)\\n        int price = grid[start[0]][start[1]];\\n        int [] cdpij = new int[]{0,price, start[0],start[1]};//current - distance, price, i, j;\\n        Queue<int[]> queue = new LinkedList<>();\\n        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)-> \\n         (a[0]!=b[0])?(a[0]-b[0]):((a[1]!=b[1])?(a[1]-b[1]):((a[2]!=b[2])?(a[2]-b[2]):(a[3]-b[3]))));\\n        Set<String> visited = new HashSet<>();//track \\n        int dist = 0;\\n        queue.offer(cdpij);//can use 2 maps as well\\n        visited.add(start[0]+\"_\"+start[1]);\\n        int[][]dirs = {{-1,0},{1,0},{0,1},{0,-1}};\\n        while(queue.size()>0){\\n            int count = queue.size();\\n            while(count>0){\\n                cdpij = queue.poll();\\n                price = cdpij[1];\\n                if(price!=0 && price>=pricing[0] && price<=pricing[1])\\n                pq.offer(cdpij);\\n                for(int [] dir : dirs){\\n                    int ni = cdpij[2]+dir[0];\\n                    int nj = cdpij[3]+dir[1];\\n                    if(ni>=0 && nj>=0 && ni< grid.length && nj <grid[0].length && grid[ni][nj]!=0 && !visited.contains(ni+\"_\"+nj)){\\n                        visited.add(ni+\"_\"+nj);\\n                        queue.offer(new int[]{dist+1,grid[ni][nj],ni, nj});\\n                    }                        \\n                }\\n                count--;\\n            }\\n            dist++;\\n        }\\n        List<List<Integer>> list = new ArrayList<>();\\n        while(k>0 && pq.size()>0){\\n            int[] current = pq.poll();\\n            List<Integer> l = new ArrayList<>();\\n            l.add(current[2]);\\n            l.add(current[3]);\\n            list.add(l);\\n            k--;\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        //bfs to find distances and add to priority queue to sort based on criteria\\n        // Real estate problem - distance from school :)\\n        int price = grid[start[0]][start[1]];\\n        int [] cdpij = new int[]{0,price, start[0],start[1]}",
                "codeTag": "Java"
            },
            {
                "id": 1709738,
                "title": "c-bfs-priority-queue",
                "content": "\\n```\\nstruct Node{\\n    int dis;\\n    int price;\\n    int row, col;\\n    Node(int d, int p, int r, int c){\\n        dis = d, price = p, row = r, col = c;\\n    }\\n    bool operator < (const Node& a) const{\\n        if(dis == a.dis){\\n            if(price == a.price){\\n                if(row == a.row){\\n                    return col > a.col;\\n                }\\n                return row > a.row;\\n            }\\n            return price > a.price;\\n        }\\n        return dis > a.dis;\\n    }\\n};\\nclass Solution {\\nprivate:\\n    vector<int> x = {0, 0, 1, -1};\\n    vector<int> y = {1, -1, 0, 0};\\npublic:\\n    bool isValid(int i, int j, int n, int m, vector<vector<int>>& grid){\\n        if(i >= n || j >= m || i < 0 || j < 0 || grid[i][j] == 0) return false;\\n        return true;\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        queue<pair<int, int>> qt;\\n        vector<vector<int>> dis(n + 1, vector<int>(m + 1, INT_MAX));\\n        vector<vector<bool>> vis(n + 1, vector<bool>(m + 1, false));\\n        qt.push({start[0], start[1]});\\n        dis[start[0]][start[1]] = 0;\\n        vis[start[0]][start[1]] = true;\\n        priority_queue<Node> kItem;\\n        if(grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1]){\\n            kItem.push(Node(dis[start[0]][start[1]], grid[start[0]][start[1]], start[0], start[1]));\\n        }\\n        while(!qt.empty()){\\n            auto fr = qt.front();\\n            qt.pop();\\n            for(int i = 0; i < 4; i++){\\n                int nx = x[i] + fr.first;\\n                int ny = y[i] + fr.second;\\n                if(isValid(nx, ny, n, m, grid) && !vis[nx][ny]){\\n                    vis[nx][ny] = true;\\n                    dis[nx][ny] = dis[fr.first][fr.second] + 1;\\n                    qt.push({nx, ny});\\n                    if(grid[nx][ny] >= pricing[0] && grid[nx][ny] <= pricing[1]){\\n                        kItem.push(Node(dis[nx][ny], grid[nx][ny], nx, ny));\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        int idx = 0;\\n        while(!kItem.empty() && idx < k){\\n            auto item = kItem.top();\\n            kItem.pop();\\n            ans.push_back({item.row, item.col});\\n            idx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct Node{\\n    int dis;\\n    int price;\\n    int row, col;\\n    Node(int d, int p, int r, int c){\\n        dis = d, price = p, row = r, col = c;\\n    }\\n    bool operator < (const Node& a) const{\\n        if(dis == a.dis){\\n            if(price == a.price){\\n                if(row == a.row){\\n                    return col > a.col;\\n                }\\n                return row > a.row;\\n            }\\n            return price > a.price;\\n        }\\n        return dis > a.dis;\\n    }\\n};\\nclass Solution {\\nprivate:\\n    vector<int> x = {0, 0, 1, -1};\\n    vector<int> y = {1, -1, 0, 0};\\npublic:\\n    bool isValid(int i, int j, int n, int m, vector<vector<int>>& grid){\\n        if(i >= n || j >= m || i < 0 || j < 0 || grid[i][j] == 0) return false;\\n        return true;\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        queue<pair<int, int>> qt;\\n        vector<vector<int>> dis(n + 1, vector<int>(m + 1, INT_MAX));\\n        vector<vector<bool>> vis(n + 1, vector<bool>(m + 1, false));\\n        qt.push({start[0], start[1]});\\n        dis[start[0]][start[1]] = 0;\\n        vis[start[0]][start[1]] = true;\\n        priority_queue<Node> kItem;\\n        if(grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1]){\\n            kItem.push(Node(dis[start[0]][start[1]], grid[start[0]][start[1]], start[0], start[1]));\\n        }\\n        while(!qt.empty()){\\n            auto fr = qt.front();\\n            qt.pop();\\n            for(int i = 0; i < 4; i++){\\n                int nx = x[i] + fr.first;\\n                int ny = y[i] + fr.second;\\n                if(isValid(nx, ny, n, m, grid) && !vis[nx][ny]){\\n                    vis[nx][ny] = true;\\n                    dis[nx][ny] = dis[fr.first][fr.second] + 1;\\n                    qt.push({nx, ny});\\n                    if(grid[nx][ny] >= pricing[0] && grid[nx][ny] <= pricing[1]){\\n                        kItem.push(Node(dis[nx][ny], grid[nx][ny], nx, ny));\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        int idx = 0;\\n        while(!kItem.empty() && idx < k){\\n            auto item = kItem.top();\\n            kItem.pop();\\n            ans.push_back({item.row, item.col});\\n            idx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709678,
                "title": "java-bfs-heap",
                "content": "**Solution**\\n```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        List<List<Integer>> output = new ArrayList<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[2] != b[2]) {\\n                    return a[2] - b[2];\\n                } else if (grid[a[0]][a[1]] != grid[b[0]][b[1]]) {\\n                    return grid[a[0]][a[1]] - grid[b[0]][b[1]];\\n                } else if (a[0] != b[0]) {\\n                    return a[0] - b[0];\\n                } else {\\n                    return a[1] - b[1];\\n                }\\n            }\\n        });\\n        queue.offer(new int[]{start[0], start[1], 0});\\n        \\n        while (!queue.isEmpty() && k > 0) {\\n           int[] pos = queue.poll();\\n\\n            if (grid[pos[0]][pos[1]] == 0) {\\n                continue;\\n            }\\n\\n            if (pricing[0] <= grid[pos[0]][pos[1]] && grid[pos[0]][pos[1]] <= pricing[1]) {\\n                output.add(List.of(pos[0], pos[1]));\\n                -- k;\\n            }\\n\\n            if (pos[0] - 1 >= 0) {\\n                queue.offer(new int[] {pos[0] - 1, pos[1], pos[2] + 1});\\n            } \\n            if (pos[0] + 1 < m) {\\n                queue.offer(new int[] {pos[0] + 1, pos[1], pos[2] + 1});\\n            }\\n            if (pos[1] - 1 >= 0) {\\n                queue.offer(new int[] {pos[0], pos[1] - 1, pos[2] + 1});\\n            }\\n            if (pos[1] + 1 < n) {\\n                queue.offer(new int[] {pos[0], pos[1] + 1, pos[2] + 1});\\n            }\\n        \\n            grid[pos[0]][pos[1]] = 0; \\n            \\n        }\\n        \\n        return output;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        List<List<Integer>> output = new ArrayList<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[2] != b[2]) {\\n                    return a[2] - b[2];\\n                } else if (grid[a[0]][a[1]] != grid[b[0]][b[1]]) {\\n                    return grid[a[0]][a[1]] - grid[b[0]][b[1]];\\n                } else if (a[0] != b[0]) {\\n                    return a[0] - b[0];\\n                } else {\\n                    return a[1] - b[1];\\n                }\\n            }\\n        });\\n        queue.offer(new int[]{start[0], start[1], 0});\\n        \\n        while (!queue.isEmpty() && k > 0) {\\n           int[] pos = queue.poll();\\n\\n            if (grid[pos[0]][pos[1]] == 0) {\\n                continue;\\n            }\\n\\n            if (pricing[0] <= grid[pos[0]][pos[1]] && grid[pos[0]][pos[1]] <= pricing[1]) {\\n                output.add(List.of(pos[0], pos[1]));\\n                -- k;\\n            }\\n\\n            if (pos[0] - 1 >= 0) {\\n                queue.offer(new int[] {pos[0] - 1, pos[1], pos[2] + 1});\\n            } \\n            if (pos[0] + 1 < m) {\\n                queue.offer(new int[] {pos[0] + 1, pos[1], pos[2] + 1});\\n            }\\n            if (pos[1] - 1 >= 0) {\\n                queue.offer(new int[] {pos[0], pos[1] - 1, pos[2] + 1});\\n            }\\n            if (pos[1] + 1 < n) {\\n                queue.offer(new int[] {pos[0], pos[1] + 1, pos[2] + 1});\\n            }\\n        \\n            grid[pos[0]][pos[1]] = 0; \\n            \\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709676,
                "title": "a-few-solutions",
                "content": "Perform BFS from `start` to sort and append candidates (cells `i`,`j` of the input matrix `A` with `price` between `lo` and `hi` inclusive) per BFS depth onto the answer `ans` (with maximum cardinality `K`).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun highestRankedKItems(A: Array<IntArray>, price: IntArray, start: IntArray, K: Int): List<List<Int>> {\\n        var ans = mutableListOf<List<Int>>()\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var (lo, hi) = Pair(price[0], price[1])\\n        var (i, j) = Pair(start[0], start[1])\\n        var q: Queue<Pair<Int, Int>> = LinkedList<Pair<Int, Int>>(listOf(Pair(i, j)))\\n        var seen = mutableSetOf<String>(\"$i,$j\")\\n        while (0 < q.size && ans.size < K) {\\n            var cands = mutableListOf<Triple<Int, Int, Int>>()\\n            var k = q.size\\n            while (0 < k--) {\\n                var (i, j) = q.poll()\\n                if (lo <= A[i][j] && A[i][j] <= hi)\\n                    cands.add(Triple(A[i][j], i, j))\\n                for ((u, v) in listOf(Pair(i - 1, j), Pair(i + 1, j), Pair(i, j - 1), Pair(i, j + 1))) {\\n                    if (0 <= u && u < M && 0 <= v && v < N && A[u][v] != 0 && !seen.contains(\"$u,$v\")) {\\n                        q.add(Pair(u, v)); seen.add(\"$u,$v\")\\n                    }\\n                }\\n            }\\n            cands.sortWith(compareBy<Triple<Int, Int, Int>>{ it.first }.thenBy{ it.second }.thenBy{ it.third })\\n            for ((_, i, j) in cands) {\\n                if (ans.size == K)\\n                    break\\n                ans.add(listOf(i, j))\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet highestRankedKItems = (A, price, start, K, key = (i, j) => `${i},${j}`, ans = []) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let [lo, hi] = price;\\n    let [i, j] = start;\\n    let q = [[i, j]];\\n    let seen = new Set([key(i, j)]);\\n    while (q.length) {\\n        let cands = [];\\n        let k = q.length;\\n        while (k--) {\\n            let [i, j] = q.shift();\\n            if (lo <= A[i][j] && A[i][j] <= hi)\\n                cands.push([A[i][j], i, j]);\\n            for (let [u, v] of [[i - 1, j], [i, j - 1], [i + 1, j], [i, j + 1]])\\n                if (0 <= u && u < M && 0 <= v && v < N && A[u][v] && !seen.has(key(u, v)))\\n                    q.push([u, v]), seen.add(key(u, v));\\n        }\\n        cands.sort((a, b) => {\\n            let [x, i, j] = a,\\n                [y, u, v] = b;\\n            if (x != y) return x - y;\\n            if (i != u) return i - u;\\n            if (j != v) return j - v;\\n            return 0;\\n        });\\n        for (let [_, i, j] of cands) {\\n            if (ans.length == K)\\n                break;\\n            ans.push([i, j]);\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def highestRankedKItems(self, A: List[List[int]], price: List[int], start: List[int], K: int) -> List[List[int]]:\\n        ans = []\\n        M, N = len(A), len(A[0])\\n        lo, hi = price\\n        i, j = start\\n        q = deque([[i, j]])\\n        seen = set([f\\'{i},{j}\\'])\\n        while q:\\n            cands = []\\n            k = len(q)\\n            while k:\\n                i, j = q.popleft()\\n                if 1 < A[i][j] and lo <= A[i][j] <= hi:\\n                    cands.append([A[i][j], i, j])\\n                for u, v in [[i - 1, j], [i, j - 1], [i + 1, j], [i, j + 1]]:\\n                    if 0 <= u < M and 0 <= v < N and A[u][v] and f\\'{u},{v}\\' not in seen:\\n                        q.append([u, v]); seen.add(f\\'{u},{v}\\')\\n                k -= 1\\n            for _, i, j in sorted(cands):\\n                if len(ans) == K:\\n                    break\\n                ans.append([i, j])\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Map = unordered_map<int, Pairs>;\\n    using Queue = queue<Pair>;\\n    using Seen = unordered_map<int, unordered_map<int, bool>>;\\n    using Triple = tuple<int, int, int>;\\n    using Triples = vector<Triple>;\\n    VVI highestRankedKItems(VVI& A, VI& price, VI& start, int K, Seen seen = {}, VVI ans = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto [lo, hi] = tie(price[0], price[1]);\\n        auto [i, j] = make_tuple(start[0], start[1]);\\n        Queue q{{{i, j}}};\\n        seen[i][j] = true;\\n        while (q.size() && ans.size() < K) {\\n            Triples cands;\\n            int k = q.size();\\n            while (k--) {\\n                auto [i, j] = q.front(); q.pop();\\n                if (lo <= A[i][j] && A[i][j] <= hi)\\n                    cands.emplace_back(A[i][j], i, j);\\n                for (auto [u, v]: Pairs{{i - 1, j}, {i, j - 1}, {i + 1, j}, {i, j + 1}})\\n                    if (0 <= u && u < M && 0 <= v && v < N && A[u][v] && !seen[u][v])\\n                        q.push({u, v}), seen[u][v] = true;\\n            }\\n            sort(cands.begin(), cands.end(), [](auto& a, auto& b) {\\n                auto [x, i, j] = a;\\n                auto [y, u, v] = b;\\n                if (x != y) return x < y;\\n                if (i != u) return i < u;\\n                if (j != v) return j < v;\\n                return true;\\n            });\\n            for (auto [_, i, j]: cands) {\\n                if (ans.size() == K)\\n                    break;\\n                ans.emplace_back(VI{i, j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun highestRankedKItems(A: Array<IntArray>, price: IntArray, start: IntArray, K: Int): List<List<Int>> {\\n        var ans = mutableListOf<List<Int>>()\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var (lo, hi) = Pair(price[0], price[1])\\n        var (i, j) = Pair(start[0], start[1])\\n        var q: Queue<Pair<Int, Int>> = LinkedList<Pair<Int, Int>>(listOf(Pair(i, j)))\\n        var seen = mutableSetOf<String>(\"$i,$j\")\\n        while (0 < q.size && ans.size < K) {\\n            var cands = mutableListOf<Triple<Int, Int, Int>>()\\n            var k = q.size\\n            while (0 < k--) {\\n                var (i, j) = q.poll()\\n                if (lo <= A[i][j] && A[i][j] <= hi)\\n                    cands.add(Triple(A[i][j], i, j))\\n                for ((u, v) in listOf(Pair(i - 1, j), Pair(i + 1, j), Pair(i, j - 1), Pair(i, j + 1))) {\\n                    if (0 <= u && u < M && 0 <= v && v < N && A[u][v] != 0 && !seen.contains(\"$u,$v\")) {\\n                        q.add(Pair(u, v)); seen.add(\"$u,$v\")\\n                    }\\n                }\\n            }\\n            cands.sortWith(compareBy<Triple<Int, Int, Int>>{ it.first }.thenBy{ it.second }.thenBy{ it.third })\\n            for ((_, i, j) in cands) {\\n                if (ans.size == K)\\n                    break\\n                ans.add(listOf(i, j))\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nlet highestRankedKItems = (A, price, start, K, key = (i, j) => `${i},${j}`, ans = []) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let [lo, hi] = price;\\n    let [i, j] = start;\\n    let q = [[i, j]];\\n    let seen = new Set([key(i, j)]);\\n    while (q.length) {\\n        let cands = [];\\n        let k = q.length;\\n        while (k--) {\\n            let [i, j] = q.shift();\\n            if (lo <= A[i][j] && A[i][j] <= hi)\\n                cands.push([A[i][j], i, j]);\\n            for (let [u, v] of [[i - 1, j], [i, j - 1], [i + 1, j], [i, j + 1]])\\n                if (0 <= u && u < M && 0 <= v && v < N && A[u][v] && !seen.has(key(u, v)))\\n                    q.push([u, v]), seen.add(key(u, v));\\n        }\\n        cands.sort((a, b) => {\\n            let [x, i, j] = a,\\n                [y, u, v] = b;\\n            if (x != y) return x - y;\\n            if (i != u) return i - u;\\n            if (j != v) return j - v;\\n            return 0;\\n        });\\n        for (let [_, i, j] of cands) {\\n            if (ans.length == K)\\n                break;\\n            ans.push([i, j]);\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def highestRankedKItems(self, A: List[List[int]], price: List[int], start: List[int], K: int) -> List[List[int]]:\\n        ans = []\\n        M, N = len(A), len(A[0])\\n        lo, hi = price\\n        i, j = start\\n        q = deque([[i, j]])\\n        seen = set([f\\'{i},{j}\\'])\\n        while q:\\n            cands = []\\n            k = len(q)\\n            while k:\\n                i, j = q.popleft()\\n                if 1 < A[i][j] and lo <= A[i][j] <= hi:\\n                    cands.append([A[i][j], i, j])\\n                for u, v in [[i - 1, j], [i, j - 1], [i + 1, j], [i, j + 1]]:\\n                    if 0 <= u < M and 0 <= v < N and A[u][v] and f\\'{u},{v}\\' not in seen:\\n                        q.append([u, v]); seen.add(f\\'{u},{v}\\')\\n                k -= 1\\n            for _, i, j in sorted(cands):\\n                if len(ans) == K:\\n                    break\\n                ans.append([i, j])\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Map = unordered_map<int, Pairs>;\\n    using Queue = queue<Pair>;\\n    using Seen = unordered_map<int, unordered_map<int, bool>>;\\n    using Triple = tuple<int, int, int>;\\n    using Triples = vector<Triple>;\\n    VVI highestRankedKItems(VVI& A, VI& price, VI& start, int K, Seen seen = {}, VVI ans = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto [lo, hi] = tie(price[0], price[1]);\\n        auto [i, j] = make_tuple(start[0], start[1]);\\n        Queue q{{{i, j}}};\\n        seen[i][j] = true;\\n        while (q.size() && ans.size() < K) {\\n            Triples cands;\\n            int k = q.size();\\n            while (k--) {\\n                auto [i, j] = q.front(); q.pop();\\n                if (lo <= A[i][j] && A[i][j] <= hi)\\n                    cands.emplace_back(A[i][j], i, j);\\n                for (auto [u, v]: Pairs{{i - 1, j}, {i, j - 1}, {i + 1, j}, {i, j + 1}})\\n                    if (0 <= u && u < M && 0 <= v && v < N && A[u][v] && !seen[u][v])\\n                        q.push({u, v}), seen[u][v] = true;\\n            }\\n            sort(cands.begin(), cands.end(), [](auto& a, auto& b) {\\n                auto [x, i, j] = a;\\n                auto [y, u, v] = b;\\n                if (x != y) return x < y;\\n                if (i != u) return i < u;\\n                if (j != v) return j < v;\\n                return true;\\n            });\\n            for (auto [_, i, j]: cands) {\\n                if (ans.size() == K)\\n                    break;\\n                ans.emplace_back(VI{i, j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810226,
                "title": "python3-solution-heap",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def highestRankedKItems(self, grid, pricing, start, k):\\n\\n        res = []\\n        m, n = len(grid), len(grid[0])\\n        low, high = pricing\\n        row, col = start\\n        heap = deque([(0, row, col)])\\n        grid[row][col] = -grid[row][col]\\n\\n        while heap:\\n            dis, row, col = heap.popleft()\\n            if low <= -grid[row][col] <= high:\\n                res.append((dis, -grid[row][col], row, col))\\n            for x, y in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                if 0 <= row + x < m and 0 <= col + y < n and grid[row + x][col + y] > 0:\\n                    heap.append((dis + 1, row + x, col + y))\\n                    grid[row + x][col + y] = -grid[row + x][col + y]\\n        \\n        res.sort()\\n        return [(x, y) for _, _, x, y in res[:k]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid, pricing, start, k):\\n\\n        res = []\\n        m, n = len(grid), len(grid[0])\\n        low, high = pricing\\n        row, col = start\\n        heap = deque([(0, row, col)])\\n        grid[row][col] = -grid[row][col]\\n\\n        while heap:\\n            dis, row, col = heap.popleft()\\n            if low <= -grid[row][col] <= high:\\n                res.append((dis, -grid[row][col], row, col))\\n            for x, y in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                if 0 <= row + x < m and 0 <= col + y < n and grid[row + x][col + y] > 0:\\n                    heap.append((dis + 1, row + x, col + y))\\n                    grid[row + x][col + y] = -grid[row + x][col + y]\\n        \\n        res.sort()\\n        return [(x, y) for _, _, x, y in res[:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181547,
                "title": "c-explanation-with-comments-classical-bfs-solution",
                "content": "```\\n// custom compare function to defne who is the highest ranked and sort accordingly \\n// first see if distance is same then go to the price ,then row and then column \\n// return on the basis of the criteria that is different (whichever comes first)\\n\\nstatic bool cmp(vector<int>&a,vector<int>&b){\\n    if(a[0]==b[0]){\\n        if(a[1]==b[1]){\\n            if(a[2]==b[2]){\\n                return a[3]<b[3];\\n            }\\n            return a[2]<b[2];\\n        }\\n        return a[1]<b[1];\\n    }\\n    return a[0]<b[0];\\n}\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& A, vector<int>& start, int k) {\\n        queue<pair<int,int>>q;\\n        vector<vector<int>>dir={{0,1},{1,0},{-1,0},{0,-1}};\\n        \\n        // we have declare a directions array to traverse in 4 directions\\n        \\n        q.push({start[0],start[1]});\\n        \\n        // first push the starting cell\\n        vector<vector<int>>dist(grid.size(),vector<int>(grid[0].size(),0));\\n        \\n        // declare the dist size ;\\n        // in bfs we alwatys get the shortest distance because we traverse level by level \\n        // only after we finish traversing a level we go to the other level \\n        // initialise the starting cell as dist[srcx][srcy]=0\\n        \\n        dist[start[0]][start[1]]=0;\\n        vector<vector<int>>pq;\\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size()));\\n        vis[start[0]][start[1]]=1;\\n        while(q.size()){\\n            int sz=q.size();\\n            while(sz--){\\n                // traversing the levels\\n                auto curr=q.front();\\n                if(grid[curr.first][curr.second]>=A[0] && grid[curr.first][curr.second]<=A[1]){\\n                    pq.push_back({dist[curr.first][curr.second],grid[curr.first][curr.second],curr.first,curr.second});\\n                    // we push into the array the four parameters , dist from source and then the price of the cell and the row and column if cell price is within range\\n                }\\n                \\n                // we pop the cell from the queue\\n                // ad start traversing the adjacent cells if valid\\n                \\n                q.pop();\\n                for(int i=0;i<4;i++){\\n                    int xx=curr.first+dir[i][0];\\n                    int yy=curr.second+dir[i][1];\\n                    if(xx<0||yy<0||xx>=grid.size() || yy>=grid[0].size() || grid[xx][yy]==0||vis[xx][yy]==1){\\n                        continue;\\n                        // checking if the cells we are about to visit are valid or not\\n                        // or if they are visited the we dont travers the cell \\n                    }\\n                    // elase we mark the cells as visited and push it into queue after updating the distance\\n                    vis[xx][yy]=1;\\n                    dist[xx][yy]=1+dist[curr.first][curr.second];\\n                    q.push({xx,yy});\\n                }\\n            }\\n        }\\n        sort(pq.begin(),pq.end(),cmp);\\n        vector<vector<int>>ans;\\n        \\n        // the push the resulting cells to ans array \\n        // we are using min(pq.size(),k) because if we have lesser cellswithin range than k then we return all the cells in pq array\\n        // else return top k ranked cells \\n        \\n        for(int i=0;i<min((int)pq.size(),k);i++){\\n            ans.push_back({pq[i][2],pq[i][3]});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n// custom compare function to defne who is the highest ranked and sort accordingly \\n// first see if distance is same then go to the price ,then row and then column \\n// return on the basis of the criteria that is different (whichever comes first)\\n\\nstatic bool cmp(vector<int>&a,vector<int>&b){\\n    if(a[0]==b[0]){\\n        if(a[1]==b[1]){\\n            if(a[2]==b[2]){\\n                return a[3]<b[3];\\n            }\\n            return a[2]<b[2];\\n        }\\n        return a[1]<b[1];\\n    }\\n    return a[0]<b[0];\\n}\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& A, vector<int>& start, int k) {\\n        queue<pair<int,int>>q;\\n        vector<vector<int>>dir={{0,1},{1,0},{-1,0},{0,-1}};\\n        \\n        // we have declare a directions array to traverse in 4 directions\\n        \\n        q.push({start[0],start[1]});\\n        \\n        // first push the starting cell\\n        vector<vector<int>>dist(grid.size(),vector<int>(grid[0].size(),0));\\n        \\n        // declare the dist size ;\\n        // in bfs we alwatys get the shortest distance because we traverse level by level \\n        // only after we finish traversing a level we go to the other level \\n        // initialise the starting cell as dist[srcx][srcy]=0\\n        \\n        dist[start[0]][start[1]]=0;\\n        vector<vector<int>>pq;\\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size()));\\n        vis[start[0]][start[1]]=1;\\n        while(q.size()){\\n            int sz=q.size();\\n            while(sz--){\\n                // traversing the levels\\n                auto curr=q.front();\\n                if(grid[curr.first][curr.second]>=A[0] && grid[curr.first][curr.second]<=A[1]){\\n                    pq.push_back({dist[curr.first][curr.second],grid[curr.first][curr.second],curr.first,curr.second});\\n                    // we push into the array the four parameters , dist from source and then the price of the cell and the row and column if cell price is within range\\n                }\\n                \\n                // we pop the cell from the queue\\n                // ad start traversing the adjacent cells if valid\\n                \\n                q.pop();\\n                for(int i=0;i<4;i++){\\n                    int xx=curr.first+dir[i][0];\\n                    int yy=curr.second+dir[i][1];\\n                    if(xx<0||yy<0||xx>=grid.size() || yy>=grid[0].size() || grid[xx][yy]==0||vis[xx][yy]==1){\\n                        continue;\\n                        // checking if the cells we are about to visit are valid or not\\n                        // or if they are visited the we dont travers the cell \\n                    }\\n                    // elase we mark the cells as visited and push it into queue after updating the distance\\n                    vis[xx][yy]=1;\\n                    dist[xx][yy]=1+dist[curr.first][curr.second];\\n                    q.push({xx,yy});\\n                }\\n            }\\n        }\\n        sort(pq.begin(),pq.end(),cmp);\\n        vector<vector<int>>ans;\\n        \\n        // the push the resulting cells to ans array \\n        // we are using min(pq.size(),k) because if we have lesser cellswithin range than k then we return all the cells in pq array\\n        // else return top k ranked cells \\n        \\n        for(int i=0;i<min((int)pq.size(),k);i++){\\n            ans.push_back({pq[i][2],pq[i][3]});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099226,
                "title": "javascript-solution-bfs-with-sorting",
                "content": "```\\nvar highestRankedKItems = function(grid, pricing, start, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dirs = [-1, 0, 1, 0, -1];\\n    \\n    const visited = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        visited[i] = new Array(n).fill(false);\\n    }\\n    \\n    const [low, high] = pricing;\\n\\n    const queue = [];\\n    \\n    queue.push([...start, 0]);\\n    \\n    const items = [];\\n    \\n    while (queue.length > 0) {\\n        const [row, col, dist] = queue.shift();\\n        \\n        if (visited[row][col]) continue;\\n        \\n        visited[row][col] = true;\\n        \\n        const price = grid[row][col];\\n        \\n        if (withinRange(price, low, high)) {\\n            items.push({ dist, price, row, col });\\n        }\\n        \\n        for (let i = 0; i < dirs.length - 1; ++i) {\\n            const neiRow = row + dirs[i];\\n            const neiCol = col + dirs[i + 1];\\n            \\n            if (withinBound(neiRow, neiCol) && !visited[neiRow][neiCol] && grid[neiRow][neiCol] != 0) {\\n                queue.push([neiRow, neiCol, dist + 1]);\\n            }\\n        }\\n    }\\n    \\n \\n    items.sort(compareFunc);\\n    \\n    const res = [];\\n    \\n    for (let i = 0; i < Math.min(k, items.length); ++i) {\\n        const { dist, price, row, col } = items[i];\\n        \\n        res.push([row, col]);\\n    }\\n    \\n    return res;\\n    \\n    \\n    function withinRange(price, low, high) {\\n        return low <= price && price <= high;\\n    }\\n    \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < m && col < n;\\n    }\\n    \\n    \\n    function compareFunc(a, b) {\\n        return a.dist - b.dist || a.price - b.price || a.row - b.row || a.col - b.col;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nvar highestRankedKItems = function(grid, pricing, start, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dirs = [-1, 0, 1, 0, -1];\\n    \\n    const visited = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        visited[i] = new Array(n).fill(false);\\n    }\\n    \\n    const [low, high] = pricing;\\n\\n    const queue = [];\\n    \\n    queue.push([...start, 0]);\\n    \\n    const items = [];\\n    \\n    while (queue.length > 0) {\\n        const [row, col, dist] = queue.shift();\\n        \\n        if (visited[row][col]) continue;\\n        \\n        visited[row][col] = true;\\n        \\n        const price = grid[row][col];\\n        \\n        if (withinRange(price, low, high)) {\\n            items.push({ dist, price, row, col });\\n        }\\n        \\n        for (let i = 0; i < dirs.length - 1; ++i) {\\n            const neiRow = row + dirs[i];\\n            const neiCol = col + dirs[i + 1];\\n            \\n            if (withinBound(neiRow, neiCol) && !visited[neiRow][neiCol] && grid[neiRow][neiCol] != 0) {\\n                queue.push([neiRow, neiCol, dist + 1]);\\n            }\\n        }\\n    }\\n    \\n \\n    items.sort(compareFunc);\\n    \\n    const res = [];\\n    \\n    for (let i = 0; i < Math.min(k, items.length); ++i) {\\n        const { dist, price, row, col } = items[i];\\n        \\n        res.push([row, col]);\\n    }\\n    \\n    return res;\\n    \\n    \\n    function withinRange(price, low, high) {\\n        return low <= price && price <= high;\\n    }\\n    \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < m && col < n;\\n    }\\n    \\n    \\n    function compareFunc(a, b) {\\n        return a.dist - b.dist || a.price - b.price || a.row - b.row || a.col - b.col;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1905101,
                "title": "java-solution-with-explaination-bfs-priority-queue-optimal",
                "content": "We can keep track of distance of the cells from the start point , if we traverse in level wise order. I have created a custom class cell to represent the indexes , its price and distance in an object. This will make it easier to sort and rank , since all these parameter affect the ranking of each reachable cell. We will start with the root for BFS.\\nfor each current node:\\nif cell\\'s price is in the range add this to priority queue\\n for each near by neighbor in the four direction:\\ncheck if the neighbour is not out of bound and not already  visited\\n   if yes -> add this to queue if the cell value is not 0 and mark this index as visited\\n   \\n   at the end of the traversal we will have all the reachable blocks ranked based on priority defined in compareto method\\n   we will pop the top k elements out of it. and boyaah this is the answer we were looking for :D \\n\\n```\\nclass Solution {\\n    public static class Cell implements Comparable<Cell> {\\n        int r;\\n        int c;\\n        int price;\\n        int dist;\\n        public Cell(int r, int c, int p) {\\n            this.r=r;\\n            this.c=c;\\n            this.price = p;\\n        }\\n        \\n        public void setDistance(int d) {\\n            this.dist = d;\\n        }\\n        \\n        public int compareTo( Cell other) {\\n            \\n            if(this.dist!=other.dist) {\\n                return this.dist-other.dist;\\n            }\\n            \\n            if(this.price!=other.price) {\\n                return this.price-other.price;\\n            }\\n            \\n            return this.r==other.r? (this.c-other.c):this.r-other.r;          \\n        }\\n    }\\n    \\n    public static int row;\\n    public static int col;\\n    public static int minPrice;\\n    public static int maxPrice;\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        minPrice = pricing[0];\\n        maxPrice = pricing[1];\\n        row = grid.length;\\n        col = grid[0].length;\\n        int[][] nextIndexes = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n        \\n        boolean[] visited = new boolean[row*col];\\n        \\n        Queue<Cell> queue = new LinkedList<>();\\n        PriorityQueue<Cell> priorityQueue = new PriorityQueue<>();\\n        visited[start[0]*col+start[1]]=true;\\n        queue.add(new Cell(start[0],start[1],grid[start[0]][start[1]]));\\n        \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int l=0;l<size;l++) {\\n                Cell curr = queue.poll();\\n                if(curr.price>1 && curr.price<=maxPrice && curr.price>=minPrice)\\n                priorityQueue.add(curr);\\n                \\n                for(int[] next: nextIndexes) {\\n                    int nexti = curr.r + next[0];\\n                    int nextj = curr.c + next[1];\\n                    \\n                    if(isValid(nexti,nextj) && grid[nexti][nextj]!=0 && visited[nexti*col+nextj]==false) {\\n                        Cell nextCell = new Cell(nexti,nextj,grid[nexti][nextj]);\\n                        nextCell.setDistance(curr.dist+1);\\n                        queue.add(nextCell);\\n                        visited[nexti*col+nextj]=true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        LinkedList<List<Integer>> resultList = new LinkedList<>();\\n        \\n        while(!priorityQueue.isEmpty() && k-->0) {\\n            Cell c = priorityQueue.poll();\\n\\n            resultList.add(Arrays.asList(c.r,c.c));\\n        }\\n        return resultList;\\n    }\\n    \\n    public boolean isValid(int i, int j) {\\n        return !(i<0||j<0||i>=row||j>=col);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static class Cell implements Comparable<Cell> {\\n        int r;\\n        int c;\\n        int price;\\n        int dist;\\n        public Cell(int r, int c, int p) {\\n            this.r=r;\\n            this.c=c;\\n            this.price = p;\\n        }\\n        \\n        public void setDistance(int d) {\\n            this.dist = d;\\n        }\\n        \\n        public int compareTo( Cell other) {\\n            \\n            if(this.dist!=other.dist) {\\n                return this.dist-other.dist;\\n            }\\n            \\n            if(this.price!=other.price) {\\n                return this.price-other.price;\\n            }\\n            \\n            return this.r==other.r? (this.c-other.c):this.r-other.r;          \\n        }\\n    }\\n    \\n    public static int row;\\n    public static int col;\\n    public static int minPrice;\\n    public static int maxPrice;\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        minPrice = pricing[0];\\n        maxPrice = pricing[1];\\n        row = grid.length;\\n        col = grid[0].length;\\n        int[][] nextIndexes = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n        \\n        boolean[] visited = new boolean[row*col];\\n        \\n        Queue<Cell> queue = new LinkedList<>();\\n        PriorityQueue<Cell> priorityQueue = new PriorityQueue<>();\\n        visited[start[0]*col+start[1]]=true;\\n        queue.add(new Cell(start[0],start[1],grid[start[0]][start[1]]));\\n        \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int l=0;l<size;l++) {\\n                Cell curr = queue.poll();\\n                if(curr.price>1 && curr.price<=maxPrice && curr.price>=minPrice)\\n                priorityQueue.add(curr);\\n                \\n                for(int[] next: nextIndexes) {\\n                    int nexti = curr.r + next[0];\\n                    int nextj = curr.c + next[1];\\n                    \\n                    if(isValid(nexti,nextj) && grid[nexti][nextj]!=0 && visited[nexti*col+nextj]==false) {\\n                        Cell nextCell = new Cell(nexti,nextj,grid[nexti][nextj]);\\n                        nextCell.setDistance(curr.dist+1);\\n                        queue.add(nextCell);\\n                        visited[nexti*col+nextj]=true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        LinkedList<List<Integer>> resultList = new LinkedList<>();\\n        \\n        while(!priorityQueue.isEmpty() && k-->0) {\\n            Cell c = priorityQueue.poll();\\n\\n            resultList.add(Arrays.asList(c.r,c.c));\\n        }\\n        return resultList;\\n    }\\n    \\n    public boolean isValid(int i, int j) {\\n        return !(i<0||j<0||i>=row||j>=col);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807652,
                "title": "java-bfs-priorityqueue",
                "content": "```\\nclass SolComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return comparer(a, b, 0);\\n        }\\n        \\n        public int comparer(int[] a, int[] b, int i) {\\n            if(i == 4)\\n                return 0;\\n            if(a[i] > b[i])\\n                return 1;\\n            if(a[i] < b[i])\\n                return -1;\\n            return comparer(a, b, i + 1);\\n        }\\n        \\n    }\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new SolComparator());\\n        \\n        pq.add(new int[]{0, grid[start[0]][start[1]], start[0], start[1]});\\n        visited[start[0]][start[1]] = true;\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        while(!pq.isEmpty()) {\\n            int[] p = pq.poll();\\n            if(p[1] != 1) {\\n                if(p[1] >= pricing[0] && p[1] <= pricing[1])\\n                    ans.add(Arrays.asList(p[2], p[3]));\\n            }\\n            if(ans.size() == k)\\n                break;\\n            int r = p[2];\\n            int c = p[3];\\n            int currDist = p[0];\\n            \\n            if(r - 1 >= 0 && grid[r-1][c] != 0 && !visited[r-1][c]) {\\n                visited[r-1][c] = true;\\n                pq.add(new int[]{currDist + 1, grid[r-1][c], r - 1, c});\\n            }\\n            \\n            if(c - 1 >= 0 && grid[r][c-1] != 0 && !visited[r][c-1]) {\\n                visited[r][c-1] = true;\\n                pq.add(new int[]{currDist + 1, grid[r][c-1], r, c - 1});\\n            }\\n            \\n            if(r + 1 < m && grid[r+1][c] != 0 && !visited[r+1][c]) {\\n                visited[r+1][c] = true;\\n                pq.add(new int[]{currDist + 1, grid[r+1][c], r+1, c});\\n            }\\n            \\n            if(c + 1 < n && grid[r][c+1] != 0 && !visited[r][c+1]) {\\n                visited[r][c+1] = true;\\n                pq.add(new int[]{currDist + 1, grid[r][c+1], r, c + 1});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SolComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return comparer(a, b, 0);\\n        }\\n        \\n        public int comparer(int[] a, int[] b, int i) {\\n            if(i == 4)\\n                return 0;\\n            if(a[i] > b[i])\\n                return 1;\\n            if(a[i] < b[i])\\n                return -1;\\n            return comparer(a, b, i + 1);\\n        }\\n        \\n    }\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new SolComparator());\\n        \\n        pq.add(new int[]{0, grid[start[0]][start[1]], start[0], start[1]});\\n        visited[start[0]][start[1]] = true;\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        while(!pq.isEmpty()) {\\n            int[] p = pq.poll();\\n            if(p[1] != 1) {\\n                if(p[1] >= pricing[0] && p[1] <= pricing[1])\\n                    ans.add(Arrays.asList(p[2], p[3]));\\n            }\\n            if(ans.size() == k)\\n                break;\\n            int r = p[2];\\n            int c = p[3];\\n            int currDist = p[0];\\n            \\n            if(r - 1 >= 0 && grid[r-1][c] != 0 && !visited[r-1][c]) {\\n                visited[r-1][c] = true;\\n                pq.add(new int[]{currDist + 1, grid[r-1][c], r - 1, c});\\n            }\\n            \\n            if(c - 1 >= 0 && grid[r][c-1] != 0 && !visited[r][c-1]) {\\n                visited[r][c-1] = true;\\n                pq.add(new int[]{currDist + 1, grid[r][c-1], r, c - 1});\\n            }\\n            \\n            if(r + 1 < m && grid[r+1][c] != 0 && !visited[r+1][c]) {\\n                visited[r+1][c] = true;\\n                pq.add(new int[]{currDist + 1, grid[r+1][c], r+1, c});\\n            }\\n            \\n            if(c + 1 < n && grid[r][c+1] != 0 && !visited[r][c+1]) {\\n                visited[r][c+1] = true;\\n                pq.add(new int[]{currDist + 1, grid[r][c+1], r, c + 1});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729543,
                "title": "java-with-comments-181-ms-179-4-mb-2146-k-highest-ranked-items-within-a-price-range",
                "content": "The logic is straightforward.\\n- do a Breadth First Search\\n    - starting from the given start position\\n    - get all the items that can be reached, and is within the price range\\n- Sort the items based on the given ranking criteria\\n- Return those items\\n\\nFor better understanding, split the code into multiple methods and added as much comments as possible.\\n\\n---\\n\\n**// Main method**\\n```\\npublic List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   int[] start, int k) {\\n\\n\\tList<List<Integer>> ans = bfs(grid, start, pricing);       // Breadth First Search\\n\\n\\tans.sort(Solution::comparatorBasedOnRanking);              // Sort the items based on ranking\\n\\n\\tans = ans.stream().limit(k).collect(Collectors.toList());  // Get only the highest ranked K Items\\n\\n\\tans.stream().forEach(x -> {                                // Keep only the row and col in the final ans list\\n\\t\\t\\t\\tx.remove(2);                                   // Remove the dist from final ans list\\n\\t\\t\\t\\tx.remove(2);                                   // Remove the price from final ans list\\n\\t\\t\\t});\\n\\n\\treturn ans;                                                // Return the ans\\n}\\n```\\n**// Breadth First Search, to get all possible items with row num, col num, distance from start, and price.**\\n```\\nprivate List<List<Integer>> bfs(int[][] grid, int[] start, int[] pricing) {\\n\\tList<List<Integer>> ans  = new ArrayList();\\n\\n\\tint[][] visited = new int[grid.length][grid[0].length]; // Visited array to track all the already visited items\\n\\tvisited[start[0]][start[1]] = 1; // Set starting item as visited\\n\\n\\tint dist = 0;\\n\\tLinkedList<int[]> queue = new LinkedList<>();\\n\\tqueue.add(new int[]{start[0],start[1]}); // Starting item\\n\\n\\twhile (!queue.isEmpty()) { // BFS Start\\n\\t\\tint size = queue.size();\\n\\t\\twhile(size-- > 0) { // Loop all the items that can be covered at current dist\\n\\t\\t\\tint[] item = queue.poll();\\n\\t\\t\\tint row = item[0];\\n\\t\\t\\tint col = item[1];\\n\\t\\t\\tif (grid[row][col] >= pricing[0] && grid[row][col] <= pricing[1]) { // If current item within range, add to ans\\n\\t\\t\\t\\tList<Integer> temp = new ArrayList();\\n\\t\\t\\t\\ttemp.add(row);             // Current item Row\\n\\t\\t\\t\\ttemp.add(col);             // Current item Column\\n\\t\\t\\t\\ttemp.add(dist);            // Distance of Current item from start\\n\\t\\t\\t\\ttemp.add(grid[row][col]);  // Current item price\\n\\t\\t\\t\\tans.add(temp);             // Add all these 4 values to the ans list\\n\\t\\t\\t}\\n\\t\\t\\tvisitNeighbours(grid, queue, visited, row, col); // Add Neighbours of current item to queue\\n\\t\\t}\\n\\t\\tdist++; // Increment distance, for iterating all the neighbours of current items\\n\\t}\\n\\treturn ans; // Return ans\\n}\\n```\\n**// Add the 4 neighbours to the queue**\\n```\\nprivate void visitNeighbours(int[][] grid, LinkedList<int[]> queue, int[][] visited, int i, int j) {\\n\\tif (i - 1 >= 0 && visited[i - 1][j] != 1 && grid[i-1][j] != 0) {           // (Top Neighbor) Previous Row, Same Column\\n\\t\\tvisited[i-1][j] = 1;\\n\\t\\tqueue.add(new int[]{i - 1, j});\\n\\t}\\n\\tif (i + 1 < grid.length && visited[i + 1][j] != 1 && grid[i+1][j] != 0) {  // (Bottom Neighbor) Next Row, Same Column\\n\\t\\tvisited[i+1][j] = 1;\\n\\t\\tqueue.add(new int[]{i + 1, j});\\n\\t}\\n\\tif (j - 1 >= 0 && visited[i][j-1] != 1 && grid[i][j-1] != 0) {             // (Left Neighbor) Same Row, Previous Column\\n\\t\\tvisited[i][j-1] = 1;\\n\\t\\tqueue.add(new int[]{i, j-1});\\n\\t}\\n\\tif (j+1 < grid[0].length && visited[i][j+1] != 1 && grid[i][j+1] != 0) {   // (Right Neighbor) Same Row, Next Column\\n\\t\\tvisited[i][j+1] = 1;\\n\\t\\tqueue.add(new int[]{i, j+1});\\n\\t}\\n}\\n```\\n**// Comparator to sort the list, based on Ranking**\\n```\\nprivate static int comparatorBasedOnRanking(List<Integer> a, List<Integer> b) {\\n\\tif ( ! a.get(2).equals(b.get(2))) return a.get(2) - b.get(2);  // Distance Ranking\\n\\tif ( ! a.get(3).equals(b.get(3))) return a.get(3) - b.get(3);  // Price Ranking\\n\\tif ( ! a.get(0).equals(b.get(0))) return a.get(0) - b.get(0);  // Row Ranking\\n\\treturn a.get(1) - b.get(1);                                    // Col Ranking\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   int[] start, int k) {\\n\\n\\tList<List<Integer>> ans = bfs(grid, start, pricing);       // Breadth First Search\\n\\n\\tans.sort(Solution::comparatorBasedOnRanking);              // Sort the items based on ranking\\n\\n\\tans = ans.stream().limit(k).collect(Collectors.toList());  // Get only the highest ranked K Items\\n\\n\\tans.stream().forEach(x -> {                                // Keep only the row and col in the final ans list\\n\\t\\t\\t\\tx.remove(2);                                   // Remove the dist from final ans list\\n\\t\\t\\t\\tx.remove(2);                                   // Remove the price from final ans list\\n\\t\\t\\t});\\n\\n\\treturn ans;                                                // Return the ans\\n}\\n```\n```\\nprivate List<List<Integer>> bfs(int[][] grid, int[] start, int[] pricing) {\\n\\tList<List<Integer>> ans  = new ArrayList();\\n\\n\\tint[][] visited = new int[grid.length][grid[0].length]; // Visited array to track all the already visited items\\n\\tvisited[start[0]][start[1]] = 1; // Set starting item as visited\\n\\n\\tint dist = 0;\\n\\tLinkedList<int[]> queue = new LinkedList<>();\\n\\tqueue.add(new int[]{start[0],start[1]}); // Starting item\\n\\n\\twhile (!queue.isEmpty()) { // BFS Start\\n\\t\\tint size = queue.size();\\n\\t\\twhile(size-- > 0) { // Loop all the items that can be covered at current dist\\n\\t\\t\\tint[] item = queue.poll();\\n\\t\\t\\tint row = item[0];\\n\\t\\t\\tint col = item[1];\\n\\t\\t\\tif (grid[row][col] >= pricing[0] && grid[row][col] <= pricing[1]) { // If current item within range, add to ans\\n\\t\\t\\t\\tList<Integer> temp = new ArrayList();\\n\\t\\t\\t\\ttemp.add(row);             // Current item Row\\n\\t\\t\\t\\ttemp.add(col);             // Current item Column\\n\\t\\t\\t\\ttemp.add(dist);            // Distance of Current item from start\\n\\t\\t\\t\\ttemp.add(grid[row][col]);  // Current item price\\n\\t\\t\\t\\tans.add(temp);             // Add all these 4 values to the ans list\\n\\t\\t\\t}\\n\\t\\t\\tvisitNeighbours(grid, queue, visited, row, col); // Add Neighbours of current item to queue\\n\\t\\t}\\n\\t\\tdist++; // Increment distance, for iterating all the neighbours of current items\\n\\t}\\n\\treturn ans; // Return ans\\n}\\n```\n```\\nprivate void visitNeighbours(int[][] grid, LinkedList<int[]> queue, int[][] visited, int i, int j) {\\n\\tif (i - 1 >= 0 && visited[i - 1][j] != 1 && grid[i-1][j] != 0) {           // (Top Neighbor) Previous Row, Same Column\\n\\t\\tvisited[i-1][j] = 1;\\n\\t\\tqueue.add(new int[]{i - 1, j});\\n\\t}\\n\\tif (i + 1 < grid.length && visited[i + 1][j] != 1 && grid[i+1][j] != 0) {  // (Bottom Neighbor) Next Row, Same Column\\n\\t\\tvisited[i+1][j] = 1;\\n\\t\\tqueue.add(new int[]{i + 1, j});\\n\\t}\\n\\tif (j - 1 >= 0 && visited[i][j-1] != 1 && grid[i][j-1] != 0) {             // (Left Neighbor) Same Row, Previous Column\\n\\t\\tvisited[i][j-1] = 1;\\n\\t\\tqueue.add(new int[]{i, j-1});\\n\\t}\\n\\tif (j+1 < grid[0].length && visited[i][j+1] != 1 && grid[i][j+1] != 0) {   // (Right Neighbor) Same Row, Next Column\\n\\t\\tvisited[i][j+1] = 1;\\n\\t\\tqueue.add(new int[]{i, j+1});\\n\\t}\\n}\\n```\n```\\nprivate static int comparatorBasedOnRanking(List<Integer> a, List<Integer> b) {\\n\\tif ( ! a.get(2).equals(b.get(2))) return a.get(2) - b.get(2);  // Distance Ranking\\n\\tif ( ! a.get(3).equals(b.get(3))) return a.get(3) - b.get(3);  // Price Ranking\\n\\tif ( ! a.get(0).equals(b.get(0))) return a.get(0) - b.get(0);  // Row Ranking\\n\\treturn a.get(1) - b.get(1);                                    // Col Ranking\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1727114,
                "title": "bfs-sort-deque-python",
                "content": "Since the distance is the primary concern, start with the start position and gradually increase the distance. At a given distance,\\n* search all the permitted locations (record distance, row, col. Assign 0 to its value in \\u201Cgrid\\u201D in order to avoid duplication) \\n* and all the suitable items (record price, row, col).\\n\\nThis is what BFS means in this solution. Sort the items and put (r, c) into the answer in the same order.  \\n\\nThen extend the distance by 1, repeat the procedure above based on all the recorded permitted locations. Note that we do not have to sort the answer at the end, since we process shorter distances first.\\n\\n```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        lo, hi = pricing\\n        mr, mc = len(grid), len(grid[0])\\n        ans, dist = [], 0\\n        if lo <= grid[start[0]][start[1]] <= hi:\\n            ans.append(start)\\n        grid[start[0]][start[1]] = 0\\n        paths = deque([[0, start[0], start[1]]])                    # dist, row, col\\n\\n        while paths:\\n            dist += 1\\n            batch = []                                              # each batch has the same distance\\n            while paths and paths[0][0] < dist:\\n                _, row, col = paths.popleft()\\n                for r, c in ((row-1, col), (row, col-1), (row, col+1), (row+1, col)):\\n                    if -1 < r < mr and -1 < c < mc and grid[r][c]:  # neither wall nor processed\\n                        if lo <= grid[r][c] <= hi:                  # is an item with a good price\\n                            batch.append([grid[r][c], r, c])        # put it in \"batch\"\\n                        paths.append([dist, r, c])                  # one can pass, so put it in \"paths\"\\n                        grid[r][c] = 0                              # to avoid duplication\\n            ans.extend([[r, c] for _, r, c in sorted(batch)])\\n            if len(ans) >= k:\\n                break\\n        return ans[:k]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        lo, hi = pricing\\n        mr, mc = len(grid), len(grid[0])\\n        ans, dist = [], 0\\n        if lo <= grid[start[0]][start[1]] <= hi:\\n            ans.append(start)\\n        grid[start[0]][start[1]] = 0\\n        paths = deque([[0, start[0], start[1]]])                    # dist, row, col\\n\\n        while paths:\\n            dist += 1\\n            batch = []                                              # each batch has the same distance\\n            while paths and paths[0][0] < dist:\\n                _, row, col = paths.popleft()\\n                for r, c in ((row-1, col), (row, col-1), (row, col+1), (row+1, col)):\\n                    if -1 < r < mr and -1 < c < mc and grid[r][c]:  # neither wall nor processed\\n                        if lo <= grid[r][c] <= hi:                  # is an item with a good price\\n                            batch.append([grid[r][c], r, c])        # put it in \"batch\"\\n                        paths.append([dist, r, c])                  # one can pass, so put it in \"paths\"\\n                        grid[r][c] = 0                              # to avoid duplication\\n            ans.extend([[r, c] for _, r, c in sorted(batch)])\\n            if len(ans) >= k:\\n                break\\n        return ans[:k]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716283,
                "title": "python-bfs-without-deque-steps-by-distance",
                "content": "```python\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        M, N = len(grid), len(grid[0])\\n        result, visited = [], {(*start,)}\\n        i, distance, queue = -1, 0, [((grid[start[0]][start[1]], *start),)]\\n        while i < distance:\\n            i += 1\\n            next_items = []\\n            for price, row, col in queue[i]:\\n                if pricing[0] <= price <= pricing[1]:\\n                    result.append((row, col))\\n                    k -= 1\\n                    if not k:\\n                        return result\\n                for a, b in ((row-1, col), (row, col-1), (row, col+1), (row+1, col)):\\n                    if (a, b) not in visited and 0 <= a < M and 0 <= b < N and grid[a][b]:\\n                        next_items.append((grid[a][b], a, b))\\n                        visited.add((a, b))\\n            if not next_items:\\n                return result\\n            queue.append(sorted(next_items))\\n            distance += 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        M, N = len(grid), len(grid[0])\\n        result, visited = [], {(*start,)}\\n        i, distance, queue = -1, 0, [((grid[start[0]][start[1]], *start),)]\\n        while i < distance:\\n            i += 1\\n            next_items = []\\n            for price, row, col in queue[i]:\\n                if pricing[0] <= price <= pricing[1]:\\n                    result.append((row, col))\\n                    k -= 1\\n                    if not k:\\n                        return result\\n                for a, b in ((row-1, col), (row, col-1), (row, col+1), (row+1, col)):\\n                    if (a, b) not in visited and 0 <= a < M and 0 <= b < N and grid[a][b]:\\n                        next_items.append((grid[a][b], a, b))\\n                        visited.add((a, b))\\n            if not next_items:\\n                return result\\n            queue.append(sorted(next_items))\\n            distance += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713209,
                "title": "python-bfs-sorting",
                "content": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m,n=len(grid),len(grid[0])\\n        q=deque()\\n        q.append((0,start[0],start[1]))\\n        visited=set()\\n        visited.add((start[0],start[1]))\\n        directions=((-1,0),(0,-1),(0,1),(1,0))\\n        res=[]\\n        while q:\\n            dist,x,y=q.popleft()\\n            if pricing[0]<=grid[x][y]<=pricing[1]:\\n                res.append((dist,grid[x][y],x,y))\\n            for d in directions:\\n                new_x,new_y=x+d[0],y+d[1]\\n                if 0<=new_x<m and 0<=new_y<n and grid[new_x][new_y]!=0 and (new_x,new_y) not in visited:\\n                    visited.add((new_x,new_y))\\n                    q.append((dist+1,new_x,new_y))\\n        res.sort()\\n        new_res=[(i,j) for _,_,i,j in res]\\n        return new_res[:k]\\n                    \\n                        \\n\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m,n=len(grid),len(grid[0])\\n        q=deque()\\n        q.append((0,start[0],start[1]))\\n        visited=set()\\n        visited.add((start[0],start[1]))\\n        directions=((-1,0),(0,-1),(0,1),(1,0))\\n        res=[]\\n        while q:\\n            dist,x,y=q.popleft()\\n            if pricing[0]<=grid[x][y]<=pricing[1]:\\n                res.append((dist,grid[x][y],x,y))\\n            for d in directions:\\n                new_x,new_y=x+d[0],y+d[1]\\n                if 0<=new_x<m and 0<=new_y<n and grid[new_x][new_y]!=0 and (new_x,new_y) not in visited:\\n                    visited.add((new_x,new_y))\\n                    q.append((dist+1,new_x,new_y))\\n        res.sort()\\n        new_res=[(i,j) for _,_,i,j in res]\\n        return new_res[:k]\\n                    \\n                        \\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713000,
                "title": "java-clear-and-easy-without-a-priority-queue-returns-answer-as-soon-first-k-are-met",
                "content": "For Avoiding a priority queue, using BFS is important\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        int[] dirx = new int[]{-1, 0, 0, 1};\\n        int[] diry = new int[]{0, -1, 1, 0};\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        int[] starter = new int[]{0, start[0], start[1]};   // distance, x-cord, y-cord\\n        q.add(starter);\\n        \\n        while(q.size() > 0) {\\n            int size = q.size();\\n            \\n            List<int[]> level = new ArrayList<>();\\n            \\n            for (int t = 0; t < size; t++) {\\n                int[] cur = q.poll();\\n                int x = cur[1]; int y = cur[2];\\n                int dist = cur[0];\\n\\n                if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] == true || grid[x][y] == 0) continue;\\n\\n                visited[x][y] = true;\\n\\n                if (grid[x][y] > 1 && grid[x][y] >= pricing[0] && grid[x][y] <= pricing[1]) {\\n                    int[] arr = new int[]{grid[x][y], x, y};\\n                    level.add(arr);\\n                }\\n\\n                for (int i = 0; i < 4; i++) {\\n                    int nx = x + dirx[i]; int ny = y + diry[i];\\n                    int[] node = new int[]{dist + 1, nx, ny};\\n                    q.add(node);\\n                }\\n            }\\n            \\n            Collections.sort(level, (a,b) -> {\\n                if (a[0] != b[0]) return a[0] - b[0];\\n                else if (a[1] != b[1]) return a[1] - b[1];\\n                else return a[2] - b[2];\\n            });\\n            \\n            for (int[] lvl : level) {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(lvl[1]); list.add(lvl[2]); ans.add(list);\\n                \\n                if (ans.size() == k) return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        int[] dirx = new int[]{-1, 0, 0, 1};\\n        int[] diry = new int[]{0, -1, 1, 0};\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        int[] starter = new int[]{0, start[0], start[1]};   // distance, x-cord, y-cord\\n        q.add(starter);\\n        \\n        while(q.size() > 0) {\\n            int size = q.size();\\n            \\n            List<int[]> level = new ArrayList<>();\\n            \\n            for (int t = 0; t < size; t++) {\\n                int[] cur = q.poll();\\n                int x = cur[1]; int y = cur[2];\\n                int dist = cur[0];\\n\\n                if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] == true || grid[x][y] == 0) continue;\\n\\n                visited[x][y] = true;\\n\\n                if (grid[x][y] > 1 && grid[x][y] >= pricing[0] && grid[x][y] <= pricing[1]) {\\n                    int[] arr = new int[]{grid[x][y], x, y};\\n                    level.add(arr);\\n                }\\n\\n                for (int i = 0; i < 4; i++) {\\n                    int nx = x + dirx[i]; int ny = y + diry[i];\\n                    int[] node = new int[]{dist + 1, nx, ny};\\n                    q.add(node);\\n                }\\n            }\\n            \\n            Collections.sort(level, (a,b) -> {\\n                if (a[0] != b[0]) return a[0] - b[0];\\n                else if (a[1] != b[1]) return a[1] - b[1];\\n                else return a[2] - b[2];\\n            });\\n            \\n            for (int[] lvl : level) {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(lvl[1]); list.add(lvl[2]); ans.add(list);\\n                \\n                if (ans.size() == k) return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712355,
                "title": "49-49-test-cases-passed-but-took-too-long-what-may-be-the-reason",
                "content": "**bfs + sorting o(mn) + (mnlogmn) **\\n```\\nclass Solution {\\npublic:\\n    //int x=0,y=0;\\n    static bool comp(const vector<int> &a,const vector<int> &b){\\n        int dist_a=a[3];\\n        int dist_b=b[3];\\n        if(dist_a<dist_b)return 1;\\n        if(dist_a>dist_b)return 0;\\n        if(a[2]<b[2])return 1;\\n        if(a[2]>b[2])return 0;\\n        if(a[0]<b[0])return 1;\\n        if(a[0]>b[0])return 0;\\n        if(a[1]<b[1])return 1;\\n        return 0;\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int> >ans;\\n      //  x=start[0];\\n       // y=start[1];\\n        vector<vector<int> >dist(grid.size(),vector<int>(grid[0].size(),-1));\\n        if(grid[start[0]][start[1]]==0)return {{}};\\n         vector<vector<bool> >vis(grid.size(),vector<bool>(grid[0].size(),0));\\n        queue<pair<int,int> >q;\\n        q.push({start[0],start[1]});\\n        vis[start[0]][start[1]]=1;\\n        int xdir[4]={0,-1,1,0};\\n        int ydir[4]={1,0,0,-1};\\n        dist[start[0]][start[1]]=0;\\n        while(!q.empty())\\n        {\\n            int siz=q.size();\\n            while(siz--)\\n            {\\n               int ax=q.front().first;\\n                int ay=q.front().second;\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int x_ = ax + xdir[i];\\n                    int y_ = ay + ydir[i];\\n                    if(x_<0||x_>=grid.size()||y_<0||y_>=grid[0].size()||grid[x_][y_]==0||vis[x_][y_]){\\n                        continue;\\n                    }\\n                    else{\\n                        dist[x_][y_]=dist[ax][ay]+1;\\n                        vis[x_][y_]=1;\\n                        q.push({x_,y_});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]>=pricing[0]&&grid[i][j]<=pricing[1]&&dist[i][j]!=-1){\\n                    vector<int>temp(4);\\n                    temp[0]=i;\\n                    temp[1]=j;\\n                    temp[2]=grid[i][j];\\n                    temp[3]=dist[i][j];\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end(),comp);\\n        vector<vector<int> >ans1;\\n        for(int i=0;i<k&&i<ans.size();i++)\\n        {\\n            vector<int>temp(2);\\n            temp[0]=ans[i][0];\\n            temp[1]=ans[i][1];\\n            ans1.push_back(temp);\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //int x=0,y=0;\\n    static bool comp(const vector<int> &a,const vector<int> &b){\\n        int dist_a=a[3];\\n        int dist_b=b[3];\\n        if(dist_a<dist_b)return 1;\\n        if(dist_a>dist_b)return 0;\\n        if(a[2]<b[2])return 1;\\n        if(a[2]>b[2])return 0;\\n        if(a[0]<b[0])return 1;\\n        if(a[0]>b[0])return 0;\\n        if(a[1]<b[1])return 1;\\n        return 0;\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int> >ans;\\n      //  x=start[0];\\n       // y=start[1];\\n        vector<vector<int> >dist(grid.size(),vector<int>(grid[0].size(),-1));\\n        if(grid[start[0]][start[1]]==0)return {{}};\\n         vector<vector<bool> >vis(grid.size(),vector<bool>(grid[0].size(),0));\\n        queue<pair<int,int> >q;\\n        q.push({start[0],start[1]});\\n        vis[start[0]][start[1]]=1;\\n        int xdir[4]={0,-1,1,0};\\n        int ydir[4]={1,0,0,-1};\\n        dist[start[0]][start[1]]=0;\\n        while(!q.empty())\\n        {\\n            int siz=q.size();\\n            while(siz--)\\n            {\\n               int ax=q.front().first;\\n                int ay=q.front().second;\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int x_ = ax + xdir[i];\\n                    int y_ = ay + ydir[i];\\n                    if(x_<0||x_>=grid.size()||y_<0||y_>=grid[0].size()||grid[x_][y_]==0||vis[x_][y_]){\\n                        continue;\\n                    }\\n                    else{\\n                        dist[x_][y_]=dist[ax][ay]+1;\\n                        vis[x_][y_]=1;\\n                        q.push({x_,y_});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]>=pricing[0]&&grid[i][j]<=pricing[1]&&dist[i][j]!=-1){\\n                    vector<int>temp(4);\\n                    temp[0]=i;\\n                    temp[1]=j;\\n                    temp[2]=grid[i][j];\\n                    temp[3]=dist[i][j];\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end(),comp);\\n        vector<vector<int> >ans1;\\n        for(int i=0;i<k&&i<ans.size();i++)\\n        {\\n            vector<int>temp(2);\\n            temp[0]=ans[i][0];\\n            temp[1]=ans[i][1];\\n            ans1.push_back(temp);\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711962,
                "title": "simple-c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        set<vector<int>> s;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int l=pricing[0];\\n        int r=pricing[1];\\n        vector<vector<int>> vis(n,vector<int>(m));\\n        queue<pair<pair<int,int>,int>> q;\\n        q.push({{start[0],start[1]},0});\\n        if(grid[start[0]][start[1]]>=l&&grid[start[0]][start[1]]<=r)\\n        {\\n            s.insert({0,grid[start[0]][start[1]],start[0],start[1]});\\n        }\\n        vis[start[0]][start[1]]=1;\\n        const int dx[]={1,-1,0,0};\\n        const int dy[]={0,0,1,-1};\\n        while(!q.empty())\\n        {\\n            auto tp=q.front();\\n            int x=tp.first.first;\\n            int y=tp.first.second;\\n            int dist=tp.second;\\n            q.pop();\\n            for(int dir=0;dir<4;dir++)\\n            {\\n                int x1=x+dx[dir];\\n                int y1=y+dy[dir];\\n                if(x1>=0&&x1<n&&y1>=0&&y1<m&&!vis[x1][y1]&&grid[x1][y1])\\n                {\\n                    vis[x1][y1]=1;\\n                    if(grid[x1][y1]>=l&&grid[x1][y1]<=r)\\n                        s.insert({dist+1,grid[x1][y1],x1,y1});\\n                    q.push({{x1,y1},dist+1});\\n                }\\n            }\\n        }\\n        vector<vector<int>> res;\\n        int c=0;\\n        for(auto &i:s)\\n        {\\n            res.push_back({i[2],i[3]});\\n            c++;\\n            if(c==k)\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        set<vector<int>> s;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int l=pricing[0];\\n        int r=pricing[1];\\n        vector<vector<int>> vis(n,vector<int>(m));\\n        queue<pair<pair<int,int>,int>> q;\\n        q.push({{start[0],start[1]},0});\\n        if(grid[start[0]][start[1]]>=l&&grid[start[0]][start[1]]<=r)\\n        {\\n            s.insert({0,grid[start[0]][start[1]],start[0],start[1]});\\n        }\\n        vis[start[0]][start[1]]=1;\\n        const int dx[]={1,-1,0,0};\\n        const int dy[]={0,0,1,-1};\\n        while(!q.empty())\\n        {\\n            auto tp=q.front();\\n            int x=tp.first.first;\\n            int y=tp.first.second;\\n            int dist=tp.second;\\n            q.pop();\\n            for(int dir=0;dir<4;dir++)\\n            {\\n                int x1=x+dx[dir];\\n                int y1=y+dy[dir];\\n                if(x1>=0&&x1<n&&y1>=0&&y1<m&&!vis[x1][y1]&&grid[x1][y1])\\n                {\\n                    vis[x1][y1]=1;\\n                    if(grid[x1][y1]>=l&&grid[x1][y1]<=r)\\n                        s.insert({dist+1,grid[x1][y1],x1,y1});\\n                    q.push({{x1,y1},dist+1});\\n                }\\n            }\\n        }\\n        vector<vector<int>> res;\\n        int c=0;\\n        for(auto &i:s)\\n        {\\n            res.push_back({i[2],i[3]});\\n            c++;\\n            if(c==k)\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711862,
                "title": "easy-java-bfs-priority-queue-solution",
                "content": "**Approach:**\\n1.Make a priority queue that would store for all the pairs and which is sorted based on given priorities to get the ans in rankwise manner.\\n2.Now start from initial point doing bfs using and also storing all the valid points in a que for traversal (basic bfs) but putting those points in the priority queue that comes in the given price range\\n3.Keep the track of visited points in the by putting -1 in the given grid .\\n4.At the end pop out the k ranked points starting from 1 to k as pq is already sorted so give highest rank ie (1) first and then next upto k.\\n\\n```\\n\\nclass Solution {\\n    static class Pair{\\n\\t\\tint x;\\n\\t\\tint y;\\n        int d;\\n        int price;\\n\\t\\tPair(int x,int y,int d,int p){\\n\\t\\t\\tthis.x=x;\\n\\t\\t\\tthis.y=y;\\n            this.d=d;\\n            this.price=p;\\n\\t\\t}\\n\\t}\\n\\tstatic boolean check(int x,int y,int grid[][]) {\\n\\t//check function is  checking the validity of a coordinate\\n\\t\\tif(x<0||y<0||x>=grid.length||y>=grid[0].length||grid[x][y]==0||grid[x][y]==-1) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n         ArrayList<List<Integer>>l=new ArrayList<List<Integer>>();\\n            PriorityQueue<Pair>pq=new PriorityQueue<Pair>(new Comparator<Pair>() {\\n\\n                @Override\\n                public int compare(Pair o1, Pair o2) {\\n                    int p1x=o1.x;\\n                    int p1y=o1.y;\\n                    int p2x=o2.x;\\n                    int p2y=o2.y;\\n                    if(o1.d!=o2.d) {\\n                        return o1.d-o2.d;\\n                    }\\n                    else if(o1.price!=o2.price) {\\n                       return o1.price-o2.price;\\n                    }\\n                    else if(o1.x!=o2.x) {\\n                        return o1.x-o2.x;\\n                    }\\n                    else {\\n                        return o1.y-o2.y;\\n                    }\\n                }\\n            });\\n            Queue<Pair>p=new LinkedList<Pair>();\\n            int val=grid[start[0]][start[1]];\\n            boolean done=false;\\n            if(val!=0&&val!=1&&val<=pricing[1]&&val>=pricing[0]){\\n\\t\\t\\t//Starting point can also be in the given range so store it if it is in given price range \\n\\t\\t\\t//and mark as visited\\n                pq.add(new Pair(start[0],start[1],0,val));\\n                grid[start[0]][start[1]]=-1;\\n            }\\n            p.add(new Pair(start[0],start[1],0,val));\\n            int d[][]= {{0,-1},{-1,0},{0,1},{1,0}};//l t r d\\n\\t\\t\\t//bfs traversal\\n            while(!p.isEmpty()) {\\n                Pair p1=p.remove();\\n                int x=p1.x;\\n                int y=p1.y;\\n                for(int dr[]:d) {\\n                    int ax=x+dr[0];\\n                    int ay=y+dr[1];\\n\\n                    if(check(ax,ay,grid)) {\\n                       // System.out.println(ax+\" \"+ay);\\n                        Pair pr=new Pair(ax,ay,p1.d+1,grid[ax][ay]);\\n                        p.add(pr);\\n                        if(grid[ax][ay]!=1&&grid[ax][ay]>=pricing[0]&&grid[ax][ay]<=pricing[1]) {\\n                        //    System.out.println(pr.d+\" \"+pr.price);\\n                            pq.add(pr);\\n                        }\\n                        grid[ax][ay]=-1;\\n                    }\\n                }\\n            }\\n\\t\\t\\t//get the top k rankers from the priority que\\n            while(!pq.isEmpty()&&l.size()!=k) {\\n                Pair pr=pq.remove();\\n                ArrayList<Integer>l1=new ArrayList<Integer>();\\n                l1.add(pr.x);\\n                l1.add(pr.y);\\n                l.add(l1);\\n            }\\n\\n            return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\n    static class Pair{\\n\\t\\tint x;\\n\\t\\tint y;\\n        int d;\\n        int price;\\n\\t\\tPair(int x,int y,int d,int p){\\n\\t\\t\\tthis.x=x;\\n\\t\\t\\tthis.y=y;\\n            this.d=d;\\n            this.price=p;\\n\\t\\t}\\n\\t}\\n\\tstatic boolean check(int x,int y,int grid[][]) {\\n\\t//check function is  checking the validity of a coordinate\\n\\t\\tif(x<0||y<0||x>=grid.length||y>=grid[0].length||grid[x][y]==0||grid[x][y]==-1) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n         ArrayList<List<Integer>>l=new ArrayList<List<Integer>>();\\n            PriorityQueue<Pair>pq=new PriorityQueue<Pair>(new Comparator<Pair>() {\\n\\n                @Override\\n                public int compare(Pair o1, Pair o2) {\\n                    int p1x=o1.x;\\n                    int p1y=o1.y;\\n                    int p2x=o2.x;\\n                    int p2y=o2.y;\\n                    if(o1.d!=o2.d) {\\n                        return o1.d-o2.d;\\n                    }\\n                    else if(o1.price!=o2.price) {\\n                       return o1.price-o2.price;\\n                    }\\n                    else if(o1.x!=o2.x) {\\n                        return o1.x-o2.x;\\n                    }\\n                    else {\\n                        return o1.y-o2.y;\\n                    }\\n                }\\n            });\\n            Queue<Pair>p=new LinkedList<Pair>();\\n            int val=grid[start[0]][start[1]];\\n            boolean done=false;\\n            if(val!=0&&val!=1&&val<=pricing[1]&&val>=pricing[0]){\\n\\t\\t\\t//Starting point can also be in the given range so store it if it is in given price range \\n\\t\\t\\t//and mark as visited\\n                pq.add(new Pair(start[0],start[1],0,val));\\n                grid[start[0]][start[1]]=-1;\\n            }\\n            p.add(new Pair(start[0],start[1],0,val));\\n            int d[][]= {{0,-1},{-1,0},{0,1},{1,0}};//l t r d\\n\\t\\t\\t//bfs traversal\\n            while(!p.isEmpty()) {\\n                Pair p1=p.remove();\\n                int x=p1.x;\\n                int y=p1.y;\\n                for(int dr[]:d) {\\n                    int ax=x+dr[0];\\n                    int ay=y+dr[1];\\n\\n                    if(check(ax,ay,grid)) {\\n                       // System.out.println(ax+\" \"+ay);\\n                        Pair pr=new Pair(ax,ay,p1.d+1,grid[ax][ay]);\\n                        p.add(pr);\\n                        if(grid[ax][ay]!=1&&grid[ax][ay]>=pricing[0]&&grid[ax][ay]<=pricing[1]) {\\n                        //    System.out.println(pr.d+\" \"+pr.price);\\n                            pq.add(pr);\\n                        }\\n                        grid[ax][ay]=-1;\\n                    }\\n                }\\n            }\\n\\t\\t\\t//get the top k rankers from the priority que\\n            while(!pq.isEmpty()&&l.size()!=k) {\\n                Pair pr=pq.remove();\\n                ArrayList<Integer>l1=new ArrayList<Integer>();\\n                l1.add(pr.x);\\n                l1.add(pr.y);\\n                l.add(l1);\\n            }\\n\\n            return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710569,
                "title": "javascript-bfs",
                "content": "Here there is a stop at the level when the necessary amount is found. It avoids looking through the warehouse when the desired quantity has already been found.\\n\\n```js\\nconst highestRankedKItems = function(grid, pricing, start, k) {\\n  const [min, max] = pricing;\\n  const res = [];\\n  for (let queue = [start], distance = 1; 0 < queue.length; ++distance) {\\n    const level = [];\\n    for (const [row, column] of queue) \\n      if (grid[row] && grid[row][column]) {\\n        const value = grid[row][column];\\n        if (min <= value && value <= max)\\n          res.push([distance, value, row, column]);\\n        grid[row][column] = 0;\\n        level.push(...[[-1, 0], [0, -1], [0, 1], [1, 0]].map(([dr, dc]) => [row + dr, column + dc]));\\n      }\\n    queue = level;\\n    if (k <= res.length) break;\\n  }\\n  res.sort(([d1, v1, r1, c1], [d2, v2, r2, c2]) => d1 - d2 || v1 - v2 || r1 - r2 || c1 - c2);\\n  return res.slice(0, k).map(([,, row, column]) => [row, column]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```js\\nconst highestRankedKItems = function(grid, pricing, start, k) {\\n  const [min, max] = pricing;\\n  const res = [];\\n  for (let queue = [start], distance = 1; 0 < queue.length; ++distance) {\\n    const level = [];\\n    for (const [row, column] of queue) \\n      if (grid[row] && grid[row][column]) {\\n        const value = grid[row][column];\\n        if (min <= value && value <= max)\\n          res.push([distance, value, row, column]);\\n        grid[row][column] = 0;\\n        level.push(...[[-1, 0], [0, -1], [0, 1], [1, 0]].map(([dr, dc]) => [row + dr, column + dc]));\\n      }\\n    queue = level;\\n    if (k <= res.length) break;\\n  }\\n  res.sort(([d1, v1, r1, c1], [d2, v2, r2, c2]) => d1 - d2 || v1 - v2 || r1 - r2 || c1 - c2);\\n  return res.slice(0, k).map(([,, row, column]) => [row, column]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1710461,
                "title": "using-dijkstras-algorithm",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int i,j,dist;\\n        Pair(int i,int j,int d){\\n            this.i=i;\\n            this.j=j;\\n            dist=d;\\n        }\\n    }\\n    public boolean valid(int x,int y,int pricing[],int [][]grid,int [][]dist,int d){\\n        if(x<0 || y<0 || x>=grid.length || y>=grid[0].length || grid[x][y]==0 || dist[x][y]<= d+1)return false;\\n        return true;\\n    }\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>>out=new ArrayList<List<Integer>>();\\n        int directions[][]=new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\\n        int m=grid.length,n=grid[0].length;\\n        int dist[][]=new int[m][n];\\n        for(int g[]:dist){\\n            Arrays.fill(g,Integer.MAX_VALUE);\\n        }\\n        PriorityQueue<Pair>q=new PriorityQueue<Pair>((a,b)->a.dist-b.dist);\\n        dist[start[0]][start[1]]=0;\\n        q.add(new Pair(start[0],start[1],0));\\n        List<Integer>list;\\n        while(!q.isEmpty()){\\n            Pair p=q.poll();     \\n            for(int i=0;i<directions.length;i++){\\n                int x=p.i+directions[i][0];\\n                int y=p.j+directions[i][1];\\n                if(valid(x,y,pricing,grid,dist,p.dist)){\\n                    q.add(new Pair(x,y,p.dist+1));\\n                    dist[x][y]=p.dist+1;\\n                }\\n            }\\n        }\\n        PriorityQueue<Pair>pq=new PriorityQueue<Pair>((a,b)->{\\n            if(a.dist==b.dist){\\n                if(grid[a.i][a.j]==grid[b.i][b.j]){\\n                    if(a.i==b.i){\\n                        return a.j-b.j;\\n                    }\\n                    return a.i-b.i;\\n                }\\n                return grid[a.i][a.j]-grid[b.i][b.j];\\n            }\\n            return a.dist -b.dist;\\n        });\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0 && grid[i][j]!=1 && dist[i][j]!=Integer.MAX_VALUE){\\n                    pq.add(new Pair(i,j,dist[i][j]));\\n                }\\n            }\\n        }\\n        while(!pq.isEmpty() && k>0){\\n            Pair p=pq.poll();\\n            list=new ArrayList<Integer>();\\n            if(grid[p.i][p.j]<pricing[0] || grid[p.i][p.j]>pricing[1])continue;\\n            list.add(p.i);\\n            list.add(p.j);\\n            out.add(list);\\n            k--;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int i,j,dist;\\n        Pair(int i,int j,int d){\\n            this.i=i;\\n            this.j=j;\\n            dist=d;\\n        }\\n    }\\n    public boolean valid(int x,int y,int pricing[],int [][]grid,int [][]dist,int d){\\n        if(x<0 || y<0 || x>=grid.length || y>=grid[0].length || grid[x][y]==0 || dist[x][y]<= d+1)return false;\\n        return true;\\n    }\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>>out=new ArrayList<List<Integer>>();\\n        int directions[][]=new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\\n        int m=grid.length,n=grid[0].length;\\n        int dist[][]=new int[m][n];\\n        for(int g[]:dist){\\n            Arrays.fill(g,Integer.MAX_VALUE);\\n        }\\n        PriorityQueue<Pair>q=new PriorityQueue<Pair>((a,b)->a.dist-b.dist);\\n        dist[start[0]][start[1]]=0;\\n        q.add(new Pair(start[0],start[1],0));\\n        List<Integer>list;\\n        while(!q.isEmpty()){\\n            Pair p=q.poll();     \\n            for(int i=0;i<directions.length;i++){\\n                int x=p.i+directions[i][0];\\n                int y=p.j+directions[i][1];\\n                if(valid(x,y,pricing,grid,dist,p.dist)){\\n                    q.add(new Pair(x,y,p.dist+1));\\n                    dist[x][y]=p.dist+1;\\n                }\\n            }\\n        }\\n        PriorityQueue<Pair>pq=new PriorityQueue<Pair>((a,b)->{\\n            if(a.dist==b.dist){\\n                if(grid[a.i][a.j]==grid[b.i][b.j]){\\n                    if(a.i==b.i){\\n                        return a.j-b.j;\\n                    }\\n                    return a.i-b.i;\\n                }\\n                return grid[a.i][a.j]-grid[b.i][b.j];\\n            }\\n            return a.dist -b.dist;\\n        });\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0 && grid[i][j]!=1 && dist[i][j]!=Integer.MAX_VALUE){\\n                    pq.add(new Pair(i,j,dist[i][j]));\\n                }\\n            }\\n        }\\n        while(!pq.isEmpty() && k>0){\\n            Pair p=pq.poll();\\n            list=new ArrayList<Integer>();\\n            if(grid[p.i][p.j]<pricing[0] || grid[p.i][p.j]>pricing[1])continue;\\n            list.add(p.i);\\n            list.add(p.j);\\n            out.add(list);\\n            k--;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710332,
                "title": "stupid-and-unfair-tle-runtime-too-strict-or-c-comparators-too-bad",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nint dirX[4] = {1, 0, -1, 0};\\nint dirY[4] = {0, 1, 0, -1};\\n\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    vector<vector<int>> vis(n, vector<int> (m, false));\\n\\n    queue<pair<pair<int, int>, int>> q;\\n    q.push({{start[0], start[1]}, 0});\\n\\n    vector<vector<int>> reach;\\n\\n    while (!q.empty()) {\\n        auto x = q.front();\\n        auto mx = x.first;\\n        vis[mx.first][mx.second] = true;\\n        int dis = x.second;\\n        q.pop();\\n    \\n        if (grid[mx.first][mx.second] >= pricing[0] && grid[mx.first][mx.second] <= pricing[1]) {\\n            reach.push_back({dis, grid[mx.first][mx.second],mx.first, mx.second});                   \\n        }\\n        \\n        for (int i = 0; i < 4; ++i) {\\n            int desX = dirX[i] + mx.first;\\n            int desY = dirY[i] + mx.second;\\n\\n            if (desX >= 0 && desX < n && desY >= 0 && desY < m && !vis[desX][desY] && grid[desX][desY] > 0) {   \\n                vis[desX][desY]=true;\\n                q.push({{desX, desY}, (dis + 1)});\\n            }\\n        }\\n    }   \\n    \\n    sort(reach.begin(), reach.end());\\n\\n    vector<vector<int>> ans;\\n    int rn=reach.size();\\n  \\n    for (int i = 0; i < min(k,rn); ++i) {\\n   \\n        ans.push_back({reach[i][2],reach[i][3]});\\n    }\\n\\n    return ans;\\n}\\n};\\n```\\nThis code gets accepted\\nBut same complexity code with a comparator with sort fails to pass and gives TLE\\n\\n```\\nclass Solution {\\npublic:\\nint dirX[4] = {1, 0, -1, 0};\\nint dirY[4] = {0, 1, 0, -1};\\n\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    vector<vector<int>> vis(n, vector<int> (m, false));\\n\\n    queue<pair<pair<int, int>, int>> q;\\n    q.push({{start[0], start[1]}, 0});\\n\\n    vector<pair<vector<int>, vector<int>>> reach;\\n\\n    while (!q.empty()) {\\n        auto x = q.front();\\n        auto mx = x.first;\\n        vis[mx.first][mx.second] = true;\\n        int dis = x.second;\\n        q.pop();\\n    \\n        if (grid[mx.first][mx.second] >= pricing[0] && grid[mx.first][mx.second] <= pricing[1]) {\\n            reach.push_back({{mx.first, mx.second}, {dis, grid[mx.first][mx.second]}});                   \\n        }\\n        \\n        for (int i = 0; i < 4; ++i) {\\n            int desX = dirX[i] + mx.first;\\n            int desY = dirY[i] + mx.second;\\n\\n            if (desX >= 0 && desX < n && desY >= 0 && desY < m && !vis[desX][desY] && grid[desX][desY] > 0) {   \\n                vis[desX][desY]=true;\\n                q.push({{desX, desY}, (dis + 1)});\\n            }\\n        }\\n    }   \\n    \\n    sort(reach.begin(), reach.end(), [](pair<vector<int>, vector<int>> a, pair<vector<int>, vector<int>> b) {\\n        int disA = a.second[0];\\n        int disB = b.second[0];\\n\\n        int priceA = a.second[1];\\n        int priceB = b.second[1];\\n\\n        int rowA = a.first[0];\\n        int rowB = b.first[0];\\n\\n        int colA = a.first[1];\\n        int colB = b.first[1];\\n\\n        if (disA < disB) {\\n            return true;\\n        }\\n        else if (disA==disB&&priceA < priceB) {\\n            return true;\\n        }\\n        else if (disA==disB&&priceA == priceB&&rowA < rowB) {\\n            return true;\\n        }\\n        else if (disA==disB&&priceA == priceB&&rowA == rowB&&colA < colB) {\\n            return true;\\n        }\\n        return false;\\n    });\\n    \\n    \\n    \\n    vector<vector<int>> ans;\\n    int rn=reach.size();\\n  \\n    for (int i = 0; i < min(k,rn); ++i) {\\n   \\n        ans.push_back(reach[i].first);\\n    }\\n\\n    return ans;\\n}\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/54bbeb51-f578-44d2-9550-3f1b754a77fb_1642874681.2395372.png)\\n\\nI tried to submit this code 3 times in the contest but gave tle.\\n*Learning - Avoid Comparators if runtime is very strict.*\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nint dirX[4] = {1, 0, -1, 0};\\nint dirY[4] = {0, 1, 0, -1};\\n\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    vector<vector<int>> vis(n, vector<int> (m, false));\\n\\n    queue<pair<pair<int, int>, int>> q;\\n    q.push({{start[0], start[1]}, 0});\\n\\n    vector<vector<int>> reach;\\n\\n    while (!q.empty()) {\\n        auto x = q.front();\\n        auto mx = x.first;\\n        vis[mx.first][mx.second] = true;\\n        int dis = x.second;\\n        q.pop();\\n    \\n        if (grid[mx.first][mx.second] >= pricing[0] && grid[mx.first][mx.second] <= pricing[1]) {\\n            reach.push_back({dis, grid[mx.first][mx.second],mx.first, mx.second});                   \\n        }\\n        \\n        for (int i = 0; i < 4; ++i) {\\n            int desX = dirX[i] + mx.first;\\n            int desY = dirY[i] + mx.second;\\n\\n            if (desX >= 0 && desX < n && desY >= 0 && desY < m && !vis[desX][desY] && grid[desX][desY] > 0) {   \\n                vis[desX][desY]=true;\\n                q.push({{desX, desY}, (dis + 1)});\\n            }\\n        }\\n    }   \\n    \\n    sort(reach.begin(), reach.end());\\n\\n    vector<vector<int>> ans;\\n    int rn=reach.size();\\n  \\n    for (int i = 0; i < min(k,rn); ++i) {\\n   \\n        ans.push_back({reach[i][2],reach[i][3]});\\n    }\\n\\n    return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint dirX[4] = {1, 0, -1, 0};\\nint dirY[4] = {0, 1, 0, -1};\\n\\nvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    vector<vector<int>> vis(n, vector<int> (m, false));\\n\\n    queue<pair<pair<int, int>, int>> q;\\n    q.push({{start[0], start[1]}, 0});\\n\\n    vector<pair<vector<int>, vector<int>>> reach;\\n\\n    while (!q.empty()) {\\n        auto x = q.front();\\n        auto mx = x.first;\\n        vis[mx.first][mx.second] = true;\\n        int dis = x.second;\\n        q.pop();\\n    \\n        if (grid[mx.first][mx.second] >= pricing[0] && grid[mx.first][mx.second] <= pricing[1]) {\\n            reach.push_back({{mx.first, mx.second}, {dis, grid[mx.first][mx.second]}});                   \\n        }\\n        \\n        for (int i = 0; i < 4; ++i) {\\n            int desX = dirX[i] + mx.first;\\n            int desY = dirY[i] + mx.second;\\n\\n            if (desX >= 0 && desX < n && desY >= 0 && desY < m && !vis[desX][desY] && grid[desX][desY] > 0) {   \\n                vis[desX][desY]=true;\\n                q.push({{desX, desY}, (dis + 1)});\\n            }\\n        }\\n    }   \\n    \\n    sort(reach.begin(), reach.end(), [](pair<vector<int>, vector<int>> a, pair<vector<int>, vector<int>> b) {\\n        int disA = a.second[0];\\n        int disB = b.second[0];\\n\\n        int priceA = a.second[1];\\n        int priceB = b.second[1];\\n\\n        int rowA = a.first[0];\\n        int rowB = b.first[0];\\n\\n        int colA = a.first[1];\\n        int colB = b.first[1];\\n\\n        if (disA < disB) {\\n            return true;\\n        }\\n        else if (disA==disB&&priceA < priceB) {\\n            return true;\\n        }\\n        else if (disA==disB&&priceA == priceB&&rowA < rowB) {\\n            return true;\\n        }\\n        else if (disA==disB&&priceA == priceB&&rowA == rowB&&colA < colB) {\\n            return true;\\n        }\\n        return false;\\n    });\\n    \\n    \\n    \\n    vector<vector<int>> ans;\\n    int rn=reach.size();\\n  \\n    for (int i = 0; i < min(k,rn); ++i) {\\n   \\n        ans.push_back(reach[i].first);\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710320,
                "title": "cpp-bfs-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& price, vector<int>& start, int k) {\\n        \\n        queue<pair<int, int>> q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        q.emplace(start[0], start[1]);\\n        \\n        vector<pair<int, int>> dir = {{-1,0},  {0,1}, {0,-1}, {1,0}};\\n        \\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        \\n        vector<tuple<int, int, int, int>> res; // dist, price, y, x\\n        dp[start[0]][start[1]] = 0;\\n        \\n        while(!q.empty()){\\n            auto [r, c] = q.front();\\n            q.pop();\\n\\n            for(int i=0; i<4; i++){\\n                auto [dy,dx] = dir[i];\\n                \\n                int y = r+dy;\\n                int x = c+dx;\\n\\n                if (0<=y && y<n && 0<=x && x<m && dp[y][x]==-1 && grid[y][x]){\\n                    q.emplace(y,x);\\n                    dp[y][x] = 1+ dp[r][c];\\n                }               \\n            }            \\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if (dp[i][j]>-1 && price[0]<=grid[i][j] && grid[i][j]<=price[1]){\\n                    res.push_back({dp[i][j], grid[i][j], i, j});\\n                }\\n            }\\n        }\\n                \\n        sort(res.begin(), res.end());\\n\\n        \\n        vector<vector<int>> ans;\\n\\n        for (auto it: res){\\n            auto [dist, price,y,x] = it;\\n            ans.push_back({y,x});\\n            \\n            k--;\\n            if (k==0) break;\\n        \\n        }\\n        \\n        return  ans;    \\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& price, vector<int>& start, int k) {\\n        \\n        queue<pair<int, int>> q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        q.emplace(start[0], start[1]);\\n        \\n        vector<pair<int, int>> dir = {{-1,0},  {0,1}, {0,-1}, {1,0}};\\n        \\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        \\n        vector<tuple<int, int, int, int>> res; // dist, price, y, x\\n        dp[start[0]][start[1]] = 0;\\n        \\n        while(!q.empty()){\\n            auto [r, c] = q.front();\\n            q.pop();\\n\\n            for(int i=0; i<4; i++){\\n                auto [dy,dx] = dir[i];\\n                \\n                int y = r+dy;\\n                int x = c+dx;\\n\\n                if (0<=y && y<n && 0<=x && x<m && dp[y][x]==-1 && grid[y][x]){\\n                    q.emplace(y,x);\\n                    dp[y][x] = 1+ dp[r][c];\\n                }               \\n            }            \\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if (dp[i][j]>-1 && price[0]<=grid[i][j] && grid[i][j]<=price[1]){\\n                    res.push_back({dp[i][j], grid[i][j], i, j});\\n                }\\n            }\\n        }\\n                \\n        sort(res.begin(), res.end());\\n\\n        \\n        vector<vector<int>> ans;\\n\\n        for (auto it: res){\\n            auto [dist, price,y,x] = it;\\n            ans.push_back({y,x});\\n            \\n            k--;\\n            if (k==0) break;\\n        \\n        }\\n        \\n        return  ans;    \\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710135,
                "title": "java-bfs-with-custom-comparator",
                "content": "```\\nclass Solution {\\n    static int[][] DIRS= {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    \\n    class Item{\\n        int d, p, r, c;  // distance, price, row, column\\n        Item(int d, int p, int r, int c){ this.d= d; this.p= p; this.r= r; this.c= c; }\\n    }\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int m= grid.length, n= grid[0].length;\\n        PriorityQueue<Item> ans= new PriorityQueue<>((i1,i2)->{\\n            int comp= Integer.compare(i1.d, i2.d);\\n            if(comp!=0) return comp;\\n            comp= Integer.compare(i1.p, i2.p);\\n            if(comp!=0) return comp;\\n            comp= Integer.compare(i1.r, i2.r);\\n            if(comp!=0) return comp;\\n            return Integer.compare(i1.c, i2.c);\\n        });\\n        \\n        int low= pricing[0], high= pricing[1];\\n        LinkedList<Item> q= new LinkedList<>();\\n        int i= start[0], j= start[1];\\n        if(grid[i][j]>0){\\n            q.add(new Item(0, grid[i][j], i, j));\\n            grid[i][j]= -1; // mark start visited\\n        }\\n        int dist= 1;\\n        //dfs until we find k best items (no need to go deeper in dfs as the primary criterium is distance)\\n        while(!q.isEmpty() && ans.size()<k){\\n            int qSz= q.size();\\n            while(qSz-->0){\\n                Item it= q.remove();\\n                if(it.p>=low && it.p<=high) ans.add(it);\\n                for(int[] dir:DIRS){\\n                    int nr= it.r+dir[0], nc= it.c+dir[1];\\n                    if(nr<0 || nr>=m || nc<0 || nc>=n) continue;\\n                    if(grid[nr][nc]<=0) continue; // wall or visited;\\n                    q.add(new Item(dist, grid[nr][nc], nr, nc));\\n                    grid[nr][nc]= -1; // mark visited\\n                }\\n            }\\n            dist++;\\n        }\\n        return ansToList(ans, k);\\n    }\\n    \\n    List<List<Integer>> ansToList(PriorityQueue<Item> pq, int k){\\n        ArrayList<List<Integer>> ans= new ArrayList<>();\\n        for(int i=0; i<k; i++){\\n            if(pq.isEmpty()) break;\\n            Item it= pq.remove();\\n            ans.add(Arrays.asList(it.r, it.c));\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int[][] DIRS= {{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 1710130,
                "title": "cpp-bfs",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pr, vector<int>& start, int k)     {\\n        vector<vector<int>> v1,vis;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> v;\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                v.push_back(0);\\n            }\\n            vis.push_back(v);\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        vis[start[0]][start[1]]=1;\\n        if(grid[start[0]][start[1]]>=pr[0]&&grid[start[0]][start[1]]<=pr[1])\\n        {\\n            v1.push_back({start[0],start[1]});\\n        }\\n        int n=grid.size(),m=grid[0].size();\\n        while(q.size()>0&&v1.size()<k)\\n        {\\n            int a=q.size();\\n            vector<vector<int>> v2;\\n            while(a>0&&v1.size()<k)\\n            {\\n                a--;\\n                int x=q.front().first,y=q.front().second;\\n                q.pop();\\n                if(x+1<n&&vis[x+1][y]==0)\\n                {\\n                    vis[x+1][y]=1;\\n                    if(grid[x+1][y]!=0)\\n                    {\\n                        q.push({x+1,y});\\n                        if(grid[x+1][y]>=pr[0]&&grid[x+1][y]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x+1][y],x+1,y});\\n                        }\\n                    }\\n                }\\n                if(y+1<m&&vis[x][y+1]==0)\\n                {\\n                    vis[x][y+1]=1;\\n                    if(grid[x][y+1]!=0)\\n                    {\\n                        q.push({x,y+1});\\n                        if(grid[x][y+1]>=pr[0]&&grid[x][y+1]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x][y+1],x,y+1});\\n                        }\\n                    }\\n                }\\n                if(x-1>=0&&vis[x-1][y]==0)\\n                {\\n                    vis[x-1][y]=1;\\n                    if(grid[x-1][y]!=0)\\n                    {\\n                        q.push({x-1,y});\\n                        if(grid[x-1][y]>=pr[0]&&grid[x-1][y]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x-1][y],x-1,y});\\n                        }\\n                    }\\n                }\\n                if(y-1>=0&&vis[x][y-1]==0)\\n                {\\n                    vis[x][y-1]=1;\\n                    if(grid[x][y-1]!=0)\\n                    {\\n                        q.push({x,y-1});\\n                        if(grid[x][y-1]>=pr[0]&&grid[x][y-1]<=pr[1])\\n                        {\\n                            v2.push_back({grid[x][y-1],x,y-1});\\n                        }\\n                    }\\n                }\\n            }\\n            sort(v2.begin(),v2.end());\\n            for(int i=0;i<v2.size()&&v1.size()<k;i++)\\n            {\\n                v1.push_back({v2[i][1],v2[i][2]});\\n            }\\n        }\\n        return v1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pr, vector<int>& start, int k)     {\\n        vector<vector<int>> v1,vis;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> v;\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                v.push_back(0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1710091,
                "title": "c-bfs-sorting",
                "content": "**PLEASE UPVOTE IF U LIKE MY SOLUTION**\\n\\n```\\nclass Solution {\\n    struct node{\\n        int x,y,p,level;\\n    };\\n \\n    static bool comp(const node& c1,const node& c2)\\n    {\\n        if(c1.level!=c2.level)\\n            return c1.level<c2.level;\\n        else if(c1.p!=c2.p)\\n            return c1.p<c2.p;\\n        else if(c1.x!=c2.x)\\n            return c1.x<c2.x;\\n        return c1.y<c2.y;\\n            \\n    }\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        queue<node>q;\\n        vector<node>v;\\n        q.push({start[0],start[1],grid[start[0]][start[1]],0});\\n        set<pair<int,int>>s;\\n        int level=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            level++;\\n            while(size--)\\n            {\\n                auto [x,y,p,l]=q.front();\\n        \\n            if(p>=pricing[0]&&p<=pricing[1]&&p!=1)\\n            v.push_back(q.front());\\n            \\n            grid[x][y]=0;\\n            q.pop();\\n            \\n            \\n            \\n            int dir[4][2]={{1,0},{0,1},{0,-1},{-1,0}};\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int ni=x+dir[i][0];\\n                int nj=y+dir[i][1];\\n                \\n                if(ni>=0&&nj>=0&&ni<grid.size()&&nj<grid[0].size()&&grid[ni][nj]!=0)\\n                {\\n                    if(!s.count({ni,nj}))\\n                    {q.push({ni,nj,grid[ni][nj],level});\\n                     s.insert({ni,nj});}\\n                }\\n            }\\n            }\\n        }\\n        // for(auto &it:v)\\n        //     cout<<it.x<<\" \"<<it.y<<\"\\\\n\";\\n        sort(v.begin(),v.end(),comp);\\n        vector<vector<int>>res;\\n        \\n        \\n     \\n        for(int i=0;i<v.size()&&i<k;i++)\\n        {\\n    res.push_back({v[i].x,v[i].y});\\n            }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    struct node{\\n        int x,y,p,level;\\n    };\\n \\n    static bool comp(const node& c1,const node& c2)\\n    {\\n        if(c1.level!=c2.level)\\n            return c1.level<c2.level;\\n        else if(c1.p!=c2.p)\\n            return c1.p<c2.p;\\n        else if(c1.x!=c2.x)\\n            return c1.x<c2.x;\\n        return c1.y<c2.y;\\n            \\n    }\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        queue<node>q;\\n        vector<node>v;\\n        q.push({start[0],start[1],grid[start[0]][start[1]],0});\\n        set<pair<int,int>>s;\\n        int level=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            level++;\\n            while(size--)\\n            {\\n                auto [x,y,p,l]=q.front();\\n        \\n            if(p>=pricing[0]&&p<=pricing[1]&&p!=1)\\n            v.push_back(q.front());\\n            \\n            grid[x][y]=0;\\n            q.pop();\\n            \\n            \\n            \\n            int dir[4][2]={{1,0},{0,1},{0,-1},{-1,0}};\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int ni=x+dir[i][0];\\n                int nj=y+dir[i][1];\\n                \\n                if(ni>=0&&nj>=0&&ni<grid.size()&&nj<grid[0].size()&&grid[ni][nj]!=0)\\n                {\\n                    if(!s.count({ni,nj}))\\n                    {q.push({ni,nj,grid[ni][nj],level});\\n                     s.insert({ni,nj});}\\n                }\\n            }\\n            }\\n        }\\n        // for(auto &it:v)\\n        //     cout<<it.x<<\" \"<<it.y<<\"\\\\n\";\\n        sort(v.begin(),v.end(),comp);\\n        vector<vector<int>>res;\\n        \\n        \\n     \\n        for(int i=0;i<v.size()&&i<k;i++)\\n        {\\n    res.push_back({v[i].x,v[i].y});\\n            }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1710090,
                "title": "bfs-java-solution-sorting-collections-sort-using-custom-comparator",
                "content": "The comments in the solution depicts my thought process, while solving this question in the **Biweekly Contest - 70**. The code looks big, but is easy to understand.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int low = pricing[0];\\n        int high = pricing[1];\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Queue<Pair> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[n][m];\\n        ArrayList<Pair> list = new ArrayList<>();\\n        int dis = 0;\\n        q.add(new Pair(start[0], start[1], grid[start[0]][start[1]], 0));\\n        visited[start[0]][start[1]] = true;\\n\\t\\t// normal bfs starts here.\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            dis++;\\n            while (size-- > 0) {\\n                Pair p = q.remove();\\n                int x = p.x;\\n                int y = p.y;\\n                int val = p.val;\\n\\t\\t\\t\\t// if nearby cells in range add that element to queue and mark the cell as visited.\\n                if (isInRange(x + 1, y, n, m, grid, visited, low, high)) {\\n                    q.add(new Pair(x + 1, y, grid[x + 1][y], dis));\\n                    visited[x + 1][y] = true;\\n                }\\n                if (isInRange(x - 1, y, n, m, grid, visited, low, high)) {\\n                    q.add(new Pair(x - 1, y, grid[x - 1][y], dis));\\n                    visited[x - 1][y] = true;\\n                }\\n                if (isInRange(x, y + 1, n, m, grid, visited, low, high)) {\\n                    q.add(new Pair(x, y + 1, grid[x][y + 1], dis));\\n                    visited[x][y + 1] = true;\\n                }\\n                if (isInRange(x, y - 1, n, m, grid, visited, low, high)) {\\n                    q.add(new Pair(x, y - 1, grid[x][y - 1], dis));\\n                    visited[x][y - 1] = true;\\n                }\\n\\t\\t\\t\\t// add every element of queue to list.\\n                list.add(new Pair(p.x, p.y, p.val, p.dis));\\n            }\\n        }\\n        ArrayList<Pair> list2 = new ArrayList<>();\\n        for(Pair p: list) {\\n\\t\\t    // remove the values from list if they are not in pricing range and add that to list2.\\n            if (p.val != 1 && p.val >= low && p.val <= high) {\\n                list2.add(new Pair(p.x, p.y, p.val, p.dis));\\n            }\\n        }\\n\\t\\t// Most important part. Sorting the list2 on basis of the conditions given in question. Higher rank cells must be added first(before) in the list.\\n        Collections.sort(list2, new Comparator<Pair>() {\\n            @Override\\n            public int compare(Pair p1, Pair p2) {\\n\\t\\t\\t    // first check on basis of distance (high value, then add it before the second pair).\\n                if (p1.dis > p2.dis) {\\n                    return 1;\\n                } else if (p1.dis < p2.dis) {\\n                    return -1;\\n                } else {\\n\\t\\t\\t\\t   // if distances are equal, then second check on basis of value (high value, then add it before the second pair).\\n                    if (p1.val > p2.val) {\\n                        return 1;\\n                    } else if (p1.val < p2.val) {\\n                        return -1;\\n                    } else {\\n\\t\\t\\t\\t\\t    // if distances and values are equal, then third check on basis of x-coordinate (high value, then add it before the second pair).\\n                        if (p1.x > p2.x) {\\n                            return 1;\\n                        } else if (p1.x < p2.x) {\\n                            return -1;\\n                        } else {\\n\\t\\t\\t\\t\\t\\t   // if distances, values and x-coordinate are equal, then fourth check on basis of y-coordinate (high value, then add it before the second pair).).\\n                            if (p1.y > p2.y) {\\n                                return 1;\\n                            } else {\\n                                return -1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        });\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\t\\t// selecting only first k values from list2, and adding there x,y - coordinates in ans arraylist.\\n        for(Pair p: list2) {\\n            if (k == 0) {\\n                break;\\n            } \\n            k--;\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(p.x);\\n            temp.add(p.y);\\n            ans.add(new ArrayList<>(temp));\\n        }\\n        return ans;\\n    }\\n    \\n\\t// check whether i, j is in range or not (ignore visited cells and cells with zero value)\\n    private boolean isInRange(int i, int j, int n, int m, int[][] grid, boolean[][] visited, int low, int high) {\\n        if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 0 || visited[i][j]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n// Pair class for x-coordinate, y-coordinate, grid value, distance from start point\\nclass Pair {\\n    int x; int y; int val; int dis;\\n    \\n    public Pair(int x, int y, int val, int dis) {\\n        this.x = x;\\n        this.y = y;\\n        this.val = val;\\n        this.dis = dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int low = pricing[0];\\n        int high = pricing[1];\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Queue<Pair> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[n][m];\\n        ArrayList<Pair> list = new ArrayList<>();\\n        int dis = 0;\\n        q.add(new Pair(start[0], start[1], grid[start[0]][start[1]], 0));\\n        visited[start[0]][start[1]] = true;\\n\\t\\t// normal bfs starts here.\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            dis++;\\n            while (size-- > 0) {\\n                Pair p = q.remove();\\n                int x = p.x;\\n                int y = p.y;\\n                int val = p.val;\\n\\t\\t\\t\\t// if nearby cells in range add that element to queue and mark the cell as visited.\\n                if (isInRange(x + 1, y, n, m, grid, visited, low, high)) {\\n                    q.add(new Pair(x + 1, y, grid[x + 1][y], dis));\\n                    visited[x + 1][y] = true;\\n                }\\n                if (isInRange(x - 1, y, n, m, grid, visited, low, high)) {\\n                    q.add(new Pair(x - 1, y, grid[x - 1][y], dis));\\n                    visited[x - 1][y] = true;\\n                }\\n                if (isInRange(x, y + 1, n, m, grid, visited, low, high)) {\\n                    q.add(new Pair(x, y + 1, grid[x][y + 1], dis));\\n                    visited[x][y + 1] = true;\\n                }\\n                if (isInRange(x, y - 1, n, m, grid, visited, low, high)) {\\n                    q.add(new Pair(x, y - 1, grid[x][y - 1], dis));\\n                    visited[x][y - 1] = true;\\n                }\\n\\t\\t\\t\\t// add every element of queue to list.\\n                list.add(new Pair(p.x, p.y, p.val, p.dis));\\n            }\\n        }\\n        ArrayList<Pair> list2 = new ArrayList<>();\\n        for(Pair p: list) {\\n\\t\\t    // remove the values from list if they are not in pricing range and add that to list2.\\n            if (p.val != 1 && p.val >= low && p.val <= high) {\\n                list2.add(new Pair(p.x, p.y, p.val, p.dis));\\n            }\\n        }\\n\\t\\t// Most important part. Sorting the list2 on basis of the conditions given in question. Higher rank cells must be added first(before) in the list.\\n        Collections.sort(list2, new Comparator<Pair>() {\\n            @Override\\n            public int compare(Pair p1, Pair p2) {\\n\\t\\t\\t    // first check on basis of distance (high value, then add it before the second pair).\\n                if (p1.dis > p2.dis) {\\n                    return 1;\\n                } else if (p1.dis < p2.dis) {\\n                    return -1;\\n                } else {\\n\\t\\t\\t\\t   // if distances are equal, then second check on basis of value (high value, then add it before the second pair).\\n                    if (p1.val > p2.val) {\\n                        return 1;\\n                    } else if (p1.val < p2.val) {\\n                        return -1;\\n                    } else {\\n\\t\\t\\t\\t\\t    // if distances and values are equal, then third check on basis of x-coordinate (high value, then add it before the second pair).\\n                        if (p1.x > p2.x) {\\n                            return 1;\\n                        } else if (p1.x < p2.x) {\\n                            return -1;\\n                        } else {\\n\\t\\t\\t\\t\\t\\t   // if distances, values and x-coordinate are equal, then fourth check on basis of y-coordinate (high value, then add it before the second pair).).\\n                            if (p1.y > p2.y) {\\n                                return 1;\\n                            } else {\\n                                return -1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        });\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\t\\t// selecting only first k values from list2, and adding there x,y - coordinates in ans arraylist.\\n        for(Pair p: list2) {\\n            if (k == 0) {\\n                break;\\n            } \\n            k--;\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(p.x);\\n            temp.add(p.y);\\n            ans.add(new ArrayList<>(temp));\\n        }\\n        return ans;\\n    }\\n    \\n\\t// check whether i, j is in range or not (ignore visited cells and cells with zero value)\\n    private boolean isInRange(int i, int j, int n, int m, int[][] grid, boolean[][] visited, int low, int high) {\\n        if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 0 || visited[i][j]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n// Pair class for x-coordinate, y-coordinate, grid value, distance from start point\\nclass Pair {\\n    int x; int y; int val; int dis;\\n    \\n    public Pair(int x, int y, int val, int dis) {\\n        this.x = x;\\n        this.y = y;\\n        this.val = val;\\n        this.dis = dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710041,
                "title": "simple-bfs-c-solution",
                "content": "**Approach**\\n1) Perform BFS on grid\\n2) Declare a structure **node** which contains entries (distance, price, row, col)\\n3) While performing BFS check if all conditiions are met then insert entry into a **vector\\\\<node> store** \\n4) To optimize the solution we can break out of the loop as soon as **store.size() >= k**. Here we can\\'t break as soon as **store.size() == k** because there may be a case that cell with lower price and same distance has not been visited yet.\\n5) To tackle that we can keep an addition flag **ind**, which will store the distance as soon as **store.size() == k** i.e **ind == dist** and now wait till all the entries with distance **ind** has been entered into store and then break\\n6) Next step is to sort store using std::sort and an additional **comparator**, which will sort store on the basis of lower distance then lower price then lower row then lower col\\n7) If store.size() > k, return first k entries of [row,col] in store, else return all the entries.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int distr[4] = {0,1,-1,0};\\n    int distc[4] = {1,0,0,-1};\\n    \\n    struct node {\\n        int dist;\\n        int price;\\n        int row;\\n        int col;\\n    };\\n    \\n    static bool compare(const node a, const node b) {\\n        if(a.dist < b.dist) return true;\\n        else if(a.dist == b.dist) {\\n            if(a.price < b.price) return true;\\n            else if(a.price == b.price) {\\n                if(a.row < b.row) return true;\\n                else if(a.row == b.row) {\\n                    if(a.col < b.col) return true;\\n                    else return false;\\n                }\\n                return false;\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<node> store;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>> q;\\n        q.push({{start[0], start[1]}, 1});\\n        vis[start[0]][start[1]] = 1;\\n        int ind = INT_MAX;\\n        while(!q.empty()) {\\n            int row = q.front().first.first;\\n            int col = q.front().first.second;\\n            int dis = q.front().second;\\n            q.pop();\\n            if(grid[row][col] > 1) {\\n                if(dis > ind) break;\\n                if(grid[row][col] >= pricing[0] && grid[row][col] <= pricing[1]) {\\n                    struct node n1;\\n                    n1.dist = dis;\\n                    n1.price = grid[row][col];\\n                    n1.row = row;\\n                    n1.col = col;\\n                    store.push_back(n1);\\n                }\\n                if(store.size() == k) ind = dis;\\n            }\\n            for(int i=0;i<4;i++) {\\n                if(row+distr[i] < n && row+distr[i] >= 0) {\\n                    if(col+distc[i] < m && col+distc[i] >= 0) {\\n                        if(grid[row+distr[i]][col+distc[i]] >= 1 && vis[row+distr[i]][col+distc[i]] == 0) {\\n                            q.push({{row+distr[i], col+distc[i]}, dis+1});\\n                            vis[row+distr[i]][col+distc[i]] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        sort(store.begin(), store.end(), compare);\\n        vector<vector<int>> ret;\\n        int x = store.size();\\n        for(int i=0;i<min(x,k);i++) {\\n            vector<int> dec(2);\\n            dec[0] = store[i].row;\\n            dec[1] = store[i].col;\\n            ret.push_back(dec);\\n        }\\n        return ret;\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int distr[4] = {0,1,-1,0};\\n    int distc[4] = {1,0,0,-1};\\n    \\n    struct node {\\n        int dist;\\n        int price;\\n        int row;\\n        int col;\\n    };\\n    \\n    static bool compare(const node a, const node b) {\\n        if(a.dist < b.dist) return true;\\n        else if(a.dist == b.dist) {\\n            if(a.price < b.price) return true;\\n            else if(a.price == b.price) {\\n                if(a.row < b.row) return true;\\n                else if(a.row == b.row) {\\n                    if(a.col < b.col) return true;\\n                    else return false;\\n                }\\n                return false;\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<node> store;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>> q;\\n        q.push({{start[0], start[1]}, 1});\\n        vis[start[0]][start[1]] = 1;\\n        int ind = INT_MAX;\\n        while(!q.empty()) {\\n            int row = q.front().first.first;\\n            int col = q.front().first.second;\\n            int dis = q.front().second;\\n            q.pop();\\n            if(grid[row][col] > 1) {\\n                if(dis > ind) break;\\n                if(grid[row][col] >= pricing[0] && grid[row][col] <= pricing[1]) {\\n                    struct node n1;\\n                    n1.dist = dis;\\n                    n1.price = grid[row][col];\\n                    n1.row = row;\\n                    n1.col = col;\\n                    store.push_back(n1);\\n                }\\n                if(store.size() == k) ind = dis;\\n            }\\n            for(int i=0;i<4;i++) {\\n                if(row+distr[i] < n && row+distr[i] >= 0) {\\n                    if(col+distc[i] < m && col+distc[i] >= 0) {\\n                        if(grid[row+distr[i]][col+distc[i]] >= 1 && vis[row+distr[i]][col+distc[i]] == 0) {\\n                            q.push({{row+distr[i], col+distc[i]}, dis+1});\\n                            vis[row+distr[i]][col+distc[i]] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        sort(store.begin(), store.end(), compare);\\n        vector<vector<int>> ret;\\n        int x = store.size();\\n        for(int i=0;i<min(x,k);i++) {\\n            vector<int> dec(2);\\n            dec[0] = store[i].row;\\n            dec[1] = store[i].col;\\n            ret.push_back(dec);\\n        }\\n        return ret;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709959,
                "title": "java-easy-bfs",
                "content": "```\\nclass Solution {\\n    public class Node implements Comparable<Node>{\\n        int r,c,dist,val;\\n        Node(int r,int c,int val,int dist){\\n            this.r=r;\\n            this.c=c;\\n            this.val=val;\\n            this.dist=dist;\\n        }\\n        public int compareTo(Node o){\\n            if(o.dist!=this.dist){\\n                return this.dist-o.dist;\\n            }\\n            if(o.val!=this.val){\\n                return this.val-o.val;\\n            }\\n            if(this.r!=o.r)return this.r-o.r;\\n            if(o.c!=this.c){\\n            }\\n                return this.c-o.c;\\n        }\\n    }\\n    private int[][] dirs={{0,1},{0,-1},{1,0},{-1,0}};\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        boolean visited[][]=new boolean[n][m];\\n        List<Node> ans=new ArrayList<>();\\n        \\n        Queue<Node> queue=new ArrayDeque<>();\\n        queue.add(new Node(start[0],start[1],grid[start[0]][start[1]],0));\\n        visited[start[0]][start[1]]=true;\\n        \\n        while(queue.size()!=0){\\n            int l=queue.size();\\n            while(l-->0){\\n                Node rem=queue.remove();\\n                ans.add(rem);\\n                int r=rem.r;\\n                int c=rem.c;\\n                int dist=rem.dist;\\n                for(int dir[]:dirs){\\n                    int nr=dir[0]+r;\\n                    int nc=dir[1]+c;\\n                    if(nr<0||nc<0||nr>=n||nc>=m||grid[nr][nc]==0||visited[nr][nc])continue;\\n                    visited[nr][nc]=true;\\n                    queue.add(new Node(nr,nc,grid[nr][nc],dist+1));\\n                }\\n                \\n            }\\n        }\\n        List<List<Integer>> ret=new ArrayList<>();\\n        Collections.sort(ans);\\n        for(int i=0;i<ans.size()&&k>0;i++){\\n            if(ans.get(i).val>=pricing[0]&&ans.get(i).val<=pricing[1]){\\n                k--;\\n                ret.add(Arrays.asList(ans.get(i).r,ans.get(i).c));\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public class Node implements Comparable<Node>{\\n        int r,c,dist,val;\\n        Node(int r,int c,int val,int dist){\\n            this.r=r;\\n            this.c=c;\\n            this.val=val;\\n            this.dist=dist;\\n        }\\n        public int compareTo(Node o){\\n            if(o.dist!=this.dist){\\n                return this.dist-o.dist;\\n            }\\n            if(o.val!=this.val){\\n                return this.val-o.val;\\n            }\\n            if(this.r!=o.r)return this.r-o.r;\\n            if(o.c!=this.c){\\n            }\\n                return this.c-o.c;\\n        }\\n    }\\n    private int[][] dirs={{0,1},{0,-1},{1,0},{-1,0}};\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        boolean visited[][]=new boolean[n][m];\\n        List<Node> ans=new ArrayList<>();\\n        \\n        Queue<Node> queue=new ArrayDeque<>();\\n        queue.add(new Node(start[0],start[1],grid[start[0]][start[1]],0));\\n        visited[start[0]][start[1]]=true;\\n        \\n        while(queue.size()!=0){\\n            int l=queue.size();\\n            while(l-->0){\\n                Node rem=queue.remove();\\n                ans.add(rem);\\n                int r=rem.r;\\n                int c=rem.c;\\n                int dist=rem.dist;\\n                for(int dir[]:dirs){\\n                    int nr=dir[0]+r;\\n                    int nc=dir[1]+c;\\n                    if(nr<0||nc<0||nr>=n||nc>=m||grid[nr][nc]==0||visited[nr][nc])continue;\\n                    visited[nr][nc]=true;\\n                    queue.add(new Node(nr,nc,grid[nr][nc],dist+1));\\n                }\\n                \\n            }\\n        }\\n        List<List<Integer>> ret=new ArrayList<>();\\n        Collections.sort(ans);\\n        for(int i=0;i<ans.size()&&k>0;i++){\\n            if(ans.get(i).val>=pricing[0]&&ans.get(i).val<=pricing[1]){\\n                k--;\\n                ret.add(Arrays.asList(ans.get(i).r,ans.get(i).c));\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709951,
                "title": "bfs-solution-o-n-m",
                "content": "```\\n vector<vector<int>> g;\\n bool cmp(pair<int,int> a, pair<int,int> b){\\n        if(g[a.first][a.second]==g[b.first][b.second]){\\n            if(a.first==b.first){\\n                return a.second<b.second;\\n            }\\n            else \\n            return a.first<b.first;\\n        }\\n        return g[a.first][a.second]<g[b.first][b.second];\\n    }\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int K) {\\n        vector<vector<int>> dist(grid.size(),vector<int> (grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0) dist[i][j]=INT_MAX;\\n                else dist[i][j]=0;\\n            }\\n        }\\n        g=grid;\\n        vector<pair<int,int>> vec[200000];\\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        int k=0;\\n        vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        vis[start[0]][start[1]]=1;\\n        while(not q.empty()){\\n            int s=q.size();\\n            while(s--){\\n                pair<int,int> p=q.front();\\n                vec[k].push_back({p.first,p.second});\\n                q.pop();\\n                if(p.first+1>=0 and p.first+1<grid.size()){\\n                    if(grid[p.first+1][p.second]!=0){\\n                        int fi=p.first+1,si=p.second;\\n                        if(vis[fi][si]==0){\\n                        q.push({p.first+1,p.second});\\n                            vis[fi][si]=1;\\n                        }\\n                    }\\n                }\\n                if(p.first-1>=0 and p.first-1<grid.size()){\\n                    if(grid[p.first-1][p.second]!=0){\\n                        int fi=p.first-1,si=p.second;\\n                        if(vis[fi][si]==0){\\n                        q.push({p.first-1,p.second});\\n                            vis[fi][si]=1;\\n                        }\\n                    }\\n                }\\n                if(p.second+1>=0 and p.second+1<grid[0].size()){\\n                    if(grid[p.first][p.second+1]!=0){\\n                        int fi=p.first,si=p.second+1;\\n                        if(vis[fi][si]==0){\\n                        q.push({p.first,p.second+1});\\n                            vis[fi][si]=1;\\n                        }\\n                    }\\n                }\\n                if(p.second-1>=0 and p.second-1<grid[0].size()){\\n                   if(grid[p.first][p.second-1]!=0){\\n                       int fi=p.first,si=p.second-1;\\n                        if(vis[fi][si]==0){\\n                        q.push({p.first,p.second-1});\\n                            vis[fi][si]=1;\\n                        }\\n                    }\\n                }\\n            }\\n            k++;\\n        }\\n        vector<vector<int>> ans;\\n        for(int i=0;i<200000;i++){\\n            sort(vec[i].begin(),vec[i].end(),cmp);\\n            for(int j=0;j<vec[i].size();j++){\\n                if(grid[vec[i][j].first][vec[i][j].second]!=1 and grid[vec[i][j].first][vec[i][j].second]>=pricing[0] and grid[vec[i][j].first][vec[i][j].second]<=pricing[1] and K>0){\\n                    ans.push_back({vec[i][j].first,vec[i][j].second});\\n                    K--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n vector<vector<int>> g;\\n bool cmp(pair<int,int> a, pair<int,int> b){\\n        if(g[a.first][a.second]==g[b.first][b.second]){\\n            if(a.first==b.first){\\n                return a.second<b.second;\\n            }\\n            else \\n            return a.first<b.first;\\n        }\\n        return g[a.first][a.second]<g[b.first][b.second];\\n    }\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int K) {\\n        vector<vector<int>> dist(grid.size(),vector<int> (grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0) dist[i][j]=INT_MAX;\\n                else dist[i][j]=0;\\n            }\\n        }\\n        g=grid;\\n        vector<pair<int,int>> vec[200000];\\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        int k=0;\\n        vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        vis[start[0]][start[1]]=1;\\n        while(not q.empty()){\\n            int s=q.size();\\n            while(s--){\\n                pair<int,int> p=q.front();\\n                vec[k].push_back({p.first,p.second});\\n                q.pop();\\n                if(p.first+1>=0 and p.first+1<grid.size()){\\n                    if(grid[p.first+1][p.second]!=0){\\n                        int fi=p.first+1,si=p.second;\\n                        if(vis[fi][si]==0){\\n                        q.push({p.first+1,p.second});\\n                            vis[fi][si]=1;\\n                        }\\n                    }\\n                }\\n                if(p.first-1>=0 and p.first-1<grid.size()){\\n                    if(grid[p.first-1][p.second]!=0){\\n                        int fi=p.first-1,si=p.second;\\n                        if(vis[fi][si]==0){\\n                        q.push({p.first-1,p.second});\\n                            vis[fi][si]=1;\\n                        }\\n                    }\\n                }\\n                if(p.second+1>=0 and p.second+1<grid[0].size()){\\n                    if(grid[p.first][p.second+1]!=0){\\n                        int fi=p.first,si=p.second+1;\\n                        if(vis[fi][si]==0){\\n                        q.push({p.first,p.second+1});\\n                            vis[fi][si]=1;\\n                        }\\n                    }\\n                }\\n                if(p.second-1>=0 and p.second-1<grid[0].size()){\\n                   if(grid[p.first][p.second-1]!=0){\\n                       int fi=p.first,si=p.second-1;\\n                        if(vis[fi][si]==0){\\n                        q.push({p.first,p.second-1});\\n                            vis[fi][si]=1;\\n                        }\\n                    }\\n                }\\n            }\\n            k++;\\n        }\\n        vector<vector<int>> ans;\\n        for(int i=0;i<200000;i++){\\n            sort(vec[i].begin(),vec[i].end(),cmp);\\n            for(int j=0;j<vec[i].size();j++){\\n                if(grid[vec[i][j].first][vec[i][j].second]!=1 and grid[vec[i][j].first][vec[i][j].second]>=pricing[0] and grid[vec[i][j].first][vec[i][j].second]<=pricing[1] and K>0){\\n                    ans.push_back({vec[i][j].first,vec[i][j].second});\\n                    K--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709880,
                "title": "simple-bfs-and-sorting",
                "content": "```\\n\\n\\nbool compKK(vector<int> &v1, vector<int> &v2){\\n        return v1 <= v2;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int n, int m, int i, int j){\\n        return i >= 0 && i<n && j>= 0 && j<m;\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        queue<pair<int,int>> q;\\n        q.push({start[0], start[1]});\\n        \\n        \\n        vector<vector<int>> pq;\\n        \\n        vector<pair<int,int>> directions = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n\\t\\t\\n        if(grid[start[0]][start[1]] != 0 && grid[start[0]][start[1]] != 1\\n           && grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1] \\n          ) pq.push_back({0, grid[start[0]][start[1]], start[0],start[1] });\\n\\t\\t  \\n        visited[start[0]][start[1]] = true;\\n        int dis = 1;\\n\\t\\t\\n        while(!q.empty()){\\n            int qn = q.size();\\n            while(qn--){\\n                pair<int,int> p = q.front(); q.pop();\\n                for(auto &[x,y]: directions){\\n                    int i= p.first+x;\\n                    int j = p.second+y;\\n                    if(isValid(n, m, i, j) && !visited[i][j] && grid[i][j] != 0){\\n                        visited[i][j] = true;\\n                        if(grid[i][j] != 1 && grid[i][j] >= pricing[0] && grid[i][j] <= pricing[1]) pq.push_back({dis, grid[i][j], i, j});\\n                        q.push({i, j});\\n                    }\\n                }\\n            }\\n            dis++;\\n        }\\n        \\n        sort(pq.begin(), pq.end(),compKK);\\n\\t\\t\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<k && i < pq.size(); i++){\\n            ans.push_back({pq[i][2], pq[i][3]});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nbool compKK(vector<int> &v1, vector<int> &v2){\\n        return v1 <= v2;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int n, int m, int i, int j){\\n        return i >= 0 && i<n && j>= 0 && j<m;\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        queue<pair<int,int>> q;\\n        q.push({start[0], start[1]});\\n        \\n        \\n        vector<vector<int>> pq;\\n        \\n        vector<pair<int,int>> directions = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n\\t\\t\\n        if(grid[start[0]][start[1]] != 0 && grid[start[0]][start[1]] != 1\\n           && grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1] \\n          ) pq.push_back({0, grid[start[0]][start[1]], start[0],start[1] });\\n\\t\\t  \\n        visited[start[0]][start[1]] = true;\\n        int dis = 1;\\n\\t\\t\\n        while(!q.empty()){\\n            int qn = q.size();\\n            while(qn--){\\n                pair<int,int> p = q.front(); q.pop();\\n                for(auto &[x,y]: directions){\\n                    int i= p.first+x;\\n                    int j = p.second+y;\\n                    if(isValid(n, m, i, j) && !visited[i][j] && grid[i][j] != 0){\\n                        visited[i][j] = true;\\n                        if(grid[i][j] != 1 && grid[i][j] >= pricing[0] && grid[i][j] <= pricing[1]) pq.push_back({dis, grid[i][j], i, j});\\n                        q.push({i, j});\\n                    }\\n                }\\n            }\\n            dis++;\\n        }\\n        \\n        sort(pq.begin(), pq.end(),compKK);\\n\\t\\t\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<k && i < pq.size(); i++){\\n            ans.push_back({pq[i][2], pq[i][3]});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709847,
                "title": "c-bfs-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& p, vector<int>& start, int k) {\\n        vector<vector<int>> ans;\\n        queue<vector<int>> q;\\n        int c = 0;\\n        q.push({grid[start[0]][start[1]], start[0], start[1]});\\n        int len = grid.size();\\n        vector<vector<bool>> vis(len, vector<bool>(grid[0].size(), false));\\n        \\n        vis[start[0]][start[1]] = true;\\n        \\n        vector<vector<int>> pp = {{0,-1}, {-1, 0}, {0, 1}, {1, 0}};\\n        \\n        while(!q.empty() && c<k){\\n            int n = q.size();\\n            vector<vector<int>> v;\\n            while(n--){\\n                vector<int> vv = q.front();\\n                q.pop();\\n                v.push_back(vv);\\n            }\\n            sort(v.begin(),v.end());\\n            for(auto x:v){\\n                if(c==k) break;\\n                if(x[0]!=0 && x[0]!=1 && p[0]<=x[0] && p[1]>=x[0]){\\n                    ans.push_back({x[1], x[2]});\\n                    c++;\\n                }\\n                if(x[0]!=0){\\n                    int i = x[1], j = x[2];\\n                    for(auto y:pp){\\n                        i+=y[0];j+=y[1];\\n                        if(i>=0 && j>=0 && i<grid.size() && j<grid[i].size() && grid[i][j]!=0 && !vis[i][j]){\\n                            q.push({grid[i][j], i, j});\\n                            vis[i][j] = true;\\n                        }\\n                        i-=y[0];j-=y[1];\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& p, vector<int>& start, int k) {\\n        vector<vector<int>> ans;\\n        queue<vector<int>> q;\\n        int c = 0;\\n        q.push({grid[start[0]][start[1]], start[0], start[1]});\\n        int len = grid.size();\\n        vector<vector<bool>> vis(len, vector<bool>(grid[0].size(), false));\\n        \\n        vis[start[0]][start[1]] = true;\\n        \\n        vector<vector<int>> pp = {{0,-1}, {-1, 0}, {0, 1}, {1, 0}};\\n        \\n        while(!q.empty() && c<k){\\n            int n = q.size();\\n            vector<vector<int>> v;\\n            while(n--){\\n                vector<int> vv = q.front();\\n                q.pop();\\n                v.push_back(vv);\\n            }\\n            sort(v.begin(),v.end());\\n            for(auto x:v){\\n                if(c==k) break;\\n                if(x[0]!=0 && x[0]!=1 && p[0]<=x[0] && p[1]>=x[0]){\\n                    ans.push_back({x[1], x[2]});\\n                    c++;\\n                }\\n                if(x[0]!=0){\\n                    int i = x[1], j = x[2];\\n                    for(auto y:pp){\\n                        i+=y[0];j+=y[1];\\n                        if(i>=0 && j>=0 && i<grid.size() && j<grid[i].size() && grid[i][j]!=0 && !vis[i][j]){\\n                            q.push({grid[i][j], i, j});\\n                            vis[i][j] = true;\\n                        }\\n                        i-=y[0];j-=y[1];\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709828,
                "title": "c-all-cases-passed-still-tle",
                "content": "This approach passes all TC still Leetcode gives me TLE? Can someone please optimise this code?\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int R,int C,int x,int y){\\n        return x>=0&&x<R&&y>=0&&y<C;\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        \\n        priority_queue<vector<int>,vector<vector<int>>,less<vector<int>>>PQ;// {dist,price,x,y}\\n        \\n        int size = 0;\\n        \\n        int R= grid.size();\\n        int C=grid[0].size();\\n        deque<vector<int>>Q;\\n        \\n        Q.push_back(start);\\n        \\n        vector<vector<int>>moves={\\n            {1,0},\\n            {0,-1},\\n            {-1,0},\\n            {0,1}\\n        };\\n        \\n        \\n        auto front =Q.front();\\n        if(grid[front[0]][front[1]]!=1&& grid[front[0]][front[1]]>=pricing[0]&&grid[front[0]][front[1]]<=pricing[1])\\n            {\\n            \\n                PQ.push({0,grid[front[0]][front[1]],front[0],front[1]});\\n                size++;\\n                    \\n            }  \\n        \\n        int dis =0;\\n        while(!Q.empty()){\\n            \\n            deque<vector<int>>childQ;\\n            \\n            while(!Q.empty()){\\n                \\n                auto front=Q.front();\\n                \\n                 \\n                while(size>k){\\n                            PQ.pop();\\n                            size--;\\n                }\\n                grid[front[0]][front[1]]=0;\\n                \\n                \\n                Q.pop_front();\\n                \\n                for(auto every:moves){\\n                    int nextX = front[0]+every[0];\\n                    int nextY = front[1]+every[1];\\n                    \\n                    if(isValid(R,C,nextX,nextY)&&grid[nextX][nextY]!=0){\\n                        \\n                        if(grid[nextX][nextY]!=1&& grid[nextX][nextY]>=pricing[0]&&grid[nextX][nextY]<=pricing[1]){\\n                            \\n                            PQ.push({dis+1,grid[nextX][nextY],nextX,nextY});\\n                            size++;\\n                        }\\n                        while(size>k){\\n                            PQ.pop();\\n                            size--;\\n                        }\\n                        grid[nextX][nextY]=0;\\n                        childQ.push_back({nextX,nextY});\\n                    }\\n                    \\n                }\\n                \\n            }\\n            Q=childQ;\\n            dis++;\\n            \\n        }\\n        \\n        vector<vector<int>>ans;\\n        \\n        while(!PQ.empty()){\\n            auto top=PQ.top();\\n            PQ.pop();\\n            ans.push_back({top[2],top[3]});\\n        }\\n        \\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int R,int C,int x,int y){\\n        return x>=0&&x<R&&y>=0&&y<C;\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        \\n        priority_queue<vector<int>,vector<vector<int>>,less<vector<int>>>PQ;// {dist,price,x,y}\\n        \\n        int size = 0;\\n        \\n        int R= grid.size();\\n        int C=grid[0].size();\\n        deque<vector<int>>Q;\\n        \\n        Q.push_back(start);\\n        \\n        vector<vector<int>>moves={\\n            {1,0},\\n            {0,-1},\\n            {-1,0},\\n            {0,1}\\n        };\\n        \\n        \\n        auto front =Q.front();\\n        if(grid[front[0]][front[1]]!=1&& grid[front[0]][front[1]]>=pricing[0]&&grid[front[0]][front[1]]<=pricing[1])\\n            {\\n            \\n                PQ.push({0,grid[front[0]][front[1]],front[0],front[1]});\\n                size++;\\n                    \\n            }  \\n        \\n        int dis =0;\\n        while(!Q.empty()){\\n            \\n            deque<vector<int>>childQ;\\n            \\n            while(!Q.empty()){\\n                \\n                auto front=Q.front();\\n                \\n                 \\n                while(size>k){\\n                            PQ.pop();\\n                            size--;\\n                }\\n                grid[front[0]][front[1]]=0;\\n                \\n                \\n                Q.pop_front();\\n                \\n                for(auto every:moves){\\n                    int nextX = front[0]+every[0];\\n                    int nextY = front[1]+every[1];\\n                    \\n                    if(isValid(R,C,nextX,nextY)&&grid[nextX][nextY]!=0){\\n                        \\n                        if(grid[nextX][nextY]!=1&& grid[nextX][nextY]>=pricing[0]&&grid[nextX][nextY]<=pricing[1]){\\n                            \\n                            PQ.push({dis+1,grid[nextX][nextY],nextX,nextY});\\n                            size++;\\n                        }\\n                        while(size>k){\\n                            PQ.pop();\\n                            size--;\\n                        }\\n                        grid[nextX][nextY]=0;\\n                        childQ.push_back({nextX,nextY});\\n                    }\\n                    \\n                }\\n                \\n            }\\n            Q=childQ;\\n            dis++;\\n            \\n        }\\n        \\n        vector<vector<int>>ans;\\n        \\n        while(!PQ.empty()){\\n            auto top=PQ.top();\\n            PQ.pop();\\n            ans.push_back({top[2],top[3]});\\n        }\\n        \\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709746,
                "title": "whoa-question-or-a-mini-project-bfs-priorityqueue-eventually",
                "content": "Reading through the question, it seemed like a mini project. Anyway, here\\'s a BFS+PQbased impl\\n```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(grid[start[0]][start[1]] == 0) {\\n            return ans;\\n        }\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> {\\n            if(a[2] != b[2]) {\\n                return a[2] - b[2];\\n            } else if(a[3] != b[3]) {\\n                return a[3] - b[3];\\n            } else if(a[0] != b[0]) {\\n                return a[0] - b[0];\\n            } else {\\n                return a[1] - b[1];\\n            }\\n        });\\n        int[] item = new int[] { start[0], start[1], 0, grid[start[0]][start[1]]}; //row, col, dist, price\\n        q.add(item);\\n        if(item[3] >= pricing[0] && item[3] <= pricing[1]) {\\n            pq.add(item);    \\n        }\\n        \\n        grid[start[0]][start[1]] = 0;\\n        int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        while(!q.isEmpty()) {\\n            int[] curr = q.remove();\\n            int r = curr[0];\\n            int c = curr[1];\\n            int d = curr[2];\\n            for(int[] dir : dirs) {\\n                int nr = r + dir[0];\\n                int nc = c + dir[1];\\n                if(nr < grid.length && nr >= 0 && nc < grid[0].length && nc >= 0 && grid[nr][nc] > 0) {\\n                    item = new int[] {nr, nc, d + 1, grid[nr][nc]}; \\n                    q.add(item);\\n                    if(grid[nr][nc] >= pricing[0] && grid[nr][nc] <= pricing[1]) {\\n                        pq.add(item);    \\n                    }\\n                    grid[nr][nc] = 0;\\n                }\\n            }\\n        }\\n        while(!pq.isEmpty()) {\\n            item = pq.remove();\\n            List<Integer> list = new ArrayList<>();\\n            list.add(item[0]);\\n            list.add(item[1]);\\n            ans.add(list);\\n            if(ans.size() == k) {\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(grid[start[0]][start[1]] == 0) {\\n            return ans;\\n        }\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> {\\n            if(a[2] != b[2]) {\\n                return a[2] - b[2];\\n            } else if(a[3] != b[3]) {\\n                return a[3] - b[3];\\n            } else if(a[0] != b[0]) {\\n                return a[0] - b[0];\\n            } else {\\n                return a[1] - b[1];\\n            }\\n        });\\n        int[] item = new int[] { start[0], start[1], 0, grid[start[0]][start[1]]}; //row, col, dist, price\\n        q.add(item);\\n        if(item[3] >= pricing[0] && item[3] <= pricing[1]) {\\n            pq.add(item);    \\n        }\\n        \\n        grid[start[0]][start[1]] = 0;\\n        int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        while(!q.isEmpty()) {\\n            int[] curr = q.remove();\\n            int r = curr[0];\\n            int c = curr[1];\\n            int d = curr[2];\\n            for(int[] dir : dirs) {\\n                int nr = r + dir[0];\\n                int nc = c + dir[1];\\n                if(nr < grid.length && nr >= 0 && nc < grid[0].length && nc >= 0 && grid[nr][nc] > 0) {\\n                    item = new int[] {nr, nc, d + 1, grid[nr][nc]}; \\n                    q.add(item);\\n                    if(grid[nr][nc] >= pricing[0] && grid[nr][nc] <= pricing[1]) {\\n                        pq.add(item);    \\n                    }\\n                    grid[nr][nc] = 0;\\n                }\\n            }\\n        }\\n        while(!pq.isEmpty()) {\\n            item = pq.remove();\\n            List<Integer> list = new ArrayList<>();\\n            list.add(item[0]);\\n            list.add(item[1]);\\n            ans.add(list);\\n            if(ans.size() == k) {\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709702,
                "title": "python3-bfs",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/8fc8469e823a229654fc858172dfa9383d805e39) for solutions of biweekly 70. \\n\\n**Intuition**\\nStarting from `start` and collect those satisfying `pricing` requirement into a vector. Sort the vector and output the best `k` of them. \\n\\n```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        ans = []\\n        queue = deque([(0, *start)])\\n        grid[start[0]][start[1]] *= -1 \\n        while queue: \\n            x, i, j = queue.popleft()\\n            if pricing[0] <= -grid[i][j] <= pricing[1]: ans.append((x, -grid[i][j], i, j))\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] > 0: \\n                    queue.append((x+1, ii, jj))\\n                    grid[ii][jj] *= -1\\n        return [[i, j] for _, _, i, j in sorted(ans)[:k]]\\n```\\n\\n**AofA**\\ntime complexity `O(NlogN)`\\nspace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        ans = []\\n        queue = deque([(0, *start)])\\n        grid[start[0]][start[1]] *= -1 \\n        while queue: \\n            x, i, j = queue.popleft()\\n            if pricing[0] <= -grid[i][j] <= pricing[1]: ans.append((x, -grid[i][j], i, j))\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] > 0: \\n                    queue.append((x+1, ii, jj))\\n                    grid[ii][jj] *= -1\\n        return [[i, j] for _, _, i, j in sorted(ans)[:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709697,
                "title": "suggestions-please",
                "content": "```\\nclass Solution {\\npublic:\\n    priority_queue<pair<int,pair<int,pair<int,int>>>>pq;\\n\\n    void dfs(vector<vector<int>>& grid,vector<int>& pricing,vector<vector<bool>>&vis, int i, int j, int steps){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || vis[i][j] || grid[i][j]==0) return;\\n        vis[i][j]=1;\\n        if(grid[i][j]!=1 && grid[i][j]>=pricing[0] && grid[i][j]<=pricing[1]) \\n            pq.push({-1*steps,{-1*grid[i][j],{-1*i,-1*j}}});\\n        dfs(grid,pricing,vis,i+1,j,steps+1);\\n        dfs(grid,pricing,vis,i,j+1,steps+1);\\n        dfs(grid,pricing,vis,i-1,j,steps+1);\\n        dfs(grid,pricing,vis,i,j-1,steps+1);\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<bool>>vis(grid.size(),vector<bool>(grid[0].size(),0));\\n        dfs(grid,pricing,vis,start[0],start[1],0);    \\n        vector<vector<int>>ans;\\n        while(!pq.empty() && k--){\\n            auto t=pq.top();\\n            pq.pop();\\n            int row=-1*t.second.second.first;\\n            int col=-1*t.second.second.first;\\n            ans.push_back({row,col});\\n        }\\n        return ans;\\n    }\\n};\\n```\\nCan anyone tell me whats wrong here? I have thought of everything but couldnt come up with the problem!! And please dont say to do bfs as my dfs concept is same as bfs since I have used visited array , so each node will be visited exactly once, hence there\\'s no difference at all. Ts not showing TLE, its giving wrong answer, so please just point out the mistake !",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    priority_queue<pair<int,pair<int,pair<int,int>>>>pq;\\n\\n    void dfs(vector<vector<int>>& grid,vector<int>& pricing,vector<vector<bool>>&vis, int i, int j, int steps){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || vis[i][j] || grid[i][j]==0) return;\\n        vis[i][j]=1;\\n        if(grid[i][j]!=1 && grid[i][j]>=pricing[0] && grid[i][j]<=pricing[1]) \\n            pq.push({-1*steps,{-1*grid[i][j],{-1*i,-1*j}}});\\n        dfs(grid,pricing,vis,i+1,j,steps+1);\\n        dfs(grid,pricing,vis,i,j+1,steps+1);\\n        dfs(grid,pricing,vis,i-1,j,steps+1);\\n        dfs(grid,pricing,vis,i,j-1,steps+1);\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<bool>>vis(grid.size(),vector<bool>(grid[0].size(),0));\\n        dfs(grid,pricing,vis,start[0],start[1],0);    \\n        vector<vector<int>>ans;\\n        while(!pq.empty() && k--){\\n            auto t=pq.top();\\n            pq.pop();\\n            int row=-1*t.second.second.first;\\n            int col=-1*t.second.second.first;\\n            ans.push_back({row,col});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709675,
                "title": "java-bfs-priorityqueue",
                "content": "Just do exactly what is told to do in the description. Not so much analytical problem in my opinion. For ranking heap/pq is used and for shortest distance textbook plain BFS is used.\\n\\n```\\nclass Solution {  \\n    class Node{\\n        int r;\\n        int c;\\n        int dist;\\n        int price;\\n\\n        public Node(int r, int c, int dist, int price){\\n            this.r = r;\\n            this.c = c;\\n            this.dist = dist;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int r = start[0];\\n        int c = start[1];\\n\\n        int lower = pricing[0];\\n        int upper = pricing[1];\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        boolean[][] vs = new boolean[m][n];\\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n        Queue<Node> q = new ArrayDeque<>();\\n        PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt((Node a) -> a.dist)\\n                .thenComparingInt(a -> a.price)\\n                .thenComparingInt(a -> a.r)\\n                .thenComparingInt(a -> a.c));\\n\\n        Node temp = new Node(r, c, 0, grid[r][c]);\\n        q.add(temp);\\n        vs[r][c] = true;\\n        \\n        if(grid[r][c] >=lower && grid[r][c] <= upper){\\n            pq.add(temp);\\n        }\\n\\n        int level = 1;\\n        while (!q.isEmpty()){\\n            int sz = q.size();\\n            \\n            for (int i=0; i<sz; i++){\\n                \\n                Node curr = q.poll();\\n                \\n                for(int[] dir : dirs){\\n                    \\n                    int ni = curr.r + dir[0];\\n                    int nj = curr.c + dir[1];\\n\\n                    if(ni >= 0 && ni < m && nj >=0 && nj < n && !vs[ni][nj] && grid[ni][nj]!=0){\\n                        \\n                        Node t = new Node(ni, nj, level, grid[ni][nj]);\\n                        vs[ni][nj] = true;\\n                        q.add(t);\\n                        \\n                        if(grid[ni][nj] >= lower && grid[ni][nj] <= upper){\\n                            pq.add(t);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            level++;\\n\\n        }\\n\\n        for(int i=0; i<k && !pq.isEmpty(); i++){\\n            Node curr = pq.poll();\\n            res.add(List.of(curr.r, curr.c));\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\n    class Node{\\n        int r;\\n        int c;\\n        int dist;\\n        int price;\\n\\n        public Node(int r, int c, int dist, int price){\\n            this.r = r;\\n            this.c = c;\\n            this.dist = dist;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int r = start[0];\\n        int c = start[1];\\n\\n        int lower = pricing[0];\\n        int upper = pricing[1];\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        boolean[][] vs = new boolean[m][n];\\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n        Queue<Node> q = new ArrayDeque<>();\\n        PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt((Node a) -> a.dist)\\n                .thenComparingInt(a -> a.price)\\n                .thenComparingInt(a -> a.r)\\n                .thenComparingInt(a -> a.c));\\n\\n        Node temp = new Node(r, c, 0, grid[r][c]);\\n        q.add(temp);\\n        vs[r][c] = true;\\n        \\n        if(grid[r][c] >=lower && grid[r][c] <= upper){\\n            pq.add(temp);\\n        }\\n\\n        int level = 1;\\n        while (!q.isEmpty()){\\n            int sz = q.size();\\n            \\n            for (int i=0; i<sz; i++){\\n                \\n                Node curr = q.poll();\\n                \\n                for(int[] dir : dirs){\\n                    \\n                    int ni = curr.r + dir[0];\\n                    int nj = curr.c + dir[1];\\n\\n                    if(ni >= 0 && ni < m && nj >=0 && nj < n && !vs[ni][nj] && grid[ni][nj]!=0){\\n                        \\n                        Node t = new Node(ni, nj, level, grid[ni][nj]);\\n                        vs[ni][nj] = true;\\n                        q.add(t);\\n                        \\n                        if(grid[ni][nj] >= lower && grid[ni][nj] <= upper){\\n                            pq.add(t);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            level++;\\n\\n        }\\n\\n        for(int i=0; i<k && !pq.isEmpty(); i++){\\n            Node curr = pq.poll();\\n            res.add(List.of(curr.r, curr.c));\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709661,
                "title": "python-simple-bfs-sort",
                "content": "```python\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        q = collections.deque()\\n        candidates = []\\n        h, w = len(grid), len(grid[0])\\n        low, high = pricing\\n        visited = set()\\n\\n        q.append((1, start[0], start[1]))\\n        visited.add((start[0], start[1]))\\n\\n        if low <= grid[start[0]][start[1]] <= high:\\n            candidates.append((1, start[0], start[1]))\\n\\n        while q:\\n            d, y, x = q.popleft()\\n        \\n            for dy, dx in ((y + 1, x), (y - 1, x), (y, x + 1), (y, x - 1)):\\n\\n                if not (0 <= dy < h and 0 <= dx < w):\\n                    continue\\n\\n                if (dy, dx) in visited:\\n                    continue\\n\\n                if grid[dy][dx] == 0:\\n                    continue\\n                    \\n                if low <= grid[dy][dx] <= high:\\n                    candidates.append((d + 1, dy, dx))\\n\\n                visited.add((dy, dx))\\n                q.append((d + 1, dy, dx))\\n\\n        candidates.sort(key=lambda k: (k[0], grid[k[1]][k[2]], k[1], k[2]))\\n        return [[candidates[i][1], candidates[i][2]] for i in range(min(k, len(candidates)))]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        q = collections.deque()\\n        candidates = []\\n        h, w = len(grid), len(grid[0])\\n        low, high = pricing\\n        visited = set()\\n\\n        q.append((1, start[0], start[1]))\\n        visited.add((start[0], start[1]))\\n\\n        if low <= grid[start[0]][start[1]] <= high:\\n            candidates.append((1, start[0], start[1]))\\n\\n        while q:\\n            d, y, x = q.popleft()\\n        \\n            for dy, dx in ((y + 1, x), (y - 1, x), (y, x + 1), (y, x - 1)):\\n\\n                if not (0 <= dy < h and 0 <= dx < w):\\n                    continue\\n\\n                if (dy, dx) in visited:\\n                    continue\\n\\n                if grid[dy][dx] == 0:\\n                    continue\\n                    \\n                if low <= grid[dy][dx] <= high:\\n                    candidates.append((d + 1, dy, dx))\\n\\n                visited.add((dy, dx))\\n                q.append((d + 1, dy, dx))\\n\\n        candidates.sort(key=lambda k: (k[0], grid[k[1]][k[2]], k[1], k[2]))\\n        return [[candidates[i][1], candidates[i][2]] for i in range(min(k, len(candidates)))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074110,
                "title": "simple-java-code-with-using-comparators",
                "content": "```\\nclass Solution {\\n    class Node implements Comparable<Node> {\\n        int i;\\n        int j;\\n        int dis;\\n        int price;\\n        public Node(int i , int j , int dis , int price){\\n            this.i = i;\\n            this.j = j;\\n            this.dis = dis;\\n            this.price = price;\\n        }\\n        public int compareTo(Node node){\\n            if(this.dis != node.dis){\\n                return this.dis - node.dis;\\n            }else if(this.price != node.price){\\n                return this.price - node.price;\\n            }else if(this.i != node.i){\\n                return this.i - node.i;\\n            }else if(this.j != node.j){\\n                return this.j - node.j;\\n            }else{\\n                return this.dis - node.dis;\\n            }\\n        }\\n    }\\n    int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n    public List<List<Integer>> highestRankedKItems(int[][] arr, int[] price, int[] start, int k) {\\n        List<Node> ans = new ArrayList<>();\\n        Queue<Node> queue = new LinkedList<>();\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        boolean[][] isVis = new boolean[rows][cols];\\n        queue.offer(new Node(start[0] , start[1] , 0 , arr[start[0]][start[1]]));\\n        isVis[start[0]][start[1]] = true;\\n        while(!queue.isEmpty()){\\n            Node curNode = queue.poll();\\n            int i = curNode.i;\\n            int j = curNode.j;\\n            if(arr[i][j] >= price[0] && arr[i][j] <= price[1]){\\n                ans.add(curNode);\\n            }\\n            for(int ptr = 0 ; ptr < 4 ; ptr++){\\n                int I = dir[ptr][0] + i;\\n                int J = dir[ptr][1] + j;\\n                if(I < rows && I >= 0 && J < cols && J >= 0 && !isVis[I][J] && arr[I][J] != 0){\\n                    isVis[I][J] = true;\\n                    queue.offer(new Node(I , J , curNode.dis + 1 , arr[I][J]));\\n                }\\n            }\\n        }\\n        Collections.sort(ans);\\n        List<List<Integer>> ans2 = new ArrayList<>();\\n        int K = 0;\\n        for(Node node : ans){\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(node.i);\\n            temp.add(node.j);\\n            ans2.add(temp);\\n            K++;\\n            if(K >= k) break;\\n        }\\n        return ans2;\\n    }\\n}\\n```\\n**Please UpVote, if found useful :)**",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    class Node implements Comparable<Node> {\\n        int i;\\n        int j;\\n        int dis;\\n        int price;\\n        public Node(int i , int j , int dis , int price){\\n            this.i = i;\\n            this.j = j;\\n            this.dis = dis;\\n            this.price = price;\\n        }\\n        public int compareTo(Node node){\\n            if(this.dis != node.dis){\\n                return this.dis - node.dis;\\n            }else if(this.price != node.price){\\n                return this.price - node.price;\\n            }else if(this.i != node.i){\\n                return this.i - node.i;\\n            }else if(this.j != node.j){\\n                return this.j - node.j;\\n            }else{\\n                return this.dis - node.dis;\\n            }\\n        }\\n    }\\n    int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n    public List<List<Integer>> highestRankedKItems(int[][] arr, int[] price, int[] start, int k) {\\n        List<Node> ans = new ArrayList<>();\\n        Queue<Node> queue = new LinkedList<>();\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        boolean[][] isVis = new boolean[rows][cols];\\n        queue.offer(new Node(start[0] , start[1] , 0 , arr[start[0]][start[1]]));\\n        isVis[start[0]][start[1]] = true;\\n        while(!queue.isEmpty()){\\n            Node curNode = queue.poll();\\n            int i = curNode.i;\\n            int j = curNode.j;\\n            if(arr[i][j] >= price[0] && arr[i][j] <= price[1]){\\n                ans.add(curNode);\\n            }\\n            for(int ptr = 0 ; ptr < 4 ; ptr++){\\n                int I = dir[ptr][0] + i;\\n                int J = dir[ptr][1] + j;\\n                if(I < rows && I >= 0 && J < cols && J >= 0 && !isVis[I][J] && arr[I][J] != 0){\\n                    isVis[I][J] = true;\\n                    queue.offer(new Node(I , J , curNode.dis + 1 , arr[I][J]));\\n                }\\n            }\\n        }\\n        Collections.sort(ans);\\n        List<List<Integer>> ans2 = new ArrayList<>();\\n        int K = 0;\\n        for(Node node : ans){\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(node.i);\\n            temp.add(node.j);\\n            ans2.add(temp);\\n            K++;\\n            if(K >= k) break;\\n        }\\n        return ans2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978671,
                "title": "simple-typescript-solution-using-bfs-o-n-space-and-time-apparently-beats-100",
                "content": "# Intuition\\nKeep traversing the graph using BFS, until we got k items. After that, keep going until the distance is too far.\\n\\nWe want to stop as early as possible. Once we got k items, we can limit our distance to where we\\'re at, because we know that any further items will be outranked. That way we avoid traversing the entire grid.\\n\\n# Approach\\n- Setup a queue in which we\\'ll push position AND distance.\\n- For each item in the queue\\n    - If it\\'s already visited, skip\\n    - Check if the price. If there\\'s no price, just skip (note that out of bound means price is undefined, so same check for no price).\\n    - If the price is within range, add it to our basket.\\n    - Add surroundings in the queue (position + distance increased by 1)\\n    - Check if we got enough items in the basket. If so, mark our distance and keep looking for items within the same distance.\\n- Once done, sort by all criterias (distance, price, row, col) and take the first k.\\n\\n# Complexity\\n- Time complexity:\\nO(n) (n is number of cells)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nconst DIR = [\\n        [-1,0],\\n    [0,-1], [0,1],\\n        [1,0],\\n];\\n\\nfunction highestRankedKItems(grid: number[][], pricing: number[], start: number[], k: number) {\\n    const queue: number[][] = [];\\n    queue.push([...start, 0]);\\n    const items = [];\\n    let maxDistance = 0;\\n    const visited = new Set<string>();\\n    while(queue.length) {\\n        const pos = queue.shift();\\n        const [r, c, distance] = pos;\\n        if (visited.has(`${r}_${c}`)) {\\n            continue;\\n        }\\n        visited.add(`${r}_${c}`);\\n        const price = grid[r]?.[c];\\n        if (price) {\\n            if (pricing[0] <= price && price <= pricing[1]) {\\n                items.push({\\n                    pos,\\n                    distance,\\n                    price,\\n                });\\n            }\\n            for (let [y, x] of DIR) {\\n                queue.push([r + y, c + x, distance + 1]);\\n            }\\n            if (items.length >= k) {\\n                if (!maxDistance) {\\n                    maxDistance = distance;\\n                }\\n                if (distance > maxDistance) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return items.sort((a, b) => {\\n        if (a.distance !== b.distance) {\\n            return a.distance - b.distance;\\n        }\\n        if (a.price !== b.price) {\\n            return a.price - b.price;\\n        }\\n        if (a.pos[0] !== b.pos[0]) {\\n            return a.pos[0] - b.pos[0];\\n        }\\n        return a.pos[1] - b.pos[1];\\n    }).map(({pos}) => pos.slice(0,2)).slice(0, k);\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst DIR = [\\n        [-1,0],\\n    [0,-1], [0,1],\\n        [1,0],\\n];\\n\\nfunction highestRankedKItems(grid: number[][], pricing: number[], start: number[], k: number) {\\n    const queue: number[][] = [];\\n    queue.push([...start, 0]);\\n    const items = [];\\n    let maxDistance = 0;\\n    const visited = new Set<string>();\\n    while(queue.length) {\\n        const pos = queue.shift();\\n        const [r, c, distance] = pos;\\n        if (visited.has(`${r}_${c}`)) {\\n            continue;\\n        }\\n        visited.add(`${r}_${c}`);\\n        const price = grid[r]?.[c];\\n        if (price) {\\n            if (pricing[0] <= price && price <= pricing[1]) {\\n                items.push({\\n                    pos,\\n                    distance,\\n                    price,\\n                });\\n            }\\n            for (let [y, x] of DIR) {\\n                queue.push([r + y, c + x, distance + 1]);\\n            }\\n            if (items.length >= k) {\\n                if (!maxDistance) {\\n                    maxDistance = distance;\\n                }\\n                if (distance > maxDistance) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return items.sort((a, b) => {\\n        if (a.distance !== b.distance) {\\n            return a.distance - b.distance;\\n        }\\n        if (a.price !== b.price) {\\n            return a.price - b.price;\\n        }\\n        if (a.pos[0] !== b.pos[0]) {\\n            return a.pos[0] - b.pos[0];\\n        }\\n        return a.pos[1] - b.pos[1];\\n    }).map(({pos}) => pos.slice(0,2)).slice(0, k);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941175,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n    final int m = grid.length;\\n    final int n = grid[0].length;\\n    final int low = pricing[0];\\n    final int high = pricing[1];\\n    final int row = start[0];\\n    final int col = start[1];\\n    final int[] dirs = {0, 1, 0, -1, 0};\\n    List<List<Integer>> ans = new ArrayList<>();\\n\\n    if (low <= grid[row][col] && grid[row][col] <= high) {\\n      ans.add(Arrays.asList(row, col));\\n      if (k == 1)\\n        return ans;\\n    }\\n\\n    Queue<Pair<Integer, Integer>> q = new ArrayDeque<>(Arrays.asList(new Pair<>(row, col)));\\n    boolean[][] seen = new boolean[m][n];\\n    seen[row][col] = true; // Mark as visited\\n\\n    while (!q.isEmpty()) {\\n      List<List<Integer>> neighbors = new ArrayList<>();\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        final int i = q.peek().getKey();\\n        final int j = q.poll().getValue();\\n        for (int t = 0; t < 4; ++t) {\\n          final int x = i + dirs[t];\\n          final int y = j + dirs[t + 1];\\n          if (x < 0 || x == m || y < 0 || y == n)\\n            continue;\\n          if (grid[x][y] == 0 || seen[x][y])\\n            continue;\\n          if (low <= grid[x][y] && grid[x][y] <= high)\\n            neighbors.add(Arrays.asList(x, y));\\n          q.offer(new Pair<>(x, y));\\n          seen[x][y] = true;\\n        }\\n      }\\n      Collections.sort(neighbors, new Comparator<List<Integer>>() {\\n        @Override\\n        public int compare(List<Integer> a, List<Integer> b) {\\n          final int x1 = a.get(0);\\n          final int y1 = a.get(1);\\n          final int x2 = b.get(0);\\n          final int y2 = b.get(1);\\n          if (grid[x1][y1] != grid[x2][y2])\\n            return grid[x1][y1] - grid[x2][y2];\\n          return x1 == x2 ? y1 - y2 : x1 - x2;\\n        }\\n      });\\n      for (List<Integer> neighbor : neighbors) {\\n        if (ans.size() < k)\\n          ans.add(neighbor);\\n        if (ans.size() == k)\\n          return ans;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n    final int m = grid.length;\\n    final int n = grid[0].length;\\n    final int low = pricing[0];\\n    final int high = pricing[1];\\n    final int row = start[0];\\n    final int col = start[1];\\n    final int[] dirs = {0, 1, 0, -1, 0};\\n    List<List<Integer>> ans = new ArrayList<>();\\n\\n    if (low <= grid[row][col] && grid[row][col] <= high) {\\n      ans.add(Arrays.asList(row, col));\\n      if (k == 1)\\n        return ans;\\n    }\\n\\n    Queue<Pair<Integer, Integer>> q = new ArrayDeque<>(Arrays.asList(new Pair<>(row, col)));\\n    boolean[][] seen = new boolean[m][n];\\n    seen[row][col] = true; // Mark as visited\\n\\n    while (!q.isEmpty()) {\\n      List<List<Integer>> neighbors = new ArrayList<>();\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        final int i = q.peek().getKey();\\n        final int j = q.poll().getValue();\\n        for (int t = 0; t < 4; ++t) {\\n          final int x = i + dirs[t];\\n          final int y = j + dirs[t + 1];\\n          if (x < 0 || x == m || y < 0 || y == n)\\n            continue;\\n          if (grid[x][y] == 0 || seen[x][y])\\n            continue;\\n          if (low <= grid[x][y] && grid[x][y] <= high)\\n            neighbors.add(Arrays.asList(x, y));\\n          q.offer(new Pair<>(x, y));\\n          seen[x][y] = true;\\n        }\\n      }\\n      Collections.sort(neighbors, new Comparator<List<Integer>>() {\\n        @Override\\n        public int compare(List<Integer> a, List<Integer> b) {\\n          final int x1 = a.get(0);\\n          final int y1 = a.get(1);\\n          final int x2 = b.get(0);\\n          final int y2 = b.get(1);\\n          if (grid[x1][y1] != grid[x2][y2])\\n            return grid[x1][y1] - grid[x2][y2];\\n          return x1 == x2 ? y1 - y2 : x1 - x2;\\n        }\\n      });\\n      for (List<Integer> neighbor : neighbors) {\\n        if (ans.size() < k)\\n          ans.add(neighbor);\\n        if (ans.size() == k)\\n          return ans;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910681,
                "title": "easy-to-understand-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- BFS to travel through all the nodes and reaching the valid node (Conditions provided in the question).\\n- Store the valid node into a vector or array and then sort in via sorting.\\n- Take the first \\'K\\' element as they are having highest rank.  \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comparator(vector<int> &a, vector<int> &b){\\n        if(a[0] == b[0]){\\n            if(a[1] == b[1]){\\n                if(a[2] == b[2]){\\n                    return a[3] < b[3];\\n                }\\n                return a[2] < b[2];\\n            }\\n            return a[1] < b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<int> row = {1, -1, 0, 0};\\n        vector<int> col = {0, 0, 1, -1};\\n        map<pair<int, int>, bool> vis;\\n        vector<vector<int>> ans;\\n        vector<vector<int>> temp;\\n        int x = start[0];\\n        int y = start[1];\\n        queue<pair<int, int>> q;\\n        if(grid[x][y] != 1 && grid[x][y] != 0 && grid[x][y] >= pricing[0] && grid[x][y] <= pricing[1])\\n            temp.push_back({0, grid[x][y], x, y});\\n        q.push({x, y});\\n        vis[{x, y}] = 1;\\n        int dist = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            dist++;\\n            // cout<<\"EXEC\"<<endl;\\n            while(size--){\\n                for(int i=0; i<row.size(); i++){\\n                    x = row[i] + q.front().first;\\n                    y = col[i] + q.front().second;\\n                    if(x >= 0 && y >= 0 && x < grid.size() && y < grid[0].size() && grid[x][y] != 0 && !vis[{x, y}]){\\n                        if(grid[x][y] != 1 && grid[x][y] >= pricing[0] && grid[x][y] <= pricing[1]){\\n                            temp.push_back({dist, grid[x][y], x, y});\\n                        }\\n                        vis[{x, y}] = 1;\\n                        q.push({x, y});\\n                    }\\n                }\\n                q.pop();\\n            }\\n        }\\n\\n        sort(temp.begin(), temp.end(), comparator);\\n\\n        for(auto x: temp){\\n            if(k == 0)\\n                break;\\n            k--;\\n            ans.push_back({x[2], x[3]});\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comparator(vector<int> &a, vector<int> &b){\\n        if(a[0] == b[0]){\\n            if(a[1] == b[1]){\\n                if(a[2] == b[2]){\\n                    return a[3] < b[3];\\n                }\\n                return a[2] < b[2];\\n            }\\n            return a[1] < b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<int> row = {1, -1, 0, 0};\\n        vector<int> col = {0, 0, 1, -1};\\n        map<pair<int, int>, bool> vis;\\n        vector<vector<int>> ans;\\n        vector<vector<int>> temp;\\n        int x = start[0];\\n        int y = start[1];\\n        queue<pair<int, int>> q;\\n        if(grid[x][y] != 1 && grid[x][y] != 0 && grid[x][y] >= pricing[0] && grid[x][y] <= pricing[1])\\n            temp.push_back({0, grid[x][y], x, y});\\n        q.push({x, y});\\n        vis[{x, y}] = 1;\\n        int dist = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            dist++;\\n            // cout<<\"EXEC\"<<endl;\\n            while(size--){\\n                for(int i=0; i<row.size(); i++){\\n                    x = row[i] + q.front().first;\\n                    y = col[i] + q.front().second;\\n                    if(x >= 0 && y >= 0 && x < grid.size() && y < grid[0].size() && grid[x][y] != 0 && !vis[{x, y}]){\\n                        if(grid[x][y] != 1 && grid[x][y] >= pricing[0] && grid[x][y] <= pricing[1]){\\n                            temp.push_back({dist, grid[x][y], x, y});\\n                        }\\n                        vis[{x, y}] = 1;\\n                        q.push({x, y});\\n                    }\\n                }\\n                q.pop();\\n            }\\n        }\\n\\n        sort(temp.begin(), temp.end(), comparator);\\n\\n        for(auto x: temp){\\n            if(k == 0)\\n                break;\\n            k--;\\n            ans.push_back({x[2], x[3]});\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3897006,
                "title": "most-understandable-java-solution-trading-off-time-performance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int[][] pathGrid = pathMatrix(grid, start, 0);\\n\\n        List<List<Integer>> prices = positionsWithinPriceRange(grid, pricing)\\n                .stream().filter(p -> pathGrid[p.get(0)][p.get(1)] != Integer.MAX_VALUE)\\n                .collect(Collectors.toList());\\n\\n        PriorityQueue<List<Integer>> pq =  new PriorityQueue<>( // Adding the comparator based on specified rank: path > price > row > col\\n                (x, y) -> {\\n                    // checking shorter path\\n                    int xPath = pathGrid[x.get(0)][x.get(1)];\\n                    int yPath = pathGrid[y.get(0)][y.get(1)];\\n                    if (xPath != yPath){\\n                        return xPath - yPath;\\n                    }\\n\\n                    // checking lower price\\n                    int xPrice = grid[x.get(0)][x.get(1)];\\n                    int yPrice = grid[y.get(0)][y.get(1)];\\n                    if(xPrice != yPrice){\\n                        return xPrice - yPrice;\\n                    }\\n\\n                    // Checking lower row - the row is at index 0\\n                    if(!Objects.equals(x.get(0), y.get(0))){\\n                        return x.get(0) - y.get(0);\\n                    }\\n\\n                    // finally comparing by column. The column is at index 1\\n                    return Integer.compare(x.get(1), y.get(1));\\n                }\\n        );\\n\\n        pq.addAll(prices);\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        while(!pq.isEmpty() && k-- != 0){\\n            result.add(pq.poll());\\n        }\\n\\n        return result;\\n    }\\n\\n    public static int[][] pathMatrix(int[][] matrix, int[] start,int WALL){\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n\\n        // Fill the distance array\\n        int[][] distances = new int[rows][cols];\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                distances[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n\\n        // Set the start position to a distance of zero\\n        distances[start[0]][start[1]] = 0;\\n\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(start);\\n\\n        // top, down, left right directions to go.\\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n        // BFS transversal\\n        while (!queue.isEmpty()) {\\n            int[] current = queue.poll();\\n            for (int[] dir : directions) {\\n                int newRow = current[0] + dir[0];\\n                int newCol = current[1] + dir[1];\\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && matrix[newRow][newCol] != WALL) {\\n                    int newDistance = distances[current[0]][current[1]] + 1;\\n                    if (newDistance < distances[newRow][newCol]) {\\n                        distances[newRow][newCol] = newDistance;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return distances;\\n    }\\n\\n    public static List<List<Integer>> positionsWithinPriceRange(int[][] matrix, int[] pricing){\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        List<List<Integer>> pricePositions = new ArrayList<>();\\n        for (int i = 0; i < rows; i++){\\n            for (int j = 0; j < cols; j++){\\n                if(matrix[i][j] >= pricing[0] && matrix[i][j] <= pricing[1]){\\n                    pricePositions.add(List.of(i, j));\\n                }\\n            }\\n        }\\n        return pricePositions;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int[][] pathGrid = pathMatrix(grid, start, 0);\\n\\n        List<List<Integer>> prices = positionsWithinPriceRange(grid, pricing)\\n                .stream().filter(p -> pathGrid[p.get(0)][p.get(1)] != Integer.MAX_VALUE)\\n                .collect(Collectors.toList());\\n\\n        PriorityQueue<List<Integer>> pq =  new PriorityQueue<>( // Adding the comparator based on specified rank: path > price > row > col\\n                (x, y) -> {\\n                    // checking shorter path\\n                    int xPath = pathGrid[x.get(0)][x.get(1)];\\n                    int yPath = pathGrid[y.get(0)][y.get(1)];\\n                    if (xPath != yPath){\\n                        return xPath - yPath;\\n                    }\\n\\n                    // checking lower price\\n                    int xPrice = grid[x.get(0)][x.get(1)];\\n                    int yPrice = grid[y.get(0)][y.get(1)];\\n                    if(xPrice != yPrice){\\n                        return xPrice - yPrice;\\n                    }\\n\\n                    // Checking lower row - the row is at index 0\\n                    if(!Objects.equals(x.get(0), y.get(0))){\\n                        return x.get(0) - y.get(0);\\n                    }\\n\\n                    // finally comparing by column. The column is at index 1\\n                    return Integer.compare(x.get(1), y.get(1));\\n                }\\n        );\\n\\n        pq.addAll(prices);\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        while(!pq.isEmpty() && k-- != 0){\\n            result.add(pq.poll());\\n        }\\n\\n        return result;\\n    }\\n\\n    public static int[][] pathMatrix(int[][] matrix, int[] start,int WALL){\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n\\n        // Fill the distance array\\n        int[][] distances = new int[rows][cols];\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                distances[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n\\n        // Set the start position to a distance of zero\\n        distances[start[0]][start[1]] = 0;\\n\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(start);\\n\\n        // top, down, left right directions to go.\\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n        // BFS transversal\\n        while (!queue.isEmpty()) {\\n            int[] current = queue.poll();\\n            for (int[] dir : directions) {\\n                int newRow = current[0] + dir[0];\\n                int newCol = current[1] + dir[1];\\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && matrix[newRow][newCol] != WALL) {\\n                    int newDistance = distances[current[0]][current[1]] + 1;\\n                    if (newDistance < distances[newRow][newCol]) {\\n                        distances[newRow][newCol] = newDistance;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return distances;\\n    }\\n\\n    public static List<List<Integer>> positionsWithinPriceRange(int[][] matrix, int[] pricing){\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        List<List<Integer>> pricePositions = new ArrayList<>();\\n        for (int i = 0; i < rows; i++){\\n            for (int j = 0; j < cols; j++){\\n                if(matrix[i][j] >= pricing[0] && matrix[i][j] <= pricing[1]){\\n                    pricePositions.add(List.of(i, j));\\n                }\\n            }\\n        }\\n        return pricePositions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840563,
                "title": "python-clean-and-simple-solution-using-bfs-and-priority-queue",
                "content": "```python\\nfrom collections import deque\\nfrom heapq import heappush, heappushpop\\n\\nMOVES = (\\n    (1, 0),\\n    (-1, 0),\\n    (0, 1),\\n    (0, -1),\\n)\\nWALL = 0\\n\\n\\nclass Solution:\\n    def highestRankedKItems(self, M: list[list[int]], P: list[int],\\n                            start: list[int], k: int) -> list[list[int]]:\\n        m, n = len(M), len(M[0])\\n\\n        q = deque()\\n        pq = []\\n\\n        def add_to_q(r: int, c: int, d: int):\\n            q.append((r, c))\\n\\n            if P[0] <= M[r][c] <= P[1]:\\n                key = (-d, -M[r][c], -r, -c)\\n\\n                if len(pq) < k:\\n                    heappush(pq, key)\\n                else:\\n                    heappushpop(pq, key)\\n\\n            M[r][c] = WALL\\n\\n        distance = 0\\n        add_to_q(start[0], start[1], distance)\\n\\n        while q:\\n            distance += 1\\n\\n            for _ in range(len(q)):\\n                i, j = q.popleft()\\n\\n                for dx, dy in MOVES:\\n                    if 0 <= (x := i + dx) < m and 0 <= (y := j + dy) < n and M[x][y] != WALL:\\n                        add_to_q(x, y, distance)\\n\\n        # we can also pop heap using heappop (instead of sorting pq directly as used below) which will\\n        # provide items in sorted order and then reverse the list of items popped and extract negative\\n        # of coordinates\\n        pq.sort(reverse=True)\\n        return [[-x, -y] for _, _, x, y in pq]\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nfrom collections import deque\\nfrom heapq import heappush, heappushpop\\n\\nMOVES = (\\n    (1, 0),\\n    (-1, 0),\\n    (0, 1),\\n    (0, -1),\\n)\\nWALL = 0\\n\\n\\nclass Solution:\\n    def highestRankedKItems(self, M: list[list[int]], P: list[int],\\n                            start: list[int], k: int) -> list[list[int]]:\\n        m, n = len(M), len(M[0])\\n\\n        q = deque()\\n        pq = []\\n\\n        def add_to_q(r: int, c: int, d: int):\\n            q.append((r, c))\\n\\n            if P[0] <= M[r][c] <= P[1]:\\n                key = (-d, -M[r][c], -r, -c)\\n\\n                if len(pq) < k:\\n                    heappush(pq, key)\\n                else:\\n                    heappushpop(pq, key)\\n\\n            M[r][c] = WALL\\n\\n        distance = 0\\n        add_to_q(start[0], start[1], distance)\\n\\n        while q:\\n            distance += 1\\n\\n            for _ in range(len(q)):\\n                i, j = q.popleft()\\n\\n                for dx, dy in MOVES:\\n                    if 0 <= (x := i + dx) < m and 0 <= (y := j + dy) < n and M[x][y] != WALL:\\n                        add_to_q(x, y, distance)\\n\\n        # we can also pop heap using heappop (instead of sorting pq directly as used below) which will\\n        # provide items in sorted order and then reverse the list of items popped and extract negative\\n        # of coordinates\\n        pq.sort(reverse=True)\\n        return [[-x, -y] for _, _, x, y in pq]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810067,
                "title": "beats-94-priorityqueue-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mnlog(mn))\\nThis is the upper cap which won\\'t be hit as maximum elements in heap would be number of elements at same distance from the starting point. So there will never be any point in time when all the elements will be in the heap.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(mn)\\nSame reason for space as well if we exclude the space for result.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int d[] = new int[]{-1,0,1,0,-1};\\n    public List<List<Integer>> highestRankedKItems(int[][] g, int[] p, int[] start, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new ItemComparator());\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,g[start[0]][start[1]],start[0],start[1]});\\n        g[start[0]][start[1]] = 0;\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            while(s-->0){\\n                int a[] = q.poll();\\n                if(a[1]>=p[0] && a[1]<=p[1]) \\n                    pq.add(new int[]{a[0],a[1],a[2],a[3]});\\n                for(int i=0;i<4;i++){\\n                    int x = a[2]+d[i];\\n                    int y = a[3]+d[i+1];\\n                    if(x<0 || x>=g.length || y<0 || y>=g[0].length || g[x][y]==0) continue;\\n                    q.add(new int[]{a[0]+1,g[x][y],x,y});\\n                    g[x][y] = 0;\\n                }\\n            }\\n\\n            while(k>0 && !pq.isEmpty()){\\n                int a[] = pq.poll();\\n                res.add(Arrays.asList(a[2],a[3]));\\n                k--;\\n            }\\n            if(k==0 || q.isEmpty())\\n                break;\\n        }\\n        return res;\\n    }\\n\\n    private static class ItemComparator implements Comparator<int[]>{\\n        @Override\\n        public int compare(int []a, int []b){\\n            if(a[1]-b[1]!=0)\\n                return a[1]-b[1];\\n            if(a[2]-b[2]!=0)\\n                return a[2]-b[2];\\n            return a[3]-b[3];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int d[] = new int[]{-1,0,1,0,-1};\\n    public List<List<Integer>> highestRankedKItems(int[][] g, int[] p, int[] start, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new ItemComparator());\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,g[start[0]][start[1]],start[0],start[1]});\\n        g[start[0]][start[1]] = 0;\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            while(s-->0){\\n                int a[] = q.poll();\\n                if(a[1]>=p[0] && a[1]<=p[1]) \\n                    pq.add(new int[]{a[0],a[1],a[2],a[3]});\\n                for(int i=0;i<4;i++){\\n                    int x = a[2]+d[i];\\n                    int y = a[3]+d[i+1];\\n                    if(x<0 || x>=g.length || y<0 || y>=g[0].length || g[x][y]==0) continue;\\n                    q.add(new int[]{a[0]+1,g[x][y],x,y});\\n                    g[x][y] = 0;\\n                }\\n            }\\n\\n            while(k>0 && !pq.isEmpty()){\\n                int a[] = pq.poll();\\n                res.add(Arrays.asList(a[2],a[3]));\\n                k--;\\n            }\\n            if(k==0 || q.isEmpty())\\n                break;\\n        }\\n        return res;\\n    }\\n\\n    private static class ItemComparator implements Comparator<int[]>{\\n        @Override\\n        public int compare(int []a, int []b){\\n            if(a[1]-b[1]!=0)\\n                return a[1]-b[1];\\n            if(a[2]-b[2]!=0)\\n                return a[2]-b[2];\\n            return a[3]-b[3];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721822,
                "title": "quite-ordinary-approach",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$, n - number of elements in the grid.\\n\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        result = []\\n        seen = {tuple(start)}\\n        q = deque([start])\\n        distance = 0\\n        while q and len(result) < k:\\n            for _ in range(len(q)):\\n                r, c = q.pop()\\n                if pricing[0] <= grid[r][c] <= pricing[1]:\\n                    result.append((distance, grid[r][c], r, c))\\n                \\n                for rr, cc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\\n                    if (0 <= rr < m) and (0 <= cc < n) and (rr, cc) not in seen and grid[rr][cc]:\\n                        q.appendleft((rr, cc))\\n                        seen.add((rr, cc))\\n            \\n            distance += 1\\n\\n        result.sort()\\n\\n        return [(r, c) for _, _, r, c in result[:k]]\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        result = []\\n        seen = {tuple(start)}\\n        q = deque([start])\\n        distance = 0\\n        while q and len(result) < k:\\n            for _ in range(len(q)):\\n                r, c = q.pop()\\n                if pricing[0] <= grid[r][c] <= pricing[1]:\\n                    result.append((distance, grid[r][c], r, c))\\n                \\n                for rr, cc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\\n                    if (0 <= rr < m) and (0 <= cc < n) and (rr, cc) not in seen and grid[rr][cc]:\\n                        q.appendleft((rr, cc))\\n                        seen.add((rr, cc))\\n            \\n            distance += 1\\n\\n        result.sort()\\n\\n        return [(r, c) for _, _, r, c in result[:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695739,
                "title": "python-bfsb",
                "content": "# Code\\n```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        if not grid:\\n            return []\\n        \\n        m, n = len(grid), len(grid[0])\\n        d = [[0,1], [0,-1], [1,0], [-1,0]]\\n        h = []\\n        queue = [[start[0], start[1]]]\\n        step = 0\\n\\n        while queue:\\n            nextQ = []\\n\\n            for [i, j] in queue:\\n                if 0 <= i < m and 0 <= j < n and grid[i][j]:\\n                    p = grid[i][j]\\n                    grid[i][j] = 0\\n\\n                    if p >= pricing[0] and p <= pricing[1]:\\n                        heapq.heappush(h, (step, p, i, j))\\n\\n                    for [a, b] in d:\\n                        x, y = i+a, j+b\\n\\n                        if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] != 0:\\n                            nextQ.append([x, y])\\n\\n            queue = nextQ\\n            step += 1\\n\\n            if len(h) >= k:\\n                break\\n\\n        res = heapq.nsmallest(k, h)\\n        return [[i, j] for (step, p, i, j) in res]\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        if not grid:\\n            return []\\n        \\n        m, n = len(grid), len(grid[0])\\n        d = [[0,1], [0,-1], [1,0], [-1,0]]\\n        h = []\\n        queue = [[start[0], start[1]]]\\n        step = 0\\n\\n        while queue:\\n            nextQ = []\\n\\n            for [i, j] in queue:\\n                if 0 <= i < m and 0 <= j < n and grid[i][j]:\\n                    p = grid[i][j]\\n                    grid[i][j] = 0\\n\\n                    if p >= pricing[0] and p <= pricing[1]:\\n                        heapq.heappush(h, (step, p, i, j))\\n\\n                    for [a, b] in d:\\n                        x, y = i+a, j+b\\n\\n                        if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] != 0:\\n                            nextQ.append([x, y])\\n\\n            queue = nextQ\\n            step += 1\\n\\n            if len(h) >= k:\\n                break\\n\\n        res = heapq.nsmallest(k, h)\\n        return [[i, j] for (step, p, i, j) in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596092,
                "title": "level-wise-bfs-for-each-cell-python3-86-beats",
                "content": "# Intuition\\nSince we want to return k highest ranked items, and for determining rank we need to use (level, price, row, col). The shortest the distance better. Because of this I decided to use BFS to track the shortest distance starting from start point. So we will explore neighbors level by level and add them to the heap in this tuple format (level,price, row, col).\\nhere the level is the distance from the starting point\\nwe will take Top K prices based on distances.\\n# Approach\\nApproach\\nInitiate visited set, queue for BFS, and items array keeping items explored\\nAdd the starting point values to visited, queue, and items\\nExplore from the starting point with BFS level by level. \\nAdd them to the heap in this tuple format (level,price, row, col).\\nhere the level is the distance from the starting point\\nwe will take Top K prices based on distances\\n\\n\\n\\n# Complexity\\n\\nTime Complexity: O(MNlogK)\\nFor exploring each cell with BFS: O(MN)\\n\\n\\n- Space complexity:\\nSpace complexity: O(MN)\\nFor visited set and queue: O(MN)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        direc=[(0,1),(1,0),(-1,0),(0,-1)]\\n        n=len(grid)\\n        m=len(grid[0])\\n\\n\\n        que=[(start[0],start[1])]\\n        visit=set()\\n        visit.add((start[0],start[1]))\\n\\n        heap=[]\\n        if pricing[0]<=grid[start[0]][start[1]]<=pricing[1]:\\n            heapq.heappush(heap,(0,grid[start[0]][start[1]],start[0],start[1]))\\n        stage=0\\n        while que:\\n            level=[]\\n            stage+=1\\n            \\n\\n            for _ in range(len(que)):\\n                i,j= que.pop(0)\\n                for a,b in direc:\\n                    r=i+a\\n                    c=j+b\\n                    if 0<=r<n and 0<=c<m and grid[r][c]!=0 and (r,c) not in visit:\\n\\n                        que.append((r,c))\\n                        visit.add((r,c))\\n                        if pricing[0]<=grid[r][c]<=pricing[1]:\\n                            heapq.heappush(heap,((stage,grid[r][c],r,c)))\\n        \\n\\n           \\n        # print(heap)\\n        if heap:\\n            res=[]\\n            for i in range(k):\\n                if heap:\\n                    dis,val,r,c =heapq.heappop(heap)\\n                    res.append([r,c])\\n            return res\\n        return []\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        direc=[(0,1),(1,0),(-1,0),(0,-1)]\\n        n=len(grid)\\n        m=len(grid[0])\\n\\n\\n        que=[(start[0],start[1])]\\n        visit=set()\\n        visit.add((start[0],start[1]))\\n\\n        heap=[]\\n        if pricing[0]<=grid[start[0]][start[1]]<=pricing[1]:\\n            heapq.heappush(heap,(0,grid[start[0]][start[1]],start[0],start[1]))\\n        stage=0\\n        while que:\\n            level=[]\\n            stage+=1\\n            \\n\\n            for _ in range(len(que)):\\n                i,j= que.pop(0)\\n                for a,b in direc:\\n                    r=i+a\\n                    c=j+b\\n                    if 0<=r<n and 0<=c<m and grid[r][c]!=0 and (r,c) not in visit:\\n\\n                        que.append((r,c))\\n                        visit.add((r,c))\\n                        if pricing[0]<=grid[r][c]<=pricing[1]:\\n                            heapq.heappush(heap,((stage,grid[r][c],r,c)))\\n        \\n\\n           \\n        # print(heap)\\n        if heap:\\n            res=[]\\n            for i in range(k):\\n                if heap:\\n                    dis,val,r,c =heapq.heappop(heap)\\n                    res.append([r,c])\\n            return res\\n        return []\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591277,
                "title": "dijkstra-s-algo-using-set",
                "content": "\\n\\nvector<int> dijkstra(vector<vector<int>> &vec, int vertices, int edges, int source) {\\n    // create adjacency list\\n    unordered_map<int, list<pair<int,int> > > adj;\\n    for(int i=0; i<edges; i++){\\n        int u = vec[i][0];\\n        int v = vec[i][1];\\n        int w = vec[i][2];\\n\\n        adj[u].push_back(make_pair(v,w));\\n        adj[v].push_back(make_pair(u,w));\\n\\n    }\\n    // creation of distance array with infinite value intially\\n    vector<int> dist(vertices);\\n    for(int i=0; i<vertices; i++)\\n        dist[i] = INT_MAX;\\n\\n    // creation of set on basis (distance, node)\\n    \\n    set<pair<int,int> > st;\\n\\n    // intialise distance and set with source node\\n    dist[source] = 0;\\n    st.insert(make_pair(0, source));\\n\\n    while(!st.empty()){\\n\\n        // fetch top record\\n        auto top = *(st.begin());\\n\\n        int nodeDistance = top.first;\\n        int topNode = top.second;\\n\\n        // remove top record now\\n        st.erase(st.begin());\\n\\n        // traverse on neighbours\\n        for(auto neighbour: adj[topNode]){\\n            if(nodeDistance + neighbour.second < dist[neighbour.first]){\\n                auto record = st.find(make_pair(dist[neighbour.first],neighbour.first));\\n\\n                // if record found, then erase it\\n                if(record != st.end()){\\n                    st.erase(record);\\n                }\\n\\n                // distance update\\n                dist[neighbour.first] = nodeDistance + neighbour.second;\\n                // record push in set\\n                st.insert(make_pair(dist[neighbour.first],neighbour.first));\\n\\n            }\\n        }\\n    }\\n    return dist;\\n}",
                "solutionTags": [
                    "Graph",
                    "Ordered Set"
                ],
                "code": "\\n\\nvector<int> dijkstra(vector<vector<int>> &vec, int vertices, int edges, int source) {\\n    // create adjacency list\\n    unordered_map<int, list<pair<int,int> > > adj;\\n    for(int i=0; i<edges; i++){\\n        int u = vec[i][0];\\n        int v = vec[i][1];\\n        int w = vec[i][2];\\n\\n        adj[u].push_back(make_pair(v,w));\\n        adj[v].push_back(make_pair(u,w));\\n\\n    }\\n    // creation of distance array with infinite value intially\\n    vector<int> dist(vertices);\\n    for(int i=0; i<vertices; i++)\\n        dist[i] = INT_MAX;\\n\\n    // creation of set on basis (distance, node)\\n    \\n    set<pair<int,int> > st;\\n\\n    // intialise distance and set with source node\\n    dist[source] = 0;\\n    st.insert(make_pair(0, source));\\n\\n    while(!st.empty()){\\n\\n        // fetch top record\\n        auto top = *(st.begin());\\n\\n        int nodeDistance = top.first;\\n        int topNode = top.second;\\n\\n        // remove top record now\\n        st.erase(st.begin());\\n\\n        // traverse on neighbours\\n        for(auto neighbour: adj[topNode]){\\n            if(nodeDistance + neighbour.second < dist[neighbour.first]){\\n                auto record = st.find(make_pair(dist[neighbour.first],neighbour.first));\\n\\n                // if record found, then erase it\\n                if(record != st.end()){\\n                    st.erase(record);\\n                }\\n\\n                // distance update\\n                dist[neighbour.first] = nodeDistance + neighbour.second;\\n                // record push in set\\n                st.insert(make_pair(dist[neighbour.first],neighbour.first));\\n\\n            }\\n        }\\n    }\\n    return dist;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3572917,
                "title": "bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int dist = 0;\\n        vector<vector<int>> ans;\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        std::priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        queue<pair<int, int>> q;\\n        q.push({start[0], start[1]});\\n        vis[start[0]][start[1]] = 1;\\n        if (grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1]) {\\n            pq.push({0, grid[start[0]][start[1]], start[0], start[1]});\\n        }\\n        while(!q.empty()) {\\n            int w = q.size();\\n            ++dist;\\n            while(w--) {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for (int s = 0; s < 4; ++s) {\\n                    int di = i + dirs[s].first;\\n                    int dj = j + dirs[s].second;\\n                    if (di >= 0 && di < m && dj >= 0 && dj < n && grid[di][dj] != 0 && !vis[di][dj]) {\\n                        q.push({di, dj});\\n                        vis[di][dj] = 1;\\n                        if (grid[di][dj] >= pricing[0] && grid[di][dj] <= pricing[1]) {\\n                            pq.push({dist, grid[di][dj], di, dj});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        while(!pq.empty()) {\\n            vector<int> temp = pq.top();\\n            int p = temp[2];\\n            int l = temp[3];\\n            ans.push_back({p, l});\\n            if (ans.size() == k) {\\n                return ans;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int dist = 0;\\n        vector<vector<int>> ans;\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        std::priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        queue<pair<int, int>> q;\\n        q.push({start[0], start[1]});\\n        vis[start[0]][start[1]] = 1;\\n        if (grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1]) {\\n            pq.push({0, grid[start[0]][start[1]], start[0], start[1]});\\n        }\\n        while(!q.empty()) {\\n            int w = q.size();\\n            ++dist;\\n            while(w--) {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for (int s = 0; s < 4; ++s) {\\n                    int di = i + dirs[s].first;\\n                    int dj = j + dirs[s].second;\\n                    if (di >= 0 && di < m && dj >= 0 && dj < n && grid[di][dj] != 0 && !vis[di][dj]) {\\n                        q.push({di, dj});\\n                        vis[di][dj] = 1;\\n                        if (grid[di][dj] >= pricing[0] && grid[di][dj] <= pricing[1]) {\\n                            pq.push({dist, grid[di][dj], di, dj});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        while(!pq.empty()) {\\n            vector<int> temp = pq.top();\\n            int p = temp[2];\\n            int l = temp[3];\\n            ans.push_back({p, l});\\n            if (ans.size() == k) {\\n                return ans;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559385,
                "title": "bfs-priority-queue-custom-comparator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Given the start node, simply perform a BFS traversal through the grid starting at the given cell. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Define each cell in the grid as a Node object.\\n- While performing the BFS traversal, add a node to the queue only if the value of the cell is positive (thereby not passing through a wall).\\n- If the price lies within the acceptable range, add that node to the Priority Queue which uses a custom comparator following the given rules for tie-breaks.\\n- Poll the first k (or fewer if less than k) nodes and add its co-ordinates to the list to be returned.\\n\\n# Complexity\\n- Time complexity: O(mn log(mn))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Node implements Comparable<Node> {\\n        int row;\\n        int col;\\n        int price;\\n        int dist;\\n        public Node(int row, int col, int price, int dist) {\\n            this.row = row;\\n            this.col = col;\\n            this.price = price;\\n            this.dist = dist;\\n        }\\n        \\n        @Override\\n        public int compareTo(Node other) {\\n            // Define your comparison logic based on the attributes of the Node class\\n            // Return a negative value if this object should be placed before other\\n            // Return a positive value if this object should be placed after other\\n            // Return 0 if this object and other are considered equal\\n            if(this.dist != other.dist) {\\n                return this.dist - other.dist;\\n            }\\n            if(this.price != other.price) {\\n                return this.price - other.price;\\n            }\\n            if(this.row != other.row) {\\n                return this.row - other.row;\\n            }\\n            return this.col - other.col; \\n        }\\n    }\\n\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int low = pricing[0];\\n        int high = pricing[1];\\n        int sRow = start[0];\\n        int sCol = start[1];\\n        int rows = grid.length; \\n        int cols = grid[0].length;\\n\\n        boolean[][] vis = new boolean[rows][cols];\\n        vis[sRow][sCol] = true;\\n\\n        Queue<Node> q = new LinkedList<>();\\n        q.add(new Node(sRow, sCol, grid[sRow][sCol], 0));\\n\\n        PriorityQueue<Node> pq = new PriorityQueue<>();\\n\\n        while(!q.isEmpty()) {\\n            Node front = q.remove();\\n            int row = front.row;\\n            int col = front.col;\\n            int price = front.price;\\n            int dist = front.dist;\\n            if(price>=low && price<=high) {\\n                pq.add(front);\\n            }\\n            for(int delr=-1 ; delr<=1 ; delr++) {\\n                for(int delc=-1 ; delc<=1 ; delc++) {\\n                    if(delr!=0 && delc!=0) {\\n                        continue;\\n                    }\\n                    int nr = row + delr;\\n                    int nc = col + delc;\\n                    if(nr>=0 && nr<rows && nc>=0 && nc<cols && grid[nr][nc]>0 && !vis[nr][nc]) {\\n                        vis[nr][nc] = true;\\n                        q.add(new Node(nr, nc, grid[nr][nc], dist+1));\\n                    }\\n                }\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0 ; i<k && !pq.isEmpty() ; i++) {\\n            Node front = pq.remove();\\n            List<Integer> index = new ArrayList<>();\\n            index.add(front.row);\\n            index.add(front.col);\\n            ans.add(index);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Node implements Comparable<Node> {\\n        int row;\\n        int col;\\n        int price;\\n        int dist;\\n        public Node(int row, int col, int price, int dist) {\\n            this.row = row;\\n            this.col = col;\\n            this.price = price;\\n            this.dist = dist;\\n        }\\n        \\n        @Override\\n        public int compareTo(Node other) {\\n            // Define your comparison logic based on the attributes of the Node class\\n            // Return a negative value if this object should be placed before other\\n            // Return a positive value if this object should be placed after other\\n            // Return 0 if this object and other are considered equal\\n            if(this.dist != other.dist) {\\n                return this.dist - other.dist;\\n            }\\n            if(this.price != other.price) {\\n                return this.price - other.price;\\n            }\\n            if(this.row != other.row) {\\n                return this.row - other.row;\\n            }\\n            return this.col - other.col; \\n        }\\n    }\\n\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int low = pricing[0];\\n        int high = pricing[1];\\n        int sRow = start[0];\\n        int sCol = start[1];\\n        int rows = grid.length; \\n        int cols = grid[0].length;\\n\\n        boolean[][] vis = new boolean[rows][cols];\\n        vis[sRow][sCol] = true;\\n\\n        Queue<Node> q = new LinkedList<>();\\n        q.add(new Node(sRow, sCol, grid[sRow][sCol], 0));\\n\\n        PriorityQueue<Node> pq = new PriorityQueue<>();\\n\\n        while(!q.isEmpty()) {\\n            Node front = q.remove();\\n            int row = front.row;\\n            int col = front.col;\\n            int price = front.price;\\n            int dist = front.dist;\\n            if(price>=low && price<=high) {\\n                pq.add(front);\\n            }\\n            for(int delr=-1 ; delr<=1 ; delr++) {\\n                for(int delc=-1 ; delc<=1 ; delc++) {\\n                    if(delr!=0 && delc!=0) {\\n                        continue;\\n                    }\\n                    int nr = row + delr;\\n                    int nc = col + delc;\\n                    if(nr>=0 && nr<rows && nc>=0 && nc<cols && grid[nr][nc]>0 && !vis[nr][nc]) {\\n                        vis[nr][nc] = true;\\n                        q.add(new Node(nr, nc, grid[nr][nc], dist+1));\\n                    }\\n                }\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0 ; i<k && !pq.isEmpty() ; i++) {\\n            Node front = pq.remove();\\n            List<Integer> index = new ArrayList<>();\\n            index.add(front.row);\\n            index.add(front.col);\\n            ans.add(index);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527305,
                "title": "c-python-bfs-using-pq-solution-with-explanation",
                "content": "The problem can be transformed into finding the k closest items to ```start```, how far of a item is based on the rule problem mentioned.\\nSo we can use PQ to traverse grid from near to far.\\n\\ntc is ```O(klog(m*n))```, sc is ```O(m*n)```\\n### c++\\n```cpp\\nclass Item {\\n    public:\\n        int distance, price, row, col;\\n        Item(int distance, int price, int row, int col): distance(distance), price(price), row(row), col(col) {}\\n        Item(const Item &other): distance(other.distance), price(other.price), row(other.row), col(other.col) {}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        auto cmp  = [] (Item& x, Item& y) {\\n            if (x.distance < y.distance) return false;\\n            else if (x.distance > y.distance) return true;\\n            if (x.price < y.price) return false;\\n            else if (x.price > y.price) return true;\\n            if (x.row < y.row) return false;\\n            else if (x.row > y.row) return true;\\n            if (x.col < y.col) return false;\\n            return true;\\n        };\\n        priority_queue<Item, vector<Item>, decltype(cmp)> pq(cmp);\\n        vector<vector<int>> ans;\\n        pq.emplace(0, grid[start[0]][start[1]], start[0], start[1]);\\n        grid[start[0]][start[1]] = 0;\\n        \\n        while (!pq.empty() && ans.size() < k) {\\n            Item im {pq.top()}; \\n            pq.pop();\\n\\n            if (im.price >= pricing[0] && im.price <= pricing[1]) {\\n                ans.emplace_back(vector<int>{im.row, im.col});\\n            }\\n            for (auto [nr, nc]: vector<pair<int,int>> {{im.row + 1, im.col}, {im.row - 1, im.col}, {im.row, im.col + 1}, {im.row, im.col - 1}}) {\\n                if (nr >= 0 && nr < grid.size() && nc >= 0 && nc < grid[0].size() && grid[nr][nc] != 0) {\\n                    pq.emplace(im.distance+1, grid[nr][nc], nr, nc);\\n                    grid[nr][nc] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### python\\n```python\\nfrom heapq import heappush, heappop\\nclass Item:\\n    def __init__(self, distance, price, row, col):\\n        self.distance = distance\\n        self.price = price\\n        self.row = row\\n        self.col = col\\n    \\n    def __lt__(self, other):\\n        if self.distance < other.distance: return True\\n        elif self.distance > other.distance: return False\\n\\n        if self.price < other.price: return True\\n        elif self.price > other.price: return False\\n\\n        if self.row < other.row: return True\\n        elif self.row > other.row: return False\\n\\n        if self.col < other.col: return True\\n        elif self.col > other.col: return False\\n    \\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        rownum, colnum = len(grid), len(grid[0])\\n        pq = [Item(0, grid[start[0]][start[1]], start[0], start[1])]\\n        ans = []\\n        grid[start[0]][start[1]] = 0\\n        while pq and len(ans) < k:\\n            im = heappop(pq)\\n            if pricing[0] <= im.price <= pricing[1]:\\n                ans.append([im.row, im.col])\\n            for nr, nc in ((im.row+1, im.col), (im.row-1, im.col), (im.row, im.col+1), (im.row, im.col-1)):\\n                if 0 <= nr < rownum and 0 <= nc < colnum and grid[nr][nc] != 0:\\n                    heappush(pq, Item(im.distance+1, grid[nr][nc], nr, nc))\\n                    grid[nr][nc] = 0\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```start```\n```O(klog(m*n))```\n```O(m*n)```\n```cpp\\nclass Item {\\n    public:\\n        int distance, price, row, col;\\n        Item(int distance, int price, int row, int col): distance(distance), price(price), row(row), col(col) {}\\n        Item(const Item &other): distance(other.distance), price(other.price), row(other.row), col(other.col) {}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        auto cmp  = [] (Item& x, Item& y) {\\n            if (x.distance < y.distance) return false;\\n            else if (x.distance > y.distance) return true;\\n            if (x.price < y.price) return false;\\n            else if (x.price > y.price) return true;\\n            if (x.row < y.row) return false;\\n            else if (x.row > y.row) return true;\\n            if (x.col < y.col) return false;\\n            return true;\\n        };\\n        priority_queue<Item, vector<Item>, decltype(cmp)> pq(cmp);\\n        vector<vector<int>> ans;\\n        pq.emplace(0, grid[start[0]][start[1]], start[0], start[1]);\\n        grid[start[0]][start[1]] = 0;\\n        \\n        while (!pq.empty() && ans.size() < k) {\\n            Item im {pq.top()}; \\n            pq.pop();\\n\\n            if (im.price >= pricing[0] && im.price <= pricing[1]) {\\n                ans.emplace_back(vector<int>{im.row, im.col});\\n            }\\n            for (auto [nr, nc]: vector<pair<int,int>> {{im.row + 1, im.col}, {im.row - 1, im.col}, {im.row, im.col + 1}, {im.row, im.col - 1}}) {\\n                if (nr >= 0 && nr < grid.size() && nc >= 0 && nc < grid[0].size() && grid[nr][nc] != 0) {\\n                    pq.emplace(im.distance+1, grid[nr][nc], nr, nc);\\n                    grid[nr][nc] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nfrom heapq import heappush, heappop\\nclass Item:\\n    def __init__(self, distance, price, row, col):\\n        self.distance = distance\\n        self.price = price\\n        self.row = row\\n        self.col = col\\n    \\n    def __lt__(self, other):\\n        if self.distance < other.distance: return True\\n        elif self.distance > other.distance: return False\\n\\n        if self.price < other.price: return True\\n        elif self.price > other.price: return False\\n\\n        if self.row < other.row: return True\\n        elif self.row > other.row: return False\\n\\n        if self.col < other.col: return True\\n        elif self.col > other.col: return False\\n    \\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        rownum, colnum = len(grid), len(grid[0])\\n        pq = [Item(0, grid[start[0]][start[1]], start[0], start[1])]\\n        ans = []\\n        grid[start[0]][start[1]] = 0\\n        while pq and len(ans) < k:\\n            im = heappop(pq)\\n            if pricing[0] <= im.price <= pricing[1]:\\n                ans.append([im.row, im.col])\\n            for nr, nc in ((im.row+1, im.col), (im.row-1, im.col), (im.row, im.col+1), (im.row, im.col-1)):\\n                if 0 <= nr < rownum and 0 <= nc < colnum and grid[nr][nc] != 0:\\n                    heappush(pq, Item(im.distance+1, grid[nr][nc], nr, nc))\\n                    grid[nr][nc] = 0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449375,
                "title": "c-bfs-custom-sort",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>movements  // to track the movements\\n    {\\n       {1,0},{-1,0},{0,1},{0,-1}\\n    };\\n    void set_dis(vector<vector<int>>&grid,vector<vector<int>>&dis,vector<int>&start,vector<vector<bool>>&visit) // VFS to find shortest distance\\n    {\\n        int x=start[0],y=start[1];\\n        //vector<vector<bool>>visit(dis.size(),vector<bool>(dis[0].size()));\\n        queue<pair<int,int>>q;\\n        q.push({x,y});\\n        visit[x][y]=1;\\n        while(q.size())\\n        {\\n            auto node=q.front();\\n            q.pop();\\n            for(auto it:movements)\\n            {\\n               int next_x=it.first+node.first;\\n               int next_y=it.second+node.second;\\n               if(next_x<0||next_y<0||next_x>=dis.size()||next_y>=dis[0].size()||grid[next_x][next_y]==0) // invalid\\n                 continue;\\n               if(visit[next_x][next_y]==0)\\n               {\\n                   visit[next_x][next_y]=1;\\n                   q.push({next_x,next_y});\\n                   dis[next_x][next_y]=dis[node.first][node.second]+1;\\n               }\\n            }\\n        }\\n\\n    }\\n\\n    static bool comp(pair<pair<int,int>,pair<int,int>>&a,pair<pair<int,int>,pair<int,int>>&b) // custom comparator\\n    {\\n        if(a.first.first!=b.first.first)\\n        return (a.first.first<b.first.first);\\n         \\n         if(a.first.second!=b.first.second)\\n         return(a.first.second<b.first.second);\\n\\n          if(a.second.first!=b.second.first)\\n         return(a.second.first<b.second.first);\\n         \\n         \\n          return a.second.second<b.second.second;\\n        \\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        vector<vector<int>>dis(n,vector<int>(m,0));\\n        vector<vector<bool>>visit(n,vector<bool>(m,0));\\n\\n        set_dis(grid,dis,start,visit);\\n        vector<pair<pair<int,int>,pair<int,int>>>v; // stores dis,price,row,col \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]!=0 and grid[i][j]!=1 and visit[i][j] and grid[i][j]>=pricing[0] and grid[i][j]<=pricing[1]) // pushing only the valid items\\n                {\\n                    pair<int,int>pos={i,j};\\n                    pair<int,int>val={dis[i][j],grid[i][j]};\\n                    v.push_back({val,pos});\\n                }\\n            }\\n        }\\n        sort(v.begin(),v.end(),comp); // sorting the array \\n\\n        vector<vector<int>>ans;\\n        for(int i=0;i<v.size();i++) // iterating over the array\\n        {\\n            if(k==0)   // if found l elements then break\\n            break;\\n            int x=v[i].second.first;\\n            int y=v[i].second.second;\\n            vector<int>curr={x,y};\\n            ans.push_back(curr);\\n            --k;\\n        }\\n       return ans; // return the answer\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>movements  // to track the movements\\n    {\\n       {1,0},{-1,0},{0,1},{0,-1}\\n    };\\n    void set_dis(vector<vector<int>>&grid,vector<vector<int>>&dis,vector<int>&start,vector<vector<bool>>&visit) // VFS to find shortest distance\\n    {\\n        int x=start[0],y=start[1];\\n        //vector<vector<bool>>visit(dis.size(),vector<bool>(dis[0].size()));\\n        queue<pair<int,int>>q;\\n        q.push({x,y});\\n        visit[x][y]=1;\\n        while(q.size())\\n        {\\n            auto node=q.front();\\n            q.pop();\\n            for(auto it:movements)\\n            {\\n               int next_x=it.first+node.first;\\n               int next_y=it.second+node.second;\\n               if(next_x<0||next_y<0||next_x>=dis.size()||next_y>=dis[0].size()||grid[next_x][next_y]==0) // invalid\\n                 continue;\\n               if(visit[next_x][next_y]==0)\\n               {\\n                   visit[next_x][next_y]=1;\\n                   q.push({next_x,next_y});\\n                   dis[next_x][next_y]=dis[node.first][node.second]+1;\\n               }\\n            }\\n        }\\n\\n    }\\n\\n    static bool comp(pair<pair<int,int>,pair<int,int>>&a,pair<pair<int,int>,pair<int,int>>&b) // custom comparator\\n    {\\n        if(a.first.first!=b.first.first)\\n        return (a.first.first<b.first.first);\\n         \\n         if(a.first.second!=b.first.second)\\n         return(a.first.second<b.first.second);\\n\\n          if(a.second.first!=b.second.first)\\n         return(a.second.first<b.second.first);\\n         \\n         \\n          return a.second.second<b.second.second;\\n        \\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        vector<vector<int>>dis(n,vector<int>(m,0));\\n        vector<vector<bool>>visit(n,vector<bool>(m,0));\\n\\n        set_dis(grid,dis,start,visit);\\n        vector<pair<pair<int,int>,pair<int,int>>>v; // stores dis,price,row,col \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]!=0 and grid[i][j]!=1 and visit[i][j] and grid[i][j]>=pricing[0] and grid[i][j]<=pricing[1]) // pushing only the valid items\\n                {\\n                    pair<int,int>pos={i,j};\\n                    pair<int,int>val={dis[i][j],grid[i][j]};\\n                    v.push_back({val,pos});\\n                }\\n            }\\n        }\\n        sort(v.begin(),v.end(),comp); // sorting the array \\n\\n        vector<vector<int>>ans;\\n        for(int i=0;i<v.size();i++) // iterating over the array\\n        {\\n            if(k==0)   // if found l elements then break\\n            break;\\n            int x=v[i].second.first;\\n            int y=v[i].second.second;\\n            vector<int>curr={x,y};\\n            ans.push_back(curr);\\n            --k;\\n        }\\n       return ans; // return the answer\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429442,
                "title": "c-easy-and-understandable-code-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& price, vector<int>& st, int k) {\\n        int n=grid.size() , m=grid[0].size() ;\\n        int lp = price[0] , hp = price[1] ; // price range\\n        \\n        vector<int> dx = {1,-1,0,0} , dy = {0,0,1,-1} ;\\n        vector<vector<int>> vis(n , vector<int>(m , 0)) ;\\n        \\n        queue<vector<int>> q ;\\n        priority_queue<vector<int> , vector<vector<int>> , greater<vector<int>>> pq ;\\n        \\n        // standard BFS\\n        \\n        q.push({st[0] , st[1] , 0}) ;\\n        vis[st[0]][st[1]]  = 1 ;\\n\\n        while( !q.empty() )\\n        {\\n            int sz = q.size() ;\\n            while(sz--)\\n            {\\n                auto cur = q.front() ;\\n                q.pop() ;\\n                int x = cur[0] , y = cur[1] , d = cur[2] ;\\n                vis[x][y]=1 ;\\n                // if grid value is in the range then push it in min heap\\n                if(grid[x][y] >= lp && grid[x][y] <= hp)  pq.push({d+1 , grid[x][y] , x , y}) ;\\n\\n                for(int i=0 ; i<4 ; i++)\\n                {\\n                    int nx = x + dx[i] , ny = y + dy[i] ;\\n                    if(nx<0 || ny<0 || nx>=n || ny>=m || !grid[nx][ny] || vis[nx][ny])  continue ;\\n                    q.push({nx , ny , d+1}) ;\\n                    vis[nx][ny]=1 ;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> ans ;\\n        // extracting the top k value from heap\\n        while(k-- && !pq.empty())\\n        {\\n            auto t = pq.top() ;\\n            pq.pop() ;\\n            ans.push_back({t[2] , t[3]}) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n**UPVOTE IF HELPFUL :)**",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& price, vector<int>& st, int k) {\\n        int n=grid.size() , m=grid[0].size() ;\\n        int lp = price[0] , hp = price[1] ; // price range\\n        \\n        vector<int> dx = {1,-1,0,0} , dy = {0,0,1,-1} ;\\n        vector<vector<int>> vis(n , vector<int>(m , 0)) ;\\n        \\n        queue<vector<int>> q ;\\n        priority_queue<vector<int> , vector<vector<int>> , greater<vector<int>>> pq ;\\n        \\n        // standard BFS\\n        \\n        q.push({st[0] , st[1] , 0}) ;\\n        vis[st[0]][st[1]]  = 1 ;\\n\\n        while( !q.empty() )\\n        {\\n            int sz = q.size() ;\\n            while(sz--)\\n            {\\n                auto cur = q.front() ;\\n                q.pop() ;\\n                int x = cur[0] , y = cur[1] , d = cur[2] ;\\n                vis[x][y]=1 ;\\n                // if grid value is in the range then push it in min heap\\n                if(grid[x][y] >= lp && grid[x][y] <= hp)  pq.push({d+1 , grid[x][y] , x , y}) ;\\n\\n                for(int i=0 ; i<4 ; i++)\\n                {\\n                    int nx = x + dx[i] , ny = y + dy[i] ;\\n                    if(nx<0 || ny<0 || nx>=n || ny>=m || !grid[nx][ny] || vis[nx][ny])  continue ;\\n                    q.push({nx , ny , d+1}) ;\\n                    vis[nx][ny]=1 ;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> ans ;\\n        // extracting the top k value from heap\\n        while(k-- && !pq.empty())\\n        {\\n            auto t = pq.top() ;\\n            pq.pop() ;\\n            ans.push_back({t[2] , t[3]}) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411424,
                "title": "c-bfs-priority-queue",
                "content": "\\n\\n# Approach\\nFirst find distance from start to all cells which can be visited (use BFS because it gives minimum distance). Now use **priority queue** of **vector** which contains {distance, price, rowNumber, colNumber, row, col}. This will be a max heap. Now iterate over all cells and store their distance, price etc in heap and as soon as heap size becomes greater than k, pop one element. The heap now contains k highest ranked items but in reverse order i.e. lowest rank on top of heap so store them in ans vector and reverse the vector and return the ans.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,0,1,-1};\\n    int dy[4] = {1,-1,0,0};\\n\\n    bool isValid(int x,int y,vector<vector<int>>& grid,vector<vector<int>>& dist)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(x>=0 && y>=0 && x<n && y<m && grid[x][y]!=0 && dist[x][y]==-1)\\n        return true;\\n        return false;\\n    }\\n    void bfs(vector<vector<int>>& dist,vector<vector<int>>& grid,int row,int col)\\n    {\\n        dist[row][col] = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i=0;i<siz;i++)\\n            {\\n                int r = q.front().first;\\n                int c = q.front().second;\\n                q.pop();\\n                for(int j=0;j<4;j++)\\n                {\\n                    int nr = r+dx[j];\\n                    int nc = c+dy[j];\\n                    if(isValid(nr,nc,grid,dist))\\n                    {\\n                        dist[nr][nc] = dist[r][c]+1;\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int low = pricing[0];\\n        int high = pricing[1];\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int r = start[0];\\n        int c = start[1];\\n        vector<vector<int>> dist(n,vector<int>(m,-1));\\n        bfs(dist,grid,r,c);\\n        priority_queue<vector<int>> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0 || dist[i][j]==-1)\\n                continue;\\n                if(grid[i][j]>=low && grid[i][j]<=high)\\n                {\\n                    int dis = dist[i][j];\\n                    int price = grid[i][j];\\n                    int row = i;\\n                    int col = j;\\n                    pq.push({dis,price,row,col,i,j});\\n                    if(pq.size()>k)\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty())\\n        {\\n            auto node = pq.top();\\n            pq.pop();\\n            ans.push_back({node[4],node[5]});\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,0,1,-1};\\n    int dy[4] = {1,-1,0,0};\\n\\n    bool isValid(int x,int y,vector<vector<int>>& grid,vector<vector<int>>& dist)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(x>=0 && y>=0 && x<n && y<m && grid[x][y]!=0 && dist[x][y]==-1)\\n        return true;\\n        return false;\\n    }\\n    void bfs(vector<vector<int>>& dist,vector<vector<int>>& grid,int row,int col)\\n    {\\n        dist[row][col] = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i=0;i<siz;i++)\\n            {\\n                int r = q.front().first;\\n                int c = q.front().second;\\n                q.pop();\\n                for(int j=0;j<4;j++)\\n                {\\n                    int nr = r+dx[j];\\n                    int nc = c+dy[j];\\n                    if(isValid(nr,nc,grid,dist))\\n                    {\\n                        dist[nr][nc] = dist[r][c]+1;\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int low = pricing[0];\\n        int high = pricing[1];\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int r = start[0];\\n        int c = start[1];\\n        vector<vector<int>> dist(n,vector<int>(m,-1));\\n        bfs(dist,grid,r,c);\\n        priority_queue<vector<int>> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0 || dist[i][j]==-1)\\n                continue;\\n                if(grid[i][j]>=low && grid[i][j]<=high)\\n                {\\n                    int dis = dist[i][j];\\n                    int price = grid[i][j];\\n                    int row = i;\\n                    int col = j;\\n                    pq.push({dis,price,row,col,i,j});\\n                    if(pq.size()>k)\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty())\\n        {\\n            auto node = pq.top();\\n            pq.pop();\\n            ans.push_back({node[4],node[5]});\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350812,
                "title": "python3-classical-bfs-with-sortedlist-or-heap-o-m-n-logk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we need to traverse all prices while keeping track of the distance this is a classical bfs problem.\\n\\nThere are two general approaches:\\n1) Do BFS and keep all the prices we meet, then sort O(m* n + m\\nn* log(m*n))\\n2) Do BFS and keep a heap/sorted list during the bfs O(m* n* logk)\\n\\nI did the second one and keept a sorted list, which I kept in the given size.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS + sorting\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m* n* logk)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n) worst case\\n# Code\\n```\\nimport sortedcontainers\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n\\n        # bfs with sorted list booooooooiiiiiiiis\\n        sorted_list = sortedcontainers.SortedList()\\n\\n        # get the grid size\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        # make a queue for the bfs\\n        queue = collections.deque([(start[0], start[1], 0, grid[start[0]][start[1]])])\\n        grid[start[0]][start[1]] = 0\\n        while queue:\\n\\n            # pop the position and and current steps\\n            rx, cx, steps, price = queue.popleft()\\n\\n            # check whether the item is in the price range\\n            if pricing[0] <= price <= pricing[1]:\\n\\n                # make the score of the item\\n                item = (steps, price, rx, cx)\\n\\n                # put into the sorted list\\n                sorted_list.add(item)\\n\\n                # check the length of our list\\n                if len(sorted_list) > k:\\n                    sorted_list.pop(-1)\\n            \\n            # check the neighbours\\n            for nrx, ncx in [(rx+1, cx), (rx-1, cx), (rx, cx+1), (rx, cx-1)]:\\n                if 0 <= nrx < m and 0 <= ncx < n and grid[nrx][ncx]:\\n\\n                    # push into the queue\\n                    queue.append((nrx, ncx, steps+1, grid[nrx][ncx]))\\n                    \\n                    # mark the position as visited\\n                    grid[nrx][ncx] = 0\\n        \\n        # get the sorted return\\n        return [item[2:] for item in sorted_list]\\n\\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport sortedcontainers\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n\\n        # bfs with sorted list booooooooiiiiiiiis\\n        sorted_list = sortedcontainers.SortedList()\\n\\n        # get the grid size\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        # make a queue for the bfs\\n        queue = collections.deque([(start[0], start[1], 0, grid[start[0]][start[1]])])\\n        grid[start[0]][start[1]] = 0\\n        while queue:\\n\\n            # pop the position and and current steps\\n            rx, cx, steps, price = queue.popleft()\\n\\n            # check whether the item is in the price range\\n            if pricing[0] <= price <= pricing[1]:\\n\\n                # make the score of the item\\n                item = (steps, price, rx, cx)\\n\\n                # put into the sorted list\\n                sorted_list.add(item)\\n\\n                # check the length of our list\\n                if len(sorted_list) > k:\\n                    sorted_list.pop(-1)\\n            \\n            # check the neighbours\\n            for nrx, ncx in [(rx+1, cx), (rx-1, cx), (rx, cx+1), (rx, cx-1)]:\\n                if 0 <= nrx < m and 0 <= ncx < n and grid[nrx][ncx]:\\n\\n                    # push into the queue\\n                    queue.append((nrx, ncx, steps+1, grid[nrx][ncx]))\\n                    \\n                    # mark the position as visited\\n                    grid[nrx][ncx] = 0\\n        \\n        # get the sorted return\\n        return [item[2:] for item in sorted_list]\\n\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340348,
                "title": "solved-by-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int a[4]={0,0,-1,1};\\n    int b[4]={1,-1,0,0};\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        set<pair<int,int>>st;\\n        map<int,set<pair<int,pair<int,int>>>>m;\\n        queue<pair<pair<int,int>,int>>q;\\n        q.push({{start[0],start[1]},0});\\n        int r=grid.size(),c=grid[0].size();\\n        vector<vector<int>>vis(r,vector<int>(c,-1));\\n         vis[start[0]][start[1]]=1;\\n\\n\\n         while(q.size()>0){\\n            pair<pair<int,int>,int>p=q.front();\\n            int x=p.first.first;\\n            int y=p.first.second;\\n            int d=p.second;\\n           \\n            if(grid[x][y]>=pricing[0]&&grid[x][y]<=pricing[1])\\n                    m[d].insert({grid[x][y],{x,y}});\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int x1=(a[i]+x);\\n                int y1=(b[i]+y);\\n                if(x1>=0&&y1>=0&&x1<grid.size()&&y1<grid[0].size()&&grid[x1][y1]!=0&&vis[x1][y1]==-1){\\n                    vis[x1][y1]=1;\\n                    q.push({{x1,y1},d+1});\\n                  }\\n            }\\n        }\\n        \\n        \\n        \\n        vector<vector<int>>ans;\\n        \\n        for(auto it:m){\\n            map<int,set<pair<int,int>>>m1;\\n            for(auto i:it.second){\\n                if(k>0){\\n                    m1[i.first].insert({i.second.first,i.second.second});\\n                    k--;\\n                }\\n            }\\n            for(auto it:m1){ \\n                for(auto i:it.second){\\n                    vector<int>find;\\n                    find.push_back(i.first);\\n                    find.push_back(i.second);\\n                    ans.push_back(find);\\n                }\\n            }\\n          \\n        }\\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int a[4]={0,0,-1,1};\\n    int b[4]={1,-1,0,0};\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        set<pair<int,int>>st;\\n        map<int,set<pair<int,pair<int,int>>>>m;\\n        queue<pair<pair<int,int>,int>>q;\\n        q.push({{start[0],start[1]},0});\\n        int r=grid.size(),c=grid[0].size();\\n        vector<vector<int>>vis(r,vector<int>(c,-1));\\n         vis[start[0]][start[1]]=1;\\n\\n\\n         while(q.size()>0){\\n            pair<pair<int,int>,int>p=q.front();\\n            int x=p.first.first;\\n            int y=p.first.second;\\n            int d=p.second;\\n           \\n            if(grid[x][y]>=pricing[0]&&grid[x][y]<=pricing[1])\\n                    m[d].insert({grid[x][y],{x,y}});\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int x1=(a[i]+x);\\n                int y1=(b[i]+y);\\n                if(x1>=0&&y1>=0&&x1<grid.size()&&y1<grid[0].size()&&grid[x1][y1]!=0&&vis[x1][y1]==-1){\\n                    vis[x1][y1]=1;\\n                    q.push({{x1,y1},d+1});\\n                  }\\n            }\\n        }\\n        \\n        \\n        \\n        vector<vector<int>>ans;\\n        \\n        for(auto it:m){\\n            map<int,set<pair<int,int>>>m1;\\n            for(auto i:it.second){\\n                if(k>0){\\n                    m1[i.first].insert({i.second.first,i.second.second});\\n                    k--;\\n                }\\n            }\\n            for(auto it:m1){ \\n                for(auto i:it.second){\\n                    vector<int>find;\\n                    find.push_back(i.first);\\n                    find.push_back(i.second);\\n                    ans.push_back(find);\\n                }\\n            }\\n          \\n        }\\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292544,
                "title": "bfs-sorting-bfs-heap-solutions-in-python-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we want to return k highest ranked items, and for determining rank we need to use (distance, price, row, col). The shortest the distance better. Because of this I decided to use BFS to track the shortest distance starting from start point. So we will explore neighbors level by level and add them to the items array in this tuple format `(distance, price, row, col)`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initiate `visited` set, `queue` for BFS, and `items` array keeping items explored\\n2. Add the starting point values to visited, queue, and items\\n3. Explore from the starting point with BFS level by level. Add items with valid pricing criteria\\n4. Sort the items array\\n5. Return the first top k items\\n\\n# Complexity\\n- Time complexity: `O(MNlog(MN))`\\n     For exploring each cell with BFS: `O(MN)`\\n     For sorting items array: `O(MNlog(MN))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(MN)`\\n     For visited set and queue: `O(MN)`\\n     For sorting items array: `O(MN)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        # adds item in the cell (row, col) if it is in the pricing range\\n        def addValidItem(row, col, level):\\n            if pricing[0] <= grid[row][col] <= pricing[1]:\\n                items.append((level, grid[row][col], row, col))\\n\\n        level, items, visited, queue = 0, [], set(), deque([])\\n        R, C = len(grid), len(grid[0])\\n\\n        # initiate by adding the starting point to visited, queue, and items (if it is in priceing range)\\n        visited.add(tuple(start))\\n        queue.append(tuple(start))\\n        addValidItem(start[0], start[1], 0)\\n\\n        # explore all the neighbors [DOWN, UP, LEFT, RIGHT] level by level to keep the distance from the starting point\\n        while queue:\\n            level += 1\\n\\n            for _ in range(len(queue)):\\n                row, col = queue.popleft()\\n\\n                # exploring neighbors\\n                for r, c in [(0,1), (0,-1), (1,0), (-1,0)]:\\n                    new_r, new_c = row+r, col+c\\n\\n                    # check if neighbor cell is in bound, not visited previously, and not a wall\\n                    if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited or grid[new_r][new_c] == 0:\\n                        continue\\n\\n                    # add the neighbor cell if it is in the pricing range\\n                    addValidItem(new_r, new_c, level)\\n                    # mark this neighbor as visited\\n                    visited.add((new_r, new_c))\\n                    queue.append((new_r, new_c))\\n\\n        # sort the items by ranking, items contain tuple of (distance, price, row, col)\\n        items.sort()\\n\\n        # return top k elements\\n        return [[row, col] for (_, _, row, col) in items[:k]]\\n                    \\n```\\n\\n**\\nApproach 2: BFS + Max Heap**\\n\\nInstead of keeping all prices, we can only keep k elements with high rates. \\n\\nTime Complexity: `O(MNlogK)`\\nSpace Complexity: `O(MN + K)`\\n\\n```\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        queue = deque([])\\n        visited = set()\\n        max_heap = []\\n        level = 0\\n        R, C = len(grid), len(grid[0])\\n\\n        def hasHigherRank(rank1, rank2):\\n            return rank1 > rank2\\n\\n        def addValidPrice(row, col, dist):\\n            if pricing[0] <= grid[row][col] <= pricing[1]:\\n                curr_rank = [-dist, -grid[row][col], -row, -col]\\n\\n                if len(max_heap) < k:\\n                    heappush(max_heap, curr_rank)\\n                else:\\n                    if hasHigherRank(curr_rank, max_heap[0]):\\n                        heappop(max_heap)\\n                        heappush(max_heap, rank)\\n\\n        # initiate initial states\\n        queue.append(tuple(start))\\n        visited.add(tuple(start))\\n        addValidPrice(start[0], start[1], 0)\\n\\n        while queue:\\n            level += 1\\n\\n            for _ in range(len(queue)):\\n                row, col = queue.popleft()\\n\\n                for r, c in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    new_r, new_c = row + r, col + c\\n\\n                    if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or grid[new_r][new_c] == 0 or (new_r, new_c) in visited:\\n                        continue\\n\\n                    visited.add((new_r, new_c))\\n                    addValidPrice(new_r, new_c, level)\\n                    queue.append((new_r, new_c))\\n\\n        ans = []\\n\\n        while max_heap:\\n            _, _, row, col = heappop(max_heap)\\n            ans.append([-row, -col])\\n\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        # adds item in the cell (row, col) if it is in the pricing range\\n        def addValidItem(row, col, level):\\n            if pricing[0] <= grid[row][col] <= pricing[1]:\\n                items.append((level, grid[row][col], row, col))\\n\\n        level, items, visited, queue = 0, [], set(), deque([])\\n        R, C = len(grid), len(grid[0])\\n\\n        # initiate by adding the starting point to visited, queue, and items (if it is in priceing range)\\n        visited.add(tuple(start))\\n        queue.append(tuple(start))\\n        addValidItem(start[0], start[1], 0)\\n\\n        # explore all the neighbors [DOWN, UP, LEFT, RIGHT] level by level to keep the distance from the starting point\\n        while queue:\\n            level += 1\\n\\n            for _ in range(len(queue)):\\n                row, col = queue.popleft()\\n\\n                # exploring neighbors\\n                for r, c in [(0,1), (0,-1), (1,0), (-1,0)]:\\n                    new_r, new_c = row+r, col+c\\n\\n                    # check if neighbor cell is in bound, not visited previously, and not a wall\\n                    if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited or grid[new_r][new_c] == 0:\\n                        continue\\n\\n                    # add the neighbor cell if it is in the pricing range\\n                    addValidItem(new_r, new_c, level)\\n                    # mark this neighbor as visited\\n                    visited.add((new_r, new_c))\\n                    queue.append((new_r, new_c))\\n\\n        # sort the items by ranking, items contain tuple of (distance, price, row, col)\\n        items.sort()\\n\\n        # return top k elements\\n        return [[row, col] for (_, _, row, col) in items[:k]]\\n                    \\n```\n```\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        queue = deque([])\\n        visited = set()\\n        max_heap = []\\n        level = 0\\n        R, C = len(grid), len(grid[0])\\n\\n        def hasHigherRank(rank1, rank2):\\n            return rank1 > rank2\\n\\n        def addValidPrice(row, col, dist):\\n            if pricing[0] <= grid[row][col] <= pricing[1]:\\n                curr_rank = [-dist, -grid[row][col], -row, -col]\\n\\n                if len(max_heap) < k:\\n                    heappush(max_heap, curr_rank)\\n                else:\\n                    if hasHigherRank(curr_rank, max_heap[0]):\\n                        heappop(max_heap)\\n                        heappush(max_heap, rank)\\n\\n        # initiate initial states\\n        queue.append(tuple(start))\\n        visited.add(tuple(start))\\n        addValidPrice(start[0], start[1], 0)\\n\\n        while queue:\\n            level += 1\\n\\n            for _ in range(len(queue)):\\n                row, col = queue.popleft()\\n\\n                for r, c in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    new_r, new_c = row + r, col + c\\n\\n                    if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or grid[new_r][new_c] == 0 or (new_r, new_c) in visited:\\n                        continue\\n\\n                    visited.add((new_r, new_c))\\n                    addValidPrice(new_r, new_c, level)\\n                    queue.append((new_r, new_c))\\n\\n        ans = []\\n\\n        while max_heap:\\n            _, _, row, col = heappop(max_heap)\\n            ans.append([-row, -col])\\n\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284636,
                "title": "java-solution-bfs-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>(\\n            new Comparator<int[]>(){\\n                //distance, price, row, col\\n                public int compare(int[] a, int[] b){\\n                    return (\\n                        a[0] == b[0] ? (\\n                        a[1] == b[1] ? (\\n                        a[2] == b[2] ? (\\n                        a[3] - b[3]\\n                        ) : a[2] - b[2]\\n                        ) : a[1] - b[1]\\n                        ) : a[0]-b[0]  \\n                    );\\n                }\\n            }\\n        );\\n\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n\\n        Queue<int[]> queue = new ArrayDeque<int[]>();\\n\\n        queue.add(new int[]{0, grid[start[0]][start[1]], start[0], start[1]});\\n        grid[start[0]][start[1]] *= -1;\\n        while(!queue.isEmpty()){\\n            int[] arr = queue.remove();\\n            int distance = arr[0];\\n            int price = arr[1];\\n            int r = arr[2];\\n            int c = arr[3];\\n            if (price != 1 && pricing[0]<= price && price <= pricing[1]) {\\n                minHeap.add(arr);\\n            }\\n            for(int[] dir : dirs){\\n                int r_next = r + dir[0];\\n                int c_next = c + dir[1];\\n                if (canAdd(grid, r_next, c_next)){\\n                    queue.add(new int[]{distance+1, grid[r_next][c_next], r_next, c_next});\\n                    grid[r_next][c_next] *= -1;\\n                }\\n            }\\n\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList();\\n        while(!minHeap.isEmpty() && k>0){\\n            int[] arr = minHeap.remove();\\n            ArrayList<Integer> subAns = new ArrayList();\\n            subAns.add(arr[2]);\\n            subAns.add(arr[3]);\\n            ans.add(subAns);\\n            k--;\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n    private boolean canAdd(int[][] grid, int r, int c){\\n        return !(r<0 || r>=grid.length || c<0 || c>= grid[0].length || grid[r][c]<=0);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>(\\n            new Comparator<int[]>(){\\n                //distance, price, row, col\\n                public int compare(int[] a, int[] b){\\n                    return (\\n                        a[0] == b[0] ? (\\n                        a[1] == b[1] ? (\\n                        a[2] == b[2] ? (\\n                        a[3] - b[3]\\n                        ) : a[2] - b[2]\\n                        ) : a[1] - b[1]\\n                        ) : a[0]-b[0]  \\n                    );\\n                }\\n            }\\n        );\\n\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n\\n        Queue<int[]> queue = new ArrayDeque<int[]>();\\n\\n        queue.add(new int[]{0, grid[start[0]][start[1]], start[0], start[1]});\\n        grid[start[0]][start[1]] *= -1;\\n        while(!queue.isEmpty()){\\n            int[] arr = queue.remove();\\n            int distance = arr[0];\\n            int price = arr[1];\\n            int r = arr[2];\\n            int c = arr[3];\\n            if (price != 1 && pricing[0]<= price && price <= pricing[1]) {\\n                minHeap.add(arr);\\n            }\\n            for(int[] dir : dirs){\\n                int r_next = r + dir[0];\\n                int c_next = c + dir[1];\\n                if (canAdd(grid, r_next, c_next)){\\n                    queue.add(new int[]{distance+1, grid[r_next][c_next], r_next, c_next});\\n                    grid[r_next][c_next] *= -1;\\n                }\\n            }\\n\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList();\\n        while(!minHeap.isEmpty() && k>0){\\n            int[] arr = minHeap.remove();\\n            ArrayList<Integer> subAns = new ArrayList();\\n            subAns.add(arr[2]);\\n            subAns.add(arr[3]);\\n            ans.add(subAns);\\n            k--;\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n    private boolean canAdd(int[][] grid, int r, int c){\\n        return !(r<0 || r>=grid.length || c<0 || c>= grid[0].length || grid[r][c]<=0);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282609,
                "title": "c-easy-fast-bfs-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int drow[4]={0,1,0,-1};\\n        int dcol[4]={1,0,-1,0};\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq,res;\\n        int low=pricing[0],high=pricing[1];\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vis[start[0]][start[1]]=true;\\n        pq.push({0,{start[0],start[1]}});\\n        if(grid[start[0]][start[1]]>=low and grid[start[0]][start[1]]<=high)\\n        res.push({0,{start[0],start[1]}});\\n        while(!pq.empty())\\n        {\\n            auto curr=pq.top();\\n            pq.pop();\\n            int row=curr.second.first;\\n            int col=curr.second.second;\\n            int dist=curr.first;\\n            for(int i=0;i<4;i++)\\n            {\\n                int nrow=drow[i]+row;\\n                int ncol=dcol[i]+col;\\n                if((nrow>=0 and nrow<n) and (ncol>=0 and ncol<m) and (vis[nrow][ncol]==false) and (grid[nrow][ncol]!=0))\\n                {\\n                    if(grid[nrow][ncol]>=low and grid[nrow][ncol]<=high)\\n                    {\\n                        res.push({dist+1,{nrow,ncol}});\\n                    }\\n                    vis[nrow][ncol]=true;\\n                    pq.push({dist+1,{nrow,ncol}});\\n\\n                }\\n            }\\n        }\\n\\n        map<int,priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>> mp;\\n       \\n        while(!res.empty())\\n        {\\n            auto curr=res.top();\\n            res.pop();\\n            mp[curr.first].push({grid[curr.second.first][curr.second.second],{curr.second.first,curr.second.second}});\\n        }\\n\\n        vector<vector<int>> ans;\\n        auto it=mp.begin();\\n        while(it!=mp.end())\\n        {\\n            \\n            auto curr=it->second;\\n            bool flag=false;\\n            while(curr.empty()==false)\\n            {\\n                auto temp=curr.top();\\n                curr.pop();\\n                ans.push_back({temp.second.first,temp.second.second});\\n                if(ans.size()==k)\\n                {\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n            break;\\n            ++it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int drow[4]={0,1,0,-1};\\n        int dcol[4]={1,0,-1,0};\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq,res;\\n        int low=pricing[0],high=pricing[1];\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vis[start[0]][start[1]]=true;\\n        pq.push({0,{start[0],start[1]}});\\n        if(grid[start[0]][start[1]]>=low and grid[start[0]][start[1]]<=high)\\n        res.push({0,{start[0],start[1]}});\\n        while(!pq.empty())\\n        {\\n            auto curr=pq.top();\\n            pq.pop();\\n            int row=curr.second.first;\\n            int col=curr.second.second;\\n            int dist=curr.first;\\n            for(int i=0;i<4;i++)\\n            {\\n                int nrow=drow[i]+row;\\n                int ncol=dcol[i]+col;\\n                if((nrow>=0 and nrow<n) and (ncol>=0 and ncol<m) and (vis[nrow][ncol]==false) and (grid[nrow][ncol]!=0))\\n                {\\n                    if(grid[nrow][ncol]>=low and grid[nrow][ncol]<=high)\\n                    {\\n                        res.push({dist+1,{nrow,ncol}});\\n                    }\\n                    vis[nrow][ncol]=true;\\n                    pq.push({dist+1,{nrow,ncol}});\\n\\n                }\\n            }\\n        }\\n\\n        map<int,priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>> mp;\\n       \\n        while(!res.empty())\\n        {\\n            auto curr=res.top();\\n            res.pop();\\n            mp[curr.first].push({grid[curr.second.first][curr.second.second],{curr.second.first,curr.second.second}});\\n        }\\n\\n        vector<vector<int>> ans;\\n        auto it=mp.begin();\\n        while(it!=mp.end())\\n        {\\n            \\n            auto curr=it->second;\\n            bool flag=false;\\n            while(curr.empty()==false)\\n            {\\n                auto temp=curr.top();\\n                curr.pop();\\n                ans.push_back({temp.second.first,temp.second.second});\\n                if(ans.size()==k)\\n                {\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n            break;\\n            ++it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279921,
                "title": "1742-ms",
                "content": "```ruby\\ndef highest_ranked_k_items g, p, s, k\\n    pl, ph, q = p.first, p.last, []\\n    rz, r = 0, Hash.new { _1[_2] = [] }\\n    si, sj = *s\\n    mask = (1 << 20) - 1\\n    q << ((si << 20) | sj)\\n    p = g[si][sj]\\n    g[si][sj] = 0\\n    if pl <= p && p <= ph\\n        return [s] if k == 1\\n        r[p] << q.last\\n        rz += 1\\n    end\\n    m, n = g.size, g[0].size\\n    c, d = 0, [[-1, 0], [1, 0], [0, -1], [0, 1]]\\n    while rz < k && !q.empty? && c += 1\\n        q.size.times do\\n            i, j = (x = q.shift) >> 20, x & mask\\n            d.each do | (y, x) |\\n                y += i; x += j\\n                if 0 <= y && y < m && 0 <= x && x < n &&\\n                   (p = g[y][x]) > 0\\n                    g[y][x] = 0\\n                    q << (yx = (y << 20) | x)\\n                    if pl <= p && p <= ph\\n                        r[(c << 20) | p] << yx\\n                        rz += 1\\n                    end\\n                end\\n            end\\n        end\\n    end\\n    return [] if r.empty?\\n    r = r.sort_by(&:first)\\n    while rz - (z = r.last.last.size) >= k\\n        r.pop; rz -= z\\n    end\\n    v = r.last.last.sort!\\n    v.pop while (rz -= 1) >= k\\n    r.flat_map do | (_, v) |\\n        v.sort!.map! { [_1 >> 20, _1 & mask] }\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef highest_ranked_k_items g, p, s, k\\n    pl, ph, q = p.first, p.last, []\\n    rz, r = 0, Hash.new { _1[_2] = [] }\\n    si, sj = *s\\n    mask = (1 << 20) - 1\\n    q << ((si << 20) | sj)\\n    p = g[si][sj]\\n    g[si][sj] = 0\\n    if pl <= p && p <= ph\\n        return [s] if k == 1\\n        r[p] << q.last\\n        rz += 1\\n    end\\n    m, n = g.size, g[0].size\\n    c, d = 0, [[-1, 0], [1, 0], [0, -1], [0, 1]]\\n    while rz < k && !q.empty? && c += 1\\n        q.size.times do\\n            i, j = (x = q.shift) >> 20, x & mask\\n            d.each do | (y, x) |\\n                y += i; x += j\\n                if 0 <= y && y < m && 0 <= x && x < n &&\\n                   (p = g[y][x]) > 0\\n                    g[y][x] = 0\\n                    q << (yx = (y << 20) | x)\\n                    if pl <= p && p <= ph\\n                        r[(c << 20) | p] << yx\\n                        rz += 1\\n                    end\\n                end\\n            end\\n        end\\n    end\\n    return [] if r.empty?\\n    r = r.sort_by(&:first)\\n    while rz - (z = r.last.last.size) >= k\\n        r.pop; rz -= z\\n    end\\n    v = r.last.last.sort!\\n    v.pop while (rz -= 1) >= k\\n    r.flat_map do | (_, v) |\\n        v.sort!.map! { [_1 >> 20, _1 & mask] }\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3220592,
                "title": "java-priorityqueue-with-custom-class",
                "content": "##### We can create an actual class to use for the PriorityQueue & use Comparable interface. This makes it easier to understand than a bunch of ternary operations. The compareTo function goes in the order of the problem description.\\n\\n##### compareTo function a return of 1 represents \"this\" object\\'s return and -1 is the other object\\'s return. We add elements to PriorityQueue based on descending order \"b.compareTo(a)\" to indicate the correct ordering.\\n\\n# Code\\n```\\nclass RankedItem implements Comparable<RankedItem>{\\n    int distance;\\n    int price;\\n    int row;\\n    int col;\\n\\n    public RankedItem(int distance, int price, int row, int col){\\n        this.distance = distance;\\n        this.price = price;\\n        this.row = row;\\n        this.col = col;\\n    }\\n    @Override\\n    public int compareTo(RankedItem o){\\n        if(this.distance < o.distance) return 1;\\n        else if(this.distance > o.distance) return -1;\\n        \\n        if(this.price < o.price) return 1;\\n        else if(this.price > o.price) return -1;\\n\\n        if(this.row < o.row) return 1;\\n        else if(this.row > o.row) return -1;\\n\\n        if(this.col < o.col) return 1;\\n        else if(this.col > o.col) return -1;\\n\\n        return 0;\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int[][] dirs = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };\\n        int x = start[0];\\n        int y = start[1];\\n        int low = pricing[0];\\n        int high = pricing[1];\\n        List<List<Integer>> res = new ArrayList<>();\\n        PriorityQueue<RankedItem> pq = new PriorityQueue<>((a, b) -> b.compareTo(a));\\n        RankedItem ri = new RankedItem(0, grid[x][y], x, y);\\n        pq.add(ri);\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        visited[x][y] = true;\\n        while(!pq.isEmpty()){\\n            if(res.size() == k) return res;\\n            RankedItem cri = pq.remove();\\n            int distance = cri.distance;\\n            int price = cri.price;\\n            int row = cri.row;\\n            int col = cri.col;\\n            if(price >= low && price <= high)\\n            {\\n                List<Integer> cur = new ArrayList<>();\\n                cur.add(row);\\n                cur.add(col);\\n                res.add(cur);\\n            }\\n            for(int[] dir : dirs){\\n                int nextX = row + dir[0];\\n                int nextY = col + dir[1];\\n                if(nextX >= 0 && nextX < grid.length && nextY >= 0 && nextY < grid[0].length && grid[nextX][nextY] != 0){\\n                    if(visited[nextX][nextY]) continue;\\n                    visited[nextX][nextY] = true;\\n                    RankedItem nextri = new RankedItem(distance + 1, grid[nextX][nextY], nextX, nextY);\\n                    pq.add(nextri);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RankedItem implements Comparable<RankedItem>{\\n    int distance;\\n    int price;\\n    int row;\\n    int col;\\n\\n    public RankedItem(int distance, int price, int row, int col){\\n        this.distance = distance;\\n        this.price = price;\\n        this.row = row;\\n        this.col = col;\\n    }\\n    @Override\\n    public int compareTo(RankedItem o){\\n        if(this.distance < o.distance) return 1;\\n        else if(this.distance > o.distance) return -1;\\n        \\n        if(this.price < o.price) return 1;\\n        else if(this.price > o.price) return -1;\\n\\n        if(this.row < o.row) return 1;\\n        else if(this.row > o.row) return -1;\\n\\n        if(this.col < o.col) return 1;\\n        else if(this.col > o.col) return -1;\\n\\n        return 0;\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int[][] dirs = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };\\n        int x = start[0];\\n        int y = start[1];\\n        int low = pricing[0];\\n        int high = pricing[1];\\n        List<List<Integer>> res = new ArrayList<>();\\n        PriorityQueue<RankedItem> pq = new PriorityQueue<>((a, b) -> b.compareTo(a));\\n        RankedItem ri = new RankedItem(0, grid[x][y], x, y);\\n        pq.add(ri);\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        visited[x][y] = true;\\n        while(!pq.isEmpty()){\\n            if(res.size() == k) return res;\\n            RankedItem cri = pq.remove();\\n            int distance = cri.distance;\\n            int price = cri.price;\\n            int row = cri.row;\\n            int col = cri.col;\\n            if(price >= low && price <= high)\\n            {\\n                List<Integer> cur = new ArrayList<>();\\n                cur.add(row);\\n                cur.add(col);\\n                res.add(cur);\\n            }\\n            for(int[] dir : dirs){\\n                int nextX = row + dir[0];\\n                int nextY = col + dir[1];\\n                if(nextX >= 0 && nextX < grid.length && nextY >= 0 && nextY < grid[0].length && grid[nextX][nextY] != 0){\\n                    if(visited[nextX][nextY]) continue;\\n                    visited[nextX][nextY] = true;\\n                    RankedItem nextri = new RankedItem(distance + 1, grid[nextX][nextY], nextX, nextY);\\n                    pq.add(nextri);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213079,
                "title": "bfs-sorting",
                "content": "# Intuition\\nSimple Bfs with some edge cases can do the work\\n\\n# Approach\\nBFS+sorting\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     bool isvalid(int x, int y, int m, int n)\\n    {\\n    if (x < 0 or y < 0 or x >= m or y >= n)\\n       return 0;\\n    return 1;\\n    }\\n   \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> ans;\\n        queue<pair<pair<int,int>,int>> q;\\n        vector<vector<int>> dir={{0,1},{0,-1},{1,0},{-1,0}};\\n        q.push({{start[0],start[1]},0});\\n        if (grid[start[0]][start[1]]>=pricing[0] && grid[start[0]][start[1]]<=pricing[1])\\n           ans.push_back({start[0],start[1],grid[start[0]][start[1]],0});\\n        grid[start[0]][start[1]]=0;\\n        \\n\\n        while (!q.empty())\\n        {\\n            int x=q.front().first.first;\\n            int y=q.front().first.second;\\n            int dist=q.front().second;\\n            q.pop();\\n            for (int i=0;i<4;i++)\\n            {\\n                int new_x=x+dir[i][0];\\n                int new_y=y+dir[i][1];\\n\\n                if (isvalid(new_x,new_y,m,n) && grid[new_x][new_y]!=0)\\n                {\\n                    q.push({{new_x,new_y},dist+1});\\n                    ans.push_back({new_x,new_y, grid[new_x][new_y],dist+1});\\n                    grid[new_x][new_y]=0;\\n                }\\n            }\\n        }\\n       \\n        vector<vector<int>> res; \\n        for (int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i][2]>=pricing[0] && ans[i][2]<=pricing[1])\\n            {\\n                vector<int> v = {ans[i][0],ans[i][1],ans[i][2],ans[i][3]};\\n                res.push_back(v);\\n            }\\n        }\\n        sort(begin(res), end(res), [&](vector<int>&a, vector<int>&b)\\n        {\\n      if(a[3] == b[3])\\n      {\\n        if(a[2] == b[2])\\n        {\\n          if(a[0] == b[0]) \\n          {\\n            return a[1] < b[1];\\n          }\\n          return a[0] < b[0];\\n        }\\n        return a[2] < b[2];\\n      }\\n      return a[3] < b[3];\\n    });\\n\\n    vector<vector<int>> answer;\\n\\n    for(int i = 0; i < res.size() && i<k; i++)\\n      answer.push_back({res[i][0], res[i][1]});\\n    return answer;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isvalid(int x, int y, int m, int n)\\n    {\\n    if (x < 0 or y < 0 or x >= m or y >= n)\\n       return 0;\\n    return 1;\\n    }\\n   \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> ans;\\n        queue<pair<pair<int,int>,int>> q;\\n        vector<vector<int>> dir={{0,1},{0,-1},{1,0},{-1,0}};\\n        q.push({{start[0],start[1]},0});\\n        if (grid[start[0]][start[1]]>=pricing[0] && grid[start[0]][start[1]]<=pricing[1])\\n           ans.push_back({start[0],start[1],grid[start[0]][start[1]],0});\\n        grid[start[0]][start[1]]=0;\\n        \\n\\n        while (!q.empty())\\n        {\\n            int x=q.front().first.first;\\n            int y=q.front().first.second;\\n            int dist=q.front().second;\\n            q.pop();\\n            for (int i=0;i<4;i++)\\n            {\\n                int new_x=x+dir[i][0];\\n                int new_y=y+dir[i][1];\\n\\n                if (isvalid(new_x,new_y,m,n) && grid[new_x][new_y]!=0)\\n                {\\n                    q.push({{new_x,new_y},dist+1});\\n                    ans.push_back({new_x,new_y, grid[new_x][new_y],dist+1});\\n                    grid[new_x][new_y]=0;\\n                }\\n            }\\n        }\\n       \\n        vector<vector<int>> res; \\n        for (int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i][2]>=pricing[0] && ans[i][2]<=pricing[1])\\n            {\\n                vector<int> v = {ans[i][0],ans[i][1],ans[i][2],ans[i][3]};\\n                res.push_back(v);\\n            }\\n        }\\n        sort(begin(res), end(res), [&](vector<int>&a, vector<int>&b)\\n        {\\n      if(a[3] == b[3])\\n      {\\n        if(a[2] == b[2])\\n        {\\n          if(a[0] == b[0]) \\n          {\\n            return a[1] < b[1];\\n          }\\n          return a[0] < b[0];\\n        }\\n        return a[2] < b[2];\\n      }\\n      return a[3] < b[3];\\n    });\\n\\n    vector<vector<int>> answer;\\n\\n    for(int i = 0; i < res.size() && i<k; i++)\\n      answer.push_back({res[i][0], res[i][1]});\\n    return answer;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169928,
                "title": "python-bfs-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        queue=[(start[0],start[1],0)]\\n        heap1=[]\\n        list1=[]\\n        visit=set()\\n        while queue:\\n            \\n            i,j,dist=queue.pop(0)\\n\\n            if (i,j) in visit:\\n                continue\\n            visit.add((i,j))\\n            if i>=0 and j>=0 and i<len(grid) and j<len(grid[0]):\\n\\n                if grid[i][j]!=1 and grid[i][j]!=0 and grid[i][j]>=pricing[0] and grid[i][j]<=pricing[1]:\\n                    list1.append([dist,grid[i][j],i,j])\\n                    heapq.heappush(heap1,[dist,grid[i][j],i,j])\\n                if grid[i][j]!=0:\\n                    queue.append((i-1,j,dist+1))\\n                    queue.append((i+1,j,dist+1))\\n                    queue.append((i,j-1,dist+1))\\n                    queue.append((i,j+1,dist+1))\\n        z=0\\n        result=[]\\n        while heap1 and z<k:\\n            check=heapq.heappop(heap1)\\n            result.append([check[2],check[3]])\\n            z+=1\\n        return result\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        queue=[(start[0],start[1],0)]\\n        heap1=[]\\n        list1=[]\\n        visit=set()\\n        while queue:\\n            \\n            i,j,dist=queue.pop(0)\\n\\n            if (i,j) in visit:\\n                continue\\n            visit.add((i,j))\\n            if i>=0 and j>=0 and i<len(grid) and j<len(grid[0]):\\n\\n                if grid[i][j]!=1 and grid[i][j]!=0 and grid[i][j]>=pricing[0] and grid[i][j]<=pricing[1]:\\n                    list1.append([dist,grid[i][j],i,j])\\n                    heapq.heappush(heap1,[dist,grid[i][j],i,j])\\n                if grid[i][j]!=0:\\n                    queue.append((i-1,j,dist+1))\\n                    queue.append((i+1,j,dist+1))\\n                    queue.append((i,j-1,dist+1))\\n                    queue.append((i,j+1,dist+1))\\n        z=0\\n        result=[]\\n        while heap1 and z<k:\\n            check=heapq.heappop(heap1)\\n            result.append([check[2],check[3]])\\n            z+=1\\n        return result\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169603,
                "title": "golang-easy-to-read-dfs-solution-without-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc highestRankedKItems(grid [][]int, pricing []int, start []int, k int) [][]int {\\n    type p struct{i, j int}\\n    dirs := []p{\\n        { -1, 0},\\n        {1, 0},\\n        {0, -1},\\n        {0, 1},\\n    }\\n    q := []p{\\n        {\\n            start[0],\\n            start[1],\\n        },\\n    }\\n    type Item struct {\\n        p p\\n        distance int\\n    }\\n    res := make([]Item, 0)\\n    s := grid[q[0].i][q[0].j] \\n    if s >= pricing[0] && s <= pricing[1] {\\n        res = append(res, Item{\\n                            q[0],\\n                            0,\\n        })\\n    }\\n    visited := make(map[p]struct{})\\n    visited[q[0]] = struct{}{}\\n    distance := 1\\n    for len(q) > 0 {\\n        n := len(q)\\n        for n > 0 {\\n            n--\\n            c := q[0]\\n            q = q[1:]\\n              \\n\\n            for _, d := range dirs {\\n                i := c.i + d.i\\n                j := c.j + d.j\\n                if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[i])  {\\n                    continue\\n                }\\n                if _, ok := visited[p{i, j}]; ok {\\n                    continue\\n                }\\n                if grid[i][j] == 0 {\\n                    continue\\n                }\\n                visited[p{i, j}] = struct{}{}\\n                q = append(q, p{i, j})\\n                if grid[i][j] >= pricing[0] && grid[i][j] <= pricing[1] {\\n                  res = append(res, Item{\\n                        p{i, j},\\n                        distance,\\n                    })\\n                }\\n            }\\n        }\\n        distance++\\n    }\\n    sort.Slice(res, func(i, j int) bool {\\n        a := res[i]\\n        b := res[j]\\n        if a.distance != b.distance {\\n            return a.distance < b.distance\\n        }\\n\\n        if grid[a.p.i][a.p.j] != grid[b.p.i][b.p.j] {\\n            return grid[a.p.i][a.p.j] < grid[b.p.i][b.p.j]\\n        }\\n        if a.p.i !=  b.p.i {\\n            return a.p.i < b.p.i\\n        }\\n        if a.p.j != b.p.j {\\n            return a.p.j < b.p.j\\n        }\\n        return false\\n    })\\n    rr := make([][]int, 0)\\n    for _, item := range res[:min(k, len(res))] {\\n        rr = append(rr, []int{item.p.i, item.p.j})\\n    }\\n    return rr\\n}\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc highestRankedKItems(grid [][]int, pricing []int, start []int, k int) [][]int {\\n    type p struct{i, j int}\\n    dirs := []p{\\n        { -1, 0},\\n        {1, 0},\\n        {0, -1},\\n        {0, 1},\\n    }\\n    q := []p{\\n        {\\n            start[0],\\n            start[1],\\n        },\\n    }\\n    type Item struct {\\n        p p\\n        distance int\\n    }\\n    res := make([]Item, 0)\\n    s := grid[q[0].i][q[0].j] \\n    if s >= pricing[0] && s <= pricing[1] {\\n        res = append(res, Item{\\n                            q[0],\\n                            0,\\n        })\\n    }\\n    visited := make(map[p]struct{})\\n    visited[q[0]] = struct{}{}\\n    distance := 1\\n    for len(q) > 0 {\\n        n := len(q)\\n        for n > 0 {\\n            n--\\n            c := q[0]\\n            q = q[1:]\\n              \\n\\n            for _, d := range dirs {\\n                i := c.i + d.i\\n                j := c.j + d.j\\n                if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[i])  {\\n                    continue\\n                }\\n                if _, ok := visited[p{i, j}]; ok {\\n                    continue\\n                }\\n                if grid[i][j] == 0 {\\n                    continue\\n                }\\n                visited[p{i, j}] = struct{}{}\\n                q = append(q, p{i, j})\\n                if grid[i][j] >= pricing[0] && grid[i][j] <= pricing[1] {\\n                  res = append(res, Item{\\n                        p{i, j},\\n                        distance,\\n                    })\\n                }\\n            }\\n        }\\n        distance++\\n    }\\n    sort.Slice(res, func(i, j int) bool {\\n        a := res[i]\\n        b := res[j]\\n        if a.distance != b.distance {\\n            return a.distance < b.distance\\n        }\\n\\n        if grid[a.p.i][a.p.j] != grid[b.p.i][b.p.j] {\\n            return grid[a.p.i][a.p.j] < grid[b.p.i][b.p.j]\\n        }\\n        if a.p.i !=  b.p.i {\\n            return a.p.i < b.p.i\\n        }\\n        if a.p.j != b.p.j {\\n            return a.p.j < b.p.j\\n        }\\n        return false\\n    })\\n    rr := make([][]int, 0)\\n    for _, item := range res[:min(k, len(res))] {\\n        rr = append(rr, []int{item.p.i, item.p.j})\\n    }\\n    return rr\\n}\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3169584,
                "title": "bfs-priority-queue-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        int i;\\n        int j;\\n        int price;\\n        int dist;\\n        \\n        public Pair(int i , int j , int price , int dist){\\n            this.i = i;\\n            this.j = j;\\n            this.price = price;\\n            this.dist = dist;\\n        }\\n\\n        public int compareTo(Pair p){\\n            if(p.dist != this.dist){\\n                return this.dist - p.dist;\\n            }\\n            else if(p.price != this.price){\\n                return this.price - p.price;\\n            }\\n            else if(p.i != this.i){\\n                return this.i - p.i;\\n            }\\n            else{\\n                return this.j - p.j;\\n            }\\n        }\\n    }\\n\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        \\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        Queue<Pair> que = new ArrayDeque<>();\\n        que.offer(new Pair(start[0],start[1],grid[start[0]][start[1]],0));\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n    \\n        if(grid[start[0]][start[1]] > 1 && grid[start[0]][start[1]] >= pricing[0] &&\\n        grid[start[0]][start[1]] <= pricing[1]){ \\n            pq.offer(new Pair(start[0],start[1],grid[start[0]][start[1]],0));\\n        }\\n\\n        grid[start[0]][start[1]] = 0;\\n        int[][] dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\n        while(!que.isEmpty()){\\n            int size = que.size();\\n            for(int s = 0 ; s < size ; s++){\\n                Pair temp = que.poll();\\n                for(int[] d : dir){\\n                    int i = temp.i + d[0];\\n                    int j = temp.j + d[1];\\n                    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) continue;\\n                    if(grid[i][j] >= pricing[0] && grid[i][j] <= pricing[1]){\\n                        pq.add(new Pair(i,j,grid[i][j],temp.dist+1));\\n                    }\\n                     grid[i][j] = 0;\\n                     que.offer(new Pair(i,j,grid[i][j],temp.dist+1));\\n                }\\n            }\\n        }\\n        \\n        while(!pq.isEmpty() && k-- > 0){\\n            Pair temp = pq.poll();\\n            res.add(new ArrayList<>(Arrays.asList(temp.i,temp.j)));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        int i;\\n        int j;\\n        int price;\\n        int dist;\\n        \\n        public Pair(int i , int j , int price , int dist){\\n            this.i = i;\\n            this.j = j;\\n            this.price = price;\\n            this.dist = dist;\\n        }\\n\\n        public int compareTo(Pair p){\\n            if(p.dist != this.dist){\\n                return this.dist - p.dist;\\n            }\\n            else if(p.price != this.price){\\n                return this.price - p.price;\\n            }\\n            else if(p.i != this.i){\\n                return this.i - p.i;\\n            }\\n            else{\\n                return this.j - p.j;\\n            }\\n        }\\n    }\\n\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        \\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        Queue<Pair> que = new ArrayDeque<>();\\n        que.offer(new Pair(start[0],start[1],grid[start[0]][start[1]],0));\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n    \\n        if(grid[start[0]][start[1]] > 1 && grid[start[0]][start[1]] >= pricing[0] &&\\n        grid[start[0]][start[1]] <= pricing[1]){ \\n            pq.offer(new Pair(start[0],start[1],grid[start[0]][start[1]],0));\\n        }\\n\\n        grid[start[0]][start[1]] = 0;\\n        int[][] dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\n        while(!que.isEmpty()){\\n            int size = que.size();\\n            for(int s = 0 ; s < size ; s++){\\n                Pair temp = que.poll();\\n                for(int[] d : dir){\\n                    int i = temp.i + d[0];\\n                    int j = temp.j + d[1];\\n                    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) continue;\\n                    if(grid[i][j] >= pricing[0] && grid[i][j] <= pricing[1]){\\n                        pq.add(new Pair(i,j,grid[i][j],temp.dist+1));\\n                    }\\n                     grid[i][j] = 0;\\n                     que.offer(new Pair(i,j,grid[i][j],temp.dist+1));\\n                }\\n            }\\n        }\\n        \\n        while(!pq.isEmpty() && k-- > 0){\\n            Pair temp = pq.poll();\\n            res.add(new ArrayList<>(Arrays.asList(temp.i,temp.j)));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167541,
                "title": "java-priority-queue-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] p, int[] start, int k) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        boolean visited[][]=new boolean[grid.length][grid[0].length];\\n        visited[start[0]][start[1]]=true;\\n        Queue<int[]> pq=new PriorityQueue<>((a,b)->{\\n            if(a[2]!=b[2])\\n                return a[2]-b[2];\\n            if(a[3]!=b[3])\\n                return a[3]-b[3];\\n            if(a[0]!=b[0])\\n                return a[0]-b[0];\\n            return a[1]-b[1];\\n        });\\n        pq.offer(new int[]{start[0],start[1],0,grid[start[0]][start[1]]}); //row,col,distance,price\\n        int[][] dir=new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n\\n        while(!pq.isEmpty() && k!=0){\\n            int[] x=pq.poll();\\n\\n            //check if its a valid product\\n            if(x[3]>=p[0] && x[3]<=p[1]){\\n                res.add(new ArrayList<Integer>(Arrays.asList(x[0],x[1])));\\n                k--;\\n            }\\n            \\n            //add neighbours\\n            for(int[] d:dir){\\n                int i=x[0]+d[0];\\n                int j=x[1]+d[1];\\n                if(i>=0 && j>=0 && i<grid.length && j<grid[0].length && !visited[i][j] && grid[i][j]!=0){\\n                    visited[i][j]=true;\\n                    pq.offer(new int[]{i,j,x[2]+1,grid[i][j]});\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] p, int[] start, int k) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        boolean visited[][]=new boolean[grid.length][grid[0].length];\\n        visited[start[0]][start[1]]=true;\\n        Queue<int[]> pq=new PriorityQueue<>((a,b)->{\\n            if(a[2]!=b[2])\\n                return a[2]-b[2];\\n            if(a[3]!=b[3])\\n                return a[3]-b[3];\\n            if(a[0]!=b[0])\\n                return a[0]-b[0];\\n            return a[1]-b[1];\\n        });\\n        pq.offer(new int[]{start[0],start[1],0,grid[start[0]][start[1]]}); //row,col,distance,price\\n        int[][] dir=new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n\\n        while(!pq.isEmpty() && k!=0){\\n            int[] x=pq.poll();\\n\\n            //check if its a valid product\\n            if(x[3]>=p[0] && x[3]<=p[1]){\\n                res.add(new ArrayList<Integer>(Arrays.asList(x[0],x[1])));\\n                k--;\\n            }\\n            \\n            //add neighbours\\n            for(int[] d:dir){\\n                int i=x[0]+d[0];\\n                int j=x[1]+d[1];\\n                if(i>=0 && j>=0 && i<grid.length && j<grid[0].length && !visited[i][j] && grid[i][j]!=0){\\n                    visited[i][j]=true;\\n                    pq.offer(new int[]{i,j,x[2]+1,grid[i][j]});\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167078,
                "title": "c-easy",
                "content": "# Intuition\\nGRAPH\\n# Approach\\nBFS AND HEAP\\n\\n# Complexity\\n- Time complexity\\nO(n*m)+O(log(n))\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\n\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>> &grid, vector<int> &pricing, vector<int> &start, int k)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n\\n    int rr[] = {-1, 0, 1, 0};\\n    int cc[] = {0, -1, 0, 1};\\n\\n    queue<pair<int, pair<int, int>>> q;\\n    priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    vector<vector<int>> ans;\\n\\n    q.push({0, {start[0], start[1]}});\\n    visited[start[0]][start[1]] = 1;\\n    if (grid[start[0]][start[1]] >= pricing[0] and grid[start[0]][start[1]] <= pricing[1])\\n    {\\n        pq.push({{0, grid[start[0]][start[1]]}, {start[0], start[1]}});\\n    }\\n\\n    while (!q.empty())\\n    {\\n        int dis = q.front().first;\\n        int row = q.front().second.first;\\n        int col = q.front().second.second;\\n        q.pop();\\n\\n        // if (pq.size() == k)\\n        // {\\n        //     break;\\n        // }\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            int r = row + rr[i];\\n            int c = col + cc[i];\\n\\n            if (r < n and r >= 0 and c >= 0 and c < m and !visited[r][c] and grid[r][c] != 0)\\n            {\\n                q.push({dis + 1, {r, c}});\\n                visited[r][c] = 1;\\n                if (grid[r][c] >= pricing[0] and grid[r][c] <= pricing[1])\\n                {\\n                    pq.push({{dis + 1, grid[r][c]}, {r, c}});\\n                }\\n            }\\n        }\\n    }\\n\\n    while (!pq.empty() and k--)\\n    {\\n        int x = pq.top().second.first;\\n        int y = pq.top().second.second;\\n        pq.pop();\\n\\n        ans.push_back({x, y});\\n    }\\n\\n    return ans;\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>> &grid, vector<int> &pricing, vector<int> &start, int k)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n\\n    int rr[] = {-1, 0, 1, 0};\\n    int cc[] = {0, -1, 0, 1};\\n\\n    queue<pair<int, pair<int, int>>> q;\\n    priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    vector<vector<int>> ans;\\n\\n    q.push({0, {start[0], start[1]}});\\n    visited[start[0]][start[1]] = 1;\\n    if (grid[start[0]][start[1]] >= pricing[0] and grid[start[0]][start[1]] <= pricing[1])\\n    {\\n        pq.push({{0, grid[start[0]][start[1]]}, {start[0], start[1]}});\\n    }\\n\\n    while (!q.empty())\\n    {\\n        int dis = q.front().first;\\n        int row = q.front().second.first;\\n        int col = q.front().second.second;\\n        q.pop();\\n\\n        // if (pq.size() == k)\\n        // {\\n        //     break;\\n        // }\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            int r = row + rr[i];\\n            int c = col + cc[i];\\n\\n            if (r < n and r >= 0 and c >= 0 and c < m and !visited[r][c] and grid[r][c] != 0)\\n            {\\n                q.push({dis + 1, {r, c}});\\n                visited[r][c] = 1;\\n                if (grid[r][c] >= pricing[0] and grid[r][c] <= pricing[1])\\n                {\\n                    pq.push({{dis + 1, grid[r][c]}, {r, c}});\\n                }\\n            }\\n        }\\n    }\\n\\n    while (!pq.empty() and k--)\\n    {\\n        int x = pq.top().second.first;\\n        int y = pq.top().second.second;\\n        pq.pop();\\n\\n        ans.push_back({x, y});\\n    }\\n\\n    return ans;\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3166883,
                "title": "swift-bfs-and-sort-results",
                "content": "# Intuition\\nBFS. **Read problem carefully I was stuck for a good while because I forgot you cant cross 0\\'s**\\n\\n# Approach\\nBFS\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func highestRankedKItems(_ grid: [[Int]], _ pricing: [Int], _ start: [Int], _ k: Int) -> [[Int]] {\\n        var queue = [[Int]]()\\n        var visited = Set<[Int]>()\\n        var rows = grid.count \\n        var cols = grid[0].count\\n        var res = [[Int]]()\\n        var directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n        queue.append([0, grid[start[0]][start[1]], start[0], start[1]])\\n        visited.insert([start[0],start[1]])\\n        while queue.count > 0 {\\n            let item = queue.removeFirst()\\n            let distance = item[0]\\n            let price = item[1]\\n            let x = item[2]\\n            let y = item[3]\\n            if price >= pricing[0] && price <= pricing[1] {\\n                res.append([distance, price, x, y])\\n            }\\n            for dir in directions {\\n                let newX = dir[0] + x \\n                let newY = dir[1] + y\\n                if newX >= 0 && newX < rows && newY >= 0 && newY < cols && !visited.contains([newX,newY]) && grid[newX][newY] != 0 {\\n                    queue.append([distance + 1, grid[newX][newY], newX, newY])\\n                    visited.insert([newX,newY])\\n                }\\n            }\\n        }\\n        res.sort { \\n            if $0[0] != $1[0] {\\n                return $0[0] < $1[0]\\n            } \\n            else if $0[1] != $1[1] {\\n                return $0[1] < $1[1]\\n            }   \\n            else if $0[2] != $1[2] {\\n                return $0[2] < $1[2]\\n            } \\n            else {\\n                return $0[3] < $1[3]\\n            }\\n        }\\n        return k >= res.count ? res.map { $0.suffix(2) } : res[0..<k].map{ $0.suffix(2) }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func highestRankedKItems(_ grid: [[Int]], _ pricing: [Int], _ start: [Int], _ k: Int) -> [[Int]] {\\n        var queue = [[Int]]()\\n        var visited = Set<[Int]>()\\n        var rows = grid.count \\n        var cols = grid[0].count\\n        var res = [[Int]]()\\n        var directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n        queue.append([0, grid[start[0]][start[1]], start[0], start[1]])\\n        visited.insert([start[0],start[1]])\\n        while queue.count > 0 {\\n            let item = queue.removeFirst()\\n            let distance = item[0]\\n            let price = item[1]\\n            let x = item[2]\\n            let y = item[3]\\n            if price >= pricing[0] && price <= pricing[1] {\\n                res.append([distance, price, x, y])\\n            }\\n            for dir in directions {\\n                let newX = dir[0] + x \\n                let newY = dir[1] + y\\n                if newX >= 0 && newX < rows && newY >= 0 && newY < cols && !visited.contains([newX,newY]) && grid[newX][newY] != 0 {\\n                    queue.append([distance + 1, grid[newX][newY], newX, newY])\\n                    visited.insert([newX,newY])\\n                }\\n            }\\n        }\\n        res.sort { \\n            if $0[0] != $1[0] {\\n                return $0[0] < $1[0]\\n            } \\n            else if $0[1] != $1[1] {\\n                return $0[1] < $1[1]\\n            }   \\n            else if $0[2] != $1[2] {\\n                return $0[2] < $1[2]\\n            } \\n            else {\\n                return $0[3] < $1[3]\\n            }\\n        }\\n        return k >= res.count ? res.map { $0.suffix(2) } : res[0..<k].map{ $0.suffix(2) }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141281,
                "title": "python-bfs-with-a-result-array",
                "content": "```python\\nclass Solution:\\n\\tdef highestRankedKItems(self, grid: list[list[int]], pricing: list[int], start: list[int], k: int) -> list[list[int]]:\\n\\t\\tROWS, COLS = len(grid), len(grid[0])\\n\\t\\tqueue = deque()\\n\\t\\tseen = set()\\n\\t\\tres = []\\n\\t\\tqueue.append((0, grid[start[0]][start[1]], start[0], start[1]))\\n\\t\\tseen.add((start[0], start[1]))\\n\\t\\tdirections = [[-1,0], [1,0],[0,-1],[0,1]]\\n\\t\\t\\n\\t\\twhile queue:\\n\\t\\t\\tdist, price, i, j = queue.popleft()\\n\\t\\t\\t# add to result only if its greater than 1 and within range.\\n\\t\\t\\t# else its only allowed to move but not include in teh result\\n\\t\\t\\tif pricing[0] <= price <= pricing[1]:\\n\\t\\t\\t\\tres.append((dist, price, i, j))\\n\\n\\t\\t\\tfor rd, cd in directions:\\n\\t\\t\\t\\trr, cc = i + rd, j + cd\\n\\t\\t\\t\\t# check the bounding condition and if its already seen and if its not 0.\\n\\t\\t\\t\\tif rr >= 0 and rr < ROWS  and cc >= 0 and cc < COLS and grid[rr][cc] != 0 and (rr,cc) not in seen:\\n\\t\\t\\t\\t\\t# grid_val = grid[rr][cc]\\n\\t\\t\\t\\t\\tseen.add((rr,cc))\\n\\t\\t\\t\\t\\tqueue.append((dist + 1, grid[rr][cc], rr, cc))\\n\\t\\tres = sorted(res)\\n\\t\\treturn [[i, j] for _, _, i, j in res[:k]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n\\tdef highestRankedKItems(self, grid: list[list[int]], pricing: list[int], start: list[int], k: int) -> list[list[int]]:\\n\\t\\tROWS, COLS = len(grid), len(grid[0])\\n\\t\\tqueue = deque()\\n\\t\\tseen = set()\\n\\t\\tres = []\\n\\t\\tqueue.append((0, grid[start[0]][start[1]], start[0], start[1]))\\n\\t\\tseen.add((start[0], start[1]))\\n\\t\\tdirections = [[-1,0], [1,0],[0,-1],[0,1]]\\n\\t\\t\\n\\t\\twhile queue:\\n\\t\\t\\tdist, price, i, j = queue.popleft()\\n\\t\\t\\t# add to result only if its greater than 1 and within range.\\n\\t\\t\\t# else its only allowed to move but not include in teh result\\n\\t\\t\\tif pricing[0] <= price <= pricing[1]:\\n\\t\\t\\t\\tres.append((dist, price, i, j))\\n\\n\\t\\t\\tfor rd, cd in directions:\\n\\t\\t\\t\\trr, cc = i + rd, j + cd\\n\\t\\t\\t\\t# check the bounding condition and if its already seen and if its not 0.\\n\\t\\t\\t\\tif rr >= 0 and rr < ROWS  and cc >= 0 and cc < COLS and grid[rr][cc] != 0 and (rr,cc) not in seen:\\n\\t\\t\\t\\t\\t# grid_val = grid[rr][cc]\\n\\t\\t\\t\\t\\tseen.add((rr,cc))\\n\\t\\t\\t\\t\\tqueue.append((dist + 1, grid[rr][cc], rr, cc))\\n\\t\\tres = sorted(res)\\n\\t\\treturn [[i, j] for _, _, i, j in res[:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140729,
                "title": "c",
                "content": "```\\nusing VI = vector<int> ;\\nusing PIII = pair<int, pair<int, pair<int, int>>> ;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        auto visited = vector<vector<bool>>(m, vector<bool>(n, false)) ;\\n        auto dir = vector<pair<int, int>>({{1, 0},{-1,0},{0,1},{0,-1}}) ;\\n        priority_queue<PIII, vector<PIII>, greater<PIII>> pq ;\\n        int x = start[0] ;\\n        int y = start[1] ;\\n        pq.push({0, {grid[x][y], {x, y}}}) ;\\n        vector<vector<int>> ans ;\\n        visited[x][y] = true ;\\n        while(!pq.empty())\\n        {\\n            int level = pq.top().first;\\n            int price = pq.top().second.first ;\\n            int i = pq.top().second.second.first ;\\n            int j = pq.top().second.second.second;\\n\\n            pq.pop() ;\\n            if(price >= pricing[0] && price <= pricing[1])\\n            {\\n                ans.push_back({i, j}) ;\\n                if(ans.size() == k)\\n                    return ans ;\\n            }\\n            for(int z = 0; z < 4; z++)\\n            {\\n                int xx = i + dir[z].first ;\\n                int yy = j + dir[z].second ;\\n                if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                    continue ;\\n                if(visited[xx][yy])\\n                    continue ;\\n                if(grid[xx][yy] == 0)\\n                    continue ;\\n                pq.push({level+1, {grid[xx][yy], {xx, yy}}}) ;\\n                visited[xx][yy] = true ;\\n            }\\n        }\\n\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing VI = vector<int> ;\\nusing PIII = pair<int, pair<int, pair<int, int>>> ;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        auto visited = vector<vector<bool>>(m, vector<bool>(n, false)) ;\\n        auto dir = vector<pair<int, int>>({{1, 0},{-1,0},{0,1},{0,-1}}) ;\\n        priority_queue<PIII, vector<PIII>, greater<PIII>> pq ;\\n        int x = start[0] ;\\n        int y = start[1] ;\\n        pq.push({0, {grid[x][y], {x, y}}}) ;\\n        vector<vector<int>> ans ;\\n        visited[x][y] = true ;\\n        while(!pq.empty())\\n        {\\n            int level = pq.top().first;\\n            int price = pq.top().second.first ;\\n            int i = pq.top().second.second.first ;\\n            int j = pq.top().second.second.second;\\n\\n            pq.pop() ;\\n            if(price >= pricing[0] && price <= pricing[1])\\n            {\\n                ans.push_back({i, j}) ;\\n                if(ans.size() == k)\\n                    return ans ;\\n            }\\n            for(int z = 0; z < 4; z++)\\n            {\\n                int xx = i + dir[z].first ;\\n                int yy = j + dir[z].second ;\\n                if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                    continue ;\\n                if(visited[xx][yy])\\n                    continue ;\\n                if(grid[xx][yy] == 0)\\n                    continue ;\\n                pq.push({level+1, {grid[xx][yy], {xx, yy}}}) ;\\n                visited[xx][yy] = true ;\\n            }\\n        }\\n\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137195,
                "title": "traverse-the-whole-map-not-optimal-heapq-nsmallest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\nimport heapq\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        if not grid or not grid[0]:\\n            return []\\n        m = len(grid)\\n        n = len(grid[0])\\n        queue = deque([start])\\n        within_range = []\\n        d = 0\\n        # check pricing and add to the result\\n        price = grid[start[0]][start[1]]\\n        if pricing[0] <= price <= pricing[1]:\\n            within_range.append([d, price] + start)\\n        # mark as visited\\n        grid[start[0]][start[1]] = -d\\n\\n        while queue and k:\\n            curr_i, curr_j = queue.pop()\\n            d = - grid[curr_i][curr_j]\\n\\n            for i,j in [(-1,0),(1,0),(0,1),(0,-1)]:\\n                adj_i = curr_i + i\\n                adj_j = curr_j + j\\n                if (0 <= adj_i < m and 0 <= adj_j < n\\n                    and grid[adj_i][adj_j] > 0):\\n                    # add to the queue\\n                    queue.appendleft([adj_i, adj_j])\\n                    # check pricing and add to the heap\\n                    price = grid[adj_i][adj_j]\\n                    if pricing[0] <= price <= pricing[1]:\\n                        within_range.append([d + 1, price, adj_i, adj_j])\\n                    # mark as visited\\n                    grid[adj_i][adj_j] = - (d + 1)\\n\\n        k_smallest = heapq.nsmallest(k, within_range)\\n\\n        return [[i,j] for d, price, i, j in k_smallest]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nimport heapq\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        if not grid or not grid[0]:\\n            return []\\n        m = len(grid)\\n        n = len(grid[0])\\n        queue = deque([start])\\n        within_range = []\\n        d = 0\\n        # check pricing and add to the result\\n        price = grid[start[0]][start[1]]\\n        if pricing[0] <= price <= pricing[1]:\\n            within_range.append([d, price] + start)\\n        # mark as visited\\n        grid[start[0]][start[1]] = -d\\n\\n        while queue and k:\\n            curr_i, curr_j = queue.pop()\\n            d = - grid[curr_i][curr_j]\\n\\n            for i,j in [(-1,0),(1,0),(0,1),(0,-1)]:\\n                adj_i = curr_i + i\\n                adj_j = curr_j + j\\n                if (0 <= adj_i < m and 0 <= adj_j < n\\n                    and grid[adj_i][adj_j] > 0):\\n                    # add to the queue\\n                    queue.appendleft([adj_i, adj_j])\\n                    # check pricing and add to the heap\\n                    price = grid[adj_i][adj_j]\\n                    if pricing[0] <= price <= pricing[1]:\\n                        within_range.append([d + 1, price, adj_i, adj_j])\\n                    # mark as visited\\n                    grid[adj_i][adj_j] = - (d + 1)\\n\\n        k_smallest = heapq.nsmallest(k, within_range)\\n\\n        return [[i,j] for d, price, i, j in k_smallest]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088365,
                "title": "c-easy-solution-using-bfs-comparator-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int x, y;\\n    vector<vector<int>> Move = {{-1,0}, {1,0},{0,1},{0,-1}};\\n    static bool comp(vector<int> &v1, vector<int> &v2)\\n    {\\n        if(v1[0] != v2[0])return v1[0] < v2[0];\\n        if(v1[1] != v2[1])return v1[1] < v2[1];\\n        if(v1[2] != v2[2])return v1[2] < v2[2];\\n        return v1[3] < v2[3];\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int>> items;\\n        int n = grid.size(), m = grid[0].size();\\n        x = start[0], y = start[1];\\n        vector<vector<bool>> IsVisited(n, vector<bool>(m , false));\\n        queue<vector<int>> q1;\\n        q1.push({x,y,0});\\n        \\n        IsVisited[x][y]=true;\\n        while(!q1.empty())\\n        {\\n            vector<int> v1 = q1.front();\\n            q1.pop();\\n            if(grid[v1[0]][v1[1]] <= pricing[1] && grid[v1[0]][v1[1]] >= pricing[0])\\n            {\\n                items.push_back({v1[2],grid[v1[0]][v1[1]],v1[0],v1[1]});\\n            }\\n            for(auto &x : Move)\\n            {\\n                int x_new = v1[0] + x[0], y_new = v1[1] + x[1], d_new = 1 + v1[2];\\n                if(x_new < 0 || x_new >= n || y_new < 0 || y_new >= m || IsVisited[x_new][y_new] || grid[x_new][y_new] == 0)continue;\\n                IsVisited[x_new][y_new] = true;\\n                q1.push({x_new, y_new, d_new});\\n            }\\n        }\\n        int cnt = 0;\\n        sort(items.begin(), items.end(), comp);\\n        vector<vector<int>> ans;\\n        for(auto &x : items){ans.push_back({x[2], x[3]});cnt++;if(cnt == k)break;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x, y;\\n    vector<vector<int>> Move = {{-1,0}, {1,0},{0,1},{0,-1}};\\n    static bool comp(vector<int> &v1, vector<int> &v2)\\n    {\\n        if(v1[0] != v2[0])return v1[0] < v2[0];\\n        if(v1[1] != v2[1])return v1[1] < v2[1];\\n        if(v1[2] != v2[2])return v1[2] < v2[2];\\n        return v1[3] < v2[3];\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int>> items;\\n        int n = grid.size(), m = grid[0].size();\\n        x = start[0], y = start[1];\\n        vector<vector<bool>> IsVisited(n, vector<bool>(m , false));\\n        queue<vector<int>> q1;\\n        q1.push({x,y,0});\\n        \\n        IsVisited[x][y]=true;\\n        while(!q1.empty())\\n        {\\n            vector<int> v1 = q1.front();\\n            q1.pop();\\n            if(grid[v1[0]][v1[1]] <= pricing[1] && grid[v1[0]][v1[1]] >= pricing[0])\\n            {\\n                items.push_back({v1[2],grid[v1[0]][v1[1]],v1[0],v1[1]});\\n            }\\n            for(auto &x : Move)\\n            {\\n                int x_new = v1[0] + x[0], y_new = v1[1] + x[1], d_new = 1 + v1[2];\\n                if(x_new < 0 || x_new >= n || y_new < 0 || y_new >= m || IsVisited[x_new][y_new] || grid[x_new][y_new] == 0)continue;\\n                IsVisited[x_new][y_new] = true;\\n                q1.push({x_new, y_new, d_new});\\n            }\\n        }\\n        int cnt = 0;\\n        sort(items.begin(), items.end(), comp);\\n        vector<vector<int>> ans;\\n        for(auto &x : items){ans.push_back({x[2], x[3]});cnt++;if(cnt == k)break;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050616,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    private List<int[]> solve(int[][] grid, int[] pricing, int[] start, int k){\\n        int n = grid.length, m = grid[0].length;\\n        List<int[]> res = new ArrayList<>();\\n        boolean[][] visited = new boolean[n][m];\\n        Queue<int[]> que = new LinkedList<>();\\n        que.offer(new int[]{start[0], start[1], 0});\\n        visited[start[0]][start[1]] = true;\\n        if(grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1])\\n            res.add(new int[]{start[0], start[1], grid[start[0]][start[1]], 0});\\n        while(!que.isEmpty()){\\n            int[] coor = que.poll();\\n            for(int[] dir: dirs){\\n                int x = dir[0] + coor[0];\\n                int y = dir[1] + coor[1];\\n                if(x < 0 || y < 0 || x == n || y == m || visited[x][y] || grid[x][y] == 0) continue;\\n                visited[x][y] = true;\\n                que.add(new int[]{x, y, coor[2] + 1});\\n                if(grid[x][y] <= pricing[1] && grid[x][y] >= pricing[0])\\n                    res.add(new int[]{x, y, grid[x][y], coor[2] + 1});\\n            }\\n        }\\n        return res;\\n    }\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<int[]> lst = solve(grid, pricing, start, k);\\n        Collections.sort(lst, (a, b) -> {\\n            if(a[3] != b[3]) return a[3] - b[3];\\n            if(a[2] != b[2]) return a[2] - b[2];\\n            if(a[0] != b[0]) return a[0] - b[0];\\n            return a[1] - b[1];\\n        });\\n        int n = Math.min(k, lst.size());\\n        List<List<Integer>> res = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            res.add(Arrays.asList(lst.get(i)[0], lst.get(i)[1]));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    private List<int[]> solve(int[][] grid, int[] pricing, int[] start, int k){\\n        int n = grid.length, m = grid[0].length;\\n        List<int[]> res = new ArrayList<>();\\n        boolean[][] visited = new boolean[n][m];\\n        Queue<int[]> que = new LinkedList<>();\\n        que.offer(new int[]{start[0], start[1], 0});\\n        visited[start[0]][start[1]] = true;\\n        if(grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1])\\n            res.add(new int[]{start[0], start[1], grid[start[0]][start[1]], 0});\\n        while(!que.isEmpty()){\\n            int[] coor = que.poll();\\n            for(int[] dir: dirs){\\n                int x = dir[0] + coor[0];\\n                int y = dir[1] + coor[1];\\n                if(x < 0 || y < 0 || x == n || y == m || visited[x][y] || grid[x][y] == 0) continue;\\n                visited[x][y] = true;\\n                que.add(new int[]{x, y, coor[2] + 1});\\n                if(grid[x][y] <= pricing[1] && grid[x][y] >= pricing[0])\\n                    res.add(new int[]{x, y, grid[x][y], coor[2] + 1});\\n            }\\n        }\\n        return res;\\n    }\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<int[]> lst = solve(grid, pricing, start, k);\\n        Collections.sort(lst, (a, b) -> {\\n            if(a[3] != b[3]) return a[3] - b[3];\\n            if(a[2] != b[2]) return a[2] - b[2];\\n            if(a[0] != b[0]) return a[0] - b[0];\\n            return a[1] - b[1];\\n        });\\n        int n = Math.min(k, lst.size());\\n        List<List<Integer>> res = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            res.add(Arrays.asList(lst.get(i)[0], lst.get(i)[1]));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026755,
                "title": "c-easy-solution-using-bfs-comparator-sort-well-commented",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //use comparator for comparing price,row,column \\n    static bool com(pair<int,pair<int,int>>& a,pair<int,pair<int,int>>& b){\\n        if(a.second.second!=b.second.second){\\n            return a.second.second<b.second.second;\\n        }\\n        \\n        if(a.first==b.first){\\n            return a.second.first<b.second.first;\\n        }\\n        if(a.second.second==b.second.second){\\n            return a.first<b.first;\\n        }\\n        return a.second.second<b.second.second;\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n=grid.size(),m=grid[0].size(),c=0;\\n        vector<vector<int>> v;\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<vector<int>>dir={{0,1},{0,-1},{1,0},{-1,0}};\\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        vis[start[0]][start[1]]=true;\\n        bool flag=false;\\n        if(grid[start[0]][start[1]]>=pricing[0] && grid[start[0]][start[1]]<=pricing[1]){\\n            v.push_back({start[0],start[1]});\\n            c++;\\n            if(c==k){\\n                flag=true;\\n            }\\n        }\\n        //if k==1 and queue front element within price range then return answer now no need to do bfs\\n        if(flag){\\n            return v;\\n        }\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<pair<int,pair<int,int>>> ans;\\n                 //{row,{col,price}}\\n            for(int i=0;i<size;i++){\\n                int r=q.front().first;\\n                int c=q.front().second;\\n                q.pop();\\n                //move in four direction\\n                for(int i=0;i<dir.size();i++){\\n                    int curr_r=r+dir[i][0];\\n                    int curr_c=c+dir[i][1];\\n                    if(curr_r>=0 && curr_r<n && curr_c>=0 && curr_c<m && !vis[curr_r][curr_c] && grid[curr_r][curr_c]>=1){\\n                        vis[curr_r][curr_c]=true;\\n                        if it is withing price range then add it to vector \\n                        if(grid[curr_r][curr_c]>=pricing[0] && grid[curr_r][curr_c]<=pricing[1]){\\n                            ans.push_back({curr_r,{curr_c,grid[curr_r][curr_c]}});\\n                        }\\n                        q.push({curr_r,curr_c});\\n                    }\\n                }\\n               \\n            }\\n            //sort according to pricing,row,col value using comparator\\n             sort(ans.begin(),ans.end(),com);\\n             bool flag=false;\\n            for(int i=0;i<ans.size();i++){\\n                v.push_back({ans[i].first,ans[i].second.first});\\n                c++;\\n                if(c==k){\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n**Author:Jayesh Badgujar**\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //use comparator for comparing price,row,column \\n    static bool com(pair<int,pair<int,int>>& a,pair<int,pair<int,int>>& b){\\n        if(a.second.second!=b.second.second){\\n            return a.second.second<b.second.second;\\n        }\\n        \\n        if(a.first==b.first){\\n            return a.second.first<b.second.first;\\n        }\\n        if(a.second.second==b.second.second){\\n            return a.first<b.first;\\n        }\\n        return a.second.second<b.second.second;\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n=grid.size(),m=grid[0].size(),c=0;\\n        vector<vector<int>> v;\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<vector<int>>dir={{0,1},{0,-1},{1,0},{-1,0}};\\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        vis[start[0]][start[1]]=true;\\n        bool flag=false;\\n        if(grid[start[0]][start[1]]>=pricing[0] && grid[start[0]][start[1]]<=pricing[1]){\\n            v.push_back({start[0],start[1]});\\n            c++;\\n            if(c==k){\\n                flag=true;\\n            }\\n        }\\n        //if k==1 and queue front element within price range then return answer now no need to do bfs\\n        if(flag){\\n            return v;\\n        }\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<pair<int,pair<int,int>>> ans;\\n                 //{row,{col,price}}\\n            for(int i=0;i<size;i++){\\n                int r=q.front().first;\\n                int c=q.front().second;\\n                q.pop();\\n                //move in four direction\\n                for(int i=0;i<dir.size();i++){\\n                    int curr_r=r+dir[i][0];\\n                    int curr_c=c+dir[i][1];\\n                    if(curr_r>=0 && curr_r<n && curr_c>=0 && curr_c<m && !vis[curr_r][curr_c] && grid[curr_r][curr_c]>=1){\\n                        vis[curr_r][curr_c]=true;\\n                        if it is withing price range then add it to vector \\n                        if(grid[curr_r][curr_c]>=pricing[0] && grid[curr_r][curr_c]<=pricing[1]){\\n                            ans.push_back({curr_r,{curr_c,grid[curr_r][curr_c]}});\\n                        }\\n                        q.push({curr_r,curr_c});\\n                    }\\n                }\\n               \\n            }\\n            //sort according to pricing,row,col value using comparator\\n             sort(ans.begin(),ans.end(),com);\\n             bool flag=false;\\n            for(int i=0;i<ans.size();i++){\\n                v.push_back({ans[i].first,ans[i].second.first});\\n                c++;\\n                if(c==k){\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n**Author:Jayesh Badgujar**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018804,
                "title": "java-bfs-priorityqueue-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        List<List<Integer>> res = new ArrayList();\\n        PriorityQueue<Item> minHeap = new PriorityQueue<Item>();\\n        bfs(grid, start, pricing, minHeap);\\n        \\n        while(!minHeap.isEmpty() && k-- >0){\\n            Item item = minHeap.poll();\\n            List<Integer> list = Arrays.asList(item.x, item.y);\\n            res.add(list);\\n        }\\n        return res;\\n    }\\n    \\n    public void bfs(int[][] grid, int[] start, int[] pricing, PriorityQueue<Item> minHeap){\\n        int m = grid.length, n = grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        \\n        int dist = 0;\\n        if(validPrice(grid[start[0]][start[1]], pricing)){\\n            Item item = new Item(grid[start[0]][start[1]], start[0], start[1], dist);\\n            minHeap.offer(item); \\n        }\\n        \\n        grid[start[0]][start[1]] = 0;\\n        \\n        \\n        int[][] DIRS = {\\n            {-1, 0}, {0, +1}, {+1, 0}, {0, -1}\\n        };\\n        while(!q.isEmpty()){\\n            dist++;\\n            int sz = q.size();\\n            for(int i=0; i<sz; i++){\\n                int[] curr = q.poll();\\n                \\n                for(int[] dir : DIRS){\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x>=0 && y>=0 && x<m && y<n && grid[x][y] != 0){\\n                        Item item = new Item(grid[x][y], x, y, dist);\\n                        if(validPrice(grid[x][y], pricing)){\\n                            minHeap.offer(item);\\n                        }\\n                        grid[x][y] = 0;\\n                        q.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    public boolean validPrice(int price, int[] pricing){\\n        return pricing[0] <= price && price <= pricing[1];\\n    }\\n    \\n    public int findDist(int i, int j, int[] start){\\n        return Math.abs(i-start[0]) + Math.abs(j-start[1]);\\n    }\\n}\\n\\nclass Item implements Comparable<Item> {\\n    int price;\\n    int x, y;\\n    int dist;\\n    \\n    public Item(int price, int x, int y, int dist){\\n        this.price = price;\\n        this.x = x;\\n        this.y = y;\\n        this.dist = dist;\\n    }\\n    \\n    public int compareTo(Item item){\\n        if(this.dist != item.dist){\\n            return this.dist - item.dist;\\n            // return this.dist < item.dist ? +1 : -1;\\n        }\\n        if(this.price != item.price){\\n            return this.price - item.price;\\n            // return this.price < item.price ?  +1 : -1;\\n        }\\n        if(this.x != item.x){\\n            return this.x - item.x;\\n            // return this.x < item.x ?  +1 : -1;\\n        }\\n        if(this.y != item.y){\\n            return this.y - item.y;\\n            // return this.y < item.y ?  +1 : -1;\\n        }\\n        return 0;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        List<List<Integer>> res = new ArrayList();\\n        PriorityQueue<Item> minHeap = new PriorityQueue<Item>();\\n        bfs(grid, start, pricing, minHeap);\\n        \\n        while(!minHeap.isEmpty() && k-- >0){\\n            Item item = minHeap.poll();\\n            List<Integer> list = Arrays.asList(item.x, item.y);\\n            res.add(list);\\n        }\\n        return res;\\n    }\\n    \\n    public void bfs(int[][] grid, int[] start, int[] pricing, PriorityQueue<Item> minHeap){\\n        int m = grid.length, n = grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        \\n        int dist = 0;\\n        if(validPrice(grid[start[0]][start[1]], pricing)){\\n            Item item = new Item(grid[start[0]][start[1]], start[0], start[1], dist);\\n            minHeap.offer(item); \\n        }\\n        \\n        grid[start[0]][start[1]] = 0;\\n        \\n        \\n        int[][] DIRS = {\\n            {-1, 0}, {0, +1}, {+1, 0}, {0, -1}\\n        };\\n        while(!q.isEmpty()){\\n            dist++;\\n            int sz = q.size();\\n            for(int i=0; i<sz; i++){\\n                int[] curr = q.poll();\\n                \\n                for(int[] dir : DIRS){\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x>=0 && y>=0 && x<m && y<n && grid[x][y] != 0){\\n                        Item item = new Item(grid[x][y], x, y, dist);\\n                        if(validPrice(grid[x][y], pricing)){\\n                            minHeap.offer(item);\\n                        }\\n                        grid[x][y] = 0;\\n                        q.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    public boolean validPrice(int price, int[] pricing){\\n        return pricing[0] <= price && price <= pricing[1];\\n    }\\n    \\n    public int findDist(int i, int j, int[] start){\\n        return Math.abs(i-start[0]) + Math.abs(j-start[1]);\\n    }\\n}\\n\\nclass Item implements Comparable<Item> {\\n    int price;\\n    int x, y;\\n    int dist;\\n    \\n    public Item(int price, int x, int y, int dist){\\n        this.price = price;\\n        this.x = x;\\n        this.y = y;\\n        this.dist = dist;\\n    }\\n    \\n    public int compareTo(Item item){\\n        if(this.dist != item.dist){\\n            return this.dist - item.dist;\\n            // return this.dist < item.dist ? +1 : -1;\\n        }\\n        if(this.price != item.price){\\n            return this.price - item.price;\\n            // return this.price < item.price ?  +1 : -1;\\n        }\\n        if(this.x != item.x){\\n            return this.x - item.x;\\n            // return this.x < item.x ?  +1 : -1;\\n        }\\n        if(this.y != item.y){\\n            return this.y - item.y;\\n            // return this.y < item.y ?  +1 : -1;\\n        }\\n        return 0;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016571,
                "title": "golang-bfs-with-sorting",
                "content": "```go\\nfunc highestRankedKItems(grid [][]int, pricing []int, start []int, k int) [][]int {\\n  var items [][4]int // <x, y, dist, price>\\n  var queue [][2]int\\n  directions := [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}\\n  // Let\\'s do a BFS starting from the starting point\\n  queue = append(queue, [2]int{start[0], start[1]})\\n  grid[start[0]][start[1]] = -grid[start[0]][start[1]] // mark as visited\\n  var dist int\\n  for len(queue) > 0 {\\n    var newQueue [][2]int\\n    for _, curr := range queue {\\n      x, y := curr[0], curr[1]\\n      // Looking at absolute value here since we negate the value for visiting a vertex\\n      if abs(grid[x][y]) >= pricing[0] && abs(grid[x][y]) <= pricing[1] {\\n        // Add eligible items to the list\\n        items = append(items, [4]int{x, y, dist, abs(grid[x][y])})\\n      }\\n      for _, dir := range directions {\\n        x1, y1 := x + dir[0], y + dir[1]\\n        if x1 >= 0 && x1 < len(grid) && y1 >= 0 && y1 < len(grid[x]) && grid[x1][y1] > 0 {\\n          // Mark as visited by negating\\n          grid[x1][y1] = -grid[x1][y1]\\n          newQueue = append(newQueue, [2]int{x1,y1})\\n        }\\n      }\\n    }\\n    dist++\\n    queue = newQueue\\n  }\\n  // Sort the items based on the constraints given\\n  sort.Slice(items, func(i, j int) bool {\\n    if items[i][2] != items[j][2] {\\n      return items[i][2] < items[j][2]\\n    }\\n    if items[i][3] != items[j][3] {\\n      return items[i][3] < items[j][3]\\n    }\\n    if items[i][0] != items[j][0] {\\n      return items[i][0] < items[j][0]\\n    }\\n    return items[i][1] < items[j][1]\\n  })\\n  // Get upto k items\\n  res := make([][]int, 0, k)\\n  for i := 0; i < len(items) && len(res) < cap(res); i++ {\\n    res = append(res, []int{items[i][0], items[i][1]})\\n  }\\n  return res\\n}\\n\\nfunc abs(a int) int {\\n  if a < 0 {\\n    return -a\\n  }\\n  return a\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```go\\nfunc highestRankedKItems(grid [][]int, pricing []int, start []int, k int) [][]int {\\n  var items [][4]int // <x, y, dist, price>\\n  var queue [][2]int\\n  directions := [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}\\n  // Let\\'s do a BFS starting from the starting point\\n  queue = append(queue, [2]int{start[0], start[1]})\\n  grid[start[0]][start[1]] = -grid[start[0]][start[1]] // mark as visited\\n  var dist int\\n  for len(queue) > 0 {\\n    var newQueue [][2]int\\n    for _, curr := range queue {\\n      x, y := curr[0], curr[1]\\n      // Looking at absolute value here since we negate the value for visiting a vertex\\n      if abs(grid[x][y]) >= pricing[0] && abs(grid[x][y]) <= pricing[1] {\\n        // Add eligible items to the list\\n        items = append(items, [4]int{x, y, dist, abs(grid[x][y])})\\n      }\\n      for _, dir := range directions {\\n        x1, y1 := x + dir[0], y + dir[1]\\n        if x1 >= 0 && x1 < len(grid) && y1 >= 0 && y1 < len(grid[x]) && grid[x1][y1] > 0 {\\n          // Mark as visited by negating\\n          grid[x1][y1] = -grid[x1][y1]\\n          newQueue = append(newQueue, [2]int{x1,y1})\\n        }\\n      }\\n    }\\n    dist++\\n    queue = newQueue\\n  }\\n  // Sort the items based on the constraints given\\n  sort.Slice(items, func(i, j int) bool {\\n    if items[i][2] != items[j][2] {\\n      return items[i][2] < items[j][2]\\n    }\\n    if items[i][3] != items[j][3] {\\n      return items[i][3] < items[j][3]\\n    }\\n    if items[i][0] != items[j][0] {\\n      return items[i][0] < items[j][0]\\n    }\\n    return items[i][1] < items[j][1]\\n  })\\n  // Get upto k items\\n  res := make([][]int, 0, k)\\n  for i := 0; i < len(items) && len(res) < cap(res); i++ {\\n    res = append(res, []int{items[i][0], items[i][1]})\\n  }\\n  return res\\n}\\n\\nfunc abs(a int) int {\\n  if a < 0 {\\n    return -a\\n  }\\n  return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2929399,
                "title": "python-simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def highestRankedKItems(self, grid, pricing, start, k):\\n        m, n, ans, visited = len(grid), len(grid[0]), [], set()\\n\\n        visited.add((start[0],start[1]))\\n\\n        node = (0,grid[start[0]][start[1]],start[0],start[1])\\n\\n        stack = collections.deque([node])\\n\\n        while stack:\\n            dist, cost, r, c = stack.popleft()\\n\\n            if pricing[0] <= cost <= pricing[1]:\\n                ans += [(dist,cost,r,c)]\\n\\n            for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\\n                if 0 <= nr < m and 0 <= nc < n and (nr,nc) not in visited and grid[nr][nc] != 0:\\n                    stack.append((dist+1,grid[nr][nc],nr,nc))\\n                    visited.add((nr,nc))\\n\\n        ans = sorted(ans)\\n\\n        return [i[2:] for i in ans][:k]\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid, pricing, start, k):\\n        m, n, ans, visited = len(grid), len(grid[0]), [], set()\\n\\n        visited.add((start[0],start[1]))\\n\\n        node = (0,grid[start[0]][start[1]],start[0],start[1])\\n\\n        stack = collections.deque([node])\\n\\n        while stack:\\n            dist, cost, r, c = stack.popleft()\\n\\n            if pricing[0] <= cost <= pricing[1]:\\n                ans += [(dist,cost,r,c)]\\n\\n            for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\\n                if 0 <= nr < m and 0 <= nc < n and (nr,nc) not in visited and grid[nr][nc] != 0:\\n                    stack.append((dist+1,grid[nr][nc],nr,nc))\\n                    visited.add((nr,nc))\\n\\n        ans = sorted(ans)\\n\\n        return [i[2:] for i in ans][:k]\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803885,
                "title": "java-simple-bfs-and-sorting-beats-98-full-explanation",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        // the question is very simple BFS question with lot of constraints.\\n        // we will apply simple BFS for for all the cells whose value greater than 0\\n        // rather making a boolean array for visited we just replce the cell value with negative of the values.\\n        // \\n        List<List<Integer>> ans = new ArrayList<>(); // list to return answer\\n        Queue<Pair> q = new ArrayDeque<>(); // queue to apply BFS\\n        Pair.grid = grid;// just incase we use priorityQueue to pair should implement Comparable interface which needs grid to compare\\n        q.add(new Pair(start[0] , start[1] , 0));//add source Pair\\n        grid[start[0]][start[1]] *= -1; // mark it visited by reversing its sign\\n        List<Pair> allPairs = new ArrayList<>(); // list to add all the valid Pairs\\n        while(q.size() > 0){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Pair p = q.remove();\\n                if(isInRange(Math.abs(grid[p.r][p.c]) ,  pricing)){\\n                    // if the Pair price within range add it to allPairs\\n                    allPairs.add(p);\\n                }\\n                int r = p.r;\\n                int c = p.c;\\n                //up\\n                if(p.r > 0 && grid[p.r-1][p.c] > 0){\\n                    q.add(new Pair(r-1 , c , p.dist+1));\\n                    grid[p.r-1][p.c] *= -1;\\n                }\\n                //right\\n                if(p.c < grid[0].length-1  && grid[p.r][p.c+1] > 0){\\n                    q.add(new Pair(r , c+1 , p.dist+1));\\n                    grid[p.r][p.c+1] *= -1;\\n                }\\n                //bottom\\n                if(p.r < grid.length-1 && grid[p.r+1][p.c] > 0){\\n                    q.add(new Pair(r+1 , c , p.dist+1));\\n                    grid[p.r+1][p.c] *= -1;\\n                }\\n                //left\\n                if(p.c > 0 && grid[p.r][p.c-1] > 0){\\n                    q.add(new Pair(r , c-1 , p.dist+1));\\n                    grid[p.r][p.c-1] *= -1;\\n                }\\n            }\\n        }\\n        \\n        Comparator<Pair> comp = new Comparator<Pair>(){ // costum comparator for Sorting Pairs \\n            @Override\\n            public int compare(Pair a , Pair b){\\n                int d1 = a.dist;\\n                int d2 = b.dist;\\n                if(d1 == d2){\\n                    int val1 = grid[a.r][a.c];\\n                    int val2 = grid[b.r][b.c];\\n                    if( val1 == val2 ){\\n                        if(a.r == b.r){\\n                            return a.c - b.c;\\n                        }else{\\n                            return a.r - b.r;\\n                        }\\n                    }else{\\n                        return val2 - val1;//i am not getting why this is working it should be val1 -val2\\n                    }\\n                    \\n                }else{\\n                    return a.dist - b.dist;\\n                }\\n            }\\n        };\\n        // System.out.println(allPairs);\\n        Collections.sort(allPairs, comp);\\n        // System.out.println(allPairs);\\n        for(int i = 0 ; i < k && i < allPairs.size() ; i++){//if there are less pairs than k sor add condition\\n            List<Integer> l = new ArrayList<>();\\n            Pair p = allPairs.get(i);\\n            l.add(p.r);\\n            l.add(p.c);\\n            ans.add(l);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n    public boolean isInRange(int val , int[] price){\\n        return val >= price[0] && val <= price[1];\\n    }\\n}\\nclass Pair {\\n    int r;\\n    int c;\\n    int dist;\\n    static int[][] grid;\\n    Pair(){}\\n    Pair(int r , int c , int dist){\\n        this.r = r;\\n        this.c = c;\\n        this.dist = dist;\\n    }\\n    \\n    @Override\\n    public String toString(){\\n        return r+\",\"+c+\",\"+dist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        // the question is very simple BFS question with lot of constraints.\\n        // we will apply simple BFS for for all the cells whose value greater than 0\\n        // rather making a boolean array for visited we just replce the cell value with negative of the values.\\n        // \\n        List<List<Integer>> ans = new ArrayList<>(); // list to return answer\\n        Queue<Pair> q = new ArrayDeque<>(); // queue to apply BFS\\n        Pair.grid = grid;// just incase we use priorityQueue to pair should implement Comparable interface which needs grid to compare\\n        q.add(new Pair(start[0] , start[1] , 0));//add source Pair\\n        grid[start[0]][start[1]] *= -1; // mark it visited by reversing its sign\\n        List<Pair> allPairs = new ArrayList<>(); // list to add all the valid Pairs\\n        while(q.size() > 0){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Pair p = q.remove();\\n                if(isInRange(Math.abs(grid[p.r][p.c]) ,  pricing)){\\n                    // if the Pair price within range add it to allPairs\\n                    allPairs.add(p);\\n                }\\n                int r = p.r;\\n                int c = p.c;\\n                //up\\n                if(p.r > 0 && grid[p.r-1][p.c] > 0){\\n                    q.add(new Pair(r-1 , c , p.dist+1));\\n                    grid[p.r-1][p.c] *= -1;\\n                }\\n                //right\\n                if(p.c < grid[0].length-1  && grid[p.r][p.c+1] > 0){\\n                    q.add(new Pair(r , c+1 , p.dist+1));\\n                    grid[p.r][p.c+1] *= -1;\\n                }\\n                //bottom\\n                if(p.r < grid.length-1 && grid[p.r+1][p.c] > 0){\\n                    q.add(new Pair(r+1 , c , p.dist+1));\\n                    grid[p.r+1][p.c] *= -1;\\n                }\\n                //left\\n                if(p.c > 0 && grid[p.r][p.c-1] > 0){\\n                    q.add(new Pair(r , c-1 , p.dist+1));\\n                    grid[p.r][p.c-1] *= -1;\\n                }\\n            }\\n        }\\n        \\n        Comparator<Pair> comp = new Comparator<Pair>(){ // costum comparator for Sorting Pairs \\n            @Override\\n            public int compare(Pair a , Pair b){\\n                int d1 = a.dist;\\n                int d2 = b.dist;\\n                if(d1 == d2){\\n                    int val1 = grid[a.r][a.c];\\n                    int val2 = grid[b.r][b.c];\\n                    if( val1 == val2 ){\\n                        if(a.r == b.r){\\n                            return a.c - b.c;\\n                        }else{\\n                            return a.r - b.r;\\n                        }\\n                    }else{\\n                        return val2 - val1;//i am not getting why this is working it should be val1 -val2\\n                    }\\n                    \\n                }else{\\n                    return a.dist - b.dist;\\n                }\\n            }\\n        };\\n        // System.out.println(allPairs);\\n        Collections.sort(allPairs, comp);\\n        // System.out.println(allPairs);\\n        for(int i = 0 ; i < k && i < allPairs.size() ; i++){//if there are less pairs than k sor add condition\\n            List<Integer> l = new ArrayList<>();\\n            Pair p = allPairs.get(i);\\n            l.add(p.r);\\n            l.add(p.c);\\n            ans.add(l);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n    public boolean isInRange(int val , int[] price){\\n        return val >= price[0] && val <= price[1];\\n    }\\n}\\nclass Pair {\\n    int r;\\n    int c;\\n    int dist;\\n    static int[][] grid;\\n    Pair(){}\\n    Pair(int r , int c , int dist){\\n        this.r = r;\\n        this.c = c;\\n        this.dist = dist;\\n    }\\n    \\n    @Override\\n    public String toString(){\\n        return r+\",\"+c+\",\"+dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788074,
                "title": "easy-c-solution-use-bfs-trickfully",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSafe(int x, int y, int m, int n, int l, int u, vector<vector<int>> &vis, vector<vector<int>> &grid)\\n    {\\n        return x >= 0 && y >= 0 && x < m && y < n && grid[x][y] != 0 && vis[x][y] == -1; \\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int>> cand;\\n        vector<vector<int>> vis(grid.size(), vector<int> (grid[0].size(), -1));\\n        \\n        queue<vector<int>> q;\\n        q.push({start[0], start[1], 0});\\n        vis[start[0]][start[1]] = 1;\\n        \\n        vector<vector<int>> ans;\\n        if (grid[start[0]][start[1]] != 0 && grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1])\\n            ans.push_back({start[0], start[1], 0, grid[0][0]});\\n        \\n        while(!q.empty())\\n        {\\n            auto f = q.front();\\n            q.pop();\\n            \\n            int x = f[0], y = f[1], r = f[2];\\n            int dx[4] = {1, 0, -1, 0};\\n            int dy[4] = {0, 1, 0, -1};\\n            \\n            for (int i = 0; i < 4; i++)\\n            {\\n                if (isSafe(x + dx[i], y + dy[i], grid.size(), grid[0].size(), pricing[0], pricing[1], vis, grid))\\n                {\\n                    if (grid[x + dx[i]][y + dy[i]] != 1 && grid[x + dx[i]][y + dy[i]] >= pricing[0] && grid[x + dx[i]][y + dy[i]] <= pricing[1])\\n                        ans.push_back({x + dx[i], y + dy[i], r + 1, grid[x + dx[i]][y + dy[i]]});\\n                    \\n                    q.push({x + dx[i], y + dy[i], r + 1});\\n                    vis[x + dx[i]][y + dy[i]] = 1;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end(), [](vector<int> &v1, vector<int> &v2){\\n            // Distance, defined as the length of the shortest path from the start (shorter distance has a higher rank).\\n            // Price (lower price has a higher rank, but it must be in the price range).\\n            // The row number (smaller row number has a higher rank).\\n            // The column number (smaller column number has a higher rank).\\n            \\n            if (v1[2] != v2[2])\\n                return v1[2] < v2[2];\\n            else if (v1[3] != v2[3])\\n                return v1[3] < v2[3];\\n            else if (v1[0] != v2[0])\\n                return v1[0] < v2[0];\\n            else\\n                return v1[1] < v2[1];\\n        });\\n        \\n        vector<vector<int>> res;\\n        for (int i = 0; i < min((int)ans.size(), k); i++)\\n            res.push_back({ans[i][0], ans[i][1]});\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int x, int y, int m, int n, int l, int u, vector<vector<int>> &vis, vector<vector<int>> &grid)\\n    {\\n        return x >= 0 && y >= 0 && x < m && y < n && grid[x][y] != 0 && vis[x][y] == -1; \\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int>> cand;\\n        vector<vector<int>> vis(grid.size(), vector<int> (grid[0].size(), -1));\\n        \\n        queue<vector<int>> q;\\n        q.push({start[0], start[1], 0});\\n        vis[start[0]][start[1]] = 1;\\n        \\n        vector<vector<int>> ans;\\n        if (grid[start[0]][start[1]] != 0 && grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1])\\n            ans.push_back({start[0], start[1], 0, grid[0][0]});\\n        \\n        while(!q.empty())\\n        {\\n            auto f = q.front();\\n            q.pop();\\n            \\n            int x = f[0], y = f[1], r = f[2];\\n            int dx[4] = {1, 0, -1, 0};\\n            int dy[4] = {0, 1, 0, -1};\\n            \\n            for (int i = 0; i < 4; i++)\\n            {\\n                if (isSafe(x + dx[i], y + dy[i], grid.size(), grid[0].size(), pricing[0], pricing[1], vis, grid))\\n                {\\n                    if (grid[x + dx[i]][y + dy[i]] != 1 && grid[x + dx[i]][y + dy[i]] >= pricing[0] && grid[x + dx[i]][y + dy[i]] <= pricing[1])\\n                        ans.push_back({x + dx[i], y + dy[i], r + 1, grid[x + dx[i]][y + dy[i]]});\\n                    \\n                    q.push({x + dx[i], y + dy[i], r + 1});\\n                    vis[x + dx[i]][y + dy[i]] = 1;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end(), [](vector<int> &v1, vector<int> &v2){\\n            // Distance, defined as the length of the shortest path from the start (shorter distance has a higher rank).\\n            // Price (lower price has a higher rank, but it must be in the price range).\\n            // The row number (smaller row number has a higher rank).\\n            // The column number (smaller column number has a higher rank).\\n            \\n            if (v1[2] != v2[2])\\n                return v1[2] < v2[2];\\n            else if (v1[3] != v2[3])\\n                return v1[3] < v2[3];\\n            else if (v1[0] != v2[0])\\n                return v1[0] < v2[0];\\n            else\\n                return v1[1] < v2[1];\\n        });\\n        \\n        vector<vector<int>> res;\\n        for (int i = 0; i < min((int)ans.size(), k); i++)\\n            res.push_back({ans[i][0], ans[i][1]});\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785246,
                "title": "java-bfs-solution-beats-89-78-in-runtime",
                "content": "```\\nclass Hotel {\\n        int distance;\\n        int price;\\n        int row;\\n        int column;\\n\\n        Hotel(int d, int p, int row, int column) {\\n            this.distance = d;\\n            this.price = p;\\n            this.row = row;\\n            this.column = column;\\n        }\\n    }\\n\\n    class Node {\\n        int row;\\n        int col;\\n        int dist;\\n\\n        Node(int r, int c, int d) {\\n            this.row = r;\\n            this.col = c;\\n            this.dist = d;\\n        }\\n    }\\n\\n    //Use BFS to find shortest distance\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Hotel> hotels = new ArrayList<>();\\n        int lowPrice = pricing[0];\\n        int highPrice = pricing[1];\\n\\n        int rowLen = grid.length;\\n        int colLen = grid[0].length;\\n        int startRow = start[0];\\n        int startCol = start[1];\\n        int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        Queue<Node> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[rowLen][colLen];\\n        queue.add(new Node(startRow, startCol, 0));\\n\\n        //Start point is a Hotel\\n        if (grid[start[0]][start[1]] > 1) {\\n            int price = grid[startRow][startCol];\\n            if (price >= lowPrice && price <= highPrice) {\\n                hotels.add(new Hotel(0, price, startRow, startCol));\\n                visited[startRow][startCol] = true;\\n            }\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            Node node = queue.poll();\\n\\n            for (int i = 0; i < dirs.length; i++) {\\n                int nextRow = node.row + dirs[i][0];\\n                int nextColumn = node.col + dirs[i][1];\\n\\n                if (isValid(nextRow, nextColumn, rowLen, colLen) && !visited[nextRow][nextColumn] && grid[nextRow][nextColumn] != 0) {\\n                    int price = grid[nextRow][nextColumn];\\n                    if (price != 1) {\\n                        //New hotel found\\n                        Hotel hotel = new Hotel(node.dist + 1, price, nextRow, nextColumn);\\n                        if (price >= lowPrice && price <= highPrice)\\n                            hotels.add(hotel);\\n                    }\\n\\n                    visited[nextRow][nextColumn] = true;\\n                    queue.add(new Node(nextRow, nextColumn, node.dist + 1));\\n                }\\n            }\\n        }\\n\\n        boolean returnAll = false;\\n        if (hotels.size() <= k) returnAll = true;\\n\\n        hotels.sort((o1, o2) -> {\\n            if (o1.distance != o2.distance) {\\n                return o1.distance - o2.distance;\\n            } else if (o1.price != o2.price) {\\n                return o1.price - o2.price;\\n            } else if (o1.row != o2.row) {\\n                return o1.row - o2.row;\\n            } else if (o1.column != o2.column) {\\n                return o1.column - o2.column;\\n            }\\n            return 0;\\n        });\\n\\n        if (returnAll) {\\n            for (int i = 0; i < hotels.size(); i++) {\\n                Hotel hotel = hotels.get(i);\\n                List<Integer> list = new ArrayList<>();\\n                list.add(hotel.row);\\n                list.add(hotel.column);\\n                result.add(list);\\n            }\\n            return result;\\n        }\\n\\n        //Get top K\\n        int index = 0;\\n        while (k > 0) {\\n            Hotel hotel = hotels.get(index);\\n            List<Integer> list = new ArrayList<>();\\n            list.add(hotel.row);\\n            list.add(hotel.column);\\n            result.add(list);\\n            k--;\\n            index++;\\n        }\\n\\n        return result;\\n    }\\n\\n    boolean isValid(int i, int j, int rowLen, int colLen) {\\n        if (i >= 0 && i < rowLen && j >= 0 && j < colLen) return true;\\n        return false;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Hotel {\\n        int distance;\\n        int price;\\n        int row;\\n        int column;\\n\\n        Hotel(int d, int p, int row, int column) {\\n            this.distance = d;\\n            this.price = p;\\n            this.row = row;\\n            this.column = column;\\n        }\\n    }\\n\\n    class Node {\\n        int row;\\n        int col;\\n        int dist;\\n\\n        Node(int r, int c, int d) {\\n            this.row = r;\\n            this.col = c;\\n            this.dist = d;\\n        }\\n    }\\n\\n    //Use BFS to find shortest distance\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Hotel> hotels = new ArrayList<>();\\n        int lowPrice = pricing[0];\\n        int highPrice = pricing[1];\\n\\n        int rowLen = grid.length;\\n        int colLen = grid[0].length;\\n        int startRow = start[0];\\n        int startCol = start[1];\\n        int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        Queue<Node> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[rowLen][colLen];\\n        queue.add(new Node(startRow, startCol, 0));\\n\\n        //Start point is a Hotel\\n        if (grid[start[0]][start[1]] > 1) {\\n            int price = grid[startRow][startCol];\\n            if (price >= lowPrice && price <= highPrice) {\\n                hotels.add(new Hotel(0, price, startRow, startCol));\\n                visited[startRow][startCol] = true;\\n            }\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            Node node = queue.poll();\\n\\n            for (int i = 0; i < dirs.length; i++) {\\n                int nextRow = node.row + dirs[i][0];\\n                int nextColumn = node.col + dirs[i][1];\\n\\n                if (isValid(nextRow, nextColumn, rowLen, colLen) && !visited[nextRow][nextColumn] && grid[nextRow][nextColumn] != 0) {\\n                    int price = grid[nextRow][nextColumn];\\n                    if (price != 1) {\\n                        //New hotel found\\n                        Hotel hotel = new Hotel(node.dist + 1, price, nextRow, nextColumn);\\n                        if (price >= lowPrice && price <= highPrice)\\n                            hotels.add(hotel);\\n                    }\\n\\n                    visited[nextRow][nextColumn] = true;\\n                    queue.add(new Node(nextRow, nextColumn, node.dist + 1));\\n                }\\n            }\\n        }\\n\\n        boolean returnAll = false;\\n        if (hotels.size() <= k) returnAll = true;\\n\\n        hotels.sort((o1, o2) -> {\\n            if (o1.distance != o2.distance) {\\n                return o1.distance - o2.distance;\\n            } else if (o1.price != o2.price) {\\n                return o1.price - o2.price;\\n            } else if (o1.row != o2.row) {\\n                return o1.row - o2.row;\\n            } else if (o1.column != o2.column) {\\n                return o1.column - o2.column;\\n            }\\n            return 0;\\n        });\\n\\n        if (returnAll) {\\n            for (int i = 0; i < hotels.size(); i++) {\\n                Hotel hotel = hotels.get(i);\\n                List<Integer> list = new ArrayList<>();\\n                list.add(hotel.row);\\n                list.add(hotel.column);\\n                result.add(list);\\n            }\\n            return result;\\n        }\\n\\n        //Get top K\\n        int index = 0;\\n        while (k > 0) {\\n            Hotel hotel = hotels.get(index);\\n            List<Integer> list = new ArrayList<>();\\n            list.add(hotel.row);\\n            list.add(hotel.column);\\n            result.add(list);\\n            k--;\\n            index++;\\n        }\\n\\n        return result;\\n    }\\n\\n    boolean isValid(int i, int j, int rowLen, int colLen) {\\n        if (i >= 0 && i < rowLen && j >= 0 && j < colLen) return true;\\n        return false;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760933,
                "title": "c-concise-bfs",
                "content": "```\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int low = pricing[0], high = pricing[1];\\n        const int n = grid.size(), m = grid[0].size();\\n        const vector<pair<int,int>> dirs = {{0,1}, {0, -1}, {-1,0}, {1,0}};\\n        queue<tuple<int,int,int>> q; //x, y, dis\\n        q.emplace(start[0], start[1], 0);\\n        vector<vector<int>> res;\\n        set<tuple<int,int,int, int>> st; //price, x, y\\n        while(!q.empty()){\\n            auto [i, j, d] = q.front(); q.pop();\\n            if(grid[i][j] == -1) continue; //visited;\\n            int& p = grid[i][j];\\n            if(low <= p && p <= high) st.insert(tuple(d, p, i, j));\\n            p = -1;\\n            for(auto [di, dj] : dirs){                \\n                int x = i+di, y = j+dj;\\n                if(x<0 || x>=n || y<0 || y>= m || grid[x][y] < 1) continue;\\n                q.emplace(x, y, d+1);\\n            }\\n        }\\n        for(auto [d, p, i, j] : st){\\n            if(res.size() == k) break;\\n            res.emplace_back(vector{i, j});\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int low = pricing[0], high = pricing[1];\\n        const int n = grid.size(), m = grid[0].size();\\n        const vector<pair<int,int>> dirs = {{0,1}, {0, -1}, {-1,0}, {1,0}};\\n        queue<tuple<int,int,int>> q; //x, y, dis\\n        q.emplace(start[0], start[1], 0);\\n        vector<vector<int>> res;\\n        set<tuple<int,int,int, int>> st; //price, x, y\\n        while(!q.empty()){\\n            auto [i, j, d] = q.front(); q.pop();\\n            if(grid[i][j] == -1) continue; //visited;\\n            int& p = grid[i][j];\\n            if(low <= p && p <= high) st.insert(tuple(d, p, i, j));\\n            p = -1;\\n            for(auto [di, dj] : dirs){                \\n                int x = i+di, y = j+dj;\\n                if(x<0 || x>=n || y<0 || y>= m || grid[x][y] < 1) continue;\\n                q.emplace(x, y, d+1);\\n            }\\n        }\\n        for(auto [d, p, i, j] : st){\\n            if(res.size() == k) break;\\n            res.emplace_back(vector{i, j});\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2752881,
                "title": "rust-solution-using-bfs",
                "content": "```\\nuse std::cmp::Ordering;\\nuse std::collections::*;\\n\\nfn helper(\\n    grid: &Vec<Vec<i32>>, \\n    memo: &mut Vec<Vec<i32>>,\\n    memo2: &mut HashMap<(usize,usize), (i32,i32)>,\\n    stack: &mut Vec<(usize,usize,i32)>,\\n    r:usize, c:usize, lv:i32, rv:i32, cv:i32) {\\n    let nv = cv + 1;\\n    let gv = grid[r][c];\\n    if gv >= 1 && nv < memo[r][c] {\\n        memo[r][c] = nv;\\n        stack.push((r,c,nv));\\n\\n        if lv <= gv && gv <= rv {\\n            memo2.insert((r,c), (nv,gv));\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn highest_ranked_k_items(grid: Vec<Vec<i32>>, pricing: Vec<i32>, start: Vec<i32>, k: i32) -> Vec<Vec<i32>> {\\n        let n = grid.len();\\n        let m = grid[0].len();\\n        let sri = start[0] as usize;\\n        let sci = start[1] as usize;\\n        let inf = 1_000_000_000;\\n        let mut memo = vec![vec![inf;m];n];\\n        memo[sri][sci] = 0;\\n        let mut memo2 = HashMap::new();\\n        let mut stack = vec![(sri, sci, 0)];\\n        let lv = pricing[0];\\n        let rv = pricing[1];\\n\\n        if lv <= grid[sri][sci] && grid[sri][sci] <= rv {\\n            memo2.insert((sri, sci), (0,grid[sri][sci]));\\n        }\\n\\n        while !stack.is_empty() {\\n            let mut new_stack = vec![];\\n            while let Some((r,c,v)) = stack.pop() {\\n                if 0 < r {\\n                    helper(&grid, &mut memo, &mut memo2, &mut new_stack, r-1,c,lv,rv,v);\\n                }\\n                if r < n-1 {\\n                    helper(&grid, &mut memo, &mut memo2, &mut new_stack, r+1,c,lv,rv,v);\\n                }\\n                if 0 < c {\\n                    helper(&grid, &mut memo, &mut memo2, &mut new_stack, r,c-1,lv,rv,v);\\n                }\\n                if c < m-1 {\\n                    helper(&grid, &mut memo, &mut memo2, &mut new_stack, r,c+1,lv,rv,v);\\n                }\\n            }\\n            stack = new_stack;\\n        }\\n\\n        let mut memo2 = memo2.into_iter().map(|(key,val)|  (val.0,val.1,key.0,key.1)).collect::<Vec<(i32,i32,usize,usize)>>();\\n        memo2.sort_by(|a,b| {\\n            let v1 = a.0.cmp(&b.0);\\n            if v1 == Ordering::Equal {\\n                let v2 = a.1.cmp(&b.1); \\n                if v2 == Ordering::Equal {\\n                    let v3 = a.2.cmp(&b.2); \\n                    if v3 == Ordering::Equal {\\n                        a.3.cmp(&b.3)\\n                    } else{\\n                        v3\\n                    }\\n                } else {\\n                    v2\\n                }\\n            } else {\\n                v1\\n            }\\n        });\\n        let mut result = vec![];\\n        for i in 0..k.min(memo2.len() as i32) {\\n            result.push(vec![memo2[i as usize].2 as i32, memo2[i as usize].3 as i32]);\\n        }\\n        result\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::*;\\n\\nfn helper(\\n    grid: &Vec<Vec<i32>>, \\n    memo: &mut Vec<Vec<i32>>,\\n    memo2: &mut HashMap<(usize,usize), (i32,i32)>,\\n    stack: &mut Vec<(usize,usize,i32)>,\\n    r:usize, c:usize, lv:i32, rv:i32, cv:i32) {\\n    let nv = cv + 1;\\n    let gv = grid[r][c];\\n    if gv >= 1 && nv < memo[r][c] {\\n        memo[r][c] = nv;\\n        stack.push((r,c,nv));\\n\\n        if lv <= gv && gv <= rv {\\n            memo2.insert((r,c), (nv,gv));\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn highest_ranked_k_items(grid: Vec<Vec<i32>>, pricing: Vec<i32>, start: Vec<i32>, k: i32) -> Vec<Vec<i32>> {\\n        let n = grid.len();\\n        let m = grid[0].len();\\n        let sri = start[0] as usize;\\n        let sci = start[1] as usize;\\n        let inf = 1_000_000_000;\\n        let mut memo = vec![vec![inf;m];n];\\n        memo[sri][sci] = 0;\\n        let mut memo2 = HashMap::new();\\n        let mut stack = vec![(sri, sci, 0)];\\n        let lv = pricing[0];\\n        let rv = pricing[1];\\n\\n        if lv <= grid[sri][sci] && grid[sri][sci] <= rv {\\n            memo2.insert((sri, sci), (0,grid[sri][sci]));\\n        }\\n\\n        while !stack.is_empty() {\\n            let mut new_stack = vec![];\\n            while let Some((r,c,v)) = stack.pop() {\\n                if 0 < r {\\n                    helper(&grid, &mut memo, &mut memo2, &mut new_stack, r-1,c,lv,rv,v);\\n                }\\n                if r < n-1 {\\n                    helper(&grid, &mut memo, &mut memo2, &mut new_stack, r+1,c,lv,rv,v);\\n                }\\n                if 0 < c {\\n                    helper(&grid, &mut memo, &mut memo2, &mut new_stack, r,c-1,lv,rv,v);\\n                }\\n                if c < m-1 {\\n                    helper(&grid, &mut memo, &mut memo2, &mut new_stack, r,c+1,lv,rv,v);\\n                }\\n            }\\n            stack = new_stack;\\n        }\\n\\n        let mut memo2 = memo2.into_iter().map(|(key,val)|  (val.0,val.1,key.0,key.1)).collect::<Vec<(i32,i32,usize,usize)>>();\\n        memo2.sort_by(|a,b| {\\n            let v1 = a.0.cmp(&b.0);\\n            if v1 == Ordering::Equal {\\n                let v2 = a.1.cmp(&b.1); \\n                if v2 == Ordering::Equal {\\n                    let v3 = a.2.cmp(&b.2); \\n                    if v3 == Ordering::Equal {\\n                        a.3.cmp(&b.3)\\n                    } else{\\n                        v3\\n                    }\\n                } else {\\n                    v2\\n                }\\n            } else {\\n                v1\\n            }\\n        });\\n        let mut result = vec![];\\n        for i in 0..k.min(memo2.len() as i32) {\\n            result.push(vec![memo2[i as usize].2 as i32, memo2[i as usize].3 as i32]);\\n        }\\n        result\\n    }  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2749186,
                "title": "bfs-sort-optimisation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& a, vector<int>& price, vector<int>& start, int K) {\\n        int n = a.size(), m = a[0].size();\\n        // bfs from start\\n        int dr[4] = {0, 0, 1, -1}, dc[4] = {1, -1, 0, 0};\\n        set<pair<int, int>> vis;        \\n        auto is_inside = [&](int i, int j){\\n            return i >= 0 and i < n and j >= 0 and j < m;        \\n        };\\n        \\n        queue<pair<int, int>> q;\\n        q.push({start[0], start[1]});\\n        vis.insert({start[0], start[1]});\\n        int dist = 0;\\n        vector<vector<int>> store;  // {dist, price, row, col}\\n        \\n        while(q.size()){\\n            int sz = q.size();\\n            \\n            if(store.size() > K){\\n                break; \\n            }\\n            // if store.size() > K then first K elements have been visited and since this iteration has dist greater than all of them hence iterations beginning from here wont produce any answer\\n            \\n            for(int i = 0; i < sz; ++i){\\n                auto top = q.front(); q.pop();\\n                int x = top.first, y = top.second;\\n                \\n                if(a[x][y] >= price[0] and a[x][y] <= price[1]){\\n                    store.push_back({dist, a[x][y], x, y});\\n                }\\n                \\n                for(int k = 0; k < 4; ++k){\\n                    int nx = x + dr[k], ny = y + dc[k];\\n                    if(is_inside(nx, ny) and a[nx][ny] != 0 and vis.count({nx, ny}) == 0){\\n                        q.push({nx, ny});\\n                        vis.insert({nx, ny});\\n                    }\\n                }\\n            }\\n            dist++; // increasing distance\\n        }\\n        sort(store.begin(), store.end());\\n        \\n        vector<vector<int>> ans;\\n        for(int i = 0; i < min(K, (int)store.size()); ++i){\\n            int x = store[i][2], y = store[i][3];\\n            ans.push_back({x, y});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& a, vector<int>& price, vector<int>& start, int K) {\\n        int n = a.size(), m = a[0].size();\\n        // bfs from start\\n        int dr[4] = {0, 0, 1, -1}, dc[4] = {1, -1, 0, 0};\\n        set<pair<int, int>> vis;        \\n        auto is_inside = [&](int i, int j){\\n            return i >= 0 and i < n and j >= 0 and j < m;        \\n        };\\n        \\n        queue<pair<int, int>> q;\\n        q.push({start[0], start[1]});\\n        vis.insert({start[0], start[1]});\\n        int dist = 0;\\n        vector<vector<int>> store;  // {dist, price, row, col}\\n        \\n        while(q.size()){\\n            int sz = q.size();\\n            \\n            if(store.size() > K){\\n                break; \\n            }\\n            // if store.size() > K then first K elements have been visited and since this iteration has dist greater than all of them hence iterations beginning from here wont produce any answer\\n            \\n            for(int i = 0; i < sz; ++i){\\n                auto top = q.front(); q.pop();\\n                int x = top.first, y = top.second;\\n                \\n                if(a[x][y] >= price[0] and a[x][y] <= price[1]){\\n                    store.push_back({dist, a[x][y], x, y});\\n                }\\n                \\n                for(int k = 0; k < 4; ++k){\\n                    int nx = x + dr[k], ny = y + dc[k];\\n                    if(is_inside(nx, ny) and a[nx][ny] != 0 and vis.count({nx, ny}) == 0){\\n                        q.push({nx, ny});\\n                        vis.insert({nx, ny});\\n                    }\\n                }\\n            }\\n            dist++; // increasing distance\\n        }\\n        sort(store.begin(), store.end());\\n        \\n        vector<vector<int>> ans;\\n        for(int i = 0; i < min(K, (int)store.size()); ++i){\\n            int x = store[i][2], y = store[i][3];\\n            ans.push_back({x, y});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700403,
                "title": "bfs-c-code-sorting-custom-comparator-on-vector",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n\\t\\t\\tvector<vector<int>>ans;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tint m = grid[0].size();\\n\\t\\t\\tvector<int>dr = {-1,1,0,0};\\n\\t\\t\\tvector<int>dc = {0,0,-1,1};\\n\\t\\t\\tvector<vector<bool>>vis(n,vector<bool>(m,false));\\n\\t\\t\\tqueue<pair<pair<int,int>,pair<int,int>>>q;\\n\\t\\t\\tq.push({{start[0],start[1]},{0,grid[start[0]][start[1]]}});\\n\\t\\t\\tint a = pricing[0];\\n\\t\\t\\tint b = pricing[1];\\n\\t\\t\\tvector<pair<int,pair<int,pair<int,int>>>>v;\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto it = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tint r = it.first.first;\\n\\t\\t\\t\\tint c = it.first.second;\\n\\t\\t\\t\\tint currDistance = it.second.first;\\n\\t\\t\\t\\tint cost = it.second.second;\\n\\t\\t\\t\\tif(cost!=1 && cost>=a && cost<=b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back({currDistance,{cost,{r,c}}});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0;i<4;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint row = r+dr[i];\\n\\t\\t\\t\\t\\tint col = c+dc[i];\\n\\t\\t\\t\\t\\tif(row>=0 && col>=0 && row<n && col<m && !vis[row][col] && grid[row][col]!=0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvis[row][col] = true;\\n\\t\\t\\t\\t\\t\\tq.push({{row,col},{currDistance+1,grid[row][col]}});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsort(v.begin(),v.end(),[&](pair<int,pair<int,pair<int,int>>>p1,pair<int,pair<int,pair<int,int>>>p2){\\n\\t\\t\\t\\tif(p1.first==p2.first)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(p1.second.first==p2.second.first)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(p1.second.second.first==p2.second.second.first)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn p1.second.second.second<p2.second.second.second;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn p1.second.second.first<p2.second.second.first;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn p1.second.first<p2.second.first;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn p1.first<p2.first;\\n\\t\\t\\t});\\n\\t\\t\\tfor(int i=0;i<v.size();i++)ans.push_back({v[i].second.second.first,v[i].second.second.second});\\n\\t\\t\\tset<vector<int>>s;\\n\\t\\t\\tfor(auto i:ans)s.insert(i);\\n\\t\\t\\tvector<vector<int>>final;\\n\\t\\t\\tfor(int i=0;i<ans.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.find(ans[i])!=s.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.erase(ans[i]);\\n\\t\\t\\t\\t\\tfinal.push_back(ans[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(final.size()>k)final.pop_back();\\n\\t\\t\\treturn final;\\n\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n\\t\\t\\tvector<vector<int>>ans;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tint m = grid[0].size();\\n\\t\\t\\tvector<int>dr = {-1,1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2691721,
                "title": "quad-tuple-priority-queue-easy-readable-c-custom-comparator-sol-bfs-pq",
                "content": "\\t\\tstruct Quad {\\n\\t\\t\\tint dist;\\n\\t\\t\\tint price;\\n\\t\\t\\tint row;\\n\\t\\t\\tint col;\\n\\t\\t};\\n\\n\\t\\tstruct comp {\\n\\t\\t\\tbool operator() (Quad &a, Quad &b) {\\n\\t\\t\\t\\tif(a.dist == b.dist) {\\n\\t\\t\\t\\t\\tif(a.price == b.price) {\\n\\t\\t\\t\\t\\t\\tif(a.row == b.row) {\\n\\t\\t\\t\\t\\t\\t\\treturn a.col > b.col;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn a.row > b.row;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn a.price > b.price;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn a.dist > b.dist;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tclass Solution {\\n\\t\\tprivate:\\n\\t\\t\\tbool isValid(int x, int y, int r, int c) {\\n\\t\\t\\t\\treturn (x >= 0 && y >= 0 && x < r && y < c);\\n\\t\\t\\t}\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n\\t\\t\\t\\tint m = grid.size(), n = grid[0].size();\\n\\t\\t\\t\\tint low = pricing[0], high = pricing[1];\\n\\n\\t\\t\\t\\tstatic int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n\\t\\t\\t\\tpriority_queue<Quad, vector<Quad>, comp> pq;\\n\\t\\t\\t\\tpq.push({0, grid[start[0]][start[1]] , start[0], start[1]});\\n\\n\\t\\t\\t\\tvector<vector<int>> vis(m, vector<int> (n, 0));\\n\\t\\t\\t\\tvector<vector<int>> res;\\n\\n\\t\\t\\t\\tvis[start[0]][start[1]] = true;\\n\\n\\t\\t\\t\\twhile(!pq.empty() && k > 0) {\\n\\t\\t\\t\\t\\tauto curr = pq.top();\\n\\t\\t\\t\\t\\tauto dist = curr.dist;\\n\\t\\t\\t\\t\\tauto price = curr.price;\\n\\t\\t\\t\\t\\tauto x = curr.row;\\n\\t\\t\\t\\t\\tauto y = curr.col;\\n\\t\\t\\t\\t\\tpq.pop();\\n\\n\\t\\t\\t\\t\\tif(price >= low && price <= high) {\\n\\t\\t\\t\\t\\t\\tk--;\\n\\t\\t\\t\\t\\t\\tres.push_back({x, y});\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor(int i = 0;i < 4;i++) {\\n\\t\\t\\t\\t\\t\\tint newX = x + dir[i][0];\\n\\t\\t\\t\\t\\t\\tint newY = y + dir[i][1];\\n\\n\\t\\t\\t\\t\\t\\tif(isValid(newX, newY, m, n) && !vis[newX][newY] && grid[newX][newY] != 0) {\\n\\t\\t\\t\\t\\t\\t\\tvis[newX][newY] = true;\\n\\t\\t\\t\\t\\t\\t\\tpq.push({dist + 1, grid[newX][newY], newX, newY});\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tprivate:\\n\\t\\t\\tbool isValid(int x, int y, int r, int c) {\\n\\t\\t\\t\\treturn (x >= 0 && y >= 0 && x < r && y < c);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2665070,
                "title": "c-beats-100-bfs-priorityqueue-using-tuples",
                "content": "Part 1: Write a custom comparer that fulfills the criteria (intuitively shown in the code where each tuple value represents distance, value, row, col, respectively)\\n\\nPart 2: Use queue BFS + visited combo to prevent revisiting. Queue keeps track of x,y and number of moves since origin\\n\\nPart 3: If the cell contains an item within ALL boundary conditions (out of bounds, price, and visited), add to our priority queue, and our custom comparer sorts it out\\n\\nPart 4: Dequeue up to k items and voila\\n\\n```\\npublic class ItemComparer : IComparer<(int,int,int,int)>\\n{\\n    public int Compare((int,int,int,int) x, (int,int,int,int) y)\\n    {\\n        if (x.Item1 > y.Item1)\\n        {\\n            return 1;\\n        }\\n        else if (x.Item1 < y.Item1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            if (x.Item2 > y.Item2)\\n            {\\n                return 1;\\n            }\\n            else if (x.Item2 < y.Item2)\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                if (x.Item3 > y.Item3)\\n                {\\n                    return 1;\\n                }\\n                else if (x.Item3 < y.Item3)\\n                {\\n                    return -1;\\n                }\\n                else\\n                {\\n                    if (x.Item4 >= y.Item4)\\n                    {\\n                        return 1;\\n                    }\\n                    else\\n                    {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\npublic class Solution \\n{\\n    public IList<IList<int>> HighestRankedKItems(int[][] grid, int[] pricing, int[] start, int k)\\n    {\\n        int[][] visited = new int[grid.Length][];\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            visited[i] = new int[grid[0].Length];\\n        }\\n        \\n        visited[start[0]][start[1]] = 1;        \\n        PriorityQueue<(int,int),(int,int,int,int)> itemRankings = \\n            new PriorityQueue<(int,int),(int,int,int,int)>(new ItemComparer());\\n        Queue<(int,int,int)> gridMove = new Queue<(int,int,int)>();\\n        gridMove.Enqueue((start[0], start[1], 0));\\n        \\n        while (gridMove.Count > 0)\\n        {\\n            (int,int,int) cur = gridMove.Dequeue();\\n            if (grid[cur.Item1][cur.Item2] >= pricing[0] && grid[cur.Item1][cur.Item2] <= pricing[1])\\n            {\\n                itemRankings.Enqueue((cur.Item1, cur.Item2), \\n                                     (cur.Item3, grid[cur.Item1][cur.Item2], cur.Item1, cur.Item2));\\n            }\\n            if (cur.Item1 - 1 >= 0 \\n                && grid[cur.Item1 - 1][cur.Item2] > 0\\n                && visited[cur.Item1 - 1][cur.Item2] == 0)\\n            {\\n                visited[cur.Item1 - 1][cur.Item2] = 1;\\n                gridMove.Enqueue((cur.Item1 - 1, cur.Item2, cur.Item3 + 1));\\n            }\\n            if (cur.Item1 + 1 < grid.Length\\n               && grid[cur.Item1 + 1][cur.Item2] > 0\\n               && visited[cur.Item1 + 1][cur.Item2] == 0)\\n            {\\n                visited[cur.Item1 + 1][cur.Item2] = 1;\\n                gridMove.Enqueue((cur.Item1 + 1, cur.Item2, cur.Item3 + 1));\\n            }\\n            if (cur.Item2 - 1 >= 0 \\n                && grid[cur.Item1][cur.Item2 - 1] > 0\\n                && visited[cur.Item1][cur.Item2 - 1] == 0)\\n            {\\n                visited[cur.Item1][cur.Item2 - 1] = 1;\\n                gridMove.Enqueue((cur.Item1, cur.Item2 - 1, cur.Item3 + 1));\\n            }\\n            if (cur.Item2 + 1 < grid[0].Length\\n               && grid[cur.Item1][cur.Item2 + 1] > 0\\n               && visited[cur.Item1][cur.Item2 + 1] == 0)\\n            {\\n                visited[cur.Item1][cur.Item2 + 1] = 1;\\n                gridMove.Enqueue((cur.Item1, cur.Item2 + 1, cur.Item3 + 1));\\n            }\\n        }\\n        \\n        IList<IList<int>> result = new List<IList<int>>();\\n        while (k > 0 && itemRankings.Count > 0)\\n        {\\n            (int,int) item = itemRankings.Dequeue();\\n            result.Add(new List<int> { item.Item1, item.Item2 });\\n            k--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class ItemComparer : IComparer<(int,int,int,int)>\\n{\\n    public int Compare((int,int,int,int) x, (int,int,int,int) y)\\n    {\\n        if (x.Item1 > y.Item1)\\n        {\\n            return 1;\\n        }\\n        else if (x.Item1 < y.Item1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            if (x.Item2 > y.Item2)\\n            {\\n                return 1;\\n            }\\n            else if (x.Item2 < y.Item2)\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                if (x.Item3 > y.Item3)\\n                {\\n                    return 1;\\n                }\\n                else if (x.Item3 < y.Item3)\\n                {\\n                    return -1;\\n                }\\n                else\\n                {\\n                    if (x.Item4 >= y.Item4)\\n                    {\\n                        return 1;\\n                    }\\n                    else\\n                    {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\npublic class Solution \\n{\\n    public IList<IList<int>> HighestRankedKItems(int[][] grid, int[] pricing, int[] start, int k)\\n    {\\n        int[][] visited = new int[grid.Length][];\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            visited[i] = new int[grid[0].Length];\\n        }\\n        \\n        visited[start[0]][start[1]] = 1;        \\n        PriorityQueue<(int,int),(int,int,int,int)> itemRankings = \\n            new PriorityQueue<(int,int),(int,int,int,int)>(new ItemComparer());\\n        Queue<(int,int,int)> gridMove = new Queue<(int,int,int)>();\\n        gridMove.Enqueue((start[0], start[1], 0));\\n        \\n        while (gridMove.Count > 0)\\n        {\\n            (int,int,int) cur = gridMove.Dequeue();\\n            if (grid[cur.Item1][cur.Item2] >= pricing[0] && grid[cur.Item1][cur.Item2] <= pricing[1])\\n            {\\n                itemRankings.Enqueue((cur.Item1, cur.Item2), \\n                                     (cur.Item3, grid[cur.Item1][cur.Item2], cur.Item1, cur.Item2));\\n            }\\n            if (cur.Item1 - 1 >= 0 \\n                && grid[cur.Item1 - 1][cur.Item2] > 0\\n                && visited[cur.Item1 - 1][cur.Item2] == 0)\\n            {\\n                visited[cur.Item1 - 1][cur.Item2] = 1;\\n                gridMove.Enqueue((cur.Item1 - 1, cur.Item2, cur.Item3 + 1));\\n            }\\n            if (cur.Item1 + 1 < grid.Length\\n               && grid[cur.Item1 + 1][cur.Item2] > 0\\n               && visited[cur.Item1 + 1][cur.Item2] == 0)\\n            {\\n                visited[cur.Item1 + 1][cur.Item2] = 1;\\n                gridMove.Enqueue((cur.Item1 + 1, cur.Item2, cur.Item3 + 1));\\n            }\\n            if (cur.Item2 - 1 >= 0 \\n                && grid[cur.Item1][cur.Item2 - 1] > 0\\n                && visited[cur.Item1][cur.Item2 - 1] == 0)\\n            {\\n                visited[cur.Item1][cur.Item2 - 1] = 1;\\n                gridMove.Enqueue((cur.Item1, cur.Item2 - 1, cur.Item3 + 1));\\n            }\\n            if (cur.Item2 + 1 < grid[0].Length\\n               && grid[cur.Item1][cur.Item2 + 1] > 0\\n               && visited[cur.Item1][cur.Item2 + 1] == 0)\\n            {\\n                visited[cur.Item1][cur.Item2 + 1] = 1;\\n                gridMove.Enqueue((cur.Item1, cur.Item2 + 1, cur.Item3 + 1));\\n            }\\n        }\\n        \\n        IList<IList<int>> result = new List<IList<int>>();\\n        while (k > 0 && itemRankings.Count > 0)\\n        {\\n            (int,int) item = itemRankings.Dequeue();\\n            result.Add(new List<int> { item.Item1, item.Item2 });\\n            k--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608564,
                "title": "python-bfs-solution",
                "content": "```\\ndef highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n\\tq = deque([(0, grid[start[0]][start[1]], start[0], start[1])])\\n\\tm, n, ans, grid[start[0]][start[1]] = len(grid), len(grid[0]), [], 0\\n\\twhile(q):\\n\\t\\td, p, x, y = q.popleft()\\n\\t\\tif pricing[0]<=p<=pricing[1]:\\n\\t\\t\\tans.append((d, p, x, y))\\n\\t\\tfor nx, ny in ((x-1, y),(x+1, y),(x, y-1),(x, y+1)):\\n\\t\\t\\tif 0<=nx<m and 0<=ny<n and grid[nx][ny]:\\n\\t\\t\\t\\tq.append((d+1, grid[nx][ny], nx, ny))\\n\\t\\t\\t\\tgrid[nx][ny] = 0\\n\\treturn [[x, y] for _, _ , x, y in sorted(ans)[:k]]\\n```",
                "solutionTags": [],
                "code": "```\\ndef highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n\\tq = deque([(0, grid[start[0]][start[1]], start[0], start[1])])\\n\\tm, n, ans, grid[start[0]][start[1]] = len(grid), len(grid[0]), [], 0\\n\\twhile(q):\\n\\t\\td, p, x, y = q.popleft()\\n\\t\\tif pricing[0]<=p<=pricing[1]:\\n\\t\\t\\tans.append((d, p, x, y))\\n\\t\\tfor nx, ny in ((x-1, y),(x+1, y),(x, y-1),(x, y+1)):\\n\\t\\t\\tif 0<=nx<m and 0<=ny<n and grid[nx][ny]:\\n\\t\\t\\t\\tq.append((d+1, grid[nx][ny], nx, ny))\\n\\t\\t\\t\\tgrid[nx][ny] = 0\\n\\treturn [[x, y] for _, _ , x, y in sorted(ans)[:k]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2600931,
                "title": "python-straightforward-bfs-sorting-easy-to-understand-beats-97",
                "content": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        numRows, numCols, queue = len(grid), len(grid[0]), deque()\\n        distance, visited = [[math.inf] * numCols for _ in range(numRows)], [[0] * numCols for _ in range(numRows)]\\n        directions, validPaths = [[1, 0], [-1, 0], [0, 1], [0, -1]], []\\n        queue.append(tuple(start))\\n        visited[start[0]][start[1]], distance[start[0]][start[1]] = 1, 0\\n        while queue:\\n            size = len(queue)\\n            for i in range(size):\\n                row, col = queue.popleft()\\n                for direction in directions:\\n                    newRow, newCol = row + direction[0], col + direction[1]\\n                    if newRow >= 0 and newRow < numRows and newCol >= 0 and newCol < numCols and not visited[newRow][newCol] and grid[newRow][newCol] != 0:\\n                        visited[newRow][newCol], distance[newRow][newCol] = 1, distance[row][col] + 1\\n                        queue.append((newRow, newCol))\\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] >= pricing[0] and grid[row][col] <= pricing[1] and distance[row][col] != math.inf:\\n                    validPaths.append((distance[row][col], grid[row][col], row, col))\\n        validPaths = list(sorted(validPaths, key = lambda path: (path[0], path[1], path[2])))\\n        ans, numPaths = [], len(validPaths)\\n        for index in range(min(k, numPaths)):\\n            ans.append((validPaths[index][2], validPaths[index][3]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        numRows, numCols, queue = len(grid), len(grid[0]), deque()\\n        distance, visited = [[math.inf] * numCols for _ in range(numRows)], [[0] * numCols for _ in range(numRows)]\\n        directions, validPaths = [[1, 0], [-1, 0], [0, 1], [0, -1]], []\\n        queue.append(tuple(start))\\n        visited[start[0]][start[1]], distance[start[0]][start[1]] = 1, 0\\n        while queue:\\n            size = len(queue)\\n            for i in range(size):\\n                row, col = queue.popleft()\\n                for direction in directions:\\n                    newRow, newCol = row + direction[0], col + direction[1]\\n                    if newRow >= 0 and newRow < numRows and newCol >= 0 and newCol < numCols and not visited[newRow][newCol] and grid[newRow][newCol] != 0:\\n                        visited[newRow][newCol], distance[newRow][newCol] = 1, distance[row][col] + 1\\n                        queue.append((newRow, newCol))\\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] >= pricing[0] and grid[row][col] <= pricing[1] and distance[row][col] != math.inf:\\n                    validPaths.append((distance[row][col], grid[row][col], row, col))\\n        validPaths = list(sorted(validPaths, key = lambda path: (path[0], path[1], path[2])))\\n        ans, numPaths = [], len(validPaths)\\n        for index in range(min(k, numPaths)):\\n            ans.append((validPaths[index][2], validPaths[index][3]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585358,
                "title": "simple-and-clean-sol-with-functions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > v;\\n    int n,m;\\n    bool isValid(int i,int j)\\n    {\\n        return (i<0||j<0||i>=n||j>=m);\\n    }\\n    vector<pair<int,int>> mov={\\n        {-1,0},{1,0},{0,1},{0,-1}\\n    };\\n    void bfs(int i,int j,int l,int h,vector<vector<int> > &g)\\n    {\\n        vector<vector<int> > lev(n,vector<int>(m,0));\\n        queue<pair<int,int> > q;\\n        q.push({i,j});\\n         if(g[i][j]!=1&&(g[i][j]>=l&&g[i][j]<=h))\\n         {\\n             v.push_back({lev[i][j],g[i][j],i,j});\\n         }\\n        while(!q.empty())\\n        {\\n            pair<int,int> p=q.front();\\n            q.pop();\\n            for(auto x: mov)\\n            {\\n                int x1=x.first+p.first;\\n                int x2=x.second+p.second;\\n                if((!isValid(x1,x2)) && g[x1][x2]!=0)\\n                {\\n                    if((x1==i&&x2==j)||lev[x1][x2])continue;\\n                    lev[x1][x2]=1+lev[p.first][p.second];\\n                    q.push({x1,x2});\\n                    if(g[x1][x2]==1||(g[x1][x2]<l||g[x1][x2]>h))continue;\\n                    v.push_back({lev[x1][x2],g[x1][x2],x1,x2});\\n                    \\n                }\\n            }\\n        }\\n        \\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& g, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int> > ans;\\n        n=g.size();\\n        m=g[0].size();\\n        bfs(start[0],start[1],pricing[0],pricing[1],g);\\n        sort(begin(v),end(v));\\n        for(auto x: v)\\n        {\\n            if(k==0)break;\\n            ans.push_back({x[2],x[3]});\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > v;\\n    int n,m;\\n    bool isValid(int i,int j)\\n    {\\n        return (i<0||j<0||i>=n||j>=m);\\n    }\\n    vector<pair<int,int>> mov={\\n        {-1,0},{1,0},{0,1},{0,-1}\\n    };\\n    void bfs(int i,int j,int l,int h,vector<vector<int> > &g)\\n    {\\n        vector<vector<int> > lev(n,vector<int>(m,0));\\n        queue<pair<int,int> > q;\\n        q.push({i,j});\\n         if(g[i][j]!=1&&(g[i][j]>=l&&g[i][j]<=h))\\n         {\\n             v.push_back({lev[i][j],g[i][j],i,j});\\n         }\\n        while(!q.empty())\\n        {\\n            pair<int,int> p=q.front();\\n            q.pop();\\n            for(auto x: mov)\\n            {\\n                int x1=x.first+p.first;\\n                int x2=x.second+p.second;\\n                if((!isValid(x1,x2)) && g[x1][x2]!=0)\\n                {\\n                    if((x1==i&&x2==j)||lev[x1][x2])continue;\\n                    lev[x1][x2]=1+lev[p.first][p.second];\\n                    q.push({x1,x2});\\n                    if(g[x1][x2]==1||(g[x1][x2]<l||g[x1][x2]>h))continue;\\n                    v.push_back({lev[x1][x2],g[x1][x2],x1,x2});\\n                    \\n                }\\n            }\\n        }\\n        \\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& g, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int> > ans;\\n        n=g.size();\\n        m=g[0].size();\\n        bfs(start[0],start[1],pricing[0],pricing[1],g);\\n        sort(begin(v),end(v));\\n        for(auto x: v)\\n        {\\n            if(k==0)break;\\n            ans.push_back({x[2],x[3]});\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518182,
                "title": "straightforward-c-solution-bfs-customized-sort",
                "content": "Program is made up of two parts:\\n* get all satisfied items (terminate when at least `k` items have been found\\n* define customized sort and sort the previous vector `all`\\n* return `max(k, all.size())` items from the sorted array `all`, which is the correct result\\n```\\nclass Solution {\\n    int dx[4] = {-1, 0, 0, 1};\\n    int dy[4] = {0, -1, 1, 0};\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\\n        dist[start[0]][start[1]] = 0;\\n        queue<pair<int, int>> q;\\n        vector<pair<int, int>> all;\\n        int count = 0;\\n        if (grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1]) {\\n            all.push_back({start[0], start[1]});\\n            count++;\\n        }\\n        q.push({start[0], start[1]});\\n        while (!q.empty() && count < k) { // get all the satisfied item throughout BFS\\n            int size = q.size();\\n            while (size--) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for (int i = 0; i < 4; i++) {\\n                    int nx = x + dx[i], ny = y + dy[i];\\n                    if (nx < 0 || nx >= m || ny < 0 || ny >= n)\\n                        continue;\\n                    if (dist[nx][ny] < INT_MAX)\\n                        continue;\\n                    if (grid[nx][ny] == 0)\\n                        continue;\\n                    dist[nx][ny] = dist[x][y] + 1;\\n                    q.push({nx, ny});\\n                    if (grid[nx][ny] >= pricing[0] && grid[nx][ny] <= pricing[1]) {\\n                        all.push_back({nx, ny});\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        auto cmp = [&](const pair<int, int> &a, const pair<int, int> &b) { // customized comparator\\n            if (dist[a.first][a.second] != dist[b.first][b.second]) // 1. distance\\n                return dist[a.first][a.second] < dist[b.first][b.second]; // 2. price\\n            if (grid[a.first][a.second] != grid[b.first][b.second]) // 3. row number\\n                return grid[a.first][a.second] < grid[b.first][b.second]; // 4. column number\\n            if (a.first != b.first)\\n                return a.first < b.first;\\n            return a.second < b.second;\\n        };\\n        sort(all.begin(), all.end(), cmp);\\n        vector<vector<int>> res;\\n        for (int i = 0; i < min(k, (int)all.size()); i++) {\\n            res.push_back({all[i].first, all[i].second});\\n        }\\n        return res;\\n    }\\n};\\n```\\nTime Complexity: `O(m*n*log(min{k, m*n}))`\\nSpace Complexity: `O(m*n)`",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int dx[4] = {-1, 0, 0, 1};\\n    int dy[4] = {0, -1, 1, 0};\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\\n        dist[start[0]][start[1]] = 0;\\n        queue<pair<int, int>> q;\\n        vector<pair<int, int>> all;\\n        int count = 0;\\n        if (grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1]) {\\n            all.push_back({start[0], start[1]});\\n            count++;\\n        }\\n        q.push({start[0], start[1]});\\n        while (!q.empty() && count < k) { // get all the satisfied item throughout BFS\\n            int size = q.size();\\n            while (size--) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for (int i = 0; i < 4; i++) {\\n                    int nx = x + dx[i], ny = y + dy[i];\\n                    if (nx < 0 || nx >= m || ny < 0 || ny >= n)\\n                        continue;\\n                    if (dist[nx][ny] < INT_MAX)\\n                        continue;\\n                    if (grid[nx][ny] == 0)\\n                        continue;\\n                    dist[nx][ny] = dist[x][y] + 1;\\n                    q.push({nx, ny});\\n                    if (grid[nx][ny] >= pricing[0] && grid[nx][ny] <= pricing[1]) {\\n                        all.push_back({nx, ny});\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        auto cmp = [&](const pair<int, int> &a, const pair<int, int> &b) { // customized comparator\\n            if (dist[a.first][a.second] != dist[b.first][b.second]) // 1. distance\\n                return dist[a.first][a.second] < dist[b.first][b.second]; // 2. price\\n            if (grid[a.first][a.second] != grid[b.first][b.second]) // 3. row number\\n                return grid[a.first][a.second] < grid[b.first][b.second]; // 4. column number\\n            if (a.first != b.first)\\n                return a.first < b.first;\\n            return a.second < b.second;\\n        };\\n        sort(all.begin(), all.end(), cmp);\\n        vector<vector<int>> res;\\n        for (int i = 0; i < min(k, (int)all.size()); i++) {\\n            res.push_back({all[i].first, all[i].second});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505081,
                "title": "c-solution-simple-bfs-solution",
                "content": "class Solution {\\nprivate:\\n    vector<vector<int>>dir = {{0,1},{1,0},{-1,0},{0,-1}};\\npublic:\\n*     vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int>>temp;\\n        vector<vector<int>>vis(grid.size(), vector<int>(grid[0].size(),0));\\n        bfs(grid, start[0],start[1],pricing[0],pricing[1],vis,temp,grid.size(),grid[0].size());\\n        vector<vector<int>>ans;\\n        vector<vector<int>>finalanswer;\\n        for(int i = 0;i < temp.size(); i++)\\n        {\\n            if(grid[temp[i][0]][temp[i][1]] != 1 && (temp[i][3] >= pricing[0] && temp[i][3] <= pricing[1]))\\n            {\\n                ans.push_back(temp[i]);\\n            }\\n        }\\n        sort(ans.begin(),ans.end(),cmp);\\n        int size = ans.size();\\n        for(int i = 0;i < min(k,size); i++)\\n        {\\n            finalanswer.push_back({ans[i][0],ans[i][1]});\\n        }\\n        return finalanswer;\\n    }\\n    \\n*     static bool cmp(vector<int>& a, vector<int>& b) {\\n        if(a[2] < b[2])\\n        {\\n            return true;\\n        }else\\n        {\\n            if(a[2] > b[2])\\n            {\\n                return false;\\n            }\\n            if(a[2] == b[2])\\n            {\\n                if(a[3] < b[3])\\n                {\\n                    return true;\\n                }else\\n                {\\n                    if(a[3] > b[3])\\n                    {\\n                        return false;\\n                    }\\n                    if(a[3] == b[3])\\n                    {\\n                        if(a[0] < b[0])\\n                        {\\n                            return true;\\n                        }else\\n                        {\\n                            if(a[0] > b[0])\\n                            {\\n                                return false;\\n                            }\\n                            if(a[0] == b[0])\\n                            {\\n                                if(a[1] < b[1])\\n                                {\\n                                    return true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n*     void bfs(vector<vector<int>>& grid, int& startx, int& starty, int& startprice, int& endprice, vector<vector<int>>& vis,vector<vector<int>>& ans,int row, int col){\\n        vis[startx][starty] = 1;\\n        queue<vector<int>>q;\\n        q.push({startx,starty,0,grid[startx][starty]});\\n        ans.push_back({startx,starty,0,grid[startx][starty]});\\n        while(!q.empty())\\n        {\\n            vector<int>temp = q.front();\\n            int currd = temp[2];\\n            int x = temp[0];\\n            int y = temp[1];\\n            q.pop();\\n            for(int i = 0;i < 4; i++)\\n            {\\n                int nx = x+dir[i][0];\\n                int ny = y+dir[i][1];\\n                if(nx >= 0 && nx < row && ny >= 0 && ny < col && vis[nx][ny] == 0 && grid[nx][ny] != 0)\\n                {\\n                    ans.push_back({nx,ny,currd+1,grid[nx][ny]});\\n                    vis[nx][ny] = 1;\\n                    q.push({nx,ny,currd+1,grid[nx][ny]});\\n                }\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<vector<int>>dir = {{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2489165,
                "title": "use-bfs-with-sorting",
                "content": "```\\n\"\"\"\\nwe can solve this problem using bfs\\n\"\"\"\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        visited = set()\\n        que = deque()\\n        sr, sc = start[:]\\n        que.append((grid[sr][sc], sr, sc))\\n        visited.add(tuple(start))\\n        ans = []\\n        \\n        def get_neighbors(i, j):\\n            return [(i-1,j), (i,j-1), (i,j+1), (i+1,j)]\\n        \\n        def is_valid(i, j):\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        while len(que):\\n            temp = []\\n            for _ in range(len(que)):\\n                price, i, j = que.popleft()\\n                temp.append((price, i, j))\\n                \\n                for nei in get_neighbors(i,j):\\n                    x,y = nei\\n                    if is_valid(x,y) and nei not in visited and grid[x][y] != 0:\\n                        que.append((grid[x][y], x, y))\\n                        visited.add(nei)\\n                        \\n            temp = sorted(temp, key=lambda x: (x[0], x[1], x[2]))\\n            for elem in temp:\\n                price, i, j = elem\\n                if pricing[0] <= price <= pricing[1]:\\n                    ans.append([i,j])\\n                    if len(ans) == k:\\n                        return ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\n\"\"\"\\nwe can solve this problem using bfs\\n\"\"\"\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        visited = set()\\n        que = deque()\\n        sr, sc = start[:]\\n        que.append((grid[sr][sc], sr, sc))\\n        visited.add(tuple(start))\\n        ans = []\\n        \\n        def get_neighbors(i, j):\\n            return [(i-1,j), (i,j-1), (i,j+1), (i+1,j)]\\n        \\n        def is_valid(i, j):\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        while len(que):\\n            temp = []\\n            for _ in range(len(que)):\\n                price, i, j = que.popleft()\\n                temp.append((price, i, j))\\n                \\n                for nei in get_neighbors(i,j):\\n                    x,y = nei\\n                    if is_valid(x,y) and nei not in visited and grid[x][y] != 0:\\n                        que.append((grid[x][y], x, y))\\n                        visited.add(nei)\\n                        \\n            temp = sorted(temp, key=lambda x: (x[0], x[1], x[2]))\\n            for elem in temp:\\n                price, i, j = elem\\n                if pricing[0] <= price <= pricing[1]:\\n                    ans.append([i,j])\\n                    if len(ans) == k:\\n                        return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2476755,
                "title": "easy-c-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& g, vector<int>& p, vector<int>& start, int k) {\\n        priority_queue<vector<int>> pq;\\n        queue<vector<int>> q;\\n        q.push(start);\\n        int c=0;\\n        vector<vector<bool>> vis(g.size(),vector<bool> (g[0].size()));\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            while(s--)\\n            {\\n                int i=q.front()[0],j=q.front()[1];\\n                q.pop();\\n                if(vis[i][j])\\n                    continue;\\n                vis[i][j]=true;\\n                if(g[i][j]>=p[0] && g[i][j]<=p[1])\\n                    pq.push({c,g[i][j],i,j});\\n                while(pq.size()>k)\\n                    pq.pop();\\n                if(i+1<g.size() && i>=0 &&  j>=0 && j<g[0].size() && g[i+1][j]!=0 && !vis[i+1][j])\\n                q.push({i+1,j});\\n                if(i<g.size() && i-1>=0 &&  j>=0 && j<g[0].size() && g[i-1][j]!=0 && !vis[i-1][j])\\n                q.push({i-1,j});\\n                if(i<g.size() && i>=0 &&  j>=0 && j+1<g[0].size() && g[i][j+1]!=0 && !vis[i][j+1])\\n                q.push({i,j+1});\\n                if(i<g.size() && i>=0 &&  j-1>=0 && j<g[0].size() && g[i][j-1]!=0 && !vis[i][j-1])\\n                q.push({i,j-1});\\n            }\\n            if(pq.size()>=k)\\n                break;\\n            c++;\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty())\\n        {\\n            vector<int> b=pq.top();\\n            pq.pop();\\n            ans.push_back({b[2],b[3]});\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& g, vector<int>& p, vector<int>& start, int k) {\\n        priority_queue<vector<int>> pq;\\n        queue<vector<int>> q;\\n        q.push(start);\\n        int c=0;\\n        vector<vector<bool>> vis(g.size(),vector<bool> (g[0].size()));\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            while(s--)\\n            {\\n                int i=q.front()[0],j=q.front()[1];\\n                q.pop();\\n                if(vis[i][j])\\n                    continue;\\n                vis[i][j]=true;\\n                if(g[i][j]>=p[0] && g[i][j]<=p[1])\\n                    pq.push({c,g[i][j],i,j});\\n                while(pq.size()>k)\\n                    pq.pop();\\n                if(i+1<g.size() && i>=0 &&  j>=0 && j<g[0].size() && g[i+1][j]!=0 && !vis[i+1][j])\\n                q.push({i+1,j});\\n                if(i<g.size() && i-1>=0 &&  j>=0 && j<g[0].size() && g[i-1][j]!=0 && !vis[i-1][j])\\n                q.push({i-1,j});\\n                if(i<g.size() && i>=0 &&  j>=0 && j+1<g[0].size() && g[i][j+1]!=0 && !vis[i][j+1])\\n                q.push({i,j+1});\\n                if(i<g.size() && i>=0 &&  j-1>=0 && j<g[0].size() && g[i][j-1]!=0 && !vis[i][j-1])\\n                q.push({i,j-1});\\n            }\\n            if(pq.size()>=k)\\n                break;\\n            c++;\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty())\\n        {\\n            vector<int> b=pq.top();\\n            pq.pop();\\n            ans.push_back({b[2],b[3]});\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473843,
                "title": "intuitive-python-solution-w-bfs-and-heap",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        q = deque([start + [0]])\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        h = []\\n        \\n        while q:\\n            x, y, d = q.popleft()\\n            if grid[x][y] > 0:\\n                price = grid[x][y]\\n                if price in range(pricing[0], pricing[1] + 1):\\n                    heapq.heappush(h, [-d, -price, -x, -y])\\n                    if len(h) > k:\\n                        heapq.heappop(h)\\n                grid[x][y] = -1\\n                for dx, dy in dirs:\\n                    X = x + dx\\n                    Y = y + dy\\n                    if X in range(0, m) and Y in range(0, n) and (X, Y):\\n                        q.append([X, Y, d+1])\\n        ans = []\\n        while h:\\n            _, _, r, c = heapq.heappop(h)\\n            ans.append([-r, -c])\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        q = deque([start + [0]])\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        h = []\\n        \\n        while q:\\n            x, y, d = q.popleft()\\n            if grid[x][y] > 0:\\n                price = grid[x][y]\\n                if price in range(pricing[0], pricing[1] + 1):\\n                    heapq.heappush(h, [-d, -price, -x, -y])\\n                    if len(h) > k:\\n                        heapq.heappop(h)\\n                grid[x][y] = -1\\n                for dx, dy in dirs:\\n                    X = x + dx\\n                    Y = y + dy\\n                    if X in range(0, m) and Y in range(0, n) and (X, Y):\\n                        q.append([X, Y, d+1])\\n        ans = []\\n        while h:\\n            _, _, r, c = heapq.heappop(h)\\n            ans.append([-r, -c])\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417861,
                "title": "c-solution-using-bfs-and-sorting",
                "content": "```\\nvector<int>dx = {-1, 0, 1, 0};\\nvector<int>dy = {0, 1, 0, -1};\\n\\nstruct Ds {\\n    int dist, price, row, col;\\n    Ds(int _dist, int _price, int _row, int _col) {\\n        dist = _dist;\\n        price = _price;\\n        row = _row;\\n        col = _col;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void bfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& distance) {\\n        queue<pair<int,int>>q;\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        q.push({i, j});\\n        distance[i][j] = 0;\\n        \\n        while(!q.empty()) {\\n            auto [x, y] = q.front();\\n            q.pop();\\n            \\n            for(int idx = 0; idx < 4; idx++) {\\n                int newX = x + dx[idx];\\n                int newY = y + dy[idx];\\n                if(newX < 0 || newY < 0 || newX >= n || newY >= m || grid[newX][newY] == 0) continue;\\n                if(distance[newX][newY] == -1) {\\n                    distance[newX][newY] = 1 + distance[x][y];\\n                    q.push({newX, newY});\\n                }\\n            }  \\n        }  \\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>distance(n, vector<int>(m, -1));\\n        \\n        bfs(start[0], start[1], grid, distance);\\n        \\n        vector<Ds>ans;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 0) continue;\\n                if(distance[i][j] == -1) continue;\\n                else {\\n                    int dist = distance[i][j];\\n                    int price = grid[i][j];\\n                    int row = i;\\n                    int col = j;\\n                    if(price <= pricing[1] && price >= pricing[0]) {\\n                        Ds temp(dist, price, row, col);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        sort(ans.begin(), ans.end(), [](Ds d1, Ds d2){\\n            if(d1.dist != d2.dist) return d1.dist <d2.dist;\\n            else if(d1.price != d2.price) return d1.price <d2.price;\\n            else if(d1.row != d2.row) return d1.row < d2.row;\\n            return d1.col <= d2.col;\\n        });\\n        \\n        vector<vector<int>>res;\\n        \\n        for(int i = 0; i < min((int)ans.size(), k); i++) {\\n            res.push_back({ans[i].row, ans[i].col});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nvector<int>dx = {-1, 0, 1, 0};\\nvector<int>dy = {0, 1, 0, -1};\\n\\nstruct Ds {\\n    int dist, price, row, col;\\n    Ds(int _dist, int _price, int _row, int _col) {\\n        dist = _dist;\\n        price = _price;\\n        row = _row;\\n        col = _col;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void bfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& distance) {\\n        queue<pair<int,int>>q;\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        q.push({i, j});\\n        distance[i][j] = 0;\\n        \\n        while(!q.empty()) {\\n            auto [x, y] = q.front();\\n            q.pop();\\n            \\n            for(int idx = 0; idx < 4; idx++) {\\n                int newX = x + dx[idx];\\n                int newY = y + dy[idx];\\n                if(newX < 0 || newY < 0 || newX >= n || newY >= m || grid[newX][newY] == 0) continue;\\n                if(distance[newX][newY] == -1) {\\n                    distance[newX][newY] = 1 + distance[x][y];\\n                    q.push({newX, newY});\\n                }\\n            }  \\n        }  \\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>distance(n, vector<int>(m, -1));\\n        \\n        bfs(start[0], start[1], grid, distance);\\n        \\n        vector<Ds>ans;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 0) continue;\\n                if(distance[i][j] == -1) continue;\\n                else {\\n                    int dist = distance[i][j];\\n                    int price = grid[i][j];\\n                    int row = i;\\n                    int col = j;\\n                    if(price <= pricing[1] && price >= pricing[0]) {\\n                        Ds temp(dist, price, row, col);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        sort(ans.begin(), ans.end(), [](Ds d1, Ds d2){\\n            if(d1.dist != d2.dist) return d1.dist <d2.dist;\\n            else if(d1.price != d2.price) return d1.price <d2.price;\\n            else if(d1.row != d2.row) return d1.row < d2.row;\\n            return d1.col <= d2.col;\\n        });\\n        \\n        vector<vector<int>>res;\\n        \\n        for(int i = 0; i < min((int)ans.size(), k); i++) {\\n            res.push_back({ans[i].row, ans[i].col});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406609,
                "title": "cpp-bfs-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int stx,sty;\\n    int low,high;\\n    vector<vector<int>> dir = {{0,1},{1,0},{-1,0},{0,-1}};\\n    bool isValid(vector<vector<int>>& grid,int x,int y,vector<vector<int>> &vis){\\n        int n =grid.size();\\n        int m = grid[0].size();\\n        if(x>=0 and x<n and y>=0 and y<m and grid[x][y]!=0 and !vis[x][y]){\\n            return true;\\n        }\\n        return false;\\n    }\\n    static bool comp(vector<int> &a,vector<int> &b){\\n        if(a[0]!=b[0]){\\n            return a[0]<b[0];\\n        }\\n        if(a[1]!=b[1]){\\n            return a[1]<b[1];\\n        }\\n        if(a[2]!=b[2]){\\n            return a[2]<b[2];\\n        }\\n        return a[3]<b[3];\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int>> ans;\\n        stx = start[0];\\n        sty = start[1];\\n        low = pricing[0];\\n        high = pricing[1];\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        \\n        \\n        queue<int> row;\\n        queue<int> col;\\n        row.push(stx);\\n        col.push(sty);\\n        vis[stx][sty]=1;\\n        int i = 1;\\n        int j = 0;\\n        int d = 0;\\n        while(!row.empty()){\\n            int r = row.front();\\n            int c = col.front();\\n            row.pop();\\n            col.pop();\\n            if(grid[r][c]!=1 and grid[r][c]<=high and grid[r][c]>=low){\\n                ans.push_back({d,grid[r][c],r,c});\\n            }\\n            i--;\\n            for(auto d:dir){\\n                if(isValid(grid,r+d[0],c+d[1],vis)){\\n                    vis[r+d[0]][c+d[1]]=1;\\n                    row.push(r+d[0]);\\n                    col.push(c+d[1]);\\n                    j++;\\n                }\\n            }\\n            if(i==0){\\n                i = j;\\n                j = 0;\\n                d++;\\n            }\\n            \\n        }\\n        sort(ans.begin(),ans.end(),comp);\\n        vector<vector<int>> anss;\\n        for(int i=0;i<min(k,(int)ans.size());i++){\\n            anss.push_back({ans[i][2],ans[i][3]});\\n        }\\n        return anss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stx,sty;\\n    int low,high;\\n    vector<vector<int>> dir = {{0,1},{1,0},{-1,0},{0,-1}};\\n    bool isValid(vector<vector<int>>& grid,int x,int y,vector<vector<int>> &vis){\\n        int n =grid.size();\\n        int m = grid[0].size();\\n        if(x>=0 and x<n and y>=0 and y<m and grid[x][y]!=0 and !vis[x][y]){\\n            return true;\\n        }\\n        return false;\\n    }\\n    static bool comp(vector<int> &a,vector<int> &b){\\n        if(a[0]!=b[0]){\\n            return a[0]<b[0];\\n        }\\n        if(a[1]!=b[1]){\\n            return a[1]<b[1];\\n        }\\n        if(a[2]!=b[2]){\\n            return a[2]<b[2];\\n        }\\n        return a[3]<b[3];\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int>> ans;\\n        stx = start[0];\\n        sty = start[1];\\n        low = pricing[0];\\n        high = pricing[1];\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        \\n        \\n        queue<int> row;\\n        queue<int> col;\\n        row.push(stx);\\n        col.push(sty);\\n        vis[stx][sty]=1;\\n        int i = 1;\\n        int j = 0;\\n        int d = 0;\\n        while(!row.empty()){\\n            int r = row.front();\\n            int c = col.front();\\n            row.pop();\\n            col.pop();\\n            if(grid[r][c]!=1 and grid[r][c]<=high and grid[r][c]>=low){\\n                ans.push_back({d,grid[r][c],r,c});\\n            }\\n            i--;\\n            for(auto d:dir){\\n                if(isValid(grid,r+d[0],c+d[1],vis)){\\n                    vis[r+d[0]][c+d[1]]=1;\\n                    row.push(r+d[0]);\\n                    col.push(c+d[1]);\\n                    j++;\\n                }\\n            }\\n            if(i==0){\\n                i = j;\\n                j = 0;\\n                d++;\\n            }\\n            \\n        }\\n        sort(ans.begin(),ans.end(),comp);\\n        vector<vector<int>> anss;\\n        for(int i=0;i<min(k,(int)ans.size());i++){\\n            anss.push_back({ans[i][2],ans[i][3]});\\n        }\\n        return anss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381708,
                "title": "python-3-bfs-priority-queue",
                "content": "\\tclass Solution:\\n\\t\\tdef highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n\\t\\t\\tn,m=len(grid),len(grid[0])\\n\\t\\t\\tres=[]\\n\\t\\t\\theapify(res)\\n\\t\\t\\tq=[start]\\n\\t\\t\\tvis=[[False]*m for _ in range(n)]\\n\\t\\t\\tvis[start[0]][start[1]]=True\\n\\t\\t\\td=0\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tnew_q=[]\\n\\t\\t\\t\\tfor x,y in q:\\n\\t\\t\\t\\t\\tif pricing[0]<=grid[x][y]<=pricing[1]:\\n\\t\\t\\t\\t\\t\\theappush(res,[-d,-grid[x][y],-x,-y])\\n\\t\\t\\t\\t\\tif len(res)>k:\\n\\t\\t\\t\\t\\t\\theappop(res)\\n\\t\\t\\t\\t\\tfor i,j in [(x+1,y),(x,y+1),(x-1,y),(x,y-1)]:\\n\\t\\t\\t\\t\\t\\tif 0<=i<n and 0<=j<m and not vis[i][j] and grid[i][j]:\\n\\t\\t\\t\\t\\t\\t\\tvis[i][j]=True\\n\\t\\t\\t\\t\\t\\t\\tnew_q.append([i,j])\\n\\t\\t\\t\\tq=new_q\\n\\t\\t\\t\\td+=1\\n\\t\\t\\tres=[[-x,-y] for _,_,x,y in sorted(res,reverse=True)]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n\\t\\t\\tn,m=len(grid),len(grid[0])\\n\\t\\t\\tres=[]\\n\\t\\t\\theapify(res)\\n\\t\\t\\tq=[start]\\n\\t\\t\\tvis=[[False]*m for _ in range(n)]\\n\\t\\t\\tvis[start[0]][start[1]]=True\\n\\t\\t\\td=0\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tnew_q=[]\\n\\t\\t\\t\\tfor x,y in q:\\n\\t\\t\\t\\t\\tif pricing[0]<=grid[x][y]<=pricing[1]:\\n\\t\\t\\t\\t\\t\\theappush(res,[-d,-grid[x][y],-x,-y])\\n\\t\\t\\t\\t\\tif len(res)>k:\\n\\t\\t\\t\\t\\t\\theappop(res)\\n\\t\\t\\t\\t\\tfor i,j in [(x+1,y),(x,y+1),(x-1,y),(x,y-1)]:\\n\\t\\t\\t\\t\\t\\tif 0<=i<n and 0<=j<m and not vis[i][j] and grid[i][j]:\\n\\t\\t\\t\\t\\t\\t\\tvis[i][j]=True\\n\\t\\t\\t\\t\\t\\t\\tnew_q.append([i,j])\\n\\t\\t\\t\\tq=new_q\\n\\t\\t\\t\\td+=1\\n\\t\\t\\tres=[[-x,-y] for _,_,x,y in sorted(res,reverse=True)]\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2360981,
                "title": "c-simple-c-code-97-time-89-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        priority_queue<pair<int,pair<int,pair<int, int>>>, vector<pair<int,pair<int,pair<int, int>>>>, greater<pair<int,pair<int,pair<int, int>>>>> pq;\\n        int dirx[4] = {-1,1,0,0};\\n        int diry[4] = {0,0,-1,1};\\n        queue<pair<int,pair<int,int>>> q;\\n        vector<vector<int>> ans;\\n        q.push({grid[start[0]][start[1]],{start[0],start[1]}});\\n        grid[start[0]][start[1]] = 0;\\n        int pl = pricing[0], ph = pricing[1];\\n        int n = grid.size(), m = grid[0].size();\\n        int dist = 0;\\n        while(!q.empty())\\n        {\\n            dist++;\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                pair<int,pair<int, int>> xy = q.front();\\n                q.pop();\\n                int val = xy.first;\\n                int x = xy.second.first;\\n                int y = xy.second.second;\\n                if(pl <= val && val <= ph)\\n                {\\n                    pq.push({dist,{val,{x,y}}});\\n                }\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int nxtx = x + dirx[i];\\n                    int nxty = y + diry[i];\\n                    if(nxtx < 0 || nxtx >= n || nxty < 0 || nxty >= m) continue;\\n                    if(grid[nxtx][nxty] == 0) continue;\\n                    q.push({grid[nxtx][nxty],{nxtx,nxty}});\\n                    grid[nxtx][nxty] = 0;\\n                }\\n            }   \\n        }\\n        while(!pq.empty() && k--)\\n        {\\n            pair<int,pair<int,pair<int, int>>> tp = pq.top();\\n            pq.pop();\\n            ans.push_back({tp.second.second.first, tp.second.second.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        priority_queue<pair<int,pair<int,pair<int, int>>>, vector<pair<int,pair<int,pair<int, int>>>>, greater<pair<int,pair<int,pair<int, int>>>>> pq;\\n        int dirx[4] = {-1,1,0,0};\\n        int diry[4] = {0,0,-1,1};\\n        queue<pair<int,pair<int,int>>> q;\\n        vector<vector<int>> ans;\\n        q.push({grid[start[0]][start[1]],{start[0],start[1]}});\\n        grid[start[0]][start[1]] = 0;\\n        int pl = pricing[0], ph = pricing[1];\\n        int n = grid.size(), m = grid[0].size();\\n        int dist = 0;\\n        while(!q.empty())\\n        {\\n            dist++;\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                pair<int,pair<int, int>> xy = q.front();\\n                q.pop();\\n                int val = xy.first;\\n                int x = xy.second.first;\\n                int y = xy.second.second;\\n                if(pl <= val && val <= ph)\\n                {\\n                    pq.push({dist,{val,{x,y}}});\\n                }\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int nxtx = x + dirx[i];\\n                    int nxty = y + diry[i];\\n                    if(nxtx < 0 || nxtx >= n || nxty < 0 || nxty >= m) continue;\\n                    if(grid[nxtx][nxty] == 0) continue;\\n                    q.push({grid[nxtx][nxty],{nxtx,nxty}});\\n                    grid[nxtx][nxty] = 0;\\n                }\\n            }   \\n        }\\n        while(!pq.empty() && k--)\\n        {\\n            pair<int,pair<int,pair<int, int>>> tp = pq.top();\\n            pq.pop();\\n            ans.push_back({tp.second.second.first, tp.second.second.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321397,
                "title": "95-efficient-solution-c",
                "content": "**Logic**\\n1. Traverse BFS for each item\\n2. Maintain a priority queue for adding elements and simultaneously sorting them based on the given conditions\\n3. Push in priority queue elements being popped from queue if they have valid price\\n4. Pop the first k elements of priority queue into array and return\\n\\n```\\nclass Solution {\\n    int INF = 1e6;\\npublic:\\n    struct Item{\\n      int price,x,y,dist;\\n        \\n      Item(int i, int j, int d, int p){\\n          x = i; y = j; dist = d; price = p;\\n      }\\n    };\\n    \\n    struct comp{\\n        bool operator()(const struct Item* a, const struct Item* b){\\n            if(a->dist < b->dist) return false;\\n            else if(a->dist == b->dist){\\n                if(a->price < b->price) return false;\\n                else if(a->price == b->price){\\n                    if(a->x < b->x) return false;\\n                    else if(a->x == b->x && a->y < b->y) return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n    };\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        queue<Item*> q;\\n        int p = INF;\\n        if(grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1])\\n            p = grid[start[0]][start[1]];\\n        q.push(new Item(start[0],start[1],0,p));\\n        \\n        int cord_x[] = {-1,1,0,0};\\n        int cord_y[] = {0 ,0,-1,1};\\n        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        int n_x,n_y;\\n        priority_queue<struct Item*, vector<struct Item*>, comp> pq;        \\n        visited[start[0]][start[1]] = true;\\n    \\n        while(!q.empty()){\\n            Item *i = q.front();\\n            if(i->price != INF)\\n                pq.push(i);\\n            q.pop();\\n\\n            for(int t = 0; t < 4; t++){\\n                n_x = i->x + cord_x[t]; n_y = i->y  + cord_y[t];\\n                if(n_x < 0 || n_x >= grid.size() || n_y < 0 || n_y >= grid[0].size()) continue;\\n                if(grid[n_x][n_y] == 0) continue;\\n                \\n                if(!visited[n_x][n_y]){\\n                    visited[n_x][n_y] = true;\\n                    p = INF;\\n                    if(grid[n_x][n_y] >= pricing[0] && grid[n_x][n_y] <= pricing[1])\\n                        p = grid[n_x][n_y];\\n                    q.push(new Item(n_x,n_y,i->dist+1,p));\\n                }\\n            }\\n            \\n        }\\n        \\n        vector<vector<int>> ans;\\n        while(!pq.empty() && k--){\\n            Item* i = pq.top();\\n            ans.push_back({i->x,i->y});\\n            pq.pop();\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int INF = 1e6;\\npublic:\\n    struct Item{\\n      int price,x,y,dist;\\n        \\n      Item(int i, int j, int d, int p){\\n          x = i; y = j; dist = d; price = p;\\n      }\\n    };\\n    \\n    struct comp{\\n        bool operator()(const struct Item* a, const struct Item* b){\\n            if(a->dist < b->dist) return false;\\n            else if(a->dist == b->dist){\\n                if(a->price < b->price) return false;\\n                else if(a->price == b->price){\\n                    if(a->x < b->x) return false;\\n                    else if(a->x == b->x && a->y < b->y) return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n    };\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        queue<Item*> q;\\n        int p = INF;\\n        if(grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1])\\n            p = grid[start[0]][start[1]];\\n        q.push(new Item(start[0],start[1],0,p));\\n        \\n        int cord_x[] = {-1,1,0,0};\\n        int cord_y[] = {0 ,0,-1,1};\\n        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        int n_x,n_y;\\n        priority_queue<struct Item*, vector<struct Item*>, comp> pq;        \\n        visited[start[0]][start[1]] = true;\\n    \\n        while(!q.empty()){\\n            Item *i = q.front();\\n            if(i->price != INF)\\n                pq.push(i);\\n            q.pop();\\n\\n            for(int t = 0; t < 4; t++){\\n                n_x = i->x + cord_x[t]; n_y = i->y  + cord_y[t];\\n                if(n_x < 0 || n_x >= grid.size() || n_y < 0 || n_y >= grid[0].size()) continue;\\n                if(grid[n_x][n_y] == 0) continue;\\n                \\n                if(!visited[n_x][n_y]){\\n                    visited[n_x][n_y] = true;\\n                    p = INF;\\n                    if(grid[n_x][n_y] >= pricing[0] && grid[n_x][n_y] <= pricing[1])\\n                        p = grid[n_x][n_y];\\n                    q.push(new Item(n_x,n_y,i->dist+1,p));\\n                }\\n            }\\n            \\n        }\\n        \\n        vector<vector<int>> ans;\\n        while(!pq.empty() && k--){\\n            Item* i = pq.top();\\n            ans.push_back({i->x,i->y});\\n            pq.pop();\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321066,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > offset = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        queue<vector<int>> q;\\n        vector<vector<int> > res;\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));\\n        dist[start[0]][start[1]] = 0;\\n        q.push({start[0], start[1], 0});\\n        while(!q.empty()) {\\n            int x = q.front()[0];\\n            int y = q.front()[1]; \\n            int d = q.front()[2];\\n            q.pop();\\n            if(grid[x][y] >= pricing[0] && grid[x][y] <= pricing[1]) {\\n                res.push_back({d, grid[x][y], x, y});\\n            }\\n            for(int k = 0; k < 4; k++) {\\n                int i = x + offset[k][0];\\n                int j = y + offset[k][1];\\n                if(i < 0 || i >= n || j < 0 || j >= m || dist[i][j] != INT_MAX || grid[i][j] == 0) continue;\\n                dist[i][j] = 1 + d;\\n                q.push({i, j, 1+d});\\n            }\\n        }\\n        sort(res.begin(), res.end());\\n        while(res.size() > k) res.pop_back();\\n        for(int i = 0; i < res.size(); i++) {\\n            res[i] = {res[i][2], res[i][3]};\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > offset = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        queue<vector<int>> q;\\n        vector<vector<int> > res;\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));\\n        dist[start[0]][start[1]] = 0;\\n        q.push({start[0], start[1], 0});\\n        while(!q.empty()) {\\n            int x = q.front()[0];\\n            int y = q.front()[1]; \\n            int d = q.front()[2];\\n            q.pop();\\n            if(grid[x][y] >= pricing[0] && grid[x][y] <= pricing[1]) {\\n                res.push_back({d, grid[x][y], x, y});\\n            }\\n            for(int k = 0; k < 4; k++) {\\n                int i = x + offset[k][0];\\n                int j = y + offset[k][1];\\n                if(i < 0 || i >= n || j < 0 || j >= m || dist[i][j] != INT_MAX || grid[i][j] == 0) continue;\\n                dist[i][j] = 1 + d;\\n                q.push({i, j, 1+d});\\n            }\\n        }\\n        sort(res.begin(), res.end());\\n        while(res.size() > k) res.pop_back();\\n        for(int i = 0; i < res.size(); i++) {\\n            res[i] = {res[i][2], res[i][3]};\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292284,
                "title": "typescript-100-100",
                "content": "Uses a couple collector arrays to keep depth levels separate\\n\\n```\\nfunction highestRankedKItems(grid: number[][], pricing: number[], start: number[], k: number): number[][] {\\n  const n = grid.length\\n  const m = grid[0].length\\n  const priceLow = pricing[0]\\n  const priceHigh = pricing[1]\\n  \\n  const final: number[][] = []\\n  let temp: number[][] = [] // collector for the current batch (by depth)\\n  \\n  let firstNodeQueue: number[][] = []\\n  let secondNodeQueue: number[][] = [] // used to break into batches by depth\\n  \\n  const visitNode = (node: number[]) => {\\n    const i = node[0]\\n    const j = node[1]\\n    if (i < 0 || i >= n || j < 0 || j >= m) return // out of bounds\\n    const val = grid[i][j]\\n    if (val <= 0) return // visited or a wall\\n    if (val > 1 && val >= priceLow && val <= priceHigh) {\\n      temp.push([i, j]) // possible value\\n    }\\n    grid[i][j] = -val // marking visited\\n    \\n    secondNodeQueue.push([i, j+1]) // get around\\n    secondNodeQueue.push([i, j-1])\\n    secondNodeQueue.push([i+1, j])\\n    secondNodeQueue.push([i-1, j])\\n  }\\n  \\n  firstNodeQueue.push(start)\\n  \\n  while (firstNodeQueue.length > 0) {\\n    const node = firstNodeQueue.pop()\\n    visitNode(node)\\n    if (firstNodeQueue.length === 0) {\\n      if (temp.length > 0) {\\n        temp.sort((a, b) => {\\n          const firstVal = Math.abs(grid[a[0]][a[1]])\\n          const secondVal = Math.abs(grid[b[0]][b[1]])\\n          return (firstVal - secondVal) || (a[0] - b[0]) || (a[1] - b[1])\\n        })\\n      }\\n                  \\n      final.push(...temp)\\n      temp = []\\n      if (final.length >= k) {\\n        final.length = k\\n        break\\n      }\\n      \\n      if (secondNodeQueue.length > 0) {\\n        firstNodeQueue = secondNodeQueue\\n        secondNodeQueue = []\\n      }\\n    }\\n  }\\n    \\n  return final\\n  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction highestRankedKItems(grid: number[][], pricing: number[], start: number[], k: number): number[][] {\\n  const n = grid.length\\n  const m = grid[0].length\\n  const priceLow = pricing[0]\\n  const priceHigh = pricing[1]\\n  \\n  const final: number[][] = []\\n  let temp: number[][] = [] // collector for the current batch (by depth)\\n  \\n  let firstNodeQueue: number[][] = []\\n  let secondNodeQueue: number[][] = [] // used to break into batches by depth\\n  \\n  const visitNode = (node: number[]) => {\\n    const i = node[0]\\n    const j = node[1]\\n    if (i < 0 || i >= n || j < 0 || j >= m) return // out of bounds\\n    const val = grid[i][j]\\n    if (val <= 0) return // visited or a wall\\n    if (val > 1 && val >= priceLow && val <= priceHigh) {\\n      temp.push([i, j]) // possible value\\n    }\\n    grid[i][j] = -val // marking visited\\n    \\n    secondNodeQueue.push([i, j+1]) // get around\\n    secondNodeQueue.push([i, j-1])\\n    secondNodeQueue.push([i+1, j])\\n    secondNodeQueue.push([i-1, j])\\n  }\\n  \\n  firstNodeQueue.push(start)\\n  \\n  while (firstNodeQueue.length > 0) {\\n    const node = firstNodeQueue.pop()\\n    visitNode(node)\\n    if (firstNodeQueue.length === 0) {\\n      if (temp.length > 0) {\\n        temp.sort((a, b) => {\\n          const firstVal = Math.abs(grid[a[0]][a[1]])\\n          const secondVal = Math.abs(grid[b[0]][b[1]])\\n          return (firstVal - secondVal) || (a[0] - b[0]) || (a[1] - b[1])\\n        })\\n      }\\n                  \\n      final.push(...temp)\\n      temp = []\\n      if (final.length >= k) {\\n        final.length = k\\n        break\\n      }\\n      \\n      if (secondNodeQueue.length > 0) {\\n        firstNodeQueue = secondNodeQueue\\n        secondNodeQueue = []\\n      }\\n    }\\n  }\\n    \\n  return final\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276219,
                "title": "python-bfs-solution-o-m-n-o-m-n-log-m-n-time-and-o-m-n-space",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        #we can start doing bfs from that point and store the result\\n        [row,col] = start\\n        que = deque([(row,col)])\\n        visited = set([(row,col)])\\n        distance = {(row,col) : 0}\\n        result = []\\n        heapq.heapify(result)\\n        while que:\\n            row,col = que.popleft()\\n            if grid[row][col] >= pricing[0] and grid[row][col] <= pricing[1]:\\n                heapq.heappush(result,[distance[(row,col)],grid[row][col],row,col])\\n            if row > 0 and grid[row-1][col] > 0 and (row-1,col) not in visited:\\n                distance[(row-1,col)] = 1 + distance[(row,col)]\\n                visited.add((row-1,col))\\n                que.append((row-1,col))\\n            if col > 0 and grid[row][col-1] > 0 and (row,col-1) not in visited:\\n                distance[(row,col-1)] = 1 + distance[(row,col)]\\n                visited.add((row,col-1))\\n                que.append((row,col-1))\\n            if row < len(grid)-1 and grid[row+1][col] > 0 and (row+1,col) not in visited:\\n                distance[(row+1,col)] = 1 + distance[(row,col)]\\n                visited.add((row+1,col))\\n                que.append((row+1,col))\\n            if col < len(grid[0])-1 and grid[row][col+1] > 0 and (row,col+1) not in visited:\\n                distance[(row,col+1)] = 1 + distance[(row,col)]\\n                visited.add((row,col+1))\\n                que.append((row,col+1))\\n        answer = []\\n        while result and len(answer) < k:\\n            [_,_,row,col] = heapq.heappop(result)\\n            answer.append([row,col])\\n        return answer\\n        \\n                \\n",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        #we can start doing bfs from that point and store the result\\n        [row,col] = start\\n        que = deque([(row,col)])\\n        visited = set([(row,col)])\\n        distance = {(row,col) : 0}",
                "codeTag": "Java"
            },
            {
                "id": 2227706,
                "title": "python-bfs-faster-than-91",
                "content": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        q = deque()\\n        hashset = set()\\n        result = []\\n        q.append([start[0], start[1], 0])\\n        hashset.add((start[0], start[1]))\\n        steps = float(\\'inf\\')\\n        directions = [[1,0], [-1, 0], [0, 1], [0, -1]]\\n        \\n        \\n        while q:\\n            x, y, s = q.popleft()\\n            if s > steps:\\n                break\\n            if pricing[0] <= grid[x][y] <= pricing[1]:\\n                result.append([s, grid[x][y], x, y])\\n                if len(result) == k:\\n                    steps = s\\n            for (a,b) in directions:\\n                if 0 <= a+x < m and 0 <= b+y < n and (a+x, b+y) not in hashset and grid[a+x][b+y] != 0:\\n                    q.append([a+x, y+b, s+1])\\n                    hashset.add((a+x, y+b))\\n        \\n        result.sort()\\n        result = [[x[2], x[3]] for x in result]\\n        return result[:k]\\n```\\n\\n1. Use a queue system with an early exit point once the length of the results meets the size K (although you need to finish out the queue for things with similar steps for the tiebreaks\\n2. Make sure to append everything for the tiebreaking criteria to the result array in order so you can sort afterward\\n3. Only take the x,y values for the top sorted items",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        q = deque()\\n        hashset = set()\\n        result = []\\n        q.append([start[0], start[1], 0])\\n        hashset.add((start[0], start[1]))\\n        steps = float(\\'inf\\')\\n        directions = [[1,0], [-1, 0], [0, 1], [0, -1]]\\n        \\n        \\n        while q:\\n            x, y, s = q.popleft()\\n            if s > steps:\\n                break\\n            if pricing[0] <= grid[x][y] <= pricing[1]:\\n                result.append([s, grid[x][y], x, y])\\n                if len(result) == k:\\n                    steps = s\\n            for (a,b) in directions:\\n                if 0 <= a+x < m and 0 <= b+y < n and (a+x, b+y) not in hashset and grid[a+x][b+y] != 0:\\n                    q.append([a+x, y+b, s+1])\\n                    hashset.add((a+x, y+b))\\n        \\n        result.sort()\\n        result = [[x[2], x[3]] for x in result]\\n        return result[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226172,
                "title": "c-bfs-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        queue<vector<int>> q; // steps,price,x,y\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        \\n        q.push({0,grid[start[0]][start[1]],start[0],start[1]});\\n        \\n        vis[start[0]][start[1]]=1;\\n        int dx[5]={0,1,0,-1,0};\\n        vector<vector<int>> ans,res;\\n        while(!q.empty()){\\n            int node=q.size();\\n            while(node--){\\n                auto it=q.front();q.pop();\\n                //res.push_back(it);\\n                int r=it[2];int c=it[3];\\n                int step=it[0];int pr=it[1];\\n                if(pr>=pricing[0] && pr<=pricing[1])\\n                    res.push_back(it); \\n                for(int i=0;i<4;i++){\\n                    int row=r+dx[i],col=c+dx[i+1];\\n                    \\n                    if(row<0 || row>=m || col<0 || col>=n)\\n                        continue;\\n                    \\n                    if(grid[row][col]==0)\\n                        continue;\\n                    \\n                    if(vis[row][col]==1)\\n                        continue;\\n                    \\n                    q.push({step+1,grid[row][col],row,col});\\n                    vis[row][col]=1;\\n                }\\n            }\\n        }\\n        sort(res.begin(),res.end());\\n        int x=min(int (k),int (res.size()));\\n        for(int i=0;i<x;i++)\\n            ans.push_back({res[i][2],res[i][3]});\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        queue<vector<int>> q; // steps,price,x,y\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        \\n        q.push({0,grid[start[0]][start[1]],start[0],start[1]});\\n        \\n        vis[start[0]][start[1]]=1;\\n        int dx[5]={0,1,0,-1,0};\\n        vector<vector<int>> ans,res;\\n        while(!q.empty()){\\n            int node=q.size();\\n            while(node--){\\n                auto it=q.front();q.pop();\\n                //res.push_back(it);\\n                int r=it[2];int c=it[3];\\n                int step=it[0];int pr=it[1];\\n                if(pr>=pricing[0] && pr<=pricing[1])\\n                    res.push_back(it); \\n                for(int i=0;i<4;i++){\\n                    int row=r+dx[i],col=c+dx[i+1];\\n                    \\n                    if(row<0 || row>=m || col<0 || col>=n)\\n                        continue;\\n                    \\n                    if(grid[row][col]==0)\\n                        continue;\\n                    \\n                    if(vis[row][col]==1)\\n                        continue;\\n                    \\n                    q.push({step+1,grid[row][col],row,col});\\n                    vis[row][col]=1;\\n                }\\n            }\\n        }\\n        sort(res.begin(),res.end());\\n        int x=min(int (k),int (res.size()));\\n        for(int i=0;i<x;i++)\\n            ans.push_back({res[i][2],res[i][3]});\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181528,
                "title": "c-explanation-with-comments-classical-bfs-solution",
                "content": "// custom compare function to defne who is the highest ranked and sort accordingly \\n      // first see if distance is same then go to the price ,then row and then column \\n      // return on the basis of the criteria that is different (whichever comes first)\\n\\n     // static bool cmp(vector<int>&a,vector<int>&b){\\n         //     if(a[0]==b[0]){\\n     //         if(a[1]==b[1]){\\n    //             if(a[2]==b[2]){\\n    //                 return a[3]<b[3];\\n      //             }\\n    //             return a[2]<b[2];\\n    //         }\\n     //         return a[1]<b[1];\\n      //     }\\n    //     return a[0]<b[0];\\n    // }\\n\\n         // class Solution {\\n         // public:\\n         //     vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& A, vector<int>& start, int k) {\\n        //         queue<pair<int,int>>q;\\n       // vector<vector<int>>dir={{0,1},{1,0},{-1,0},{0,-1}};\\n\\t\\t  \\n      // we have declare a directions array to traverse in 4 directions\\n        \\n        // q.push({start[0],start[1]});\\n        \\n        // first push the starting cell\\n        // vector<vector<int>>dist(grid.size(),vector<int>(grid[0].size(),0));\\n        \\n        // declare the dist size ;\\n        // in bfs we alwatys get the shortest distance because we traverse level by level \\n        // only after we finish traversing a level we go to the other level \\n        // initialise the starting cell as dist[srcx][srcy]=0\\n        \\n        // dist[start[0]][start[1]]=0;\\n        // vector<vector<int>>pq;\\n        // vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size()));\\n        // vis[start[0]][start[1]]=1;\\n        // while(q.size()){\\n        //     int sz=q.size();\\n        //     while(sz--){\\n                // traversing the levels\\n                // auto curr=q.front();\\n                // if(grid[curr.first][curr.second]>=A[0] && grid[curr.first][curr.second]<=A[1]){\\n                //     pq.push_back({dist[curr.first][curr.second],grid[curr.first][curr.second],curr.first,curr.second});\\n                    // we push into the array the four parameters , dist from source and then the price of the cell and the row and column if cell price is within range\\n                }\\n                \\n                // we pop the cell from the queue\\n                // ad start traversing the adjacent cells if valid\\n                \\n                // q.pop();\\n                // for(int i=0;i<4;i++){\\n                //     int xx=curr.first+dir[i][0];\\n                //     int yy=curr.second+dir[i][1];\\n                //     if(xx<0||yy<0||xx>=grid.size() || yy>=grid[0].size() || grid[xx][yy]==0||vis[xx][yy]==1){\\n                //         continue;\\n                        // checking if the cells we are about to visit are valid or not\\n                        // or if they are visited the we dont travers the cell \\n                    // }\\n                    // elase we mark the cells as visited and push it into queue after updating the distance\\n        //             vis[xx][yy]=1;\\n        //             dist[xx][yy]=1+dist[curr.first][curr.second];\\n        //             q.push({xx,yy});\\n        //         }\\n        //     }\\n        // }\\n        // sort(pq.begin(),pq.end(),cmp);\\n        // vector<vector<int>>ans;\\n        \\n        // the push the resulting cells to ans array \\n        // we are using min(pq.size(),k) because if we have lesser cellswithin range than k then we return all the cells in pq array\\n        // else return top k ranked cells \\n        \\n        // for(int i=0;i<min((int)pq.size(),k);i++){\\n        //     ans.push_back({pq[i][2],pq[i][3]});\\n        // }\\n        // return ans;\\n        \\n       }\\n     };",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n         // public:\\n         //     vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& A, vector<int>& start, int k) {\\n        //         queue<pair<int,int>>q;\\n       // vector<vector<int>>dir={{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2152272,
                "title": "c-bfs-sorting-easy-simple",
                "content": "```\\n#define pii pair<int,int>\\n#define pipii pair<int, pii>\\n#define F first\\n#define S second\\nbool comp(pipii &p1, pipii &p2)\\n{\\n    if(p1.F == p2.F)\\n    {\\n        if(p1.S.F == p2.S.F)\\n        {\\n            return p1.S.S < p2.S.S;\\n        }\\n        return p1.S.F < p2.S.F;\\n    }\\n    return p1.F < p2.F;\\n}\\nclass Solution {\\npublic:\\n    int x[4] = {0, 0, 1, -1};\\n    int y[4] = {1, -1, 0, 0};\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        \\n        int low = pricing[0], high = pricing[1], n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> ans;\\n        queue<pii> q;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        \\n        vis[start[0]][start[1]] = true;\\n        q.push({start[0], start[1]});\\n        \\n        while(!q.empty() && ans.size() < k)\\n        {\\n            int sz = q.size();\\n            vector<pipii> curr;\\n            \\n            for(int i=0; i<sz; ++i)\\n            {\\n                pii front = q.front();\\n                q.pop();\\n                \\n                int X = front.first, Y = front.second;\\n                \\n                if(grid[X][Y] >= low && grid[X][Y] <= high)\\n                    curr.push_back({grid[X][Y], front});\\n                \\n                for(int k=0; k<4; ++k)\\n                {\\n                    int x1 = X + x[k];\\n                    int y1 = Y + y[k];\\n                    \\n                    if(x1>=0 && y1>=0 && x1<n && y1<m && !vis[x1][y1] && grid[x1][y1])\\n                    {\\n                        vis[x1][y1] = true;\\n                        q.push({x1, y1});\\n                    }\\n                }\\n            }\\n            \\n            //sort curr\\n            \\n            sort(curr.begin(), curr.end(), comp);\\n            \\n            for(auto i : curr)\\n            {\\n                if(ans.size() < k)\\n                {\\n                    ans.push_back({i.S.F, i.S.S});\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define pii pair<int,int>\\n#define pipii pair<int, pii>\\n#define F first\\n#define S second\\nbool comp(pipii &p1, pipii &p2)\\n{\\n    if(p1.F == p2.F)\\n    {\\n        if(p1.S.F == p2.S.F)\\n        {\\n            return p1.S.S < p2.S.S;\\n        }\\n        return p1.S.F < p2.S.F;\\n    }\\n    return p1.F < p2.F;\\n}\\nclass Solution {\\npublic:\\n    int x[4] = {0, 0, 1, -1};\\n    int y[4] = {1, -1, 0, 0};\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        \\n        int low = pricing[0], high = pricing[1], n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> ans;\\n        queue<pii> q;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        \\n        vis[start[0]][start[1]] = true;\\n        q.push({start[0], start[1]});\\n        \\n        while(!q.empty() && ans.size() < k)\\n        {\\n            int sz = q.size();\\n            vector<pipii> curr;\\n            \\n            for(int i=0; i<sz; ++i)\\n            {\\n                pii front = q.front();\\n                q.pop();\\n                \\n                int X = front.first, Y = front.second;\\n                \\n                if(grid[X][Y] >= low && grid[X][Y] <= high)\\n                    curr.push_back({grid[X][Y], front});\\n                \\n                for(int k=0; k<4; ++k)\\n                {\\n                    int x1 = X + x[k];\\n                    int y1 = Y + y[k];\\n                    \\n                    if(x1>=0 && y1>=0 && x1<n && y1<m && !vis[x1][y1] && grid[x1][y1])\\n                    {\\n                        vis[x1][y1] = true;\\n                        q.push({x1, y1});\\n                    }\\n                }\\n            }\\n            \\n            //sort curr\\n            \\n            sort(curr.begin(), curr.end(), comp);\\n            \\n            for(auto i : curr)\\n            {\\n                if(ans.size() < k)\\n                {\\n                    ans.push_back({i.S.F, i.S.S});\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120116,
                "title": "c-n-ary-tree-bfs",
                "content": "The problem is basically perform a simple bfs and retrieve some nodes during the traversal. \\nThe trick here is how to maintain the ranking of each node, given the criteria: \\n\\n-Distance\\n-Price\\n-Row\\n-Column\\n\\nTo do this, a N-ary tree should be created, each level represents a sorting criteria, for example given the image bellow: all branches in first level will represent all nodes with distances 1,2,...100. \\nThe second level will sort by price, for example, given that distance=1 we can support multiple nodes with distance =1 but different price. Each node will be sorted in order from left to right, for example again, nodes in first level are sorted by distance from left to right. \\n\\n\\n![image](https://assets.leetcode.com/users/images/6b703288-03aa-4289-bb60-e08a743165ab_1654560201.2279913.png)\\n\\nWe can extend this logic to sort by any different parameter. \\n\\nAt the end, after inserting all nodes, we can retireve all of them (or only k of them) by making a dfs and getting always left most node, (just like BST preOrder traversal)\\n\\n```\\nclass RankNode{\\n  public:\\n    int x;\\n    int y;\\n    map<int,RankNode*> children;\\n    bool terminal;\\n    \\n    RankNode(){\\n        this->x = -1;\\n        this->y = -1;\\n        terminal = false;\\n    }\\n    RankNode(int x,int y){\\n        this->x = x;\\n        this->y = y;\\n    }  \\n};\\n\\nclass Solution {\\npublic:\\n    RankNode* root= new RankNode();\\n    int dx[4] = {-1,0,1,0};\\n    int dy[4] = {0,1,0,-1};\\n    \\n    //check if a node has been inserted before given that criteria, if not then create the node and traverse.\\n\\t//Insertion can be seen similar on how Trie insert works\\n    void insert(int x,int y,int price,int distance){\\n        RankNode* curr = root;\\n        //distance\\n        if(!curr->children[distance]) curr->children[distance] = new RankNode();\\n        curr = curr->children[distance];\\n        \\n        //price\\n        if(!curr->children[price]) curr->children[price] = new RankNode();\\n        curr = curr->children[price];\\n        \\n        //row\\n        if(!curr->children[x]) curr->children[x] = new RankNode();\\n        curr=curr->children[x];\\n        \\n        //col\\n        if(!curr->children[y]) curr->children[y] = new RankNode(x,y);\\n        curr=curr->children[y];\\n        \\n        curr->terminal = true;\\n    }\\n    vector<vector<int>> ans;\\n    \\n    void dfs(RankNode* rot){\\n        if(rot->terminal){\\n            ans.push_back({rot->x,rot->y});\\n            return;\\n        }\\n        \\n        for(auto kv:rot->children){\\n            dfs(kv.second);\\n        }\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n=grid.size();\\n        int m =grid[0].size();\\n        int distance[n+1][m+1];\\n        bool visited[n+1][m+1];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                distance[i][j] = -1;\\n                visited[i][j] = false;\\n            }\\n        }\\n        \\n        queue<pair<int,int>> Q;\\n        \\n        Q.push({start[0],start[1]});\\n        visited[start[0]][start[1]] = true;\\n        distance[start[0]][start[1]] = 0;\\n        while(!Q.empty()){\\n            pair<int,int> curr = Q.front();\\n            Q.pop();\\n            \\n            int x = curr.first;\\n            int y = curr.second;\\n            \\n            for(int i=0;i<4;i++){\\n                int nx = x+dx[i];\\n                int ny = y+dy[i];\\n                int d = distance[x][y];\\n                if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny] >=1 && !visited[nx][ny]){\\n                    Q.push({nx,ny});\\n                    visited[nx][ny] = true;\\n                    distance[nx][ny] = d+1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int price = grid[i][j];\\n                if(price>1){\\n                    if(price>=pricing[0] && price<=pricing[1]){\\n                        if(distance[i][j] >=0){\\n                            insert(i,j,grid[i][j],distance[i][j]);    \\n                        }\\n                            \\n                    }\\n                }\\n            }\\n        }\\n        \\n        dfs(root);\\n        \\n        vector<vector<int>> kth;\\n        if(k>=ans.size()) return ans;\\n        for(int i=0;i<k;i++){\\n            vector<int> curr = ans[i];\\n            kth.push_back(curr);\\n        }\\n        \\n        return kth;\\n        \\n        /*for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                cout << distance[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }*/\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RankNode{\\n  public:\\n    int x;\\n    int y;\\n    map<int,RankNode*> children;\\n    bool terminal;\\n    \\n    RankNode(){\\n        this->x = -1;\\n        this->y = -1;\\n        terminal = false;\\n    }\\n    RankNode(int x,int y){\\n        this->x = x;\\n        this->y = y;\\n    }  \\n};\\n\\nclass Solution {\\npublic:\\n    RankNode* root= new RankNode();\\n    int dx[4] = {-1,0,1,0};\\n    int dy[4] = {0,1,0,-1};\\n    \\n    //check if a node has been inserted before given that criteria, if not then create the node and traverse.\\n\\t//Insertion can be seen similar on how Trie insert works\\n    void insert(int x,int y,int price,int distance){\\n        RankNode* curr = root;\\n        //distance\\n        if(!curr->children[distance]) curr->children[distance] = new RankNode();\\n        curr = curr->children[distance];\\n        \\n        //price\\n        if(!curr->children[price]) curr->children[price] = new RankNode();\\n        curr = curr->children[price];\\n        \\n        //row\\n        if(!curr->children[x]) curr->children[x] = new RankNode();\\n        curr=curr->children[x];\\n        \\n        //col\\n        if(!curr->children[y]) curr->children[y] = new RankNode(x,y);\\n        curr=curr->children[y];\\n        \\n        curr->terminal = true;\\n    }\\n    vector<vector<int>> ans;\\n    \\n    void dfs(RankNode* rot){\\n        if(rot->terminal){\\n            ans.push_back({rot->x,rot->y});\\n            return;\\n        }\\n        \\n        for(auto kv:rot->children){\\n            dfs(kv.second);\\n        }\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n=grid.size();\\n        int m =grid[0].size();\\n        int distance[n+1][m+1];\\n        bool visited[n+1][m+1];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                distance[i][j] = -1;\\n                visited[i][j] = false;\\n            }\\n        }\\n        \\n        queue<pair<int,int>> Q;\\n        \\n        Q.push({start[0],start[1]});\\n        visited[start[0]][start[1]] = true;\\n        distance[start[0]][start[1]] = 0;\\n        while(!Q.empty()){\\n            pair<int,int> curr = Q.front();\\n            Q.pop();\\n            \\n            int x = curr.first;\\n            int y = curr.second;\\n            \\n            for(int i=0;i<4;i++){\\n                int nx = x+dx[i];\\n                int ny = y+dy[i];\\n                int d = distance[x][y];\\n                if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny] >=1 && !visited[nx][ny]){\\n                    Q.push({nx,ny});\\n                    visited[nx][ny] = true;\\n                    distance[nx][ny] = d+1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int price = grid[i][j];\\n                if(price>1){\\n                    if(price>=pricing[0] && price<=pricing[1]){\\n                        if(distance[i][j] >=0){\\n                            insert(i,j,grid[i][j],distance[i][j]);    \\n                        }\\n                            \\n                    }\\n                }\\n            }\\n        }\\n        \\n        dfs(root);\\n        \\n        vector<vector<int>> kth;\\n        if(k>=ans.size()) return ans;\\n        for(int i=0;i<k;i++){\\n            vector<int> curr = ans[i];\\n            kth.push_back(curr);\\n        }\\n        \\n        return kth;\\n        \\n        /*for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                cout << distance[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }*/\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2098068,
                "title": "c-bfs",
                "content": "vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>> q;\\n        vector<pair<int,int>> dir={{0,1},{0,-1},{1,0},{-1,0}};\\n        q.push({start[0],start[1]});\\n        \\n        vector<vector<int>> vis(n,vector<int>(m));\\n         vector<vector<int>> ans;\\n        // queue<pair<int,int>> q;\\n        vis[start[0]][start[1]]=1;\\n        while(!q.empty()){\\n            int sz=q.size();\\n           vector<vector<int>> tem;\\n            while(sz--){\\n                int i=q.front().first;\\n                int j=q.front().second;\\n                q.pop();\\n                if(grid[i][j]>=pricing[0] and grid[i][j]<=pricing[1]){\\n                    ans.push_back({i,j});\\n                    k--;\\n                    if(k==0) return ans;\\n                }\\n                \\n                \\n                for(int l=0;l<4;l++){\\n                    int x=dir[l].first+i;\\n                    int y=dir[l].second+j;\\n                    if(x>=0 and x<n and y>=0 and y<m and grid[x][y]!=0 and vis[x][y]==0){\\n                        vis[x][y]=1;\\n                        // q.push({x,y});\\n                        tem.push_back({grid[x][y],x,y});\\n                    }\\n                }\\n                \\n            }\\n            sort(tem.begin(),tem.end());\\n            for(int i=0;i<tem.size();i++) q.push({tem[i][1],tem[i][2]});\\n            \\n        }\\n        // for(int i=0;i<ans.size();i++) sort(ans[i].begin(),ans[i].end());\\n        return ans;\\n    }",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>> q;\\n        vector<pair<int,int>> dir={{0,1},{0,-1},{1,0},{-1,0}};\\n        q.push({start[0],start[1]});\\n        \\n        vector<vector<int>> vis(n,vector<int>(m));\\n         vector<vector<int>> ans;\\n        // queue<pair<int,int>> q;\\n        vis[start[0]][start[1]]=1;\\n        while(!q.empty()){\\n            int sz=q.size();\\n           vector<vector<int>> tem;\\n            while(sz--){\\n                int i=q.front().first;\\n                int j=q.front().second;\\n                q.pop();\\n                if(grid[i][j]>=pricing[0] and grid[i][j]<=pricing[1]){\\n                    ans.push_back({i,j});\\n                    k--;\\n                    if(k==0) return ans;\\n                }\\n                \\n                \\n                for(int l=0;l<4;l++){\\n                    int x=dir[l].first+i;\\n                    int y=dir[l].second+j;\\n                    if(x>=0 and x<n and y>=0 and y<m and grid[x][y]!=0 and vis[x][y]==0){\\n                        vis[x][y]=1;\\n                        // q.push({x,y});\\n                        tem.push_back({grid[x][y],x,y});\\n                    }\\n                }\\n                \\n            }\\n            sort(tem.begin(),tem.end());\\n            for(int i=0;i<tem.size();i++) q.push({tem[i][1],tem[i][2]});\\n            \\n        }\\n        // for(int i=0;i<ans.size();i++) sort(ans[i].begin(),ans[i].end());\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2088701,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> pip;\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    priority_queue<pip, vector<pip>, greater<pip>> minh;\\n    int n = grid.size(), m = grid[0].size();\\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\\n    int directions[5] = {0,1,0,-1,0};\\n    vector<vector<int>> collect;\\n    vector<vector<int>> ret;\\n        \\n    minh.push({0,{start[0], start[1]}});\\n    if(grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1]) collect.push_back({0,grid[start[0]][start[1]], start[0],start[1]});\\n    visited[start[0]][start[1]] = true;\\n    while(minh.size())\\n    {\\n        auto [dist, corr] = minh.top();\\n        minh.pop();\\n        int x = corr.first;\\n        int y = corr.second;\\n        \\n        for(int dir = 0; dir < 4 ; dir++)\\n        {\\n            int newx = x + directions[dir]; \\n            int newy = y + directions[dir+1];\\n\\n            if(newx < 0 || newy < 0 || newx >= n || newy >= m || visited[newx][newy] || !grid[newx][newy]) continue;\\n            else{\\n                if(!visited[newx][newy])\\n                {\\n                    visited[newx][newy] = true;\\n                    if(grid[newx][newy] >= pricing[0] && grid[newx][newy] <= pricing[1])\\n                    {\\n                        collect.push_back({dist+1,grid[newx][newy],newx, newy});\\n                    }\\n                    minh.push({dist + 1, {newx, newy}});\\n                }\\n            }\\n        }\\n    }\\n        \\n    sort(collect.begin(), collect.end());\\n    if(collect.size() < k)\\n    {\\n        for(int i = 0 ; i < collect.size() ; i++)\\n            ret.push_back({collect[i][2], collect[i][3]});\\n    }\\n    else{\\n        for(int i = 0 ; i < k ; i++)\\n            ret.push_back({collect[i][2], collect[i][3]});\\n    }\\n    return ret;\\n\\n }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> pip;\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    priority_queue<pip, vector<pip>, greater<pip>> minh;\\n    int n = grid.size(), m = grid[0].size();\\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\\n    int directions[5] = {0,1,0,-1,0};\\n    vector<vector<int>> collect;\\n    vector<vector<int>> ret;\\n        \\n    minh.push({0,{start[0], start[1]}});\\n    if(grid[start[0]][start[1]] >= pricing[0] && grid[start[0]][start[1]] <= pricing[1]) collect.push_back({0,grid[start[0]][start[1]], start[0],start[1]});\\n    visited[start[0]][start[1]] = true;\\n    while(minh.size())\\n    {\\n        auto [dist, corr] = minh.top();\\n        minh.pop();\\n        int x = corr.first;\\n        int y = corr.second;\\n        \\n        for(int dir = 0; dir < 4 ; dir++)\\n        {\\n            int newx = x + directions[dir]; \\n            int newy = y + directions[dir+1];\\n\\n            if(newx < 0 || newy < 0 || newx >= n || newy >= m || visited[newx][newy] || !grid[newx][newy]) continue;\\n            else{\\n                if(!visited[newx][newy])\\n                {\\n                    visited[newx][newy] = true;\\n                    if(grid[newx][newy] >= pricing[0] && grid[newx][newy] <= pricing[1])\\n                    {\\n                        collect.push_back({dist+1,grid[newx][newy],newx, newy});\\n                    }\\n                    minh.push({dist + 1, {newx, newy}});\\n                }\\n            }\\n        }\\n    }\\n        \\n    sort(collect.begin(), collect.end());\\n    if(collect.size() < k)\\n    {\\n        for(int i = 0 ; i < collect.size() ; i++)\\n            ret.push_back({collect[i][2], collect[i][3]});\\n    }\\n    else{\\n        for(int i = 0 ; i < k ; i++)\\n            ret.push_back({collect[i][2], collect[i][3]});\\n    }\\n    return ret;\\n\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070300,
                "title": "c-easy-bfs-with-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>> dis(n,vector<int>(m,-1));\\n        priority_queue<tuple<int,int,int,int> > pq;\\n        queue<pair<int,int>> q;\\n        q.push({start[0], start[1]});\\n        vector<int> nxt={0,1,0,-1,0};\\n        dis[start[0]][start[1]]=0;\\n        \\n        while(!q.empty()){\\n            int r=q.front().first, c=q.front().second;\\n            // cout<<pq.size()<<\"\\\\n\";\\n            q.pop();\\n             \\n            if(grid[r][c]>=pricing[0] && grid[r][c]<=pricing[1]){\\n                \\n                pq.push(make_tuple(dis[r][c], grid[r][c], r,c));\\n                if(pq.size()>k) pq.pop();\\n            }\\n            \\n            for(int i=0;i<4;i++){\\n                int rr=r+nxt[i], cc=c+nxt[i+1];\\n                // cout<<rr<<\" rr cc \"<<cc<<\"\\\\n\";\\n                if(rr>=0 && rr<n && cc>=0 && cc<m && dis[rr][cc]==-1 && grid[rr][cc]!=0){\\n                       // cout<<rr<<\" rr cc \"<<cc<<\"\\\\n\";\\n                       // cout<<grid[rr][cc]<<\" grid[rr][cc]\\\\n\";\\n                       dis[rr][cc]=dis[r][c]+1;\\n                       q.push({rr,cc});\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty()){\\n            auto [step, val, x,y]=pq.top();\\n            pq.pop();\\n            ans.push_back({x,y});\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\nBFS(using queue) to traverse in matrix and dist array to store distance of the current cell from the starting index.\\nWe use max heap to get k highest ranekd items.\\nCriteria for highest rank should be looked at carefully\\n1. min dist from starting point\\n2. smaller value of the cell in the grid gets higher rank provided the value lies within the given range\\n3. lower row gets higher rank\\n4. lower column gets higher rank\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>> dis(n,vector<int>(m,-1));\\n        priority_queue<tuple<int,int,int,int> > pq;\\n        queue<pair<int,int>> q;\\n        q.push({start[0], start[1]});\\n        vector<int> nxt={0,1,0,-1,0};\\n        dis[start[0]][start[1]]=0;\\n        \\n        while(!q.empty()){\\n            int r=q.front().first, c=q.front().second;\\n            // cout<<pq.size()<<\"\\\\n\";\\n            q.pop();\\n             \\n            if(grid[r][c]>=pricing[0] && grid[r][c]<=pricing[1]){\\n                \\n                pq.push(make_tuple(dis[r][c], grid[r][c], r,c));\\n                if(pq.size()>k) pq.pop();\\n            }\\n            \\n            for(int i=0;i<4;i++){\\n                int rr=r+nxt[i], cc=c+nxt[i+1];\\n                // cout<<rr<<\" rr cc \"<<cc<<\"\\\\n\";\\n                if(rr>=0 && rr<n && cc>=0 && cc<m && dis[rr][cc]==-1 && grid[rr][cc]!=0){\\n                       // cout<<rr<<\" rr cc \"<<cc<<\"\\\\n\";\\n                       // cout<<grid[rr][cc]<<\" grid[rr][cc]\\\\n\";\\n                       dis[rr][cc]=dis[r][c]+1;\\n                       q.push({rr,cc});\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty()){\\n            auto [step, val, x,y]=pq.top();\\n            pq.pop();\\n            ans.push_back({x,y});\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2043194,
                "title": "c-bfs-bst-of-pairs-of-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(\\n        vector<vector<int>>& grid,\\n        vector<int>& pricing,\\n        vector<int>& start,\\n        int k\\n    ) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int di[] = {0, 0, 1, -1};\\n        int dj[] = {1, -1, 0, 0};\\n        vector<vector<bool>> vis(m, vector<bool>(n));\\n        auto isValid = [&](int i, int j) {\\n            return 0 <= i && i < m\\n                && 0 <= j && j < n\\n                && grid[i][j] && !vis[i][j];\\n        };\\n        \\n        set<pair<pair<int,int>,pair<int,int>>> items;\\n        \\n        int low = pricing[0];\\n        int high = pricing[1];\\n        \\n        queue<pair<int, int>> q;\\n        q.emplace(start[0], start[1]);\\n        vis[start[0]][start[1]] = true;\\n        for (int cd = 0; q.size(); ++cd) {\\n            int sz = q.size();\\n            while (sz--) {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                if (low <= grid[i][j] && grid[i][j] <= high) {\\n                    items.insert({{cd, grid[i][j]}, {i, j}});\\n                    if (items.size() > k)\\n                        items.erase(prev(items.end()));\\n                }\\n                \\n                for (int z = 0; z < 4; ++z) {\\n                    int ni = i + di[z];\\n                    int nj = j + dj[z];\\n                    if (isValid(ni, nj)) {\\n                        q.emplace(ni, nj);\\n                        vis[ni][nj] = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for (auto [dist_price, pos]: items) {\\n            auto [i, j] = pos;\\n            ans.push_back({i, j});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestRankedKItems(\\n        vector<vector<int>>& grid,\\n        vector<int>& pricing,\\n        vector<int>& start,\\n        int k\\n    ) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int di[] = {0, 0, 1, -1};\\n        int dj[] = {1, -1, 0, 0};\\n        vector<vector<bool>> vis(m, vector<bool>(n));\\n        auto isValid = [&](int i, int j) {\\n            return 0 <= i && i < m\\n                && 0 <= j && j < n\\n                && grid[i][j] && !vis[i][j];\\n        };\\n        \\n        set<pair<pair<int,int>,pair<int,int>>> items;\\n        \\n        int low = pricing[0];\\n        int high = pricing[1];\\n        \\n        queue<pair<int, int>> q;\\n        q.emplace(start[0], start[1]);\\n        vis[start[0]][start[1]] = true;\\n        for (int cd = 0; q.size(); ++cd) {\\n            int sz = q.size();\\n            while (sz--) {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                if (low <= grid[i][j] && grid[i][j] <= high) {\\n                    items.insert({{cd, grid[i][j]}, {i, j}});\\n                    if (items.size() > k)\\n                        items.erase(prev(items.end()));\\n                }\\n                \\n                for (int z = 0; z < 4; ++z) {\\n                    int ni = i + di[z];\\n                    int nj = j + dj[z];\\n                    if (isValid(ni, nj)) {\\n                        q.emplace(ni, nj);\\n                        vis[ni][nj] = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for (auto [dist_price, pos]: items) {\\n            auto [i, j] = pos;\\n            ans.push_back({i, j});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015172,
                "title": "c-bfs-custom-sorting-easy-understandable-including-tle-counterpart",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pii;\\n    int dx[4] = {1,0, 0,-1};\\n    int dy[4] = {0,1,-1, 0};\\n    vector<vector<int>> ans;\\n    vector<vector<int>> dist;\\n    unordered_set<int> ds; // contains all distinct distances encountered so far from start --> the moment we see k+1 we can exit\\n    void bfs(vector<vector<int>> &g, vector<int> &p, vector<int> &s, int k) {\\n        queue<pii> q;\\n        int row = g.size();\\n        int col = g[0].size();\\n        q.push({s[0], s[1]});\\n        dist[s[0]][s[1]] = 0;\\n        if(!(g[s[0]][s[1]] < p[0] || g[s[0]][s[1]] > p[1])) {\\n            ds.insert(0);\\n            ans.push_back({s[0], s[1]});\\n        }\\n        \\n        while(!q.empty()) {\\n            pii f = q.front();\\n            q.pop();\\n            int x = f.first;\\n            int y = f.second;\\n            int d = dist[x][y];\\n            // cout << \"(x, y) = \" << x << \" \" << y << endl;\\n            for(int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                if(nx < 0 || ny < 0 || nx >= row || ny >= col) {\\n                    continue;\\n                }\\n                if(g[nx][ny] == 0 || (dist[nx][ny]) >= 0) {\\n                    continue;\\n                }\\n                q.push({nx, ny});\\n                dist[nx][ny] = d + 1;\\n                if(g[nx][ny] < p[0] || g[nx][ny] > p[1]) {\\n                    continue;\\n                }\\n                ds.insert(d + 1);\\n                // cout << \"(nx, ny) = \" << nx << \" \" << ny << endl;\\n                if(ds.size() == k + 1) {\\n                    return;\\n                }\\n                ans.push_back({nx, ny});\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        dist = vector<vector<int>> (row, vector<int> (col, -1));\\n        ans = {};\\n        bfs(grid, pricing, start, k);\\n        \\n        auto cmp = [&] (vector<int> &a, vector<int> &b) {\\n            int d1 = dist[a[0]][a[1]];\\n            int d2 = dist[b[0]][b[1]];\\n            if(d1 < d2) {\\n                return true;\\n            } else if(d1 > d2) {\\n                return false;\\n            } else {\\n                if(grid[a[0]][a[1]] < grid[b[0]][b[1]]) {\\n                    return true;\\n                } else if(grid[a[0]][a[1]] > grid[b[0]][b[1]]) {\\n                    return false;\\n                } else {\\n                    if(a[0] < b[0]) {\\n                        return true;\\n                    } else if(a[0] > b[0]) {\\n                        return false;\\n                    } else {\\n                        if(a[1] < b[1]) {\\n                            return true;\\n                        } else if(a[1] > b[1]) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n        \\n        sort(ans.begin(), ans.end(), cmp);\\n        if(ans.size() > k) {\\n            ans.resize(k);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n---------------------------------------------------------------------------------------------------------------------------------\\n\\n// TLE Solution\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pii;\\n    int dx[4] = {1,0, 0,-1};\\n    int dy[4] = {0,1,-1, 0};\\n    vector<vector<int>> ans;\\n    map<pii, int> dist;\\n    unordered_set<int> ds;\\n    void bfs(vector<vector<int>> &g, vector<int> &p, vector<int> &s, int k) {\\n        queue<pii> q;\\n        int row = g.size();\\n        int col = g[0].size();\\n        q.push({s[0], s[1]});\\n        dist[{s[0], s[1]}] = 0;\\n        if(!(g[s[0]][s[1]] < p[0] || g[s[0]][s[1]] > p[1])) {\\n            ds.insert(0);\\n            ans.push_back({s[0], s[1]});\\n        }\\n        \\n        while(!q.empty()) {\\n            pii f = q.front();\\n            q.pop();\\n            int x = f.first;\\n            int y = f.second;\\n            int d = dist[{x, y}];\\n            // cout << \"(x, y) = \" << x << \" \" << y << endl;\\n            for(int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                if(nx < 0 || ny < 0 || nx >= row || ny >= col) {\\n                    continue;\\n                }\\n                if(g[nx][ny] == 0 || (dist.count({nx, ny})) > 0) {\\n                    continue;\\n                }\\n                q.push({nx, ny});\\n                dist[{nx, ny}] = d + 1;\\n                if(g[nx][ny] < p[0] || g[nx][ny] > p[1]) {\\n                    continue;\\n                }\\n                ds.insert(d + 1);\\n                // cout << \"(nx, ny) = \" << nx << \" \" << ny << endl;\\n                if(ds.size() == k + 1) {\\n                    return;\\n                }\\n                ans.push_back({nx, ny});\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        ans = {};\\n        bfs(grid, pricing, start, k);\\n        \\n        auto cmp = [&] (vector<int> &a, vector<int> &b) {\\n            int d1 = dist[{a[0], a[1]}];\\n            int d2 = dist[{b[0], b[1]}];\\n            if(d1 < d2) {\\n                return true;\\n            } else if(d1 > d2) {\\n                return false;\\n            } else {\\n                if(grid[a[0]][a[1]] < grid[b[0]][b[1]]) {\\n                    return true;\\n                } else if(grid[a[0]][a[1]] > grid[b[0]][b[1]]) {\\n                    return false;\\n                } else {\\n                    if(a[0] < b[0]) {\\n                        return true;\\n                    } else if(a[0] > b[0]) {\\n                        return false;\\n                    } else {\\n                        if(a[1] < b[1]) {\\n                            return true;\\n                        } else if(a[1] > b[1]) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n        \\n        sort(ans.begin(), ans.end(), cmp);\\n        if(ans.size() > k) {\\n            ans.resize(k);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pii;\\n    int dx[4] = {1,0, 0,-1};\\n    int dy[4] = {0,1,-1, 0};\\n    vector<vector<int>> ans;\\n    vector<vector<int>> dist;\\n    unordered_set<int> ds; // contains all distinct distances encountered so far from start --> the moment we see k+1 we can exit\\n    void bfs(vector<vector<int>> &g, vector<int> &p, vector<int> &s, int k) {\\n        queue<pii> q;\\n        int row = g.size();\\n        int col = g[0].size();\\n        q.push({s[0], s[1]});\\n        dist[s[0]][s[1]] = 0;\\n        if(!(g[s[0]][s[1]] < p[0] || g[s[0]][s[1]] > p[1])) {\\n            ds.insert(0);\\n            ans.push_back({s[0], s[1]});\\n        }\\n        \\n        while(!q.empty()) {\\n            pii f = q.front();\\n            q.pop();\\n            int x = f.first;\\n            int y = f.second;\\n            int d = dist[x][y];\\n            // cout << \"(x, y) = \" << x << \" \" << y << endl;\\n            for(int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                if(nx < 0 || ny < 0 || nx >= row || ny >= col) {\\n                    continue;\\n                }\\n                if(g[nx][ny] == 0 || (dist[nx][ny]) >= 0) {\\n                    continue;\\n                }\\n                q.push({nx, ny});\\n                dist[nx][ny] = d + 1;\\n                if(g[nx][ny] < p[0] || g[nx][ny] > p[1]) {\\n                    continue;\\n                }\\n                ds.insert(d + 1);\\n                // cout << \"(nx, ny) = \" << nx << \" \" << ny << endl;\\n                if(ds.size() == k + 1) {\\n                    return;\\n                }\\n                ans.push_back({nx, ny});\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        dist = vector<vector<int>> (row, vector<int> (col, -1));\\n        ans = {};\\n        bfs(grid, pricing, start, k);\\n        \\n        auto cmp = [&] (vector<int> &a, vector<int> &b) {\\n            int d1 = dist[a[0]][a[1]];\\n            int d2 = dist[b[0]][b[1]];\\n            if(d1 < d2) {\\n                return true;\\n            } else if(d1 > d2) {\\n                return false;\\n            } else {\\n                if(grid[a[0]][a[1]] < grid[b[0]][b[1]]) {\\n                    return true;\\n                } else if(grid[a[0]][a[1]] > grid[b[0]][b[1]]) {\\n                    return false;\\n                } else {\\n                    if(a[0] < b[0]) {\\n                        return true;\\n                    } else if(a[0] > b[0]) {\\n                        return false;\\n                    } else {\\n                        if(a[1] < b[1]) {\\n                            return true;\\n                        } else if(a[1] > b[1]) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n        \\n        sort(ans.begin(), ans.end(), cmp);\\n        if(ans.size() > k) {\\n            ans.resize(k);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n---------------------------------------------------------------------------------------------------------------------------------\\n\\n// TLE Solution\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pii;\\n    int dx[4] = {1,0, 0,-1};\\n    int dy[4] = {0,1,-1, 0};\\n    vector<vector<int>> ans;\\n    map<pii, int> dist;\\n    unordered_set<int> ds;\\n    void bfs(vector<vector<int>> &g, vector<int> &p, vector<int> &s, int k) {\\n        queue<pii> q;\\n        int row = g.size();\\n        int col = g[0].size();\\n        q.push({s[0], s[1]});\\n        dist[{s[0], s[1]}] = 0;\\n        if(!(g[s[0]][s[1]] < p[0] || g[s[0]][s[1]] > p[1])) {\\n            ds.insert(0);\\n            ans.push_back({s[0], s[1]});\\n        }\\n        \\n        while(!q.empty()) {\\n            pii f = q.front();\\n            q.pop();\\n            int x = f.first;\\n            int y = f.second;\\n            int d = dist[{x, y}];\\n            // cout << \"(x, y) = \" << x << \" \" << y << endl;\\n            for(int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                if(nx < 0 || ny < 0 || nx >= row || ny >= col) {\\n                    continue;\\n                }\\n                if(g[nx][ny] == 0 || (dist.count({nx, ny})) > 0) {\\n                    continue;\\n                }\\n                q.push({nx, ny});\\n                dist[{nx, ny}] = d + 1;\\n                if(g[nx][ny] < p[0] || g[nx][ny] > p[1]) {\\n                    continue;\\n                }\\n                ds.insert(d + 1);\\n                // cout << \"(nx, ny) = \" << nx << \" \" << ny << endl;\\n                if(ds.size() == k + 1) {\\n                    return;\\n                }\\n                ans.push_back({nx, ny});\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        ans = {};\\n        bfs(grid, pricing, start, k);\\n        \\n        auto cmp = [&] (vector<int> &a, vector<int> &b) {\\n            int d1 = dist[{a[0], a[1]}];\\n            int d2 = dist[{b[0], b[1]}];\\n            if(d1 < d2) {\\n                return true;\\n            } else if(d1 > d2) {\\n                return false;\\n            } else {\\n                if(grid[a[0]][a[1]] < grid[b[0]][b[1]]) {\\n                    return true;\\n                } else if(grid[a[0]][a[1]] > grid[b[0]][b[1]]) {\\n                    return false;\\n                } else {\\n                    if(a[0] < b[0]) {\\n                        return true;\\n                    } else if(a[0] > b[0]) {\\n                        return false;\\n                    } else {\\n                        if(a[1] < b[1]) {\\n                            return true;\\n                        } else if(a[1] > b[1]) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n        \\n        sort(ans.begin(), ans.end(), cmp);\\n        if(ans.size() > k) {\\n            ans.resize(k);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1952305,
                "title": "beats-100-percent-cpp-solution-multisource-bfs",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>>bfs(vector<vector<int>>&grid,int x,int y){\\n        int n =grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        vector<vector<int>>lev(n,vector<int>(m,0));\\n        queue<pair<int ,int>>q;\\n        q.push({x,y});\\n        visited[x][y]=true;\\n        while(!q.empty()){\\n            int i =q.front().first;\\n            int j =q.front().second;\\n            q.pop();\\n            if(i-1>=0){\\n                if(grid[i-1][j]>=1 && visited[i-1][j]==false ){\\n                    visited[i-1][j]=true;\\n                    q.push({i-1,j});\\n                    lev[i-1][j]=lev[i][j]+1;\\n                }\\n            }\\n              if(i+1<n){\\n                if(grid[i+1][j]>=1 && visited[i+1][j]==false ){\\n                    visited[i+1][j]=true;\\n                    q.push({i+1,j});\\n                    lev[i+1][j]=lev[i][j]+1;\\n                }\\n            }\\n              if(j-1>=0){\\n                if(grid[i][j-1]>=1 && visited[i][j-1]==false ){\\n                    visited[i][j-1]=true;\\n                    q.push({i,j-1});\\n                    lev[i][j-1]=lev[i][j]+1;\\n                }\\n            }\\n              if(j+1<m){\\n                if(grid[i][j+1]>=1 && visited[i][j+1]==false ){\\n                    visited[i][j+1]=true;\\n                    q.push({i,j+1});\\n                    lev[i][j+1]=lev[i][j]+1;\\n                }\\n            }\\n        }\\n        return lev;\\n    }\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        vector<vector<int>>ans = bfs(grid,start[0],start[1]);\\n       \\npriority_queue<pair<pair<int ,int>,pair<int,int>>, vector<pair<pair<int ,int>,pair<int,int>>>, greater<pair<pair<int ,int>,pair<int,int>>> >p;\\n        for(int i =0;i<ans.size();i++){\\n            for(int j =0;j<ans[0].size();j++){\\n                if(grid[i][j]>1 && ans[i][j]>0){\\n                   // cout<<i<<\" \"<<j<<endl;\\n                    p.push({{ans[i][j],grid[i][j]},{i,j}});\\n                }\\n            }\\n        }\\n        if(grid[start[0]][start[1]]>1){\\n               p.push({{0,grid[start[0]][start[1]]},{start[0],start[1]}});\\n        }\\n        vector<vector<int>>f;\\n       while(!p.empty()){\\n            if(k==0){\\n                break;\\n            }\\n            if(p.top().first.second<=pricing[1] && p.top().first.second>=pricing[0]){\\n                f.push_back({p.top().second.first,p.top().second.second});\\n                p.pop();\\n                k--;\\n            }\\n            else{\\n                p.pop();\\n            }\\n          }\\n        return f;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>>bfs(vector<vector<int>>&grid,int x,int y){\\n        int n =grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        vector<vector<int>>lev(n,vector<int>(m,0));\\n        queue<pair<int ,int>>q;\\n        q.push({x,y}",
                "codeTag": "Java"
            },
            {
                "id": 1943674,
                "title": "bfs-sort",
                "content": "```\\nclass Solution(object):\\n    def calculateRank(self, price, pricing):\\n        if price < pricing[0] or price > pricing[1]:\\n            return False\\n        return True\\n    \\n    def highestRankedKItems(self, grid, pricing, start, k):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type pricing: List[int]\\n        :type start: List[int]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        vis = {}\\n        heap = []\\n        queue = []\\n        queue.append((start[0], start[1]))\\n        level = 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                ele = queue.pop(0)\\n                if ele in vis:\\n                    continue\\n                vis[ele] = level\\n                if self.calculateRank(grid[ele[0]][ele[1]], pricing):\\n                    heap.append((level, grid[ele[0]][ele[1]], ele[0], ele[1]))\\n                dx = [0,0,-1,1]\\n                dy = [-1,1,0,0]\\n                for g in range(4):\\n                    cx = ele[0]+dx[g]\\n                    cy = ele[1]+dy[g]\\n                    if cx < 0 or cx >= n or cy < 0 or cy >= m:\\n                        continue\\n                    if (cx, cy) in vis:\\n                        continue\\n                    if grid[cx][cy] == 0:\\n                        continue\\n                    queue.append((cx, cy))\\n            level+=1\\n        r = [(ele[2], ele[3]) for ele in sorted(heap)]\\n                    \\n        return r[0:k]\\n                   \\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def calculateRank(self, price, pricing):\\n        if price < pricing[0] or price > pricing[1]:\\n            return False\\n        return True\\n    \\n    def highestRankedKItems(self, grid, pricing, start, k):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type pricing: List[int]\\n        :type start: List[int]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        vis = {}\\n        heap = []\\n        queue = []\\n        queue.append((start[0], start[1]))\\n        level = 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                ele = queue.pop(0)\\n                if ele in vis:\\n                    continue\\n                vis[ele] = level\\n                if self.calculateRank(grid[ele[0]][ele[1]], pricing):\\n                    heap.append((level, grid[ele[0]][ele[1]], ele[0], ele[1]))\\n                dx = [0,0,-1,1]\\n                dy = [-1,1,0,0]\\n                for g in range(4):\\n                    cx = ele[0]+dx[g]\\n                    cy = ele[1]+dy[g]\\n                    if cx < 0 or cx >= n or cy < 0 or cy >= m:\\n                        continue\\n                    if (cx, cy) in vis:\\n                        continue\\n                    if grid[cx][cy] == 0:\\n                        continue\\n                    queue.append((cx, cy))\\n            level+=1\\n        r = [(ele[2], ele[3]) for ele in sorted(heap)]\\n                    \\n        return r[0:k]\\n                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920735,
                "title": "c-bfs-sorting-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dir={{1,0},{0,1},{0,-1},{-1,0}};\\n    vector<vector<bool>> visited;\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n=grid.size(),m=grid[0].size();\\n        visited.resize(n,vector<bool>(m));\\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        \\n        visited[start[0]][start[1]]=true;\\n        int distance=0;\\n        vector<vector<int>> temp_ans;\\n        while(!q.empty()){\\n            int s=q.size();\\n            for(int i=0;i<s;i++){\\n                auto [x,y]=q.front();\\n                q.pop();\\n                if(grid[x][y]!=1 && grid[x][y]>=pricing[0] && grid[x][y]<=pricing[1])\\n                    temp_ans.push_back({distance,grid[x][y],x,y});\\n                for(auto [a,b]:dir){\\n                    int xx=x+a,yy=y+b;\\n                    if(xx<0 || yy<0 || xx>=n || yy>=m || visited[xx][yy] || grid[xx][yy]==0)\\n                        continue;\\n                    visited[xx][yy]=true;\\n                    q.push({xx,yy});   \\n\\n                }\\n            }\\n            distance++;\\n        }\\n        sort(temp_ans.begin(),temp_ans.end());\\n        return temp_ans;\\n        vector<vector<int>> ans;\\n        for(int i=0;i<temp_ans.size() && i<k;i++){\\n            ans.push_back({temp_ans[i][2],temp_ans[i][3]});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dir={{1,0},{0,1},{0,-1},{-1,0}};\\n    vector<vector<bool>> visited;\\n    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {\\n        int n=grid.size(),m=grid[0].size();\\n        visited.resize(n,vector<bool>(m));\\n        queue<pair<int,int>> q;\\n        q.push({start[0],start[1]});\\n        \\n        visited[start[0]][start[1]]=true;\\n        int distance=0;\\n        vector<vector<int>> temp_ans;\\n        while(!q.empty()){\\n            int s=q.size();\\n            for(int i=0;i<s;i++){\\n                auto [x,y]=q.front();\\n                q.pop();\\n                if(grid[x][y]!=1 && grid[x][y]>=pricing[0] && grid[x][y]<=pricing[1])\\n                    temp_ans.push_back({distance,grid[x][y],x,y});\\n                for(auto [a,b]:dir){\\n                    int xx=x+a,yy=y+b;\\n                    if(xx<0 || yy<0 || xx>=n || yy>=m || visited[xx][yy] || grid[xx][yy]==0)\\n                        continue;\\n                    visited[xx][yy]=true;\\n                    q.push({xx,yy});   \\n\\n                }\\n            }\\n            distance++;\\n        }\\n        sort(temp_ans.begin(),temp_ans.end());\\n        return temp_ans;\\n        vector<vector<int>> ans;\\n        for(int i=0;i<temp_ans.size() && i<k;i++){\\n            ans.push_back({temp_ans[i][2],temp_ans[i][3]});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855384,
                "title": "bfs-with-heap",
                "content": "```\\nclass Solution {\\n    class Cell {\\n        int distance;\\n        int price;\\n        int row;\\n        int column;\\n        public Cell(int distance, int price, int row, int column) {\\n            this.distance = distance;\\n            this.price = price;\\n            this.row = row;\\n            this.column = column;\\n        }\\n    }\\n    class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    Point[] points = {\\n        new Point(0, -1),\\n        new Point(0, 1),\\n        new Point(1, 0),\\n        new Point(-1, 0)\\n    };\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        PriorityQueue<Cell> minHeap = new PriorityQueue<>((cell1, cell2) -> {\\n            if (cell1.distance != cell2.distance) {\\n                return (cell1.distance < cell2.distance) ? 1 : -1;\\n            }\\n            if (cell1.price != cell2.price) {\\n                return (cell1.price < cell2.price) ? 1 : -1;\\n            }\\n            if (cell1.row != cell2.row) {\\n                return (cell1.row < cell2.row) ? 1 : -1;\\n            }\\n            if (cell1.column != cell2.column) {\\n                return (cell1.column < cell2.column) ? 1 : -1;\\n            }\\n            return 0;\\n        });\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        Queue<Cell> queue = new LinkedList<>();\\n        Cell startingCell = new Cell(0, grid[start[0]][start[1]], start[0], start[1]);\\n        queue.offer(startingCell);\\n        if(grid[start[0]][start[1]] > 1 && pricing[0] <= grid[start[0]][start[1]] && grid[start[0]][start[1]] <= pricing[1]) {\\n            minHeap.offer(startingCell);   \\n        }\\n        visited[start[0]][start[1]] = true;\\n        while (!queue.isEmpty()) {\\n            int currentSize = queue.size();\\n            while (currentSize > 0) {\\n                Cell currentCell = queue.poll();\\n                for (Point point: points) {\\n                    int row = currentCell.row + point.x;\\n                    int column = currentCell.column + point.y;\\n                    if(!(row < 0 || column < 0 || row >= grid.length || column >= grid[0].length || grid[row][column] == 0 || visited[row][column])) {\\n                        Cell cell = new Cell(currentCell.distance + 1, grid[row][column], row, column);\\n                        queue.offer(cell);\\n                        if (grid[row][column] != 1 && pricing[0] <= grid[row][column] && grid[row][column] <= pricing[1]) {\\n                            minHeap.offer(cell);   \\n                        }\\n                        if (minHeap.size() > k) {\\n                            minHeap.poll();\\n                        }\\n                        visited[row][column] = true;\\n                    }\\n                }\\n                currentSize -= 1;\\n            }\\n        }\\n        List<List<Integer>> highestRankedKItems = new ArrayList<>();\\n        while (!minHeap.isEmpty()) {\\n            Cell cell = minHeap.poll();\\n            highestRankedKItems.add(Arrays.asList(new Integer[]{cell.row, cell.column}));\\n        }\\n        Collections.reverse(highestRankedKItems);\\n        return highestRankedKItems;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class Cell {\\n        int distance;\\n        int price;\\n        int row;\\n        int column;\\n        public Cell(int distance, int price, int row, int column) {\\n            this.distance = distance;\\n            this.price = price;\\n            this.row = row;\\n            this.column = column;\\n        }\\n    }\\n    class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    Point[] points = {\\n        new Point(0, -1),\\n        new Point(0, 1),\\n        new Point(1, 0),\\n        new Point(-1, 0)\\n    };\\n    \\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        PriorityQueue<Cell> minHeap = new PriorityQueue<>((cell1, cell2) -> {\\n            if (cell1.distance != cell2.distance) {\\n                return (cell1.distance < cell2.distance) ? 1 : -1;\\n            }\\n            if (cell1.price != cell2.price) {\\n                return (cell1.price < cell2.price) ? 1 : -1;\\n            }\\n            if (cell1.row != cell2.row) {\\n                return (cell1.row < cell2.row) ? 1 : -1;\\n            }\\n            if (cell1.column != cell2.column) {\\n                return (cell1.column < cell2.column) ? 1 : -1;\\n            }\\n            return 0;\\n        });\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        Queue<Cell> queue = new LinkedList<>();\\n        Cell startingCell = new Cell(0, grid[start[0]][start[1]], start[0], start[1]);\\n        queue.offer(startingCell);\\n        if(grid[start[0]][start[1]] > 1 && pricing[0] <= grid[start[0]][start[1]] && grid[start[0]][start[1]] <= pricing[1]) {\\n            minHeap.offer(startingCell);   \\n        }\\n        visited[start[0]][start[1]] = true;\\n        while (!queue.isEmpty()) {\\n            int currentSize = queue.size();\\n            while (currentSize > 0) {\\n                Cell currentCell = queue.poll();\\n                for (Point point: points) {\\n                    int row = currentCell.row + point.x;\\n                    int column = currentCell.column + point.y;\\n                    if(!(row < 0 || column < 0 || row >= grid.length || column >= grid[0].length || grid[row][column] == 0 || visited[row][column])) {\\n                        Cell cell = new Cell(currentCell.distance + 1, grid[row][column], row, column);\\n                        queue.offer(cell);\\n                        if (grid[row][column] != 1 && pricing[0] <= grid[row][column] && grid[row][column] <= pricing[1]) {\\n                            minHeap.offer(cell);   \\n                        }\\n                        if (minHeap.size() > k) {\\n                            minHeap.poll();\\n                        }\\n                        visited[row][column] = true;\\n                    }\\n                }\\n                currentSize -= 1;\\n            }\\n        }\\n        List<List<Integer>> highestRankedKItems = new ArrayList<>();\\n        while (!minHeap.isEmpty()) {\\n            Cell cell = minHeap.poll();\\n            highestRankedKItems.add(Arrays.asList(new Integer[]{cell.row, cell.column}));\\n        }\\n        Collections.reverse(highestRankedKItems);\\n        return highestRankedKItems;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853235,
                "title": "java-simple-solution-using-priorityqueue-bfs-sorting",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                    /*distance*/\\n                if(a[3] != b[3])\\n                    return a[3] - b[3];\\n                \\n                    /*price*/\\n                if(a[0] != b[0])  \\n                    return a[0] - b[0];\\n                \\n                    /*row*/\\n                if(a[1] != b[1])\\n                    return a[1] - b[1];\\n                \\n                    /*column*/\\n                return a[2] - b[2];\\n            }\\n        });\\n        \\n        int[][] dirs = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};\\n        \\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        \\n        q.offer(new int[]{start[0], start[1]});\\n        q.offer(new int[]{-1, -1});\\n        \\n        int dist = 0;\\n        \\n            /*BFS*/\\n        \\n        while(!q.isEmpty()){\\n            int r = q.peek()[0];\\n            int c = q.poll()[1];\\n            \\n            if(r >= 0 && c >= 0){\\n                if(visited[r][c])\\n                    continue;\\n                \\n                if(grid[r][c] > 1 && (grid[r][c] >= pricing[0] && grid[r][c] <= pricing[1]))\\n                    pq.offer(new int[]{grid[r][c], r, c, dist});\\n\\n                visited[r][c] = true;\\n\\n                for(int[] dir: dirs){\\n                    int row = r + dir[0];\\n                    int col = c + dir[1];\\n\\n                    if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || visited[row][col] || grid[row][col] == 0)\\n                        continue;\\n\\n                    q.offer(new int[]{row, col});\\n                }\\n            }\\n            else{\\n                dist++;\\n                \\n                if(!q.isEmpty())\\n                    q.offer(new int[]{-1, -1});\\n            }\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        while(!pq.isEmpty() && k-- > 0){\\n            List<Integer> l = new ArrayList<>();\\n            \\n            l.add(pq.peek()[1]);\\n            l.add(pq.poll()[2]);\\n            \\n            res.add(new ArrayList<>(l));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                    /*distance*/\\n                if(a[3] != b[3])\\n                    return a[3] - b[3];\\n                \\n                    /*price*/\\n                if(a[0] != b[0])  \\n                    return a[0] - b[0];\\n                \\n                    /*row*/\\n                if(a[1] != b[1])\\n                    return a[1] - b[1];\\n                \\n                    /*column*/\\n                return a[2] - b[2];\\n            }\\n        });\\n        \\n        int[][] dirs = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};\\n        \\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        \\n        q.offer(new int[]{start[0], start[1]});\\n        q.offer(new int[]{-1, -1});\\n        \\n        int dist = 0;\\n        \\n            /*BFS*/\\n        \\n        while(!q.isEmpty()){\\n            int r = q.peek()[0];\\n            int c = q.poll()[1];\\n            \\n            if(r >= 0 && c >= 0){\\n                if(visited[r][c])\\n                    continue;\\n                \\n                if(grid[r][c] > 1 && (grid[r][c] >= pricing[0] && grid[r][c] <= pricing[1]))\\n                    pq.offer(new int[]{grid[r][c], r, c, dist});\\n\\n                visited[r][c] = true;\\n\\n                for(int[] dir: dirs){\\n                    int row = r + dir[0];\\n                    int col = c + dir[1];\\n\\n                    if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || visited[row][col] || grid[row][col] == 0)\\n                        continue;\\n\\n                    q.offer(new int[]{row, col});\\n                }\\n            }\\n            else{\\n                dist++;\\n                \\n                if(!q.isEmpty())\\n                    q.offer(new int[]{-1, -1});\\n            }\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        while(!pq.isEmpty() && k-- > 0){\\n            List<Integer> l = new ArrayList<>();\\n            \\n            l.add(pq.peek()[1]);\\n            l.add(pq.poll()[2]);\\n            \\n            res.add(new ArrayList<>(l));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852104,
                "title": "49-49-tc-passed-but-took-too-long",
                "content": "idk how to optimize it further, if anybody can, please do, I used dijkstra algorithm after making a graph from the given matrix...\\n\\n\\n\\n```class Solution {\\npublic:\\nconst static int N = 1e5+10;\\nconst int INF = 1e9 + 7;\\nvector<vector<int>> ans;\\nbool isValid(int x, int y, int n, int m)\\n{\\n    return x >= 0 && y >= 0 && x < n && y < m;\\n}\\nvector<pair<int, int>> movements = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nvoid dijkstra(int source, vector<pair<int, int>> adj[], vector<int> &vis, vector<int> &dist)\\n{\\n    set<pair<long long, long long>> st;\\n    st.insert({0, source});\\n    dist[source] = 0;\\n    while (st.size())\\n    {\\n        auto node = *st.begin();\\n        st.erase(st.begin());\\n        int vert = node.second;\\n        int vert_dist = node.first;\\n        if (vis[vert])\\n            continue;\\n        vis[vert] = 1;\\n        for (auto &child : adj[vert])\\n        {\\n            int child_vert = child.first;\\n            int child_dist = child.second;\\n            if (vert_dist + child_dist < dist[child_vert])\\n            {\\n                dist[child_vert] = vert_dist + child_dist;\\n                st.insert({dist[child_vert], child_vert});\\n            }\\n        }\\n    }\\n}\\n\\nvector<vector<int>> highestRankedKItems(vector<vector<int>> &grid, vector<int> &pricing, vector<int> &start, int k)\\n{\\n    int n = grid.size(), m = grid[0].size(), c = 1;\\n    vector<vector<int>> grid2;\\n    for (int i = 0; i < n; i++)\\n    {\\n        vector<int> temp;\\n        for (int j = 0; j < m; j++)\\n        {\\n            if (grid[i][j] != 0)\\n                temp.push_back(c);\\n            else\\n                temp.push_back(0);\\n            c++;\\n        }\\n        grid2.push_back(temp);\\n    }\\n    vector<pair<int, int>> adj[(n*m)+1];\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            if (grid[i][j] == 0)\\n                continue;\\n            for (auto &movement : movements)\\n            {\\n                int childi = movement.first + i;\\n                int childj = movement.second + j;\\n                if (!(isValid(childi, childj, n, m)) || grid2[childi][childj] == 0)\\n                    continue;\\n                adj[grid2[i][j]].push_back({grid2[childi][childj], 1});\\n            }\\n        }\\n    }\\n    vector<int> vis(N, 0);\\n    vector<int> dist(N, INF);\\n    int source = grid2[start[0]][start[1]];\\n    dijkstra(source, adj, vis, dist);\\n    vector<pair<pair<int, int>, pair<int, int>>> vpp;\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            int valz = grid[i][j];\\n            if (valz >= pricing[0] && valz <= pricing[1] && dist[grid2[i][j]] != INF)\\n                vpp.push_back({{dist[grid2[i][j]], valz}, {i, j}});\\n        }\\n    }\\n    sort(vpp.begin(), vpp.end());\\n    for (int i = 0; i < min(k, (int)vpp.size()); i++)\\n    {\\n        vector<int> freq;\\n        freq.push_back({vpp[i].second.first});\\n        freq.push_back({vpp[i].second.second});\\n        ans.push_back(freq);\\n    }\\n    return ans;\\n}\\n};",
                "solutionTags": [
                    "Sorting",
                    "Ordered Set",
                    "Shortest Path"
                ],
                "code": "class Solution {\\npublic:\\nconst static int N = 1e5+10;\\nconst int INF = 1e9 + 7;\\nvector<vector<int>> ans;\\nbool isValid(int x, int y, int n, int m)\\n{\\n    return x >= 0 && y >= 0 && x < n && y < m;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1828906,
                "title": "java-bfs-sorting-solution",
                "content": "```\\npublic class KHighestRankedItemsWithinPriceRange {\\n    class Item {\\n        int distance;\\n        int price;\\n        int[] position;\\n\\n        public Item(int distance, int price, int[] position) {\\n            this.distance = distance;\\n            this.price = price;\\n            this.position = position;\\n        }\\n    }\\n\\n    private static final int[][] DIRECTIONS = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    private static final int WALL = 0;\\n\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        // initial variables\\n        List<Item> items = new ArrayList<>();\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        Queue<Item> queue = new LinkedList<>();\\n\\n        // set the start position\\n        int startRow = start[0];\\n        int startCol = start[1];\\n        int price = grid[startRow][startCol];\\n        Item firstItem = new Item(0, price, start);\\n\\n        if (price > 1 && priceIsValid(price, pricing)) {\\n            items.add(firstItem);\\n        }\\n\\n        visited[startRow][startCol] = true;\\n        queue.add(firstItem);\\n\\n        // iterate the grid\\n        while(!queue.isEmpty()) {\\n            Item item = queue.remove();\\n            int[] position = item.position;\\n            List<int[]> adjs = findAdj(grid, position);\\n\\n            for (int[] adj : adjs) {\\n                int row = adj[0];\\n                int col = adj[1];\\n\\n                if (!visited[row][col]) {\\n                    visited[row][col] = true;\\n                    int cellValue = grid[row][col];\\n                    Item newItem = new Item(item.distance + 1, cellValue, new int[]{row, col});\\n\\n                    if (cellValue == WALL) {\\n                        continue;\\n                    } else if (priceIsValid(cellValue, pricing)) {\\n                        items.add(newItem);\\n                    }\\n                    queue.add(newItem);\\n                }\\n            }\\n        }\\n\\n        //sort items\\n        Collections.sort(items, new Comparator<Item>() {\\n            @Override\\n            public int compare(Item item1, Item item2) {\\n                if (item1.distance != item2.distance) {\\n                    return item1.distance - item2.distance;\\n                } else if (item1.price != item2.price) {\\n                    return item1.price - item2.price;\\n                } else if (item1.position[0] != item2.position[0]) {\\n                    return item1.position[0] - item2.position[0];\\n                } else if (item1.position[1] != item2.position[1]) {\\n                    return item1.position[1] - item2.position[1];\\n                }\\n                return 0;\\n            }\\n        });\\n\\n        // return result\\n        return items.stream()\\n                .limit(k)\\n                .map(item -> Arrays.stream(item.position).boxed().collect(Collectors.toList()))\\n                .collect(Collectors.toList());\\n    }\\n\\n    private List<int[]> findAdj(int[][] grid, int[] position) {\\n        List<int[]> adjs = new ArrayList<>();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        for (int[] dir : DIRECTIONS) {\\n            int row = position[0] + dir[0];\\n            int col = position[1] + dir[1];\\n\\n            if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == 0) {\\n                continue;\\n            }\\n\\n            adjs.add(new int[]{row, col});\\n        }\\n\\n        return adjs;\\n    }\\n\\n    private boolean priceIsValid(int price, int[] pricing) {\\n        return price >= pricing[0] && price <= pricing[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\npublic class KHighestRankedItemsWithinPriceRange {\\n    class Item {\\n        int distance;\\n        int price;\\n        int[] position;\\n\\n        public Item(int distance, int price, int[] position) {\\n            this.distance = distance;\\n            this.price = price;\\n            this.position = position;\\n        }\\n    }\\n\\n    private static final int[][] DIRECTIONS = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    private static final int WALL = 0;\\n\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        // initial variables\\n        List<Item> items = new ArrayList<>();\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        Queue<Item> queue = new LinkedList<>();\\n\\n        // set the start position\\n        int startRow = start[0];\\n        int startCol = start[1];\\n        int price = grid[startRow][startCol];\\n        Item firstItem = new Item(0, price, start);\\n\\n        if (price > 1 && priceIsValid(price, pricing)) {\\n            items.add(firstItem);\\n        }\\n\\n        visited[startRow][startCol] = true;\\n        queue.add(firstItem);\\n\\n        // iterate the grid\\n        while(!queue.isEmpty()) {\\n            Item item = queue.remove();\\n            int[] position = item.position;\\n            List<int[]> adjs = findAdj(grid, position);\\n\\n            for (int[] adj : adjs) {\\n                int row = adj[0];\\n                int col = adj[1];\\n\\n                if (!visited[row][col]) {\\n                    visited[row][col] = true;\\n                    int cellValue = grid[row][col];\\n                    Item newItem = new Item(item.distance + 1, cellValue, new int[]{row, col});\\n\\n                    if (cellValue == WALL) {\\n                        continue;\\n                    } else if (priceIsValid(cellValue, pricing)) {\\n                        items.add(newItem);\\n                    }\\n                    queue.add(newItem);\\n                }\\n            }\\n        }\\n\\n        //sort items\\n        Collections.sort(items, new Comparator<Item>() {\\n            @Override\\n            public int compare(Item item1, Item item2) {\\n                if (item1.distance != item2.distance) {\\n                    return item1.distance - item2.distance;\\n                } else if (item1.price != item2.price) {\\n                    return item1.price - item2.price;\\n                } else if (item1.position[0] != item2.position[0]) {\\n                    return item1.position[0] - item2.position[0];\\n                } else if (item1.position[1] != item2.position[1]) {\\n                    return item1.position[1] - item2.position[1];\\n                }\\n                return 0;\\n            }\\n        });\\n\\n        // return result\\n        return items.stream()\\n                .limit(k)\\n                .map(item -> Arrays.stream(item.position).boxed().collect(Collectors.toList()))\\n                .collect(Collectors.toList());\\n    }\\n\\n    private List<int[]> findAdj(int[][] grid, int[] position) {\\n        List<int[]> adjs = new ArrayList<>();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        for (int[] dir : DIRECTIONS) {\\n            int row = position[0] + dir[0];\\n            int col = position[1] + dir[1];\\n\\n            if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == 0) {\\n                continue;\\n            }\\n\\n            adjs.add(new int[]{row, col});\\n        }\\n\\n        return adjs;\\n    }\\n\\n    private boolean priceIsValid(int price, int[] pricing) {\\n        return price >= pricing[0] && price <= pricing[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1803313,
                "content": [
                    {
                        "username": "kuznetsov_alv",
                        "content": "The task contains soo many details! Feel like it\\'s not easy to keep all of them in the head. Hope to not face a such one a real interview"
                    },
                    {
                        "username": "c4tdog",
                        "content": "easy , but lot\\'s of coding"
                    },
                    {
                        "username": "illitain",
                        "content": "Hello! \\n\\nCould someone help me please? I can`t understand test case 3:\\ngrid =[[1,1,1],[0,0,1],[2,3,4]]\\npricing = [2,3]\\nstart = [0,0]\\nk = 3\\n\\nWhy is expected output [[2,1],[2,0]]? \\nSince we start at [0,0], can`t go diagonally and distance is the most decisive attribute, the [2,0] cell should be higher-ranked than [2,1] because [2,0] is closer to [0,0].\\nWhat am i missing?\\n\\nThanks in advance. "
                    },
                    {
                        "username": "chaitanya89",
                        "content": "[1,0] & [1,1] are walls. We have to go around them to reach the bottom row. That makes [2,1] closer than [2,0]"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Nitpicking a wordy (though relatively simple) problem for some oversights in its description: \n\nFor clarity, the following sentence: \"The rank is determined by the first of these criteria that is different: \" should further state \"IN THIS ORDER\". The order of the criteria matters, and will change the output otherwise. It is vaguely implied by *giving* you the criteria on separate lines, but requirements ought to be specific and complete. In an interview I'd be sure to ask this.  \n\nFurthermore, it does not specify you can only move orthogonally, as most of these problems do. It does not specifically state that distance is the Manhattan/Taxi distance, just that it is the \"defined as the length of the shortest path from the start\", and that \"It takes 1 step to travel between adjacent grid cells\". But adjacent *can* include diagonals, depending on your definition. It does not always imply orthogonal adjacency only. Again, one can assume they meant \"orthogonally adjacent\", but they really ought to specify. "
                    }
                ]
            },
            {
                "id": 1926423,
                "content": [
                    {
                        "username": "kuznetsov_alv",
                        "content": "The task contains soo many details! Feel like it\\'s not easy to keep all of them in the head. Hope to not face a such one a real interview"
                    },
                    {
                        "username": "c4tdog",
                        "content": "easy , but lot\\'s of coding"
                    },
                    {
                        "username": "illitain",
                        "content": "Hello! \\n\\nCould someone help me please? I can`t understand test case 3:\\ngrid =[[1,1,1],[0,0,1],[2,3,4]]\\npricing = [2,3]\\nstart = [0,0]\\nk = 3\\n\\nWhy is expected output [[2,1],[2,0]]? \\nSince we start at [0,0], can`t go diagonally and distance is the most decisive attribute, the [2,0] cell should be higher-ranked than [2,1] because [2,0] is closer to [0,0].\\nWhat am i missing?\\n\\nThanks in advance. "
                    },
                    {
                        "username": "chaitanya89",
                        "content": "[1,0] & [1,1] are walls. We have to go around them to reach the bottom row. That makes [2,1] closer than [2,0]"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Nitpicking a wordy (though relatively simple) problem for some oversights in its description: \n\nFor clarity, the following sentence: \"The rank is determined by the first of these criteria that is different: \" should further state \"IN THIS ORDER\". The order of the criteria matters, and will change the output otherwise. It is vaguely implied by *giving* you the criteria on separate lines, but requirements ought to be specific and complete. In an interview I'd be sure to ask this.  \n\nFurthermore, it does not specify you can only move orthogonally, as most of these problems do. It does not specifically state that distance is the Manhattan/Taxi distance, just that it is the \"defined as the length of the shortest path from the start\", and that \"It takes 1 step to travel between adjacent grid cells\". But adjacent *can* include diagonals, depending on your definition. It does not always imply orthogonal adjacency only. Again, one can assume they meant \"orthogonally adjacent\", but they really ought to specify. "
                    }
                ]
            },
            {
                "id": 1875314,
                "content": [
                    {
                        "username": "kuznetsov_alv",
                        "content": "The task contains soo many details! Feel like it\\'s not easy to keep all of them in the head. Hope to not face a such one a real interview"
                    },
                    {
                        "username": "c4tdog",
                        "content": "easy , but lot\\'s of coding"
                    },
                    {
                        "username": "illitain",
                        "content": "Hello! \\n\\nCould someone help me please? I can`t understand test case 3:\\ngrid =[[1,1,1],[0,0,1],[2,3,4]]\\npricing = [2,3]\\nstart = [0,0]\\nk = 3\\n\\nWhy is expected output [[2,1],[2,0]]? \\nSince we start at [0,0], can`t go diagonally and distance is the most decisive attribute, the [2,0] cell should be higher-ranked than [2,1] because [2,0] is closer to [0,0].\\nWhat am i missing?\\n\\nThanks in advance. "
                    },
                    {
                        "username": "chaitanya89",
                        "content": "[1,0] & [1,1] are walls. We have to go around them to reach the bottom row. That makes [2,1] closer than [2,0]"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Nitpicking a wordy (though relatively simple) problem for some oversights in its description: \n\nFor clarity, the following sentence: \"The rank is determined by the first of these criteria that is different: \" should further state \"IN THIS ORDER\". The order of the criteria matters, and will change the output otherwise. It is vaguely implied by *giving* you the criteria on separate lines, but requirements ought to be specific and complete. In an interview I'd be sure to ask this.  \n\nFurthermore, it does not specify you can only move orthogonally, as most of these problems do. It does not specifically state that distance is the Manhattan/Taxi distance, just that it is the \"defined as the length of the shortest path from the start\", and that \"It takes 1 step to travel between adjacent grid cells\". But adjacent *can* include diagonals, depending on your definition. It does not always imply orthogonal adjacency only. Again, one can assume they meant \"orthogonally adjacent\", but they really ought to specify. "
                    }
                ]
            },
            {
                "id": 1860153,
                "content": [
                    {
                        "username": "kuznetsov_alv",
                        "content": "The task contains soo many details! Feel like it\\'s not easy to keep all of them in the head. Hope to not face a such one a real interview"
                    },
                    {
                        "username": "c4tdog",
                        "content": "easy , but lot\\'s of coding"
                    },
                    {
                        "username": "illitain",
                        "content": "Hello! \\n\\nCould someone help me please? I can`t understand test case 3:\\ngrid =[[1,1,1],[0,0,1],[2,3,4]]\\npricing = [2,3]\\nstart = [0,0]\\nk = 3\\n\\nWhy is expected output [[2,1],[2,0]]? \\nSince we start at [0,0], can`t go diagonally and distance is the most decisive attribute, the [2,0] cell should be higher-ranked than [2,1] because [2,0] is closer to [0,0].\\nWhat am i missing?\\n\\nThanks in advance. "
                    },
                    {
                        "username": "chaitanya89",
                        "content": "[1,0] & [1,1] are walls. We have to go around them to reach the bottom row. That makes [2,1] closer than [2,0]"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Nitpicking a wordy (though relatively simple) problem for some oversights in its description: \n\nFor clarity, the following sentence: \"The rank is determined by the first of these criteria that is different: \" should further state \"IN THIS ORDER\". The order of the criteria matters, and will change the output otherwise. It is vaguely implied by *giving* you the criteria on separate lines, but requirements ought to be specific and complete. In an interview I'd be sure to ask this.  \n\nFurthermore, it does not specify you can only move orthogonally, as most of these problems do. It does not specifically state that distance is the Manhattan/Taxi distance, just that it is the \"defined as the length of the shortest path from the start\", and that \"It takes 1 step to travel between adjacent grid cells\". But adjacent *can* include diagonals, depending on your definition. It does not always imply orthogonal adjacency only. Again, one can assume they meant \"orthogonally adjacent\", but they really ought to specify. "
                    }
                ]
            }
        ]
    }
]