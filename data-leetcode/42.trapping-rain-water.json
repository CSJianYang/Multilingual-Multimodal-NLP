[
    {
        "title": "Trapping Rain Water",
        "question_content": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n&nbsp;\nExample 1:\n\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\nExample 2:\n\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n\n&nbsp;\nConstraints:\n\n\tn == height.length\n\t1 <= n <= 2 * 104\n\t0 <= height[i] <= 105",
        "solutions": [
            {
                "id": 17357,
                "title": "sharing-my-simple-c-code-o-n-time-o-1-space",
                "content": "    \\nHere is my idea: instead of calculating area by height*width, we can think it in a cumulative way. In other words, sum water amount of each bin(width=1). \\nSearch from left to right and maintain a max height of left and right separately, which is like a one-side wall of  partial container. Fix the higher one and flow water from the lower part. For example, if current height of left is lower, we fill water in the left bin. Until left meets right, we filled the whole container.\\n\\n    class Solution {\\n    public:\\n        int trap(int A[], int n) {\\n            int left=0; int right=n-1;\\n            int res=0;\\n            int maxleft=0, maxright=0;\\n            while(left<=right){\\n                if(A[left]<=A[right]){\\n                    if(A[left]>=maxleft) maxleft=A[left];\\n                    else res+=maxleft-A[left];\\n                    left++;\\n                }\\n                else{\\n                    if(A[right]>=maxright) maxright= A[right];\\n                    else res+=maxright-A[right];\\n                    right--;\\n                }\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trap(int A[], int n) {\\n            int left=0; int right=n-1;\\n            int res=0;\\n            int maxleft=0, maxright=0;\\n            while(left<=right){\\n                if(A[left]<=A[right]){\\n                    if(A[left]>=maxleft) maxleft=A[left];\\n                    else res+=maxleft-A[left];\\n                    left++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 153992,
                "title": "java-o-n-time-and-o-1-space-with-explanations",
                "content": "Here\\'s how we can arrive at this solution:\\n\\nLet\\'s think about the absolute simplest case: we\\'ve got a [2,1,3] array, telling us that we can trap 1 block of rainwater.\\n\\nHow we arrive to this, is pretty simple, we know that because we\\'ve got a two at the beginning, we can only fill up to two blocks of water per point, and we know that we can only do that at a point after two, and we know that we can do it at all because 3, at the end of the array, would be able to contain the water, so we can add water until we get to 3, and can only add 2 - the height of the point.\\n\\nSo, if we had something a little more complex, like [2, 1, 3, 1, 4], we could fill up to the 3 optimally, and then repear the same algorithm from the 3 onward. However, if we had, instead, [2, 1, 3, 1, 2] we would fill up to the 3, and then see that we cannot fill over to the 2 because we would overflow, so we instead mirror the algorithm and bring from the 2 backward.\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        if (height == null || height.length == 0) {\\n            return 0;\\n        }\\n        int left = 0; int right = height.length - 1; // Pointers to both ends of the array.\\n        int maxLeft = 0; int maxRight = 0;\\n        \\n        int totalWater = 0;\\n        while (left < right) {\\n            // Water could, potentially, fill everything from left to right, if there is nothing in between.\\n            if (height[left] < height[right]) {\\n                // If the current elevation is greater than the previous maximum, water cannot occupy that point at all.\\n                // However, we do know that everything from maxLeft to the current index, has been optimally filled, as we\\'ve\\n                // been adding water to the brim of the last maxLeft.\\n                if (height[left] >= maxLeft) { \\n                    // So, we say we\\'ve found a new maximum, and look to see how much water we can fill from this point on.\\n                    maxLeft = height[left]; \\n                // If we\\'ve yet to find a maximum, we know that we can fill the current point with water up to the previous\\n                // maximum, as any more will overflow it. We also subtract the current height, as that is the elevation the\\n                // ground will be at.\\n                } else { \\n                    totalWater += maxLeft - height[left]; \\n                }\\n                // Increment left, we\\'ll now look at the next point.\\n                left++;\\n            // If the height at the left is NOT greater than height at the right, we cannot fill from left to right without over-\\n            // flowing; however, we do know that we could potentially fill from right to left, if there is nothing in between.\\n            } else {\\n                // Similarly to above, we see that we\\'ve found a height greater than the max, and cannot fill it whatsoever, but\\n                // everything before is optimally filled\\n                if (height[right] >= maxRight) { \\n                    // We can say we\\'ve found a new maximum and move on.  \\n                    maxRight = height[right]; \\n                // If we haven\\'t found a greater elevation, we can fill the current elevation with maxRight - height[right]\\n                // water.\\n                } else {\\n                    totalWater += maxRight - height[right]; \\n                }\\n                // Decrement left, we\\'ll look at the next point.\\n                right--;\\n            }\\n        }\\n        // Return the sum we\\'ve been adding to.\\n        return totalWater;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        if (height == null || height.length == 0) {\\n            return 0;\\n        }\\n        int left = 0; int right = height.length - 1; // Pointers to both ends of the array.\\n        int maxLeft = 0; int maxRight = 0;\\n        \\n        int totalWater = 0;\\n        while (left < right) {\\n            // Water could, potentially, fill everything from left to right, if there is nothing in between.\\n            if (height[left] < height[right]) {\\n                // If the current elevation is greater than the previous maximum, water cannot occupy that point at all.\\n                // However, we do know that everything from maxLeft to the current index, has been optimally filled, as we\\'ve\\n                // been adding water to the brim of the last maxLeft.\\n                if (height[left] >= maxLeft) { \\n                    // So, we say we\\'ve found a new maximum, and look to see how much water we can fill from this point on.\\n                    maxLeft = height[left]; \\n                // If we\\'ve yet to find a maximum, we know that we can fill the current point with water up to the previous\\n                // maximum, as any more will overflow it. We also subtract the current height, as that is the elevation the\\n                // ground will be at.\\n                } else { \\n                    totalWater += maxLeft - height[left]; \\n                }\\n                // Increment left, we\\'ll now look at the next point.\\n                left++;\\n            // If the height at the left is NOT greater than height at the right, we cannot fill from left to right without over-\\n            // flowing; however, we do know that we could potentially fill from right to left, if there is nothing in between.\\n            } else {\\n                // Similarly to above, we see that we\\'ve found a height greater than the max, and cannot fill it whatsoever, but\\n                // everything before is optimally filled\\n                if (height[right] >= maxRight) { \\n                    // We can say we\\'ve found a new maximum and move on.  \\n                    maxRight = height[right]; \\n                // If we haven\\'t found a greater elevation, we can fill the current elevation with maxRight - height[right]\\n                // water.\\n                } else {\\n                    totalWater += maxRight - height[right]; \\n                }\\n                // Decrement left, we\\'ll look at the next point.\\n                right--;\\n            }\\n        }\\n        // Return the sum we\\'ve been adding to.\\n        return totalWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17391,
                "title": "share-my-short-solution",
                "content": "Keep track of the maximum height from both forward directions backward directions, call them leftmax and rightmax. \\n\\n----------\\n\\n    public int trap(int[] A){\\n        int a=0;\\n        int b=A.length-1;\\n        int max=0;\\n        int leftmax=0;\\n        int rightmax=0;\\n        while(a<=b){\\n            leftmax=Math.max(leftmax,A[a]);\\n            rightmax=Math.max(rightmax,A[b]);\\n            if(leftmax<rightmax){\\n                max+=(leftmax-A[a]);       // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored\\n                a++;\\n            }\\n            else{\\n                max+=(rightmax-A[b]);\\n                b--;\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "Keep track of the maximum height from both forward directions backward directions, call them leftmax and rightmax. \\n\\n----------\\n\\n    public int trap(int[] A){\\n        int a=0;\\n        int b=A.length-1;\\n        int max=0;\\n        int leftmax=0;\\n        int rightmax=0;\\n        while(a<=b){\\n            leftmax=Math.max(leftmax,A[a]);\\n            rightmax=Math.max(rightmax,A[b]);\\n            if(leftmax<rightmax){\\n                max+=(leftmax-A[a]);       // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored\\n                a++;\\n            }\\n            else{\\n                max+=(rightmax-A[b]);\\n                b--;\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1374608,
                "title": "c-java-python-maxleft-maxright-so-far-with-picture-o-1-space-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Max Left, Max Right So Far!**\\n- A `ith` bar can trap the water if and only if there exists a higher bar to the left and a higher bar to the right of `ith` bar.\\n- To calculate how much amount of water the `ith` bar can trap, we need to look at the maximum height of the left bar and the maximum height of the right bar, then\\n\\t- The water level can be formed at `ith` bar is: `waterLevel = min(maxLeft[i], maxRight[i])`\\n\\t- If `waterLevel >= height[i]` then `ith` bar can trap `waterLevel - height[i]` amount of water.\\n- To achieve in O(1) when looking at the maximum height of the bar on the left side and on the right side of `ith` bar, we pre-compute it:\\n\\t- Let `maxLeft[i]` is the maximum height of the bar on the left side of `ith` bar.\\n\\t- Let `maxRight[i]` is the maximum height of the bar on the right side of `ith` bar.\\n\\n![image](https://assets.leetcode.com/users/images/defee20d-dca9-4244-8817-2f158efecc55_1627750629.6494076.png)\\n\\n<iframe src=\"https://leetcode.com/playground/DqjGWjTX/shared\" frameBorder=\"0\" width=\"100%\" height=\"380\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 3*10^4` is number of bars.\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Two Pointers**\\n- Same idea with solution 1, but now we don\\'t need to build `maxLeft` and `maxRight` arrays, we will calculate `maxLeft` and `maxRight` as we go.\\n- We start with `maxLeft = height[0], maxRight = height[n-1]`, using 2 pointers `left` point to the next bar on the left side, `right` point to the next bar on the right side.\\n- How to decide to move `left` or move `right`?\\n\\t- If `maxLeft < maxRight`, it means the water level is based on the left side (the left bar is smaller) then move left side:\\n\\t\\t- If `height[left] > maxLeft` then there is no trap water, we update maxLeft by `maxLeft = height[left]`.\\n\\t\\t- Else if `height[left] < maxLeft` then it can trap an amount of water, which is `maxLeft - height[left]`.\\n\\t\\t- Move left by `left += 1`\\n\\t- Else if `maxLeft > maxRight`, it means the water level is based on the right side (the right bar is smaller) then move right side:\\n\\t\\t- If `height[right] > maxRight` then there is no trap water, we update maxRight by `maxRight = height[right]`.\\n\\t\\t- Else if `height[right] < maxRight` then it can trap an amount of water, which is `maxRight - height[right]`.\\n\\t\\t- Move right by `right -= 1`. \\n\\n<iframe src=\"https://leetcode.com/playground/f3Qoj7vT/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 3*10^4` is number of bars.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Max Left, Max Right So Far!**\\n- A `ith` bar can trap the water if and only if there exists a higher bar to the left and a higher bar to the right of `ith` bar.\\n- To calculate how much amount of water the `ith` bar can trap, we need to look at the maximum height of the left bar and the maximum height of the right bar, then\\n\\t- The water level can be formed at `ith` bar is: `waterLevel = min(maxLeft[i], maxRight[i])`\\n\\t- If `waterLevel >= height[i]` then `ith` bar can trap `waterLevel - height[i]` amount of water.\\n- To achieve in O(1) when looking at the maximum height of the bar on the left side and on the right side of `ith` bar, we pre-compute it:\\n\\t- Let `maxLeft[i]` is the maximum height of the bar on the left side of `ith` bar.\\n\\t- Let `maxRight[i]` is the maximum height of the bar on the right side of `ith` bar.\\n\\n![image](https://assets.leetcode.com/users/images/defee20d-dca9-4244-8817-2f158efecc55_1627750629.6494076.png)\\n\\n<iframe src=\"https://leetcode.com/playground/DqjGWjTX/shared\" frameBorder=\"0\" width=\"100%\" height=\"380\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 3*10^4` is number of bars.\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Two Pointers**\\n- Same idea with solution 1, but now we don\\'t need to build `maxLeft` and `maxRight` arrays, we will calculate `maxLeft` and `maxRight` as we go.\\n- We start with `maxLeft = height[0], maxRight = height[n-1]`, using 2 pointers `left` point to the next bar on the left side, `right` point to the next bar on the right side.\\n- How to decide to move `left` or move `right`?\\n\\t- If `maxLeft < maxRight`, it means the water level is based on the left side (the left bar is smaller) then move left side:\\n\\t\\t- If `height[left] > maxLeft` then there is no trap water, we update maxLeft by `maxLeft = height[left]`.\\n\\t\\t- Else if `height[left] < maxLeft` then it can trap an amount of water, which is `maxLeft - height[left]`.\\n\\t\\t- Move left by `left += 1`\\n\\t- Else if `maxLeft > maxRight`, it means the water level is based on the right side (the right bar is smaller) then move right side:\\n\\t\\t- If `height[right] > maxRight` then there is no trap water, we update maxRight by `maxRight = height[right]`.\\n\\t\\t- Else if `height[right] < maxRight` then it can trap an amount of water, which is `maxRight - height[right]`.\\n\\t\\t- Move right by `right -= 1`. \\n\\n<iframe src=\"https://leetcode.com/playground/f3Qoj7vT/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 3*10^4` is number of bars.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 17364,
                "title": "7-lines-c-c",
                "content": "Keep track of the already safe `level` and the total `water` so far. In each step, process and discard the `lower` one of the leftmost or rightmost elevation.\\n\\n---\\n\\n**C**\\n\\nChanging the given parameters to discard the lower border. I'm quite fond of this one.\\n\\n    int trap(int* height, int n) {\\n        int level = 0, water = 0;\\n        while (n--) {\\n            int lower = *height < height[n] ? *height++ : height[n];\\n            if (lower > level) level = lower;\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\nSlight variation with two pointers (left and right).\\n\\n    int trap(int* height, int n) {\\n        int *L = height, *R = L+n-1, level = 0, water = 0;\\n        while (L < R) {\\n            int lower = *L < *R ? *L++ : *R--;\\n            if (lower > level) level = lower;\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\n---\\n\\n**C++**\\n\\nWith left and right index.\\n\\n    int trap(vector<int>& height) {\\n        int l = 0, r = height.size()-1, level = 0, water = 0;\\n        while (l < r) {\\n            int lower = height[height[l] < height[r] ? l++ : r--];\\n            level = max(level, lower);\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\nWith left and right iterator.\\n\\n    int trap(vector<int>& height) {\\n        auto l = height.begin(), r = height.end() - 1;\\n        int level = 0, water = 0;\\n        while (l != r + 1) {\\n            int lower = *l < *r ? *l++ : *r--;\\n            level = max(level, lower);\\n            water += level - lower;\\n        }\\n        return water;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Keep track of the already safe `level` and the total `water` so far. In each step, process and discard the `lower` one of the leftmost or rightmost elevation.\\n\\n---\\n\\n**C**\\n\\nChanging the given parameters to discard the lower border. I'm quite fond of this one.\\n\\n    int trap(int* height, int n) {\\n        int level = 0, water = 0;\\n        while (n--) {\\n            int lower = *height < height[n] ? *height++ : height[n];\\n            if (lower > level) level = lower;\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\nSlight variation with two pointers (left and right).\\n\\n    int trap(int* height, int n) {\\n        int *L = height, *R = L+n-1, level = 0, water = 0;\\n        while (L < R) {\\n            int lower = *L < *R ? *L++ : *R--;\\n            if (lower > level) level = lower;\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\n---\\n\\n**C++**\\n\\nWith left and right index.\\n\\n    int trap(vector<int>& height) {\\n        int l = 0, r = height.size()-1, level = 0, water = 0;\\n        while (l < r) {\\n            int lower = height[height[l] < height[r] ? l++ : r--];\\n            level = max(level, lower);\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\nWith left and right iterator.\\n\\n    int trap(vector<int>& height) {\\n        auto l = height.begin(), r = height.end() - 1;\\n        int level = 0, water = 0;\\n        while (l != r + 1) {\\n            int lower = *l < *r ? *l++ : *r--;\\n            level = max(level, lower);\\n            water += level - lower;\\n        }\\n        return water;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17414,
                "title": "a-stack-based-solution-for-reference-inspired-by-histogram",
                "content": "Indeed this question can be solved in one pass and O(1) space, but it's probably hard to come up with in a short interview. If you have read the stack O(n) solution for Largest Rectangle in Histogram, you will find this solution is very very similar. \\n\\nThe main idea is : if we want to find out how much water on a bar(bot), we need to find out the left larger bar's index (il), and right larger bar's index(ir), so that the water is (min(A[il],A[ir])-A[bot])*(ir-il-1), use min since only the lower boundary can hold water, and we also need to handle the edge case that there is no il.\\n\\nTo implement this we use a stack that store the indices with decreasing bar height, once we find a bar who's height is larger, then let the top of the stack be bot, the cur bar is ir, and the previous bar is il. \\n\\n\\n    public int trap(int[] A) {\\n            if (A==null) return 0;\\n            Stack<Integer> s = new Stack<Integer>();\\n            int i = 0, maxWater = 0, maxBotWater = 0;\\n            while (i < A.length){\\n                if (s.isEmpty() || A[i]<=A[s.peek()]){\\n                    s.push(i++);\\n                }\\n                else {\\n                    int bot = s.pop();\\n                    maxBotWater = s.isEmpty()? // empty means no il\\n                    0:(Math.min(A[s.peek()],A[i])-A[bot])*(i-s.peek()-1);\\n                    maxWater += maxBotWater;\\n                }\\n            }\\n            return maxWater;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Indeed this question can be solved in one pass and O(1) space, but it's probably hard to come up with in a short interview. If you have read the stack O(n) solution for Largest Rectangle in Histogram, you will find this solution is very very similar. \\n\\nThe main idea is : if we want to find out how much water on a bar(bot), we need to find out the left larger bar's index (il), and right larger bar's index(ir), so that the water is (min(A[il],A[ir])-A[bot])*(ir-il-1), use min since only the lower boundary can hold water, and we also need to handle the edge case that there is no il.\\n\\nTo implement this we use a stack that store the indices with decreasing bar height, once we find a bar who's height is larger, then let the top of the stack be bot, the cur bar is ir, and the previous bar is il. \\n\\n\\n    public int trap(int[] A) {\\n            if (A==null) return 0;\\n            Stack<Integer> s = new Stack<Integer>();\\n            int i = 0, maxWater = 0, maxBotWater = 0;\\n            while (i < A.length){\\n                if (s.isEmpty() || A[i]<=A[s.peek()]){\\n                    s.push(i++);\\n                }\\n                else {\\n                    int bot = s.pop();\\n                    maxBotWater = s.isEmpty()? // empty means no il\\n                    0:(Math.min(A[s.peek()],A[i])-A[bot])*(i-s.peek()-1);\\n                    maxWater += maxBotWater;\\n                }\\n            }\\n            return maxWater;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3401992,
                "title": "100-detailed-explaination-with-pictures-in-c-java-python-two-pointers",
                "content": "# Approach\\n- Here the approach is like we basically find the left max and right max and based on that we start our movement in two pointer , first have a glance at the below depicted figure which is later followed by explaination.\\n\\n![pic1.png](https://assets.leetcode.com/users/images/d5703973-8ea3-4427-8e28-a6cd53053572_1681157571.4794183.webp)\\n\\n>- As shown in the figure we start with finding the left most height and the right most height and then we do left++ , right-- and continue. Now if the new left height is greater than max left height then we update the lmax height and similarly for the right side.\\n>- When This is not the case the we proceed with the side with the minimum height , say it\\'s left for the further understanding , now we take the difference b/w the left heights and add to the water stored $i.e$ `water += lmax - height[lpos];` or `water += rmax - height[rpos];` according to the current scenario as explained above.\\n\\n>- In the same way depicted above we further continue till the loop $i.e$ ends `while(lpos <= ros)` then we would finally obtain the water which can be trapped during this process.\\n\\n---\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int lmax = height[0];\\n        int rmax = height[n-1];\\n        int lpos = 1;\\n        int rpos = n-2;\\n        int water = 0;\\n        while(lpos <= rpos)\\n        {\\n            if(height[lpos] >= lmax)\\n            {\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax)\\n            {\\n                rmax = height[rpos];\\n                rpos--;\\n            }\\n            else if(lmax <= rmax && height[lpos] < lmax)\\n            {\\n                water += lmax - height[lpos];\\n                lpos++;\\n            }\\n            else\\n            {\\n                water += rmax - height[rpos];\\n                rpos--;\\n            }\\n        \\n        }\\n        return water;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int leftMax = height[0], rightMax = height[height.length - 1];\\n        int water = 0;\\n        while (left < right) {\\n            if (leftMax < rightMax) {\\n                left++;\\n                if (leftMax < height[left]) {\\n                    leftMax = height[left];\\n                } else {\\n                    water += leftMax - height[left];\\n                }\\n            } else {\\n                right--;\\n                if (rightMax < height[right]) {\\n                    rightMax = height[right];\\n                } else {\\n                    water += rightMax - height[right];\\n                }\\n            }\\n        }\\n        return water;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def sumBackets(self, height: list[int], left, right):\\n\\n        minHeightLeft = height[left]\\n        total = 0\\n        leftBacket = 0\\n        locationMinLeft = left\\n\\n        while left < right:\\n            \\n            if height[left] < minHeightLeft:\\n                leftBacket += minHeightLeft - height[left]                \\n            else:\\n                minHeightLeft = height[left]\\n                total +=  leftBacket\\n                leftBacket = 0\\n                locationMinLeft = left            \\n            left += 1\\n            \\n        if minHeightLeft <= height[right]:\\n             return total + leftBacket, right\\n        else :      \\n            return total, locationMinLeft\\n\\n    def sumBacketsReverce(self, height: list[int], left, right):\\n\\n        minHeightRight = height[right]\\n        total = 0\\n        rightBacket = 0\\n        locationMinRight = right\\n\\n        while left < right:\\n            \\n            if height[right] < minHeightRight:\\n                rightBacket += minHeightRight - height[right]                \\n            else :\\n                minHeightRight = height[right]\\n                total +=  rightBacket\\n                rightBacket = 0\\n                locationMinRight = right            \\n            right -= 1\\n\\n\\n        if minHeightRight <= height[left]:\\n            return total + rightBacket, left\\n        else :\\n            return total, locationMinRight\\n    \\n    def trap(self, height: List[int]) -> int:                      \\n        right = len(height)-1\\n        left =0\\n        totalSum =0\\n\\n\\n        while left < right-1:            \\n            if( height[left]< height[right]):\\n                total, left = self.sumBackets(height, left, right)    \\n            else:\\n                total, right = self.sumBacketsReverce(height, left, right)        \\n                \\n            totalSum += total       \\n             \\n        return totalSum\\n```\\n---\\n\\n# Complexity\\n>- Time complexity:Here the time complexity would be $O(n)$ as there is only one loop running in the two pointers.\\n\\n>- Space complexity:Here the space complexity is constant as we are not creating any extra space excluding the variables.\\n\\n---\\n\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/6fd15896-4c61-47f8-83ed-1b69586ead07_1681158160.5226042.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int lmax = height[0];\\n        int rmax = height[n-1];\\n        int lpos = 1;\\n        int rpos = n-2;\\n        int water = 0;\\n        while(lpos <= rpos)\\n        {\\n            if(height[lpos] >= lmax)\\n            {\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax)\\n            {\\n                rmax = height[rpos];\\n                rpos--;\\n            }\\n            else if(lmax <= rmax && height[lpos] < lmax)\\n            {\\n                water += lmax - height[lpos];\\n                lpos++;\\n            }\\n            else\\n            {\\n                water += rmax - height[rpos];\\n                rpos--;\\n            }\\n        \\n        }\\n        return water;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int leftMax = height[0], rightMax = height[height.length - 1];\\n        int water = 0;\\n        while (left < right) {\\n            if (leftMax < rightMax) {\\n                left++;\\n                if (leftMax < height[left]) {\\n                    leftMax = height[left];\\n                } else {\\n                    water += leftMax - height[left];\\n                }\\n            } else {\\n                right--;\\n                if (rightMax < height[right]) {\\n                    rightMax = height[right];\\n                } else {\\n                    water += rightMax - height[right];\\n                }\\n            }\\n        }\\n        return water;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def sumBackets(self, height: list[int], left, right):\\n\\n        minHeightLeft = height[left]\\n        total = 0\\n        leftBacket = 0\\n        locationMinLeft = left\\n\\n        while left < right:\\n            \\n            if height[left] < minHeightLeft:\\n                leftBacket += minHeightLeft - height[left]                \\n            else:\\n                minHeightLeft = height[left]\\n                total +=  leftBacket\\n                leftBacket = 0\\n                locationMinLeft = left            \\n            left += 1\\n            \\n        if minHeightLeft <= height[right]:\\n             return total + leftBacket, right\\n        else :      \\n            return total, locationMinLeft\\n\\n    def sumBacketsReverce(self, height: list[int], left, right):\\n\\n        minHeightRight = height[right]\\n        total = 0\\n        rightBacket = 0\\n        locationMinRight = right\\n\\n        while left < right:\\n            \\n            if height[right] < minHeightRight:\\n                rightBacket += minHeightRight - height[right]                \\n            else :\\n                minHeightRight = height[right]\\n                total +=  rightBacket\\n                rightBacket = 0\\n                locationMinRight = right            \\n            right -= 1\\n\\n\\n        if minHeightRight <= height[left]:\\n            return total + rightBacket, left\\n        else :\\n            return total, locationMinRight\\n    \\n    def trap(self, height: List[int]) -> int:                      \\n        right = len(height)-1\\n        left =0\\n        totalSum =0\\n\\n\\n        while left < right-1:            \\n            if( height[left]< height[right]):\\n                total, left = self.sumBackets(height, left, right)    \\n            else:\\n                total, right = self.sumBacketsReverce(height, left, right)        \\n                \\n            totalSum += total       \\n             \\n        return totalSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17386,
                "title": "sharing-my-java-code-o-n-time-o-1-space",
                "content": "Traverse one pass with two pointers, from two sides to the middle.\\n\\n\\n    public int trap(int[] A) {\\n        if (A.length < 3) return 0;\\n        \\n        int ans = 0;\\n        int l = 0, r = A.length - 1;\\n        \\n        // find the left and right edge which can hold water\\n        while (l < r && A[l] <= A[l + 1]) l++;\\n        while (l < r && A[r] <= A[r - 1]) r--;\\n        \\n        while (l < r) {\\n            int left = A[l];\\n            int right = A[r];\\n            if (left <= right) {\\n                // add volum until an edge larger than the left edge\\n                while (l < r && left >= A[++l]) {\\n                    ans += left - A[l];\\n                }\\n            } else {\\n                // add volum until an edge larger than the right volum\\n                while (l < r && A[--r] <= right) {\\n                    ans += right - A[r];\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Traverse one pass with two pointers, from two sides to the middle.\\n\\n\\n    public int trap(int[] A) {\\n        if (A.length < 3) return 0;\\n        \\n        int ans = 0;\\n        int l = 0, r = A.length - 1;\\n        \\n        // find the left and right edge which can hold water\\n        while (l < r && A[l] <= A[l + 1]) l++;\\n        while (l < r && A[r] <= A[r - 1]) r--;\\n        \\n        while (l < r) {\\n            int left = A[l];\\n            int right = A[r];\\n            if (left <= right) {\\n                // add volum until an edge larger than the left edge\\n                while (l < r && left >= A[++l]) {\\n                    ans += left - A[l];\\n                }\\n            } else {\\n                // add volum until an edge larger than the right volum\\n                while (l < r && A[--r] <= right) {\\n                    ans += right - A[r];\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17527,
                "title": "my-accepted-java-solution",
                "content": "    public class Solution {\\n    public int trap(int[] height) {\\n        if (height.length <= 2) return 0;\\n        int max = Integer.MIN_VALUE;\\n        int maxIndex = -1;\\n        for (int i = 0; i < height.length; i++) {\\n            if (height[i] > max) {\\n                max = height[i];\\n                maxIndex = i;\\n            }\\n        }\\n        \\n        int leftMax = height[0];\\n        int water = 0;\\n        for (int i = 1; i < maxIndex; i++) {\\n            if (height[i] > leftMax) {\\n                leftMax = height[i];\\n            } else {\\n                water += leftMax - height[i];\\n            }\\n        }\\n        \\n        int rightMax = height[height.length - 1];\\n        for (int i = height.length - 2; i > maxIndex; i--) {\\n            if (height[i] > rightMax) {\\n                rightMax = height[i];\\n            } else {\\n                water += rightMax - height[i];\\n            }\\n        }\\n        \\n        return water;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int trap(int[] height) {\\n        if (height.length <= 2) return 0;\\n        int max = Integer.MIN_VALUE;\\n        int maxIndex = -1;\\n        for (int i = 0; i < height.length; i++) {\\n            if (height[i] > max) {\\n                max = height[i];\\n                maxIndex = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 17554,
                "title": "share-my-one-pass-python-solution-with-explaination",
                "content": "For index i, the water volume of i: `vol_i = min(left_max_i, right_max_i) - bar_i`. \\n\\nThe left_max array from left to right is always non-descending,  the right_max is non-ascending.\\n\\nHaving such observation, we can say:\\n\\nGiven i < j, if left_max_i <= right_max_j: `vol_i = left_max_i - bar_i`, otherwise, `vol_j = right_max_j - bar_j` \\nbecause, if left_max_i <= right_max_j: `left_max_i <= right_max_j <= right_max_j-1 <= ... <= right_max_i`, then `min(left_max_i, right_max_i)` is always `left_max_i`\\n\\nCode is pasted.\\n\\n    def trap(self, bars):\\n        if not bars or len(bars) < 3:\\n            return 0\\n        volume = 0\\n        left, right = 0, len(bars) - 1\\n        l_max, r_max = bars[left], bars[right]\\n        while left < right:\\n            l_max, r_max = max(bars[left], l_max), max(bars[right], r_max)\\n            if l_max <= r_max:\\n                volume += l_max - bars[left]\\n                left += 1\\n            else:\\n                volume += r_max - bars[right]\\n                right -= 1\\n        return volume",
                "solutionTags": [
                    "Python"
                ],
                "code": "For index i, the water volume of i: `vol_i = min(left_max_i, right_max_i) - bar_i`. \\n\\nThe left_max array from left to right is always non-descending,  the right_max is non-ascending.\\n\\nHaving such observation, we can say:\\n\\nGiven i < j, if left_max_i <= right_max_j: `vol_i = left_max_i - bar_i`, otherwise, `vol_j = right_max_j - bar_j` \\nbecause, if left_max_i <= right_max_j: `left_max_i <= right_max_j <= right_max_j-1 <= ... <= right_max_i`, then `min(left_max_i, right_max_i)` is always `left_max_i`\\n\\nCode is pasted.\\n\\n    def trap(self, bars):\\n        if not bars or len(bars) < 3:\\n            return 0\\n        volume = 0\\n        left, right = 0, len(bars) - 1\\n        l_max, r_max = bars[left], bars[right]\\n        while left < right:\\n            l_max, r_max = max(bars[left], l_max), max(bars[right], r_max)\\n            if l_max <= r_max:\\n                volume += l_max - bars[left]\\n                left += 1\\n            else:\\n                volume += r_max - bars[right]\\n                right -= 1\\n        return volume",
                "codeTag": "Python3"
            },
            {
                "id": 178028,
                "title": "stack-with-explanation-java-python-scala",
                "content": "> When is water trapped?\\nWater is trapped when an increasing height appears.\\n```\\n        __     __rightUpper2\\nleftUpper |  _|\\n          |_| rightUpper1\\n           ^\\n      lowerHeight\\nrightUpper1 traps 1 x 1(width x height) units of water.\\nrightUpper2 traps 2 x 1(width x height) units of water.\\n```\\n> Stack store decreasing heights that can be possible `leftUpper` .\\nWhenever we meet a `rightUpper`, we should accumulate water trapped.\\n\\n> How much water is trapped because of the `rightUpper`?\\nwater trapped = width * height\\nThe width of water trapped depends on distance from `leftUpper` to `rightUpper`, so we save index rather than height\\nThe height of water trapped depends on `min(leftUpper, rightUpper) - lowerHeight`.\\n\\n****\\n**Java**\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Stack<Integer> stack = new Stack<>();\\n        int totalWater = 0;\\n        for (int right = 0; right < height.length; right++) {\\n            while (!stack.isEmpty() \\n                   && height[stack.peek()] < height[right]) {\\n                int bottom = stack.pop();\\n                if (stack.isEmpty()) {\\n                    break;\\n                }\\n                int left = stack.peek();\\n                // Identified water trapped = width * height\\n                int water = (right - left - 1) * \\n                    (Math.min(height[right], height[left]) - height[bottom]);\\n                totalWater += water;\\n            }\\n            stack.push(right);\\n        }\\n        return totalWater;\\n    }\\n}\\n```\\n**Python**\\n```\\n    def trap(self, height):\\n        decreasingHeightStack, totalWaterTrapped = [], 0\\n        \\n        for i, v in enumerate(height):\\n            while len(decreasingHeightStack) > 0 and height[decreasingHeightStack[-1]] < v:\\n                bottomHeight = height[decreasingHeightStack.pop()]\\n                if len(decreasingHeightStack) == 0:\\n                    break\\n                leftUpperIndex = decreasingHeightStack[-1]\\n                heightDiff = min(height[leftUpperIndex], v) - bottomHeight\\n                width = i - leftUpperIndex - 1\\n                totalWaterTrapped += heightDiff * width\\n                \\n            decreasingHeightStack.append(i)\\n            \\n        return totalWaterTrapped\\n```\\n**Scala**\\n```\\n    def trap(height: Array[Int]): Int = {\\n        val stack = new Stack[Int]()\\n        var waterTrapped = 0\\n\\n        for (i <- 0 to height.size - 1) {\\n            while (!stack.isEmpty && height(i) > height(stack.top)) { // With water trapped.\\n                val bottomHeight = height(stack.pop())\\n                if (!stack.isEmpty) {\\n                    val leftHeight = height(stack.top)\\n                    val width = i - stack.top - 1\\n                    waterTrapped += width * (Math.min(leftHeight, height(i)) - bottomHeight)\\n                }\\n            }\\n            stack.push(i)\\n        }\\n        \\n        waterTrapped\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n        __     __rightUpper2\\nleftUpper |  _|\\n          |_| rightUpper1\\n           ^\\n      lowerHeight\\nrightUpper1 traps 1 x 1(width x height) units of water.\\nrightUpper2 traps 2 x 1(width x height) units of water.\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Stack<Integer> stack = new Stack<>();\\n        int totalWater = 0;\\n        for (int right = 0; right < height.length; right++) {\\n            while (!stack.isEmpty() \\n                   && height[stack.peek()] < height[right]) {\\n                int bottom = stack.pop();\\n                if (stack.isEmpty()) {\\n                    break;\\n                }\\n                int left = stack.peek();\\n                // Identified water trapped = width * height\\n                int water = (right - left - 1) * \\n                    (Math.min(height[right], height[left]) - height[bottom]);\\n                totalWater += water;\\n            }\\n            stack.push(right);\\n        }\\n        return totalWater;\\n    }\\n}\\n```\n```\\n    def trap(self, height):\\n        decreasingHeightStack, totalWaterTrapped = [], 0\\n        \\n        for i, v in enumerate(height):\\n            while len(decreasingHeightStack) > 0 and height[decreasingHeightStack[-1]] < v:\\n                bottomHeight = height[decreasingHeightStack.pop()]\\n                if len(decreasingHeightStack) == 0:\\n                    break\\n                leftUpperIndex = decreasingHeightStack[-1]\\n                heightDiff = min(height[leftUpperIndex], v) - bottomHeight\\n                width = i - leftUpperIndex - 1\\n                totalWaterTrapped += heightDiff * width\\n                \\n            decreasingHeightStack.append(i)\\n            \\n        return totalWaterTrapped\\n```\n```\\n    def trap(height: Array[Int]): Int = {\\n        val stack = new Stack[Int]()\\n        var waterTrapped = 0\\n\\n        for (i <- 0 to height.size - 1) {\\n            while (!stack.isEmpty && height(i) > height(stack.top)) { // With water trapped.\\n                val bottomHeight = height(stack.pop())\\n                if (!stack.isEmpty) {\\n                    val leftHeight = height(stack.top)\\n                    val width = i - stack.top - 1\\n                    waterTrapped += width * (Math.min(leftHeight, height(i)) - bottomHeight)\\n                }\\n            }\\n            stack.push(i)\\n        }\\n        \\n        waterTrapped\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409175,
                "title": "java-detailed-explanations-illustrations-divide-and-conquer-dp-two-pointers",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/trapping-rain-water/)\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n## Problem\\n\\n> Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it is able to trap after raining.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/73p9s.jpg \"by Marcos\")\\n\\n**Example:** \\n\\n```java\\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\\nOutput: 6\\n```\\n\\n\\n## Analysis\\n\\n**Wrong Idea:** One pointer to detect increase or decrease. My mind was influenced by the solution to the longest mountain in an array.\\n\\n**A tricky test case:**\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/58vfa.jpg)\\n\\nThe correct answer is `w1 + w2`. To compute the amount, we can\\'t just go by the bars `b` and `c`; instead, we must consider `a` and `d` with a broader perspective.\\n\\nCome up with the brute-force first!\\n\\n### Brute-Force\\n\\nFor each position `i` in `height[0...n-1]`, calculate how much water it contains. The amount of water can be computed by `min(leftMax, rightMax) - height[i]`. where `leftMax` is the highest left bar in `height[0...i-1]` and `rightMax` is the highest right bar in `height[i+1...n-1]`. What does it mean? No Picture You Say J8~\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/cta9e.jpg)\\n\\n**Note:** \\n\\n- When `i` equals `0` and `n - 1`, the amount must be 0 since `min(leftMax, rightMax)` is 0.\\n- Notice that if the amount of water is negative, we just skip it. It happens when `height[i]` is greater than `min(leftMax, rightMax)`, which means no water is stored on it.\\n\\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int totalWater = 0;\\n  for (int k = 0; k < n; ++k) {\\n    int leftMax = 0;\\n    for (int i = 0; i <= k - 1; ++i) {\\n      leftMax = Math.max(leftMax, height[i]);\\n    }\\n    int rightMax = 0;\\n    for (int i = k + 1; i < n; ++i) {\\n      rightMax = Math.max(rightMax, height[i]);\\n    }\\n    int water = Math.min(leftMax, rightMax) - height[k];\\n    totalWater += (water > 0) ? water : 0;\\n  }\\n  return totalWater;\\n}\\n```\\n\\n**Time:** `O(N^2)` since computing `leftMax` and `rightMax` in each round takes `O(N)`.\\n**Space:** `O(1)`\\n\\n\\n\\n### DP (pre-compute)\\n\\nBased on the brute-force approach, we can pre-compute all `leftMax` and `rightMax` in advance, which reduces time complexity to `O(N)`.\\n\\nWe denote `leftMax[i]` as the highest bar in `height[0...i]` and `rightMax[i]` as the highest bar in `height[i...n-1]`.\\n\\n**Note:** Before pre-computation, `leftMax[0]` and `rightMax[n - 1]` are each initialized by `height[0]` and `height[n - 1]`. By doing this, the code in the loop is cleaner.\\n\\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  if (n <= 2) return 0;\\n  // pre-compute\\n  int[] leftMax = new int[n];\\n  int[] rightMax = new int[n];\\n  leftMax[0] = height[0]; // init\\n  rightMax[n - 1] = height[n - 1];\\n  for (int i = 1, j = n - 2; i < n; ++i, --j) {\\n    leftMax[i] = Math.max(leftMax[i - 1], height[i]);\\n    rightMax[j] = Math.max(rightMax[j + 1], height[j]);\\n  }\\n  // water\\n  int totalWater = 0;\\n  for (int k = 1; k < n - 1; ++k) { // do not consider the first and the last places\\n    int water = Math.min(leftMax[k - 1], rightMax[k + 1]) - height[k];\\n    totalWater += (water > 0) ? water : 0;\\n  }\\n  return totalWater;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)`\\n\\n\\n\\n### Divide and Conquer\\n\\nWe can also solve this problem by divide-and-conquer approach.\\n\\nInitially, `leftMax` is `height[0]` and `rightMax` is `height[n - 1]`. We recursively compute the amount of trapping water in the problem `subTrap[1, n - 2]` with `leftMax` and `rightMax`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/7nxzy.jpg)\\n\\n**Divide:** We use `findMax` to find the highest bar `i` in `height[lo, hi]`, then divide into three subproblems `p1`, `p2`, and `p3`.\\n**Conquer:** We compute `p1` and `p2` recursively. `p3` can be computed by `height[i] - min(leftMax, rightMax)` (remember to skip negative results).\\n**Combine:** Returns `p1 + p2 + p3`.\\n\\nIn each step, we update `rightMax` for the left subproblem `p1` and update `leftMax` for the right subproblem `p2` if they are greater than `height[findMax[i]]`.\\n\\n**Base Case:** When there is one position (`lo == hi`), just solve it as we did for `p3`. If there is no place (`lo > hi`), returns `0`.\\n\\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  if (n < 3) return 0;\\n  return subTrap(height, 1, n - 2, height[0], height[n - 1]);\\n}\\n\\nprivate int subTrap(int[] height, int lo, int hi, int leftMax, int rightMax) {\\n  if (lo > hi) {\\n    return 0; // no water\\n  }\\n  if (lo == hi) { // one element\\n    int water = Math.min(leftMax, rightMax) - height[lo];\\n    return (water >= 0) ? water : 0; // return 0 if it is negative\\n  }\\n  int max = findMax(height, lo, hi); // O(N)\\n  \\n  // 3 cases (p1, p2, p3)\\n  int p1 = subTrap(height, lo, max - 1, leftMax, Math.max(height[max], rightMax));\\n  int p2 = subTrap(height, max + 1, hi, Math.max(height[max], leftMax), rightMax);\\n  int p3 = Math.min(leftMax, rightMax) - height[max];\\n  if (p3 < 0) p3 = 0; // if p3 is negative, set it 0\\n  // combine\\n  return p1 + p2 + p3;\\n}\\n\\nprivate int findMax(int[] height, int lo, int hi) {\\n  if (height.length == 0) return 0;\\n  int maxVal = height[lo];\\n  int maxIdx = lo;\\n  for (int i = lo + 1; i <= hi; ++i) {\\n    if (height[i] > maxVal) {\\n      maxVal = height[i];\\n      maxIdx = i;\\n    }\\n  }\\n  return maxIdx;\\n}\\n```\\n\\n**Time:**\\n- Best case: `O(NlogN)` where `T(N) = 2T(N/2) + O(N)`\\n- Worst case: `O(N^2)` where `T(N) = T(N-1) + O(N)`\\n\\n**Space:**\\n\\n- Best case: `O(logN)`\\n- Worst case: `O(N)`\\n\\nIt depends on how the problem is divided into two subproblems by the highest bar.\\n\\n**Note:** Time complexity can be reduced to $O(N)$ if the divide step `findMax()` takes $O(1)$ (pre-compute), no matter how the problem is divided.\\n\\n\\n\\n\\n\\n\\n\\n### Two Pointers (no extra space, clever)\\n\\n**Note:** We have `leftMax` and `rightMax` that record the largest heights `lo` and `hi` have seen so far.\\n\\nAs in DP approach, instead of computing each `leftMax` and `rightMax` separately, we can actually consider one bar at each time as our `min(leftMax, rightMax)` since we only care about the bar with a smaller height.\\n\\nWe denote two pointers `lo` and `hi` starting from two ends of the array. In the loop, we update `leftMax` and `rightMax` first.\\n\\nIf the current `leftMax` is less than `rightMax`, we can correctly compute the water at `lo`, but not the water at `hi`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/eixvt.jpg)\\n\\nLet\\'s examine the case `leftMax < rightMax`. We assume a `leftMax` in `height[0, lo]`. Since we do update first, `height[lo]` should be **less than or equal to** `leftMax` (it means that `leftMax` could have been just updated by `height[lo]`).\\n\\nSince `leftMax < rightMax`, the amount of water at `lo` can be determined at this time, no matter what the heights between `[lo + 1, hi - 1]` are. For example, if there is an `e` higher than `b` but lower than `leftMax`, it still works because there is `rightMax` on the right that can eliminate the effect of `e`. In terms of `f`, it is more obvious that it is right. (it is hard to explain well T_T)\\n\\n**However**, it does not always hold true if we compute the amount of water at `hi` in this case (`leftMax < rightMax`). Consider `d` that is less than `rightMax`:\\n\\n- If we use `leftMax` to compute the amount (`leftMax - d`), there could be an `f` that gives a larger result (`min(f, rightMax) - d`).\\n\\n- If we use `rightMax` to compute the amount (`rightMax - d`), there could be an `e` that gives a smaller result (`min(e, rightMax) - d` if `e > leftMax` or `min(leftMax, rightMax) - d` if `e < leftMax`).\\n\\nHere is the code:\\n\\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int lo = 0, hi = n - 1;\\n  int leftMax = 0, rightMax = 0;\\n  int water = 0;\\n  while (lo < hi) {\\n    // update\\n    if (height[lo] > leftMax)  leftMax = height[lo];\\n    if (height[hi] > rightMax) rightMax = height[hi];\\n    // compute\\n    if (leftMax < rightMax) { // consider the min\\n        water += (leftMax - height[lo]); // leftMax >= height[lo]\\n        ++lo;\\n    } else {\\n        water += (rightMax - height[hi]);\\n        --hi;\\n    }\\n  }\\n  return totalWater;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n\\n\\n\\n### Two Pointers (my first attempt)\\n\\nHere is the solution I first came up with... It just uses `two pointers` to keep track of two bars and compute the water by levels constrained by the minimum height of two bars. (a bit similar to Skyline problem...)\\n\\nLeft/right pointers are both aiming for higher bars when they move on to the center. It is not intuitive because each time we should not add computed amount of water (minus `wateredHt` in the code).\\n\\nHow could I write such a solution instead of brute-force at first?\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/bufdh.png)\\n\\n**See a better approach below.**\\n\\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int i = 0, j = n - 1;\\n  int wateredHt = 0;\\n  int leftHt = 0, rightHt = 0;\\n  int totalWater = 0;\\n  while (i < j) {\\n    int currHt = Math.min(height[i], height[j]); // consider beginning case when currHt = 0\\n    // Water\\n    int water = 0;\\n    for (int k = i + 1; k <= j - 1; ++k) {\\n      water += currHt - Math.max(Math.min(height[k], currHt), wateredHt);\\n    }\\n    totalWater += water;\\n    wateredHt = currHt;\\n    \\n    // Move i and J\\n    if (height[i] <= height[j]) { // move i\\n      int oldHt = height[i];\\n      while (i < j && height[i] <= oldHt) ++i;\\n    } else { // move j\\n      int oldHt = height[j];\\n      while (i < j && height[j] <= oldHt) --j;\\n    }\\n  }\\n  return totalWater;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(1)`",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\\nOutput: 6\\n```\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int totalWater = 0;\\n  for (int k = 0; k < n; ++k) {\\n    int leftMax = 0;\\n    for (int i = 0; i <= k - 1; ++i) {\\n      leftMax = Math.max(leftMax, height[i]);\\n    }\\n    int rightMax = 0;\\n    for (int i = k + 1; i < n; ++i) {\\n      rightMax = Math.max(rightMax, height[i]);\\n    }\\n    int water = Math.min(leftMax, rightMax) - height[k];\\n    totalWater += (water > 0) ? water : 0;\\n  }\\n  return totalWater;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  if (n <= 2) return 0;\\n  // pre-compute\\n  int[] leftMax = new int[n];\\n  int[] rightMax = new int[n];\\n  leftMax[0] = height[0]; // init\\n  rightMax[n - 1] = height[n - 1];\\n  for (int i = 1, j = n - 2; i < n; ++i, --j) {\\n    leftMax[i] = Math.max(leftMax[i - 1], height[i]);\\n    rightMax[j] = Math.max(rightMax[j + 1], height[j]);\\n  }\\n  // water\\n  int totalWater = 0;\\n  for (int k = 1; k < n - 1; ++k) { // do not consider the first and the last places\\n    int water = Math.min(leftMax[k - 1], rightMax[k + 1]) - height[k];\\n    totalWater += (water > 0) ? water : 0;\\n  }\\n  return totalWater;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  if (n < 3) return 0;\\n  return subTrap(height, 1, n - 2, height[0], height[n - 1]);\\n}\\n\\nprivate int subTrap(int[] height, int lo, int hi, int leftMax, int rightMax) {\\n  if (lo > hi) {\\n    return 0; // no water\\n  }\\n  if (lo == hi) { // one element\\n    int water = Math.min(leftMax, rightMax) - height[lo];\\n    return (water >= 0) ? water : 0; // return 0 if it is negative\\n  }\\n  int max = findMax(height, lo, hi); // O(N)\\n  \\n  // 3 cases (p1, p2, p3)\\n  int p1 = subTrap(height, lo, max - 1, leftMax, Math.max(height[max], rightMax));\\n  int p2 = subTrap(height, max + 1, hi, Math.max(height[max], leftMax), rightMax);\\n  int p3 = Math.min(leftMax, rightMax) - height[max];\\n  if (p3 < 0) p3 = 0; // if p3 is negative, set it 0\\n  // combine\\n  return p1 + p2 + p3;\\n}\\n\\nprivate int findMax(int[] height, int lo, int hi) {\\n  if (height.length == 0) return 0;\\n  int maxVal = height[lo];\\n  int maxIdx = lo;\\n  for (int i = lo + 1; i <= hi; ++i) {\\n    if (height[i] > maxVal) {\\n      maxVal = height[i];\\n      maxIdx = i;\\n    }\\n  }\\n  return maxIdx;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int lo = 0, hi = n - 1;\\n  int leftMax = 0, rightMax = 0;\\n  int water = 0;\\n  while (lo < hi) {\\n    // update\\n    if (height[lo] > leftMax)  leftMax = height[lo];\\n    if (height[hi] > rightMax) rightMax = height[hi];\\n    // compute\\n    if (leftMax < rightMax) { // consider the min\\n        water += (leftMax - height[lo]); // leftMax >= height[lo]\\n        ++lo;\\n    } else {\\n        water += (rightMax - height[hi]);\\n        --hi;\\n    }\\n  }\\n  return totalWater;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int i = 0, j = n - 1;\\n  int wateredHt = 0;\\n  int leftHt = 0, rightHt = 0;\\n  int totalWater = 0;\\n  while (i < j) {\\n    int currHt = Math.min(height[i], height[j]); // consider beginning case when currHt = 0\\n    // Water\\n    int water = 0;\\n    for (int k = i + 1; k <= j - 1; ++k) {\\n      water += currHt - Math.max(Math.min(height[k], currHt), wateredHt);\\n    }\\n    totalWater += water;\\n    wateredHt = currHt;\\n    \\n    // Move i and J\\n    if (height[i] <= height[j]) { // move i\\n      int oldHt = height[i];\\n      while (i < j && height[i] <= oldHt) ++i;\\n    } else { // move j\\n      int oldHt = height[j];\\n      while (i < j && height[j] <= oldHt) --j;\\n    }\\n  }\\n  return totalWater;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17395,
                "title": "a-different-o-n-approach-easy-to-understand-and-simple-code",
                "content": "    class Solution {\\n    public:\\n        int trap(int a[], int n) {\\n            int i, res = 0;\\n            if(!n) return res;\\n            vector<int> ltr(n, 0), rtl(n, 0);\\n            for(i = 1, ltr[0] = a[0]; i < n; i++)\\n                ltr[i] = max(ltr[i-1], a[i]);\\n            for(i = n - 2, rtl[n-1] = a[n-1]; i >= 0; i--)\\n                rtl[i] = max(rtl[i+1], a[i]);\\n            for(i = 0; i < n; i++)\\n                res += min(ltr[i], rtl[i]) - a[i];\\n            return res;\\n        }\\n    };\\n\\nobservation:\\n\\nscan A both from left to right and right to left, record the largest seen during the scan; then for each position the water level should be the min of the 2 large value.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trap(int a[], int n) {\\n            int i, res = 0;\\n            if(!n) return res;\\n            vector<int> ltr(n, 0), rtl(n, 0);\\n            for(i = 1, ltr[0] = a[0]; i < n; i++)\\n                ltr[i] = max(ltr[i-1], a[i]);\\n            for(i = n - 2, rtl[n-1] = a[n-1]; i >= 0; i--)\\n                rtl[i] = max(rtl[i+1], a[i]);\\n            for(i = 0; i < n; i++)\\n                res += min(ltr[i], rtl[i]) - a[i];\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17528,
                "title": "easy-to-understand-python-10-line-60ms-o-n",
                "content": "    def trap(self, height):\\n        waterLevel = []\\n        left = 0\\n        for h in height:\\n            left = max(left, h) \\n            waterLevel += [left] # over-fill it to left max height\\n        right = 0\\n        for i, h in reversed(list(enumerate(height))):\\n            right = max(right, h)\\n            waterLevel[i] = min(waterLevel[i], right) - h # drain to the right height\\n        return sum(waterLevel)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def trap(self, height):\\n        waterLevel = []\\n        left = 0\\n        for h in height:\\n            left = max(left, h) \\n            waterLevel += [left] # over-fill it to left max height\\n        right = 0\\n        for i, h in reversed(list(enumerate(height))):\\n            right = max(right, h)\\n            waterLevel[i] = min(waterLevel[i], right) - h # drain to the right height\\n        return sum(waterLevel)",
                "codeTag": "Python3"
            },
            {
                "id": 1005489,
                "title": "python-two-pointer-approach-with-explanation-o-n-time-o-1-space",
                "content": "Time complexity O(n)\\nSpace complexity O(1)\\n\\n* Water units trapped in each index of the array is calculated and added individually. \\n* Water level at an index is determined by the lower of max_left and max_right for any bar,i.e. essentially water trapped in bar i depends on min(max_left, right_left). \\n*  Water trapped in index i = min(max_left, max_right) - height[i]. \\n*  Therefore if max_left < max_right, we fill the left index up to max_left, and advance the left pointer; and vice versa. If max_left equals max_right, moving either pointer would work.\\n    \\n```\\n\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\n        if len(height)<= 2:\\n            return 0\\n        \\n        ans = 0\\n        \\n        #using two pointers i and j on indices 1 and n-1\\n        i = 1\\n        j = len(height) - 1\\n        \\n        #initialising leftmax to the leftmost bar and rightmax to the rightmost bar\\n        lmax = height[0]\\n        rmax = height[-1]\\n        \\n        while i <=j:\\n            # check lmax and rmax for current i, j positions\\n            if height[i] > lmax:\\n                lmax = height[i]\\n            if height[j] > rmax:\\n                rmax = height[j]\\n            \\n            #fill water upto lmax level for index i and move i to the right\\n            if lmax <= rmax:\\n                ans += lmax - height[i]\\n                i += 1\\n\\t\\t\\t\\t\\n            #fill water upto rmax level for index j and move j to the left\\n            else:\\n                ans += rmax - height[j]\\n                j -= 1\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\n        if len(height)<= 2:\\n            return 0\\n        \\n        ans = 0\\n        \\n        #using two pointers i and j on indices 1 and n-1\\n        i = 1\\n        j = len(height) - 1\\n        \\n        #initialising leftmax to the leftmost bar and rightmax to the rightmost bar\\n        lmax = height[0]\\n        rmax = height[-1]\\n        \\n        while i <=j:\\n            # check lmax and rmax for current i, j positions\\n            if height[i] > lmax:\\n                lmax = height[i]\\n            if height[j] > rmax:\\n                rmax = height[j]\\n            \\n            #fill water upto lmax level for index i and move i to the right\\n            if lmax <= rmax:\\n                ans += lmax - height[i]\\n                i += 1\\n\\t\\t\\t\\t\\n            #fill water upto rmax level for index j and move j to the left\\n            else:\\n                ans += rmax - height[j]\\n                j -= 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400555,
                "title": "clean-javascript-solutions-brute-force-dynamic-programming-stack-two-pointers",
                "content": "```\\n/** 1) Brute force */\\n// time O(n^2)\\n// space O(1)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let res = 0;\\n  for (let i = 0; i < height.length; i++) {\\n    let lMax = 0;\\n    let rMax = 0;\\n\\n    for (let j = 0; j < i; j++) {\\n      lMax = Math.max(lMax, height[j]);\\n    }\\n    for (let j = i + 1; j < height.length; j++) {\\n      rMax = Math.max(rMax, height[j]);\\n    }\\n\\n    const water = Math.min(lMax, rMax) - height[i];\\n    if (water > 0) res += water;\\n  }\\n\\n  return res;\\n}\\n\\n/** 2) Dynamic programming */\\n// time O(n)\\n// space O(n)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let res = 0;\\n  let l = height.length;\\n  let lMax = {};\\n  let rMax = {};\\n\\n  lMax[0] = height[0];\\n  for (let i = 1; i < l; i++) {\\n    lMax[i] = Math.max(height[i], lMax[i - 1]);\\n  }\\n\\n  rMax[l - 1] = height[l - 1];\\n  for (let i = l - 2; i >= 0; i--) {\\n    rMax[i] = Math.max(height[i], rMax[i + 1]);\\n  }\\n\\n  for (let i = 0; i < height.length; i++) {\\n    res += Math.min(lMax[i], rMax[i]) - height[i];\\n  }\\n\\n  return res;\\n}\\n\\n/** 3) Stack */\\n// time O(n)\\n// space O(n)\\nfunction trap(height) {\\n  let res = 0;\\n  let i = 0;\\n  const st = [];\\n\\n  while (i < height.length) {\\n    while (st.length !== 0 && height[i] > height[st[st.length - 1]]) {\\n      const top = st[st.length - 1];\\n      st.pop();\\n\\n      if (st.length === 0) break;\\n\\n      const dist = i - st[st.length - 1] - 1;\\n      const h = Math.min(height[i], height[st[st.length - 1]]) - height[top];\\n      res += dist * h;\\n    }\\n    st.push(i);\\n    i++;\\n  }\\n  return res;\\n}\\n\\n/** 4) Two pointers */\\n// time O(n)\\n// space O(1)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let l = 0;\\n  let r = height.length - 1;\\n\\n  let lMax = 0;\\n  let rMax = 0;\\n\\n  let res = 0;\\n\\n  while (l < r) {\\n    lMax = Math.max(lMax, height[l]);\\n    if (height[l] < lMax) {\\n      res += lMax - height[l];\\n    }\\n\\n    rMax = Math.max(rMax, height[r]);\\n    if (height[r] < rMax) {\\n      res += rMax - height[r];\\n    }\\n\\n    height[l] < height[r] ? l++ : r--;\\n  }\\n\\n  return res;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/** 1) Brute force */\\n// time O(n^2)\\n// space O(1)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let res = 0;\\n  for (let i = 0; i < height.length; i++) {\\n    let lMax = 0;\\n    let rMax = 0;\\n\\n    for (let j = 0; j < i; j++) {\\n      lMax = Math.max(lMax, height[j]);\\n    }\\n    for (let j = i + 1; j < height.length; j++) {\\n      rMax = Math.max(rMax, height[j]);\\n    }\\n\\n    const water = Math.min(lMax, rMax) - height[i];\\n    if (water > 0) res += water;\\n  }\\n\\n  return res;\\n}\\n\\n/** 2) Dynamic programming */\\n// time O(n)\\n// space O(n)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let res = 0;\\n  let l = height.length;\\n  let lMax = {};\\n  let rMax = {};\\n\\n  lMax[0] = height[0];\\n  for (let i = 1; i < l; i++) {\\n    lMax[i] = Math.max(height[i], lMax[i - 1]);\\n  }\\n\\n  rMax[l - 1] = height[l - 1];\\n  for (let i = l - 2; i >= 0; i--) {\\n    rMax[i] = Math.max(height[i], rMax[i + 1]);\\n  }\\n\\n  for (let i = 0; i < height.length; i++) {\\n    res += Math.min(lMax[i], rMax[i]) - height[i];\\n  }\\n\\n  return res;\\n}\\n\\n/** 3) Stack */\\n// time O(n)\\n// space O(n)\\nfunction trap(height) {\\n  let res = 0;\\n  let i = 0;\\n  const st = [];\\n\\n  while (i < height.length) {\\n    while (st.length !== 0 && height[i] > height[st[st.length - 1]]) {\\n      const top = st[st.length - 1];\\n      st.pop();\\n\\n      if (st.length === 0) break;\\n\\n      const dist = i - st[st.length - 1] - 1;\\n      const h = Math.min(height[i], height[st[st.length - 1]]) - height[top];\\n      res += dist * h;\\n    }\\n    st.push(i);\\n    i++;\\n  }\\n  return res;\\n}\\n\\n/** 4) Two pointers */\\n// time O(n)\\n// space O(1)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let l = 0;\\n  let r = height.length - 1;\\n\\n  let lMax = 0;\\n  let rMax = 0;\\n\\n  let res = 0;\\n\\n  while (l < r) {\\n    lMax = Math.max(lMax, height[l]);\\n    if (height[l] < lMax) {\\n      res += lMax - height[l];\\n    }\\n\\n    rMax = Math.max(rMax, height[r]);\\n    if (height[r] < rMax) {\\n      res += rMax - height[r];\\n    }\\n\\n    height[l] < height[r] ? l++ : r--;\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17403,
                "title": "c-two-pointers",
                "content": "The following idea is from [this post](https://leetcode.com/problems/trapping-rain-water/discuss/17357/Sharing-my-simple-c%2B%2B-code%3A-O(n)-time-O(1)-space).\\n\\nSet two pointers `l` and `r` to the left and right end of `height`. Then we get the minimum height (`minHeight`) of these pointers since the level of the water cannot be higher than it. Then we move the two pointers towards the center. If the coming level is less than `minHeight`, then it will hold some water. Fill the water until we meet some \"barrier\" (with height larger than `minHeight`) and update `l` and `r` to repeat this process.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int l = 0, r = height.size() - 1, water = 0, minHeight = 0;\\n        while (l < r) {\\n            while (l < r && height[l] <= minHeight) {\\n                water += minHeight - height[l++];\\n            }\\n            while (l < r && height[r] <= minHeight) {\\n                water += minHeight - height[r--];\\n            }\\n            minHeight = min(height[l], height[r]);\\n        }\\n        return water;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int l = 0, r = height.size() - 1, water = 0, minHeight = 0;\\n        while (l < r) {\\n            while (l < r && height[l] <= minHeight) {\\n                water += minHeight - height[l++];\\n            }\\n            while (l < r && height[r] <= minHeight) {\\n                water += minHeight - height[r--];\\n            }\\n            minHeight = min(height[l], height[r]);\\n        }\\n        return water;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17526,
                "title": "very-concise-java-solution-no-stack-with-explanations",
                "content": "The idea is very simple. Begin scan from beginning and end of array. Compare value of left and right pointer, hold the greater one and move the other to inner array. Compute passed area when pointer gets inner.\\n\\n    public int trap(int[] height) {\\n\\t\\tint secHight = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = height.length - 1;\\n\\t\\tint area = 0;\\n\\t\\twhile (left < right) {\\n\\t\\t\\tif (height[left] < height[right]) {\\n\\t\\t\\t\\tsecHight = Math.max(height[left], secHight);\\n\\t\\t\\t\\tarea += secHight - height[left];\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecHight = Math.max(height[right], secHight);\\n\\t\\t\\t\\tarea += secHight - height[right];\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn area;\\n\\t}",
                "solutionTags": [],
                "code": "The idea is very simple. Begin scan from beginning and end of array. Compare value of left and right pointer, hold the greater one and move the other to inner array. Compute passed area when pointer gets inner.\\n\\n    public int trap(int[] height) {\\n\\t\\tint secHight = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = height.length - 1;\\n\\t\\tint area = 0;\\n\\t\\twhile (left < right) {\\n\\t\\t\\tif (height[left] < height[right]) {\\n\\t\\t\\t\\tsecHight = Math.max(height[left], secHight);\\n\\t\\t\\t\\tarea += secHight - height[left];\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecHight = Math.max(height[right], secHight);\\n\\t\\t\\t\\tarea += secHight - height[right];\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn area;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1374012,
                "title": "c-dp-and-2-pointer-solutions-compared-and-explained-100-time-85-space",
                "content": "For the first solution, we could figure out the maximum capacity of our environment checking from the left and then checking it from the right, keeping the minimum of the two.\\n\\nFor example, given the initial example input of `{0,1,0,2,1,0,1,3,2,1,2,1}` we would have from the left:\\n![image](https://assets.leetcode.com/users/images/bf30fa77-bb36-4bcf-9985-1fc4c6b015d3_1627722443.1107793.png)\\n\\nAnd from the right:\\n![image](https://assets.leetcode.com/users/images/ac337f3b-f8ce-416d-8f80-2e7e37af5e10_1627722597.849632.png)\\n\\nEasy to see now that the correct answer is the area included in both perspectives, as shown in the original picture accompanying the problem.\\n\\nWe might be tempted to store both results in a DP container, but actually we can proceed to go in one direction, store what we saw and, while looking from the other direction, directly compute and store the result for each cell as we go.\\n\\nTo do so, we will first of all rule out an annoying edge case for empty inputs, then declare a few support variables:\\n* `len` will store the length of our input;\\n* `dp` is going to be our array of `len` elements in which we will store what we see going from one side first (left to right, in our case, but it would not change to do the opposite);\\n* `currMax` will store the value of the currently observed maximum, initially set to `-1`;\\n* `res`, finally, will store our result going in the other direction (right to left for us), cell by cell.\\n\\nWe will then proceed looking from the left and with `i` going from `0` to `len` (excluded) we will:\\n* assign `h[i]` to `e`;\\n* compute `currMax` as the maximum between its present value and `e`;\\n* store the value of `currMax - e` in `dp[i]`.\\n\\nWe can now reset `currMax` to `-1` and proceed the other way around, with `i` going from `len - 1` up to `0` (included) we will:\\n* assign `h[i]` to `e`;\\n* compute `currMax` as the maximum between its present value and `e`;\\n* increase `res` by `currMax - e`.\\n\\nOnce done, we can `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        // edge case: empty input\\n        if (!h.size()) return 0;\\n        // support variables\\n        int len = h.size(), dp[len], currMax = -1, res = 0;\\n        // computing the maximum capacity looking from left\\n        for (int i = 0, e; i < len; i++) {\\n            e = h[i];\\n            currMax = max(currMax, e);\\n            dp[i] = currMax - e;\\n        }\\n        // computing the maximum capacity looking from right\\n        currMax = -1;\\n        for (int i = len - 1, e; i > -1; i--) {\\n            e = h[i];\\n            currMax = max(currMax, e);\\n            res += min(dp[i], currMax - e);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThen it dawned to me that we can avoid the DP modest costs altogether and go for a single pass, using 2 pointers, `i` and `j`, that we will advance until they meet, always moving the one that points at the smallest element, keeping track of the biggest number we saw in each direction and and building `res` as we go.\\n\\nThe improved code, which surprisingly does not do that much better in terms of memory usage:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        // edge case: empty input\\n        if (!h.size()) return 0;\\n        // support variables\\n        int i = 0, j = h.size() - 1, maxLeft = h[i], maxRight = h[j], res = 0, e;\\n        while (i <= j) {\\n            // case 1: i points to a bigger element, so we advance j\\n            if (h[i] > h[j]) {\\n                e = h[j];\\n                if (e > maxRight) maxRight = e;\\n                else res += maxRight - e;\\n                j--;\\n            }\\n            // case 2: j points to a bigger/equal element, so we advance i\\n            else {\\n                e = h[i];\\n                if (e > maxLeft) maxLeft = e;\\n                else res += maxLeft - e;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        // edge case: empty input\\n        if (!h.size()) return 0;\\n        // support variables\\n        int len = h.size(), dp[len], currMax = -1, res = 0;\\n        // computing the maximum capacity looking from left\\n        for (int i = 0, e; i < len; i++) {\\n            e = h[i];\\n            currMax = max(currMax, e);\\n            dp[i] = currMax - e;\\n        }\\n        // computing the maximum capacity looking from right\\n        currMax = -1;\\n        for (int i = len - 1, e; i > -1; i--) {\\n            e = h[i];\\n            currMax = max(currMax, e);\\n            res += min(dp[i], currMax - e);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        // edge case: empty input\\n        if (!h.size()) return 0;\\n        // support variables\\n        int i = 0, j = h.size() - 1, maxLeft = h[i], maxRight = h[j], res = 0, e;\\n        while (i <= j) {\\n            // case 1: i points to a bigger element, so we advance j\\n            if (h[i] > h[j]) {\\n                e = h[j];\\n                if (e > maxRight) maxRight = e;\\n                else res += maxRight - e;\\n                j--;\\n            }\\n            // case 2: j points to a bigger/equal element, so we advance i\\n            else {\\n                e = h[i];\\n                if (e > maxLeft) maxLeft = e;\\n                else res += maxLeft - e;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17564,
                "title": "java-10-lines-accepted-code-o-n-time-o-1-space-is-there-a-better-solution",
                "content": "Basically this solution runs two pointers from two sides to the middle, and the plank is used to record the height of the elevation within a certain range, **plank height can only increase (or remain the same) from two sides to the middle**. If the current pointer is pointing at a number that is less than the current plank height, the difference between plank height and the number would be the amount of water trapped. Otherwise, A[i] == plank, no water is trapped. \\n\\n    public class Solution {\\n        public int trap(int[] A) {\\n            int i = 0, j = A.length - 1, result = 0, plank = 0;\\n            while(i <= j){\\n                plank = plank < Math.min(A[i], A[j]) ? Math.min(A[i], A[j]) : plank;\\n                result = A[i] >= A[j] ? result + (plank - A[j--]) : result + (plank - A[i++]);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int trap(int[] A) {\\n            int i = 0, j = A.length - 1, result = 0, plank = 0;\\n            while(i <= j){\\n                plank = plank < Math.min(A[i], A[j]) ? Math.min(A[i], A[j]) : plank;\\n                result = A[i] >= A[j] ? result + (plank - A[j--]) : result + (plank - A[i++]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2590736,
                "title": "java-simple-solution-with-explanation-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int l = 0, r = height.length - 1, sum = 0, lMax = 0, rMax = 0;\\n        while(l <= r){\\n            lMax = Math.max(height[l], lMax);\\n            rMax = Math.max(height[r], rMax);\\n\\t\\t\\t //why? because, for example if the lMax is smaller, we can sure that how much water could be trapped at the left pointer position is decided by the left side. \\n            if(lMax < rMax){\\n                sum += lMax - height[l++];\\n            }else{\\n                sum += rMax - height[r--];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int l = 0, r = height.length - 1, sum = 0, lMax = 0, rMax = 0;\\n        while(l <= r){\\n            lMax = Math.max(height[l], lMax);\\n            rMax = Math.max(height[r], rMax);\\n\\t\\t\\t //why? because, for example if the lMax is smaller, we can sure that how much water could be trapped at the left pointer position is decided by the left side. \\n            if(lMax < rMax){\\n                sum += lMax - height[l++];\\n            }else{\\n                sum += rMax - height[r--];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589774,
                "title": "c-precomputation-explained",
                "content": "- Precompute the maximum left and maximum right of each element in array.\\n- There cannot be any water on leftmost and rightmost bar. So we can simply ignore those two bars.\\n- The answer is just minimum of left and right elements and its subtraction with current bar.\\n\\n![image](https://assets.leetcode.com/users/images/92509098-7aaa-411b-82f8-d43a82fad274_1663464971.7655392.png)\\nIn above example, we found that left maximum element is 2 and right maximum element is 3. The minimum of which is 2. The bar height is zero. So at this position, water stored will be.\\n`Answer : min(2, 3) - 0 = 2`\\n\\n![image](https://assets.leetcode.com/users/images/25e14f49-a623-40a1-aa7f-869d4f727792_1663465018.506349.png)\\nSimilarly, the left maximum for this element is 2 and right maximum is 3. The height of current bar is 1.\\n`Answer : min(2, 3) - 1 = 1`\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& A) {\\n        int N = A.size(), ans = 0;\\n        \\n        vector<int> left(N, 0), right(N, 0);\\n        \\n        for(int i = 1; i < N; i++) {\\n            left[i] = max(left[i - 1], A[i - 1]);\\n        }\\n        \\n        for(int i = N - 2; i >= 0; i--) {\\n            right[i] = max(right[i + 1], A[i + 1]);\\n        }\\n        \\n        for(int i = 1; i < N - 1; i++) {\\n            ans += max(0, min(left[i], right[i]) - A[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& A) {\\n        int N = A.size(), ans = 0;\\n        \\n        vector<int> left(N, 0), right(N, 0);\\n        \\n        for(int i = 1; i < N; i++) {\\n            left[i] = max(left[i - 1], A[i - 1]);\\n        }\\n        \\n        for(int i = N - 2; i >= 0; i--) {\\n            right[i] = max(right[i + 1], A[i + 1]);\\n        }\\n        \\n        for(int i = 1; i < N - 1; i++) {\\n            ans += max(0, min(left[i], right[i]) - A[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589802,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n**Dynamic Programming**\\n\\n```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n// where N is the length of height\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int ans = 0, n = height.size();\\n        // dp1[i]: the max height of bar from the left till position i\\n        // dp2[i]: the max height of bar from the right till position i\\n        vector<int> dp1(n), dp2(n);\\n        // let\\'s build dp1 first\\n        dp1[0] = height[0];\\n        // for each position i, \\n        // if the current height is greater than the max height, then dp1[i] will be height[i]\\n        // else dp1[i] will be taking the previous result, i.e. dp1[i - 1]\\n        for (int i = 1; i < n; i++) dp1[i] = max(dp1[i - 1], height[i]);\\n        // build dp2 in a similar way\\n        dp2[n - 1] = height[n - 1];\\n        // for each position i, \\n        // if the current height is greater than the max height, \\n        // then dp2[i] will be height[i]\\n        // else dp2[i] will be taking the previous result, i.e. dp2[i + 1]\\n        for (int i = n - 2; i >= 0; i--) dp2[i] = max(dp2[i + 1], height[i]);\\n        // then iterate the heights and take the minimum of dp1[i] and dp2[i]\\n        // why minimum? because that is the max height a bar can hold. (water will overflow)\\n        // then we substract height[i] from the min\\n        // if min(dp1[i], dp2[i]) is 2 and height[i] is 2, then no water is being trapped\\n        // if min(dp1[i], dp2[i]) is 2 and height[i] is 0, then 2 units of water are being trapped\\n        for (int i = 1; i < n - 1; i++) ans += min(dp1[i], dp2[i]) - height[i];\\n        return ans;\\n    }\\n};\\n```\\n\\n**Two Pointers**\\n\\n```java\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\n    public int trap(int[] height) {\\n        int i = 0, j = height.length - 1, ans = 0, mx = 0, mi = 0;\\n        // two pointers \\n        // pointer i from the left\\n        // pointer j from the right\\n        while (i <= j) {\\n            // take the min height \\n            mi = Math.min(height[i], height[j]);\\n            // find the max min height\\n            mx = Math.max(mx, mi);\\n            // the units of water being tapped is the diffence between max height and min height\\n            ans += mx - mi;\\n            // move the pointer i if height[i] is smaller\\n            if (height[i] < height[j]) i++;\\n            // else move pointer j\\n            else j--;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n```py\\n# Time Complexity: O(N)\\n# Space Complexity: O(1)\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        i, j, ans, mx, mi = 0, len(height) - 1, 0, 0, 0\\n        # two pointers \\n        # pointer i from the left\\n        # pointer j from the right\\n        while i <= j:\\n            # take the min height\\n            mi = min(height[i], height[j])\\n            # find the max min height\\n            mx = max(mx, mi)\\n            # the units of water being tapped is the diffence between max height and min height\\n            ans += mx - mi\\n            # move the pointer i if height[i] is smaller\\n            if height[i] < height[j]: i += 1\\n            # else move pointer j\\n            else: j -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n// where N is the length of height\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int ans = 0, n = height.size();\\n        // dp1[i]: the max height of bar from the left till position i\\n        // dp2[i]: the max height of bar from the right till position i\\n        vector<int> dp1(n), dp2(n);\\n        // let\\'s build dp1 first\\n        dp1[0] = height[0];\\n        // for each position i, \\n        // if the current height is greater than the max height, then dp1[i] will be height[i]\\n        // else dp1[i] will be taking the previous result, i.e. dp1[i - 1]\\n        for (int i = 1; i < n; i++) dp1[i] = max(dp1[i - 1], height[i]);\\n        // build dp2 in a similar way\\n        dp2[n - 1] = height[n - 1];\\n        // for each position i, \\n        // if the current height is greater than the max height, \\n        // then dp2[i] will be height[i]\\n        // else dp2[i] will be taking the previous result, i.e. dp2[i + 1]\\n        for (int i = n - 2; i >= 0; i--) dp2[i] = max(dp2[i + 1], height[i]);\\n        // then iterate the heights and take the minimum of dp1[i] and dp2[i]\\n        // why minimum? because that is the max height a bar can hold. (water will overflow)\\n        // then we substract height[i] from the min\\n        // if min(dp1[i], dp2[i]) is 2 and height[i] is 2, then no water is being trapped\\n        // if min(dp1[i], dp2[i]) is 2 and height[i] is 0, then 2 units of water are being trapped\\n        for (int i = 1; i < n - 1; i++) ans += min(dp1[i], dp2[i]) - height[i];\\n        return ans;\\n    }\\n};\\n```\n```java\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\n    public int trap(int[] height) {\\n        int i = 0, j = height.length - 1, ans = 0, mx = 0, mi = 0;\\n        // two pointers \\n        // pointer i from the left\\n        // pointer j from the right\\n        while (i <= j) {\\n            // take the min height \\n            mi = Math.min(height[i], height[j]);\\n            // find the max min height\\n            mx = Math.max(mx, mi);\\n            // the units of water being tapped is the diffence between max height and min height\\n            ans += mx - mi;\\n            // move the pointer i if height[i] is smaller\\n            if (height[i] < height[j]) i++;\\n            // else move pointer j\\n            else j--;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```py\\n# Time Complexity: O(N)\\n# Space Complexity: O(1)\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        i, j, ans, mx, mi = 0, len(height) - 1, 0, 0, 0\\n        # two pointers \\n        # pointer i from the left\\n        # pointer j from the right\\n        while i <= j:\\n            # take the min height\\n            mi = min(height[i], height[j])\\n            # find the max min height\\n            mx = max(mx, mi)\\n            # the units of water being tapped is the diffence between max height and min height\\n            ans += mx - mi\\n            # move the pointer i if height[i] is smaller\\n            if height[i] < height[j]: i += 1\\n            # else move pointer j\\n            else: j -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17575,
                "title": "python-solutions-o-n-space-and-o-1-space",
                "content": "The water we trapped depends on the left side and right side which has the max height,\\n\\nWe keep the left side and right side until we find a higher side\\n\\n    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def trap(self, arr):\\n        height, left, right, water = [], 0, 0, 0\\n        for i in arr:\\n            left = max(left, i)\\n            height.append(left)\\n        height.reverse()\\n        for n, i in enumerate(reversed(arr)):\\n            right = max(right, i)\\n            water += min(height[n], right) - i\\n        return water\\n\\nO(1)\\n\\n    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def trap(self, arr):\\n        left = right = water = 0\\n        i, j = 0, len(arr)-1\\n        while i <= j:\\n            left, right = max(left, arr[i]), max(right, arr[j])\\n            while i <= j and arr[i] <= left <= right:\\n                water += left - arr[i]\\n                i += 1\\n            while i <= j and arr[j] <= right <= left:\\n                water += right - arr[j]\\n                j -= 1\\n        return water",
                "solutionTags": [],
                "code": "The water we trapped depends on the left side and right side which has the max height,\\n\\nWe keep the left side and right side until we find a higher side\\n\\n    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def trap(self, arr):\\n        height, left, right, water = [], 0, 0, 0\\n        for i in arr:\\n            left = max(left, i)\\n            height.append(left)\\n        height.reverse()\\n        for n, i in enumerate(reversed(arr)):\\n            right = max(right, i)\\n            water += min(height[n], right) - i\\n        return water\\n\\nO(1)\\n\\n    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def trap(self, arr):\\n        left = right = water = 0\\n        i, j = 0, len(arr)-1\\n        while i <= j:\\n            left, right = max(left, arr[i]), max(right, arr[j])\\n            while i <= j and arr[i] <= left <= right:\\n                water += left - arr[i]\\n                i += 1\\n            while i <= j and arr[j] <= right <= left:\\n                water += right - arr[j]\\n                j -= 1\\n        return water",
                "codeTag": "Java"
            },
            {
                "id": 3387829,
                "title": "c-java-python-javascript-o-n-time-o-1-space-brute-force-optimized-code",
                "content": "# Intuition:\\nThe task is to calculate the amount of water that can be trapped between the bars of different heights. The optimized code uses a two-pointer approach, whereas the brute force approach checks for the maximum height of bars to the left and right of every bar. The approach with two pointers calculates the water between two bars by keeping track of the maximum height bars from left and right as it moves towards the middle of the bars.\\n\\n# Approach:\\n\\n### Brute Force Approach:\\n\\n1. For every bar in the height array, calculate the maximum height bar to the left and right.\\n2. Subtract the height of the current bar from the minimum of the left and right maximum bar heights to get the amount of water that can be trapped.\\n3. Add the result to a variable \"water\" which keeps track of the total amount of water that can be trapped.\\n4. Return the value of the \"water\" variable.\\n\\n### Optimized Approach:\\n\\n1. Initialize left, right pointers to the first and last bars of the height array, respectively.\\n2. Initialize variables left_max and right_max to zero.\\n3. While the left pointer is less than or equal to the right pointer, compare the heights of the bars pointed to by the left and right pointers.\\n4. If the height of the left bar is less than or equal to the height of the right bar, check if the height of the left bar is greater than the left_max variable. If it is, update left_max, otherwise, add left_max - height[left] to the \"water\" variable. Move the left pointer to the next bar.\\n5. If the height of the right bar is less than the height of the left bar, check if the height of the right bar is greater than the right_max variable. If it is, update right_max, otherwise, add right_max - height[right] to the \"water\" variable. Move the right pointer to the previous bar.\\n6. Return the value of the \"water\" variable.\\n\\n# Complexity\\n\\n### Brute Force Approach:\\n- The time complexity of the brute force approach is O(n^2), where n is the length of the height array. This is because the algorithm has to check for the maximum height bars to the left and right of every bar in the height array. \\n- The space complexity is O(1), as the algorithm only uses constant extra space to store the left_max, right_max, and water variables.\\n\\n### Optimized Approach:\\n- The time complexity of the optimized approach is O(n), where n is the length of the height array. This is because the algorithm has to traverse the height array only once with two pointers. \\n- The space complexity is O(1), as the algorithm only uses constant extra space to store the left, right, left_max, right_max, and water variables.\\n# Similar Question: \\n[https://leetcode.com/problems/container-with-most-water/solutions/3493276/c-java-python-javascript-optimized-code-easy-to-understand-100-solution-explained/](https://leetcode.com/problems/container-with-most-water/solutions/3493276/c-java-python-javascript-optimized-code-easy-to-understand-100-solution-explained/)\\n---\\n\\n# C++\\n## Brute Force\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n         int water=0;\\n         for(int i=0;i<height.size();i++){\\n             int left_max=0,right_max=0;\\n             int j=i;\\n             while(j<n){\\n                 right_max=max(right_max,height[j]);\\n                 j++;\\n             }\\n             j=i;\\n             while(j>=0){\\n                 left_max=max(left_max,height[j]);\\n                 j--;\\n             }\\n             j=i;\\n             water+= min(left_max,right_max)-height[i];\\n        }\\n        return water;\\n    }\\n};\\n```\\n## Optimized Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left=0,right=n-1,left_max=0,right_max=0,water=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>left_max) left_max=height[left];\\n                else water += left_max-height[left];\\n                left++;\\n            }\\n            else{\\n                if(height[right]>right_max) right_max=height[right];\\n                else water += right_max-height[right];\\n                right--;\\n            }\\n        }\\n        return water;\\n    }\\n};\\n```\\n\\n---\\n# JavaScript\\n## Brute Force\\n\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n  let n = height.length;\\n  let water = 0;\\n  for (let i = 0; i < n; i++) {\\n    let left_max = 0, right_max = 0;\\n    let j = i;\\n    while (j < n) {\\n      right_max = Math.max(right_max, height[j]);\\n      j++;\\n    }\\n    j = i;\\n    while (j >= 0) {\\n      left_max = Math.max(left_max, height[j]);\\n      j--;\\n    }\\n    j = i;\\n    water += Math.min(left_max, right_max) - height[i];\\n  }\\n  return water;\\n}\\n\\n```\\n## Optimized Code\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    let n = height.length;\\n    let left = 0, right = n - 1, left_max = 0, right_max = 0, water = 0;\\n    while (left <= right) {\\n        if (height[left] <= height[right]) {\\n            if (height[left] > left_max) left_max = height[left];\\n            else water += left_max - height[left];\\n            left++;\\n        } else {\\n            if (height[right] > right_max) right_max = height[right];\\n            else water += right_max - height[right];\\n            right--;\\n        }\\n    }\\n    return water;\\n}\\n\\n\\n```\\n---\\n# Java\\n## Brute Force\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int water = 0;\\n        for (int i = 0; i < n; i++) {\\n            int left_max = 0, right_max = 0;\\n            int j = i;\\n            while (j < n) {\\n                right_max = Math.max(right_max, height[j]);\\n                j++;\\n            }\\n            j = i;\\n            while (j >= 0) {\\n                left_max = Math.max(left_max, height[j]);\\n                j--;\\n            }\\n            j = i;\\n            water += Math.min(left_max, right_max) - height[i];\\n        }\\n        return water;\\n    }\\n}\\n\\n```\\n## Optimized Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int left = 0, right = n - 1, left_max = 0, right_max = 0, water = 0;\\n        while (left <= right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > left_max) left_max = height[left];\\n                else water += left_max - height[left];\\n                left++;\\n            } else {\\n                if (height[right] > right_max) right_max = height[right];\\n                else water += right_max - height[right];\\n                right--;\\n            }\\n        }\\n        return water;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n## Brute Force\\n```\\nclass Solution(object):\\n    def trap(self, height):\\n        n = len(height)\\n        water = 0\\n        for i in range(n):\\n            left_max, right_max = 0, 0\\n            j = i\\n            while j < n:\\n                right_max = max(right_max, height[j])\\n                j += 1\\n            j = i\\n            while j >= 0:\\n                left_max = max(left_max, height[j])\\n                j -= 1\\n            j = i\\n            water += min(left_max, right_max) - height[i]\\n        return water\\n\\n```\\n## Optimized Code\\n```\\nclass Solution(object):\\n    def trap(self, height):\\n        n = len(height)\\n        left, right, left_max, right_max, water = 0, n - 1, 0, 0, 0\\n        while left <= right:\\n            if height[left] <= height[right]:\\n                if height[left] > left_max:\\n                    left_max = height[left]\\n                else:\\n                    water += left_max - height[left]\\n                left += 1\\n            else:\\n                if height[right] > right_max:\\n                    right_max = height[right]\\n                else:\\n                    water += right_max - height[right]\\n                right -= 1\\n        return water\\n\\n```\\n\\n---\\n\\n# Similar Question : \\n[https://leetcode.com/problems/container-with-most-water/solutions/3493276/c-java-python-javascript-optimized-code-easy-to-understand-100-solution-explained/](https://leetcode.com/problems/container-with-most-water/solutions/3493276/c-java-python-javascript-optimized-code-easy-to-understand-100-solution-explained/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n         int water=0;\\n         for(int i=0;i<height.size();i++){\\n             int left_max=0,right_max=0;\\n             int j=i;\\n             while(j<n){\\n                 right_max=max(right_max,height[j]);\\n                 j++;\\n             }\\n             j=i;\\n             while(j>=0){\\n                 left_max=max(left_max,height[j]);\\n                 j--;\\n             }\\n             j=i;\\n             water+= min(left_max,right_max)-height[i];\\n        }\\n        return water;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left=0,right=n-1,left_max=0,right_max=0,water=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>left_max) left_max=height[left];\\n                else water += left_max-height[left];\\n                left++;\\n            }\\n            else{\\n                if(height[right]>right_max) right_max=height[right];\\n                else water += right_max-height[right];\\n                right--;\\n            }\\n        }\\n        return water;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n  let n = height.length;\\n  let water = 0;\\n  for (let i = 0; i < n; i++) {\\n    let left_max = 0, right_max = 0;\\n    let j = i;\\n    while (j < n) {\\n      right_max = Math.max(right_max, height[j]);\\n      j++;\\n    }\\n    j = i;\\n    while (j >= 0) {\\n      left_max = Math.max(left_max, height[j]);\\n      j--;\\n    }\\n    j = i;\\n    water += Math.min(left_max, right_max) - height[i];\\n  }\\n  return water;\\n}\\n\\n```\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    let n = height.length;\\n    let left = 0, right = n - 1, left_max = 0, right_max = 0, water = 0;\\n    while (left <= right) {\\n        if (height[left] <= height[right]) {\\n            if (height[left] > left_max) left_max = height[left];\\n            else water += left_max - height[left];\\n            left++;\\n        } else {\\n            if (height[right] > right_max) right_max = height[right];\\n            else water += right_max - height[right];\\n            right--;\\n        }\\n    }\\n    return water;\\n}\\n\\n\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int water = 0;\\n        for (int i = 0; i < n; i++) {\\n            int left_max = 0, right_max = 0;\\n            int j = i;\\n            while (j < n) {\\n                right_max = Math.max(right_max, height[j]);\\n                j++;\\n            }\\n            j = i;\\n            while (j >= 0) {\\n                left_max = Math.max(left_max, height[j]);\\n                j--;\\n            }\\n            j = i;\\n            water += Math.min(left_max, right_max) - height[i];\\n        }\\n        return water;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int left = 0, right = n - 1, left_max = 0, right_max = 0, water = 0;\\n        while (left <= right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > left_max) left_max = height[left];\\n                else water += left_max - height[left];\\n                left++;\\n            } else {\\n                if (height[right] > right_max) right_max = height[right];\\n                else water += right_max - height[right];\\n                right--;\\n            }\\n        }\\n        return water;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def trap(self, height):\\n        n = len(height)\\n        water = 0\\n        for i in range(n):\\n            left_max, right_max = 0, 0\\n            j = i\\n            while j < n:\\n                right_max = max(right_max, height[j])\\n                j += 1\\n            j = i\\n            while j >= 0:\\n                left_max = max(left_max, height[j])\\n                j -= 1\\n            j = i\\n            water += min(left_max, right_max) - height[i]\\n        return water\\n\\n```\n```\\nclass Solution(object):\\n    def trap(self, height):\\n        n = len(height)\\n        left, right, left_max, right_max, water = 0, n - 1, 0, 0, 0\\n        while left <= right:\\n            if height[left] <= height[right]:\\n                if height[left] > left_max:\\n                    left_max = height[left]\\n                else:\\n                    water += left_max - height[left]\\n                left += 1\\n            else:\\n                if height[right] > right_max:\\n                    right_max = height[right]\\n                else:\\n                    water += right_max - height[right]\\n                right -= 1\\n        return water\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373811,
                "title": "python-3-lines-oneliner-explained",
                "content": "To solve this problem, we need to understand what does trapping means. Imagine that we have some index `i`, how to evaluate amount of water we have in this index? There are two constraints: water can go to the left and to the right. Imagine for the moment, that we have infinite wall in the left, than what is the level of water it can rise? It is the maximum value from our map to the right of our index! The same logic works if we add infinite wall in the left. What to do now if we do not have infninite walls? We need to find **minimum** between the highest point to the left and the highest point to the right and this will solve the problem!\\n\\n#### Complexity\\nWe have `O(n)` time and memory complexity.\\n\\n\\n#### Code\\n```\\nclass Solution:\\n    def trap(self, H):\\n        left = list(accumulate(H, max))\\n        right = list(accumulate(H[::-1], max))[::-1]\\n        return sum(min(i, j) - k for i, j, k in zip(left, right, H))\\n```\\n\\n#### Oneliner\\n```python\\nreturn sum(min(i, j) - k for i, j, k in zip(accumulate(H, max), list(accumulate(H[::-1], max))[::-1], H))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trap(self, H):\\n        left = list(accumulate(H, max))\\n        right = list(accumulate(H[::-1], max))[::-1]\\n        return sum(min(i, j) - k for i, j, k in zip(left, right, H))\\n```\n```python\\nreturn sum(min(i, j) - k for i, j, k in zip(accumulate(H, max), list(accumulate(H[::-1], max))[::-1], H))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323354,
                "title": "very-easy-100-fully-explained-java-c-c-javascript",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int max1 = 0;\\n        //create left array so that we find the maximum element on its left...\\n        int left[] = new int[height.length];\\n        // Scan every element from left to right...\\n        for(int i = 0; i < height.length; i++) {\\n            // Find maximum element on its left...\\n            if(max1 < height[i]) {\\n                max1 = height[i];\\n            }\\n            left[i] = max1;\\n        }\\n        \\n        int max2 = 0;\\n        //create right array so that we find the maximum element on its right...\\n        int right[] = new int[height.length];\\n        // Scan every element from right to left...\\n        for(int i = height.length-1; i >= 0; i--) {\\n            \\n            // Find maximum element on its left...\\n            if(max2 < height[i]) {\\n                max2 = height[i];\\n            }\\n            right[i] = max2;\\n        }\\n        \\n        // To store the maximum water that can be stored..\\n        int trap = 0;\\n        // Scan and Calculate maximum trapped water...\\n        for(int i = 0; i  < height.length; i++) {\\n            trap += Math.min(left[i], right[i]) - height[i];\\n        }\\n        return trap;        //return the amount..\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        // Base condition...\\n        if (height.empty())\\n            return 0;\\n        // To store the maximum water that can be stored..\\n        int trap = 0;\\n        \\n        int left = 0;\\n        int right = height.size() - 1;\\n        \\n        int max1 = height[left];\\n        int max2 = height[right];\\n        \\n        // Find maximum element on its left and right & Calculate maximum trapped water...\\n        while (left < right)\\n            if (max1 < max2) {\\n                trap += max1 - height[left];\\n                max1 = max(max1, height[++left]);\\n            } else {\\n                trap += max2 - height[right];\\n                max2 = max(max2, height[--right]);\\n            }\\n        return trap;    //return the amount..\\n    }\\n};\\n```\\n\\n# **C Language:**\\n```\\n#define min(a,b) ((a>b)?b:a)    //this is neccessary..\\nint trap(int* height, int heightSize){\\n    int max1 = 0;\\n    //create left array so that we find the maximum element on its left...\\n    int left[heightSize];\\n    // Scan every element from left to right...\\n    for(int i = 0; i < heightSize; i++) { \\n        // Find maximum element on its left...\\n        if(max1 < height[i]) {\\n            max1 = height[i];\\n        }\\n        left[i] = max1;\\n    }\\n        \\n    int max2 = 0;\\n    //create right array so that we find the maximum element on its right...\\n    int right[heightSize];\\n    // Scan every element from right to left...\\n    for(int i = heightSize-1; i >= 0; i--) {\\n        // Find maximum element on its left...\\n        if(max2 < height[i]) {\\n            max2 = height[i];\\n        }\\n        right[i] = max2;\\n    }\\n        \\n    // To store the maximum water that can be stored..\\n    int trap = 0;\\n    // Scan and Calculate maximum trapped water...\\n    for(int i = 0; i  < heightSize; i++) {\\n        trap += min(left[i], right[i]) - height[i];\\n    }\\n    return trap;        //return the amount..\\n}\\n```\\n\\n# **Javascript Solution:**\\n```\\nvar trap = function(height) {\\n    \\n    let max1 = 0;\\n    //create left array so that we find the maximum element on its left...\\n    let left = [height.length];\\n    // Scan every element from left to right...\\n    for(let i = 0; i < height.length; i++) { \\n        // Find maximum element on its left...\\n        if(max1 < height[i]) {\\n            max1 = height[i];\\n        }\\n        left[i] = max1;\\n    }\\n        \\n    let max2 = 0;\\n    //create right array so that we find the maximum element on its right...\\n    let right = [height.length];\\n    // Scan every element from right to left...\\n    for(let i = height.length-1; i >= 0; i--){\\n        // Find maximum element on its left...\\n        if(max2 < height[i]) {\\n            max2 = height[i];\\n        }\\n        right[i] = max2;\\n    }\\n        \\n    // To store the maximum water that can be stored..\\n    let trap = 0;\\n    // Scan and Calculate maximum trapped water...\\n    for(let i = 0; i  < height.length; i++) {\\n        trap += Math.min(left[i], right[i]) - height[i];\\n    }\\n    return trap;        //return the amount..\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int max1 = 0;\\n        //create left array so that we find the maximum element on its left...\\n        int left[] = new int[height.length];\\n        // Scan every element from left to right...\\n        for(int i = 0; i < height.length; i++) {\\n            // Find maximum element on its left...\\n            if(max1 < height[i]) {\\n                max1 = height[i];\\n            }\\n            left[i] = max1;\\n        }\\n        \\n        int max2 = 0;\\n        //create right array so that we find the maximum element on its right...\\n        int right[] = new int[height.length];\\n        // Scan every element from right to left...\\n        for(int i = height.length-1; i >= 0; i--) {\\n            \\n            // Find maximum element on its left...\\n            if(max2 < height[i]) {\\n                max2 = height[i];\\n            }\\n            right[i] = max2;\\n        }\\n        \\n        // To store the maximum water that can be stored..\\n        int trap = 0;\\n        // Scan and Calculate maximum trapped water...\\n        for(int i = 0; i  < height.length; i++) {\\n            trap += Math.min(left[i], right[i]) - height[i];\\n        }\\n        return trap;        //return the amount..\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        // Base condition...\\n        if (height.empty())\\n            return 0;\\n        // To store the maximum water that can be stored..\\n        int trap = 0;\\n        \\n        int left = 0;\\n        int right = height.size() - 1;\\n        \\n        int max1 = height[left];\\n        int max2 = height[right];\\n        \\n        // Find maximum element on its left and right & Calculate maximum trapped water...\\n        while (left < right)\\n            if (max1 < max2) {\\n                trap += max1 - height[left];\\n                max1 = max(max1, height[++left]);\\n            } else {\\n                trap += max2 - height[right];\\n                max2 = max(max2, height[--right]);\\n            }\\n        return trap;    //return the amount..\\n    }\\n};\\n```\n```\\n#define min(a,b) ((a>b)?b:a)    //this is neccessary..\\nint trap(int* height, int heightSize){\\n    int max1 = 0;\\n    //create left array so that we find the maximum element on its left...\\n    int left[heightSize];\\n    // Scan every element from left to right...\\n    for(int i = 0; i < heightSize; i++) { \\n        // Find maximum element on its left...\\n        if(max1 < height[i]) {\\n            max1 = height[i];\\n        }\\n        left[i] = max1;\\n    }\\n        \\n    int max2 = 0;\\n    //create right array so that we find the maximum element on its right...\\n    int right[heightSize];\\n    // Scan every element from right to left...\\n    for(int i = heightSize-1; i >= 0; i--) {\\n        // Find maximum element on its left...\\n        if(max2 < height[i]) {\\n            max2 = height[i];\\n        }\\n        right[i] = max2;\\n    }\\n        \\n    // To store the maximum water that can be stored..\\n    int trap = 0;\\n    // Scan and Calculate maximum trapped water...\\n    for(int i = 0; i  < heightSize; i++) {\\n        trap += min(left[i], right[i]) - height[i];\\n    }\\n    return trap;        //return the amount..\\n}\\n```\n```\\nvar trap = function(height) {\\n    \\n    let max1 = 0;\\n    //create left array so that we find the maximum element on its left...\\n    let left = [height.length];\\n    // Scan every element from left to right...\\n    for(let i = 0; i < height.length; i++) { \\n        // Find maximum element on its left...\\n        if(max1 < height[i]) {\\n            max1 = height[i];\\n        }\\n        left[i] = max1;\\n    }\\n        \\n    let max2 = 0;\\n    //create right array so that we find the maximum element on its right...\\n    let right = [height.length];\\n    // Scan every element from right to left...\\n    for(let i = height.length-1; i >= 0; i--){\\n        // Find maximum element on its left...\\n        if(max2 < height[i]) {\\n            max2 = height[i];\\n        }\\n        right[i] = max2;\\n    }\\n        \\n    // To store the maximum water that can be stored..\\n    let trap = 0;\\n    // Scan and Calculate maximum trapped water...\\n    for(let i = 0; i  < height.length; i++) {\\n        trap += Math.min(left[i], right[i]) - height[i];\\n    }\\n    return trap;        //return the amount..\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102066,
                "title": "c-simplest-way-to-solve-with-proper-explanation-100",
                "content": "![image](https://assets.leetcode.com/users/images/8215147f-7b17-485d-8189-0463c22da106_1654167246.0074456.jpeg)\\n![image](https://assets.leetcode.com/users/images/c6645ebe-0cf2-4b53-9256-ee2b51b9f2c8_1654167262.979194.jpeg)\\n![image](https://assets.leetcode.com/users/images/e4913981-04b7-48d0-bca4-a896471478fe_1654167279.6840017.jpeg)\\n\\n**Final Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size=height.size();\\n        \\n        vector<int> maxLeft(size);\\n        maxLeft[0]=height[0];\\n        for(int i=1;i<size;i++)\\n            maxLeft[i]=max(maxLeft[i-1],height[i]);\\n        \\n        vector<int> maxRight(size);\\n        maxRight[size-1]=height[size-1];\\n        for(int i=size-2;i>=0;i--) \\n            maxRight[i]=max(maxRight[i+1],height[i]);\\n        //reverse(maxRight.begin(),maxRight.end()); ------> No need to reverse\\n        \\n        vector<int> water(size);\\n        for(int i=0;i<size;i++)\\n            water[i] = min(maxLeft[i],maxRight[i]) - height[i];\\n        \\n        int sum=0;\\n        for(int i=0;i<size;i++)\\n            sum = sum + water[i];\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n**Do Upvote, if you liked. :)**\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size=height.size();\\n        \\n        vector<int> maxLeft(size);\\n        maxLeft[0]=height[0];\\n        for(int i=1;i<size;i++)\\n            maxLeft[i]=max(maxLeft[i-1],height[i]);\\n        \\n        vector<int> maxRight(size);\\n        maxRight[size-1]=height[size-1];\\n        for(int i=size-2;i>=0;i--) \\n            maxRight[i]=max(maxRight[i+1],height[i]);\\n        //reverse(maxRight.begin(),maxRight.end()); ------> No need to reverse\\n        \\n        vector<int> water(size);\\n        for(int i=0;i<size;i++)\\n            water[i] = min(maxLeft[i],maxRight[i]) - height[i];\\n        \\n        int sum=0;\\n        for(int i=0;i<size;i++)\\n            sum = sum + water[i];\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373887,
                "title": "trapping-rainwater-detailed-explanation-java",
                "content": "**Intuition**\\n* Water can only be trapped if there are blocks on the left and right to make sure it does not flow.\\n* Thus minimum number of blocks has to be 3\\n* Now the idea is to maintain a `leftMax` and a `rightMax` to store the max height of blocks on the left and right side.\\n* What do we acheive with this `leftMax` & `rightMax`? At any point (lets say `i`) we can know that the water which can be trapped will either be bounded by the `leftMax` or `rightMax`, whichever is mimimum.\\nEg: Say we have heights as `0-indexed` array `[3,1,6]` and `i=1`. So `leftMax=3` and `rightMax=6`. What could be the water trapped at `i`? Since if we fill water of more than `3 units` heights it will flow from the left side.\\n* Once we know if `leftMax` is my bound(lesser) or `rightMax`, we will fill the water to that height. But we need to subtract the height of the `ith` block if we need to fill water. In above eg. water at `i=1` block would be `2` since the height of this block is `1`.\\n* So we start from both sides and if `rightMax` is greater, then we know our bound is on the left side and vice versa.\\n* We also need to update our `leftMax`  or `rightMax` if the height of the block is greater than `leftMax` or `rightMax` based on indices `l` and `r` respectively.\\n* If `l` becomes greater than `r` we have seen all the blocks so return the water trapped.\\n\\n```\\nclass Solution {\\n    public int trap(int[] heights) {\\n        int n = heights.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax = heights[0];\\n        int rightMax = heights[n-1];\\n        int l = 1;\\n        int r = n-2;\\n        \\n        int trappedWater = 0;\\n        while(l<=r){\\n            if(leftMax<rightMax){\\n                if(heights[l]>leftMax){\\n                    leftMax = heights[l];\\n                } else {\\n                    trappedWater+=(leftMax-heights[l]);\\n                }\\n                l++;\\n            } else {\\n                if(heights[r]>rightMax){\\n                    rightMax = heights[r];\\n                } else {\\n                    trappedWater+=(rightMax-heights[r]);\\n                }\\n                r--;\\n            }\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(1)`\\n\\nWe can also do the same with `O(n)` space. The idea is same but instead of two pointers we keep `leftMax` and `rightMax` for any index in an array.\\n*Note*: Since only lower bound is needed in this case is the reason why we can eliminate this array by the use of two pointers.\\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax[] = new int[n];\\n        int rightMax[] = new int[n];\\n        leftMax[0] = height[0];\\n        rightMax[n-1] = height[n-1];\\n        for(int i=1;i<n;i++){\\n            leftMax[i] = Math.max(leftMax[i-1], height[i]);\\n            rightMax[n-i-1] = Math.max(rightMax[n-i], height[n-i-1]);\\n        }\\n        \\n        int trappedWater = 0;\\n        for(int i=0;i<n;i++){\\n            trappedWater += Math.min(leftMax[i], rightMax[i])-height[i];\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n\\nPlease upvote if this helps you understanding so it can reach others as well. Thanks :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] heights) {\\n        int n = heights.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax = heights[0];\\n        int rightMax = heights[n-1];\\n        int l = 1;\\n        int r = n-2;\\n        \\n        int trappedWater = 0;\\n        while(l<=r){\\n            if(leftMax<rightMax){\\n                if(heights[l]>leftMax){\\n                    leftMax = heights[l];\\n                } else {\\n                    trappedWater+=(leftMax-heights[l]);\\n                }\\n                l++;\\n            } else {\\n                if(heights[r]>rightMax){\\n                    rightMax = heights[r];\\n                } else {\\n                    trappedWater+=(rightMax-heights[r]);\\n                }\\n                r--;\\n            }\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax[] = new int[n];\\n        int rightMax[] = new int[n];\\n        leftMax[0] = height[0];\\n        rightMax[n-1] = height[n-1];\\n        for(int i=1;i<n;i++){\\n            leftMax[i] = Math.max(leftMax[i-1], height[i]);\\n            rightMax[n-i-1] = Math.max(rightMax[n-i], height[n-i-1]);\\n        }\\n        \\n        int trappedWater = 0;\\n        for(int i=0;i<n;i++){\\n            trappedWater += Math.min(leftMax[i], rightMax[i])-height[i];\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359803,
                "title": "python3-from-dynamic-programming-to-2-pointer",
                "content": "1.   Dynamic programming:\\n\\tTime complexity : O(n)\\n\\tSpace complexity: O(n)\\n\\t\\n\\n\\tExplanation: \\n\\tLet\\'s move from left to right.\\n\\tQuestion :How many unit of water can one bar(height[i]) trap?\\n\\tAnswer:  it depends maximum height from the left side, the maximum height from the right side, and the height of the bar.\\n\\t\\n\\tlower_bound = min (maximum_left, maximum_right)\\n\\t\\n\\theight =         [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\\n\\tmaximum_left =   [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]\\n\\tmaximum_right =  [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 0]\\n\\tlower_bound =    [0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 0]\\n\\twater_trap_at_i =[0, 0, 1, -1, 1,2, 1, -1,0, 1, -1, 0]  \\n\\t\\n\\t ignore negative values in water_trap_at_i, it means,\\n\\t the height at index i is high than the lower bound.\\n\\t\\n\\t\\n\\twater_level means the at index i, the potential water level can reach.\\n\\tindex  0 1 2 3 4 5\\n\\theight 0 1 0 2 1 0\\n\\t2            -\\n\\t1        -       -\\n\\t0      -    -       -\\n\\tthe water_level at index i should be the lower height of maximum_left and maximum_right.\\n\\tfor example: \\n\\tat index 2, the maximum_left = 1, the maximum_right = 2. \\n\\tthe lower boundry height is 1, \\n\\tthe amount of water can be traped here equals lower boundry minus height.\\n\\n\\t\\n\\t\\n```\\nclass Solution(object):\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if height == []:\\n            return 0\\n\\n        n = len(height)\\n        max_left = [0]* n\\n        max_right = [0]* n\\n        ##print(max_left, height)\\n        max_left[0] = 0\\n        max_right[n-1] = 0\\n        for i in range (1, n):\\n            max_left[i] = max(max_left[i - 1], height[i-1])\\n             \\n        for i in range(n-2, -1, -1):\\n           \\n            max_right[i] = max(max_right[i + 1], height[i + 1])\\n\\n        output = 0\\n        print(max_left, max_right)\\n        \\n        for i in range(n):\\n\\t\\t    \\n            lower_boundary = min(max_left[i], max_right[i])\\n            \\n            max_trap_at_i = lower_boundary - height[i]\\n            \\n            if max_trap_at_i > 0:\\n                output += max_trap_at_i\\n                \\n        return output\\n```\\n\\n\\n2. 2 Pointer \\nTime complexity: O(n)\\nSpace compexity:O(1)\\n```\\nLet\\'s look at the maximum_left, maximum_right, lower_bound\\nused in dynamic programming\\nand think about how to improve them. \\n\\nheight =         [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\\nmaximum_left =   [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]\\nmaximum_right =  [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 0]\\nlower_bound =    [0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 0]\\nwater_trap_at_i =[0, 0, 1, -1, 1,2, 1, -1,0, 1, -1, 0]  \\n\\n\\u2728Are they necessary?\\u2728\\nNo. they are not.  \\nWe only need store them as variables.\\nl_max: moving from left to right, updating the maximum height seeing so far.\\nr_max: moving from right to left, updating the maximum height seeing so far.\\nIt becomes 2 pointers moving towards to each other.\\n\\nheight =         [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\\n                  ^                                ^\\nl = 0, r = 11     l_max = 0                        r_max = 1   answer = 0\\n                     ^                          ^\\nl = 1, r = 10     l_max = 1                     r_max = 2      answer = 0\\n\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        l,r = 0 , len(height) -1\\n        l_max, r_max = 0,0\\n        while l < r:\\n\\t\\t# case 1: lower_bound is from left.\\n            if height[l] < height[r]:\\n                if height[l] >= l_max:\\n                    l_max = height[l]\\n                else:\\n                    ans += l_max - height[l]\\n                l += 1\\n\\t\\t\\t# case 2: the lower_bound is from right\\n            else:\\n                if height[r] >= r_max:\\n                    r_max = height[r]\\n                else:\\n                    ans += r_max - height[r]\\n                r -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if height == []:\\n            return 0\\n\\n        n = len(height)\\n        max_left = [0]* n\\n        max_right = [0]* n\\n        ##print(max_left, height)\\n        max_left[0] = 0\\n        max_right[n-1] = 0\\n        for i in range (1, n):\\n            max_left[i] = max(max_left[i - 1], height[i-1])\\n             \\n        for i in range(n-2, -1, -1):\\n           \\n            max_right[i] = max(max_right[i + 1], height[i + 1])\\n\\n        output = 0\\n        print(max_left, max_right)\\n        \\n        for i in range(n):\\n\\t\\t    \\n            lower_boundary = min(max_left[i], max_right[i])\\n            \\n            max_trap_at_i = lower_boundary - height[i]\\n            \\n            if max_trap_at_i > 0:\\n                output += max_trap_at_i\\n                \\n        return output\\n```\n```\\nLet\\'s look at the maximum_left, maximum_right, lower_bound\\nused in dynamic programming\\nand think about how to improve them. \\n\\nheight =         [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\\nmaximum_left =   [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]\\nmaximum_right =  [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 0]\\nlower_bound =    [0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 0]\\nwater_trap_at_i =[0, 0, 1, -1, 1,2, 1, -1,0, 1, -1, 0]  \\n\\n\\u2728Are they necessary?\\u2728\\nNo. they are not.  \\nWe only need store them as variables.\\nl_max: moving from left to right, updating the maximum height seeing so far.\\nr_max: moving from right to left, updating the maximum height seeing so far.\\nIt becomes 2 pointers moving towards to each other.\\n\\nheight =         [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\\n                  ^                                ^\\nl = 0, r = 11     l_max = 0                        r_max = 1   answer = 0\\n                     ^                          ^\\nl = 1, r = 10     l_max = 1                     r_max = 2      answer = 0\\n\\n\\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        l,r = 0 , len(height) -1\\n        l_max, r_max = 0,0\\n        while l < r:\\n\\t\\t# case 1: lower_bound is from left.\\n            if height[l] < height[r]:\\n                if height[l] >= l_max:\\n                    l_max = height[l]\\n                else:\\n                    ans += l_max - height[l]\\n                l += 1\\n\\t\\t\\t# case 2: the lower_bound is from right\\n            else:\\n                if height[r] >= r_max:\\n                    r_max = height[r]\\n                else:\\n                    ans += r_max - height[r]\\n                r -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355890,
                "title": "solution-swift-trapping-rain-water-test-cases",
                "content": "```swift\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        \\n        var stack: [Int] = [], result = 0\\n        \\n        for i in height.indices {\\n            let hidx = height[i]\\n            \\n            while !(stack.isEmpty), let last = stack.last, hidx > height[last] {\\n                let top = stack.removeLast()\\n                if !(stack.isEmpty), let last = stack.last {\\n                    let diff = min(hidx, height[last]) - height[top]\\n                    result += (i - last - 1) * diff\\n                } else { break }\\n            }\\n            stack.append(i)\\n        }\\n        \\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.024 (0.026) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1].\\n    /// In this case, 6 units of rain water (blue section) are being trapped.\\n    func test0() {\\n        let value = solution.trap([0,1,0,2,1,0,1,3,2,1,2,1])\\n        XCTAssertEqual(value, 6)\\n    }\\n    \\n    func test1() {\\n        let value = solution.trap([4,2,0,3,2,5])\\n        XCTAssertEqual(value, 9)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        \\n        var stack: [Int] = [], result = 0\\n        \\n        for i in height.indices {\\n            let hidx = height[i]\\n            \\n            while !(stack.isEmpty), let last = stack.last, hidx > height[last] {\\n                let top = stack.removeLast()\\n                if !(stack.isEmpty), let last = stack.last {\\n                    let diff = min(hidx, height[last]) - height[top]\\n                    result += (i - last - 1) * diff\\n                } else { break }\\n            }\\n            stack.append(i)\\n        }\\n        \\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1].\\n    /// In this case, 6 units of rain water (blue section) are being trapped.\\n    func test0() {\\n        let value = solution.trap([0,1,0,2,1,0,1,3,2,1,2,1])\\n        XCTAssertEqual(value, 6)\\n    }\\n    \\n    func test1() {\\n        let value = solution.trap([4,2,0,3,2,5])\\n        XCTAssertEqual(value, 9)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536379,
                "title": "java-brute-force",
                "content": "```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int res = 0;\\n        for (int i = 0; i < height.length; i++){\\n            int leftMax = 0, rightMax = 0;\\n            for (int k = i; k >= 0; k--){\\n                leftMax = Math.max(leftMax, height[k]);\\n            }\\n            for (int j = i; j < height.length; j++){\\n                rightMax = Math.max(rightMax, height[j]);\\n            }\\n            res += Math.min(leftMax, rightMax) - height[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int res = 0;\\n        for (int i = 0; i < height.length; i++){\\n            int leftMax = 0, rightMax = 0;\\n            for (int k = i; k >= 0; k--){\\n                leftMax = Math.max(leftMax, height[k]);\\n            }\\n            for (int j = i; j < height.length; j++){\\n                rightMax = Math.max(rightMax, height[j]);\\n            }\\n            res += Math.min(leftMax, rightMax) - height[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151093,
                "title": "python-o-n-stack-solution-without-recursion",
                "content": "```py3\\nclass Solution:\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        #initialize the  two variables required\\n        stk = []\\n        waterCollected = 0\\n\\n        #iterate over the whole array of bars\\n        for i in range(0,len(height)):\\n\\n            #while there is something  in the stack and the current bar\\'s height is more than \\n            #the height of index of the stack\\'s top value\\n            while stk and height[i] > height[stk[-1]]:\\n\\n                #let\\'s pop the top of the stack and call this index as top\\n                top = stk.pop()\\n\\n                #check if the last pop results in underflow --> break \\n                if not len(stk):\\n                    break\\n\\n                #calculate the distance from current bar to the top of the stack\\'s element index\\n                #remember this is different from the element we popped; due to the while loop\\n                # we are trying to touch all the elements in the stack which are smaller than current\\n                distance = i - stk[-1] - 1\\n\\n                #now find out the water collected between the current and stack\\'s last \\n                #element index\\'s height--> only the minimum of these two will help us \\n                #determine the water collected. Again, we need not worry about the bars in \\n                #between as they were already covered in the while loop. We\\'re concerned with \\n                #two bars here, the distance between them and the water trapped between them \\n                #and above the height of top element\\'s height. \\n                waterBetweenBars = min(height[i], height[stk[-1]]) - height[top]\\n\\n                #add each iterative waterBetweenBars collected to the result\\n                waterCollected += distance*waterBetweenBars \\n\\n            #if the height of the current bar is less than or equal to height[stk[-1]]\\n            #add that index to the stack\\n            stk.append(i)\\n\\n        #return the default value or whatever was calculated\\n        return waterCollected\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py3\\nclass Solution:\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        #initialize the  two variables required\\n        stk = []\\n        waterCollected = 0\\n\\n        #iterate over the whole array of bars\\n        for i in range(0,len(height)):\\n\\n            #while there is something  in the stack and the current bar\\'s height is more than \\n            #the height of index of the stack\\'s top value\\n            while stk and height[i] > height[stk[-1]]:\\n\\n                #let\\'s pop the top of the stack and call this index as top\\n                top = stk.pop()\\n\\n                #check if the last pop results in underflow --> break \\n                if not len(stk):\\n                    break\\n\\n                #calculate the distance from current bar to the top of the stack\\'s element index\\n                #remember this is different from the element we popped; due to the while loop\\n                # we are trying to touch all the elements in the stack which are smaller than current\\n                distance = i - stk[-1] - 1\\n\\n                #now find out the water collected between the current and stack\\'s last \\n                #element index\\'s height--> only the minimum of these two will help us \\n                #determine the water collected. Again, we need not worry about the bars in \\n                #between as they were already covered in the while loop. We\\'re concerned with \\n                #two bars here, the distance between them and the water trapped between them \\n                #and above the height of top element\\'s height. \\n                waterBetweenBars = min(height[i], height[stk[-1]]) - height[top]\\n\\n                #add each iterative waterBetweenBars collected to the result\\n                waterCollected += distance*waterBetweenBars \\n\\n            #if the height of the current bar is less than or equal to height[stk[-1]]\\n            #add that index to the stack\\n            stk.append(i)\\n\\n        #return the default value or whatever was calculated\\n        return waterCollected\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17425,
                "title": "intuitive-java-solution-with-a-detailed-explanation",
                "content": "The level of the water on top of each bar is determined by the smaller of the two values: leftMax and rightMax.\\n__leftMax__ is the maximum height of the bars that are located to the left of the bar.\\n__rightMax__ is the maximum height of the bars that are located to the right of the bar.\\n\\nFor example, if our array is [13,4,10,2,5,7] and we would like to find the level of the water at index 3. We would search for the largest bar to the left (leftMax = 13), and the largest bar to the right (rightMax = 7). So the level of the water is going to be min(13,7) = 7.\\n\\nNotice that in order to find the amount of water that was trapped in a particular bar, we would take the the height of the bar and subtract it from the level of the water. So in our example, the actual amount of trapped water at index 3 is 7 - 2 = 5.\\nTherefore, the following invariant holds: \\n__Trapped water at height[i] is equal to min(leftMax, rightMax) - height[i]__\\n\\nThis observation leads us to the following \"brute force\" solution:\\n```java\\npublic int trap(int[] height) {\\n    int totalWater = 0;\\n    for (int i = 0; i < height.length; i++) {\\n        int leftMax = height[i];\\n        for (int j = 0; j < i; j++) {\\n            leftMax = Math.max(leftMax, height[j]);\\n        }\\n        int rightMax = height[i];\\n        for (int j = i; j < height.length; j++) {\\n            rightMax = Math.max(rightMax, height[j]);\\n        }\\n        int waterLevel = Math.min(leftMax, rightMax);\\n        totalWater += waterLevel - height[i];\\n    }\\n    return totalWater;\\n}\\n```\\nAs we can see, the runtime complexity of this solution is O(N^2) and the space complexity is O(1). We can optimize the runtime of this solution to be O(N) at the expense of using O(N) extra space. Using some inspiration from dynamic programming, we will precompute the leftMax and the rightMax values of each bar. That way, the loop that calculates the total water will have a O(1) access to the leftMax and rightMax values of each bar.\\n```java\\npublic int trap(int[] height) {\\n    if (height.length == 0) return 0;\\n    int[] leftMax = new int[height.length];\\n    int[] rightMax = new int[height.length];\\n    int currentLeftMax = height[0];\\n    for (int i = 0; i < height.length; i++) {\\n        currentLeftMax = Math.max(currentLeftMax, height[i]);\\n        leftMax[i] = currentLeftMax;\\n    }\\n    int currentRightMax = height[height.length - 1];\\n    for (int i = height.length - 1; i >= 0; i--) {\\n        currentRightMax = Math.max(currentRightMax, height[i]);\\n        rightMax[i] = currentRightMax;\\n    }\\n    int totalWater = 0;\\n    for (int i = 0; i < height.length; i++) {\\n        int waterLevel = Math.min(leftMax[i], rightMax[i]);\\n        totalWater += waterLevel - height[i];\\n    }\\n    return totalWater;\\n}\\n```\\nHowever, can we solve this problem in O(N) runtime and O(1) space complexity? This would require a deeper insight into the problem. \\nLet's start by first considering the \"two pointer\" strategy where we iterate through the array using two pointers originally located at the beginning and the end (called `left` and `right`).\\nAs we move our pointers towards each other, we can keep track of the current value of maxLeft and maxRight (let's call them `tempMaxLeft` and `tempMaxRight`).\\nCan we conclude what is the water level at height[left] or height[right]? Let's first look at how we would find the water level at height[left].\\nAs previously mentioned, the water level at height[left] will be the minimum of maxLeft and maxRight. As we iterate through the array, we know that tempMaxLeft is actually equal to maxLeft, but tempMaxRight is not necessarily equal to maxRight. This is because we haven't yet considered all the elements to the right of heights[left]; unlike the case with heights[left] where we already iterated through all the elements that are to the left of height[left].\\nHowever, what if tempMaxLeft <= tempMaxRight? We know that tempMaxLeft is equal to maxLeft, and that maxRight can't get smaller than tempMaxRight. In other words, the following holds: maxLeft <= tempMaxRight <= maxRight. Hence, since we need the smaller of maxLeft and maxRight and maxLeft is equal to tempMaxLeft, we can conclude that the water level at height[left] is equal to tempMaxLeft. and so the amount of water at that bar is going to be `tempMaxLeft - height[left]`.\\n\\nThis interesting observation leads to the following code:\\n```java\\npublic int trap(int[] height) {\\n    if (height.length == 0) return 0;\\n    int left = 0, right = height.length - 1;\\n    int tempMaxLeft = height[left], tempMaxRight = height[right];\\n    int totalWater = 0;\\n    while (left <= right) {\\n        tempMaxLeft = Math.max(tempMaxLeft, height[left]);\\n        tempMaxRight = Math.max(tempMaxRight, height[right]);\\n        if (tempMaxLeft <= tempMaxRight) {\\n            totalWater += tempMaxLeft - height[left++];\\n        } else {\\n            totalWater += tempMaxRight - height[right--];\\n        }\\n    }\\n    return totalWater;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int trap(int[] height) {\\n    int totalWater = 0;\\n    for (int i = 0; i < height.length; i++) {\\n        int leftMax = height[i];\\n        for (int j = 0; j < i; j++) {\\n            leftMax = Math.max(leftMax, height[j]);\\n        }\\n        int rightMax = height[i];\\n        for (int j = i; j < height.length; j++) {\\n            rightMax = Math.max(rightMax, height[j]);\\n        }\\n        int waterLevel = Math.min(leftMax, rightMax);\\n        totalWater += waterLevel - height[i];\\n    }\\n    return totalWater;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n    if (height.length == 0) return 0;\\n    int[] leftMax = new int[height.length];\\n    int[] rightMax = new int[height.length];\\n    int currentLeftMax = height[0];\\n    for (int i = 0; i < height.length; i++) {\\n        currentLeftMax = Math.max(currentLeftMax, height[i]);\\n        leftMax[i] = currentLeftMax;\\n    }\\n    int currentRightMax = height[height.length - 1];\\n    for (int i = height.length - 1; i >= 0; i--) {\\n        currentRightMax = Math.max(currentRightMax, height[i]);\\n        rightMax[i] = currentRightMax;\\n    }\\n    int totalWater = 0;\\n    for (int i = 0; i < height.length; i++) {\\n        int waterLevel = Math.min(leftMax[i], rightMax[i]);\\n        totalWater += waterLevel - height[i];\\n    }\\n    return totalWater;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n    if (height.length == 0) return 0;\\n    int left = 0, right = height.length - 1;\\n    int tempMaxLeft = height[left], tempMaxRight = height[right];\\n    int totalWater = 0;\\n    while (left <= right) {\\n        tempMaxLeft = Math.max(tempMaxLeft, height[left]);\\n        tempMaxRight = Math.max(tempMaxRight, height[right]);\\n        if (tempMaxLeft <= tempMaxRight) {\\n            totalWater += tempMaxLeft - height[left++];\\n        } else {\\n            totalWater += tempMaxRight - height[right--];\\n        }\\n    }\\n    return totalWater;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556570,
                "title": "java-solution-all-approaches-brute-to-optimal",
                "content": "Let\\'s start off with brute force approach and gradually move to optimal solution\\n\\n## Brute approach\\n\\n**Code**\\nTime - O(n^2)\\nSpace - O(1)\\n\\n```java\\npublic int trapBrute(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tint j = i, left = Integer.MIN_VALUE, right = Integer.MIN_VALUE;\\n\\t\\twhile(j >= 0) {\\n\\t\\t\\tleft = Math.max(left, height[j]);\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\tj = i;\\n\\t\\twhile(j < n) {\\n\\t\\t\\tright = Math.max(right, height[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tsum += Math.min(left, right) - height[i];\\n\\t}\\n\\n\\treturn sum;\\n}\\n```\\n\\n**Explanation**\\nAs we know that the water will be stored only if there is a valley, with valley I mean that for an index there should be a wall to the left as well as to right that is greater or equal to the height at that index, then it will be able to store water equal to it\\'s height subtracted from the minimum out of left and right walls. (try drawing it on paper for better clarity).\\n\\nSo in this approach what I did was for every index I calculated the left max and right max and updated sum by this expression.\\n`sum += Math.min(left, right) - height[i]`\\n\\n---\\n\\n## Prefix Sum approach\\nSo in the last approach we were actually traversing the entire list again just to calculate the left and right maximum, doesn\\'t it make sense to store prefix sum in an array for left and suffix sum for right values.\\n\\n**Code**\\nTime - O(n)\\nSpace - O(n)\\n```java\\npublic int trapPrefix(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\t// store maximum to the left\\n\\tint[] pre = new int[n];\\n\\tpre[0] = height[0];\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tpre[i] = Math.max(pre[i-1], height[i]);\\n\\t}\\n\\t// store maximum to the right\\n\\tint[] suff = new int[n];\\n\\tsuff[n-1] = height[n-1];\\n\\tfor(int i = n-2; i >= 0; i--) {\\n\\t\\tsuff[i] = Math.max(suff[i+1], height[i]);\\n\\t}\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tsum += Math.min(pre[i], suff[i]) - height[i];\\n\\t}\\n\\treturn sum;\\n}\\n```\\n\\n---\\n\\n## Two pointer approach\\n\\nNow talking about the optimal solution we have two pointer approach.\\n\\n**Code**\\n```java\\npublic int trap(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\n\\tint l = 0, r = n - 1;\\n\\tint leftMax = 0, rightMax = 0;\\n\\twhile(l < r) {\\n\\t\\tif(height[l] <= height[r]) {\\n\\t\\t\\tif(height[l] >= leftMax) leftMax = height[l];\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsum += leftMax - height[l];\\n\\t\\t\\t}\\n\\t\\t\\tl++;\\n\\t\\t} else {\\n\\t\\t\\tif(height[r] >= rightMax) rightMax = height[r];\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsum += rightMax - height[r];\\n\\t\\t\\t}\\n\\t\\t\\tr--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn sum;\\n}\\n```\\n\\n**Explanation**\\nIn this we will use two pointers `l` and `r` for traversing the array, and `leftmax` and `rightmax` for storing the maximum to the left and to the right. \\n\\nOne thing needs to be very clear that we can add water to our `sum` only when there is a valley. \\nSo while traversing if we find that `height[l]` is less than or equal to `height[r]`, then we know that water can only be stored if the `height[l]` is also less than `leftmax`. \\n\\nHere water can be stored:-\\n![image](https://assets.leetcode.com/users/images/fa45b642-9041-45fe-b861-f698e24fb611_1635922730.8935938.png)\\n\\nBut not here:-\\n![image](https://assets.leetcode.com/users/images/0e043405-3f9a-477c-804d-b56c2aebad29_1635922861.5676856.png)\\n\\nNow if `height[l]` greater than `height[r]` then we know that water can be stored if `height[r]` is smaller than `rightMax` as then only there will be a valley.\\n\\n![image](https://assets.leetcode.com/users/images/340f816e-d616-425f-a23e-75ee27df78f6_1635923144.6761084.png)\\n\\nNo water here:-\\n![image](https://assets.leetcode.com/users/images/2aa82096-a186-4334-b77f-5305f87105cd_1635923307.1454563.png)\\n\\nSo that\\'s what the logic is, interesting isn\\'t it?\\n\\nHope it helps\\nIf you\\'ve reached here don\\'t go without upvoting\\nThank You",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```java\\npublic int trapBrute(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tint j = i, left = Integer.MIN_VALUE, right = Integer.MIN_VALUE;\\n\\t\\twhile(j >= 0) {\\n\\t\\t\\tleft = Math.max(left, height[j]);\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\tj = i;\\n\\t\\twhile(j < n) {\\n\\t\\t\\tright = Math.max(right, height[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tsum += Math.min(left, right) - height[i];\\n\\t}\\n\\n\\treturn sum;\\n}\\n```\n```java\\npublic int trapPrefix(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\t// store maximum to the left\\n\\tint[] pre = new int[n];\\n\\tpre[0] = height[0];\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tpre[i] = Math.max(pre[i-1], height[i]);\\n\\t}\\n\\t// store maximum to the right\\n\\tint[] suff = new int[n];\\n\\tsuff[n-1] = height[n-1];\\n\\tfor(int i = n-2; i >= 0; i--) {\\n\\t\\tsuff[i] = Math.max(suff[i+1], height[i]);\\n\\t}\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tsum += Math.min(pre[i], suff[i]) - height[i];\\n\\t}\\n\\treturn sum;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\n\\tint l = 0, r = n - 1;\\n\\tint leftMax = 0, rightMax = 0;\\n\\twhile(l < r) {\\n\\t\\tif(height[l] <= height[r]) {\\n\\t\\t\\tif(height[l] >= leftMax) leftMax = height[l];\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsum += leftMax - height[l];\\n\\t\\t\\t}\\n\\t\\t\\tl++;\\n\\t\\t} else {\\n\\t\\t\\tif(height[r] >= rightMax) rightMax = height[r];\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsum += rightMax - height[r];\\n\\t\\t\\t}\\n\\t\\t\\tr--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2013463,
                "title": "7-lines-c-solution-two-pointer-easy-to-understand",
                "content": "We find `left_max` and `right_max` at every iteration `while(left < right)`. If `left_max < right_max`, we update left else we update right after adding the minimum side `(left or right)` to the `ans (water)`.\\n```\\nint trap(vector<int>& h) {\\n\\tint water = 0, l = 0, r = h.size()-1, lmax = INT_MIN, rmax = INT_MIN;\\n\\twhile(l < r){\\n\\t\\tlmax = max(h[l], lmax);\\n\\t\\trmax = max(h[r], rmax);\\n\\t\\twater += (lmax < rmax) ? lmax-h[l++] : rmax-h[r--] ;\\n\\t}\\n\\treturn water;\\n}\\n```\\n\\n**Time complexity:** O(n)\\n**Space complexity:** O(1)\\n\\n**If you like it, Please Upvote!!!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint trap(vector<int>& h) {\\n\\tint water = 0, l = 0, r = h.size()-1, lmax = INT_MIN, rmax = INT_MIN;\\n\\twhile(l < r){\\n\\t\\tlmax = max(h[l], lmax);\\n\\t\\trmax = max(h[r], rmax);\\n\\t\\twater += (lmax < rmax) ? lmax-h[l++] : rmax-h[r--] ;\\n\\t}\\n\\treturn water;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389610,
                "title": "cpp-monotonic-stack",
                "content": "The lower bars on the left are useless, so we use a decreasing stack to record all the higher bars on the left.\\n```\\nint trap(vector<int>& A) {\\n        //monotonic decreasing stack\\n        stack<int> st;\\n        int res = 0;\\n        for(int i = 0, n = A.size(); i < n; ++i) {\\n            while(st.size() && A[i] > A[st.top()]) {\\n                int cur = st.top();\\n                st.pop();\\n                if(st.size()) {\\n                    res += (i - st.top() - 1) * (min(A[st.top()], A[i]) - A[cur]);\\n                }\\n            }\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n```\\nComplexity:\\n* Time: O(N)\\n* Space: O(N)",
                "solutionTags": [],
                "code": "```\\nint trap(vector<int>& A) {\\n        //monotonic decreasing stack\\n        stack<int> st;\\n        int res = 0;\\n        for(int i = 0, n = A.size(); i < n; ++i) {\\n            while(st.size() && A[i] > A[st.top()]) {\\n                int cur = st.top();\\n                st.pop();\\n                if(st.size()) {\\n                    res += (i - st.top() - 1) * (min(A[st.top()], A[i]) - A[cur]);\\n                }\\n            }\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 552821,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    const size = height.length;\\n    const leftMax = new Array(size);\\n    const rightMax = new Array(size);\\n    let water = 0\\n    \\n    leftMax[0] = height[0]\\n    rightMax[size - 1] = height[size - 1];\\n    \\n    // find the height of left wall for each elevation\\n    for (let i = 1; i < size; i++) {\\n        leftMax[i] = Math.max(height[i], leftMax[i - 1]);\\n    }\\n    // find the height of right wall for each elevation\\n    for (let i = size - 2; i >= 0; i--) {\\n        rightMax[i] = Math.max(height[i], rightMax[i + 1]);\\n    }\\n    // the height of the water for each elevation would be the \\n    // the height of the shorter wal minus the elevation height\\n    for (let i = 1; i < size - 1; i++) {\\n        water += Math.min(leftMax[i], rightMax[i]) - height[i]   \\n    }\\n    \\n    return water\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    const size = height.length;\\n    const leftMax = new Array(size);\\n    const rightMax = new Array(size);\\n    let water = 0\\n    \\n    leftMax[0] = height[0]\\n    rightMax[size - 1] = height[size - 1];\\n    \\n    // find the height of left wall for each elevation\\n    for (let i = 1; i < size; i++) {\\n        leftMax[i] = Math.max(height[i], leftMax[i - 1]);\\n    }\\n    // find the height of right wall for each elevation\\n    for (let i = size - 2; i >= 0; i--) {\\n        rightMax[i] = Math.max(height[i], rightMax[i + 1]);\\n    }\\n    // the height of the water for each elevation would be the \\n    // the height of the shorter wal minus the elevation height\\n    for (let i = 1; i < size - 1; i++) {\\n        water += Math.min(leftMax[i], rightMax[i]) - height[i]   \\n    }\\n    \\n    return water\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17498,
                "title": "clear-c-solution-11ms",
                "content": "Count the rocks cell first, then the total cell.\\nThe key thing here is that if a cell has some rock on both left and right that higher than itself, it will either be water or rock.\\n\\n    class Solution {\\n    public:\\n        int trap(int A[], int n) {\\n            int summap = 0;\\n            int sumtot = 0;\\n            \\n            for(int i = 0; i < n; i++) summap += A[i];\\n            \\n            int left = 0, right = n - 1;\\n            int leftbar = 0, rightbar = 0;\\n            while(left <= right) {\\n                leftbar = max(A[left], leftbar);\\n                rightbar = max(A[right], rightbar);\\n                \\n                if(leftbar <= rightbar) {\\n                    sumtot += leftbar;\\n                    left++;\\n                } else {\\n                    sumtot += rightbar;\\n                    right--;\\n                }\\n            }\\n            \\n            return sumtot - summap;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trap(int A[], int n) {\\n            int summap = 0;\\n            int sumtot = 0;\\n            \\n            for(int i = 0; i < n; i++) summap += A[i];\\n            \\n            int left = 0, right = n - 1;\\n            int leftbar = 0, rightbar = 0;\\n            while(left <= right) {\\n                leftbar = max(A[left], leftbar);\\n                rightbar = max(A[right], rightbar);\\n                \\n                if(leftbar <= rightbar) {\\n                    sumtot += leftbar;\\n                    left++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17393,
                "title": "javascript-o-n-geometric-solution",
                "content": "```\\nvar trap = function(height) {\\n    let landArea = 0;\\n    let maxFromLeft = 0;\\n    let maxAreaFromLeft = 0;\\n    \\n    for (let h of height) {\\n        landArea += h;\\n        maxFromLeft = Math.max(maxFromLeft, h);\\n        maxAreaFromLeft += maxFromLeft;\\n    }\\n    \\n    let maxFromRight = 0;\\n    let maxAreaFromRight = 0;\\n    \\n    for (let i = height.length - 1; i >= 0; i--) {\\n        maxFromRight = Math.max(maxFromRight, height[i]);\\n        maxAreaFromRight += maxFromRight;\\n    }\\n    \\n    const boundingArea = height.length * maxFromLeft;\\n    const leftVoid = boundingArea - maxAreaFromLeft;\\n    const rightVoid = boundingArea - maxAreaFromRight;\\n    return boundingArea - leftVoid - rightVoid - landArea;\\n};\\n```\\nWe have a mountain with a bunch of filled ponds. We'll hike (and swim) over the highest parts and subtract from that area the same mountain during a nasty drought.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar trap = function(height) {\\n    let landArea = 0;\\n    let maxFromLeft = 0;\\n    let maxAreaFromLeft = 0;\\n    \\n    for (let h of height) {\\n        landArea += h;\\n        maxFromLeft = Math.max(maxFromLeft, h);\\n        maxAreaFromLeft += maxFromLeft;\\n    }\\n    \\n    let maxFromRight = 0;\\n    let maxAreaFromRight = 0;\\n    \\n    for (let i = height.length - 1; i >= 0; i--) {\\n        maxFromRight = Math.max(maxFromRight, height[i]);\\n        maxAreaFromRight += maxFromRight;\\n    }\\n    \\n    const boundingArea = height.length * maxFromLeft;\\n    const leftVoid = boundingArea - maxAreaFromLeft;\\n    const rightVoid = boundingArea - maxAreaFromRight;\\n    return boundingArea - leftVoid - rightVoid - landArea;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17559,
                "title": "my-solution-inspired-by-2-sum",
                "content": "This code looks like O(n) algorithm of the question 2 sum:    \\n\\n    int trap(int A[], int n) {\\n        if (n == 0) return 0;\\n        int l = 0, r = n - 1;\\n        int lv = A[l], rv = A[r];\\n        int total = A[l] + A[r], rainTotal = total;\\n        while (l != r)\\n        {\\n            if (A[l] < A[r])\\n            {\\n                l++;\\n                total += A[l];\\n                lv = max(lv, A[l]);\\n                rainTotal += lv;\\n            }\\n            else\\n            {\\n                r--;\\n                total += A[r];\\n                rv = max(rv, A[r]);\\n                rainTotal += rv;\\n            }\\n        }\\n        return rainTotal - total;\\n    }\\n\\n \\nlv is A[0...l]'s max value, rv is A[r...n-1]'s max value.\\n rainTotal is the total volume after raining, total is Sigma(A[0...n-1])",
                "solutionTags": [],
                "code": "This code looks like O(n) algorithm of the question 2 sum:    \\n\\n    int trap(int A[], int n) {\\n        if (n == 0) return 0;\\n        int l = 0, r = n - 1;\\n        int lv = A[l], rv = A[r];\\n        int total = A[l] + A[r], rainTotal = total;\\n        while (l != r)\\n        {\\n            if (A[l] < A[r])\\n            {\\n                l++;\\n                total += A[l];\\n                lv = max(lv, A[l]);\\n                rainTotal += lv;\\n            }\\n            else\\n            {\\n                r--;\\n                total += A[r];\\n                rv = max(rv, A[r]);\\n                rainTotal += rv;\\n            }\\n        }\\n        return rainTotal - total;\\n    }\\n\\n \\nlv is A[0...l]'s max value, rv is A[r...n-1]'s max value.\\n rainTotal is the total volume after raining, total is Sigma(A[0...n-1])",
                "codeTag": "Unknown"
            },
            {
                "id": 3335736,
                "title": "most-jugadu-solution-by-trippy-the-coder-no-dp-no-stack-just-simple-array-and-for-loop",
                "content": "# Intuition\\nAFTER SEEING IT YOU WILL THINK WHY IT IS LABELED AS HARD\\nHERE I AM PRESENTING JAVA CODE C++ CODE WILL ALSO BE SAME JUST USE VECTOR INSTEAD OF ARRAY\\n\\n# Approach\\nJUST SMILE AND SOLVE\\n\\n# Complexity\\nNOTHING COMPLEX HERE\\n\\n# HUMBLE REQUEST \\nPLEASE UPVOTE IF I HELPED YOU\\nTHANK YOU.\\nKEEP IT UP.\\n\\u2764\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] h) {\\n        int n=h.length;\\n        int sum=0;\\n        int l[]=new int[n];\\n        int r[]=new int[n];\\n        l[0]=h[0];\\n        for(int i=1;i<n;i++)\\n        l[i]=Math.max(h[i],l[i-1]);\\n         r[n-1]=h[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        r[i]=Math.max(h[i],r[i+1]);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=Math.min(l[i],r[i])-h[i];\\n        }\\n        return sum;\\n        // PLEASE UPVOTE\\n        // LOVE FOR YOU BY TRIPPY THE CODER  \\u2764\\uFE0F \\u2764\\uFE0F\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] h) {\\n        int n=h.length;\\n        int sum=0;\\n        int l[]=new int[n];\\n        int r[]=new int[n];\\n        l[0]=h[0];\\n        for(int i=1;i<n;i++)\\n        l[i]=Math.max(h[i],l[i-1]);\\n         r[n-1]=h[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        r[i]=Math.max(h[i],r[i+1]);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=Math.min(l[i],r[i])-h[i];\\n        }\\n        return sum;\\n        // PLEASE UPVOTE\\n        // LOVE FOR YOU BY TRIPPY THE CODER  \\u2764\\uFE0F \\u2764\\uFE0F\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315604,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Intuition\\nJust find right max and left max of a buildng and deduct the building height. Do it for all the buildings and return the sum.\\n\\n# Approach\\nFor every element calculating the most largest element to its left and right. now the water saved by one building will be min of the left largest and right largest minus the area the covered the that building that is height[i]. Suming it for every building we getting our desired answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void damn(vector<int> &h, vector<int> &right, vector<int> &left){\\n        int n = h.size();\\n        int mx = -1;\\n        for(int i=0; i<n; i++){\\n            left[i] = mx;\\n            mx = max(mx, h[i]);\\n        }\\n        mx = -1;\\n        for(int i=n-1; i>=0; i--){\\n            right[i] = mx;\\n            mx = max(mx, h[i]);\\n        }\\n    }\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> right(n), left(n);\\n        damn(height, right, left);\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(min(right[i], left[i])>height[i])\\n            ans += min(right[i], left[i]) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void damn(vector<int> &h, vector<int> &right, vector<int> &left){\\n        int n = h.size();\\n        int mx = -1;\\n        for(int i=0; i<n; i++){\\n            left[i] = mx;\\n            mx = max(mx, h[i]);\\n        }\\n        mx = -1;\\n        for(int i=n-1; i>=0; i--){\\n            right[i] = mx;\\n            mx = max(mx, h[i]);\\n        }\\n    }\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> right(n), left(n);\\n        damn(height, right, left);\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(min(right[i], left[i])>height[i])\\n            ans += min(right[i], left[i]) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192264,
                "title": "python-2-pointer-beats-100",
                "content": "```\\nclass Solution(object):\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        left = 0\\n        right = len(height) - 1\\n        left_max = right_max = area = 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                if height[left] < left_max:\\n                    area += left_max - height[left]\\n                else:\\n                    left_max = height[left]\\n                left += 1\\n            else:\\n                if height[right] < right_max:\\n                    area += right_max - height[right]\\n                else:\\n                    right_max = height[right]\\n                right -= 1\\n                \\n        return area",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        left = 0\\n        right = len(height) - 1\\n        left_max = right_max = area = 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                if height[left] < left_max:\\n                    area += left_max - height[left]\\n                else:\\n                    left_max = height[left]\\n                left += 1\\n            else:\\n                if height[right] < right_max:\\n                    area += right_max - height[right]\\n                else:\\n                    right_max = height[right]\\n                right -= 1\\n                \\n        return area",
                "codeTag": "Java"
            },
            {
                "id": 3443541,
                "title": "best-swift-solution-easy-to-understand",
                "content": "# Approach\\nThe approach to solving the problem involves using *two pointers*, one starting at the left end of the elevation map and the other starting at the right end. These pointers are moved inward until they meet in the middle. During this process, two variables, `leftMax` and `rightMax`, are used to keep track of the maximum height of bars seen so far from the left and right end respectively. \\n\\nAt each step, we compare the height of the bars pointed to by the two pointers. If the height of the bar pointed to by the left pointer is less than the height of the bar pointed to by the right pointer, we check if the height of the left bar is less than the `leftMax`. If it is less than `leftMax`, we calculate the difference between `leftMax` and the height of the bar pointed to by the left pointer and add it to `trappedWater`. If it is greater than or equal to `leftMax`, we update the `leftMax` variable. We then move the left pointer one step to the right. If the height of the bar pointed to by the left pointer is greater than or equal to the height of the bar pointed to by the right pointer, we follow a similar procedure, but with the right pointer, `rightMax`, and `trappedWater`.\\n\\nThe process continues until the two pointers meet in the middle. At this point, the `trappedWater` variable contains the amount of water that can be trapped by the elevation map.\\n\\n![trap.gif](https://assets.leetcode.com/users/images/676355cc-3ed5-4461-8388-665c6c221047_1682157652.2869074.gif)\\n\\n\\n# Complexity\\nTime complexity: $$O(n)$$, where $$n$$ is the length of the input array. This is because we traverse the array only once.\\n\\nSpace complexity: $$O(1)$$, as we only use a constant amount of extra space, independent of the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        var left = 0\\n        var right = height.count - 1\\n        var leftMax = height[left]\\n        var rightMax = height[right]\\n        var trappedWater = 0\\n\\n        while left < right {\\n            if height[left] < height[right] {\\n                leftMax = max(leftMax, height[left])\\n                trappedWater += leftMax - height[left]\\n                left += 1\\n            } else {\\n                rightMax = max(rightMax, height[right])\\n                trappedWater += rightMax - height[right]\\n                right -= 1\\n            }\\n        }\\n\\n        return trappedWater\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/500a3dc2-a214-44d2-8aa9-2d54fb49128a_1682155607.4010892.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        var left = 0\\n        var right = height.count - 1\\n        var leftMax = height[left]\\n        var rightMax = height[right]\\n        var trappedWater = 0\\n\\n        while left < right {\\n            if height[left] < height[right] {\\n                leftMax = max(leftMax, height[left])\\n                trappedWater += leftMax - height[left]\\n                left += 1\\n            } else {\\n                rightMax = max(rightMax, height[right])\\n                trappedWater += rightMax - height[right]\\n                right -= 1\\n            }\\n        }\\n\\n        return trappedWater\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589775,
                "title": "python-o-n-tc-o-n-sc-logic-explained",
                "content": "This problem can get you really worked up if you don\\'t catch an insight about how to solve it easily. My first ever attempt on it took me several hours and ended up with a super convoluted code.\\n\\nThe insight that will allow you to solve it easily is as follows:\\n1. A cell traps some water if there are cells to the right and to the left that have higher elevation\\n2. To find how much a cell is capable of trapping, you need to find a cell with the highest elevation to the left of it, and a cell with the highest elevation to the right of it. The minimum of those two elevation values, less the cell\\'s own elevation, is how much it will trap.\\n3. The overall result is just a sum of individual trapped water values for each cell\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        h_len = len(height)\\n        biggest_left: list[int] = [height[0]] * h_len\\n        biggest_right: list[int] = [height[-1]] * h_len\\n\\n        for i in range(1, h_len):\\n            biggest_left[i] = max(biggest_left[i-1], height[i])\\n            biggest_right[-i-1] = max(biggest_right[-i], height[-i-1])\\n        \\n        return sum(min(biggest_left[i], biggest_right[i]) - height[i] for i in range(h_len))\\n```\\n\\nTime complexity is **O(n)** where `n` is the size of the map, because we do three full traversals of the map: to find the biggest elevation to the left for each cell, the biggest elevation to the right, and then eventually the amount of water trapped.\\nSpace complexity is **O(n)** as well, because we allocate two extra lists of the size `n` to store biggest side elevation values.\\n\\nIf you have any questions, don\\'t hesitate to ask =)\\n**Also, please consider upvoting this post if you found it useful**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        h_len = len(height)\\n        biggest_left: list[int] = [height[0]] * h_len\\n        biggest_right: list[int] = [height[-1]] * h_len\\n\\n        for i in range(1, h_len):\\n            biggest_left[i] = max(biggest_left[i-1], height[i])\\n            biggest_right[-i-1] = max(biggest_right[-i], height[-i-1])\\n        \\n        return sum(min(biggest_left[i], biggest_right[i]) - height[i] for i in range(h_len))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757722,
                "title": "python-solution",
                "content": "Intuition: The sum of the water bar height is equal to the sum of the water bar height at each index. The water bar height at each index `i` is determined by the longest bar to the left of the index, `l`, and the longest bar to the right of the index, `r`. More specifically, the water bar height over `i` is given by `min(l, r) - height[i]` if `height[i] < min(l, r)`, and `0` otherwise. Therefore, an intuitive solution is to construct two arrays `left`, and `right`, where `left[i]` (`right[i]`) records the height of the longest bar to the left (right) of `i`. Finally, we just need to iterate over `height`, and sum over `min(l, r) - height[i]` at each index if `height[i] < min(l, r)`. The solution is O(n) in time, and O(n) and space.\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        if n < 3:\\n            return 0\\n        left = [0] * n\\n        right = [0] * n\\n        left[0] = height[0]\\n        right[n-1] = height[n-1]\\n        for i in range(1, n):\\n            left[i] = max(left[i-1], height[i])\\n        for i in range(n-2, -1, -1):\\n            right[i] = max(right[i+1], height[i])\\n        res = 0\\n        for i in range(1, n-1):\\n            if height[i] < left[i] and height[i] < right[i]:\\n                res += min(left[i], right[i]) - height[i]\\n        return res\\n```\\nThis solution can be further improved with the following two pointer approach, which is O(n) in time, and O(1) in space. The idea is that we can maintain two pointers `0 <= i < j <= n-1`, and two ints `l` and `r`, where `l` (`r`) records the height of the longest bar to the left (right) of `i` (`j`) or at `i` (`j`). While `i` < `j`, if `l` > `r`, we move `j` to the left by one step, and increment the total water bar height by `min(l, r) - height[j] = r - height[j]` if `height[j] < r`, or update `r` to `height[j]` if `height[j] > r`; Otherwise, we move `i` to the right by one step, and increment the total water bar height by `min(l, r) - height[i] = l - height[i]` if `height[i] < l`, or update `l` to `height[i]` if `height[i] > l`.\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        if n < 3:\\n            return 0\\n        l = height[0]\\n        r = height[n-1]\\n        i = 0\\n        j = n - 1  \\n        res = 0\\n        while i < j:\\n            if r < l:\\n                j -= 1\\n                if height[j] < r:\\n                    res += r - height[j]\\n                else:\\n                    r = height[j]\\n            else:\\n                i += 1\\n                if height[i] < l:\\n                    res += l - height[i] \\n                else:\\n                    l = height[i]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        if n < 3:\\n            return 0\\n        left = [0] * n\\n        right = [0] * n\\n        left[0] = height[0]\\n        right[n-1] = height[n-1]\\n        for i in range(1, n):\\n            left[i] = max(left[i-1], height[i])\\n        for i in range(n-2, -1, -1):\\n            right[i] = max(right[i+1], height[i])\\n        res = 0\\n        for i in range(1, n-1):\\n            if height[i] < left[i] and height[i] < right[i]:\\n                res += min(left[i], right[i]) - height[i]\\n        return res\\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        if n < 3:\\n            return 0\\n        l = height[0]\\n        r = height[n-1]\\n        i = 0\\n        j = n - 1  \\n        res = 0\\n        while i < j:\\n            if r < l:\\n                j -= 1\\n                if height[j] < r:\\n                    res += r - height[j]\\n                else:\\n                    r = height[j]\\n            else:\\n                i += 1\\n                if height[i] < l:\\n                    res += l - height[i] \\n                else:\\n                    l = height[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17478,
                "title": "explanatory-and-concise-java-implementation",
                "content": "Key idea is to keep a track of the highest walls on the left and the right and narrowing down from both sides. As we narrow down keeping adding to the result, the water trapped in unit width and smaller of each walls on each move.\\n\\n    public class Solution {\\n        public int trap(int[] height) {\\n            if(height == null || height.length == 0) return 0;\\n            int leftMax = 0, rightMax = 0, waterTrapped = 0, left = 0, right = height.length-1;\\n            while(left < right) {\\n                leftMax = leftMax > height[left] ? leftMax : height[left];\\n                rightMax = rightMax > height[right] ? rightMax : height[right];\\n                waterTrapped += leftMax < rightMax ? leftMax - height[left++] : rightMax - height[right--];\\n            }\\n            return waterTrapped;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int trap(int[] height) {\\n            if(height == null || height.length == 0) return 0;\\n            int leftMax = 0, rightMax = 0, waterTrapped = 0, left = 0, right = height.length-1;\\n            while(left < right) {\\n                leftMax = leftMax > height[left] ? leftMax : height[left];\\n                rightMax = rightMax > height[right] ? rightMax : height[right];\\n                waterTrapped += leftMax < rightMax ? leftMax - height[left++] : rightMax - height[right--];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 183237,
                "title": "another-javascript-solution-99-w-bonus-illustration",
                "content": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(elevs) {\\n  var trapped = 0;\\n  var left = 0;\\n  var leftHeight = 0;\\n  var right = elevs.length - 1;\\n  var rightHeight = 0;\\n  \\n  while (left <= right) {\\n    if (leftHeight <= rightHeight) {\\n      leftHeight = Math.max(leftHeight, elevs[left]);\\n      trapped += leftHeight - elevs[left];\\n      left++;\\n    } else {\\n      rightHeight = Math.max(rightHeight, elevs[right]);\\n      trapped += rightHeight - elevs[right];\\n      right--; \\n    }\\n  }\\n  \\n  return trapped;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/mmontag/image_1539935124.png)\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(elevs) {\\n  var trapped = 0;\\n  var left = 0;\\n  var leftHeight = 0;\\n  var right = elevs.length - 1;\\n  var rightHeight = 0;\\n  \\n  while (left <= right) {\\n    if (leftHeight <= rightHeight) {\\n      leftHeight = Math.max(leftHeight, elevs[left]);\\n      trapped += leftHeight - elevs[left];\\n      left++;\\n    } else {\\n      rightHeight = Math.max(rightHeight, elevs[right]);\\n      trapped += rightHeight - elevs[right];\\n      right--; \\n    }\\n  }\\n  \\n  return trapped;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249402,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Brute-Force Algorithm**\\n\\n- For each element in the array, we find the maximum level of water it can trap after the rain, which is equal to the minimum of maximum height of bars on both the sides minus its own height.\\n\\n**Algorithm:**\\n1. Initialize `result = 0`\\n2. Iterate the array from left to right:\\n  a. Initialize `maxLeft = 0` and `maxRight = 0`\\n  b. Iterate from the current element to the beginning of array updating: `maxLeft = Max(maxLeft, height[j])`\\n  c. Iterate from the current element to the end of array updating: `maxRight = Max(maxRight, height[j])`\\n  d. Add `Min(maxLeft, maxRight) - height[i]` to the result\\n\\n**Time complexity**: O(N<sup>2</sup>) - For each element of array, we iterate the left and right parts.\\n**Space complexity**: `O(1)`\\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int result = 0;\\n        int n = height.length;\\n\\n        for (int i = 1; i < n - 1; i++) {\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n            for (int j = i; j >= 0; j--) {                  //Search the left part for max bar size\\n                maxLeft = Math.max(maxLeft, height[j]);\\n            }\\n\\n            for (int j = i; j < n; j++) {                   //Search the right part for max bar size\\n                maxRight = Math.max(maxRight, height[j]);\\n            }\\n\\n            result += Math.min(maxLeft, maxRight) - height[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 2: Using Stack**\\n\\n- We can use `stack` to keep track of the bars that are bounded by longer bars and hence, may store water. Using the `stack`, we can do the calculations in only one iteration.\\n- We keep a `stack` and iterate over the array. We add the index of the bar to the `stack` if bar is smaller than or equal to the bar at top of `stack`, which means that the current bar is bounded by the previous bar in the `stack`. If we found a bar longer than that at the top, we are sure that the bar at the top of the `stack` is bounded by the current bar and a previous bar in the `stack`, hence, we can pop it and add resulting trapped water to the `result`.\\n\\n**Algorithm:**\\n- We use stack to store the indices of the bars.\\n- Iterate the array:\\n  - While stack is not empty and `height[current] > height[stack.peek()]`.\\n    - It means that the stack element can be popped. Pop the top element as `top`.\\n    - Find the distance between the current element and the element at top of stack, which is to be filled. `distance = current - stack.peek() - 1`\\n    - Find the bounded height `boundedHeight = Math.min(height[current], height[stack.peek()]) - height[top]`.\\n    - Add resulting trapped water to result. `result += distance * boundedHeight`\\n  - Push current index to top of the stack\\n  - Move current to the next position\\n\\n**Time complexity**: `O(N)` - Single iteration of `O(N)` in which each bar can be touched at most twice due to insertion and deletion.  Insertion and deletion from stack takes `O(1)` time.\\n**Space complexity**: `O(N)` - Stack can take up to `O(N)` space in case of stairs-like or flat structure. \\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int result = 0;\\n\\n        for (int current = 0; current < height.length; current++) {\\n            while (!stack.isEmpty() && height[current] > height[stack.peek()]) {\\n                int top = stack.pop();\\n\\n                if (!stack.isEmpty()) {\\n                    int distance = current - stack.peek() - 1;\\n                    int boundedHeight = Math.min(height[current], height[stack.peek()]) - height[top];\\n                    result += distance * boundedHeight;\\n                }\\n            }\\n            stack.push(current);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 3: Using Two Pointers**\\n\\n- Here we set two pointers `start` and `end` to the left and right end of height. Then we get the minimum height (`minHeight`) of these pointers since the level of the water cannot be higher than it. \\n- Then we move the two pointers towards the center. If the coming level is less than `minHeight`, then it will hold some water. Fill the water until we meet some \"barrier\" with height larger than `minHeight` and update `start` and `end` to repeat this process.\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int start = 0;\\n        int end = height.length - 1;\\n        int minHeight = 0;\\n        int result = 0;\\n\\n        while (start < end) {\\n            while (start < end && height[start] <= minHeight) {\\n                result += minHeight - height[start++];\\n            }\\n            while (start < end && height[end] <= minHeight) {\\n                result += minHeight - height[end--];\\n            }\\n            minHeight = Math.min(height[start], height[end]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int result = 0;\\n        int n = height.length;\\n\\n        for (int i = 1; i < n - 1; i++) {\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n            for (int j = i; j >= 0; j--) {                  //Search the left part for max bar size\\n                maxLeft = Math.max(maxLeft, height[j]);\\n            }\\n\\n            for (int j = i; j < n; j++) {                   //Search the right part for max bar size\\n                maxRight = Math.max(maxRight, height[j]);\\n            }\\n\\n            result += Math.min(maxLeft, maxRight) - height[i];\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int result = 0;\\n\\n        for (int current = 0; current < height.length; current++) {\\n            while (!stack.isEmpty() && height[current] > height[stack.peek()]) {\\n                int top = stack.pop();\\n\\n                if (!stack.isEmpty()) {\\n                    int distance = current - stack.peek() - 1;\\n                    int boundedHeight = Math.min(height[current], height[stack.peek()]) - height[top];\\n                    result += distance * boundedHeight;\\n                }\\n            }\\n            stack.push(current);\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int start = 0;\\n        int end = height.length - 1;\\n        int minHeight = 0;\\n        int result = 0;\\n\\n        while (start < end) {\\n            while (start < end && height[start] <= minHeight) {\\n                result += minHeight - height[start++];\\n            }\\n            while (start < end && height[end] <= minHeight) {\\n                result += minHeight - height[end--];\\n            }\\n            minHeight = Math.min(height[start], height[end]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245162,
                "title": "python-easy-to-understand-solution-one-pass-using-2-pointers",
                "content": "\\n```\\n    def trap(self, height):\\n        left = 0\\n        right = len(height) - 1\\n        left_max = right_max = water = 0\\n        while left <= right:\\n            if left_max <= right_max:\\n                left_max = max(left_max, height[left])\\n                water += left_max - height[left]\\n                left += 1\\n            else:\\n                right_max = max(right_max, height[right])\\n                water += right_max - height[right]\\n                right -= 1\\n                \\n        return water\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def trap(self, height):\\n        left = 0\\n        right = len(height) - 1\\n        left_max = right_max = water = 0\\n        while left <= right:\\n            if left_max <= right_max:\\n                left_max = max(left_max, height[left])\\n                water += left_max - height[left]\\n                left += 1\\n            else:\\n                right_max = max(right_max, height[right])\\n                water += right_max - height[right]\\n                right -= 1\\n                \\n        return water\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17507,
                "title": "java-with-stack-following-the-approach-similar-to-largest-rectangle-in-histogram",
                "content": "    public class Solution {\\n        public int trap(int[] height) {\\n            int len = height.length;\\n            int water = 0;\\n            Stack<Integer> stack = new Stack<>();\\n            for(int i = 0; i < len; i++) {\\n                if (stack.isEmpty() || height[stack.peek()] >= height[i]) {\\n                    stack.push(i);\\n                } else {\\n                    int tmp = stack.pop();\\n                    if (!stack.isEmpty()) {\\n                        water += (Math.min(height[stack.peek()],height[i])-height[tmp])*(i-stack.peek()-1);\\n                    }\\n                    i--;\\n                }\\n            }\\n            return water;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int trap(int[] height) {\\n            int len = height.length;\\n            int water = 0;\\n            Stack<Integer> stack = new Stack<>();\\n            for(int i = 0; i < len; i++) {\\n                if (stack.isEmpty() || height[stack.peek()] >= height[i]) {\\n                    stack.push(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 561281,
                "title": "python3-stack-faster-than-95-27",
                "content": "*Runtime: 44 ms, faster than 95.27% of Python3 online submissions for Trapping Rain Water.\\nMemory Usage: 14.4 MB, less than 6.98% of Python3 online submissions for Trapping Rain Water.*\\n\\n[Largest rectangle](https://www.hackerrank.com/challenges/largest-rectangle/problem) from **hackerrank** rings a bell to anyone? :D\\n\\n```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        stack = []\\n        water = 0\\n        for i, e in enumerate(height):\\n            # we need to see if we can form a container\\n            while stack and e >= stack[-1][0]:\\n                popped, _ = stack.pop()\\n                # is it a container though? we have a left border?\\n                if stack:\\n                    left_border, j = stack[-1]\\n                    # we compute the water\\n                    water += min(left_border-popped, e-popped)*(i-j-1)\\n            stack.append((e,i))\\n        return water\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        stack = []\\n        water = 0\\n        for i, e in enumerate(height):\\n            # we need to see if we can form a container\\n            while stack and e >= stack[-1][0]:\\n                popped, _ = stack.pop()\\n                # is it a container though? we have a left border?\\n                if stack:\\n                    left_border, j = stack[-1]\\n                    # we compute the water\\n                    water += min(left_border-popped, e-popped)*(i-j-1)\\n            stack.append((e,i))\\n        return water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358874,
                "title": "java-brute-force-solution-easy-to-understand",
                "content": "Inspired by this video - https://www.youtube.com/watch?v=HmBbcDiJapY\\n\\n```\\nclass Solution {\\n    public int trap(int[] A) {\\n        int volume = 0;\\n        int left = 0, right = 0;\\n        for(int i = 0; i < A.length; i++) {\\n            left = findTallest(0, i-1, A);\\n            right = findTallest(i+1, A.length-1,A);\\n            int vol = Math.min(left,right) - A[i];\\n            if(vol >= 0) {\\n               volume = volume + vol; \\n            }\\n        }\\n        return volume;\\n    }\\n    \\n    public int findTallest(int begin, int end, int[]A) {\\n        int tallest = 0;\\n        for(int i = begin; i <=end; i++) {\\n            if(tallest < A[i]) {\\n                tallest = A[i];\\n            }\\n        }\\n        return tallest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] A) {\\n        int volume = 0;\\n        int left = 0, right = 0;\\n        for(int i = 0; i < A.length; i++) {\\n            left = findTallest(0, i-1, A);\\n            right = findTallest(i+1, A.length-1,A);\\n            int vol = Math.min(left,right) - A[i];\\n            if(vol >= 0) {\\n               volume = volume + vol; \\n            }\\n        }\\n        return volume;\\n    }\\n    \\n    public int findTallest(int begin, int end, int[]A) {\\n        int tallest = 0;\\n        for(int i = begin; i <=end; i++) {\\n            if(tallest < A[i]) {\\n                tallest = A[i];\\n            }\\n        }\\n        return tallest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272443,
                "title": "java-5ms-stack-solution-with-detailed-explanation",
                "content": "Apparently, we need **two nonadjacent bars** to save water, and there must be at least one **valley bar** between them. For bar[i], if we can find bar[j] and bar[k] where bar[j] > bar[i], bar[k] > bar[i] and j < i < k, then bar[i] is a valley bar. For example, if we have a bar sequence ```[5, 3, 2, 4]``` then 2 and 3 are both valley bars. \\nTherefore, the key point of this problem is finding all the valley bars. Here, we use a **monotone stack** to help use finding these valley bars. \\nAt first, we ignore the front bars whose length is zero. While bar[i] (current bar) is larger than the top element of the stack, then the top element is popped out of the stack as a candidate valley bar. Then we judge whether the stack is empty. If the stack is empty, the popped bar is not a valley bar since we only have right holder (current bar).  If the stack is not empty, then the top element, the candidate valley bar and current bar form a valid water holder. The height of the holder is ```(Math.min(height[i], height[stack.peek()]) - current)``` and the width is ```i - stack.peek() - 1```, the holder can hold ```width * height```  water. \\n```\\npublic int trap(int[] height) {\\n\\tStack<Integer> stack = new Stack<Integer>();\\n\\tint begin = 0, result = 0;\\n\\twhile( begin < height.length && height[begin] == 0 ) // ignore the first n bars whose length is zero\\n\\t\\tbegin++;\\n\\tfor(int i = begin; i < height.length; i++) {\\n\\t\\twhile( !stack.isEmpty() && height[i] > height[stack.peek()] ) {\\n\\t\\t\\tint valley = height[stack.pop()]; // candidate valley bar\\n\\t\\t\\tif( !stack.isEmpty() ) // If the stack is not empty, then the candidate valley bar is a real valley bar\\n\\t\\t\\t\\tresult += (Math.min(height[i], height[stack.peek()]) - valley) * (i - stack.peek() - 1);\\n\\t\\t}\\n\\t\\tstack.push(i);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```[5, 3, 2, 4]```\n```(Math.min(height[i], height[stack.peek()]) - current)```\n```i - stack.peek() - 1```\n```width * height```\n```\\npublic int trap(int[] height) {\\n\\tStack<Integer> stack = new Stack<Integer>();\\n\\tint begin = 0, result = 0;\\n\\twhile( begin < height.length && height[begin] == 0 ) // ignore the first n bars whose length is zero\\n\\t\\tbegin++;\\n\\tfor(int i = begin; i < height.length; i++) {\\n\\t\\twhile( !stack.isEmpty() && height[i] > height[stack.peek()] ) {\\n\\t\\t\\tint valley = height[stack.pop()]; // candidate valley bar\\n\\t\\t\\tif( !stack.isEmpty() ) // If the stack is not empty, then the candidate valley bar is a real valley bar\\n\\t\\t\\t\\tresult += (Math.min(height[i], height[stack.peek()]) - valley) * (i - stack.peek() - 1);\\n\\t\\t}\\n\\t\\tstack.push(i);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17555,
                "title": "o-n-solution-based-on-java",
                "content": "    public int trap(int[] A) {\\n\\n        int left = 0, right = A.length-1;\\n\\n        int level = 0, result = 0;\\n\\n        while (left<right){\\n\\n            level = Math.max(Math.min(A[left], A[right]), level);\\n\\n            if (A[left]<=A[right]){\\n                result += level-A[left];\\n                left++;\\n            }\\n            else{\\n                result += level-A[right];\\n                right--;\\n            }\\n        }\\n\\n        return result;\\n\\n    }",
                "solutionTags": [],
                "code": "    public int trap(int[] A) {\\n\\n        int left = 0, right = A.length-1;\\n\\n        int level = 0, result = 0;\\n\\n        while (left<right){\\n\\n            level = Math.max(Math.min(A[left], A[right]), level);\\n\\n            if (A[left]<=A[right]){\\n                result += level-A[left];\\n                left++;\\n            }\\n            else{\\n                result += level-A[right];\\n                right--;\\n            }\\n        }\\n\\n        return result;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2590012,
                "title": "c-brute-precomputation-two-pointers",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Solution: 1**\\n\\n### **Intuition:** **Brute Force** : \\nWe basically need to find the **maximum** height of the bar from the **left** end upto an index` i` in the array **left_max**.\\nSimilarly find the **maximum** height of the bar from the **right** end upto an index `i` in the array **right_max**. Iterate over the **height** array and update **ans**\\n\\n**Approach:**\\n* For `each` element, find the `max` on the `left` and `right` and then, \\n* take the `min` of the `two` and `subtract` the `current` `height` from it. \\n* This will give the `water` that can be `stored` at that `index`.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int ans = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            int left_max = 0, right_max = 0;\\n            for (int j = i; j >= 0; j--) {\\n                left_max = max(left_max, height[j]);\\n            }\\n            for (int j = i; j < n; j++) {\\n                right_max = max(right_max, height[j]);\\n            }\\n            ans += min(left_max, right_max) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n^2)** , where `n` is the number of bars in the histogram.\\n**Space Complexity:** **O(1)**\\n****\\n**Solution: 2**\\n\\n### **Intuition:** **Precomputation**:\\nWe can **precompute** the **maximum** height of the bar to the **left** and **right** of each bar in `linear time`.\\n\\n**Approach:**\\n* We will now **precompute** the **maximum** height of the bar to the **left** and **right** of the current bar.\\n* Store the **maximum** height of the bar to the **left** and **right** of the current bar in **two** arrays.\\n* Then iterate over the **array** and calculate the **amount** of water that can be stored in the **current** bar.\\n* Finally add the **amount** of water that can be stored in the current bar to the total amount of water that can be stored in the array and return the total amount of water that can be stored in the array.\\n\\n\\n**C++:-**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n\\t\\t\\tint n = height.size();\\n\\t\\t\\tif(n == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint left[n];\\n\\t\\t\\tint right[n];\\n\\t\\t\\tleft[0] = height[0];\\n\\t\\t\\tfor(int i = 1; i < n; i++) {\\n\\t\\t\\t\\tleft[i] = max(left[i - 1], height[i]);\\n\\t\\t\\t}\\n\\t\\t\\tright[n - 1] = height[n - 1];\\n\\t\\t\\tfor(int i = n - 2; i >= 0; i--) {\\n\\t\\t\\t\\tright[i] = max(right[i + 1], height[i]);\\n\\t\\t\\t}\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\ttotal += min(left[i], right[i]) - height[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t}\\n};\\n```\\n****\\n**Time Complexity:** **O(n)**, where `n` is the number of bars in the histogram.\\n**Space Complexity:** **O(n)**\\n****\\n\\n**Solution: 3**\\n\\n### **Intuition:** **Two Pointers**:\\nWe need a minimum of left and right. if left is smaller, we can trap water, if right is smaller, we can trap water, if left and right are equal we can\\'t trap water.\\n\\n**Approach:**\\n* Find the **max** height of the **left** and **right**\\n* If the **left** is `smaller` than the **right**, then the water trapped depends on the **left**\\n* If the **right** is `smaller` than the **left**, then the water trapped depends on the **right**\\n* If the **left** is equal to the **right**, then the water trapped depends on **either**\\n* Move the **pointer** that is **smaller** than the other\\n* Repeat until the **two** **pointers** meet.\\n\\n\\n**C++:-**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n - 1;\\n        int left_max = 0, right_max = 0;\\n        int water_stored = 0;\\n\\n        while (left < right) {\\n            if (height[left] < height[right]) {\\n                if (height[left] >= left_max) {\\n                    left_max = height[left];\\n                } else {\\n                    water_stored += left_max - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] >= right_max) {\\n                    right_max = height[right];\\n                } else {\\n                    water_stored += right_max - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return water_stored;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n)**, where `n` is the number of bars in the histogram.\\n**Space Complexity:** **O(1)**\\n****",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int ans = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            int left_max = 0, right_max = 0;\\n            for (int j = i; j >= 0; j--) {\\n                left_max = max(left_max, height[j]);\\n            }\\n            for (int j = i; j < n; j++) {\\n                right_max = max(right_max, height[j]);\\n            }\\n            ans += min(left_max, right_max) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n\\t\\t\\tint n = height.size();\\n\\t\\t\\tif(n == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint left[n];\\n\\t\\t\\tint right[n];\\n\\t\\t\\tleft[0] = height[0];\\n\\t\\t\\tfor(int i = 1; i < n; i++) {\\n\\t\\t\\t\\tleft[i] = max(left[i - 1], height[i]);\\n\\t\\t\\t}\\n\\t\\t\\tright[n - 1] = height[n - 1];\\n\\t\\t\\tfor(int i = n - 2; i >= 0; i--) {\\n\\t\\t\\t\\tright[i] = max(right[i + 1], height[i]);\\n\\t\\t\\t}\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\ttotal += min(left[i], right[i]) - height[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n - 1;\\n        int left_max = 0, right_max = 0;\\n        int water_stored = 0;\\n\\n        while (left < right) {\\n            if (height[left] < height[right]) {\\n                if (height[left] >= left_max) {\\n                    left_max = height[left];\\n                } else {\\n                    water_stored += left_max - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] >= right_max) {\\n                    right_max = height[right];\\n                } else {\\n                    water_stored += right_max - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return water_stored;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251534,
                "title": "my-python3-solution-short",
                "content": "```\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        h1 = 0\\n        h2 = 0\\n        for i in range(len(height)):\\n            h1 = max(h1,height[i])\\n            h2 = max(h2,height[-i-1])\\n            ans = ans + h1 + h2 -height[i]\\n        return  ans - len(height)*h1\\n```",
                "solutionTags": [],
                "code": "```\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        h1 = 0\\n        h2 = 0\\n        for i in range(len(height)):\\n            h1 = max(h1,height[i])\\n            h2 = max(h2,height[-i-1])\\n            ans = ans + h1 + h2 -height[i]\\n        return  ans - len(height)*h1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17477,
                "title": "c-time-o-n-space-o-1-no-stack-no-two-pointers",
                "content": "    class Solution {\\n    public:\\n    int trap(vector<int>& height) {\\n        int sz=height.size(), highest=0, water=0;\\n        //from left to right, only consider the trap's left elevation\\n        for(int i=0; i<sz; i++){\\n            if(height[i]<highest) water+=highest-height[i];\\n            highest=max(highest, height[i]);\\n        }\\n        \\n        int prehighest=highest;\\n        highest=0;\\n        //from right to left, only consider the trap's right elevation, subtract the surplus water\\n        for(int i=sz-1; i>=0; i--){\\n            highest=max(height[i], highest);\\n            if(highest<prehighest) water-=prehighest-highest;\\n        }\\n        return water;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int trap(vector<int>& height) {\\n        int sz=height.size(), highest=0, water=0;\\n        //from left to right, only consider the trap's left elevation\\n        for(int i=0; i<sz; i++){\\n            if(height[i]<highest) water+=highest-height[i];\\n            highest=max(highest, height[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1905817,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        func subtrap(_ height: [Int], _ i: Int, _ j: Int) -> Int {\\n            var max = 0\\n            var iMax = i\\n            var jMax = j\\n            var iTmp = i\\n            var jTmp = j\\n\\n            while iTmp < jTmp {\\n                let area = (jTmp - iTmp - 1) * min(height[iTmp], height[jTmp])\\n                if area > max {\\n                    max = area\\n                    iMax = iTmp\\n                    jMax = jTmp\\n                }\\n                if height[iTmp] < height[jTmp] {\\n                    iTmp += 1\\n                } else {\\n                    jTmp -= 1\\n                }\\n            }\\n\\n            if max == 0 {\\n                return 0\\n            } else {\\n                for k in iMax+1..<jMax {\\n                    let h = min(height[iMax], height[jMax])\\n                    max -= (height[k] > h ? h : height[k])\\n                }\\n                var extra = -1\\n                var tmpHeight = 0\\n                for k in iMax+1...jMax-1 {\\n                    if height[k] > min(height[iMax], height[jMax]) && height[k] > tmpHeight {\\n                        tmpHeight = height[k]\\n                        extra = k\\n                    }\\n                }\\n                if extra >= 0 { max = subtrap(height, iMax, extra) + subtrap(height, extra, jMax) }\\n                return max + subtrap(height, i, iMax) + subtrap(height, jMax, j)\\n            }\\n        }\\n        return subtrap(height, 0, height.count - 1)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        func subtrap(_ height: [Int], _ i: Int, _ j: Int) -> Int {\\n            var max = 0\\n            var iMax = i\\n            var jMax = j\\n            var iTmp = i\\n            var jTmp = j\\n\\n            while iTmp < jTmp {\\n                let area = (jTmp - iTmp - 1) * min(height[iTmp], height[jTmp])\\n                if area > max {\\n                    max = area\\n                    iMax = iTmp\\n                    jMax = jTmp\\n                }\\n                if height[iTmp] < height[jTmp] {\\n                    iTmp += 1\\n                } else {\\n                    jTmp -= 1\\n                }\\n            }\\n\\n            if max == 0 {\\n                return 0\\n            } else {\\n                for k in iMax+1..<jMax {\\n                    let h = min(height[iMax], height[jMax])\\n                    max -= (height[k] > h ? h : height[k])\\n                }\\n                var extra = -1\\n                var tmpHeight = 0\\n                for k in iMax+1...jMax-1 {\\n                    if height[k] > min(height[iMax], height[jMax]) && height[k] > tmpHeight {\\n                        tmpHeight = height[k]\\n                        extra = k\\n                    }\\n                }\\n                if extra >= 0 { max = subtrap(height, iMax, extra) + subtrap(height, extra, jMax) }\\n                return max + subtrap(height, i, iMax) + subtrap(height, jMax, j)\\n            }\\n        }\\n        return subtrap(height, 0, height.count - 1)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373785,
                "title": "trapping-rain-water-basic-implementation-w-explanation",
                "content": "<hr>\\n\\n\\u274C **(Brute-Force) Now TLE**\\n# **METHOD 1:**\\n**Approach:**\\nThe idea is to traverse every array element and find the highest bars on the left and right sides. Take the smaller of two heights. The difference between the smaller height and height of the current element is the amount of water that can be stored in this array element.\\n\\n**Algorithm:**\\n* Traverse the array from start to end.\\n* For every element, traverse the array from start to that index and find the maximum height (a) and traverse the array from the current index to end, and find the maximum height (b).\\n* The amount of water that will be stored in this column is min(a,b) \\u2013 array[i], add this value to the total amount of water stored\\n* Print the total amount of water stored.\\n\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n        int n = arr.size() ;\\n        int res = 0;\\n        // For every element of the array\\n        for (int i = 1; i < n-1; i++) \\n        {\\n            // Find the maximum element on its left\\n            int left = arr[i] ;\\n            for (int j=0; j<i; j++)\\n               left = max(left, arr[j]);\\n\\n            // Find the maximum element on its right  \\n            int right = arr[i];\\n            for (int j=i+1; j<n; j++)\\n               right = max(right, arr[j]);\\n\\n           // Update the maximum water   \\n           res += (min(left, right) - arr[i]);  \\n        }\\n        return res;\\n    }\\n};\\n```\\n**TIME COMPLEXITY: O(n^2)\\nSPACE COMPLEXITY: O(1)**\\n\\n<hr>\\n\\n\\u2714\\uFE0F **Precomputing Maximum on left and right**\\n# **METHOD 2:**\\n\\n**Approach**\\n* `a[i]` bar can only store water if there is a higher bar on its left as well as right.\\n* In this, we store maximum heights of bars in a new vector `lheight` and `rheight`\\n* Maximum water that could be stored in the `a[i]`th bar is the minimum height of the highest bar on its left and right i.e. `min(lheight[i] , rheight[i])`\\n* If `a[i] > min(lheight[i] , rheight[i])` then the water stored is ` min(lheight[i] , rheight[i]) - a[i]`\\n\\n**SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int ans = 0 , n = a.size() ;\\n        vector<int> lheight(n) , rheight(n) ;\\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            lheight[i] = max(lheight[i - 1] , a[i - 1]) ;\\n        }\\n        for(int i = n - 2 ; i >= 0 ; i--)\\n        {\\n            rheight[i] = max(rheight[i + 1] , a[i + 1]) ;\\n        }\\n        for(int i = 0 ; i < n  ; i++)\\n        {\\n            int lev = min(lheight[i] , rheight[i]) ;\\n            if(lev > a[i])\\n            {\\n                ans += lev - a[i] ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n        int n = arr.size() ;\\n        int res = 0;\\n        // For every element of the array\\n        for (int i = 1; i < n-1; i++) \\n        {\\n            // Find the maximum element on its left\\n            int left = arr[i] ;\\n            for (int j=0; j<i; j++)\\n               left = max(left, arr[j]);\\n\\n            // Find the maximum element on its right  \\n            int right = arr[i];\\n            for (int j=i+1; j<n; j++)\\n               right = max(right, arr[j]);\\n\\n           // Update the maximum water   \\n           res += (min(left, right) - arr[i]);  \\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int ans = 0 , n = a.size() ;\\n        vector<int> lheight(n) , rheight(n) ;\\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            lheight[i] = max(lheight[i - 1] , a[i - 1]) ;\\n        }\\n        for(int i = n - 2 ; i >= 0 ; i--)\\n        {\\n            rheight[i] = max(rheight[i + 1] , a[i + 1]) ;\\n        }\\n        for(int i = 0 ; i < n  ; i++)\\n        {\\n            int lev = min(lheight[i] , rheight[i]) ;\\n            if(lev > a[i])\\n            {\\n                ans += lev - a[i] ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206322,
                "title": "python-solution-using-stack-dp-two-pointers",
                "content": "1. Stack based solution: Time & Space- O(n) \\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        stack = []\\n        \\n        for i in range(n):\\n            l = len(stack)\\n            if l == 0 or height[i] < height[stack[l - 1]]:\\n                stack.append(i)\\n            else:\\n                while(l > 0 and height[stack[l - 1]] <= height[i]):\\n                    ht = height[stack.pop()]\\n                    l = l - 1\\n                    ans = ans + (0 if l == 0 else (min(height[i],height[stack[l - 1]]) - ht) * (i - stack[l - 1] - 1))\\n                stack.append(i)\\n        return ans\\n```\\n\\n2. DP based solution: Time & Space- O(n) \\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        if n == 0:\\n            return ans\\n        l_max, r_max = [0] * n, [0] * n\\n\\n        mx = height[0]\\n        for i in range(1, n):\\n            l_max[i] = mx\\n            mx = max(mx, height[i])\\n        mx = height[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            r_max[i] = mx\\n            mx = max(mx, height[i])\\n        for i in range(n):\\n            area = min(l_max[i], r_max[i]) - height[i]\\n            ans = ans + (area if area > 0 else 0)\\n        return ans\\n```\\n3. Two-pointers based solution: Time- O(n) & Space- O(1)  \\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        left, right = 0, n - 1\\n        l_max, r_max = 0, 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                l_max = max(l_max,height[left])\\n                ans = ans + l_max - height[left]\\n                left = left + 1\\n            else:\\n                r_max = max(r_max,height[right])\\n                ans = ans + r_max - height[right]\\n                right = right - 1\\n        return ans\\n```\\n**PS: Please upvote if you liked the solution**",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        stack = []\\n        \\n        for i in range(n):\\n            l = len(stack)\\n            if l == 0 or height[i] < height[stack[l - 1]]:\\n                stack.append(i)\\n            else:\\n                while(l > 0 and height[stack[l - 1]] <= height[i]):\\n                    ht = height[stack.pop()]\\n                    l = l - 1\\n                    ans = ans + (0 if l == 0 else (min(height[i],height[stack[l - 1]]) - ht) * (i - stack[l - 1] - 1))\\n                stack.append(i)\\n        return ans\\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        if n == 0:\\n            return ans\\n        l_max, r_max = [0] * n, [0] * n\\n\\n        mx = height[0]\\n        for i in range(1, n):\\n            l_max[i] = mx\\n            mx = max(mx, height[i])\\n        mx = height[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            r_max[i] = mx\\n            mx = max(mx, height[i])\\n        for i in range(n):\\n            area = min(l_max[i], r_max[i]) - height[i]\\n            ans = ans + (area if area > 0 else 0)\\n        return ans\\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        left, right = 0, n - 1\\n        l_max, r_max = 0, 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                l_max = max(l_max,height[left])\\n                ans = ans + l_max - height[left]\\n                left = left + 1\\n            else:\\n                r_max = max(r_max,height[right])\\n                ans = ans + r_max - height[right]\\n                right = right - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346640,
                "title": "pythonically-trapping-rain-water-with-common-sense-dynamically",
                "content": "The idea is to know what the max height is, to the left and right of every index. Think about it- at any given index, there can only be trapped rain water above it if the min(max_height_to_the_left, max_height_to_the_right) is bigger than the height at this particular index. \\nSo there are 3 things to do.\\n1. For every index, find max_height_to_the_left. Store in a \"maxleft\" array.\\n2. For every index, find max_height_to_the_right. Store in a \"maxright\" array.\\n3. Add min(max_height_to_the_left, max_height_to_the_right) - height(idx) for every idx to a sum. Return this sum. \\n\\nCode:\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        left=0\\n        maxleft=height[:]\\n        for i in range(len(height)):\\n            maxleft[i]=left\\n            if height[i]>left:\\n                left=height[i]\\n        right=0\\n        maxright=height[:]\\n        for i in range(len(height)-1,-1,-1):\\n            maxright[i]=right\\n            if height[i]>right:\\n                right=height[i]\\n        res=0\\n        for ind in range(len(height)):\\n            if min(maxleft[ind],maxright[ind])>height[ind]:\\n                res+=min(maxleft[ind],maxright[ind])-height[ind]\\n        return res\\n```\\n\\nTime complexity: O(N). Space:O(N). Since this solution is better than looping through the left and right of every index each time you see an index, we have improved from O(N^2) to O(N) by not unnecessarily recomputing the maxes. Hence why this can be called dynamic programming. \\n\\nVoila ;) As always, correct me if I\\'ve made a mistake.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        left=0\\n        maxleft=height[:]\\n        for i in range(len(height)):\\n            maxleft[i]=left\\n            if height[i]>left:\\n                left=height[i]\\n        right=0\\n        maxright=height[:]\\n        for i in range(len(height)-1,-1,-1):\\n            maxright[i]=right\\n            if height[i]>right:\\n                right=height[i]\\n        res=0\\n        for ind in range(len(height)):\\n            if min(maxleft[ind],maxright[ind])>height[ind]:\\n                res+=min(maxleft[ind],maxright[ind])-height[ind]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393796,
                "title": "c-stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& v) {\\n     stack<int>s;\\n     s.push(v[0]);\\n     int mx=v[0];\\n     int ans=0;\\n     for(int i=1;i<v.size();i++){\\n         if(v[i]>mx){\\n              while(s.size()){\\n                  int f=s.top();\\n                  s.pop();\\n                 ans+=mx-f;\\n              } \\n              mx=v[i];\\n         }\\n         s.push(v[i]);\\n     }\\n     mx=s.top();\\n     while(s.size()){\\n         int t=s.top();\\n         s.pop();\\n         if(t>mx)mx=t;\\n         else ans+=mx-t;\\n     }\\n     return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/d24e16e8-366f-4ef0-b142-d4508eeccba9_1680955919.3825984.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& v) {\\n     stack<int>s;\\n     s.push(v[0]);\\n     int mx=v[0];\\n     int ans=0;\\n     for(int i=1;i<v.size();i++){\\n         if(v[i]>mx){\\n              while(s.size()){\\n                  int f=s.top();\\n                  s.pop();\\n                 ans+=mx-f;\\n              } \\n              mx=v[i];\\n         }\\n         s.push(v[i]);\\n     }\\n     mx=s.top();\\n     while(s.size()){\\n         int t=s.top();\\n         s.pop();\\n         if(t>mx)mx=t;\\n         else ans+=mx-t;\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060463,
                "title": "easy-c-solution-o-n-two-pointer-why-not-brute-force-18ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere, the problem says that how many units of rain water we can trap. in order to trap/ collect rain water, we need to make a container of some width.Each index of vector depicts the height of the block/bar.\\nThe maximum water stored is equal to the minimun height of one of the two blocks taken together. here comes the idea of brute force which takes O(n^2) time complexity and O(1) space complexity. this approach is quite slow. we can use two pointer approach and stack approach. But using two pointer approach is easy. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo calculate the number of units of water stored. we first take two array of size equal to given vector. first array is (a) which contains the maximun height of the  block from the left till ith index. another array is (b) which contains maximun height of the block from right i.e. i to size-1.\\n\\nint a[n], int b[n];\\nfor vector, Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\\na= {0,1,1,2,2,2,2,3,3,3,3,3};\\nb= {3,3,3,3,3,3,3,3,2,2,2,1}\\nunit of water collected at index i is equal to minimun of a,b - nums[i] i.e.\\nsum= sum + (min(a[i], b[i])) - nums[i];\\n\\nwe did this because water is stored upto minimum height tower, if there is block of height nums[i], then we have to subtract it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)+ O(n)+ O(n)= O(3n)= O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(2n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& nums) {\\n        int n= nums.size();\\n        int a[n];\\n        int b[n];\\n\\n        a[0]= nums[0];\\n        b[n-1]= nums[n-1];\\n\\n        //left\\n        for(int i=1; i<n; i++)\\n        {\\n            a[i]= max(a[i-1], nums[i]);\\n        }\\n        // right \\n        for(int i= (n-2); i>=0; i--)\\n        {\\n            b[i]= max(b[i+1], nums[i]);\\n        }\\n\\n        // final answer\\n        int sum=0;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            sum= sum + (min(a[i], b[i])) - nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& nums) {\\n        int n= nums.size();\\n        int a[n];\\n        int b[n];\\n\\n        a[0]= nums[0];\\n        b[n-1]= nums[n-1];\\n\\n        //left\\n        for(int i=1; i<n; i++)\\n        {\\n            a[i]= max(a[i-1], nums[i]);\\n        }\\n        // right \\n        for(int i= (n-2); i>=0; i--)\\n        {\\n            b[i]= max(b[i+1], nums[i]);\\n        }\\n\\n        // final answer\\n        int sum=0;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            sum= sum + (min(a[i], b[i])) - nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592519,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**\\n\\n***Watch this video for the better explanation of the code.***\\n\\n## **Since thumbnail is not working, click on the link directly.**\\nhttps://www.youtube.com/watch?v=wa-o0Y63Xu0\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int leftend =0;\\n        int rightend = height.size()-1;\\n        int ans = 0;\\n        int maxleft = height[leftend];\\n        int maxright = height[rightend];\\n        while(leftend<=rightend){\\n            \\n            maxleft = max(maxleft,height[leftend]);\\n            maxright = max(maxright,height[rightend]);\\n            \\n            ans += min(maxleft,maxright)-min(height[leftend],height[rightend]);\\n            \\n            if(height[leftend]<height[rightend])leftend++;\\n            else{\\n                rightend--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int leftend =0;\\n        int rightend = height.size()-1;\\n        int ans = 0;\\n        int maxleft = height[leftend];\\n        int maxright = height[rightend];\\n        while(leftend<=rightend){\\n            \\n            maxleft = max(maxleft,height[leftend]);\\n            maxright = max(maxright,height[rightend]);\\n            \\n            ans += min(maxleft,maxright)-min(height[leftend],height[rightend]);\\n            \\n            if(height[leftend]<height[rightend])leftend++;\\n            else{\\n                rightend--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071384,
                "title": "python-how-to-approach-this-problem",
                "content": "This problem is difficult. Here is how I unpack it.\\n\\n## Start with the brute force idea.\\n\\nFor each column, we want to:\\n* Find the maximum height to the left (`m_left`)\\n* Find the maximum height to the right (`m_right`)\\n\\nAfter doing this, we will know that the water trapped for that column will be `min(m_left, m_right) - height[i]` (assuming it is greater than zero).\\n\\n```python\\ndef trap(height):\\n    result = 0\\n    for idx, i in enumerate(height):\\n        left, right = max(height[:idx]+[0]), max(height[idx+1:]+[0])\\n        score = min(left, right)\\n        result += max(score-i, 0)\\n    return result\\n```\\n\\nIf this doesn\\'t make sense, there\\'s no point in diving deeper into the solution yet. Re-read this again, or look at other brute-force solutions.\\n\\n## Use extra space to improve run time.\\n\\nNow, looking at the below code, its clear which line is expensive:\\n\\n```python\\ndef trap(height):\\n    result = 0\\n    for idx, i in enumerate(height):\\n        left, right = max(height[:idx]+[0]), max(height[idx+1:]+[0]) # <-- THIS GUY!\\n        score = min(left, right)\\n        result += max(score-i, 0)\\n    return result\\n```\\n\\nThis line makes our solution have a run time of `O(n^2)`.\\n\\nFrom here, we can do an easy optimization\\u2014we can use extra space to precompute the max from the left and right sides. Check this out:\\n\\n```python\\n# Left max\\nleft_max = list(height)\\nfor i in range(1, len(height)):\\n\\tleft_max[i] = max(left_max[i-1], left_max[i])\\n\\n# Right max\\nright_max = list(height)\\nfor i in reversed(range(len(height)-1)):\\n\\tright_max[i] = max(right_max[i], right_max[i+1])\\n```\\n\\nThe codes a bit ugly, but hopefully the idea is clear.\\n* We iterate from left to right, keeping track of the largest element we\\'ve seen.\\n* We do the same from right to left\\n* We store the results in `left_max` and `right_max`.\\n\\nNow, if we look at our updated solution, **it looks basically the same**! The only difference is we are using extra space to have constant run time.\\n\\n```python\\ndef trap(height):\\n\\n\\t# Left max\\n\\tleft_max = list(height)\\n\\tfor i in range(1, len(height)):\\n\\t\\tleft_max[i] = max(left_max[i-1], left_max[i])            \\n\\n\\t# Right max\\n\\tright_max = list(height)\\n\\tfor i in reversed(range(len(height)-1)):\\n\\t\\tright_max[i] = max(right_max[i], right_max[i+1])\\n\\n\\t# Calculate result\\n\\tresult = 0        \\n\\tfor idx, i in enumerate(height):\\n\\t\\tscore = min(left_max[idx], right_max[idx]) # <-- Constant time O(1) computation\\n\\t\\tresult += max(score-i, 0)\\n\\treturn result\\n```\\n\\n## Optimize for the final solution\\n\\nNow, the last jump is to the solution that uses two pointers.\\n\\nIMO, this mental jump is by far the hardest, and does not come as easy as the first two steps. \\n\\nHere is how I thought about it:\\n\\n* If we go from left to right, we can easily keep track of the current largest `height[i]` we\\'ve seen.\\n\\t* If a height we encounter is larger or equal than the current max height we\\'ve seen, we know the water trapped is zero since the heights to the left are smaller\\n\\t* If a height we encounter is smaller, then we know, at least from the perspective of the left side, that we can trap water.\\n\\t* We can repeat the same thought process above from right to left.\\n\\nNow, using this idea, we can do a left-to-right pass and a right-to-left pass, greedily calclating the max-water we can trap in each column, `height[i]`.\\n\\nAt the end of this, we can simply take the `min(left[i], right[i])` to figure out the result.\\n\\n```python\\ndef trap(height):\\n\\n\\t# Left pass\\n\\n\\tleft_max = 0\\n\\tleft_result = []\\n\\n\\tfor i in range(len(height)):\\n\\t\\tif height[i] >= left_max:\\n\\t\\t\\tleft_max = height[i]\\n\\t\\t\\tleft_result.append(0)\\n\\t\\telse:\\n\\t\\t\\tleft_result.append(left_max-height[i])\\n\\n\\t# Right pass\\n\\n\\tright_max = 0\\n\\tright_result = []\\n\\n\\tfor i in reversed(range(len(height))):\\n\\t\\tif height[i] >= right_max:\\n\\t\\t\\tright_max = height[i]\\n\\t\\t\\tright_result.append(0)\\n\\t\\telse:\\n\\t\\t\\tright_result.append(right_max-height[i])\\n\\n\\t# Min of each element in the pass \\n\\n\\treturn sum([\\n\\t\\tmin(left_result[i], right_result[len(height)-i-1])\\n\\t\\tfor i in range(len(height))\\n\\t])\\n```\\n\\nHopefully this makese sense. \\n\\nWe are still using `O(n)` space in this version, however. \\n\\nThe last optimization we can make is two use two pointers, instead of doing two passes:\\n\\n```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\n        result, l, r = 0, 0, len(height)-1\\n        \\n        left_max = right_max = 0\\n        \\n        while l < r:\\n            if height[l] < height[r]:\\n                if height[l] >= left_max:\\n                    left_max = height[l]\\n                else:\\n                    result += left_max-height[l]\\n                l += 1\\n            else:\\n                if height[r] >= right_max:\\n                    right_max = height[r]\\n                else:\\n                    result += right_max-height[r]\\n                r -= 1\\n                \\n        return result\\n```\\n\\nThis final solution is just a fancy way of combining the above two passes into one, so we don\\'t need that extra space.\\n\\nHopefully this documentation is helpful to someone!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef trap(height):\\n    result = 0\\n    for idx, i in enumerate(height):\\n        left, right = max(height[:idx]+[0]), max(height[idx+1:]+[0])\\n        score = min(left, right)\\n        result += max(score-i, 0)\\n    return result\\n```\n```python\\ndef trap(height):\\n    result = 0\\n    for idx, i in enumerate(height):\\n        left, right = max(height[:idx]+[0]), max(height[idx+1:]+[0]) # <-- THIS GUY!\\n        score = min(left, right)\\n        result += max(score-i, 0)\\n    return result\\n```\n```python\\n# Left max\\nleft_max = list(height)\\nfor i in range(1, len(height)):\\n\\tleft_max[i] = max(left_max[i-1], left_max[i])\\n\\n# Right max\\nright_max = list(height)\\nfor i in reversed(range(len(height)-1)):\\n\\tright_max[i] = max(right_max[i], right_max[i+1])\\n```\n```python\\ndef trap(height):\\n\\n\\t# Left max\\n\\tleft_max = list(height)\\n\\tfor i in range(1, len(height)):\\n\\t\\tleft_max[i] = max(left_max[i-1], left_max[i])            \\n\\n\\t# Right max\\n\\tright_max = list(height)\\n\\tfor i in reversed(range(len(height)-1)):\\n\\t\\tright_max[i] = max(right_max[i], right_max[i+1])\\n\\n\\t# Calculate result\\n\\tresult = 0        \\n\\tfor idx, i in enumerate(height):\\n\\t\\tscore = min(left_max[idx], right_max[idx]) # <-- Constant time O(1) computation\\n\\t\\tresult += max(score-i, 0)\\n\\treturn result\\n```\n```python\\ndef trap(height):\\n\\n\\t# Left pass\\n\\n\\tleft_max = 0\\n\\tleft_result = []\\n\\n\\tfor i in range(len(height)):\\n\\t\\tif height[i] >= left_max:\\n\\t\\t\\tleft_max = height[i]\\n\\t\\t\\tleft_result.append(0)\\n\\t\\telse:\\n\\t\\t\\tleft_result.append(left_max-height[i])\\n\\n\\t# Right pass\\n\\n\\tright_max = 0\\n\\tright_result = []\\n\\n\\tfor i in reversed(range(len(height))):\\n\\t\\tif height[i] >= right_max:\\n\\t\\t\\tright_max = height[i]\\n\\t\\t\\tright_result.append(0)\\n\\t\\telse:\\n\\t\\t\\tright_result.append(right_max-height[i])\\n\\n\\t# Min of each element in the pass \\n\\n\\treturn sum([\\n\\t\\tmin(left_result[i], right_result[len(height)-i-1])\\n\\t\\tfor i in range(len(height))\\n\\t])\\n```\n```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\n        result, l, r = 0, 0, len(height)-1\\n        \\n        left_max = right_max = 0\\n        \\n        while l < r:\\n            if height[l] < height[r]:\\n                if height[l] >= left_max:\\n                    left_max = height[l]\\n                else:\\n                    result += left_max-height[l]\\n                l += 1\\n            else:\\n                if height[r] >= right_max:\\n                    right_max = height[r]\\n                else:\\n                    result += right_max-height[r]\\n                r -= 1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008702,
                "title": "c-clean-correct",
                "content": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n     \\n    int n=arr.size();\\n        \\n    if(n==0) return 0;\\n        \\n    int lmax[n],rmax[n];\\n    \\n    lmax[0]=arr[0];\\n    rmax[n-1]=arr[n-1];\\n    \\n    int res=0;\\n    \\n    for(int i=1;i<n;i++)\\n        lmax[i]=max(lmax[i-1],arr[i]);\\n    \\n    for(int i=n-2;i>=0;i--)\\n        rmax[i]=max(arr[i],rmax[i+1]);\\n    \\n    for(int i=1;i<n-1;i++)\\n        res+=min(lmax[i],rmax[i])-arr[i];\\n        \\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n     \\n    int n=arr.size();\\n        \\n    if(n==0) return 0;\\n        \\n    int lmax[n],rmax[n];\\n    \\n    lmax[0]=arr[0];\\n    rmax[n-1]=arr[n-1];\\n    \\n    int res=0;\\n    \\n    for(int i=1;i<n;i++)\\n        lmax[i]=max(lmax[i-1],arr[i]);\\n    \\n    for(int i=n-2;i>=0;i--)\\n        rmax[i]=max(arr[i],rmax[i+1]);\\n    \\n    for(int i=1;i<n-1;i++)\\n        res+=min(lmax[i],rmax[i])-arr[i];\\n        \\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537396,
                "title": "python-brute-force-straightforward-solution",
                "content": "Solution goes through each position and checks for max heights `max_left` and `max_right` of current position, then takes the minimum of the two max heights (if take max, then water will overflow) and subtract the max height `potential` from `height[i]` and add the amount of holdable water to `ans`.\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        for i in range(1,len(height)-1): \\n            max_left = max(height[:i])\\n            max_right = max(height[i+1:])\\n            potential = min(max_left, max_right) - height[i]\\n            ans += max(0, potential) \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        for i in range(1,len(height)-1): \\n            max_left = max(height[:i])\\n            max_right = max(height[i+1:])\\n            potential = min(max_left, max_right) - height[i]\\n            ans += max(0, potential) \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781288,
                "title": "c-simple-and-concise-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Simple formula : for each elevation water it can store is equal to\\nmin(prefix[i], suffix[i]) - elevation\\n \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        vector<int> prefix(100000, 0);\\n        vector<int> suffix(100000, 0);\\n\\n        prefix[0] = height[0];\\n        for(int i = 1;i < height.size();i++){\\n            prefix[i] = max(prefix[i-1], height[i]); \\n        }\\n\\n        suffix[height.size()-1] = height[height.size()-1];\\n        for(int i = height.size()-2;i >= 0;i--){\\n            suffix[i] = max(suffix[i+1], height[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0;i <= height.size()-1;i++){\\n            int t = min(prefix[i], suffix[i]) - height[i];\\n            ans += t;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        vector<int> prefix(100000, 0);\\n        vector<int> suffix(100000, 0);\\n\\n        prefix[0] = height[0];\\n        for(int i = 1;i < height.size();i++){\\n            prefix[i] = max(prefix[i-1], height[i]); \\n        }\\n\\n        suffix[height.size()-1] = height[height.size()-1];\\n        for(int i = height.size()-2;i >= 0;i--){\\n            suffix[i] = max(suffix[i+1], height[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0;i <= height.size()-1;i++){\\n            int t = min(prefix[i], suffix[i]) - height[i];\\n            ans += t;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775334,
                "title": "python-94-14-faster-brute-force-optimized-both-solutions",
                "content": "**Brute Force Approach:**\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n=len(height)\\n        m=height[0]\\n        left=[m]\\n        for i in range(1,n):\\n            if height[i]>m:\\n                m=height[i]\\n            if m>height[i]:\\n                left.append(m)\\n            else:\\n                left.append(height[i])\\n        m=height[-1]\\n        right=[m]\\n        for i in range(n-2,-1,-1):\\n            if height[i]>m:\\n                m=height[i]\\n            if m>height[i]:\\n                right.append(m)\\n            else:\\n                right.append(height[i])\\n        right=right[::-1]\\n        ans=[0]*n\\n        for i in range(n):\\n            ans[i]=min(left[i],right[i])-height[i]\\n        return sum(ans)  \\n```\\n**Optimized Approach (Two Pointers):**\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        left,right=0,len(height)-1\\n        lmax,rmax=height[left],height[right]\\n        water=0\\n        while left<right:\\n            lmax,rmax=max(lmax,height[left]),max(rmax,height[right])\\n            if lmax<=rmax:\\n                water+=lmax-height[left]\\n                left+=1\\n            else:\\n                water+=rmax-height[right]\\n                right-=1\\n        return water\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n=len(height)\\n        m=height[0]\\n        left=[m]\\n        for i in range(1,n):\\n            if height[i]>m:\\n                m=height[i]\\n            if m>height[i]:\\n                left.append(m)\\n            else:\\n                left.append(height[i])\\n        m=height[-1]\\n        right=[m]\\n        for i in range(n-2,-1,-1):\\n            if height[i]>m:\\n                m=height[i]\\n            if m>height[i]:\\n                right.append(m)\\n            else:\\n                right.append(height[i])\\n        right=right[::-1]\\n        ans=[0]*n\\n        for i in range(n):\\n            ans[i]=min(left[i],right[i])-height[i]\\n        return sum(ans)  \\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        left,right=0,len(height)-1\\n        lmax,rmax=height[left],height[right]\\n        water=0\\n        while left<right:\\n            lmax,rmax=max(lmax,height[left]),max(rmax,height[right])\\n            if lmax<=rmax:\\n                water+=lmax-height[left]\\n                left+=1\\n            else:\\n                water+=rmax-height[right]\\n                right-=1\\n        return water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325600,
                "title": "simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO (n)\\n\\n- Space complexity:\\nO (1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0; \\n        int right = height.length - 1;\\n        int ans = 0; \\n        int lMax = 0, rMax = 0;\\n        while(left <= right){\\n            lMax = Math.max(height[left], lMax);\\n            rMax = Math.max(height[right], rMax);\\t\\t\\t  \\n            \\n            if (lMax < rMax){\\n                ans += lMax - height[left++];\\n            }\\n            else {\\n                ans += rMax - height[right--];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPlease upvote, if you find this useful.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0; \\n        int right = height.length - 1;\\n        int ans = 0; \\n        int lMax = 0, rMax = 0;\\n        while(left <= right){\\n            lMax = Math.max(height[left], lMax);\\n            rMax = Math.max(height[right], rMax);\\t\\t\\t  \\n            \\n            if (lMax < rMax){\\n                ans += lMax - height[left++];\\n            }\\n            else {\\n                ans += rMax - height[right--];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200975,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition:\\nThe approach to solving this problem involves using two pointers to traverse the elevation map from both ends. The idea is to maintain two variables leftmax and rightmax to keep track of the maximum height seen so far from the left and right ends, respectively. As we traverse the elevation map from both ends towards the center, we can calculate the trapped rainwater for each elevation based on the minimum of leftmax and rightmax minus the height of the current elevation. By continuously updating leftmax and rightmax, we can efficiently calculate the total trapped rainwater.\\n\\n# Algorithm:\\n\\nInitialize the variables ans to store the total trapped rainwater, n to represent the number of elevations in the height vector, i to represent the left pointer starting at index 0, and j to represent the right pointer starting at index n-1.\\nInitialize two variables leftmax and rightmax to represent the maximum heights seen so far from the left and right ends, respectively, and set both to 0 initially.\\nWhile i is less than j, do the following:\\na. If the elevation at index i is less than or equal to the elevation at index j:\\nIf the elevation at index i is greater than the current leftmax, update leftmax to the elevation at index i.\\nOtherwise, calculate the trapped rainwater for the elevation at index i as leftmax - height[i] and add it to the ans.\\nIncrement the left pointer i by 1.\\nb. If the elevation at index i is greater than the elevation at index j:\\nIf the elevation at index j is greater than the current rightmax, update rightmax to the elevation at index j.\\nOtherwise, calculate the trapped rainwater for the elevation at index j as rightmax - height[j] and add it to the ans.\\nDecrement the right pointer j by 1.\\nAfter the loop, return the ans as the final result, representing the total trapped rainwater.\\nComplexity Analysis:\\n\\n# Time Complexity:\\n The algorithm uses two pointers to traverse the height vector from both ends towards the center, which takes O(n) time, where n is the length of the height vector.\\n# Space Complexity: \\nThe algorithm uses only a constant amount of extra space to store the variables ans, n, i, j, leftmax, and rightmax, so the space complexity is O(1).\\nOverall, the algorithm has a linear time complexity of O(n) and a constant space complexity of O(1). It efficiently calculates the total trapped rainwater in the given elevation map.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int left=0,right=height.size()-1;\\n        int maxleft=0,maxright=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=maxleft)maxleft=height[left];\\n                else res += maxleft-height[left];\\n                left++;\\n            }else{\\n                 if(height[right]>=maxright)maxright=height[right];\\n                else res += maxright-height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int left=0,right=height.size()-1;\\n        int maxleft=0,maxright=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=maxleft)maxleft=height[left];\\n                else res += maxleft-height[left];\\n                left++;\\n            }else{\\n                 if(height[right]>=maxright)maxright=height[right];\\n                else res += maxright-height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212984,
                "title": "c-trapping-rain-water-easy-solution",
                "content": "\\t// water above any building will be level of water above that building -height of building \\n\\t// to find the level of water above any buiding\\n\\t// find the maxm on the left and find the maximum on the right \\n\\t// take the minimum of from maxm_left and maxm_right  \\n\\t// we will make maxm_left and maxm_right array to store the maxm height on left and right  side \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint trap(vector<int>& height) {\\n\\t\\t\\tint n=height.size();\\n\\t\\t\\tvector<int>maxm_left(n),maxm_right(n);\\n\\t\\t\\t\\n\\t\\t\\tmaxm_left[0]=height[0];\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmaxm_left[i]=max(maxm_left[i-1],height[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tmaxm_right[n-1]=height[n-1];\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmaxm_right[i]=max(maxm_right[i+1],height[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint water=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\twater+=(min(maxm_left[i],maxm_right[i])-height[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn water;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint trap(vector<int>& height) {\\n\\t\\t\\tint n=height.size();\\n\\t\\t\\tvector<int>maxm_left(n),maxm_right(n);\\n\\t\\t\\t\\n\\t\\t\\tmaxm_left[0]=height[0];\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmaxm_left[i]=max(maxm_left[i-1],height[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 609155,
                "title": "pythonic-brute-force",
                "content": "Same idea as the official brute force solution. For each height in the array of heights, find the greatest element to the left of it and the greatest element to the right. The amount of water this index can hold is equal to the minimum of the two greatest minus the value at that index. Obviously, we can\\'t have a negative amount of water, so if this value is negative, just add zero to the answer instead.\\n\\n\\n```\\ndef trap(self, height: List[int]) -> int:\\n        \\n        answer = 0\\n        for i, val in enumerate(height):\\n            l = 0 if i == 0 else max(height[:i])\\n            r = 0 if i == len(height) - 1 else max(height[i+1:])\\n            answer += max(0, min(l, r) - val)\\n        \\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\ndef trap(self, height: List[int]) -> int:\\n        \\n        answer = 0\\n        for i, val in enumerate(height):\\n            l = 0 if i == 0 else max(height[:i])\\n            r = 0 if i == len(height) - 1 else max(height[i+1:])\\n            answer += max(0, min(l, r) - val)\\n        \\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17464,
                "title": "java-using-stack-with-explanation",
                "content": "Credit to @jiaohy  https://discuss.leetcode.com/topic/47181/sharing-my-java-solution-using-stack\\nAdded in-line comments and change variable name for better understanding\\n```\\npublic class Solution {\\n    public int trap(int[] height) {\\n        if(height.length == 0) return 0;\\n        Stack<Integer> stack = new Stack<Integer>(); // store index\\n        int vol = 0;\\n        for(int i = 0; i < height.length; i++) {\\n            // columns in stack will be decreasing in height.\\n            // current column index is \"i\"\\n            if(stack.empty() || height[stack.peek()] >= height[i]) stack.push(i);\\n            // if we encounter a column lower  than the previous one, push it to stack.\\n            else {\\n            // if we encounter a column higher than the previous one (denoted as \"mid\"), start poping,\\n            // calculate the water trapped between column before mid(denote as \"j\") and \"i\"\\n                while(!stack.empty() && height[stack.peek()] < height[i]) {\\n                    int mid = stack.pop();\\n                    if(!stack.empty()) {\\n                        int j = stack.peek();\\n                        vol += (i - j - 1) * (Math.min(height[i], height[j]) - height[mid]);\\n                    }\\n                }\\n                stack.push(i);\\n            }\\n        }\\n        return vol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int trap(int[] height) {\\n        if(height.length == 0) return 0;\\n        Stack<Integer> stack = new Stack<Integer>(); // store index\\n        int vol = 0;\\n        for(int i = 0; i < height.length; i++) {\\n            // columns in stack will be decreasing in height.\\n            // current column index is \"i\"\\n            if(stack.empty() || height[stack.peek()] >= height[i]) stack.push(i);\\n            // if we encounter a column lower  than the previous one, push it to stack.\\n            else {\\n            // if we encounter a column higher than the previous one (denoted as \"mid\"), start poping,\\n            // calculate the water trapped between column before mid(denote as \"j\") and \"i\"\\n                while(!stack.empty() && height[stack.peek()] < height[i]) {\\n                    int mid = stack.pop();\\n                    if(!stack.empty()) {\\n                        int j = stack.peek();\\n                        vol += (i - j - 1) * (Math.min(height[i], height[j]) - height[mid]);\\n                    }\\n                }\\n                stack.push(i);\\n            }\\n        }\\n        return vol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17510,
                "title": "my-simple-compact-java-solution-10-lines",
                "content": "    public int trap(int[] h) {\\n        if(h == null || h.length == 0) return 0;\\n        int lMax = 0, rMax = 0, w = 0, l = 0, r = h.length - 1;\\n        while(l < r) {\\n            lMax = lMax > h[l] ? lMax : h[l];\\n            rMax = rMax > h[r] ? rMax : h[r];\\n            w += lMax < rMax ? lMax - h[l++] : rMax - h[r--];\\n        }\\n        return w;\\n    }",
                "solutionTags": [],
                "code": "    public int trap(int[] h) {\\n        if(h == null || h.length == 0) return 0;\\n        int lMax = 0, rMax = 0, w = 0, l = 0, r = h.length - 1;\\n        while(l < r) {\\n            lMax = lMax > h[l] ? lMax : h[l];\\n            rMax = rMax > h[r] ? rMax : h[r];\\n            w += lMax < rMax ? lMax - h[l++] : rMax - h[r--];\\n        }\\n        return w;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3958941,
                "title": "2-optimized-methods-beats-100-explanation-c-clean-code",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Imagine the terrain heights as a series of vertical bars. The goal is to find the amount of water that can be trapped between these bars when it rains. To do this, we need to find, for each bar, the maximum height bar to its left and the maximum height bar to its right. The amount of water that can be trapped above a bar is determined by the minimum of these two maximum heights minus the height of the bar itself.\\n---\\n#### Calculate Next Greater Elements:\\n\\n- To the Left (ngl): For each bar, find the next greater bar to its left. This will help us determine the maximum height to the left of each bar. Initialize a vector ngl to store these next greater elements to the left.\\n\\n- To the Right (ngr): Similarly, find the next greater bar to the right of each bar. Initialize a vector ngr to store these next greater elements to the right.\\n\\n- This can also done using stack.\\n----\\n\\n### Calculate Trapped Water:\\n\\n- Once we have the vectors ngl and ngr, iterate through the bars again. \\n- For each bar, calculate the trapped water above it using the formula: min(ngl[i], ngr[i]) - height[i]. \\n- Here, height[i] is the height of the current bar, and min(ngl[i], ngr[i]) represents the minimum of the maximum heights to the left and right of the current bar.\\n\\n- Accumulate these trapped water values for all bars to get the total trapped rainwater.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> ngl(n), ngr(n);\\n\\n        ngl[0] = height[0];\\n        ngr[n-1] = height[n-1];\\n\\n        for(int i=1; i<n; i++){\\n            ngl[i] = max(height[i], ngl[i-1])+ 0ll;\\n        }\\n\\n        for(int i=n-2; i>=0; i--){\\n            ngr[i] = max(height[i], ngr[i+1]) + 0ll;\\n        }\\n        int ans =0ll; \\n        for(int i=0; i<n; i++){\\n            ans+= min(ngl[i],ngr[i]) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---\\n---\\n# **Method-2**\\n# Intuition & Approach\\n- This approach is excalty same but **space optimized**.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- int trap(vector<int>& a): This is the function that takes a vector of integers a representing the heights of the terrain.\\n\\n- int n = a.size();: It calculates the size of the input vector a.\\n\\n- int left = 0, right = n - 1;: Initialize two pointers, left and right, which are positioned at the beginning and end of the terrain respectively.\\n\\n- int l = 0, r = 0, ans = 0;: Initialize three variables l, r, and ans to keep track of the left maximum height, right maximum height, and the answer (total trapped rainwater) respectively.\\n-  These variables are used to track the heights of the highest barriers seen from the left and right sides.\\n\\n- The while (left <= right) loop runs until the two pointers meet or cross each other.\\n\\n- Inside the loop, there\\'s a conditional structure to determine which pointer to move (left or right) based on the heights at their current positions.\\n\\n- If a[left] <= a[right], it means the current height at left can potentially trap water because it\\'s bounded by a barrier on the right side that\\'s either as tall or taller. In this case:\\n\\n- Update the left maximum height: l = max(l, a[left]);\\n- Calculate the trapped water by subtracting the current height from the left maximum height: ans += l - a[left];\\n- Move the left pointer one step to the right: left++;\\n- If a[left] > a[right], the situation is reversed. The current height at right can potentially trap water because it\\'s bounded by a barrier on the left side that\\'s either as tall or taller. In this case:\\n\\n- Update the right maximum height: r = max(r, a[right]);\\n- Calculate the trapped water by subtracting the current height from the right maximum height: ans += r - a[right];\\n- Move the right pointer one step to the left: right--;\\n- Once the pointers meet or cross each other, the loop terminates.\\n\\n- Finally, return the calculated ans, which represents the total trapped rainwater.\\n---\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int n=a.size();\\n        int left=0,right=n-1;\\n        int l=0,r=0,ans=0;\\n        while(left<=right){\\n            if(a[left]<=a[right]){\\n                // left may be contrtibuting\\n                l=max(l,a[left]);\\n                ans+=l-a[left];\\n                left++; \\n            }\\n            else if(a[left]>a[right]){\\n                r=max(r,a[right]);\\n                ans+=r-a[right];\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> ngl(n), ngr(n);\\n\\n        ngl[0] = height[0];\\n        ngr[n-1] = height[n-1];\\n\\n        for(int i=1; i<n; i++){\\n            ngl[i] = max(height[i], ngl[i-1])+ 0ll;\\n        }\\n\\n        for(int i=n-2; i>=0; i--){\\n            ngr[i] = max(height[i], ngr[i+1]) + 0ll;\\n        }\\n        int ans =0ll; \\n        for(int i=0; i<n; i++){\\n            ans+= min(ngl[i],ngr[i]) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int n=a.size();\\n        int left=0,right=n-1;\\n        int l=0,r=0,ans=0;\\n        while(left<=right){\\n            if(a[left]<=a[right]){\\n                // left may be contrtibuting\\n                l=max(l,a[left]);\\n                ans+=l-a[left];\\n                left++; \\n            }\\n            else if(a[left]>a[right]){\\n                r=max(r,a[right]);\\n                ans+=r-a[right];\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474549,
                "title": "c-very-simple-solution-easy-to-understand-best",
                "content": "class Solution {\\npublic:\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int>leftgreat;\\n        int left = height[0];\\n        for(int j=0; j<n; j++){\\n            if(left <height[j]){\\n                  left = height[j];\\n            }\\n            leftgreat.push_back(left);\\n        }\\n        int right = height[n-1];\\n        vector<int>rightgreat;\\n        for(int j = n-1 ; j>=0; j--){\\n                if(right<height[j])\\n                    right = height[j];\\n             rightgreat.push_back(right);\\n            }\\n        reverse(rightgreat.begin() , rightgreat.end());\\n        int sum = 0;\\n        for(int i = 0 ; i<n;i++){\\n            sum = sum + (min(leftgreat[i] , rightgreat[i]) - height[i]);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int>leftgreat;\\n        int left = height[0];\\n        for(int j=0; j<n; j++){\\n            if(left <height[j]){\\n                  left = height[j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3344957,
                "title": "super-easy-java-solution-dp-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* solving problem using DP by creating arrays for largest pillars for that particular index for both directions.\\n* assume we are moving from left to right in array \\n1. each element represent the height of pillar for that index\\n\\nex-\\n\\n| - represent pillar\\nw - represent water\\n```\\n 1   5   3   0   4   0\\n     |\\n     |   w   w   |\\n     |   |   w   |\\n     |   |   w   |   \\n |   |   |   w   | \\n\\n```\\n2. between 2 pillars water can stay\\n3. we will maintain the size of largest possible pillar at that index\\nfrom left to right and another array will have pillar from right  to left . \\n4. at last we are computing weather it is possible to hold water at given index (water can hold if it have pillar on both of its side ie..right side and left size which our rtl and ltr arrays are computing)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] arr) {\\n        int n = arr.length;\\n        int[] ltr =new int[n];\\n        int[] rtl = new int[n];\\n        ltr[0] = arr[0];\\n        rtl[n-1] = arr[n-1];\\n\\n        for(int i =1;i<n;i++){\\n            ltr[i] = Math.max(arr[i],ltr[i-1]);\\n        }\\n\\n        for(int i =n-2;i>=0;i--){\\n            rtl[i] = Math.max(arr[i],rtl[i+1]); \\n        }\\n\\n        int count =0;\\n\\n        for(int i =0;i<n;i++){\\n            int min = Math.min(ltr[i],rtl[i]);\\n            count += ((min-arr[i])>0) ? (min-arr[i]) : 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n 1   5   3   0   4   0\\n     |\\n     |   w   w   |\\n     |   |   w   |\\n     |   |   w   |   \\n |   |   |   w   | \\n\\n```\n```\\nclass Solution {\\n    public int trap(int[] arr) {\\n        int n = arr.length;\\n        int[] ltr =new int[n];\\n        int[] rtl = new int[n];\\n        ltr[0] = arr[0];\\n        rtl[n-1] = arr[n-1];\\n\\n        for(int i =1;i<n;i++){\\n            ltr[i] = Math.max(arr[i],ltr[i-1]);\\n        }\\n\\n        for(int i =n-2;i>=0;i--){\\n            rtl[i] = Math.max(arr[i],rtl[i+1]); \\n        }\\n\\n        int count =0;\\n\\n        for(int i =0;i<n;i++){\\n            int min = Math.min(ltr[i],rtl[i]);\\n            count += ((min-arr[i])>0) ? (min-arr[i]) : 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281327,
                "title": "trapping-rain-water-solution-with-intution",
                "content": "# Intuition\\n**First Let\\'s take a Look at the problem with the given testcase:-**\\n\\n![image.png](https://assets.leetcode.com/users/images/33dcabbf-b964-4d32-9c98-18cee64c812d_1678470980.14873.png)\\n\\n\\n***Testcase-1:***\\n\\n`i -> 0 1 2 3 4 5 6 7 8 9 10 11`\\nArray:`[0,1,0,2,1,0,1,3,2,1,2,1]`\\n\\nWater at `i=2` is `0`.\\nWater Stagnant or Trapped because of Buildings is done by either Building of heights `1` & `2`.\\nBut the When you look at it closely, the water trapped is by the Building of $$Height=1$$ but not trather than Building of $$Height=2$$.\\nSo water is enclosed or trapped by the $$min(\\\\text{Heights adjacent, to } i^\\\\text{th} \\\\text{ Building})$$ that is either $$i-1^\\\\text{th}$$ or $$i+1^\\\\text{th}$$.\\n\\n---\\n\\n$$Formula:-$$\\n`Water Trapped by `$$i^\\\\text{th}$$` Height Building = minimum(Height of `$$i-1^\\\\text{th}$$` Building and Height of `$$i+1^\\\\text{th}$$` Building) - Heigh at `$$i^\\\\text{th}$$` Building`.\\n\\n---\\n\\n**BUT!!!**\\n***Let\\'s take another Building from Given $$Heights$$.***\\n\\nHeigh at `i=5` is `0` once again.\\nWater Stagnant or Trapped because of Buildings is done by either Building of heights `1` & `1` according to our assumption.\\nBut the When you look at it closely, the water trapped is by the Building of $$Height=2$$ but not trather than Building of $$Height=3$$.\\n\\nSo Water trapped is $$minimum(2, 3)$$ - water left at $$5^\\\\text{th}$$ Height(i.e., `0`) = 2.\\n\\nTake a look at $$4^\\\\text{th}$$ tower with $$Height=1$$ it\\'s Height is contributed by both Left Tower i.e., $$3^\\\\text{rd}$$ and the $$5^\\\\text{th}$$ but not the $$4^\\\\text{th}$$ Tower.\\n\\nSo the $$Trapped\\\\hspace{1mm}Water$$ is contributed by Both it\\'s $$max(Left\\\\hspace{1mm}Neighbours)$$ and $$max(Right\\\\hspace{1mm}Neighbours)$$.\\n\\n$$\\\\bold{So\\\\hspace{1mm}the\\\\hspace{1mm}Formula\\\\hspace{1mm}get\\'s\\\\hspace{1mm}modified\\\\hspace{1mm}as\\\\hspace{1mm}follows:-}$$\\n\\n---\\n\\n`Water Trapped by `$$i^\\\\text{th}$$` Height Building = minimum(max(Heights from `$$0^\\\\text{th}$$`Building to `$$i^\\\\text{th}$$` Building) and max(Height of `$$i^\\\\text{th}$$` Building to the Height of `$$n-1^\\\\text{th}$$` Building)) - Height at `$$i^\\\\text{th}$$` Building`.\\n\\n---\\n$$Note:-$$\\nRefer to this if any Doubts.\\n\\n![image.png](https://assets.leetcode.com/users/images/832dcd41-9907-439a-a439-cd91a63fa6ac_1678468215.833124.png)\\n\\n# Approach-1: Simple Brute Force\\n***Compute Maximum Heights in both $$Left$$ and $$Right$$ Direction for each Tower.***  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        res = 0;\\n        for i: 0->n-1:\\n            for j: 0->i:\\n                l_max = max(l_max, height[i])\\n            for j: i->n-1:\\n                r_max = max(r_max, height[i])\\n            res += min(l_max, r_max);\\n            res -= height[i];\\n        return res;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(N^\\\\text{2})$$, Since we computing $$i^\\\\text{th}$$ from `0->n` and $$j^\\\\text{th}$$ loop from `0->i` and `i->n-1`, in worst case it goes $$N^\\\\text{2}$$ Time Complexity.\\n\\n- Space complexity: $$O(1)$$ Since we are not using extra space and variables count nothing but as $$O(1)$$.\\n\\n# Approach-2: Pre-Computation\\n***Using Precomputation Stratergy we optimize our approach,  First Precompute Maximum Heights in both $$Left$$ and $$Right$$ Direction for each Tower and Store them and use them for each Tower while Calculation.*** \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        int n = height.size();\\n        vector<int> pre(n, 0);\\n        vector<int> suf(n, 0);\\n        pre[0] = height[0], suf[n-1] = height[n-1];\\n        for(int i=1; i<n; i++)\\n        {\\n            pre[i] = max(height[i], pre[i-1]);\\n        }\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            suf[i] = max(suf[i+1], height[i]);\\n        }\\n        int res = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            res += (min(pre[i], suf[i]) - height[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(N)$$, Since we computing $$i^\\\\text{th}$$ from `0->n` only once.\\n\\n- Space complexity: $$O(N)$$ Since we are using 2 extra spaces for $$Left$$ and $$Right$$ Buildings and $$O(2*N)$$ = $$O(N)$$.\\n\\n# Approach-3: Two Pointers\\n***Here we make use of $$two\\\\hspace{1mm}pointers$$ in order to optimize our approach even more***.\\n***Maintain two pointers at $$left$$ and $$right$$, update $$left\\\\hspace{1mm}max$$ and $$right\\\\hspace{1mm}max$$ variables and calculate water trapped based on the $$minimum$$ of them using $$\\\\bold{comparision}$$.***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        int left = 0, right = heights.size()-1;\\n        int leftMax = 0, rightMax = 0, ans = 0;\\n        while(left <= right)\\n        {\\n            if(heights[left] <= heights[right])\\n            {\\n                if(heights[left] >= leftMax)\\n                {\\n                    leftMax = heights[left];\\n                }\\n                else\\n                {\\n                    ans += (leftMax - heights[left]);\\n                }\\n                left++;\\n            }\\n            else\\n            {\\n                if(heights[right] >= rightMax)\\n                {\\n                    rightMax = heights[right];\\n                }\\n                else\\n                {\\n                    ans += (rightMax - heights[right]);\\n                }\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(N)$$, Since we computing $$i^\\\\text{th}$$ from `0->n` only once.\\n\\n- Space complexity: $$O(1)$$ Since we are using only variable(s).\\n\\n**Do Upvote the solution if it was helpful, This is $$Pavan\\\\hspace{1mm}Kalyan$$ signing out!!!.**\\n\\n![minato-minato-namikaze.gif](https://assets.leetcode.com/users/images/7017c747-0a7b-4a8a-abf5-3692cc89b3bc_1678473384.9673824.gif)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        res = 0;\\n        for i: 0->n-1:\\n            for j: 0->i:\\n                l_max = max(l_max, height[i])\\n            for j: i->n-1:\\n                r_max = max(r_max, height[i])\\n            res += min(l_max, r_max);\\n            res -= height[i];\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        int n = height.size();\\n        vector<int> pre(n, 0);\\n        vector<int> suf(n, 0);\\n        pre[0] = height[0], suf[n-1] = height[n-1];\\n        for(int i=1; i<n; i++)\\n        {\\n            pre[i] = max(height[i], pre[i-1]);\\n        }\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            suf[i] = max(suf[i+1], height[i]);\\n        }\\n        int res = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            res += (min(pre[i], suf[i]) - height[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        int left = 0, right = heights.size()-1;\\n        int leftMax = 0, rightMax = 0, ans = 0;\\n        while(left <= right)\\n        {\\n            if(heights[left] <= heights[right])\\n            {\\n                if(heights[left] >= leftMax)\\n                {\\n                    leftMax = heights[left];\\n                }\\n                else\\n                {\\n                    ans += (leftMax - heights[left]);\\n                }\\n                left++;\\n            }\\n            else\\n            {\\n                if(heights[right] >= rightMax)\\n                {\\n                    rightMax = heights[right];\\n                }\\n                else\\n                {\\n                    ans += (rightMax - heights[right]);\\n                }\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722076,
                "title": "python-beginners-friendly-easy",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        lmax,rmax = [0]*n,[0]*n\\n\\n        lmax[0] = height[0]\\n        for i in range(1,len(height)):\\n            lmax[i] = max(lmax[i-1],height[i])\\n\\n        rmax[n-1] = height[n-1]\\n        for i in range(n-2,-1,-1):\\n            rmax[i] = max(rmax[i+1],height[i])\\n\\n        ans = 0\\n        for i in range(n):\\n            ans+=min(lmax[i],rmax[i])-height[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        lmax,rmax = [0]*n,[0]*n\\n\\n        lmax[0] = height[0]\\n        for i in range(1,len(height)):\\n            lmax[i] = max(lmax[i-1],height[i])\\n\\n        rmax[n-1] = height[n-1]\\n        for i in range(n-2,-1,-1):\\n            rmax[i] = max(rmax[i+1],height[i])\\n\\n        ans = 0\\n        for i in range(n):\\n            ans+=min(lmax[i],rmax[i])-height[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591672,
                "title": "python-dec-mono-stack-one-pass-explained",
                "content": "# Logic explanation\\nWe want to calculate total rain water we can trap.\\n\\nA signle wall (element in the array) can trap water between its left and right walls.\\nFor water to be trapped, the left and right walls must be bigger, therefore we need to find the first wall on the left which is bigger than the current element, and the first wall on the first which is bigger. \\n\\nThis can be done in one pass using a decreasing monotonic stack.\\n\\nNow there could be a situation like this: `| _ _ _ |` where all 3 elements in the middle will have the same wall boundaries, and that will lead to **double counting**.\\nTo resolve this I used `walls` dictionary which will store the amount of water a `(left, right)` wall pair can trap.\\n\\nThen we just return the sum of all the pair values.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        walls = {}\\n        dec_mono_stack = []\\n        \\n        for i, v in enumerate(height):\\n            while dec_mono_stack and v > height[dec_mono_stack[-1]]:\\n                mid_index = dec_mono_stack.pop()\\n                if not dec_mono_stack:\\n                    # no left wall, can\\'t trap\\n                    break\\n                left_wall_i = dec_mono_stack[-1]\\n                right_wall_i = i\\n                height_val = min(height[left_wall_i], height[right_wall_i]) - height[mid_index]\\n                walls[(left_wall_i, right_wall_i)] = height_val * (right_wall_i - left_wall_i - 1)\\n                \\n            dec_mono_stack.append(i)\\n                \\n        return sum(walls.values())\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        walls = {}\\n        dec_mono_stack = []\\n        \\n        for i, v in enumerate(height):\\n            while dec_mono_stack and v > height[dec_mono_stack[-1]]:\\n                mid_index = dec_mono_stack.pop()\\n                if not dec_mono_stack:\\n                    # no left wall, can\\'t trap\\n                    break\\n                left_wall_i = dec_mono_stack[-1]\\n                right_wall_i = i\\n                height_val = min(height[left_wall_i], height[right_wall_i]) - height[mid_index]\\n                walls[(left_wall_i, right_wall_i)] = height_val * (right_wall_i - left_wall_i - 1)\\n                \\n            dec_mono_stack.append(i)\\n                \\n        return sum(walls.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185505,
                "title": "java-simple-and-easy-to-understand-solution-using-stack-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        if(n < 2) return 0;\\n    \\n        int totalWater = 0;\\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int index = 0; index < n; index++){\\n            \\n            while(!stack.empty() && height[index] > height[stack.peek()]){\\n                //remove and store the previous index\\n                int prevIndex = stack.pop();\\n                \\n                if(stack.empty()) break;\\n                \\n                int prevToPrevIndex = stack.peek();\\n                int distance   = index - prevToPrevIndex - 1;\\n                \\n                int boundedHeight = Math.min(height[index], height[prevToPrevIndex]) - height[prevIndex];\\n                \\n                totalWater += distance * boundedHeight;\\n            }\\n            \\n            stack.push(index);\\n        }\\n      \\n        return totalWater;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        if(n < 2) return 0;\\n    \\n        int totalWater = 0;\\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int index = 0; index < n; index++){\\n            \\n            while(!stack.empty() && height[index] > height[stack.peek()]){\\n                //remove and store the previous index\\n                int prevIndex = stack.pop();\\n                \\n                if(stack.empty()) break;\\n                \\n                int prevToPrevIndex = stack.peek();\\n                int distance   = index - prevToPrevIndex - 1;\\n                \\n                int boundedHeight = Math.min(height[index], height[prevToPrevIndex]) - height[prevIndex];\\n                \\n                totalWater += distance * boundedHeight;\\n            }\\n            \\n            stack.push(index);\\n        }\\n      \\n        return totalWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468167,
                "title": "test-cases",
                "content": "Run against these before submitting:\\n```\\n[1,0,0,1]\\n[0,1,0,2,1,0,1,3,2,1,2,1]\\n[0,0,0,0,0,0,1,0,1,0,0,0,0,0]\\n[0]\\n[0,10,0]\\n[1,0,1]\\n[2,0,1]\\n[1,0,2]\\n[10,0,1]\\n[1,0,10]\\n[]\\n[1996, 337, 694, 688, 683]\\n[570, 500, 1898, 361, 1956]\\n[1145, 287, 1701, 338, 1540]\\n[765, 757, 1157, 1513, 402]\\n[1209, 1281, 433, 836, 1634]\\n[1280, 1689, 1589, 1424, 1271]\\n[1401, 634, 163, 695, 49]\\n[1357, 1650, 631, 701, 1794]\\n[641, 1773, 844, 53, 1126]\\n[1942, 396, 781, 300, 1322]\\n[57, 67, 42, 190, 107, 44, 101, 22, 158, 127, 165, 186, 6, 7, 13, 86, 3, 11, 164, 166, 56, 87, 120, 108, 157, 188, 195, 90, 82, 77, 109]\\n[84, 129, 21, 99, 50, 83, 52, 116, 117, 179, 197, 10, 181, 46, 39, 144, 174, 190, 93, 26, 67, 70, 138, 63, 162, 151, 150, 121, 160, 180, 41]\\n[72, 110, 162, 186, 189, 143, 112, 85, 175, 188, 13, 139, 92, 35, 193, 12, 124, 174, 55, 158, 32, 145, 66, 48, 70, 41, 154, 120, 37, 89, 94]\\n[100, 75, 87, 79, 64, 156, 66, 46, 81, 102, 108, 60, 137, 166, 111, 96, 88, 49, 4, 53, 176, 114, 117, 34, 37, 29, 109, 135, 58, 184, 162]\\n[5, 152, 53, 11, 67, 130, 85, 38, 140, 164, 117, 58, 142, 194, 88, 2, 47, 153, 176, 108, 113, 91, 61, 39, 10, 98, 45, 159, 42, 125, 111]\\n[79, 186, 10, 103, 120, 161, 198, 139, 167, 21, 15, 26, 188, 173, 77, 141, 149, 101, 131, 85, 16, 87, 128, 65, 30, 115, 63, 40, 145, 176, 36]\\n[65, 24, 4, 185, 193, 141, 83, 154, 67, 97, 170, 183, 188, 144, 115, 47, 139, 157, 111, 99, 101, 106, 72, 23, 66, 56, 49, 93, 176, 10, 36]\\n[163, 199, 194, 111, 161, 132, 151, 48, 50, 117, 102, 6, 146, 195, 28, 105, 119, 171, 114, 109, 20, 107, 149, 70, 59, 67, 137, 130, 116, 18, 178]\\n[120, 136, 182, 117, 9, 11, 86, 132, 75, 25, 93, 88, 188, 124, 53, 110, 113, 82, 10, 115, 108, 101, 29, 163, 71, 85, 135, 106, 146, 50, 99]\\n[63, 185, 134, 188, 45, 35, 170, 43, 103, 13, 135, 0, 115, 178, 176, 82, 38, 157, 19, 81, 21, 158, 70, 17, 87, 36, 119, 154, 99, 184, 180]\\n```",
                "solutionTags": [],
                "code": "```\\n[1,0,0,1]\\n[0,1,0,2,1,0,1,3,2,1,2,1]\\n[0,0,0,0,0,0,1,0,1,0,0,0,0,0]\\n[0]\\n[0,10,0]\\n[1,0,1]\\n[2,0,1]\\n[1,0,2]\\n[10,0,1]\\n[1,0,10]\\n[]\\n[1996, 337, 694, 688, 683]\\n[570, 500, 1898, 361, 1956]\\n[1145, 287, 1701, 338, 1540]\\n[765, 757, 1157, 1513, 402]\\n[1209, 1281, 433, 836, 1634]\\n[1280, 1689, 1589, 1424, 1271]\\n[1401, 634, 163, 695, 49]\\n[1357, 1650, 631, 701, 1794]\\n[641, 1773, 844, 53, 1126]\\n[1942, 396, 781, 300, 1322]\\n[57, 67, 42, 190, 107, 44, 101, 22, 158, 127, 165, 186, 6, 7, 13, 86, 3, 11, 164, 166, 56, 87, 120, 108, 157, 188, 195, 90, 82, 77, 109]\\n[84, 129, 21, 99, 50, 83, 52, 116, 117, 179, 197, 10, 181, 46, 39, 144, 174, 190, 93, 26, 67, 70, 138, 63, 162, 151, 150, 121, 160, 180, 41]\\n[72, 110, 162, 186, 189, 143, 112, 85, 175, 188, 13, 139, 92, 35, 193, 12, 124, 174, 55, 158, 32, 145, 66, 48, 70, 41, 154, 120, 37, 89, 94]\\n[100, 75, 87, 79, 64, 156, 66, 46, 81, 102, 108, 60, 137, 166, 111, 96, 88, 49, 4, 53, 176, 114, 117, 34, 37, 29, 109, 135, 58, 184, 162]\\n[5, 152, 53, 11, 67, 130, 85, 38, 140, 164, 117, 58, 142, 194, 88, 2, 47, 153, 176, 108, 113, 91, 61, 39, 10, 98, 45, 159, 42, 125, 111]\\n[79, 186, 10, 103, 120, 161, 198, 139, 167, 21, 15, 26, 188, 173, 77, 141, 149, 101, 131, 85, 16, 87, 128, 65, 30, 115, 63, 40, 145, 176, 36]\\n[65, 24, 4, 185, 193, 141, 83, 154, 67, 97, 170, 183, 188, 144, 115, 47, 139, 157, 111, 99, 101, 106, 72, 23, 66, 56, 49, 93, 176, 10, 36]\\n[163, 199, 194, 111, 161, 132, 151, 48, 50, 117, 102, 6, 146, 195, 28, 105, 119, 171, 114, 109, 20, 107, 149, 70, 59, 67, 137, 130, 116, 18, 178]\\n[120, 136, 182, 117, 9, 11, 86, 132, 75, 25, 93, 88, 188, 124, 53, 110, 113, 82, 10, 115, 108, 101, 29, 163, 71, 85, 135, 106, 146, 50, 99]\\n[63, 185, 134, 188, 45, 35, 170, 43, 103, 13, 135, 0, 115, 178, 176, 82, 38, 157, 19, 81, 21, 158, 70, 17, 87, 36, 119, 154, 99, 184, 180]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 268227,
                "title": "18-line-java-o-n-time-o-1-space-simple-clear-solution-approach-4",
                "content": "Thought I\\'d share my attempt at solving the problem with approach 4. Enjoy!\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        if (height.length <= 1) return 0;\\n\\t\\t// start 2 pointers\\n        int left = 0; int right = height.length-1;\\n        int sum = 0;\\n        while (left < right) {\\n            int max = 0;\\n\\t\\t\\t// keep advancing left while height is less/equal to right pointer && we havent reached the right pointer\\n            while (left < right && height[left] <= height[right]) {\\n                max = Math.max(max, height[left]);\\n                sum += max - height[left];\\n                left++;\\n            }\\n            max = 0;\\n\\t\\t\\t// reset max, and do the same while the right height is less than left height\\n            while (left < right && height[right] < height[left]) {\\n                max = Math.max(max, height[right]);\\n                sum += max - height[right];\\n                right--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        if (height.length <= 1) return 0;\\n\\t\\t// start 2 pointers\\n        int left = 0; int right = height.length-1;\\n        int sum = 0;\\n        while (left < right) {\\n            int max = 0;\\n\\t\\t\\t// keep advancing left while height is less/equal to right pointer && we havent reached the right pointer\\n            while (left < right && height[left] <= height[right]) {\\n                max = Math.max(max, height[left]);\\n                sum += max - height[left];\\n                left++;\\n            }\\n            max = 0;\\n\\t\\t\\t// reset max, and do the same while the right height is less than left height\\n            while (left < right && height[right] < height[left]) {\\n                max = Math.max(max, height[right]);\\n                sum += max - height[right];\\n                right--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253442,
                "title": "java-stack-dp",
                "content": "Stack based\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int ans = 0;\\n        \\n        for(int i = 0; i < height.length; i++) {\\n            int right = height[i];\\n            while(!stack.isEmpty() && right > height[stack.peek()]) {\\n                int bottom = height[stack.pop()];\\n                if (stack.isEmpty()) break;\\n                \\n                int left = height[stack.peek()];\\n                int minHeight = Math.min(left, right);\\n                int length = i - stack.peek() - 1;\\n                ans += length * (minHeight - bottom);\\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nDP based\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int N = height.length;\\n        if (N == 0) {\\n            return 0;\\n        }\\n\\n        int[] leftMax = new int[N]; // Max height to left of current bar, inclusive\\n        int[] rightMax = new int[N]; // Max height to right of current bar, inclusive\\n        \\n        leftMax[0] = height[0];\\n        for (int i = 1; i < N; i++) {\\n            leftMax[i] = Math.max(leftMax[i - 1], height[i]);\\n        }\\n        \\n        rightMax[N - 1] = height[N - 1];\\n         for (int i = N - 2; i >= 0; i--) {\\n            rightMax[i] = Math.max(rightMax[i + 1], height[i]);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < N; i++) {\\n            int minHeight = Math.min(leftMax[i], rightMax[i]);\\n            if (minHeight > height[i]) {\\n                ans += minHeight - height[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int ans = 0;\\n        \\n        for(int i = 0; i < height.length; i++) {\\n            int right = height[i];\\n            while(!stack.isEmpty() && right > height[stack.peek()]) {\\n                int bottom = height[stack.pop()];\\n                if (stack.isEmpty()) break;\\n                \\n                int left = height[stack.peek()];\\n                int minHeight = Math.min(left, right);\\n                int length = i - stack.peek() - 1;\\n                ans += length * (minHeight - bottom);\\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int N = height.length;\\n        if (N == 0) {\\n            return 0;\\n        }\\n\\n        int[] leftMax = new int[N]; // Max height to left of current bar, inclusive\\n        int[] rightMax = new int[N]; // Max height to right of current bar, inclusive\\n        \\n        leftMax[0] = height[0];\\n        for (int i = 1; i < N; i++) {\\n            leftMax[i] = Math.max(leftMax[i - 1], height[i]);\\n        }\\n        \\n        rightMax[N - 1] = height[N - 1];\\n         for (int i = N - 2; i >= 0; i--) {\\n            rightMax[i] = Math.max(rightMax[i + 1], height[i]);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < N; i++) {\\n            int minHeight = Math.min(leftMax[i], rightMax[i]);\\n            if (minHeight > height[i]) {\\n                ans += minHeight - height[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203121,
                "title": "simple-python-solution",
                "content": "The water in the current position is trapped if its height is smaller than both of its max left height and max right height.\\n```\\ndef trap(self, h):\\n        n = len(h)\\n        max_lh, max_rh = [0]*(n+1), [0]*(n+1)\\n        for i, x in enumerate(h): max_lh[i] = max(max_lh[i-1], x)\\n        for i, x in reversed(list(enumerate(h))): max_rh[i] = max(max_rh[i+1], x)     \\n        ans = 0\\n        for i, x in enumerate(h): ans += max(0, min(max_lh[i], max_rh[i]) - x)            \\n        return ans",
                "solutionTags": [],
                "code": "The water in the current position is trapped if its height is smaller than both of its max left height and max right height.\\n```\\ndef trap(self, h):\\n        n = len(h)\\n        max_lh, max_rh = [0]*(n+1), [0]*(n+1)\\n        for i, x in enumerate(h): max_lh[i] = max(max_lh[i-1], x)\\n        for i, x in reversed(list(enumerate(h))): max_rh[i] = max(max_rh[i+1], x)     \\n        ans = 0\\n        for i, x in enumerate(h): ans += max(0, min(max_lh[i], max_rh[i]) - x)            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 147142,
                "title": "post-explaining-the-intuition-behind-all-the-approaches",
                "content": "If I ask you to find water trapped at any i th position then you would say that find height of max bar on left and right and then minimum of them and after that subtract bar\\'s height from this minimum.\\nThis is what is followed in all the approaches it just that it tries to cover more than one i \\'s.\\n\\nSol 1) Calculate array of max height going from right to left and then left to right (2 scans)\\nThen for traverse the array again and calulate [ min(leftMax[i],rightMax[i])-height[i] ]  (1 scan)\\n\\n```\\n    public int trap(int[] height) {\\n        int [] leftMax=new int[height.length];\\n        int [] rightMax=new int[height.length];\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<height.length;i++){\\n            if(height[i]>max)\\n                max=height[i];\\n            \\n            leftMax[i]=max;\\n        }\\n        \\n        max=Integer.MIN_VALUE;\\n        \\n        for(int i=height.length-1;i>=0;i--){\\n            if(height[i]>max)\\n                max=height[i]; \\n            \\n            rightMax[i]=max;\\n        }\\n        \\n        int vol=0;\\n        \\n        for(int i=0;i<height.length;i++){\\n              vol=vol+(Math.min(leftMax[i],rightMax[i])-height[i]);      \\n        }\\n      \\n```\\n\\n\\n\\n\\n\\nSol 2) Same as solution 1 but it reduces one scan\\n\\t\\t\\t\\t\\tCalculate array of max height from left to right (1 scan)\\n\\t\\t\\t\\t\\tNow traverse from right to left and calculate max height from right to left and result array         simultaneosly.(1 scan)\\n```\\n public int trap(int[] height) {\\n        int [] leftMax=new int[height.length];\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<height.length;i++){\\n            if(height[i]>max)\\n                max=height[i];\\n            \\n            leftMax[i]=max;\\n        }\\n        \\n        int vol=0;\\n        int maxRightHeight=0;\\n        \\n        for(int i=height.length-1;i>=0;i--){\\n            if(height[i]>maxRightHeight){\\n                 maxRightHeight=height[i];\\n            }  \\n            \\n            vol=vol+(Math.min(leftMax[i],maxRightHeight)-height[i]);      \\n        }\\n        return vol;\\n    }\\n```\\nSol 3) Using Stack (same as Max Histogram Area)\\nRefer to the approach for that problem.\\nHere is just an oulline:\\nAgain the intuition remains the same that is we have to find max walls on either side then its minimum and then remove the cell height which gives water trapped in that cell.\\nSo maintain a stack and starting from i th position push all bars until there is any bar greater or equal to ith......say this position is j. When you reach that point j you know for all bars between i and j, min(height[i],height[j]) is the height of water trapped. Width can be found using (j-i+1).\\n\\n```\\n    public int trap(int[] height) {\\n        Stack<Integer> stack=new Stack<>();\\n        int vol=0;\\n        int i=0;\\n        while(i<height.length){\\n            if(stack.isEmpty() || height[i]<=height[stack.peek()]){\\n                stack.push(i++);\\n            }else{\\n                int curr = stack.pop();\\n                int maxBotWater = stack.isEmpty()?0:(Math.min(height[stack.peek()],height[i])-height[curr])*(i-stack.peek()-1);\\n                vol+= maxBotWater;\\n            }\\n        }\\n        return vol;\\n    }\\n```\\nHope it helps !",
                "solutionTags": [],
                "code": "```\\n    public int trap(int[] height) {\\n        int [] leftMax=new int[height.length];\\n        int [] rightMax=new int[height.length];\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<height.length;i++){\\n            if(height[i]>max)\\n                max=height[i];\\n            \\n            leftMax[i]=max;\\n        }\\n        \\n        max=Integer.MIN_VALUE;\\n        \\n        for(int i=height.length-1;i>=0;i--){\\n            if(height[i]>max)\\n                max=height[i]; \\n            \\n            rightMax[i]=max;\\n        }\\n        \\n        int vol=0;\\n        \\n        for(int i=0;i<height.length;i++){\\n              vol=vol+(Math.min(leftMax[i],rightMax[i])-height[i]);      \\n        }\\n      \\n```\n```\\n public int trap(int[] height) {\\n        int [] leftMax=new int[height.length];\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<height.length;i++){\\n            if(height[i]>max)\\n                max=height[i];\\n            \\n            leftMax[i]=max;\\n        }\\n        \\n        int vol=0;\\n        int maxRightHeight=0;\\n        \\n        for(int i=height.length-1;i>=0;i--){\\n            if(height[i]>maxRightHeight){\\n                 maxRightHeight=height[i];\\n            }  \\n            \\n            vol=vol+(Math.min(leftMax[i],maxRightHeight)-height[i]);      \\n        }\\n        return vol;\\n    }\\n```\n```\\n    public int trap(int[] height) {\\n        Stack<Integer> stack=new Stack<>();\\n        int vol=0;\\n        int i=0;\\n        while(i<height.length){\\n            if(stack.isEmpty() || height[i]<=height[stack.peek()]){\\n                stack.push(i++);\\n            }else{\\n                int curr = stack.pop();\\n                int maxBotWater = stack.isEmpty()?0:(Math.min(height[stack.peek()],height[i])-height[curr])*(i-stack.peek()-1);\\n                vol+= maxBotWater;\\n            }\\n        }\\n        return vol;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17517,
                "title": "java-dp-solution",
                "content": "    public int trap(int[] height) {\\n        int len = height.length;\\n        if(len == 0)    return 0;\\n        int[] maxleft = new int[len];\\n        int[] maxright = new int[len];\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<len;i++){\\n            if(height[i] > max){\\n                max = height[i];\\n            }\\n            maxleft[i] = max;\\n        }\\n        max = Integer.MIN_VALUE;\\n        for(int i=len-1;i>=0;i--){\\n            if(height[i] > max){\\n                max = height[i];\\n            }\\n            maxright[i] = max;\\n        }\\n        int ret = 0;\\n        for(int i=0;i<len;i++){\\n            int diff = Math.min(maxleft[i],maxright[i]) - height[i];\\n            if(diff > 0)    ret += diff;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int trap(int[] height) {\\n        int len = height.length;\\n        if(len == 0)    return 0;\\n        int[] maxleft = new int[len];\\n        int[] maxright = new int[len];\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<len;i++){\\n            if(height[i] > max){\\n                max = height[i];\\n            }\\n            maxleft[i] = max;\\n        }\\n        max = Integer.MIN_VALUE;\\n        for(int i=len-1;i>=0;i--){\\n            if(height[i] > max){\\n                max = height[i];\\n            }\\n            maxright[i] = max;\\n        }\\n        int ret = 0;\\n        for(int i=0;i<len;i++){\\n            int diff = Math.min(maxleft[i],maxright[i]) - height[i];\\n            if(diff > 0)    ret += diff;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4044007,
                "title": "100-detailed-explanation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining using two pointertwo\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis C++ code defines a function called `trap` that calculates the amount of water that can be trapped between a series of vertical bars represented by an input vector `height`. The function implements the two-pointer approach to solve the trapping rainwater problem.\\n\\nHere\\'s a step-by-step explanation of the code:\\n\\n1. `int n = height.size();`: This line calculates the number of elements in the `height` vector, representing the total number of bars.\\n\\n2. `int lmax = height[0];` and `int rmax = height[n-1];`: These two variables `lmax` and `rmax` are initialized with the heights of the first and last bars, respectively. These will represent the maximum heights encountered while moving from left to right and right to left.\\n\\n3. `int lpos = 1;` and `int rpos = n-2;`: These two pointers `lpos` and `rpos` are initialized to point to the second bar from the left and the second bar from the right, respectively. These pointers will be used to traverse the bars inwards.\\n\\n4. `int water = 0;`: This variable `water` is initialized to zero and will be used to accumulate the trapped water.\\n\\n5. The `while` loop continues as long as `lpos` is less than or equal to `rpos`, which means the left pointer has not crossed or met the right pointer.\\n\\n6. Inside the loop, the code checks three conditions:\\n\\n   a. `height[lpos] >= lmax`: If the height of the bar at `lpos` is greater than or equal to `lmax`, it means a new left maximum has been found. In this case, `lmax` is updated, and `lpos` is incremented to move the left pointer to the right.\\n\\n   b. `height[rpos] >= rmax`: If the height of the bar at `rpos` is greater than or equal to `rmax`, it means a new right maximum has been found. In this case, `rmax` is updated, and `rpos` is decremented to move the right pointer to the left.\\n\\n   c. `lmax <= rmax && height[lpos] < lmax`: If neither of the above conditions is met, it means that the current bar at `lpos` can potentially trap water. The code calculates the water trapped at this position by taking the difference between `lmax` and the height of the bar and adds it to the `water` variable. Then, `lpos` is incremented to move the left pointer to the right.\\n\\n   d. If none of the above conditions are met (i.e., `lmax > rmax`), the same calculation is performed using the right pointer, and the result is added to the `water` variable.\\n\\n7. Once the `while` loop finishes, the function returns the total accumulated `water`, which represents the amount of trapped rainwater between the bars.\\n\\nThis code efficiently calculates the amount of trapped water between the bars by maintaining two pointers and tracking the maximum heights encountered from both sides. The time complexity of this algorithm is O(n), where n is the number of bars in the input vector `height`.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), where \\'n\\' is the number of elements in the input vector height. The function uses a two-pointer approach that iterates through the vector once, and each iteration performs constant-time operations. In the worst case, both the left and right pointers traverse the entire array once, leading to linear time complexity.\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is O(1), which means it uses a constant amount of additional space regardless of the size of the input vector. The function only uses a fixed number of integer variables (n, lmax, rmax, lpos, rpos, and water), and the space required for these variables does not depend on the size of the input vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int> &height) {\\n\\n        int n = height.size();\\n        int lmax = height[0];\\n        int rmax = height[n-1];\\n        int lpos = 1;\\n        int rpos = n-2;\\n        int water = 0;\\n\\n        while(lpos <= rpos)\\n        {\\n            if(height[lpos] >= lmax)\\n            {\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax)\\n            {\\n                rmax = height[rpos];\\n                rpos--; \\n            }\\n\\n            else if(lmax <= rmax && height[lpos] < lmax)\\n            {\\n                water += lmax - height[lpos];\\n                lpos++; \\n            }\\n            else{\\n                water += rmax - height[rpos];\\n                rpos--;\\n            }\\n        }\\n        return water;\\n    }\\n};\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/bd5f4f3d-230c-424a-a313-b2828644cbb8_1694697623.8384008.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int> &height) {\\n\\n        int n = height.size();\\n        int lmax = height[0];\\n        int rmax = height[n-1];\\n        int lpos = 1;\\n        int rpos = n-2;\\n        int water = 0;\\n\\n        while(lpos <= rpos)\\n        {\\n            if(height[lpos] >= lmax)\\n            {\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax)\\n            {\\n                rmax = height[rpos];\\n                rpos--; \\n            }\\n\\n            else if(lmax <= rmax && height[lpos] < lmax)\\n            {\\n                water += lmax - height[lpos];\\n                lpos++; \\n            }\\n            else{\\n                water += rmax - height[rpos];\\n                rpos--;\\n            }\\n        }\\n        return water;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006957,
                "title": "100-solved-both-very-simple-way-and-optimized-way-to-solve-trapping-rain-water-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code calculates trapped rainwater by iterating through each element in the input array. For each element, it determines the minimum height of barriers on both sides and calculates the trapped water if the minimum height exceeds the current height. The total trapped water is returned. **However, this simple code can be optimized for efficiency. please find optimized code at bottom setion**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Travel the array from 1 to len(height)\\n\\n    ``` \\n    for i in range ( 1 , len(height) ):\\n    ```\\n* Find Left side maximum buiding height till \\'i\\' index\\n    ```\\n    left_max = max( height [ 0 : i ] )\\n    ```\\n* Find Right side maximum building height from \\'i\\' index\\n    ```\\n    right_max = max ( height [ i : len(height) ] )\\n    ```\\n* Find minimum height from left_max and right_max\\n    ```\\n    min_height = min( left_max , right_max )\\n    ```\\n* If minimum height - height[i] is greater than 0 then add that values to water varieble by substracting element which is at \\'i\\' index.\\n    ```\\n    if(min_height - height[i]) > 0):\\n        water += ( min_height - height[i] )```\\n* Finally return the total stored water\\n    ``` \\n    return water\\n    ```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    For simple code: O(n^2)\\n    For Optimized code : O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    For simple code: O(n)\\n    For Optimized code : O(n)\\n# Code\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        water = 0 \\n        for i in range(1, len(height)):\\n            min_height = min( max(height[0:i]), max(height[i:len(height)]))\\n            if((min_height - height[i]) > 0):\\n                water += (min_height - height[i])\\n        return water\\n```\\n\\n\\n# Optimized Code with O(n) time complexity:\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:\\n            return 0\\n        \\n        left_max, right_max = 0, 0\\n        left, right = 0, len(height) - 1\\n        water = 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                if height[left] > left_max:\\n                    left_max = height[left]\\n                else:\\n                    water += left_max - height[left]\\n                left += 1\\n            else:\\n                if height[right] > right_max:\\n                    right_max = height[right]\\n                else:\\n                    water += right_max - height[right]\\n                right -= 1\\n        \\n        return water\\n```\\n\\n=> Please comment, If you have any questions.\\n\\n\\u2764 Please upvote if you found this usefull \\u2764\\n\\n![fc626f73-c07e-4a16-88f2-99293774ffd1_1686646782.1594946.png](https://assets.leetcode.com/users/images/6e212438-d9ba-4ff5-ac78-8d8f686f3323_1694523001.494244.png)\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "``` \\n    for i in range ( 1 , len(height) ):\\n    ```\n```\\n    left_max = max( height [ 0 : i ] )\\n    ```\n```\\n    right_max = max ( height [ i : len(height) ] )\\n    ```\n```\\n    min_height = min( left_max , right_max )\\n    ```\n```\\n    if(min_height - height[i]) > 0):\\n        water += ( min_height - height[i] )```\n``` \\n    return water\\n    ```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        water = 0 \\n        for i in range(1, len(height)):\\n            min_height = min( max(height[0:i]), max(height[i:len(height)]))\\n            if((min_height - height[i]) > 0):\\n                water += (min_height - height[i])\\n        return water\\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:\\n            return 0\\n        \\n        left_max, right_max = 0, 0\\n        left, right = 0, len(height) - 1\\n        water = 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                if height[left] > left_max:\\n                    left_max = height[left]\\n                else:\\n                    water += left_max - height[left]\\n                left += 1\\n            else:\\n                if height[right] > right_max:\\n                    right_max = height[right]\\n                else:\\n                    water += right_max - height[right]\\n                right -= 1\\n        \\n        return water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603778,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int left(int idx, vector<int>& height) {\\n        int leftMax = INT_MIN;\\n        for (int i = 0; i <= idx; i++) {\\n            leftMax = max (leftMax, height[i]);\\n        }\\n        return leftMax;\\n    }\\n\\n    int right(int idx, vector<int>& height) {\\n        int rightMax = INT_MIN;\\n        for (int i = idx; i < height.size(); i++) {\\n            rightMax = max (rightMax, height[i]);\\n        }\\n        return rightMax;\\n    }\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int waterTrapped = 0;\\n        for (int i = 1; i < n-1; i++) {\\n            int leftMax = left(i, height);\\n            int rightMax = right(i, height);\\n            waterTrapped += min (leftMax, rightMax) - height[i];\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBetter\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int waterTrapped = 0;\\n        vector<int> prefix(n, 0);\\n        prefix[0] = height[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = max (prefix[i-1], height[i]);\\n        }\\n        vector<int> suffix(n, 0);\\n        suffix[n-1] = height[n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            suffix[i] = max (suffix[i+1], height[i]);\\n        }\\n        for (int i = 1; i < n-1; i++) {\\n            waterTrapped += min (prefix[i], suffix[i]) - height[i];\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```\\n\\n# Approach 3\\nEfficient - Two Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n-1;\\n        int waterTrapped = 0;\\n        int leftMax = 0, rightMax = 0;\\n        while (left <= right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax)\\n                    leftMax = height[left];\\n                else\\n                    waterTrapped += leftMax - height[left];\\n                left++;        \\n            } else {\\n                if (height[right] > rightMax)\\n                    rightMax = height[right];\\n                else\\n                    waterTrapped += rightMax - height[right];\\n                right--;\\n            }\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int left(int idx, vector<int>& height) {\\n        int leftMax = INT_MIN;\\n        for (int i = 0; i <= idx; i++) {\\n            leftMax = max (leftMax, height[i]);\\n        }\\n        return leftMax;\\n    }\\n\\n    int right(int idx, vector<int>& height) {\\n        int rightMax = INT_MIN;\\n        for (int i = idx; i < height.size(); i++) {\\n            rightMax = max (rightMax, height[i]);\\n        }\\n        return rightMax;\\n    }\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int waterTrapped = 0;\\n        for (int i = 1; i < n-1; i++) {\\n            int leftMax = left(i, height);\\n            int rightMax = right(i, height);\\n            waterTrapped += min (leftMax, rightMax) - height[i];\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int waterTrapped = 0;\\n        vector<int> prefix(n, 0);\\n        prefix[0] = height[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = max (prefix[i-1], height[i]);\\n        }\\n        vector<int> suffix(n, 0);\\n        suffix[n-1] = height[n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            suffix[i] = max (suffix[i+1], height[i]);\\n        }\\n        for (int i = 1; i < n-1; i++) {\\n            waterTrapped += min (prefix[i], suffix[i]) - height[i];\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n-1;\\n        int waterTrapped = 0;\\n        int leftMax = 0, rightMax = 0;\\n        while (left <= right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax)\\n                    leftMax = height[left];\\n                else\\n                    waterTrapped += leftMax - height[left];\\n                left++;        \\n            } else {\\n                if (height[right] > rightMax)\\n                    rightMax = height[right];\\n                else\\n                    waterTrapped += rightMax - height[right];\\n                right--;\\n            }\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587801,
                "title": "c-stack-very-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& v) {\\n        int n = v.size(),i;\\n        vector<int> l(n,-1),r(n,-1),s;\\n        for(i = 0; i < n; i++){\\n            while(!s.empty()&&s.back()<=v[i]){\\n                s.pop_back();\\n            }\\n            if(!s.empty()){\\n                l[i] = s.back();\\n                if(v[i]>s.back())\\n                s.push_back(v[i]);\\n            }else{\\n                s.push_back(v[i]);\\n            }\\n        }\\n        s.clear();\\n        for(i = n-1; i >= 0; i--){\\n            while(!s.empty()&&s.back()<=v[i]){\\n                s.pop_back();\\n            }\\n            if(!s.empty()){\\n                r[i] = s.back();\\n                if(v[i]>s.back())\\n                s.push_back(v[i]);\\n            }else{\\n                s.push_back(v[i]);\\n            }\\n        }\\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            if(l[i] != -1 && r[i] != -1){\\n                ans += min(l[i],r[i])-v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& v) {\\n        int n = v.size(),i;\\n        vector<int> l(n,-1),r(n,-1),s;\\n        for(i = 0; i < n; i++){\\n            while(!s.empty()&&s.back()<=v[i]){\\n                s.pop_back();\\n            }\\n            if(!s.empty()){\\n                l[i] = s.back();\\n                if(v[i]>s.back())\\n                s.push_back(v[i]);\\n            }else{\\n                s.push_back(v[i]);\\n            }\\n        }\\n        s.clear();\\n        for(i = n-1; i >= 0; i--){\\n            while(!s.empty()&&s.back()<=v[i]){\\n                s.pop_back();\\n            }\\n            if(!s.empty()){\\n                r[i] = s.back();\\n                if(v[i]>s.back())\\n                s.push_back(v[i]);\\n            }else{\\n                s.push_back(v[i]);\\n            }\\n        }\\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            if(l[i] != -1 && r[i] != -1){\\n                ans += min(l[i],r[i])-v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185989,
                "title": "if-anyone-looking-for-a-stack-solution-here-it-is",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to figure out the total water we can trap, A difference of heights, maybe a smaller and a greater one would do the trick but a smaller bar can be smaller than multiple bars or a single tall bar can be taller than multiple smaller bars. So we can calculate total water trapped by each bar by tracking the smaller bars in a stack which contains bars in monotonically decreasing order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPop the elements out of stack if current bar\\'s height is more than the minimum height bar in stack and calculate the water stored in that area and add it to answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans = 0;\\n        for(int i = 0; i < height.length; i++) {\\n            while(!stack.isEmpty() && height[stack.peek()] < height[i]) {\\n                int top = height[stack.peek()];\\n                stack.pop();\\n                if(stack.isEmpty()) break; // Last bar as base cannot store any water.\\n                int width = i - stack.peek() - 1;\\n                int length = Math.min(height[i], height[stack.peek()]) - top;\\n                ans += length * width;\\n                \\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans = 0;\\n        for(int i = 0; i < height.length; i++) {\\n            while(!stack.isEmpty() && height[stack.peek()] < height[i]) {\\n                int top = height[stack.peek()];\\n                stack.pop();\\n                if(stack.isEmpty()) break; // Last bar as base cannot store any water.\\n                int width = i - stack.peek() - 1;\\n                int length = Math.min(height[i], height[stack.peek()]) - top;\\n                ans += length * width;\\n                \\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229309,
                "title": "c-simple-4-solution-o-n-stack-dp-prefix-suffix-2-pointer-brute",
                "content": "```\\nclass Solution {\\npublic:\\n    /*//Brute force finding leftmax and rightmax with 2 loops give TLE TC: O(N^2)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int leftmax = INT_MIN;\\n        int totalwater = 0;\\n        for(int i = 0;i<n;i++){\\n            leftmax = max(leftmax,height[i]);\\n            int rightmax = INT_MIN;\\n            for(int j = n-1;j>=i;j--){\\n                rightmax = max(rightmax,height[j]);\\n            }\\n            totalwater += min(leftmax,rightmax) - height[i];\\n        }\\n        return totalwater;\\n    }\\n    */\\n```\\n```\\n    //Using dp prefixmax and suffixmax vectors SC: O(2N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> prefixmax(n),suffixmax(n);\\n        prefixmax[0] = height[0], suffixmax[n-1] = height[n-1];\\n        int totalwater = 0;\\n        for(int i = 1;i<n;i++){\\n            prefixmax[i] = max(prefixmax[i-1],height[i]);\\n        }\\n        for(int i = n-2;i>=0;i--){\\n            suffixmax[i] = max(suffixmax[i+1],height[i]);\\n        }\\n        for(int i = 0;i<n;i++){\\n            totalwater += min(prefixmax[i],suffixmax[i]) - height[i];\\n        }\\n\\n        return totalwater;\\n    }\\n```\\n```\\n    //Using mono Stack SC: O(N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        stack<int> st;  //store index\\n        int totalwater = 0;\\n        int cur = 0;\\n        while(cur<n){\\n            \\n            while(!st.empty() && height[cur]>height[st.top()]){\\n                int top = st.top();\\n                st.pop();\\n                if(st.empty()) \\n                    break;\\n                \\n                int bounded_height = min(height[cur],height[st.top()]) - height[top];\\n                int bounded_length = cur - st.top() - 1;\\n                \\n                totalwater += bounded_height*bounded_length;\\n                cout<<totalwater<<\" \";\\n            }\\n\\n            st.push(cur++);\\n        }\\n        \\n        return totalwater;\\n    }\\n```\\n```\\n    //Space Optimized 2-pointer approch SC: O(1)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left=0, right=n-1;\\n        int leftmax = INT_MIN, rightmax = INT_MIN;\\n        int totalwater = 0;\\n        \\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=leftmax) leftmax = height[left];\\n                else totalwater += leftmax - height[left];\\n                left++;\\n            }          \\n            else{\\n                if(height[right]>=rightmax) rightmax = height[right];\\n                else totalwater += rightmax - height[right];\\n                right--;\\n            }   \\n        }\\n        \\n        return totalwater;\\n    }  \\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*//Brute force finding leftmax and rightmax with 2 loops give TLE TC: O(N^2)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int leftmax = INT_MIN;\\n        int totalwater = 0;\\n        for(int i = 0;i<n;i++){\\n            leftmax = max(leftmax,height[i]);\\n            int rightmax = INT_MIN;\\n            for(int j = n-1;j>=i;j--){\\n                rightmax = max(rightmax,height[j]);\\n            }\\n            totalwater += min(leftmax,rightmax) - height[i];\\n        }\\n        return totalwater;\\n    }\\n    */\\n```\n```\\n    //Using dp prefixmax and suffixmax vectors SC: O(2N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> prefixmax(n),suffixmax(n);\\n        prefixmax[0] = height[0], suffixmax[n-1] = height[n-1];\\n        int totalwater = 0;\\n        for(int i = 1;i<n;i++){\\n            prefixmax[i] = max(prefixmax[i-1],height[i]);\\n        }\\n        for(int i = n-2;i>=0;i--){\\n            suffixmax[i] = max(suffixmax[i+1],height[i]);\\n        }\\n        for(int i = 0;i<n;i++){\\n            totalwater += min(prefixmax[i],suffixmax[i]) - height[i];\\n        }\\n\\n        return totalwater;\\n    }\\n```\n```\\n    //Using mono Stack SC: O(N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        stack<int> st;  //store index\\n        int totalwater = 0;\\n        int cur = 0;\\n        while(cur<n){\\n            \\n            while(!st.empty() && height[cur]>height[st.top()]){\\n                int top = st.top();\\n                st.pop();\\n                if(st.empty()) \\n                    break;\\n                \\n                int bounded_height = min(height[cur],height[st.top()]) - height[top];\\n                int bounded_length = cur - st.top() - 1;\\n                \\n                totalwater += bounded_height*bounded_length;\\n                cout<<totalwater<<\" \";\\n            }\\n\\n            st.push(cur++);\\n        }\\n        \\n        return totalwater;\\n    }\\n```\n```\\n    //Space Optimized 2-pointer approch SC: O(1)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left=0, right=n-1;\\n        int leftmax = INT_MIN, rightmax = INT_MIN;\\n        int totalwater = 0;\\n        \\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=leftmax) leftmax = height[left];\\n                else totalwater += leftmax - height[left];\\n                left++;\\n            }          \\n            else{\\n                if(height[right]>=rightmax) rightmax = height[right];\\n                else totalwater += rightmax - height[right];\\n                right--;\\n            }   \\n        }\\n        \\n        return totalwater;\\n    }  \\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1933487,
                "title": "readable-javascipt-solution-o-n-time-o-n-space",
                "content": "FYI, this algorithm can be performed without extra memory, but I find this version the easiest to understand.\\n\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    // Create two DP arrays\\n    const max_height_left = new Array(height.length);\\n    const max_height_right = new Array(height.length);\\n    \\n    // Iterate from left to right and for every index i, find the max height to the left of i\\n    max_height_left[0] = height[0];\\n    for(let i = 1; i < height.length; ++i){\\n        max_height_left[i] = Math.max(max_height_left[i-1], height[i]);\\n    }\\n    \\n    // Iterate from right to left and for every index i, find the max height to the right of i\\n    max_height_right[max_height_right.length-1] = height[height.length-1];\\n    for(let i = height.length-2; i>=0; --i){\\n        max_height_right[i] = Math.max(max_height_right[i+1], height[i]);\\n    }\\n    \\n    // Iterate from left to right and find out how much rain water is captured at index i\\n    let water_volume = 0;\\n    for(let i = 0; i < height.length; ++i){\\n        water_volume += Math.min(max_height_left[i], max_height_right[i]) - height[i];\\n    }\\n    \\n    return water_volume;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    // Create two DP arrays\\n    const max_height_left = new Array(height.length);\\n    const max_height_right = new Array(height.length);\\n    \\n    // Iterate from left to right and for every index i, find the max height to the left of i\\n    max_height_left[0] = height[0];\\n    for(let i = 1; i < height.length; ++i){\\n        max_height_left[i] = Math.max(max_height_left[i-1], height[i]);\\n    }\\n    \\n    // Iterate from right to left and for every index i, find the max height to the right of i\\n    max_height_right[max_height_right.length-1] = height[height.length-1];\\n    for(let i = height.length-2; i>=0; --i){\\n        max_height_right[i] = Math.max(max_height_right[i+1], height[i]);\\n    }\\n    \\n    // Iterate from left to right and find out how much rain water is captured at index i\\n    let water_volume = 0;\\n    for(let i = 0; i < height.length; ++i){\\n        water_volume += Math.min(max_height_left[i], max_height_right[i]) - height[i];\\n    }\\n    \\n    return water_volume;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731660,
                "title": "faster-than-90-very-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& ht) {\\n        int sum = 0;\\n        int l = 0;\\n        int r = ht.size()-1;\\n        while(l<r){\\n            if(ht[l]<=ht[r]){\\n                int curr = l;\\n                while(ht[++l] < ht[curr])\\n\\t\\t\\t\\t\\tsum += ht[curr] - ht[l];\\n            }\\n            else{\\n                int curr = r;\\n                while(ht[--r] < ht[curr])\\n\\t\\t\\t\\t\\tsum += ht[curr] - ht[r];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& ht) {\\n        int sum = 0;\\n        int l = 0;\\n        int r = ht.size()-1;\\n        while(l<r){\\n            if(ht[l]<=ht[r]){\\n                int curr = l;\\n                while(ht[++l] < ht[curr])\\n\\t\\t\\t\\t\\tsum += ht[curr] - ht[l];\\n            }\\n            else{\\n                int curr = r;\\n                while(ht[--r] < ht[curr])\\n\\t\\t\\t\\t\\tsum += ht[curr] - ht[r];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668845,
                "title": "java-solution-with-detailed-explanation-intuition-walkthrough",
                "content": "```\\nclass Solution {\\n    /**\\nIf we know the amount of water trapped above each bar. We can sum up these values to determine the total amount of water trapped by the graph. \\n    \\nIn order for water to be trapped, there must be a leftside bar and a rightside bar that traps the water.\\nNotice that the amount of rainwater that can be trapped will be upperbounded by the smaller of these two bars\\n    \\n    Example 1:\\n    _ _\\n    |  |    _ _\\n    |  |    |  |\\n    |  |    |  |\\n    \\nFor these two bars. \\nWe have a height of 3 for the bar on the left and a height of 2 for the bar on the right. \\nThe maximum amount of water we can trap in the middle will be the minimum of these two heights (2).\\n    \\n    \\nNow let us say we wanted to determine the amount of water above the middle bar in this graph. \\n    \\n    Example 2:\\n    _ _\\n    |  |        _ _\\n    |  |  _ _   |  |\\n    |  |  | |   |  |\\n    \\nNow we can see that the maximum amount of water we can trap between the left bar and the right bar is 2 (as we calculated in the previous part). \\nHowever, now since we have a bar in the middle, we can\\'t trap all 2 units of water. \\nWe will only be able to trap 1 unit of water, because the other unit of space is taken up by the bar in the middle.\\n    \\nFrom this, we can derive a formula (which we will later refine) for calculating the amount of water above the ith bar. \\n    \\n    water[i] = min(height_left_bar, height_right_bar) - h[i] (the height of the current bar).\\n    \\n    Now what if we added another bar to the graph. \\n    \\n    Example 3:\\n    _ _               _ _\\n    |  |        _ _   |  |\\n    |  |  _ _   |  |  |  |\\n    |  |  | |   |  |  |  |\\n    \\nNow if we wanted to calculate the amount of water above the bar at index 1, we can see that our left bound remains the same (the bar at index 0).\\nHowever, our right bound is now different. \\nTo trap the most amount of water, our right bound is now the bar at index 3 (as opposed to index 2 in the previous example). \\nWe can see that the minimum height of the two bars (at index 0 and index 3) is 3. \\nNow the amount of water we can trap above the bar at index 1 is  3 - 1 (1 for the height of the bar at index 1 itself) = 2. \\n    \\nThis observation shows us that the amount of water above the ith bar will be the minimum of the maximum height of all bars to the left of the ith bar \\nand the maximum height of all bars to the right of the ith bar. Thus we refine our equation as such. \\n    \\nwater[i] = min(max_height_left_bar, max_height_right_bar) - h[i] (the height of the current bar). \\n    \\nWhat if the height of the current bar is larger than min(max_height_left_bar, max_height_right_bar)\\n    \\n    Example 4: \\n         _ _\\n         | |\\n    _ _  | |  _ _\\n    | |  | |  | |\\n    \\nIn this example, let us use our formula from the previous example to calculate the amount of water above the bar at index 1. \\nThe max_height_left_bar is the bar at index 0 with height 1. \\nThe max_height_right_bar is the bar at index 2 with height 1. \\nAlso the height of the bar at index 1 is 3. Thus, water[1] = min(1, 1) - 3 ==> -2. \\nHowever, we can never trap negative units of rain water, so we already see that something wonky is happening.\\nLets look at the picture. We cannot trap any units of rainwater above the bar at index 1. \\nThis is because if we try to place any water ontop of the bar at index 1 it will either spill to the right or the left. \\nTo generalize this case, if max_height_left_bar is less than the height of the current bar, any rain water placed ontop of the current bar will spill to the left. \\nSimilarly, if max_height_right_bar is less than the height of the current bar,  any rain water placed ontop of the current bar will spill to the right. \\nOr in other words, if the minimum of our max_height_left_bar and max_height_right_bar is less than the current bar height then we can trap 0 units of water. \\n    \\nThus, if our equation to calculate water[i] gives us a negative number we want to round to 0. We cannot trap any rainwater above the current bar\\n    \\nThus, we refine our equation further:\\n    \\nwater[i] = max(min(max_height_left_bar, max_height_right_bar) - h[i] (the height of the current bar), 0)\\n    \\nAfter we enumerate our water array we can sum up all the values to find all the rainwater trapped by the graph\\n    **/\\n    public int trap(int[] height) {\\n        int[] max_height_left_bar = new int[height.length];\\n        \\n        for (int idx = 1; idx < height.length; idx++) {\\n            max_height_left_bar[idx] = Math.max(max_height_left_bar[idx - 1], height[idx - 1]);\\n        }\\n        \\n        int[] max_height_right_bar = new int[height.length];\\n        for (int idx = height.length - 2; idx >= 0; idx--) {\\n            max_height_right_bar[idx] = Math.max(max_height_right_bar[idx + 1], height[idx + 1]);\\n        }\\n        \\n        int[] water = new int[height.length];\\n        for (int idx = 0; idx < water.length; idx++) {\\n            water[idx] = Math.max(Math.min(max_height_left_bar[idx], max_height_right_bar[idx]) - height[idx], 0);\\n        }\\n        \\n        int sol = 0;\\n        for (int idx = 0; idx < water.length; idx++) { \\n            int water_above_current_bar = water[idx];\\n            sol += water_above_current_bar;\\n        }\\n        \\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    /**\\nIf we know the amount of water trapped above each bar. We can sum up these values to determine the total amount of water trapped by the graph. \\n    \\nIn order for water to be trapped, there must be a leftside bar and a rightside bar that traps the water.\\nNotice that the amount of rainwater that can be trapped will be upperbounded by the smaller of these two bars\\n    \\n    Example 1:\\n    _ _\\n    |  |    _ _\\n    |  |    |  |\\n    |  |    |  |\\n    \\nFor these two bars. \\nWe have a height of 3 for the bar on the left and a height of 2 for the bar on the right. \\nThe maximum amount of water we can trap in the middle will be the minimum of these two heights (2).\\n    \\n    \\nNow let us say we wanted to determine the amount of water above the middle bar in this graph. \\n    \\n    Example 2:\\n    _ _\\n    |  |        _ _\\n    |  |  _ _   |  |\\n    |  |  | |   |  |\\n    \\nNow we can see that the maximum amount of water we can trap between the left bar and the right bar is 2 (as we calculated in the previous part). \\nHowever, now since we have a bar in the middle, we can\\'t trap all 2 units of water. \\nWe will only be able to trap 1 unit of water, because the other unit of space is taken up by the bar in the middle.\\n    \\nFrom this, we can derive a formula (which we will later refine) for calculating the amount of water above the ith bar. \\n    \\n    water[i] = min(height_left_bar, height_right_bar) - h[i] (the height of the current bar).\\n    \\n    Now what if we added another bar to the graph. \\n    \\n    Example 3:\\n    _ _               _ _\\n    |  |        _ _   |  |\\n    |  |  _ _   |  |  |  |\\n    |  |  | |   |  |  |  |\\n    \\nNow if we wanted to calculate the amount of water above the bar at index 1, we can see that our left bound remains the same (the bar at index 0).\\nHowever, our right bound is now different. \\nTo trap the most amount of water, our right bound is now the bar at index 3 (as opposed to index 2 in the previous example). \\nWe can see that the minimum height of the two bars (at index 0 and index 3) is 3. \\nNow the amount of water we can trap above the bar at index 1 is  3 - 1 (1 for the height of the bar at index 1 itself) = 2. \\n    \\nThis observation shows us that the amount of water above the ith bar will be the minimum of the maximum height of all bars to the left of the ith bar \\nand the maximum height of all bars to the right of the ith bar. Thus we refine our equation as such. \\n    \\nwater[i] = min(max_height_left_bar, max_height_right_bar) - h[i] (the height of the current bar). \\n    \\nWhat if the height of the current bar is larger than min(max_height_left_bar, max_height_right_bar)\\n    \\n    Example 4: \\n         _ _\\n         | |\\n    _ _  | |  _ _\\n    | |  | |  | |\\n    \\nIn this example, let us use our formula from the previous example to calculate the amount of water above the bar at index 1. \\nThe max_height_left_bar is the bar at index 0 with height 1. \\nThe max_height_right_bar is the bar at index 2 with height 1. \\nAlso the height of the bar at index 1 is 3. Thus, water[1] = min(1, 1) - 3 ==> -2. \\nHowever, we can never trap negative units of rain water, so we already see that something wonky is happening.\\nLets look at the picture. We cannot trap any units of rainwater above the bar at index 1. \\nThis is because if we try to place any water ontop of the bar at index 1 it will either spill to the right or the left. \\nTo generalize this case, if max_height_left_bar is less than the height of the current bar, any rain water placed ontop of the current bar will spill to the left. \\nSimilarly, if max_height_right_bar is less than the height of the current bar,  any rain water placed ontop of the current bar will spill to the right. \\nOr in other words, if the minimum of our max_height_left_bar and max_height_right_bar is less than the current bar height then we can trap 0 units of water. \\n    \\nThus, if our equation to calculate water[i] gives us a negative number we want to round to 0. We cannot trap any rainwater above the current bar\\n    \\nThus, we refine our equation further:\\n    \\nwater[i] = max(min(max_height_left_bar, max_height_right_bar) - h[i] (the height of the current bar), 0)\\n    \\nAfter we enumerate our water array we can sum up all the values to find all the rainwater trapped by the graph\\n    **/\\n    public int trap(int[] height) {\\n        int[] max_height_left_bar = new int[height.length];\\n        \\n        for (int idx = 1; idx < height.length; idx++) {\\n            max_height_left_bar[idx] = Math.max(max_height_left_bar[idx - 1], height[idx - 1]);\\n        }\\n        \\n        int[] max_height_right_bar = new int[height.length];\\n        for (int idx = height.length - 2; idx >= 0; idx--) {\\n            max_height_right_bar[idx] = Math.max(max_height_right_bar[idx + 1], height[idx + 1]);\\n        }\\n        \\n        int[] water = new int[height.length];\\n        for (int idx = 0; idx < water.length; idx++) {\\n            water[idx] = Math.max(Math.min(max_height_left_bar[idx], max_height_right_bar[idx]) - height[idx], 0);\\n        }\\n        \\n        int sol = 0;\\n        for (int idx = 0; idx < water.length; idx++) { \\n            int water_above_current_bar = water[idx];\\n            sol += water_above_current_bar;\\n        }\\n        \\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658509,
                "title": "python-clean-fast-all-4-solutions",
                "content": "```\\nclass Solution:\\n    # O(n^2) time | O(n) space\\n    def trap(self, height: List[int]) -> int:\\n        total = 0\\n        for i, curr in enumerate(height):\\n            left = 0 if i == 0 else max(height[:i])\\n            right = 0 if i == len(height) - 1 else max(height[i+1:])\\n            total += max(0, min(left, right) - curr)\\n    \\n    # O(n) time | O(n) space\\n    def trap(self, height: List[int]) -> int:        \\n        left = [0] * len(height)\\n        for i in range(1, len(height)):\\n            left[i] = max(left[i - 1], height[i - 1])\\n        \\n        right = [0] * len(height)\\n        for i in range(len(height) - 2, -1, -1):\\n            right[i] = max(right[i + 1], height[i + 1])\\n\\n        total = 0\\n        for i, curr in enumerate(height):\\n            total += max(0, min(left[i], right[i]) - curr)        \\n        return total\\n\\n    # O(n) time | O(n) space\\n    def trap(self, height: List[int]) -> int:        \\n        total = 0\\n        stack = []  # monotonic stack\\n        for i, right in enumerate(height):\\n            while stack and right > height[stack[-1]]:\\n                curr = height[stack.pop()]\\n                if not stack:\\n                    break\\n                j, left = stack[-1], height[stack[-1]]\\n                volume = min(left, right) - curr\\n                total += volume * (i - j - 1)\\n            stack.append(i)\\n        return total\\n\\n    # O(n) time | O(1) space\\n    def trap(self, height: List[int]) -> int:\\n        max_left = max_right = 0\\n        left, right = 0, len(height) - 1\\n\\n        total = 0\\n        while left < right:\\n            max_left = max(max_left, height[left])\\n            max_right = max(max_right, height[right])\\n            if height[left] <= height[right]:\\n                total += max_left - height[left]\\n                left += 1\\n            else:\\n                total += max_right - height[right]\\n                right -= 1\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    # O(n^2) time | O(n) space\\n    def trap(self, height: List[int]) -> int:\\n        total = 0\\n        for i, curr in enumerate(height):\\n            left = 0 if i == 0 else max(height[:i])\\n            right = 0 if i == len(height) - 1 else max(height[i+1:])\\n            total += max(0, min(left, right) - curr)\\n    \\n    # O(n) time | O(n) space\\n    def trap(self, height: List[int]) -> int:        \\n        left = [0] * len(height)\\n        for i in range(1, len(height)):\\n            left[i] = max(left[i - 1], height[i - 1])\\n        \\n        right = [0] * len(height)\\n        for i in range(len(height) - 2, -1, -1):\\n            right[i] = max(right[i + 1], height[i + 1])\\n\\n        total = 0\\n        for i, curr in enumerate(height):\\n            total += max(0, min(left[i], right[i]) - curr)        \\n        return total\\n\\n    # O(n) time | O(n) space\\n    def trap(self, height: List[int]) -> int:        \\n        total = 0\\n        stack = []  # monotonic stack\\n        for i, right in enumerate(height):\\n            while stack and right > height[stack[-1]]:\\n                curr = height[stack.pop()]\\n                if not stack:\\n                    break\\n                j, left = stack[-1], height[stack[-1]]\\n                volume = min(left, right) - curr\\n                total += volume * (i - j - 1)\\n            stack.append(i)\\n        return total\\n\\n    # O(n) time | O(1) space\\n    def trap(self, height: List[int]) -> int:\\n        max_left = max_right = 0\\n        left, right = 0, len(height) - 1\\n\\n        total = 0\\n        while left < right:\\n            max_left = max(max_left, height[left])\\n            max_right = max(max_right, height[right])\\n            if height[left] <= height[right]:\\n                total += max_left - height[left]\\n                left += 1\\n            else:\\n                total += max_right - height[right]\\n                right -= 1\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533802,
                "title": "java-2-pointers-intuition-detailed-explanation-with-diagrams",
                "content": "**Intuition:**\\n\\nLet us consider the below example. We can take any particular height in the provided array and try to calculate the capacity of water that it can store and extend that understanding to solve the rest of the problem.\\n\\n```\\n\\theight = [2,1,3]\\n\\n\\t3|    _\\n\\t2|_  | |\\n\\t1| |_| |\\n\\t0|_____|\\n\\t  0 1 2  \\n```\\n\\n- The maximum water that can be stored at any point `1` is the minimum of height of right of `1` (height of `2`, i.e. 3) and height of left of `1` (height of `0`, i.e. 2) minus the height of `1`. This comes to `min(3,2) - height[1] = 2 - 1 = 1`. So the maximum water that we can store in position `1`  is 1. \\n\\n- The same can be done for the position `0` and position `2` as well. Since the left of `0` and right of `2` does not have anything specified, so we can assume that the height of left of `0` and right of `2` is always `0`, which always makes these two positions incapable of storing water as the minimum height of either positions is going to be `0`. \\n\\n- At any point of time if we calculate `min of (left-height, right-height) - curr-height` to be less than `0`, which means negative capacity, this essentially implies that we cannot store any water at this position and we can safely make it as `0`.\\n\\nBased on this intuition we can extend our thought process to the following example which has more than one positions is which water can be stored. In the earlier example for calculating the amount of water that can be trapped in only 1 position is `min(left-height, right-height) - height[curr]`, but we cannot blindly do that when we have multiple pockets in which water can be trapped. In such case, instead of checking the immediate left we check what is the height of the max element left of current and similarly we do for the right one as well. The minimum of these 2 minus the current height will again give the amount of water that can be trapped in that particular position. We\\'ll discuss 3 approaches for the same intuition as we optimize our solution along the way.\\n\\n<br/>\\n\\n**Approach 1: O(N^2) Time, O(1) Space**\\n\\n- A brute-force way of doing this would be to go and get the max of left and max of right for each position and then do the same calculation to calculate the amount of water that can be trapped at a particular position. This would mean that for every height in the array we need to traverse through all the elements in the array to get these 2 values. This will make the overall time complexity of the solution to be O(N^2).\\n\\n\\t**Code:**\\n\\n\\t```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint total = 0;\\n\\n\\t\\t\\tfor(int i=0; i < len; i++){\\n\\t\\t\\t\\tint lMax = 0, rMax = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++)\\n\\t\\t\\t\\t\\tlMax = Math.max(lMax, height[j]);\\n\\t\\t\\t\\tfor(int j = i+1; j < len; j++)\\n\\t\\t\\t\\t\\trMax = Math.max(rMax, height[j]);\\n\\t\\t\\t\\tint capacity = Math.min(lMax, rMax) - height[i];\\n\\t\\t\\t\\tif (capacity > 0)\\n\\t\\t\\t\\t\\ttotal += capacity;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```\\n\\n<br/>\\n\\n**Approach 2: O(N) Time, O(N) Space**\\n\\n- We can optimize it by pre-computing the left-max at each position and right-max at each position and store it in some data-structure. Then we simply iterate thru the `height` array and calculate the capacity to store water at each position based on the above mentioned calculation. This way we\\'ll need an additional O(N) space, but our time complexity reduces to O(N). A visual computation details is provided below.\\n\\n\\t```\\n\\theight = [4,2,0,3,2,5]\\n\\tleft      0 4 4 4 4 4   // max left at each position\\n\\tright     5 5 5 5 5 0   // max right at each position\\n\\t-----------------------\\n\\t  min     0 4 4 4 4 0   // min of right and left\\n\\t- height  4 2 0 3 2 5   // height of each index\\n\\t-----------------------\\n\\tcapacity  0 2 4 1 2 0   // negative capacity can be made as 0 \\n\\t-----------------------\\n\\ttotal       9           // adding all individual capacities\\n\\t-----------------------\\n\\n\\t5|          _\\n\\t4|_        |\\n\\t3| |    _  |\\n\\t2| |_  | |_|\\n\\t1|   | |\\n\\t0|___|_|_____\\n\\t  0 1 2 3 4 5\\n\\t```    \\n\\n\\t**Code:**\\n\\t```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint[] left = new int[len];\\n\\t\\t\\tint[] right = new int[len];\\n\\n\\t\\t\\tfor(int i=0, j=len-1, lMax=0, rMax=0; i < len; i++, j--){\\n\\t\\t\\t\\tleft[i] = lMax;\\n\\t\\t\\t\\tright[j] = rMax;\\n\\t\\t\\t\\tlMax = Math.max(lMax, height[i]);\\n\\t\\t\\t\\trMax = Math.max(rMax, height[j]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tfor(int i=0; i < len; i++) {\\n\\t\\t\\t\\tint capacity = Math.min(left[i], right[i]) - height[i];\\n\\t\\t\\t\\tif (capacity > 0)\\n\\t\\t\\t\\t\\ttotal += capacity;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```\\n\\n<br/>\\n\\n**Approach 3: O(N) Time, O(1) Space**\\n- We can optimize the above solution to use O(1) space by using 2 pointers which maintains the left max and the right max. We place 2 pointers at the either end of the array. At any point of time in the array either one can be min (or equal). We use the min (or equal) of the two values to do the above computation at any point. This will make sense if we see how we did this thing for our previous solution. We computed the left max and right max at each position and then found the min of that. Similarly, in this case while traversing thru the array, if `leftMax <= rightMax` at any point of time, this implies whatever happens in future traversal when we move the pointers, definitely the current `leftMax` is going to be less than or equal to `rightMax`. The same would have applied for the other condition as well when `rightMax <= leftMax`.\\n- On computing the capacity at a particular position we identify which of the 2 pointers is lower and we increment that. If it is equal then we\\'ll increment left. We could have decremented right pointer when equal as well, but we need to be consistent in a way. Below is the code for this final approach.\\n\\n\\t**Code:**\\n\\t```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tint lMax = 0, rMax = 0;\\n\\t\\t\\tint capacity = 0;\\n\\n\\t\\t\\tfor(int s=0, e=len-1; s <= e; ){\\n\\t\\t\\t\\tif(lMax <= rMax) {\\n\\t\\t\\t\\t\\tcapacity = lMax - height[s];\\n\\t\\t\\t\\t\\tif(capacity > 0) \\n\\t\\t\\t\\t\\t   total += capacity;\\n\\t\\t\\t\\t\\tlMax = Math.max(lMax, height[s]);\\n\\t\\t\\t\\t\\ts++;                \\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcapacity = rMax - height[e];\\n\\t\\t\\t\\t\\tif(capacity > 0)\\n\\t\\t\\t\\t\\t   total += capacity;\\n\\t\\t\\t\\t\\trMax = Math.max(rMax, height[e]); \\n\\t\\t\\t\\t\\te--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\theight = [2,1,3]\\n\\n\\t3|    _\\n\\t2|_  | |\\n\\t1| |_| |\\n\\t0|_____|\\n\\t  0 1 2  \\n```\n```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint total = 0;\\n\\n\\t\\t\\tfor(int i=0; i < len; i++){\\n\\t\\t\\t\\tint lMax = 0, rMax = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++)\\n\\t\\t\\t\\t\\tlMax = Math.max(lMax, height[j]);\\n\\t\\t\\t\\tfor(int j = i+1; j < len; j++)\\n\\t\\t\\t\\t\\trMax = Math.max(rMax, height[j]);\\n\\t\\t\\t\\tint capacity = Math.min(lMax, rMax) - height[i];\\n\\t\\t\\t\\tif (capacity > 0)\\n\\t\\t\\t\\t\\ttotal += capacity;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\theight = [4,2,0,3,2,5]\\n\\tleft      0 4 4 4 4 4   // max left at each position\\n\\tright     5 5 5 5 5 0   // max right at each position\\n\\t-----------------------\\n\\t  min     0 4 4 4 4 0   // min of right and left\\n\\t- height  4 2 0 3 2 5   // height of each index\\n\\t-----------------------\\n\\tcapacity  0 2 4 1 2 0   // negative capacity can be made as 0 \\n\\t-----------------------\\n\\ttotal       9           // adding all individual capacities\\n\\t-----------------------\\n\\n\\t5|          _\\n\\t4|_        |\\n\\t3| |    _  |\\n\\t2| |_  | |_|\\n\\t1|   | |\\n\\t0|___|_|_____\\n\\t  0 1 2 3 4 5\\n\\t```\n```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint[] left = new int[len];\\n\\t\\t\\tint[] right = new int[len];\\n\\n\\t\\t\\tfor(int i=0, j=len-1, lMax=0, rMax=0; i < len; i++, j--){\\n\\t\\t\\t\\tleft[i] = lMax;\\n\\t\\t\\t\\tright[j] = rMax;\\n\\t\\t\\t\\tlMax = Math.max(lMax, height[i]);\\n\\t\\t\\t\\trMax = Math.max(rMax, height[j]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tfor(int i=0; i < len; i++) {\\n\\t\\t\\t\\tint capacity = Math.min(left[i], right[i]) - height[i];\\n\\t\\t\\t\\tif (capacity > 0)\\n\\t\\t\\t\\t\\ttotal += capacity;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tint lMax = 0, rMax = 0;\\n\\t\\t\\tint capacity = 0;\\n\\n\\t\\t\\tfor(int s=0, e=len-1; s <= e; ){\\n\\t\\t\\t\\tif(lMax <= rMax) {\\n\\t\\t\\t\\t\\tcapacity = lMax - height[s];\\n\\t\\t\\t\\t\\tif(capacity > 0) \\n\\t\\t\\t\\t\\t   total += capacity;\\n\\t\\t\\t\\t\\tlMax = Math.max(lMax, height[s]);\\n\\t\\t\\t\\t\\ts++;                \\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcapacity = rMax - height[e];\\n\\t\\t\\t\\t\\tif(capacity > 0)\\n\\t\\t\\t\\t\\t   total += capacity;\\n\\t\\t\\t\\t\\trMax = Math.max(rMax, height[e]); \\n\\t\\t\\t\\t\\te--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1440622,
                "title": "trapping-rain-water-two-pointer-solution-with-explanation",
                "content": "Approach is to calculate water level at each elevation from both ends, \\n\\n```\\nclass Solution:\\n\\tdef trap(self, height: List[int]) -> int:\\n          \\n        lp = 0\\n        rp = len(height) - 1\\n        max_left, max_right, water = 0, 0, 0\\n        \\n        while lp <= rp:\\n            \\n            if height[lp] <= height[rp]:\\n                if max_left > height[lp]:\\n                    water += max_left - height[lp]\\n                else:\\n                    max_left = height[lp]\\n                \\n                lp += 1\\n            else:\\n                if max_right > height[rp]:\\n                    water += max_right - height[rp]\\n                else:\\n                    max_right = height[rp]\\n                \\n                rp -= 1\\n                \\n        return water\\n```\\n\\n**Lets break down the code....**\\n\\n```\\nclass Solution:\\n\\tdef trap(self, height: List[int]) -> int:\\n          \\n        lp = 0                                      # lp (left pointer) points to first index (left most elevation)\\n        rp = len(height) - 1                # rp (right pointer) points to last index (right most elevation), these two pointers just move\\n        max_left, max_right, water = 0, 0, 0     # max_left (elevation of tallest left side neighbours\\' building), max_right(elevation of tallest right side neighbours\\' building), water?\\n        \\n        while lp <= rp:                                   # like any two pointer solution, it is way to control the loop based on pointer movements, do not forget to keep the pointer movements (infinity war!) \\n            \\n\\t # if..else... they both work exactly the same way at different ends, but how? lets see!\\n\\t \\n            if height[lp] <= height[rp]:             # first, it **assures** that on the right side of neighbour, there is a building whose elevation is at least same as the height of where **lp** is or larger than it (no need to be a very adjacent building)\\n\\t\\t\\t\\n\\t\\t\\t# with the assurance given, there is a wall to hold the water from right, we entered into the if.., we now just need to find out is there a wall on left to hold water     \\n\\t\\t\\t\\n                if max_left > height[lp]:            #max_left says, it is larger than where lp is!, it has just given the second **assurance** that it can hold the water from left end,  \\n                    water += max_left - height[lp]     # finally after two assurances or both side checks we should calculate the water level\\n\\t\\t\\t\\t\\t\\n                else:              # max_left says oops!, if its elevation is not larger than the height where lp is, then height of lp is to be considered as max_left\\n                    max_left = height[lp]          # like max_left says, change to height where lp is now as max_left\\n                \\n                lp += 1          # lp moves to the right of neighbourhood space by space until it crosses path with rp (space!, what if there is no building) \\n            else:                 # like it is said above, what happenend to lp just happens in rp terms\\n\\t\\t\\t\\n\\t\\t\\t# entered into else!, means there is a larger building on the left from rp, thats an assurance, now just need whats on right side\\n                if max_right > height[rp]:    # just like max_left, max_right says, it is larger than where rp is!, it has just given the second **assurance** that it can hold the water from right end\\n                    water += max_right - height[rp]     # finally after two assurances or both side checks we should calculate the water level\\n                else:                  # max_right says oops too!, if its elevation is not larger than the height where rp is, then height of rp is to be considered as max_right\\n                    max_right = height[rp]           # like max_rights says, change to height where lp is now as max_left\\n                \\n                rp -= 1            # rp moves to the left of neighbourhood space by space until it crosses paths with lp.\\n                \\n        return water           # its flooded :D  \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n\\tdef trap(self, height: List[int]) -> int:\\n          \\n        lp = 0\\n        rp = len(height) - 1\\n        max_left, max_right, water = 0, 0, 0\\n        \\n        while lp <= rp:\\n            \\n            if height[lp] <= height[rp]:\\n                if max_left > height[lp]:\\n                    water += max_left - height[lp]\\n                else:\\n                    max_left = height[lp]\\n                \\n                lp += 1\\n            else:\\n                if max_right > height[rp]:\\n                    water += max_right - height[rp]\\n                else:\\n                    max_right = height[rp]\\n                \\n                rp -= 1\\n                \\n        return water\\n```\n```\\nclass Solution:\\n\\tdef trap(self, height: List[int]) -> int:\\n          \\n        lp = 0                                      # lp (left pointer) points to first index (left most elevation)\\n        rp = len(height) - 1                # rp (right pointer) points to last index (right most elevation), these two pointers just move\\n        max_left, max_right, water = 0, 0, 0     # max_left (elevation of tallest left side neighbours\\' building), max_right(elevation of tallest right side neighbours\\' building), water?\\n        \\n        while lp <= rp:                                   # like any two pointer solution, it is way to control the loop based on pointer movements, do not forget to keep the pointer movements (infinity war!) \\n            \\n\\t # if..else... they both work exactly the same way at different ends, but how? lets see!\\n\\t \\n            if height[lp] <= height[rp]:             # first, it **assures** that on the right side of neighbour, there is a building whose elevation is at least same as the height of where **lp** is or larger than it (no need to be a very adjacent building)\\n\\t\\t\\t\\n\\t\\t\\t# with the assurance given, there is a wall to hold the water from right, we entered into the if.., we now just need to find out is there a wall on left to hold water     \\n\\t\\t\\t\\n                if max_left > height[lp]:            #max_left says, it is larger than where lp is!, it has just given the second **assurance** that it can hold the water from left end,  \\n                    water += max_left - height[lp]     # finally after two assurances or both side checks we should calculate the water level\\n\\t\\t\\t\\t\\t\\n                else:              # max_left says oops!, if its elevation is not larger than the height where lp is, then height of lp is to be considered as max_left\\n                    max_left = height[lp]          # like max_left says, change to height where lp is now as max_left\\n                \\n                lp += 1          # lp moves to the right of neighbourhood space by space until it crosses path with rp (space!, what if there is no building) \\n            else:                 # like it is said above, what happenend to lp just happens in rp terms\\n\\t\\t\\t\\n\\t\\t\\t# entered into else!, means there is a larger building on the left from rp, thats an assurance, now just need whats on right side\\n                if max_right > height[rp]:    # just like max_left, max_right says, it is larger than where rp is!, it has just given the second **assurance** that it can hold the water from right end\\n                    water += max_right - height[rp]     # finally after two assurances or both side checks we should calculate the water level\\n                else:                  # max_right says oops too!, if its elevation is not larger than the height where rp is, then height of rp is to be considered as max_right\\n                    max_right = height[rp]           # like max_rights says, change to height where lp is now as max_left\\n                \\n                rp -= 1            # rp moves to the left of neighbourhood space by space until it crosses paths with lp.\\n                \\n        return water           # its flooded :D  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254143,
                "title": "java-dynamic-program-o-n-time-and-space-with-explanation",
                "content": "**Algorithm:**\\n1. For each element in height array, create maximum left array i.e., what is the maximum left bar for every each element.\\n2. For each element in height array, create maximum right array i.e., what is the maximum right bar for every each element.\\n3. Iterate height array for each bar, use below formula to find volume of rain water sitting at each bar:\\n\\t\\t\\t ***Volume at bar : Minimum(Maximum Left of the bar, Maximum Right of the bar) x Height of the bar x Width***\\n\\t\\t\\t \\n**Note:** \\n\\t1. Width of each bar is 1 as per description.\\n\\t2. Minimum of max left and max right is taken as water level is retained by lowest height.\\n\\t\\n\\t\\n```\\nclass Solution {\\n    \\n    public int trap(int[] height) {\\n        \\n        //base condition\\n        if(height.length==0)\\n            return 0;\\n        \\n        int volume = 0;\\n        int[] maxLeft = new int[height.length];\\n        int[] maxRight = new int[height.length];\\n        \\n        maxLeft = createMaxLeft(height,maxLeft);\\n        maxRight = createMaxRight(height,maxRight);\\n        \\n        //calculate volume at each bar using formule : min(maxLeft,maxRight)-height\\n        for(int i=1;i<height.length-1;i++){\\n            int barVolume = Math.min(maxLeft[i],maxRight[i])-height[i];\\n            if(barVolume>0)\\n                volume += barVolume;\\n        }\\n        \\n        return volume;\\n    }\\n    \\n    //Dynamic Programming to calculate left max array\\n    private int[] createMaxLeft(int[] height, int[] maxLeft){\\n        maxLeft[0] = 0;\\n        for(int i=1;i<height.length;i++)\\n           maxLeft[i] = Math.max(height[i-1],maxLeft[i-1]); \\n        return maxLeft;\\n    }\\n    \\n     //Dynamic Programming to calculate right max array\\n    private int[] createMaxRight(int[] height, int[] maxRight){\\n        int n = height.length-1;\\n        maxRight[n] = 0;\\n         for(int i=n-1;i>=0;i--)\\n           maxRight[i] = Math.max(height[i+1],maxRight[i+1]); \\n        return maxRight;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int trap(int[] height) {\\n        \\n        //base condition\\n        if(height.length==0)\\n            return 0;\\n        \\n        int volume = 0;\\n        int[] maxLeft = new int[height.length];\\n        int[] maxRight = new int[height.length];\\n        \\n        maxLeft = createMaxLeft(height,maxLeft);\\n        maxRight = createMaxRight(height,maxRight);\\n        \\n        //calculate volume at each bar using formule : min(maxLeft,maxRight)-height\\n        for(int i=1;i<height.length-1;i++){\\n            int barVolume = Math.min(maxLeft[i],maxRight[i])-height[i];\\n            if(barVolume>0)\\n                volume += barVolume;\\n        }\\n        \\n        return volume;\\n    }\\n    \\n    //Dynamic Programming to calculate left max array\\n    private int[] createMaxLeft(int[] height, int[] maxLeft){\\n        maxLeft[0] = 0;\\n        for(int i=1;i<height.length;i++)\\n           maxLeft[i] = Math.max(height[i-1],maxLeft[i-1]); \\n        return maxLeft;\\n    }\\n    \\n     //Dynamic Programming to calculate right max array\\n    private int[] createMaxRight(int[] height, int[] maxRight){\\n        int n = height.length-1;\\n        maxRight[n] = 0;\\n         for(int i=n-1;i>=0;i--)\\n           maxRight[i] = Math.max(height[i+1],maxRight[i+1]); \\n        return maxRight;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946345,
                "title": "cpp-clear-dp-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n=height.size();\\n        if(n==0)\\n            return 0;\\n        int dp[n],val=0;\\n        for(int i=0;i<n;i++){\\n            val=max(val,height[i]);\\n            dp[i]=val;\\n        }\\n        val=0;\\n        for(int i=n-1;i>=0;i--){\\n            val=max(val,height[i]);\\n            dp[i]=min(dp[i],val);\\n        }\\n        val=0;\\n        for(int i=0;i<n;i++)\\n            val+=dp[i]-height[i];\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n=height.size();\\n        if(n==0)\\n            return 0;\\n        int dp[n],val=0;\\n        for(int i=0;i<n;i++){\\n            val=max(val,height[i]);\\n            dp[i]=val;\\n        }\\n        val=0;\\n        for(int i=n-1;i>=0;i--){\\n            val=max(val,height[i]);\\n            dp[i]=min(dp[i],val);\\n        }\\n        val=0;\\n        for(int i=0;i<n;i++)\\n            val+=dp[i]-height[i];\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412574,
                "title": "java-o-n-solution-based-on-monotonous-stack-with-image-explanation",
                "content": "The basic idea is to use a monotonous stack to keep the bars of decreasing height. \\n\\nWe maintain a stack which is decreasing in \"height\" value and processing like below: \\nOnce we encounter an element that\\'s taller than the current stack top element, we know that the stack top element will be a potential \"bottom\" of the area that can hold water. \\n\\nSo we pop the top element from the stack. In this case, the next elements in the stack that is greater than the \"bottom\" element (left bar), as well as the currently checking element (the right bar), will form an area that can hold water.\\n\\nThe capacity formed will be *height x width*, where: \\n* heigth = min(left, right) - bottom\\n* width = right idx -left idx -1\\n\\n\\nWith the example given in the problem description, below image explains what will happen when processing elements with index 6 and 7:\\n![image](https://assets.leetcode.com/users/isaacjumac/image_1571937715.png)\\n\\n\\nAccepted solution:\\n```\\nclass Solution {\\n    public int trap(int[] H) {\\n        int n = H.length;\\n        if(n == 0) return 0;\\n        Stack<Integer> stk = new Stack<>();\\n        int capacity = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            while(!stk.isEmpty() && H[stk.peek()] < H[i]){\\n                int low = stk.pop();\\n                if(!stk.isEmpty()){\\n                    int depth = Math.min(H[stk.peek()], H[i])-H[low];\\n                    int width = i-stk.peek()-1;\\n                    capacity += depth*width;\\n                } \\n            }\\n            if(stk.isEmpty() || H[stk.peek()] >= H[i]){\\n                stk.push(i);\\n            }\\n        }\\n        \\n        return capacity;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trap(int[] H) {\\n        int n = H.length;\\n        if(n == 0) return 0;\\n        Stack<Integer> stk = new Stack<>();\\n        int capacity = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            while(!stk.isEmpty() && H[stk.peek()] < H[i]){\\n                int low = stk.pop();\\n                if(!stk.isEmpty()){\\n                    int depth = Math.min(H[stk.peek()], H[i])-H[low];\\n                    int width = i-stk.peek()-1;\\n                    capacity += depth*width;\\n                } \\n            }\\n            if(stk.isEmpty() || H[stk.peek()] >= H[i]){\\n                stk.push(i);\\n            }\\n        }\\n        \\n        return capacity;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388140,
                "title": "python-sliding-window-with-explanation",
                "content": "This is just another sliding window problem; we need to iterate through an array and find the maximum amount of rain water that can be trapped between two heights (sliding window problems always deal with finding the min/max in some string or array).\\n\\nWe\\'ll actually keep track of 2 windows, one approaching from the left and one approaching from the right.\\n\\nThe algorithm works as follows:\\n\\nWe advance the left window as long as left_max (the tallest height we\\'ve encountered in the left window so far) is <= right_max (the tallest height encountered so far in the right window). The right window works the same way - we are always advancing the window that has the smaller maximum height (otherwise we would be added more units of water than is actually trapped).\\n\\nWhile advancing the left window, if height[left] < left_max on a given iteration, then we add the difference in heights to trapped_water. Otherwise, left_max = height[left] and we add 0 to trapped_water.  The right window works the same way.\\n\\n```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n\\t    # left advances the left window, right advances the right window\\n        left, right = 0, len(height) - 1\\n\\n\\t\\t# left_max keeps track of the tallest height the left pointer has encountered,\\n\\t\\t# right_max keeps track of the tallest height the right pointer has encountered,\\n\\t\\t# and trapped_water keeps track of the number of units of trapped rain water\\n\\t\\tleft_max = right_max = trapped_water = 0\\n\\t\\t\\n\\t\\twhile left < right:\\n\\t\\t    # get the current highest evelation on the left and right windows\\n\\t\\t    left_max = max(left_max, height[left])\\n\\t\\t\\tright_max = max(right_max, height[right])\\n\\t\\t\\t\\n\\t\\t\\t# the smaller height side is the maximum amount of rain water that can be trapped\\n\\t\\t\\t# (otherwise we would incorrectly add water that would spill over the smaller height side),\\n\\t\\t\\t# so add the number of units of water trapped from the smaller height side\\n\\t\\t\\tif left_max <= right_max:\\n\\t\\t\\t    # this will add the water trapped in height[left] relative to the tallest height we\\'ve seen on\\n\\t\\t\\t\\t# the left side so far\\n\\t\\t\\t\\t# if left_max was previously smaller than height[left], this will be 0\\n\\t\\t\\t    trapped_water += left_max - height[left]\\n\\t\\t\\t\\tleft += 1\\n\\t\\t    else:\\n\\t\\t\\t    trapped_wter += right_max - height[right]\\n\\t\\t\\t\\tright -= 1\\n\\t    \\n\\t\\treturn trapped_water\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n\\t    # left advances the left window, right advances the right window\\n        left, right = 0, len(height) - 1\\n\\n\\t\\t# left_max keeps track of the tallest height the left pointer has encountered,\\n\\t\\t# right_max keeps track of the tallest height the right pointer has encountered,\\n\\t\\t# and trapped_water keeps track of the number of units of trapped rain water\\n\\t\\tleft_max = right_max = trapped_water = 0\\n\\t\\t\\n\\t\\twhile left < right:\\n\\t\\t    # get the current highest evelation on the left and right windows\\n\\t\\t    left_max = max(left_max, height[left])\\n\\t\\t\\tright_max = max(right_max, height[right])\\n\\t\\t\\t\\n\\t\\t\\t# the smaller height side is the maximum amount of rain water that can be trapped\\n\\t\\t\\t# (otherwise we would incorrectly add water that would spill over the smaller height side),\\n\\t\\t\\t# so add the number of units of water trapped from the smaller height side\\n\\t\\t\\tif left_max <= right_max:\\n\\t\\t\\t    # this will add the water trapped in height[left] relative to the tallest height we\\'ve seen on\\n\\t\\t\\t\\t# the left side so far\\n\\t\\t\\t\\t# if left_max was previously smaller than height[left], this will be 0\\n\\t\\t\\t    trapped_water += left_max - height[left]\\n\\t\\t\\t\\tleft += 1\\n\\t\\t    else:\\n\\t\\t\\t    trapped_wter += right_max - height[right]\\n\\t\\t\\t\\tright -= 1\\n\\t    \\n\\t\\treturn trapped_water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17396,
                "title": "c-solution-left-right-shrink-sealevel-increases",
                "content": "```\\npublic class Solution \\n{\\n    public int Trap(int[] height) \\n    {\\n        var left = 0;\\n        var right = height.Length - 1;\\n\\n        var result = 0;\\n\\n        var seaLevel = 0;\\n\\n        while(left < right)\\n        {\\n            var leftHeight = height[left];\\n            var rightHeight = height[right];\\n\\n            if (leftHeight < seaLevel)\\n            {\\n                result += seaLevel - leftHeight;\\n            }\\n\\n            if (rightHeight < seaLevel)\\n            {\\n                result += seaLevel - rightHeight;\\n            }\\n\\n            seaLevel = Math.Max(seaLevel, Math.Min(leftHeight, rightHeight));\\n\\n            if (leftHeight < rightHeight)\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int Trap(int[] height) \\n    {\\n        var left = 0;\\n        var right = height.Length - 1;\\n\\n        var result = 0;\\n\\n        var seaLevel = 0;\\n\\n        while(left < right)\\n        {\\n            var leftHeight = height[left];\\n            var rightHeight = height[right];\\n\\n            if (leftHeight < seaLevel)\\n            {\\n                result += seaLevel - leftHeight;\\n            }\\n\\n            if (rightHeight < seaLevel)\\n            {\\n                result += seaLevel - rightHeight;\\n            }\\n\\n            seaLevel = Math.Max(seaLevel, Math.Min(leftHeight, rightHeight));\\n\\n            if (leftHeight < rightHeight)\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17546,
                "title": "c-stack-based-solution-inspired-by-largest-histogram-problem",
                "content": "C++ Stack-based solution inspired by largest histogram problem.\\n\\n    class Solution {\\n    public:\\n        int trap(vector<int>& height) {\\n            stack<int> s;\\n            int N = height.size();\\n            if (N < 3) return 0;\\n            int area = 0;\\n            for ( int i = 0 ; i < N; ++i){\\n                while (!s.empty() && height[i] > height[ s.top() ] ){\\n                    int low_h = height[s.top()];\\n                    s.pop();\\n                    if (!s.empty()) {\\n                        int w = i - s.top() - 1;\\n                        int h = min(height[i], height[s.top()]) - low_h;\\n                        area += w*h;\\n                    }\\n                }\\n                s.push(i);\\n            }\\n            return area;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trap(vector<int>& height) {\\n            stack<int> s;\\n            int N = height.size();\\n            if (N < 3) return 0;\\n            int area = 0;\\n            for ( int i = 0 ; i < N; ++i){\\n                while (!s.empty() && height[i] > height[ s.top() ] ){\\n                    int low_h = height[s.top()];\\n                    s.pop();\\n                    if (!s.empty()) {\\n                        int w = i - s.top() - 1;\\n                        int h = min(height[i], height[s.top()]) - low_h;\\n                        area += w*h;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 17566,
                "title": "here-is-my-ac-code-hope-be-helpful",
                "content": "i point to the left-most non-zero data and j point to the right-most non-zero data. if left is less than the right one, it means that if i go from left to right, if a data is less than A[i], of course it is less than the right one, so we can add the diff(current and the left one), if a data is greater than A[i], move the left one to i, and compare A[i] and A[j]again to find the less one. If A[j] is less, we can do in the similar way.\\n \\n\\n    class Solution {\\n        public:\\n            int trap(int A[], int n) {\\n                 int i = 0; \\n        \\t\\t int j = n - 1;\\n        \\t\\t int count = 0;\\n        \\t\\t while (A[i] == 0) ++i;\\n        \\t\\t while (A[j] == 0) --j;\\n        \\t\\t while (i < j)\\n        \\t\\t {\\n        \\t\\t\\t if (A[i] < A[j])\\n        \\t\\t\\t {\\n        \\t\\t\\t\\t int p = i;\\n        \\t\\t\\t\\t ++i;\\n        \\t\\t\\t\\t while (i < j && A[i] < A[p])\\n        \\t\\t\\t\\t\\t count += A[p] - A[i++];\\n        \\t\\t\\t }\\n        \\t\\t\\t else\\n        \\t\\t\\t {\\n        \\t\\t\\t\\t int p = j;\\n        \\t\\t\\t\\t --j;\\n        \\t\\t\\t\\t while (i < j && A[j] < A[p])\\n        \\t\\t\\t\\t\\t count += A[p] - A[j--];\\n        \\n        \\t\\t\\t }\\n        \\t\\t }\\n        \\t\\t return count;   \\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int trap(int A[], int n) {\\n                 int i = 0; \\n        \\t\\t int j = n - 1;\\n        \\t\\t int count = 0;\\n        \\t\\t while (A[i] == 0) ++i;\\n        \\t\\t while (A[j] == 0) --j;\\n        \\t\\t while (i < j)\\n        \\t\\t {\\n        \\t\\t\\t if (A[i] < A[j])\\n        \\t\\t\\t {\\n        \\t\\t\\t\\t int p = i;\\n        \\t\\t\\t\\t ++i;\\n        \\t\\t\\t\\t while (i < j && A[i] < A[p])\\n        \\t\\t\\t\\t\\t count += A[p] - A[i++];\\n        \\t\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 3882264,
                "title": "beginner-friendly-o-n-approach-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst when will the rain water be trapped between to blocks...\\ncase 1 ) When one block is bigger than other with some space in betweem them \\n\\ncase 2 ) when both blocks are of same size and there is some space between them\\n\\nLet us consider case 1 with an example[4,2,0,3,2,5] \\nFor the 1st element i.e 4 \\n->The left big block is itselt of size 4 && the right biggest block is of size 5\\n->For now let us ignore all the remaining blocks,The water being trapped between the blocks 4 and 5 will definetely have a height of 4 with some width\\n->Now let us also consider the remaining blocks between them of size less than left big block and right big block,They are immersed in the rainwater of height 4\\n->Now difinetely the water above each block is 4 - height of that particular block (For better understanding draw a graph on the paper)\\n\\n->Now u get the water being trapped between the 4 and 5\\n\\n\\n-->The same applies for the remaining blocks\\n\\nFor that simply use 2 arrays to store the left biggest boundary and right biggest boundary of each block\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the left biggest of each element and store it in an array using for loop\\n\\nAnd then find the right biggest of each block and store it in another array using another for loop\\n\\nUse another for loop to calculate the number of units of rain water trapped between or above each block\\n\\ncount += (minimum(leftblock and right block) - height of the current block)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)+O(n)+O(n) = O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUsing constant space\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int[] lmax = new int[height.length];\\n        int[] rmax = new int[height.length];\\n        int max = Integer.MIN_VALUE;\\n        // Finding Left Max \\n        for (int i = 0;i < height.length;i++){\\n            if (max < height[i]){\\n                max = height[i];\\n            }\\n            lmax[i] = max;\\n        }\\n        max = Integer.MIN_VALUE;\\n        // Finding Right Max\\n        for (int i = height.length -1;i >= 0;i--){\\n            if (max < height[i]){\\n                max = height[i];\\n            }\\n            rmax[i] = max;\\n        }\\n        // Finding how many units of rain water is trapped\\n        int count = 0;\\n        for (int i = 0;i < height.length;i++){\\n            count += (Math.min(lmax[i],rmax[i]) - height[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int[] lmax = new int[height.length];\\n        int[] rmax = new int[height.length];\\n        int max = Integer.MIN_VALUE;\\n        // Finding Left Max \\n        for (int i = 0;i < height.length;i++){\\n            if (max < height[i]){\\n                max = height[i];\\n            }\\n            lmax[i] = max;\\n        }\\n        max = Integer.MIN_VALUE;\\n        // Finding Right Max\\n        for (int i = height.length -1;i >= 0;i--){\\n            if (max < height[i]){\\n                max = height[i];\\n            }\\n            rmax[i] = max;\\n        }\\n        // Finding how many units of rain water is trapped\\n        int count = 0;\\n        for (int i = 0;i < height.length;i++){\\n            count += (Math.min(lmax[i],rmax[i]) - height[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876989,
                "title": "2-similar-but-different-o-1-approaches-3-best-solutions-beats-100",
                "content": "# Code\\n```\\n// Solution 1 - 2 for loops - SC O(1)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        int ans = 0, currTop = 0, final = 0;\\n        for(int i = 0; i<h.size(); i++){\\n            if(h[i] < h[currTop]){\\n                ans += h[currTop] - h[i];\\n            }\\n            else{\\n                currTop = i;\\n                final += ans;\\n                ans = 0;\\n            }\\n        }\\n        ans = 0;\\n        int prevTop = currTop;\\n        currTop = h.size()-1;\\n        for(int i = currTop; i>=prevTop; i--){\\n            if(h[i] < h[currTop]){\\n                ans += h[currTop] - h[i];\\n            }\\n            else{\\n                currTop = i;\\n                final += ans;\\n                ans = 0;\\n            }\\n        }\\n        return final;\\n    }\\n};\\n\\n// Solution 2 - Two pointer approach - SC O(1)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size(), lmax = height[0], rmax = height[n-1];\\n        int lpos = 1, rpos = n-2, ans = 0;\\n        while(lpos <= rpos){\\n            if(height[lpos] >= lmax){\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax){\\n                rmax = height[rpos];\\n                rpos--;\\n            }\\n            else if(lmax <= rmax && height[lpos] < lmax){\\n                ans += lmax - height[lpos];\\n                lpos++;\\n            }\\n            else{\\n                ans += rmax - height[rpos];\\n                rpos--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 3 - Stack - SC O(N)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        if(height.empty()) \\n            return 0; \\n        \\n        int res = 0;\\n        stack<int> s;   \\n        for(int i=0; i<height.size(); i++) {\\n            while(!s.empty() && height[i] > height[s.top()]) {\\n                int rightIdx = s.top();\\n                s.pop();\\n                \\n                if(s.empty()) \\n                    break;\\n                \\n                int leftIdx = s.top();\\n                int length = min(height[i], height[leftIdx]) - height[rightIdx];\\n                int breadth = i - leftIdx - 1;\\n                res += length*breadth;\\n            }\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n// Solution 1 - 2 for loops - SC O(1)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        int ans = 0, currTop = 0, final = 0;\\n        for(int i = 0; i<h.size(); i++){\\n            if(h[i] < h[currTop]){\\n                ans += h[currTop] - h[i];\\n            }\\n            else{\\n                currTop = i;\\n                final += ans;\\n                ans = 0;\\n            }\\n        }\\n        ans = 0;\\n        int prevTop = currTop;\\n        currTop = h.size()-1;\\n        for(int i = currTop; i>=prevTop; i--){\\n            if(h[i] < h[currTop]){\\n                ans += h[currTop] - h[i];\\n            }\\n            else{\\n                currTop = i;\\n                final += ans;\\n                ans = 0;\\n            }\\n        }\\n        return final;\\n    }\\n};\\n\\n// Solution 2 - Two pointer approach - SC O(1)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size(), lmax = height[0], rmax = height[n-1];\\n        int lpos = 1, rpos = n-2, ans = 0;\\n        while(lpos <= rpos){\\n            if(height[lpos] >= lmax){\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax){\\n                rmax = height[rpos];\\n                rpos--;\\n            }\\n            else if(lmax <= rmax && height[lpos] < lmax){\\n                ans += lmax - height[lpos];\\n                lpos++;\\n            }\\n            else{\\n                ans += rmax - height[rpos];\\n                rpos--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 3 - Stack - SC O(N)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        if(height.empty()) \\n            return 0; \\n        \\n        int res = 0;\\n        stack<int> s;   \\n        for(int i=0; i<height.size(); i++) {\\n            while(!s.empty() && height[i] > height[s.top()]) {\\n                int rightIdx = s.top();\\n                s.pop();\\n                \\n                if(s.empty()) \\n                    break;\\n                \\n                int leftIdx = s.top();\\n                int length = min(height[i], height[leftIdx]) - height[rightIdx];\\n                int breadth = i - leftIdx - 1;\\n                res += length*breadth;\\n            }\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748096,
                "title": "o-n-solution-arrays-basic-approach-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Initialize `totalwater` to 0 and `n` to the length of the `height` array.\\n\\n2. Create two arrays, `left` and `right`, to store the maximum heights on the left and right side of each building.\\n\\n3. Calculate `left` and `right` arrays.\\n\\n4. Iterate through each building and calculate the trapped water above it by comparing the minimum of the maximum heights on both sides with the building\\'s height.\\n\\n5. Accumulate the trapped water to get the total trapped water.\\n\\n6. Return the total trapped water as the result.\\n\\nThis approach uses precomputed maximum heights on both sides of each building to determine how much rainwater can be trapped between them.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int totalwater=0;\\n        int n=height.length;\\n    int left[]=new int[n];\\n    int right[]=new int[n];\\n\\n    left[0]=height[0];\\n    for(int i=1;i<=n-1;i++){\\n        left[i]=Math.max(left[i-1],height[i]);\\n    }\\n    right[n-1]=height[n-1];\\n    for(int i=n-2;i>=0;i--){\\n        right[i]=Math.max(right[i+1],height[i]);\\n    }\\n\\n    for(int i=0;i<n-1;i++){\\n        int water=0;\\n        int ht=Math.min(left[i],right[i]);\\n        if(ht>=height[i]){\\n            water=ht-height[i];\\n            totalwater+=water;\\n        }\\n            \\n        \\n    }\\n    return totalwater;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int totalwater=0;\\n        int n=height.length;\\n    int left[]=new int[n];\\n    int right[]=new int[n];\\n\\n    left[0]=height[0];\\n    for(int i=1;i<=n-1;i++){\\n        left[i]=Math.max(left[i-1],height[i]);\\n    }\\n    right[n-1]=height[n-1];\\n    for(int i=n-2;i>=0;i--){\\n        right[i]=Math.max(right[i+1],height[i]);\\n    }\\n\\n    for(int i=0;i<n-1;i++){\\n        int water=0;\\n        int ht=Math.min(left[i],right[i]);\\n        if(ht>=height[i]){\\n            water=ht-height[i];\\n            totalwater+=water;\\n        }\\n            \\n        \\n    }\\n    return totalwater;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593596,
                "title": "rust-two-pointers-simple-solution",
                "content": "TBH, i didn\\'t understand why do we need to keep `left_max` and `right_max` and don\\'t have 1 variable `pool_height` instead.\\n\\n```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let (mut left, mut right) = (0, height.len() - 1);\\n        let mut pool_height = 0;\\n        let mut trapped = 0;\\n        \\n        while left < right {\\n            pool_height = pool_height.max(height[left].min(height[right]));\\n            \\n            if height[left] <= height[right] {\\n                trapped += 0.max(pool_height - height[left]);\\n                left += 1;\\n            } else {\\n                trapped += 0.max(pool_height - height[right]);\\n                right -= 1;\\n            }\\n        }\\n        \\n        trapped\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let (mut left, mut right) = (0, height.len() - 1);\\n        let mut pool_height = 0;\\n        let mut trapped = 0;\\n        \\n        while left < right {\\n            pool_height = pool_height.max(height[left].min(height[right]));\\n            \\n            if height[left] <= height[right] {\\n                trapped += 0.max(pool_height - height[left]);\\n                left += 1;\\n            } else {\\n                trapped += 0.max(pool_height - height[right]);\\n                right -= 1;\\n            }\\n        }\\n        \\n        trapped\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590906,
                "title": "c-use-two-pointers-o-1-extra-space",
                "content": "**Please upvote if it helps :)**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) \\n    {\\n        int n = arr.size(), left=0, right=n-1;\\n        int left_max=0, right_max=0, res=0;\\n        \\n        while(left<=right)\\n        {\\n            if(arr[left]<=arr[right])\\n            {\\n                if(arr[left]>=left_max) left_max = arr[left];\\n                \\n                else res += left_max - arr[left];\\n\\n                left++;\\n            }\\n            else\\n            {\\n                if(arr[right]>=right_max) right_max = arr[right];\\n                \\n                else res += right_max - arr[right];\\n                \\n                right--;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) \\n    {\\n        int n = arr.size(), left=0, right=n-1;\\n        int left_max=0, right_max=0, res=0;\\n        \\n        while(left<=right)\\n        {\\n            if(arr[left]<=arr[right])\\n            {\\n                if(arr[left]>=left_max) left_max = arr[left];\\n                \\n                else res += left_max - arr[left];\\n\\n                left++;\\n            }\\n            else\\n            {\\n                if(arr[right]>=right_max) right_max = arr[right];\\n                \\n                else res += right_max - arr[right];\\n                \\n                right--;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685178,
                "title": "stack-based-approach",
                "content": "**Approach**\\n\\nWe\\'ll keep inserting the block\\'s index to stack until we found\\ncurrently iterated element is greater than element at top of stack\\n\\nonce we found that case we\\'ll calculater the sum of the water \\naccumulated by each of the block \\n\\nNote that when we encounter the higher block we actually \\ncalculates the water accumulated by block at top of stack\\n\\nand repeatedly do this task for all blocks inside our stack\\'s top\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        stack<int> st; //we\\'ll work with indexes\\n        int water = 0;\\n        \\n        \\n        for(int i=0; i<n; i++)\\n        {\\n\\t\\t\\n\\t\\t\\t//we found the potential container\\n            while(!st.empty() && arr[i] > arr[st.top()])\\n            {\\n                //take the required block on which we\\'ll calculate\\n                int curr = st.top(); \\n                st.pop();\\n                \\n                //means there is no support on left side \\n                //no container is formed\\n                if(st.empty())\\n                    break;                \\n                \\n                int d = i-st.top()-1;\\n                int h = min(arr[i],arr[st.top()]) - arr[curr];\\n                \\n                water += d*h;\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return water;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        stack<int> st; //we\\'ll work with indexes\\n        int water = 0;\\n        \\n        \\n        for(int i=0; i<n; i++)\\n        {\\n\\t\\t\\n\\t\\t\\t//we found the potential container\\n            while(!st.empty() && arr[i] > arr[st.top()])\\n            {\\n                //take the required block on which we\\'ll calculate\\n                int curr = st.top(); \\n                st.pop();\\n                \\n                //means there is no support on left side \\n                //no container is formed\\n                if(st.empty())\\n                    break;                \\n                \\n                int d = i-st.top()-1;\\n                int h = min(arr[i],arr[st.top()]) - arr[curr];\\n                \\n                water += d*h;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1679662,
                "title": "brute-force-to-optimal-solution-3-approach-stack-dp-2-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n//optimal approach : 2 pointer\\n// T.C :O(n) && S.C : O(1)\\n    int trap(vector<int>& height) {\\n        int n=height.size();\\n        int left = 0;\\n        int leftmax=0;\\n        int right = n-1;\\n        int rightmax = 0;\\n        int ans=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=leftmax)leftmax = height[left];\\n                else{\\n                  ans+=leftmax-height[left];  \\n                }\\n                left++;\\n            }else{\\n                if(height[right]>=rightmax)rightmax=height[right];\\n                else{\\n                    ans+=rightmax-height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n   // using 2 arrays :  T.C :O(n) && S.C : O(n)\\n   \\n\\t int trap(vector<int>& height) {\\n     int n=height.size();\\n        int* left= new int[n];\\n        int* right=new int[n];\\n        left[0]=height[0];\\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i-1],height[i]);\\n        }\\n        right[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i+1],height[i]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(left[i],right[i])-height[i];\\n        }\\n        return ans;\\n}\\n //using stack  T.C :O(n) && S.C : O(n) \\n  int trap(vector<int>& v) {\\n        int n=v.size();\\n        stack<int> s;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            while(!s.empty()&&v[s.top()]<v[i]){\\n                int cur=s.top();\\n                s.pop();\\n                if(s.empty())break;\\n                int diff=i-s.top()-1;\\n                ans+=(min(v[s.top()],v[i])-v[cur])*diff;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//optimal approach : 2 pointer\\n// T.C :O(n) && S.C : O(1)\\n    int trap(vector<int>& height) {\\n        int n=height.size();\\n        int left = 0;\\n        int leftmax=0;\\n        int right = n-1;\\n        int rightmax = 0;\\n        int ans=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=leftmax)leftmax = height[left];\\n                else{\\n                  ans+=leftmax-height[left];  \\n                }\\n                left++;\\n            }else{\\n                if(height[right]>=rightmax)rightmax=height[right];\\n                else{\\n                    ans+=rightmax-height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n   // using 2 arrays :  T.C :O(n) && S.C : O(n)\\n   \\n\\t int trap(vector<int>& height) {\\n     int n=height.size();\\n        int* left= new int[n];\\n        int* right=new int[n];\\n        left[0]=height[0];\\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i-1],height[i]);\\n        }\\n        right[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i+1],height[i]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(left[i],right[i])-height[i];\\n        }\\n        return ans;\\n}\\n //using stack  T.C :O(n) && S.C : O(n) \\n  int trap(vector<int>& v) {\\n        int n=v.size();\\n        stack<int> s;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            while(!s.empty()&&v[s.top()]<v[i]){\\n                int cur=s.top();\\n                s.pop();\\n                if(s.empty())break;\\n                int diff=i-s.top()-1;\\n                ans+=(min(v[s.top()],v[i])-v[cur])*diff;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518914,
                "title": "c-straightforward-and-intuitive-solution",
                "content": "**The explaination is straightforward if we don\\'t complicate stuffs ... I started to think of using stack , do DP and all ..but  those approaches were more complex than the two pointer one !!\\n\\n#### Intuition should come from the pretty basic thing that water gonna get trapped only if there is a bar in between at least 2 bars and both those bars should be greater than the one in considertaion ... So , to start with , we should take left_maxm=H[0] and right_maxm at H[n-1] and we will make left_pointer point to 1st index and right_pointer point to 2nd last one and then we will start moving with lp if(rightmaxm>leftmaxm) or with rp if(leftmaxm>rightmaxm)... and water gonna get trapped for some bar at ith index is gonna be (min(leftmaxm,rightmaxm) - H[i]) and then we will increment the lp or rp (depending on with which pointer we were moving)... if at some point, we come across an index where H[i] is > leftmaxm then we just update the leftmaxm things will keep moving forward like this !!\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& H) {\\n        \\n        int lp=1, rp=H.size()-2, leftmaxm=H[0], rightmaxm=H[H.size()-1],res=0;\\n        \\n        while(lp<=rp){\\n            if(leftmaxm<rightmaxm){\\n                if(H[lp]<leftmaxm)res+=(leftmaxm-H[lp]);\\n                else leftmaxm=H[lp];\\n                lp++;\\n            }\\n            else{\\n                if(H[rp]<rightmaxm)res+=(rightmaxm-H[rp]);\\n                else rightmaxm=H[rp];\\n                rp--;\\n            }\\n        }\\n        return res;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& H) {\\n        \\n        int lp=1, rp=H.size()-2, leftmaxm=H[0], rightmaxm=H[H.size()-1],res=0;\\n        \\n        while(lp<=rp){\\n            if(leftmaxm<rightmaxm){\\n                if(H[lp]<leftmaxm)res+=(leftmaxm-H[lp]);\\n                else leftmaxm=H[lp];\\n                lp++;\\n            }\\n            else{\\n                if(H[rp]<rightmaxm)res+=(rightmaxm-H[rp]);\\n                else rightmaxm=H[rp];\\n                rp--;\\n            }\\n        }\\n        return res;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1498913,
                "title": "javascript-explained-brute-force-optimised-dp-solution",
                "content": "# Brute force approach\\n1. For every index, find amount of water stored\\n2. Find the left max and right max where left max is maximum height of building to the left and maximum height of the building to the right\\n3. So amount of water stored will be\\n4. Amount of water stored at any index = minimum(leftMax for currentIndex, rightMax for currentIndex) - height of building at currentIndex.\\n5. Time Complexity - O(n^2) because for every index we are moving from i to 0 to find leftMax and from i to n - 1 to find rightMax so we are traversing whole array for every index so it makes an nested loop so O(n^2) will be T.C\\n6. Space Complexity - O(1)\\n\\n# Optimised - Prefix Sum\\n1. Find max height(prefix sum) of building travesing from left of array\\n2. Find max height(prefix sum) of building travesing from right of array.\\n3. Then for current index look for prefix sum from both arrays and find the amount of water stored at that point.\\n4. Time Complexity - O(n)\\n5. Space complexity - O(n)\\n\\n```\\nvar trap = function(height) {\\n    const len = height.length\\n    \\n    let prefixMax = new Array(len).fill(0);\\n    let suffixMax = new Array(len).fill(0);\\n    \\n    prefixMax[0] = height[0];\\n    suffixMax[len - 1] = height[len - 1];\\n    \\n    let result = 0;\\n    \\n    for(let i = 1; i < len; i++) {\\n        prefixMax[i] = Math.max(height[i], prefixMax[i - 1])\\n    }\\n    \\n    for(let i = len - 2; i >= 0; i--) {\\n        suffixMax[i] = Math.max(height[i], suffixMax[i + 1])\\n    }\\n    \\n    for(let i = 0; i < len; i++) {\\n        result += Math.min(prefixMax[i], suffixMax[i]) - height[i]\\n    }\\n    return result;\\n};\\n```\\n\\n# Optimised -  Two Pointers Solution\\n1. Time Complexity - O(n)\\n2. Space Complexity - O(1) \\n\\n```\\nvar trap = function(height) {\\n    let leftMax = 0;\\n    let rightMax = 0;\\n    let result = 0;\\n    let left = 0;\\n    let right = height.length - 1;\\n    \\n    while(left <= right) {\\n        leftMax = Math.max(leftMax, height[left]);\\n        rightMax = Math.max(rightMax, height[right]);\\n        \\n        if(height[left] < height[right]) {\\n            result += leftMax - height[left++];\\n        } else {\\n            result += rightMax - height[right--];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nvar trap = function(height) {\\n    const len = height.length\\n    \\n    let prefixMax = new Array(len).fill(0);\\n    let suffixMax = new Array(len).fill(0);\\n    \\n    prefixMax[0] = height[0];\\n    suffixMax[len - 1] = height[len - 1];\\n    \\n    let result = 0;\\n    \\n    for(let i = 1; i < len; i++) {\\n        prefixMax[i] = Math.max(height[i], prefixMax[i - 1])\\n    }\\n    \\n    for(let i = len - 2; i >= 0; i--) {\\n        suffixMax[i] = Math.max(height[i], suffixMax[i + 1])\\n    }\\n    \\n    for(let i = 0; i < len; i++) {\\n        result += Math.min(prefixMax[i], suffixMax[i]) - height[i]\\n    }\\n    return result;\\n};\\n```\n```\\nvar trap = function(height) {\\n    let leftMax = 0;\\n    let rightMax = 0;\\n    let result = 0;\\n    let left = 0;\\n    let right = height.length - 1;\\n    \\n    while(left <= right) {\\n        leftMax = Math.max(leftMax, height[left]);\\n        rightMax = Math.max(rightMax, height[right]);\\n        \\n        if(height[left] < height[right]) {\\n            result += leftMax - height[left++];\\n        } else {\\n            result += rightMax - height[right--];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479391,
                "title": "java-easy-solution-1ms-beats-89-solutions",
                "content": "Do a dry run by yourself you will easily understand it \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n\\t\\n\\t\\n        int [] maxl=new int[height.length];\\n        int [] maxr=new int [height.length];\\n        //Setting up maximum left array\\n        maxl[0]=height[0];\\n        for(int i=1;i<height.length;i++){\\n            maxl[i]=Math.max(maxl[i-1],height[i]);\\n        }\\n\\t\\t\\n\\t\\t\\n//         setting up for maximum right array\\n\\n\\n        maxr[height.length-1]=height[height.length-1];\\n        for(int i=height.length-2;i>=0;i--){\\n            maxr[i]=Math.max(maxr[i+1],height[i]);\\n        }\\n             \\n        int [] water=new int[height.length];\\n        for(int i=0;i<water.length;i++){\\n            water[i]=Math.min(maxl[i],maxr[i])-height[i];\\n        }\\n        int ttlwater=0;\\n        for(int a:water){\\n            ttlwater+=a;\\n        }\\n        return ttlwater;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int trap(int[] height) {\\n\\t\\n\\t\\n        int [] maxl=new int[height.length];\\n        int [] maxr=new int [height.length];\\n        //Setting up maximum left array\\n        maxl[0]=height[0];\\n        for(int i=1;i<height.length;i++){\\n            maxl[i]=Math.max(maxl[i-1],height[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1316038,
                "title": "c-all-3-approaches-naive-better-best-easy-understanding-with-explanation",
                "content": "### **Please Upvote if it helps!!**\\n*if in case, any doubts, please ask!*\\n# **Idea**\\nAn element of the array can store water if there are higher bars on left and right. We can find the amount of water to be stored in every element by finding the heights of bars on left and right sides. The idea is to compute the amount of water that can be stored in every element of array. For example, consider the array {3, 0, 0, 2, 0, 4}, we can store three units of water at indexes 1 and 2, and one unit of water at index 3, and three units of water at index 4.\\n# **Approaches:**\\n## **1. Naive Approach -> O(n2)  (better than 5%)**\\n\\nA Simple Solution is to traverse every array element and find the highest bars on left and right sides. Take the smaller of two heights. The difference between the smaller height and height of the current element is the amount of water that can be stored in this array element. Time complexity of this solution is O(n2).\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        if(height.size() < 2)\\n            return 0;\\n        int res = 0; // To store the maximum water that can be stored \\n\\t\\t// For every element of the array \\n        for(int i = 1; i < height.size() -1; i++)\\n        {\\n            int left= height[i];\\n\\t\\t\\t// Find the maximum element on its left \\n            for(int j = 0; j< i; j++)\\n            {\\n                left = max(left, height[j]);\\n            }\\n\\t\\t\\t\\n            int right = height[i];\\n\\t\\t\\t// Find the maximum element on its right    \\n            for(int j = i + 1; j< height.size(); j++)\\n            {\\n                right = max(right, height[j]);\\n            }\\n\\t\\t\\t// Update the maximum water  \\n            res += min(left, right) - height[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n## **2. Better Approach -> O(n) (Similar to DP) (better than 85%)**\\nAn element of an array can store water if there are higher bars on left and right. We can find the amount of water to be stored in every element by finding the heights of bars on the left and right sides. The idea is to compute the amount of water that can be stored in every element of the array. For example, consider the array {3, 0, 0, 2, 0, 4}, we can store two units of water at indexes 1 and 2, and one unit of water at index 2.\\nPre-compute highest bar on left and right of every bar in O(n) time. Then use these pre-computed values to find the amount of water in every array element.\\n\\n```\\nclass Solution {\\npublic:\\n// Logic is same as above naive approach just we are storing the values first in 1 go so TC reduces\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        if(n<2)\\n            return 0;\\n        vector<int> left(n,0), right(n,0); // for Storing max height values from left and right\\n        left[0] = height[0];\\n        right[n-1] = height[n-1];\\n        for(int i = 1; i< n; i++)\\n        {\\n            left[i] = max(height[i], left[i-1]); \\n        }\\n        for(int i = n-2; i>=0; i--)\\n        {\\n            right[i] = max(height[i], right[i+1]);\\n        }\\n        int watercap = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            watercap += min(left[i], right[i]) - height[i]; // Same logic as above\\n        }\\n        return watercap;       \\n    }\\n};\\n```\\n\\n## **3. Best Approach -> O(n) (Two pointer approach) (better than 100%)**\\nUse the two pointer approach. Loop from index 0 to the end of the given array. If a wall greater than or equal to the previous wall is encountered then make note of the index of that wall in a var called previndex. Keep adding previous wall\\u2019s height minus the current (ith) wall to the variable water. Have a temporary variable that stores the same value as water. If no wall greater than or equal to the previous wall is found then quit. If previndex < size of the input array then subtract the temp variable from water, and loop from end of the input array to prev_index and find a wall greater than or equal to the previous wall (in this case, the last wall from backwards).\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        if(n<2)\\n            return 0;\\n        int water = 0; // To store the final ans\\n        int lMax = 0, rMax = 0; // to store the current max height of the left side and the right side.\\n        int lo = 0, hi = n-1; //Counter to traverse from the left side and from the right side\\n        \\n        while(lo<= hi)\\n        {\\n            if(height[lo] < height[hi])\\n            {\\n                if(height[lo] > lMax) \\n                    lMax = height[lo]; // Updating left_max\\n                else\\n                    water += lMax - height[lo]; // Calculating the ans\\n                lo++;\\n            }\\n            else\\n            {\\n                if(height[hi] > rMax)\\n                    rMax = height[hi]; // Updating right_max\\n                else\\n                    water += rMax - height[hi]; // Calculating the ans\\n                hi--;\\n            }\\n        }\\n        return water; // done!\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        if(height.size() < 2)\\n            return 0;\\n        int res = 0; // To store the maximum water that can be stored \\n\\t\\t// For every element of the array \\n        for(int i = 1; i < height.size() -1; i++)\\n        {\\n            int left= height[i];\\n\\t\\t\\t// Find the maximum element on its left \\n            for(int j = 0; j< i; j++)\\n            {\\n                left = max(left, height[j]);\\n            }\\n\\t\\t\\t\\n            int right = height[i];\\n\\t\\t\\t// Find the maximum element on its right    \\n            for(int j = i + 1; j< height.size(); j++)\\n            {\\n                right = max(right, height[j]);\\n            }\\n\\t\\t\\t// Update the maximum water  \\n            res += min(left, right) - height[i];\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n// Logic is same as above naive approach just we are storing the values first in 1 go so TC reduces\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        if(n<2)\\n            return 0;\\n        vector<int> left(n,0), right(n,0); // for Storing max height values from left and right\\n        left[0] = height[0];\\n        right[n-1] = height[n-1];\\n        for(int i = 1; i< n; i++)\\n        {\\n            left[i] = max(height[i], left[i-1]); \\n        }\\n        for(int i = n-2; i>=0; i--)\\n        {\\n            right[i] = max(height[i], right[i+1]);\\n        }\\n        int watercap = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            watercap += min(left[i], right[i]) - height[i]; // Same logic as above\\n        }\\n        return watercap;       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        if(n<2)\\n            return 0;\\n        int water = 0; // To store the final ans\\n        int lMax = 0, rMax = 0; // to store the current max height of the left side and the right side.\\n        int lo = 0, hi = n-1; //Counter to traverse from the left side and from the right side\\n        \\n        while(lo<= hi)\\n        {\\n            if(height[lo] < height[hi])\\n            {\\n                if(height[lo] > lMax) \\n                    lMax = height[lo]; // Updating left_max\\n                else\\n                    water += lMax - height[lo]; // Calculating the ans\\n                lo++;\\n            }\\n            else\\n            {\\n                if(height[hi] > rMax)\\n                    rMax = height[hi]; // Updating right_max\\n                else\\n                    water += rMax - height[hi]; // Calculating the ans\\n                hi--;\\n            }\\n        }\\n        return water; // done!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231028,
                "title": "c-2-approaches-without-stack-with-stack",
                "content": "```\\n//Approach-1 (Without stack) Simple approach. Time : O(n)\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> left, right;\\n    void leftMax(vector<int>& height) {\\n        left[0] = height[0];\\n        for(int i = 1; i<n; i++) {\\n            left[i] = max(left[i-1], height[i]);\\n        }\\n    }\\n    \\n    void rightMax(vector<int>& height) {\\n        right[n-1] = height[n-1];\\n        for(int i = n-2; i>=0; i--) {\\n            right[i] = max(right[i+1], height[i]);\\n        }\\n    }\\n    \\n    int trap(vector<int>& height) {\\n        n = height.size();\\n        if(n == 0 || n == 1) \\n            return 0;\\n        \\n        left.resize(n);\\n        right.resize(n);\\n        \\n        leftMax(height);\\n        rightMax(height);\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++) {\\n            ans += ((min(left[i], right[i])-height[i]));\\n        }\\n        return ans;   \\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-2 (Using stack, a smart approach) Time : O(n) all elements are pushes and pop once\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        stack<int> st;\\n        \\n        int water = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            while(!st.empty() && height[i] > height[st.top()]) {\\n                //It means index is bounded from left (i.e. height[st.top()]) and right(i.e. height[i])\\n                int index = st.top();\\n                st.pop();\\n                \\n                //This index can\\'t contribute any more \\n                //(Example : [4,2,0,3,2,5]), we will be left with empty stack at end\\n                //while processing 5\\n                if(st.empty())\\n                    break;\\n                \\n                int h = min(height[i], height[st.top()]) - height[index];\\n                int w = i - st.top() - 1; //same concept as simplfied MAH\\n                \\n                water += h*w;\\n            }\\n            st.push(i);\\n        }\\n        return water;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Without stack) Simple approach. Time : O(n)\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> left, right;\\n    void leftMax(vector<int>& height) {\\n        left[0] = height[0];\\n        for(int i = 1; i<n; i++) {\\n            left[i] = max(left[i-1], height[i]);\\n        }\\n    }\\n    \\n    void rightMax(vector<int>& height) {\\n        right[n-1] = height[n-1];\\n        for(int i = n-2; i>=0; i--) {\\n            right[i] = max(right[i+1], height[i]);\\n        }\\n    }\\n    \\n    int trap(vector<int>& height) {\\n        n = height.size();\\n        if(n == 0 || n == 1) \\n            return 0;\\n        \\n        left.resize(n);\\n        right.resize(n);\\n        \\n        leftMax(height);\\n        rightMax(height);\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++) {\\n            ans += ((min(left[i], right[i])-height[i]));\\n        }\\n        return ans;   \\n    }\\n};\\n```\n```\\n//Approach-2 (Using stack, a smart approach) Time : O(n) all elements are pushes and pop once\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        stack<int> st;\\n        \\n        int water = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            while(!st.empty() && height[i] > height[st.top()]) {\\n                //It means index is bounded from left (i.e. height[st.top()]) and right(i.e. height[i])\\n                int index = st.top();\\n                st.pop();\\n                \\n                //This index can\\'t contribute any more \\n                //(Example : [4,2,0,3,2,5]), we will be left with empty stack at end\\n                //while processing 5\\n                if(st.empty())\\n                    break;\\n                \\n                int h = min(height[i], height[st.top()]) - height[index];\\n                int w = i - st.top() - 1; //same concept as simplfied MAH\\n                \\n                water += h*w;\\n            }\\n            st.push(i);\\n        }\\n        return water;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918251,
                "title": "python-solution-with-image-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/98318252-1d08-4d84-a32e-3e7256516c85_1604190088.9672568.png)\\n\\nTime: O(n)\\nSpace O(1)\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n    \\n    \\n        def trapTomax(height):\\n            cur_max  =0\\n            water = 0\\n            for h in height:\\n                if h < cur_max:\\n                    water += cur_max - h\\n                else:\\n                    cur_max = h\\n            return water\\n        \\n        if not height:\\n            return 0\\n        \\n        max_pos = height.index(max(height))\\n        \\n        return trapTomax(height[:max_pos]) + trapTomax(reversed(height[max_pos+1:]))    \\n```\\nThe max_pos is the key to this solution. With that, the question will be divided into left and right portions, which are actually the same if you reverse the right portion. Take the left portion as an example, follow the cur_max plot from left to right, it\\'s quite straightforward to get the trapped water. The table on the left has been filled out for you as an example to complete the one on the right (from right to left). \\n\\nThe code below should be self-explanatory, but feel free to leave questions/suggestions below for further discussion.\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n    \\n    \\n        def trapTomax(height):\\n            cur_max  =0\\n            water = 0\\n            for h in height:\\n                if h < cur_max:\\n                    water += cur_max - h\\n                else:\\n                    cur_max = h\\n            return water\\n        \\n        if not height:\\n            return 0\\n        \\n        max_pos = height.index(max(height))\\n        \\n        return trapTomax(height[:max_pos]) + trapTomax(reversed(height[max_pos+1:]))    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 818356,
                "title": "6-lines-solution-easy-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:   return 0\\n        max_left, max_right = [height[0]], [height[-1]]\\n\\n        for i in range(1, len(height)):\\n            max_left.append(max(max_left[-1], height[i]))\\n            max_right.append(max(max_right[-1], height[-1 - i]))\\n\\n        return sum(min(l, r) - h for l, r, h in zip(max_left, reversed(max_right), height))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:   return 0\\n        max_left, max_right = [height[0]], [height[-1]]\\n\\n        for i in range(1, len(height)):\\n            max_left.append(max(max_left[-1], height[i]))\\n            max_right.append(max(max_right[-1], height[-1 - i]))\\n\\n        return sum(min(l, r) - h for l, r, h in zip(max_left, reversed(max_right), height))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737447,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let mut v: Vec<(i32, i32)> = vec![(0, 0); height.len()];\\n        {\\n            let mut max = 0;\\n            for i in 0..height.len() {\\n                max = std::cmp::max(max, height[i]);\\n                v[i].0 = max;\\n            }\\n        }\\n        {\\n            let mut max = 0;\\n            for i in (0..height.len()).rev() {\\n                max = std::cmp::max(max, height[i]);\\n                v[i].1 = max;\\n            }\\n        }\\n        (0..height.len())\\n            .map(|i| std::cmp::min(v[i].0, v[i].1) - height[i])\\n            .sum()\\n    }\\n}\\n```\\n\\nupdate:\\n\\n```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let mut v = vec![i32::MAX; height.len()];\\n        {\\n            let mut max = 0;\\n            for (i, &h) in height.iter().enumerate() {\\n                max = max.max(h);\\n                v[i] = v[i].min(max);\\n            }\\n        }\\n        {\\n            let mut max = 0;\\n            for (i, &h) in height.iter().enumerate().rev() {\\n                max = max.max(h);\\n                v[i] = v[i].min(max);\\n            }\\n        }\\n        height.iter().zip(&v).map(|(h, m)| m - h).sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let mut v: Vec<(i32, i32)> = vec![(0, 0); height.len()];\\n        {\\n            let mut max = 0;\\n            for i in 0..height.len() {\\n                max = std::cmp::max(max, height[i]);\\n                v[i].0 = max;\\n            }\\n        }\\n        {\\n            let mut max = 0;\\n            for i in (0..height.len()).rev() {\\n                max = std::cmp::max(max, height[i]);\\n                v[i].1 = max;\\n            }\\n        }\\n        (0..height.len())\\n            .map(|i| std::cmp::min(v[i].0, v[i].1) - height[i])\\n            .sum()\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let mut v = vec![i32::MAX; height.len()];\\n        {\\n            let mut max = 0;\\n            for (i, &h) in height.iter().enumerate() {\\n                max = max.max(h);\\n                v[i] = v[i].min(max);\\n            }\\n        }\\n        {\\n            let mut max = 0;\\n            for (i, &h) in height.iter().enumerate().rev() {\\n                max = max.max(h);\\n                v[i] = v[i].min(max);\\n            }\\n        }\\n        height.iter().zip(&v).map(|(h, m)| m - h).sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520079,
                "title": "java-two-pointers-with-explanation",
                "content": "Thinking Process:\\n1. If we have two panels on left side and right side, the total water storage is determined by the smaller panel and the distance between the two panels. For a panel which is between left and right, its water storage is (smaller panel-current height). \\n![image](https://assets.leetcode.com/users/haimei2/image_1582616589.png)\\n2. When you only have one pointer moving in the array, you may know the left panel because you moving from the left, but you don\\'t know the right panel. In this case, we have to use two pointers, leftmax and rightmax. When you have two pointers, you have to know when to move which pointer. Here is a trick. when leftmax is smaller than rightmax, this means we can move left pointer-i. \\nWHY? because leftmax now is to determine the current water storage and current-i must be smaller than leftmax (do you remember that leftmax is always the math.max(leftmax, height[i])). in this case, we are confident to move i. By contrast, if we decide to move j pointer, we are not sure current-j column value is smaller than leftmax or not. So move i . \\nIf leftmax is bigger than rightmax, this means rightmax is determined current column\\'s water storage and current-j must be smaller than rightmax, we\\'d better move pointer-j. (here i is moving from left, j is moving from right). \\nHere I draw leftmax is smaller than rightmax and leftmax is bigger than rightmax case in graph to help understand. \\n![image](https://assets.leetcode.com/users/haimei2/image_1582616616.png)\\n\\n3. Remember: when we use two pointers, we always move one of them with confident(This is hit from question\\'s condition, like sorting).\\n4. In fact, if we understand thinking-process-1 idea, recording each column\\'s leftmax or right max first and then looping again to calculate each column\\'s water storage is also easy understand solution. During this process, you can use array or stack to record. \\n\\nTest Cases:\\n1. []\\n2. [0]\\n2. [3,2,5,7] //leftmax<rightmax\\n3. [7,5,2,3] //leftmax>rightmax\\n4. [4,3,2,4] //leftmax==rightmax\\n\\nTime Complexity is O(n)\\n\\nSpace Complexity is O(1)\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int leftmax = 0;\\n        int rightmax = 0;\\n        int i=0, j=height.length-1;\\n        int rec = 0;\\n        while(i<=j) {\\n            leftmax = Math.max(height[i], leftmax);\\n            rightmax = Math.max(height[j], rightmax);\\n            if (leftmax<rightmax) {\\n                rec += leftmax-height[i++];\\n            } else {\\n                rec += rightmax-height[j--];\\n            }\\n        }\\n        return rec;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int leftmax = 0;\\n        int rightmax = 0;\\n        int i=0, j=height.length-1;\\n        int rec = 0;\\n        while(i<=j) {\\n            leftmax = Math.max(height[i], leftmax);\\n            rightmax = Math.max(height[j], rightmax);\\n            if (leftmax<rightmax) {\\n                rec += leftmax-height[i++];\\n            } else {\\n                rec += rightmax-height[j--];\\n            }\\n        }\\n        return rec;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417194,
                "title": "48ms-python-3-solution-that-s-even-simpler-than-the-two-pointer-one",
                "content": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:\\n            return 0\\n        \\n        # find the index of the tallest point\\n        maxIndex = height.index(max(height))\\n        \\n        # sum up the water to the left of maxIndex\\n        result = 0 # the amount of water\\n        maxSeen = 0 # the max elevation seen\\n        # iterate from left to right\\n        for i in range(maxIndex):\\n            if height[i] >= maxSeen:\\n                maxSeen = height[i]\\n            else:\\n                result += maxSeen - height[i]\\n        \\n        # sum up the water to the right of maxIndex\\n        maxSeen = 0\\n        # iterate from right to left\\n        for i in range(len(height)-1, maxIndex-1, -1):\\n            if height[i] >= maxSeen:\\n                maxSeen = height[i]\\n            else:\\n                result += maxSeen - height[i]\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:\\n            return 0\\n        \\n        # find the index of the tallest point\\n        maxIndex = height.index(max(height))\\n        \\n        # sum up the water to the left of maxIndex\\n        result = 0 # the amount of water\\n        maxSeen = 0 # the max elevation seen\\n        # iterate from left to right\\n        for i in range(maxIndex):\\n            if height[i] >= maxSeen:\\n                maxSeen = height[i]\\n            else:\\n                result += maxSeen - height[i]\\n        \\n        # sum up the water to the right of maxIndex\\n        maxSeen = 0\\n        # iterate from right to left\\n        for i in range(len(height)-1, maxIndex-1, -1):\\n            if height[i] >= maxSeen:\\n                maxSeen = height[i]\\n            else:\\n                result += maxSeen - height[i]\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347671,
                "title": "simple-solution-c-o-n-solution-without-stack-detailed-explanation-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) \\n    {\\n       int l=0,r=height.size()-1,leftmax=0,rightmax=0,ans=0;\\n        while(l<r)\\n        {\\n            if(height[l]<height[r])// comparing the heights the one which is smaller is taken first\\n            {\\n                if(height[l]>=leftmax)\\n               {\\n                leftmax=height[l];// updating left max\\n                l++;\\n               }\\n               else if(height[l]<leftmax)\\n              {\\n                ans+=(leftmax-height[l]);//updating the answer and substracting height[l] to remove space //taken by bar of height[l] this is basically the amount of water above height[l]\\n                l++;\\n               }\\n            }\\n            else\\n            {\\n                if(height[r]>=rightmax)\\n                {\\n                    rightmax=height[r];// similarly for right index also\\n                    r--;\\n                }else\\n                {\\n                    ans+=(rightmax-height[r]);\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere first our concern is for the bar with max height on both sides , and then comparing the height at l and r that is leftmax and rightmax , the one which is smaller is taken into consideration first because amount of water which can be stored above a particular bar depends on the bar with minimum height only and subsequently add the result to the answer",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) \\n    {\\n       int l=0,r=height.size()-1,leftmax=0,rightmax=0,ans=0;\\n        while(l<r)\\n        {\\n            if(height[l]<height[r])// comparing the heights the one which is smaller is taken first\\n            {\\n                if(height[l]>=leftmax)\\n               {\\n                leftmax=height[l];// updating left max\\n                l++;\\n               }\\n               else if(height[l]<leftmax)\\n              {\\n                ans+=(leftmax-height[l]);//updating the answer and substracting height[l] to remove space //taken by bar of height[l] this is basically the amount of water above height[l]\\n                l++;\\n               }\\n            }\\n            else\\n            {\\n                if(height[r]>=rightmax)\\n                {\\n                    rightmax=height[r];// similarly for right index also\\n                    r--;\\n                }else\\n                {\\n                    ans+=(rightmax-height[r]);\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318446,
                "title": "js-one-pass-o-n-time-o-1-space-solution",
                "content": "The idea is to pass from left and right ends toward center. For any position, if left max height is less than right max height, the water in this position is left max height minux the height of current position, vice versa.\\n\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    let leftMax = -1, rightMax = -1, left = 0, right = height.length - 1, res = 0\\n    while (left <= right) {\\n        leftMax = height[left] > leftMax ? height[left] : leftMax\\n        rightMax = height[right] > rightMax? height[right] : rightMax\\n        if (leftMax > rightMax) {\\n            res += rightMax - height[right]\\n            right--\\n        }\\n        else {\\n            res += leftMax - height[left]\\n            left++\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    let leftMax = -1, rightMax = -1, left = 0, right = height.length - 1, res = 0\\n    while (left <= right) {\\n        leftMax = height[left] > leftMax ? height[left] : leftMax\\n        rightMax = height[right] > rightMax? height[right] : rightMax\\n        if (leftMax > rightMax) {\\n            res += rightMax - height[right]\\n            right--\\n        }\\n        else {\\n            res += leftMax - height[left]\\n            left++\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 131886,
                "title": "javascript-beats-100",
                "content": "```\\nvar trap = function(height) {\\n    let left = 0;\\n    let right = height.length-1;\\n    let leftMax = 0;\\n    let rightMax = 0;\\n    let ans = 0;\\n    while (left < right) {\\n        leftMax = Math.max(height[left], leftMax);\\n        if (leftMax > height[left]) {\\n            ans+= (leftMax - height[left]);\\n        }\\n        rightMax = Math.max(height[right], rightMax);\\n        if (rightMax > height[right]) {\\n            ans += (rightMax - height[right]);\\n        }\\n        height[left] < height[right] ? left++ : right--;\\n    }\\n    return ans;\\n};\\n```\\nO(n) time, O(1) space",
                "solutionTags": [],
                "code": "```\\nvar trap = function(height) {\\n    let left = 0;\\n    let right = height.length-1;\\n    let leftMax = 0;\\n    let rightMax = 0;\\n    let ans = 0;\\n    while (left < right) {\\n        leftMax = Math.max(height[left], leftMax);\\n        if (leftMax > height[left]) {\\n            ans+= (leftMax - height[left]);\\n        }\\n        rightMax = Math.max(height[right], rightMax);\\n        if (rightMax > height[right]) {\\n            ans += (rightMax - height[right]);\\n        }\\n        height[left] < height[right] ? left++ : right--;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17400,
                "title": "java-solution-with-o-n-time-and-o-1-space",
                "content": "Very classic Two Pointer question. \\nIf we want to trap water for one point i, we need to satisfy two conditions:\\n\\n* 1 leftBar > height[i]\\n\\n* 2 rightBar > height[i]\\n\\nThe water trapped = Min(leftBar, rightBar) - height[i]\\nSo the key is always trap water from the side of lower bar.\\n\\n```\\npublic class Solution {\\n    public int trap(int[] height) {\\n        int sum=0;\\n        int n=height.length;\\n        if(n<3) return 0;\\n        \\n        int left=0, right=n-1;\\n        int leftBar = height[left++];\\n        int rightBar = height[right--];\\n        \\n        while(left<=right){\\n            if(leftBar>rightBar){\\n                if(height[right]<rightBar) \\n                    sum+=rightBar - height[right];\\n                else\\n                    rightBar=height[right];\\n                right--;\\n            }else{\\n                if(height[left]<leftBar)\\n                    sum+=leftBar - height[left];\\n                else\\n                    leftBar=height[left];\\n                left++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int trap(int[] height) {\\n        int sum=0;\\n        int n=height.length;\\n        if(n<3) return 0;\\n        \\n        int left=0, right=n-1;\\n        int leftBar = height[left++];\\n        int rightBar = height[right--];\\n        \\n        while(left<=right){\\n            if(leftBar>rightBar){\\n                if(height[right]<rightBar) \\n                    sum+=rightBar - height[right];\\n                else\\n                    rightBar=height[right];\\n                right--;\\n            }else{\\n                if(height[left]<leftBar)\\n                    sum+=leftBar - height[left];\\n                else\\n                    leftBar=height[left];\\n                left++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707440,
                "title": "java-most-optimal-solution-with-intuition-and-approach",
                "content": "# Intuition\\n We need a minimum of leftMax and rightMax.So if we take the case when height[l]<=height[r] we increase l++, so we can surely say that there is a block with a height more than height[l] to the right of l. And for the same reason when height[r]<=height[l] we can surely say that there is a block to the left of r which is at least of height[r]. So by traversing these cases and using two pointers approach the time complexity can be decreased without using extra space.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Take 2 pointers l(left pointer) and r(right pointer) pointing to 0th and (n-1)th index respectively. Take two variables leftMax and rightMax and initialize them to 0. If height[l] is less than or equal to height[r] then if leftMax is less than height[l] update leftMax to height[l] else add leftMax-height[l] to your final answer and move the l pointer to the right i.e l++. If height[r] is less than height[l], then now we are dealing with the right block. If height[r] is greater than rightMax, then update rightMax to height[r] else add rightMax-height[r] to the final answer. Now move r to the left. Repeat these steps till l and r crosses each other.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n       int left = 0, right = height.length - 1;\\n       int maxLeft = 0, maxRight = 0;\\n       int water = 0;\\n       while(left <= right) {\\n           if(height[left] <= height[right]) {\\n               if(height[left] >= maxLeft)\\n               maxLeft = height[left];\\n               else\\n               water += maxLeft - height[left];\\n               left ++;\\n           }\\n           else {\\n               if(height[right] >= maxRight)\\n               maxRight = height[right];\\n               else\\n               water += maxRight - height[right];\\n               right --;\\n           }\\n       }\\n       return water;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n       int left = 0, right = height.length - 1;\\n       int maxLeft = 0, maxRight = 0;\\n       int water = 0;\\n       while(left <= right) {\\n           if(height[left] <= height[right]) {\\n               if(height[left] >= maxLeft)\\n               maxLeft = height[left];\\n               else\\n               water += maxLeft - height[left];\\n               left ++;\\n           }\\n           else {\\n               if(height[right] >= maxRight)\\n               maxRight = height[right];\\n               else\\n               water += maxRight - height[right];\\n               right --;\\n           }\\n       }\\n       return water;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638335,
                "title": "java-4-step-tricky-solution-for-easy-understanding",
                "content": "# Intuition\\n(Waterlevel-barHeight)*width of bar= TrappedWater\\n\\n# Approach\\n```\\nStep1- calculate left max boundary-Auxiliary Array\\n\\nStep2- calculate right max boundary-Auxiliary Array loop\\n \\nStep3- waterLevel =min(left max bound, right max bound)\\n\\nStep4- trapped water= waterlevel-height[i]\\n```\\n\\n# Complexity\\n- Time complexity:   O(N)\\n\\n- Space complexity: O(N)\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public static int trap(int height[]){\\n        int n=height.length;\\n        //calculate left max boundary-Auxiliary Array\\n        int leftMax[]=new int[n];\\n        leftMax[0]=height[0];\\n        for(int i=1;i<n;i++){\\n            leftMax[i]=Math.max(height[i],leftMax[i-1]);\\n            //after loop complted, leftMax[]={4,4,4,6,6,6,6}\\n        }\\n        \\n        //calculate right max boundary-Auxiliary Array\\n        int rightMax[]=new int[n];\\n        rightMax[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            rightMax[i]=Math.max(height[i],rightMax[i+1]);\\n            //after loop complted, leftMax[]={6,6,6,6,5,5,5}\\n        }\\n        \\n        int trappedWater=0;\\n        //loop \\n        for(int i=0; i<n;i++){\\n            //waterLevel =min(left max bound, right max bound)\\n            int waterLevel=Math.min(leftMax[i],rightMax[i]);\\n            //waterLevel ={4,4,4,6,5,5,5}\\n            \\n            //trapped water= waterlevel-height[i]\\n            trappedWater+=waterLevel- height[i];\\n        }\\n        return trappedWater;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nStep1- calculate left max boundary-Auxiliary Array\\n\\nStep2- calculate right max boundary-Auxiliary Array loop\\n \\nStep3- waterLevel =min(left max bound, right max bound)\\n\\nStep4- trapped water= waterlevel-height[i]\\n```\n```\\nimport java.util.*;\\nclass Solution {\\n    public static int trap(int height[]){\\n        int n=height.length;\\n        //calculate left max boundary-Auxiliary Array\\n        int leftMax[]=new int[n];\\n        leftMax[0]=height[0];\\n        for(int i=1;i<n;i++){\\n            leftMax[i]=Math.max(height[i],leftMax[i-1]);\\n            //after loop complted, leftMax[]={4,4,4,6,6,6,6}\\n        }\\n        \\n        //calculate right max boundary-Auxiliary Array\\n        int rightMax[]=new int[n];\\n        rightMax[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            rightMax[i]=Math.max(height[i],rightMax[i+1]);\\n            //after loop complted, leftMax[]={6,6,6,6,5,5,5}\\n        }\\n        \\n        int trappedWater=0;\\n        //loop \\n        for(int i=0; i<n;i++){\\n            //waterLevel =min(left max bound, right max bound)\\n            int waterLevel=Math.min(leftMax[i],rightMax[i]);\\n            //waterLevel ={4,4,4,6,5,5,5}\\n            \\n            //trapped water= waterlevel-height[i]\\n            trappedWater+=waterLevel- height[i];\\n        }\\n        return trappedWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378569,
                "title": "short-and-simple-java-sol-1ms-2-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int left=0;    int right=n-1;\\n        int lmax=0;    int rmax=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=lmax){ lmax = height[left]; }\\n                else{ res+= lmax-height[left]; \\n                 }left++;\\n            }else{\\n                if(height[right]>=rmax){ rmax = height[right]; }\\n                else{ res+= rmax-height[right];\\n                }right--;       \\n            }\\n        }return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int left=0;    int right=n-1;\\n        int lmax=0;    int rmax=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=lmax){ lmax = height[left]; }\\n                else{ res+= lmax-height[left]; \\n                 }left++;\\n            }else{\\n                if(height[right]>=rmax){ rmax = height[right]; }\\n                else{ res+= rmax-height[right];\\n                }right--;       \\n            }\\n        }return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336457,
                "title": "striver-s-approach-from-yt",
                "content": "# Intuition\\nTo store Water at an index there must be a >= tower to both left and right of the index.\\nSo we have to find max element to right and max element to left for each index in height vector.\\n\\n# EQUATION\\n`min(max_to_left,max_to_right)-height[i]`\\n\\n# APPROACH 1\\n- Obtain prefix max and suffix max vector.\\n- Use the equation to find water trapped.\\n```\\n//   Approach 1 \\n //   TC-->O(N)+O(N)+O(N)= 3*O(N) = O(N)\\n //   SC-->O(N)+O(N)= 2*O(N) = O(N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> premax(n),suffixmax(n);\\n        // Computing prefixmax for each element in height array\\n        premax[0]=height[0];\\n        for(int i=1;i<height.size();i++)\\n            premax[i] = max(height[i],premax[i-1]);\\n        // Computing suffixmax for each element in height array\\n        suffixmax[n-1] = height[n-1];\\n        for(int i=n-2;i>=0;i--)\\n           suffixmax[i] = max(height[i],suffixmax[i+1]);\\n        // computing the water trapped using the below formula\\n        int water = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            water += (min(premax[i],suffixmax[i])-height[i]);\\n        }\\n        return water;\\n    }\\n```\\n# APPROACH 2\\n**In this approach we use two pointer method.**\\n```\\n //   Approach 2 (Most optimal)\\n //   TC-->O(N)\\n //   SC-->O(1)\\n        int trap(vector<int>& height) {\\n        int n = height.size();\\n        int l=0,r=n-1,water=0;\\n        int leftmax=0,rightmax=0;\\n        while(l<=r)\\n        {\\n            if(height[l]<=height[r])\\n            {\\n                if(height[l]>leftmax)\\n                   leftmax = height[l];\\n                else\\n                   water+=leftmax-height[l];\\n                l++;\\n            }\\n            else\\n            {\\n                if(height[r]>rightmax)\\n                   rightmax = height[r];\\n                else\\n                   water+=rightmax-height[r];\\n                r--;\\n            }\\n        }\\n        return water;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//   Approach 1 \\n //   TC-->O(N)+O(N)+O(N)= 3*O(N) = O(N)\\n //   SC-->O(N)+O(N)= 2*O(N) = O(N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> premax(n),suffixmax(n);\\n        // Computing prefixmax for each element in height array\\n        premax[0]=height[0];\\n        for(int i=1;i<height.size();i++)\\n            premax[i] = max(height[i],premax[i-1]);\\n        // Computing suffixmax for each element in height array\\n        suffixmax[n-1] = height[n-1];\\n        for(int i=n-2;i>=0;i--)\\n           suffixmax[i] = max(height[i],suffixmax[i+1]);\\n        // computing the water trapped using the below formula\\n        int water = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            water += (min(premax[i],suffixmax[i])-height[i]);\\n        }\\n        return water;\\n    }\\n```\n```\\n //   Approach 2 (Most optimal)\\n //   TC-->O(N)\\n //   SC-->O(1)\\n        int trap(vector<int>& height) {\\n        int n = height.size();\\n        int l=0,r=n-1,water=0;\\n        int leftmax=0,rightmax=0;\\n        while(l<=r)\\n        {\\n            if(height[l]<=height[r])\\n            {\\n                if(height[l]>leftmax)\\n                   leftmax = height[l];\\n                else\\n                   water+=leftmax-height[l];\\n                l++;\\n            }\\n            else\\n            {\\n                if(height[r]>rightmax)\\n                   rightmax = height[r];\\n                else\\n                   water+=rightmax-height[r];\\n                r--;\\n            }\\n        }\\n        return water;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3281537,
                "title": "2-pointer-easy-o-n-solution-o-1-space-complexity-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt each point you must know the max size block at left and at right side of all the elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintaing a leftmax and rightmax pointer which basically makes sure that there is a building in the left and right with a height more than than the current element.If we find such elements we can add in our ans the trapped water above that particular block as ans+=min(lmax,rmax)-a[current];\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(N);\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(1);\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int l=0,r=a.size()-1,lm=0,rm=0,ans=0;\\n        while(l<r){\\n            if(a[l]<=a[r]){\\n                if(a[l]>lm) lm=a[l];\\n                else{\\n                    ans+=lm-a[l];\\n                }\\n                l++;\\n            }\\n            else{\\n                if(a[r]>rm) rm=a[r];\\n                else{\\n                    ans+=rm-a[r];\\n                }\\n                r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//Please upvote of you found it helpful :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int l=0,r=a.size()-1,lm=0,rm=0,ans=0;\\n        while(l<r){\\n            if(a[l]<=a[r]){\\n                if(a[l]>lm) lm=a[l];\\n                else{\\n                    ans+=lm-a[l];\\n                }\\n                l++;\\n            }\\n            else{\\n                if(a[r]>rm) rm=a[r];\\n                else{\\n                    ans+=rm-a[r];\\n                }\\n                r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//Please upvote of you found it helpful :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208388,
                "title": "most-optimized-solution-two-pointer-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n=height.length;\\n        int left=0;\\n        int right=n-1;\\n        int maxLeft=0;\\n        int maxRight=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=maxLeft){\\n                    maxLeft=height[left];\\n                }else{\\n                    res+=maxLeft-height[left];\\n                }\\n                left++;\\n            }else{\\n                if(height[right]>=maxRight){\\n                    maxRight=height[right];\\n                }else{\\n                    res+=maxRight-height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n=height.length;\\n        int left=0;\\n        int right=n-1;\\n        int maxLeft=0;\\n        int maxRight=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=maxLeft){\\n                    maxLeft=height[left];\\n                }else{\\n                    res+=maxLeft-height[left];\\n                }\\n                left++;\\n            }else{\\n                if(height[right]>=maxRight){\\n                    maxRight=height[right];\\n                }else{\\n                    res+=maxRight-height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137684,
                "title": "java-solution-1-ms-beats-98",
                "content": "# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int max1 = 0;\\n        int left[] = new int[height.length];\\n        for(int i = 0; i < height.length; i++) {\\n            if(max1 < height[i]) {\\n                max1 = height[i];\\n            }\\n            left[i] = max1;\\n        }\\n        \\n        int max2 = 0;\\n        int right[] = new int[height.length];\\n        for(int i = height.length-1; i >= 0; i--) {\\n            if(max2 < height[i]) {\\n                max2 = height[i];\\n            }\\n            right[i] = max2;\\n        }\\n        \\n        int trap = 0;\\n        for(int i = 0; i  < height.length; i++) {\\n            trap += Math.min(left[i], right[i]) - height[i];\\n        }\\n        return trap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int max1 = 0;\\n        int left[] = new int[height.length];\\n        for(int i = 0; i < height.length; i++) {\\n            if(max1 < height[i]) {\\n                max1 = height[i];\\n            }\\n            left[i] = max1;\\n        }\\n        \\n        int max2 = 0;\\n        int right[] = new int[height.length];\\n        for(int i = height.length-1; i >= 0; i--) {\\n            if(max2 < height[i]) {\\n                max2 = height[i];\\n            }\\n            right[i] = max2;\\n        }\\n        \\n        int trap = 0;\\n        for(int i = 0; i  < height.length; i++) {\\n            trap += Math.min(left[i], right[i]) - height[i];\\n        }\\n        return trap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092897,
                "title": "easy-to-read-and-understand-in-java-in-3s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left[] = new int[height.length];\\n        left[0] = height[0];\\n        for(int i = 1; i<height.length; i++){\\n            left[i] = Math.max(height[i], left[i-1]);\\n        }\\n        int right[] = new int[height.length];\\n        right[height.length-1] = height[height.length-1];\\n        for(int i = height.length-2; i>=0; i--){\\n            right[i] = Math.max(height[i], right[i+1]);\\n        }\\n\\n        int trappedWater = 0;\\n        for(int i = 0; i<height.length; i++){\\n            int water = Math.min(left[i], right[i]);\\n            trappedWater += water - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left[] = new int[height.length];\\n        left[0] = height[0];\\n        for(int i = 1; i<height.length; i++){\\n            left[i] = Math.max(height[i], left[i-1]);\\n        }\\n        int right[] = new int[height.length];\\n        right[height.length-1] = height[height.length-1];\\n        for(int i = height.length-2; i>=0; i--){\\n            right[i] = Math.max(height[i], right[i+1]);\\n        }\\n\\n        int trappedWater = 0;\\n        for(int i = 0; i<height.length; i++){\\n            int water = Math.min(left[i], right[i]);\\n            trappedWater += water - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984747,
                "title": "simple-python-3-solution-in-two-passes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*For each interior column:*\\n- Max. wall to the left begins a container\\n- Max. wall to the right ends a container; top surface is the minimum of the two.\\n- Positives under the top surface reduce the water capacity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Move from left to right, recording the maximum wall height to the left of the current position to the list **max_l_wall**.\\n- Move from right to left over the interior columns, computing the volume of water trapped at each column as min(highest wall to the right, highest wall to the left) minus column height (or 0 if negative) and adding this to the total volume.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as we traverse the list from left to right and then from right to left.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\'\\'\\'\\n        For each interior column:\\n            Max. wall to the left begins a container\\n            Max. wall to the right ends a container; top surface is the minimum of the two.\\n            Positives under the top surface reduce the water capacity\\n        \\'\\'\\'\\n        max_l_wall = [0]\\n        max_ht_so_far = 0                   # Maximum height to the left\\n        volume = 0\\n        # For each interior column, l to r:\\n        for i in range(1, len(height)):\\n            # record the highest wall to the left of it\\n            max_ht_so_far = max(height[i - 1], max_ht_so_far)\\n            max_l_wall.append(max_ht_so_far)\\n        max_ht_so_far = height[-1]          # Maximum height to the right\\n        i = len(height) - 2\\n        # For each interior column, r to l:\\n        while i > 0:\\n            # volume += min(highest wall to the right, highest wall to the left) minus column height (or 0)\\n            max_ht_so_far = max(max_ht_so_far, height[i + 1])\\n            volume += max(min(max_ht_so_far, max_l_wall[i]) - height[i], 0)\\n            i -= 1\\n        return volume\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\'\\'\\'\\n        For each interior column:\\n            Max. wall to the left begins a container\\n            Max. wall to the right ends a container; top surface is the minimum of the two.\\n            Positives under the top surface reduce the water capacity\\n        \\'\\'\\'\\n        max_l_wall = [0]\\n        max_ht_so_far = 0                   # Maximum height to the left\\n        volume = 0\\n        # For each interior column, l to r:\\n        for i in range(1, len(height)):\\n            # record the highest wall to the left of it\\n            max_ht_so_far = max(height[i - 1], max_ht_so_far)\\n            max_l_wall.append(max_ht_so_far)\\n        max_ht_so_far = height[-1]          # Maximum height to the right\\n        i = len(height) - 2\\n        # For each interior column, r to l:\\n        while i > 0:\\n            # volume += min(highest wall to the right, highest wall to the left) minus column height (or 0)\\n            max_ht_so_far = max(max_ht_so_far, height[i + 1])\\n            volume += max(min(max_ht_so_far, max_l_wall[i]) - height[i], 0)\\n            i -= 1\\n        return volume\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851658,
                "title": "python-1-liner",
                "content": "```\\nfrom itertools import accumulate\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        return sum([min(i, j) - x for i ,j,x  in zip(list(accumulate(height, max)) ,list(accumulate(height[::-1], max))[::-1],  height)   ])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import accumulate\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        return sum([min(i, j) - x for i ,j,x  in zip(list(accumulate(height, max)) ,list(accumulate(height[::-1], max))[::-1],  height)   ])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769161,
                "title": "cpp-o-n-time-complexity",
                "content": "```\\nint trap(vector<int>& height) {\\n        int ans=0;\\n        int n = height.size();\\n        int lMax[n];\\n        int rMax[n];\\n        \\n        lMax[0]=height[0];\\n        for(int i=1;i<n;i++)\\n            lMax[i]=max(lMax[i-1],height[i]);\\n        \\n        rMax[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            rMax[i]=max(rMax[i+1],height[i]);\\n        \\n        for(int i=0;i<n;i++)\\n            ans = ans + min(lMax[i],rMax[i])-height[i];\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint trap(vector<int>& height) {\\n        int ans=0;\\n        int n = height.size();\\n        int lMax[n];\\n        int rMax[n];\\n        \\n        lMax[0]=height[0];\\n        for(int i=1;i<n;i++)\\n            lMax[i]=max(lMax[i-1],height[i]);\\n        \\n        rMax[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            rMax[i]=max(rMax[i+1],height[i]);\\n        \\n        for(int i=0;i<n;i++)\\n            ans = ans + min(lMax[i],rMax[i])-height[i];\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754692,
                "title": "erlang-nothing-special",
                "content": "eh theres a ton of solutions that do the same thing but none in erlang\\n\\n```erl\\n-spec trap(Height :: [integer()]) -> integer().\\ntrap(Height) ->\\n    N = length(Height),\\n    {_Max_val, Max_idx} = max_height(Height),\\n    First_half = sub_array(Height, Max_idx),\\n    Second_half = sub_array(lists:reverse(Height), N - Max_idx - 1),\\n    Result = process_heights(First_half) + process_heights(Second_half),\\n    Result.\\n    %%reverse_array(Height).\\n\\n\\nprocess_heights(List) ->\\n    process_heights(List, 0, 0).\\n\\nprocess_heights([], _Cur_max, Result) ->\\n    Result;\\nprocess_heights([Head | Rest], Cur_max, Cur_res) when Head > Cur_max ->\\n    process_heights(Rest, Head, Cur_res);\\nprocess_heights([Head | Rest], Cur_max, Cur_res) ->\\n    New_res = Cur_res + Cur_max - Head,\\n    process_heights(Rest, Cur_max, New_res).\\n\\n\\nmax_height([Head | Rest]) ->\\n    max_height(Rest, {Head, 0}, 1).\\n\\nmax_height([Head | Rest], {Cur_max, _Idx}, Idx) when Head > Cur_max ->\\n    max_height(Rest, {Head, Idx}, Idx + 1);\\nmax_height([_Head | Rest], Cur_max, Idx) ->\\n    max_height(Rest, Cur_max, Idx + 1);\\nmax_height([], Max_Set, _Idx) ->\\n    Max_Set.\\n\\n\\nsub_array(List, Left) ->\\n    sub_array(List, Left, []).\\n\\nsub_array(_List, Left, Sub_array) when Left == 0 ->\\n    lists:reverse(Sub_array);\\nsub_array([Head | Rest], Left, Cur_array) ->\\n    sub_array(Rest, Left - 1, [Head | Cur_array]).\\n\\t",
                "solutionTags": [
                    "Erlang"
                ],
                "code": "eh theres a ton of solutions that do the same thing but none in erlang\\n\\n```erl\\n-spec trap(Height :: [integer()]) -> integer().\\ntrap(Height) ->\\n    N = length(Height),\\n    {_Max_val, Max_idx} = max_height(Height),\\n    First_half = sub_array(Height, Max_idx),\\n    Second_half = sub_array(lists:reverse(Height), N - Max_idx - 1),\\n    Result = process_heights(First_half) + process_heights(Second_half),\\n    Result.\\n    %%reverse_array(Height).\\n\\n\\nprocess_heights(List) ->\\n    process_heights(List, 0, 0).\\n\\nprocess_heights([], _Cur_max, Result) ->\\n    Result;\\nprocess_heights([Head | Rest], Cur_max, Cur_res) when Head > Cur_max ->\\n    process_heights(Rest, Head, Cur_res);\\nprocess_heights([Head | Rest], Cur_max, Cur_res) ->\\n    New_res = Cur_res + Cur_max - Head,\\n    process_heights(Rest, Cur_max, New_res).\\n\\n\\nmax_height([Head | Rest]) ->\\n    max_height(Rest, {Head, 0}, 1).\\n\\nmax_height([Head | Rest], {Cur_max, _Idx}, Idx) when Head > Cur_max ->\\n    max_height(Rest, {Head, Idx}, Idx + 1);\\nmax_height([_Head | Rest], Cur_max, Idx) ->\\n    max_height(Rest, Cur_max, Idx + 1);\\nmax_height([], Max_Set, _Idx) ->\\n    Max_Set.\\n\\n\\nsub_array(List, Left) ->\\n    sub_array(List, Left, []).\\n\\nsub_array(_List, Left, Sub_array) when Left == 0 ->\\n    lists:reverse(Sub_array);\\nsub_array([Head | Rest], Left, Cur_array) ->\\n    sub_array(Rest, Left - 1, [Head | Cur_array]).\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2593994,
                "title": "o-n-space-and-time-python-3-line-only-well-commented",
                "content": "```\\nclass Solution:\\n    def trap(self, h: List[int]) -> int:\\n        # calculating running max from left to right.\\n        lmax=list(accumulate(h,max))\\n        # calculating running max from right to left.\\n        rmax=list(accumulate(h[::-1],max))[::-1]\\n        \\n        # print(lmax)\\n        # print(h)\\n        # print(rmax)\\n        \\n        # return the sum of indivisual water store in i.\\n        \\n        # indivisual water stored is difference of\\n        # i\\'th height from min of max heights of left and right \\n        return sum(min(l,r)-i  for l,i,r in zip(lmax,h,rmax))\\n        \\n        #TC : O(n) for 3 times linear traversal.\\n        #SC : O(n) for 2 running list\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, h: List[int]) -> int:\\n        # calculating running max from left to right.\\n        lmax=list(accumulate(h,max))\\n        # calculating running max from right to left.\\n        rmax=list(accumulate(h[::-1],max))[::-1]\\n        \\n        # print(lmax)\\n        # print(h)\\n        # print(rmax)\\n        \\n        # return the sum of indivisual water store in i.\\n        \\n        # indivisual water stored is difference of\\n        # i\\'th height from min of max heights of left and right \\n        return sum(min(l,r)-i  for l,i,r in zip(lmax,h,rmax))\\n        \\n        #TC : O(n) for 3 times linear traversal.\\n        #SC : O(n) for 2 running list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591050,
                "title": "java-solution-commented",
                "content": "```\\n// Time complexity : O(n)\\n// Space Complexity : O(n) + O(n)\\nclass Solution {\\n    \\n    public int trap(int[] height) {\\n        \\n        int n = height.length, ans = 0, i;\\n        \\n        // store left max for every elevation map in array\\n        // store -1 if rain water can\\'t trapped by any elevation map, else store max \\n        int[] left = new int[n];\\n        left[0] = height[0];\\n        for(i = 1; i < n; i++)\\n            left[i] = Math.max(left[i-1], height[i]);\\n        \\n        // store right max for every elevation map in array\\n        int[] right = new int[n];\\n        right[n-1] = height[n-1];\\n        for(i = n-2; i >= 0; i--)\\n            right[i] = Math.max(right[i+1], height[i]);\\n        \\n        // compare left and right max for every elvation map\\n        // for ith elevation map trapped water will be min(leftmax, rightmax)-height[i]\\n        for(i = 0; i < n; i++)\\n            ans += Math.max(0, Math.min((left[i]-height[i]), (right[i]-height[i])));\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity : O(n)\\n// Space Complexity : O(n) + O(n)\\nclass Solution {\\n    \\n    public int trap(int[] height) {\\n        \\n        int n = height.length, ans = 0, i;\\n        \\n        // store left max for every elevation map in array\\n        // store -1 if rain water can\\'t trapped by any elevation map, else store max \\n        int[] left = new int[n];\\n        left[0] = height[0];\\n        for(i = 1; i < n; i++)\\n            left[i] = Math.max(left[i-1], height[i]);\\n        \\n        // store right max for every elevation map in array\\n        int[] right = new int[n];\\n        right[n-1] = height[n-1];\\n        for(i = n-2; i >= 0; i--)\\n            right[i] = Math.max(right[i+1], height[i]);\\n        \\n        // compare left and right max for every elvation map\\n        // for ith elevation map trapped water will be min(leftmax, rightmax)-height[i]\\n        for(i = 0; i < n; i++)\\n            ans += Math.max(0, Math.min((left[i]-height[i]), (right[i]-height[i])));\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590873,
                "title": "two-approaches-c-easy-to-understand",
                "content": "# Storing Max \\nConsider every block one by one , now for this block to be filled there should be block greater than it both before and after it .\\nSo , we can create a max prefix and suffix array and for every index  we will be knowing the max height of blocks from start to this index and the max height from index to end. So the water that will be trapped will be  :  `min(start[i],end[i])-height[i]` \\nEg.  1 3 2 4   \\nnow water trapped at index 2 will be  ;  `min( 3 , 4) - 2 = 1`\\n\\n**Time : O(n)\\nSpace : O(n)**\\n\\n```\\n        int n = height.size();\\n        vector<int> start(n,0);\\n        vector<int> end(n,0);\\n        \\n        for(int i =0;i<n;i++){\\n            if(i==0)start[i] = height[i];\\n            else{\\n                start[i] = max(start[i-1],height[i]);\\n            }\\n        }\\n        for(int i =n-1;i>=0;i--){\\n            if(i==n-1)end[i] = height[i];\\n            else{\\n                end[i] = max(end[i+1],height[i]);\\n            }\\n        }\\n        \\n        \\n        int res = 0;\\n        for(int i =0;i<n;i++){\\n            res+= (min(start[i],end[i])-height[i]);\\n        }\\n        \\n        \\n        return res;\\n```\\n\\n# Two Pointer Approach\\nThis is a very non intuitive approach . We will make two pointers i and j at start and end of array, Now until i<=j or j < i we will keep on moving the other smaller pointer towards the larger one. Also , we have a track of max seen before( from start to i) and from j to end. So , if  `height[i] < height[j]` this means that water will be trapped in ith block , also we know max ht before i (maxi) ,and the max ht after  j (**max height after j  will be just greater than max ht before  beacuse when we would have reached maxi by i  , we had tried to make j as big as i** ). \\n\\n**Time   : O(n)\\nSpace : O(1)**\\n\\n\\n```\\n   int i =0,j = height.size()-1;\\n        int res = 0;\\n        int max1 = INT_MIN;\\n        int max2 = INT_MIN;\\n        while(i<=j){\\n            \\n            max1 = max(max1,height[i]);\\n            max2 = max(max2,height[j]);\\n            \\n            res += min(max1,max2)-min(height[i],height[j]);\\n            \\n            if(height[i]<height[j])i++;\\n            else{\\n                j--;\\n            }\\n            \\n        }\\n        return res;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n        int n = height.size();\\n        vector<int> start(n,0);\\n        vector<int> end(n,0);\\n        \\n        for(int i =0;i<n;i++){\\n            if(i==0)start[i] = height[i];\\n            else{\\n                start[i] = max(start[i-1],height[i]);\\n            }\\n        }\\n        for(int i =n-1;i>=0;i--){\\n            if(i==n-1)end[i] = height[i];\\n            else{\\n                end[i] = max(end[i+1],height[i]);\\n            }\\n        }\\n        \\n        \\n        int res = 0;\\n        for(int i =0;i<n;i++){\\n            res+= (min(start[i],end[i])-height[i]);\\n        }\\n        \\n        \\n        return res;\\n```\n```\\n   int i =0,j = height.size()-1;\\n        int res = 0;\\n        int max1 = INT_MIN;\\n        int max2 = INT_MIN;\\n        while(i<=j){\\n            \\n            max1 = max(max1,height[i]);\\n            max2 = max(max2,height[j]);\\n            \\n            res += min(max1,max2)-min(height[i],height[j]);\\n            \\n            if(height[i]<height[j])i++;\\n            else{\\n                j--;\\n            }\\n            \\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589671,
                "title": "daily-leetcoding-challenge-september-day-18",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/trapping-rain-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Using stacks\n\n  \n**Approach 4:** Using 2 pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/trapping-rain-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2556771,
                "title": "javascript-solution-3-approach-bf-two-pointer-stack",
                "content": "**Brute Force Approach**\\n\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nconst trap = (height) => {\\n\\n    let largest = height[0];\\n    let largestIndex = 0;\\n    let water = 0;\\n\\n    for(let i=1; i height[i-1]) {\\n            \\n            // what is the max water level\\n            let fill = Math.min(largest, height[i]);\\n            \\n            // fill in the water between largest and i\\n            for(let j=largestIndex+1; j largest) {\\n                largest = height[i];\\n                largestIndex = i;\\n            }\\n            \\n        }\\n        \\n    }\\n    return water;\\n};\\n```\\n\\n**Time Complexity**\\n\\nWe are traversing through the complete array which needs O(N). Additionally, we calculate max values while traversing through the array which takes O(N). Hence the time complexity is **O(N\\xB2)**.\\n\\n**Space Complexity**\\n\\nSince we are not using any extra space, space complexity is O(1).\\n\\n\\n**Two Pointer Approach**\\n\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\n\\nvar trap = function(height) {\\n    let left = 0,right = height.length-1;\\n    let trappedWater = 0;\\n    let leftMaxHegith = 0;\\n    let rightMaxHegith = 0;\\n    \\n    while(left <= right){\\n        if(height[left] < height[right]){\\n            if(height[left] > leftMaxHegith){\\n                leftMaxHegith = height[left];\\n            }else{\\n                trappedWater+= leftMaxHegith - height[left];\\n            }\\n            left++;\\n        }else{\\n            if(height[right] > rightMaxHegith){\\n                rightMaxHegith = height[right];\\n            }else{\\n                trappedWater+=rightMaxHegith-height[right];\\n            }\\n            right--;\\n        }\\n    }\\n    return trappedWater;\\n};\\n```\\n\\n**Time Complexity**\\n\\nWe are traversing through the complete array which needs **O(N).**\\n\\n**Space Complexity**\\n\\nWe are using 2 extra arrays of size N to store max values, hence space complexity is **O(N).**\\n\\n**Approach 3:**\\n\\nUsing stack, a smart approach\\n\\nTime: O(n) all elements are pushes and pop once\\n\\n```\\nvar trap = function(height) {\\n    let stack = new Stack()\\n    let i = 0\\n    let ret = 0\\n    while(i < height.length) {\\n        if (stack.isEmpty() || height[i] <= height[stack.peek()]) {\\n            stack.push(i++)\\n        } else {\\n            let middle = stack.pop()\\n            if (!stack.isEmpty()) {\\n                let minHeight = Math.min(height[i], height[stack.peek()])\\n                ret += (minHeight - height[middle]) * (i - stack.peek() - 1)\\n            }\\n        }\\n    }\\n    return ret\\n};\\n\\nclass Stack {\\n    constructor() {\\n        this.stack = []\\n    }\\n    push(a) {\\n        this.stack.push(a)\\n    }\\n    pop() {\\n        return this.stack.pop()\\n    }\\n    peek() {\\n        return this.stack[this.stack.length - 1]\\n    }\\n    size() {\\n        return this.stack.length\\n    }\\n    isEmpty() {\\n        return this.stack.length == 0\\n    }\\n}\\n```\\n\\nFor more details you can check \\nhttps://leet-codes.blogspot.com/2022/09/42-trapping-rain-water-stack.html",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nconst trap = (height) => {\\n\\n    let largest = height[0];\\n    let largestIndex = 0;\\n    let water = 0;\\n\\n    for(let i=1; i height[i-1]) {\\n            \\n            // what is the max water level\\n            let fill = Math.min(largest, height[i]);\\n            \\n            // fill in the water between largest and i\\n            for(let j=largestIndex+1; j largest) {\\n                largest = height[i];\\n                largestIndex = i;\\n            }\\n            \\n        }\\n        \\n    }\\n    return water;\\n};\\n```\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\n\\nvar trap = function(height) {\\n    let left = 0,right = height.length-1;\\n    let trappedWater = 0;\\n    let leftMaxHegith = 0;\\n    let rightMaxHegith = 0;\\n    \\n    while(left <= right){\\n        if(height[left] < height[right]){\\n            if(height[left] > leftMaxHegith){\\n                leftMaxHegith = height[left];\\n            }else{\\n                trappedWater+= leftMaxHegith - height[left];\\n            }\\n            left++;\\n        }else{\\n            if(height[right] > rightMaxHegith){\\n                rightMaxHegith = height[right];\\n            }else{\\n                trappedWater+=rightMaxHegith-height[right];\\n            }\\n            right--;\\n        }\\n    }\\n    return trappedWater;\\n};\\n```\n```\\nvar trap = function(height) {\\n    let stack = new Stack()\\n    let i = 0\\n    let ret = 0\\n    while(i < height.length) {\\n        if (stack.isEmpty() || height[i] <= height[stack.peek()]) {\\n            stack.push(i++)\\n        } else {\\n            let middle = stack.pop()\\n            if (!stack.isEmpty()) {\\n                let minHeight = Math.min(height[i], height[stack.peek()])\\n                ret += (minHeight - height[middle]) * (i - stack.peek() - 1)\\n            }\\n        }\\n    }\\n    return ret\\n};\\n\\nclass Stack {\\n    constructor() {\\n        this.stack = []\\n    }\\n    push(a) {\\n        this.stack.push(a)\\n    }\\n    pop() {\\n        return this.stack.pop()\\n    }\\n    peek() {\\n        return this.stack[this.stack.length - 1]\\n    }\\n    size() {\\n        return this.stack.length\\n    }\\n    isEmpty() {\\n        return this.stack.length == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521981,
                "title": "explanation-simplest-solution-with-o-n-beats-99",
                "content": "**Time**- O(n)\\n**Space**- O(1)\\n**Explanation:-**\\n1) First we find the maximum height in the structure. This takes one iteration.\\n2) Next we split the structure in 2 parts- one on the left of the maximum height, and one on the right of the maximum height. \\n3) Now in the left part, we start iterating from leftmost index till the maximum height block. Let\\'s say we are at an index i, so the water that can be collected over i will the difference of maximum height on the left of i and the height of i (water at i=(max_height_left)-height(i)). Because on right of i we already have the maximum height of the whole strcuture, so the maximum_height_left will always be smaller than maximum_height_right.\\n4) Similarly for the right part of the structure, we start traversing from the right most end. And we have the maximum height of the whole structure on its left end.\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n=len(height)\\n        h=height[0]\\n        index=0\\n        water=0\\n\\t\\t# first calculate maximum height and store it and its index.\\n        for i in range(1,n):\\n            if height[i]>h:\\n                h=height[i]\\n                index=i\\n        l=r=0  # l is the maximum height found till the current index while traversing the left part. Similarly r is for the right part. \\n\\t\\t\\n\\t\\t# traversing the left part\\n\\t\\t for i in range(index):\\n            if height[i]<l:    # if height at current index is smaller than the maximum height found on its left, water can be trapped there.\\n                water+=l-height[i]\\n            elif height[i]>l:   # else we update the maximum height found until now.\\n                l=height[i]\\n\\t\\t\\n\\t\\t# traversing the right part\\n        for i in range(n-1,index,-1):\\n            if height[i]<r:\\n                water+=r-height[i]\\n            elif height[i]>r:\\n                r=height[i]\\n\\n       \\n        return water\\n```\\n**Please upvote if you like the solution**\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n=len(height)\\n        h=height[0]\\n        index=0\\n        water=0\\n\\t\\t# first calculate maximum height and store it and its index.\\n        for i in range(1,n):\\n            if height[i]>h:\\n                h=height[i]\\n                index=i\\n        l=r=0  # l is the maximum height found till the current index while traversing the left part. Similarly r is for the right part. \\n\\t\\t\\n\\t\\t# traversing the left part\\n\\t\\t for i in range(index):\\n            if height[i]<l:    # if height at current index is smaller than the maximum height found on its left, water can be trapped there.\\n                water+=l-height[i]\\n            elif height[i]>l:   # else we update the maximum height found until now.\\n                l=height[i]\\n\\t\\t\\n\\t\\t# traversing the right part\\n        for i in range(n-1,index,-1):\\n            if height[i]<r:\\n                water+=r-height[i]\\n            elif height[i]>r:\\n                r=height[i]\\n\\n       \\n        return water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504992,
                "title": "java-100-faster-interview-format-explanation-clean-code",
                "content": "Upvote if the solution helped :) For all my optimised solutions, Click || -->[Here](https://github.com/abhideepghosh/Leetcode-Solutions)<-- ||\\n```\\n/*\\nRuntime: 1 ms, faster than 99.76% of Java online submissions for Trapping Rain Water.\\nMemory Usage: 42.9 MB, less than 93.35% of Java online submissions for Trapping Rain Water.\\n*/\\n// Best Solution TC: O(N) SC: O(1)\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        // Declaring 2 Pointers At Start And End\\n        int left = 0;\\n        int right = height.length - 1;\\n        \\n        // For Storing Result\\n        int result = 0;\\n        \\n        // For Storing Maximum From Left Side And Right Side In The Array While Traversing Using The Two Pointers \\n        int leftMax = 0;\\n        int rightMax = 0;\\n        \\n        // Iterating Using 2 Pointers\\n        while(left < right){\\n            \\n            // If Height At Left Pointer Is Smaller Than Height At Right Pointer\\n            if(height[left] < height[right]){\\n                \\n                // We Check If Height At Left Is Larger Than leftMax\\n                // If It Is, Then We Store The Value Of Height At leftMax\\n                // Else, We Add The leftMax - Height Value To Amount Of Water\\n                // We Do The Same For The Right Pointer\\n                if(height[left] >= leftMax){\\n                    leftMax = height[left];\\n                }\\n                else{\\n                    result += (leftMax - height[left]);\\n                }\\n                \\n                left++;\\n                \\n            }\\n            else{\\n                \\n                if(height[right] >= rightMax){\\n                    rightMax = height[right];\\n                }\\n                else{\\n                    result += (rightMax - height[right]);\\n                }\\n                \\n                right--;\\n                \\n            }\\n            \\n        }\\n        \\n        // Returning Result\\n        return result;\\n        \\n    }\\n}\\n\\n\\n\\n/*\\nRuntime: 1 ms, faster than 99.76% of Java online submissions for Trapping Rain Water.\\nMemory Usage: 48.8 MB, less than 52.21% of Java online submissions for Trapping Rain Water.\\n*/\\n// Optimized Solution TC: O(n) SC: O(n)\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int heightLength = height.length;\\n        int[] leftMaxSize = new int[heightLength];\\n        int[] rightMaxSize = new int[heightLength];\\n        \\n        // Storing The Total Amount Of Water \\n        int amountOfWaterStored = 0;\\n        \\n        /*\\n        Approach:\\n          1. We Calculate The Max Height From Left And Right, Then Taking Their Minimum And Subtracting It\\n             With The Current Height Will Give Us The Amount Of Water Stored Above The Current Element.\\n          2. Then We Keep Adding The Amount Of Water To The Total Amount Of Water And Finally We Return The \\n             Answer.\\n        */\\n        int currentMax = 0;\\n        \\n        for(int i=0; i<heightLength; i++){\\n            if(currentMax < height[i]){\\n                currentMax = height[i];\\n            }\\n            leftMaxSize[i] = currentMax;\\n        }\\n        \\n        currentMax = 0;\\n        \\n        for(int i=heightLength-1; i>=0; i--){\\n            if(currentMax < height[i]){\\n                currentMax = height[i];\\n            }\\n            rightMaxSize[i] = currentMax;\\n        }\\n        \\n        for(int i=0; i<heightLength; i++){\\n            amountOfWaterStored += Math.min(leftMaxSize[i], rightMaxSize[i]) - height[i];\\n        }\\n        \\n        // Returning The Total Amount Of Water Stored.\\n        return amountOfWaterStored;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nRuntime: 1 ms, faster than 99.76% of Java online submissions for Trapping Rain Water.\\nMemory Usage: 42.9 MB, less than 93.35% of Java online submissions for Trapping Rain Water.\\n*/\\n// Best Solution TC: O(N) SC: O(1)\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        // Declaring 2 Pointers At Start And End\\n        int left = 0;\\n        int right = height.length - 1;\\n        \\n        // For Storing Result\\n        int result = 0;\\n        \\n        // For Storing Maximum From Left Side And Right Side In The Array While Traversing Using The Two Pointers \\n        int leftMax = 0;\\n        int rightMax = 0;\\n        \\n        // Iterating Using 2 Pointers\\n        while(left < right){\\n            \\n            // If Height At Left Pointer Is Smaller Than Height At Right Pointer\\n            if(height[left] < height[right]){\\n                \\n                // We Check If Height At Left Is Larger Than leftMax\\n                // If It Is, Then We Store The Value Of Height At leftMax\\n                // Else, We Add The leftMax - Height Value To Amount Of Water\\n                // We Do The Same For The Right Pointer\\n                if(height[left] >= leftMax){\\n                    leftMax = height[left];\\n                }\\n                else{\\n                    result += (leftMax - height[left]);\\n                }\\n                \\n                left++;\\n                \\n            }\\n            else{\\n                \\n                if(height[right] >= rightMax){\\n                    rightMax = height[right];\\n                }\\n                else{\\n                    result += (rightMax - height[right]);\\n                }\\n                \\n                right--;\\n                \\n            }\\n            \\n        }\\n        \\n        // Returning Result\\n        return result;\\n        \\n    }\\n}\\n\\n\\n\\n/*\\nRuntime: 1 ms, faster than 99.76% of Java online submissions for Trapping Rain Water.\\nMemory Usage: 48.8 MB, less than 52.21% of Java online submissions for Trapping Rain Water.\\n*/\\n// Optimized Solution TC: O(n) SC: O(n)\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int heightLength = height.length;\\n        int[] leftMaxSize = new int[heightLength];\\n        int[] rightMaxSize = new int[heightLength];\\n        \\n        // Storing The Total Amount Of Water \\n        int amountOfWaterStored = 0;\\n        \\n        /*\\n        Approach:\\n          1. We Calculate The Max Height From Left And Right, Then Taking Their Minimum And Subtracting It\\n             With The Current Height Will Give Us The Amount Of Water Stored Above The Current Element.\\n          2. Then We Keep Adding The Amount Of Water To The Total Amount Of Water And Finally We Return The \\n             Answer.\\n        */\\n        int currentMax = 0;\\n        \\n        for(int i=0; i<heightLength; i++){\\n            if(currentMax < height[i]){\\n                currentMax = height[i];\\n            }\\n            leftMaxSize[i] = currentMax;\\n        }\\n        \\n        currentMax = 0;\\n        \\n        for(int i=heightLength-1; i>=0; i--){\\n            if(currentMax < height[i]){\\n                currentMax = height[i];\\n            }\\n            rightMaxSize[i] = currentMax;\\n        }\\n        \\n        for(int i=0; i<heightLength; i++){\\n            amountOfWaterStored += Math.min(leftMaxSize[i], rightMaxSize[i]) - height[i];\\n        }\\n        \\n        // Returning The Total Amount Of Water Stored.\\n        return amountOfWaterStored;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469902,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=AjDjQOZsxsw",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=AjDjQOZsxsw",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575052,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1570326,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1901747,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1574067,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1572273,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1566651,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1575903,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1849112,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1866042,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1900237,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1575052,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1570326,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1901747,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1574067,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1572273,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1566651,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1575903,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1849112,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1866042,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1900237,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1844255,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1934619,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1781555,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1567823,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1637194,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1927736,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1895382,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1693248,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1644701,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1576600,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1571104,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 1571105,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 1568867,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2073975,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2073794,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2073354,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2073350,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2064784,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2038047,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2028233,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2022626,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 2013762,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 2007429,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 2000343,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1994346,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1973131,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1961073,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1958232,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1953883,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1950338,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1946675,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1943565,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1939861,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1939291,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1935287,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1932542,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1932380,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1932160,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1927470,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1908979,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1902863,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1890875,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1862645,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1852147,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1842433,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1841622,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1841424,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1840633,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1806431,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1798196,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1766095,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1756272,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1752620,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1739346,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1734310,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1732562,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1732056,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1727077,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1726535,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1723382,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1722980,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1716294,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1711501,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1711117,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1709127,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1698259,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1676815,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1672180,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1665827,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1650063,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    }
]