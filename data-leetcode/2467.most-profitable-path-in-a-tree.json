[
    {
        "title": "Most Profitable Path in a Tree",
        "question_content": "There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAt every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:\n\n\tthe price needed to open the gate at node i, if amount[i] is negative, or,\n\tthe cash reward obtained on opening the gate at node i, otherwise.\n\nThe game goes on as follows:\n\n\tInitially, Alice is at node 0 and Bob is at node bob.\n\tAt every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.\n\tFor every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:\n\t\n\t\tIf the gate is already open, no price will be required, nor will there be any cash reward.\n\t\tIf Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay&nbsp;c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each.\n\t\n\t\n\tIf Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other.\n\nReturn the maximum net income Alice can have if she travels towards the optimal leaf node.\n&nbsp;\nExample 1:\n\nInput: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]\nOutput: 6\nExplanation: \nThe above diagram represents the given tree. The game goes as follows:\n- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.\n  Alice's net income is now -2.\n- Both Alice and Bob move to node 1. \n&nbsp; Since they reach here simultaneously, they open the gate together and share the reward.\n&nbsp; Alice's net income becomes -2 + (4 / 2) = 0.\n- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.\n&nbsp; Bob moves on to node 0, and stops moving.\n- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.\nNow, neither Alice nor Bob can make any further moves, and the game ends.\nIt is not possible for Alice to get a higher net income.\n\nExample 2:\n\nInput: edges = [[0,1]], bob = 1, amount = [-7280,2350]\nOutput: -7280\nExplanation: \nAlice follows the path 0->1 whereas Bob follows the path 1->0.\nThus, Alice opens the gate at node 0 only. Hence, her net income is -7280. \n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 105\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= ai, bi < n\n\tai != bi\n\tedges represents a valid tree.\n\t1 <= bob < n\n\tamount.length == n\n\tamount[i] is an even integer in the range [-104, 104].",
        "solutions": [
            {
                "id": 2807150,
                "title": "2-dfs-1-dfs-simple-approach-c",
                "content": "<h5>Main Idea</h5>\\nAlice can travel to any leaf from 0 but there is only one path for Bob. So we will find the path Bob will follow and update the contribution of each node in the path first.\\n\\nWith the first dfs we will find the time to travel to each node <b>\\'u\\'</b> from 0 and previous node  of <b>\\'u\\'</b> in the path.\\nNow we can follow the path from Bob\\'s node to 0 using the previous node we found earlier. In each node \\'u\\' we will check if Alice will reach it first or Bob will. If Bob reaches it faster than Alice, we will make amount[u] = 0 and if both of them reaches at the same time we make amount[u] =amount[u]/2.\\n\\nFinally we will run our second dfs to find the cumulative sum of amount in the path to each leaf and return the maximum.\\n<h5>Sample Code</h5>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<int>par,dis;\\n\\t//Find the parent and distance from node 0\\n    void dfs(int u,int p = 0,int d = 0){\\n        dis[u] = d;\\n        par[u] = p;\\n        for(int v:adj[u]){\\n            if(v==p)continue;\\n            dfs(v,u,d+1);\\n        }\\n    }\\n\\t// Find total sum to each node\\n    int dfs2(int u,vector<int>&amount,int p= 0){\\n        int ret = amount[u];\\n        int mxc = -INT_MAX;\\n        for(int v:adj[u]){\\n            if(v!=p){\\n                mxc= max(mxc,dfs2(v,amount,u));\\n            }\\n        }\\n\\t\\t//if the node is leaf we just return its amount\\n        if(mxc==-INT_MAX)return ret;\\n        else return ret+mxc;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        adj.resize(n,vector<int>());\\n        for(auto&e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        par.resize(n);\\n        dis.resize(n);\\n        dfs(0);\\n        int cur = bob;\\n        int bob_dis = 0;\\n\\t\\t//update the path of from Bob to 0\\n        while(cur!=0){\\n            if(dis[cur]>bob_dis){\\n                amount[cur] = 0;\\n            }else if(dis[cur]==bob_dis){\\n                amount[cur]/=2;\\n            }\\n            cur = par[cur];\\n            bob_dis++;\\n        }\\n        return dfs2(0,amount);\\n    }\\n    \\n};\\n```\\n<h5>Single DFS </h5>\\nThe idea was taken from <a href=\"https://leetcode.com/problems/most-profitable-path-in-a-tree/discuss/2807411/Python-One-DFS\">this</a> solution.\\n\\nThe first dfs we ran earlier is only used to calculate the path and depth. We can merge this first dfs with the second one by taking additional vector that stores the distance from Bob\\'s node.Then we can update the amount array and calculate path some at the same time. \\n\\nSample Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<int>disFromBob;\\n    int bobNode;\\n    int dfs(int u,int par,int depth,vector<int>&amount){\\n        int ret = 0;\\n        if(u==bobNode) disFromBob[u] = 0;\\n        else disFromBob[u] = amount.size();\\n        int maxChild = -INT_MAX;\\n        for(int v:adj[u]){\\n            if(v==par)continue;\\n            maxChild = max(maxChild,dfs(v,u,depth+1,amount));\\n            disFromBob[u] = min(disFromBob[u],disFromBob[v]+1);\\n        }\\n        if(disFromBob[u]>depth)ret+=amount[u];\\n        else if(disFromBob[u]==depth)ret+=amount[u]/2;\\n        if(maxChild==-INT_MAX) return ret;\\n        else return ret+maxChild;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        bobNode = bob;\\n        adj.resize(n,vector<int>());\\n        for(auto&e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        disFromBob.resize(n);\\n        return dfs(0,0,0,amount);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<int>par,dis;\\n\\t//Find the parent and distance from node 0\\n    void dfs(int u,int p = 0,int d = 0){\\n        dis[u] = d;\\n        par[u] = p;\\n        for(int v:adj[u]){\\n            if(v==p)continue;\\n            dfs(v,u,d+1);\\n        }\\n    }\\n\\t// Find total sum to each node\\n    int dfs2(int u,vector<int>&amount,int p= 0){\\n        int ret = amount[u];\\n        int mxc = -INT_MAX;\\n        for(int v:adj[u]){\\n            if(v!=p){\\n                mxc= max(mxc,dfs2(v,amount,u));\\n            }\\n        }\\n\\t\\t//if the node is leaf we just return its amount\\n        if(mxc==-INT_MAX)return ret;\\n        else return ret+mxc;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        adj.resize(n,vector<int>());\\n        for(auto&e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        par.resize(n);\\n        dis.resize(n);\\n        dfs(0);\\n        int cur = bob;\\n        int bob_dis = 0;\\n\\t\\t//update the path of from Bob to 0\\n        while(cur!=0){\\n            if(dis[cur]>bob_dis){\\n                amount[cur] = 0;\\n            }else if(dis[cur]==bob_dis){\\n                amount[cur]/=2;\\n            }\\n            cur = par[cur];\\n            bob_dis++;\\n        }\\n        return dfs2(0,amount);\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<int>disFromBob;\\n    int bobNode;\\n    int dfs(int u,int par,int depth,vector<int>&amount){\\n        int ret = 0;\\n        if(u==bobNode) disFromBob[u] = 0;\\n        else disFromBob[u] = amount.size();\\n        int maxChild = -INT_MAX;\\n        for(int v:adj[u]){\\n            if(v==par)continue;\\n            maxChild = max(maxChild,dfs(v,u,depth+1,amount));\\n            disFromBob[u] = min(disFromBob[u],disFromBob[v]+1);\\n        }\\n        if(disFromBob[u]>depth)ret+=amount[u];\\n        else if(disFromBob[u]==depth)ret+=amount[u]/2;\\n        if(maxChild==-INT_MAX) return ret;\\n        else return ret+maxChild;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        bobNode = bob;\\n        adj.resize(n,vector<int>());\\n        for(auto&e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        disFromBob.resize(n);\\n        return dfs(0,0,0,amount);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807207,
                "title": "c-simple-dfs-and-bfs-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool DFS(int src, int time, unordered_map<int,int> &path, vector<bool> &visited, vector<vector<int>> &graph){\\n        path[src] = time;\\n        visited[src] = true;\\n        if(src == 0){\\n            return true;\\n        }\\n        for(auto adj: graph[src]){\\n            if(!visited[adj]){\\n                if(DFS(adj, time+1, path, visited, graph)){\\n                    return true;\\n                }\\n            }\\n        }   \\n        path.erase(src);\\n        return false;\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size()+1;\\n        vector<vector<int>> graph(n);\\n        for(auto it: edges){\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        \\n        // Find the path taken by bob to reach zero along with the time at which bob visited that node\\n        unordered_map<int,int> path;\\n        vector<bool> visited(n, false);\\n        DFS(bob, 0, path, visited, graph);\\n        \\n        // Push {src, time, income}\\n        queue<vector<int>> q;\\n        q.push({0, 0, 0});\\n        visited.assign(n, false);\\n                \\n        int ans = INT_MIN;\\n        while(!q.empty()){\\n            int src = q.front()[0], time = q.front()[1], income = q.front()[2];\\n            q.pop();\\n            visited[src] = true;\\n            \\n            // If bob didn\\'t visit this node\\n            if(path.find(src) == path.end()){\\n                income += amount[src];\\n            }\\n            else{\\n                // Alice visits it first\\n                if(time < path[src]){\\n                    income += amount[src];\\n                }\\n                // Both visit at the same time\\n                else if(time == path[src]){\\n                    income += (amount[src]/2);\\n                }\\n            }\\n                        \\n            // Updating when it is leaf\\n            if(graph[src].size() == 1 && src != 0){\\n                ans = max(ans, income);\\n            }\\n\\t\\t\\t// Exploring adjacent vertices\\n            for(auto adj: graph[src]){\\n                if(!visited[adj]){\\n                    q.push({adj, time+1, income});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool DFS(int src, int time, unordered_map<int,int> &path, vector<bool> &visited, vector<vector<int>> &graph){\\n        path[src] = time;\\n        visited[src] = true;\\n        if(src == 0){\\n            return true;\\n        }\\n        for(auto adj: graph[src]){\\n            if(!visited[adj]){\\n                if(DFS(adj, time+1, path, visited, graph)){\\n                    return true;\\n                }\\n            }\\n        }   \\n        path.erase(src);\\n        return false;\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size()+1;\\n        vector<vector<int>> graph(n);\\n        for(auto it: edges){\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        \\n        // Find the path taken by bob to reach zero along with the time at which bob visited that node\\n        unordered_map<int,int> path;\\n        vector<bool> visited(n, false);\\n        DFS(bob, 0, path, visited, graph);\\n        \\n        // Push {src, time, income}\\n        queue<vector<int>> q;\\n        q.push({0, 0, 0});\\n        visited.assign(n, false);\\n                \\n        int ans = INT_MIN;\\n        while(!q.empty()){\\n            int src = q.front()[0], time = q.front()[1], income = q.front()[2];\\n            q.pop();\\n            visited[src] = true;\\n            \\n            // If bob didn\\'t visit this node\\n            if(path.find(src) == path.end()){\\n                income += amount[src];\\n            }\\n            else{\\n                // Alice visits it first\\n                if(time < path[src]){\\n                    income += amount[src];\\n                }\\n                // Both visit at the same time\\n                else if(time == path[src]){\\n                    income += (amount[src]/2);\\n                }\\n            }\\n                        \\n            // Updating when it is leaf\\n            if(graph[src].size() == 1 && src != 0){\\n                ans = max(ans, income);\\n            }\\n\\t\\t\\t// Exploring adjacent vertices\\n            for(auto adj: graph[src]){\\n                if(!visited[adj]){\\n                    q.push({adj, time+1, income});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2807411,
                "title": "python-one-dfs",
                "content": "# **Explanation**\\n`d0` is the distance from node `0` to node `i`\\n`db` is the distance from node `i` to node `bob`.\\nIf node `i` is not ancestor of `bob`, we define `db >= n`.\\n\\nSo in the dfs, we first pick out the biggest sum of sub path.\\nIf the node has no child, then the biggest sum is `0`.\\nnow we compare `d0` and `db`.\\nIf `d0 == db`, this node is in the middle point between node 0 and node bob.\\nIf `d0 < db`, Bob will arrive this node first, so no score.\\n\\nFinally we return the score `res` and the incremented distance `db + 1`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = len(edges) + 1\\n        G = [[] for i in range(n)]\\n        for i,j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        seen = [0] * n\\n\\n        def dfs(i, d0):\\n            seen[i] = 1\\n            res = -inf\\n            db = 0 if i == bob else n\\n            for j in G[i]:\\n                if seen[j]: continue\\n                cur, kk = dfs(j, d0 + 1)\\n                res = max(res, cur)\\n                db = min(db, kk)\\n            if res == -inf: res = 0\\n            if d0 == db: res += amount[i] // 2\\n            if d0 < db: res += amount[i]\\n            return res, db + 1\\n\\n        return dfs(0, 0)[0]\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = len(edges) + 1\\n        G = [[] for i in range(n)]\\n        for i,j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        seen = [0] * n\\n\\n        def dfs(i, d0):\\n            seen[i] = 1\\n            res = -inf\\n            db = 0 if i == bob else n\\n            for j in G[i]:\\n                if seen[j]: continue\\n                cur, kk = dfs(j, d0 + 1)\\n                res = max(res, cur)\\n                db = min(db, kk)\\n            if res == -inf: res = 0\\n            if d0 == db: res += amount[i] // 2\\n            if d0 < db: res += amount[i]\\n            return res, db + 1\\n\\n        return dfs(0, 0)[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2807331,
                "title": "was-this-actually-tough-for-leetcode-medium",
                "content": "i felt this question was bit tougher for a typical Leetcode C. Using BFS+DFS+Time Synchroniazation in just one problem is bit of overkill for Leetcode C.\\n\\nMy opinion only. You can have different take on this.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2808192,
                "title": "python-finally-a-concise-dfs-solution-with-clean-code-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a Depth First Search approach to find both Bob\\'s path to `0` and Alice\\'s most profitable path. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Python.**\\n```\\nfrom numpy import sign\\n\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amt: List[int]) -> int:\\n\\n        graph = defaultdict(set)                           # transform the edge matrix\\n        for x, y in edges:                                 # into the adjacency map\\n            graph[x].add(y)\\n            graph[y].add(x)\\n            \\n        def income(a, t):                                  # this function returns Alice\\'s\\n            if a not in time : return amt[a]               # profit depending on whether Bob\\n            else : return (sign(time[a]-t)+1)*amt[a]//2    # has visited node \\'a\\' or not\\n        \\n        def bob_dfs(b, p, move):                           # this function finds Bob\\'s path to 0\\n            move[b] = p\\n            if b == 0:                                     # the 0\\'th node was found, thus, we\\n                path = []                                  # backtrace to the initial Bob\\'s node\\n                while b != -1:                             # that was marked with parent -1\\n                    path.append(b)    \\n                    b = move[b]\\n                return path[::-1]\\n            \\n            gen = (bob_dfs(n, b, move) for n in graph[b] if n != move[b])\\n            res = list(filter(lambda path: path != None, gen)) or [None]\\n            return res[0]\\n                      \\n        def alice_dfs(a, p, t):                            # this one-liner performs DFS\\n            return max([alice_dfs(n,a,t+1)                 # to calculate Alice\\'s maximal\\n                        for n in graph[a]                  # profit along all paths\\n                        if n != p] or [0]) + income(a,t)\\n                \\n        path = bob_dfs(bob, -1, [bob] * len(amt))          # [1] obtain Bob\\'s path to the 0\\'th node\\n        time = {b : t for t,b in enumerate(path)}          # [2] map time for each node Bob has visited\\n        return alice_dfs(0, -1, 0)                         # [3] get Alice\\'s maximal profit\\n```",
                "solutionTags": [],
                "code": "```\\nfrom numpy import sign\\n\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amt: List[int]) -> int:\\n\\n        graph = defaultdict(set)                           # transform the edge matrix\\n        for x, y in edges:                                 # into the adjacency map\\n            graph[x].add(y)\\n            graph[y].add(x)\\n            \\n        def income(a, t):                                  # this function returns Alice\\'s\\n            if a not in time : return amt[a]               # profit depending on whether Bob\\n            else : return (sign(time[a]-t)+1)*amt[a]//2    # has visited node \\'a\\' or not\\n        \\n        def bob_dfs(b, p, move):                           # this function finds Bob\\'s path to 0\\n            move[b] = p\\n            if b == 0:                                     # the 0\\'th node was found, thus, we\\n                path = []                                  # backtrace to the initial Bob\\'s node\\n                while b != -1:                             # that was marked with parent -1\\n                    path.append(b)    \\n                    b = move[b]\\n                return path[::-1]\\n            \\n            gen = (bob_dfs(n, b, move) for n in graph[b] if n != move[b])\\n            res = list(filter(lambda path: path != None, gen)) or [None]\\n            return res[0]\\n                      \\n        def alice_dfs(a, p, t):                            # this one-liner performs DFS\\n            return max([alice_dfs(n,a,t+1)                 # to calculate Alice\\'s maximal\\n                        for n in graph[a]                  # profit along all paths\\n                        if n != p] or [0]) + income(a,t)\\n                \\n        path = bob_dfs(bob, -1, [bob] * len(amt))          # [1] obtain Bob\\'s path to the 0\\'th node\\n        time = {b : t for t,b in enumerate(path)}          # [2] map time for each node Bob has visited\\n        return alice_dfs(0, -1, 0)                         # [3] get Alice\\'s maximal profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807236,
                "title": "dp-on-trees-easy-readable-code-with-explanation",
                "content": "```\\nIdea ->  1.  The first thing to notice is we have a specfic only path from Bob to 0 root. \\n           We\\'ll do a dfs to find that path and mark the vertices on those path at how much distance they\\'re at.\\n\\t      2. Now, we\\'ll traverse the whole tree from 0, we can do a dfs search with taking distance as a reference too.\\n\\t      3. If this current X vertice was visited by Bob, we\\'ll simply check if the Distance of X from 0 is < or = or > the distance from Bob. If less we\\'ll take A[x] as whole. If More we\\'ll take 0 and if equal A[x]/2;\\n\\t      4. Now, the remain question left is to take the best path we can choose from the given children.\\n             \\n\\n    vector<int>adj[200001];\\n    int vis[200001],dis[200001];\\n    int par[200001];\\n     int dp[200001];\\n    void dfs(int x,int p)\\n    {\\n      par[x]=p;\\n        for(int k:adj[x])\\n        {\\n            if(k!=p)\\n            {\\n                dfs(k,x);\\n            }\\n        }\\n    }\\n    int solve(int x,int d,vector<int>&a,int p)\\n    {\\n        int ok=0;\\n        int ans=-1e9;\\n        if(dis[x]!=-1)\\n        {\\n            if(dis[x]<d)\\n            {\\n                ok=0;\\n            }else if(dis[x]==d)\\n            {\\n                ok=a[x]/2;\\n            }else\\n            {\\n                ok=a[x];\\n            }\\n        }else\\n        {\\n            ok=a[x];\\n        }\\n\\n        int cur=-1e9;\\n        int check=0;\\n        for(int j:adj[x])\\n        {\\n            if(j!=p)\\n            {\\n                check=1;\\n                solve(j,d+1,a,x);\\n                cur=max(cur,dp[j]);\\n            }\\n        }\\n    if(!check)\\n    {\\n        cur=0;\\n    }\\n\\n        ok=ok+cur;\\n        cout<<ok<<\" \"<<x<<endl;\\n        ans=ok;\\n        return dp[x]=ans;\\n        \\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& e, int bob, vector<int>& a) {\\n        for(vector<int>x:e)\\n        {\\n            int a1=x[0]; int b=x[1];\\n            adj[a1].push_back(b);\\n            adj[b].push_back(a1);\\n        }\\n        memset(dis,-1,sizeof(dis));\\n        memset(dp,-1,sizeof(dp));\\n        dfs(0,-1);\\n        vector<int>path;\\n        int ok= bob;\\n        while(ok!=0)\\n        {\\n            path.push_back(ok);\\n            ok=par[ok];\\n        }\\n      path.push_back(0);\\n       dis[bob]=0;\\n        for(int i=1;i<path.size();i++)\\n        {\\n            dis[path[i]]=i;\\n        }\\n       int ans= solve(0,0,a,-1);\\n        \\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nIdea ->  1.  The first thing to notice is we have a specfic only path from Bob to 0 root. \\n           We\\'ll do a dfs to find that path and mark the vertices on those path at how much distance they\\'re at.\\n\\t      2. Now, we\\'ll traverse the whole tree from 0, we can do a dfs search with taking distance as a reference too.\\n\\t      3. If this current X vertice was visited by Bob, we\\'ll simply check if the Distance of X from 0 is < or = or > the distance from Bob. If less we\\'ll take A[x] as whole. If More we\\'ll take 0 and if equal A[x]/2;\\n\\t      4. Now, the remain question left is to take the best path we can choose from the given children.\\n             \\n\\n    vector<int>adj[200001];\\n    int vis[200001],dis[200001];\\n    int par[200001];\\n     int dp[200001];\\n    void dfs(int x,int p)\\n    {\\n      par[x]=p;\\n        for(int k:adj[x])\\n        {\\n            if(k!=p)\\n            {\\n                dfs(k,x);\\n            }\\n        }\\n    }\\n    int solve(int x,int d,vector<int>&a,int p)\\n    {\\n        int ok=0;\\n        int ans=-1e9;\\n        if(dis[x]!=-1)\\n        {\\n            if(dis[x]<d)\\n            {\\n                ok=0;\\n            }else if(dis[x]==d)\\n            {\\n                ok=a[x]/2;\\n            }else\\n            {\\n                ok=a[x];\\n            }\\n        }else\\n        {\\n            ok=a[x];\\n        }\\n\\n        int cur=-1e9;\\n        int check=0;\\n        for(int j:adj[x])\\n        {\\n            if(j!=p)\\n            {\\n                check=1;\\n                solve(j,d+1,a,x);\\n                cur=max(cur,dp[j]);\\n            }\\n        }\\n    if(!check)\\n    {\\n        cur=0;\\n    }\\n\\n        ok=ok+cur;\\n        cout<<ok<<\" \"<<x<<endl;\\n        ans=ok;\\n        return dp[x]=ans;\\n        \\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& e, int bob, vector<int>& a) {\\n        for(vector<int>x:e)\\n        {\\n            int a1=x[0]; int b=x[1];\\n            adj[a1].push_back(b);\\n            adj[b].push_back(a1);\\n        }\\n        memset(dis,-1,sizeof(dis));\\n        memset(dp,-1,sizeof(dp));\\n        dfs(0,-1);\\n        vector<int>path;\\n        int ok= bob;\\n        while(ok!=0)\\n        {\\n            path.push_back(ok);\\n            ok=par[ok];\\n        }\\n      path.push_back(0);\\n       dis[bob]=0;\\n        for(int i=1;i<path.size();i++)\\n        {\\n            dis[path[i]]=i;\\n        }\\n       int ans= solve(0,0,a,-1);\\n        \\n        return ans;\\n    }\\n",
                "codeTag": "C++"
            },
            {
                "id": 2808470,
                "title": "java-faster-than-100-resolve-bob-then-optimize-alice",
                "content": "**Intuition**: We can compute Bob\\'s path up to the root (0), and resolve what happens at each gate right away.  Up to, but not including, the halfway point, Bob takes or pays the entire reward/fee at each gate.  So we set `amount[i]` to 0 for each such node.  If Bob\\'s path has an even number of steps (an odd number of nodes included on the path, including his starting node (`bob`) and `0`, his ending point), then at the middle point, Bob takes or pays half of the reward/fee at that gate.  So we set `amount[i] /= 2` at that specific node (if it exists).  By doing this, we can then focus entirely on optimizing Alice\\'s path.  We are not doing things out of order so much as we are precomputing Bob\\'s effects on Alice\\'s net income should their paths overlap.\\n\\n**Traps to avoid**: As Bob nagivates towards zero, we have to track where he came from.  We\\'re in an undirected graph, but really, it\\'s a tree.  The directions matter (towards 0, away from 0).  But we can handle this by simply not allowing either Alice or Bob to return to the node they came from.  Additionally, we need to remember that both players resolve their starting position (pay or collect at their starting node) before moving to their next gate, and their starting positions may be the same point (i.e. `bob` could be `0`).  And, we need to avoid off-by-one errors when computing Bob\\'s path and whether there\\'s a middle point where he might meet Alice at the same time.\\n\\n**Optimizations**: We\\'ll find Bob\\'s path to `0` by starting at `0` and exploring until we reach Bob\\'s starting point `bob`.  We\\'ll use a node object with a parent reference (and length count) to be able to track backwards when we find Bob\\'s starting point.  This functions like a linked list of steps of Bob\\'s path from `bob` to `0`, but we find it in reverse.\\n\\n**Syntax Stuff**: I don\\'t like unparameterized uses of parameterized types.  But you can\\'t instantiate a `new ArrayList<Integer>[]`.  (I don\\'t like `new ArrayList[]` because of the unchecked warning/etc.)  So I extend `ArrayList<Integer>` with a class called `IntList`.  I find reading `IntList[]` nicer than reading `List<Integer>[]` anyway.  It\\'s a personal preference, but that\\'s the primary reason that class is there.  The static array factory method on it is just a nice way to initialize an `IntList[]` of size `n` with non-null elements and do it outside of the main solution method.  But it\\'s not necessary to do it that way.  I just find it cleaner.  If you don\\'t like it, you can make your adjacency list array (or list of lists) however you like!  Also, I isolate the resolution of Bob\\'s path on nodes that Alice may encounter (modifying the amounts array) within a separate inline block `{...}`.  It\\'s totally unnecessary, I just like the way it reads.  And finally, I use an int array of size one (`max`) to track the maximum.  I have an aversion to having solutions that have state (I do not like having fields on the Solution class).  By wrapping the max in an array, we can modify its value, and still pass it by reference as we search.  Not having it as a field means our solution remains thread-safe, etc.  It just feels like a good habit.  (We could also use some other wrapper like AtomicInteger or write a class specifically for this, but `int[1]` is pretty convenient as it is.)\\n\\n**Java Code**: O(n) time for exploring every node to compute Alice\\'s optimal path, and O(n) space for adjacency lists (graph).  Runtime as of November 12, 2022: 104ms / faster than 100%.\\n\\n```\\nclass Solution {\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        final int n = amount.length;\\n\\t\\t// Build adjacency lists (graph):\\n        final IntList[] graph = IntList.arrayOfSize(n);\\n        for (int[] edge : edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\t\\t// Find Bob\\'s path to 0 by searching depth-first from 0 to Bob\\'s starting location:\\n        final Node root = new Node(0);\\n        final Node bobNode = findBob(root, bob, graph, null);\\n        final int bobLength = bobNode.length;\\n\\t\\t// Resolve Bob\\'s impact on amounts as a result of his path.\\n        {\\n            Node node = bobNode;\\n\\t\\t\\t// Handle nodes before the halfway point (if any).\\n            while (node.length > (bobLength >> 1)) {\\n                amount[node.index] = 0;\\n                node = node.parent;\\n            }\\n\\t\\t\\t// If there is a halfway point, take or pay half of the amount at that node.\\n\\t\\t\\t// Is bobLength (number of steps, not nodes) even?  If so there\\'s a halfway point.\\n\\t\\t\\t// And, because of the way we\\'ve iterated, if it exists, it is `node`, because we\\n\\t\\t\\t// have stopped zeroing out amounts just short of that midway point.\\n            if ((bobLength & 1) == 0) {\\n                amount[node.index] /= 2;\\n            }\\n        }\\n\\t\\t// Now, optimize Alice\\'s path with a depth-first search and return her max income.\\n        int[] max = new int[] { Integer.MIN_VALUE };\\n        optimizeAlice(0, -1, graph, amount, amount[0], max);\\n        return max[0];\\n    }\\n\\n    private Node findBob(Node node, int bob, IntList[] graph, Node parent) {\\n        if (node.index == bob) {\\n            return node;\\n        }\\n        for (int n : graph[node.index]) {\\n\\t\\t\\t// Search neighbors except the neighbor we just came from.\\n            if (parent == null || parent.index != n) {\\n                final Node bobNode = findBob(new Node(n, node), bob, graph, node);\\n                if (bobNode != null) {\\n                    return bobNode;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n\\n    private void optimizeAlice(int i, int lastI, IntList[] graph, int[] amount, int income, int[] max) {\\n\\t\\t// Track number of children (neighbors not equal to lastI) so we know when we are at a leaf.\\n        int children = 0;\\n        for (int n : graph[i]) {\\n\\t\\t\\t// Search neighbors except the neighbor we just came from.\\n            if (n != lastI) {\\n                children++;\\n                optimizeAlice(n, i, graph, amount, income + amount[n], max);\\n            }\\n        }\\n        if (children == 0) {\\n            // We are at a leaf - check if income is a new maximum.\\n            if (income > max[0]) {\\n                max[0] = income;\\n            }\\n        }\\n    }\\n\\n    static class IntList extends ArrayList<Integer> {\\n\\n        static IntList[] arrayOfSize(int n) {\\n            final IntList[] out = new IntList[n];\\n            for (int i = 0; i < n; ++i) {\\n                out[i] = new IntList();\\n            }\\n            return out;\\n        }\\n    }\\n\\n    static class Node {\\n        int length;\\n        int index;\\n        Node parent;\\n\\n        Node(int index) {\\n            this.index = index;\\n            this.length = 0;\\n        }\\n\\n        Node(int index, Node parent) {\\n            this(index);\\n            this.parent = parent;\\n            this.length = 1 + parent.length;\\n        }\\n    }\\n\\t\\n}\\n```\\n\\n**Standard Plea**: If you found this useful, or interesting, or at least not a waste of time, I\\'d **appreciate your upvote so others can find this** (if you think it would be worth them reading, too).  If not, **I\\'d appreciate any constructive criticism you are willing to offer** so I can write better solutions in the future.\\n\\nThanks for reading, and happy coding!\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        final int n = amount.length;\\n\\t\\t// Build adjacency lists (graph):\\n        final IntList[] graph = IntList.arrayOfSize(n);\\n        for (int[] edge : edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\t\\t// Find Bob\\'s path to 0 by searching depth-first from 0 to Bob\\'s starting location:\\n        final Node root = new Node(0);\\n        final Node bobNode = findBob(root, bob, graph, null);\\n        final int bobLength = bobNode.length;\\n\\t\\t// Resolve Bob\\'s impact on amounts as a result of his path.\\n        {\\n            Node node = bobNode;\\n\\t\\t\\t// Handle nodes before the halfway point (if any).\\n            while (node.length > (bobLength >> 1)) {\\n                amount[node.index] = 0;\\n                node = node.parent;\\n            }\\n\\t\\t\\t// If there is a halfway point, take or pay half of the amount at that node.\\n\\t\\t\\t// Is bobLength (number of steps, not nodes) even?  If so there\\'s a halfway point.\\n\\t\\t\\t// And, because of the way we\\'ve iterated, if it exists, it is `node`, because we\\n\\t\\t\\t// have stopped zeroing out amounts just short of that midway point.\\n            if ((bobLength & 1) == 0) {\\n                amount[node.index] /= 2;\\n            }\\n        }\\n\\t\\t// Now, optimize Alice\\'s path with a depth-first search and return her max income.\\n        int[] max = new int[] { Integer.MIN_VALUE };\\n        optimizeAlice(0, -1, graph, amount, amount[0], max);\\n        return max[0];\\n    }\\n\\n    private Node findBob(Node node, int bob, IntList[] graph, Node parent) {\\n        if (node.index == bob) {\\n            return node;\\n        }\\n        for (int n : graph[node.index]) {\\n\\t\\t\\t// Search neighbors except the neighbor we just came from.\\n            if (parent == null || parent.index != n) {\\n                final Node bobNode = findBob(new Node(n, node), bob, graph, node);\\n                if (bobNode != null) {\\n                    return bobNode;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n\\n    private void optimizeAlice(int i, int lastI, IntList[] graph, int[] amount, int income, int[] max) {\\n\\t\\t// Track number of children (neighbors not equal to lastI) so we know when we are at a leaf.\\n        int children = 0;\\n        for (int n : graph[i]) {\\n\\t\\t\\t// Search neighbors except the neighbor we just came from.\\n            if (n != lastI) {\\n                children++;\\n                optimizeAlice(n, i, graph, amount, income + amount[n], max);\\n            }\\n        }\\n        if (children == 0) {\\n            // We are at a leaf - check if income is a new maximum.\\n            if (income > max[0]) {\\n                max[0] = income;\\n            }\\n        }\\n    }\\n\\n    static class IntList extends ArrayList<Integer> {\\n\\n        static IntList[] arrayOfSize(int n) {\\n            final IntList[] out = new IntList[n];\\n            for (int i = 0; i < n; ++i) {\\n                out[i] = new IntList();\\n            }\\n            return out;\\n        }\\n    }\\n\\n    static class Node {\\n        int length;\\n        int index;\\n        Node parent;\\n\\n        Node(int index) {\\n            this.index = index;\\n            this.length = 0;\\n        }\\n\\n        Node(int index, Node parent) {\\n            this(index);\\n            this.parent = parent;\\n            this.length = 1 + parent.length;\\n        }\\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807260,
                "title": "preprocess-then-dfs-java",
                "content": "\\n# Approach\\nWe first find the unique path that Bob traversed as well as the distance from Bob\\'s initial position to any node along the path.\\nThen, a DFS starting from the root to find the max income Alice can get. \\n\\n# Code\\n```\\nclass Solution {\\n    static int [] par;\\n    static int result; \\n    static int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        par = new int [amount.length];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        result = (int)(-1e9);\\n        for(int i = 0; i < amount.length; i++) adj.add(new ArrayList<>());\\n        for(int []edge: edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        setPar(0, adj, -1, par);\\n        Map<Integer, Integer> bobDist = new HashMap<>();\\n        int cur = bob, cnt = 0;\\n        while(cur != par[cur]){\\n            bobDist.put(cur, cnt++);\\n            cur = par[cur];\\n        }\\n        getResult(0, adj, bobDist, 0, amount, -1, amount[0]);\\n        return result;\\n    }\\n\\n    static void getResult(int node, List<List<Integer>> adj, Map<Integer, Integer> bobDist,\\n                         int dist, int[] amount, int p, int income) {\\n        int ans = amount[node];\\n        boolean flag = true;\\n        for(int child : adj.get(node)){\\n            if(child != p){\\n                if(bobDist.containsKey(child) && dist+1 == bobDist.get(child))\\n                    getResult(child, adj, bobDist, dist+1, amount, node, amount[child]/2 + income);\\n                else if(bobDist.get(child) == null || dist + 1 < bobDist.get(child))\\n                    getResult(child, adj, bobDist, dist+1, amount, node, amount[child] + income);\\n                else getResult(child, adj, bobDist, dist+1, amount, node, income);\\n                flag = false;\\n            }\\n        }\\n        if(flag){\\n            //leaf node.\\n            result = Math.max(result, income);\\n        }\\n    }\\n\\n    static void setPar(int cur, List<List<Integer>> adj, int p, int [] par){\\n        for(int child : adj.get(cur)){\\n            if(child != p){\\n                par[child] = cur;\\n                setPar(child, adj, cur, par);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int [] par;\\n    static int result; \\n    static int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        par = new int [amount.length];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        result = (int)(-1e9);\\n        for(int i = 0; i < amount.length; i++) adj.add(new ArrayList<>());\\n        for(int []edge: edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        setPar(0, adj, -1, par);\\n        Map<Integer, Integer> bobDist = new HashMap<>();\\n        int cur = bob, cnt = 0;\\n        while(cur != par[cur]){\\n            bobDist.put(cur, cnt++);\\n            cur = par[cur];\\n        }\\n        getResult(0, adj, bobDist, 0, amount, -1, amount[0]);\\n        return result;\\n    }\\n\\n    static void getResult(int node, List<List<Integer>> adj, Map<Integer, Integer> bobDist,\\n                         int dist, int[] amount, int p, int income) {\\n        int ans = amount[node];\\n        boolean flag = true;\\n        for(int child : adj.get(node)){\\n            if(child != p){\\n                if(bobDist.containsKey(child) && dist+1 == bobDist.get(child))\\n                    getResult(child, adj, bobDist, dist+1, amount, node, amount[child]/2 + income);\\n                else if(bobDist.get(child) == null || dist + 1 < bobDist.get(child))\\n                    getResult(child, adj, bobDist, dist+1, amount, node, amount[child] + income);\\n                else getResult(child, adj, bobDist, dist+1, amount, node, income);\\n                flag = false;\\n            }\\n        }\\n        if(flag){\\n            //leaf node.\\n            result = Math.max(result, income);\\n        }\\n    }\\n\\n    static void setPar(int cur, List<List<Integer>> adj, int p, int [] par){\\n        for(int child : adj.get(cur)){\\n            if(child != p){\\n                par[child] = cur;\\n                setPar(child, adj, cur, par);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807203,
                "title": "java-dfs-find-path-dfs-get-maxsum-explained",
                "content": "1. find path `bob -> ... -> alice`\\n2. modify the `amount` of `node` in the path by rule :\\n```\\nleft half nodes to 0 (bob reaches first),  if exact middle node exist, make it half (reaching same time)\\n```\\n3. backtrack traverse tree to get max path Sum\\n\\n![image](https://assets.leetcode.com/users/images/0d42268d-814d-4a23-a106-24f0264fe823_1668268939.877574.png)\\n![image](https://assets.leetcode.com/users/images/c74872ed-e950-4db6-a549-a7a32a7eb25a_1668268946.3543081.png)\\n![image](https://assets.leetcode.com/users/images/adcea14b-2df6-4044-a402-324dfbe30a3b_1668268952.5825174.png)\\n\\n```java\\nclass Solution {\\n\\n    List<Integer> b2a = new ArrayList<>();\\n    int maxSum = Integer.MIN_VALUE;\\n    \\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n = amount.length;\\n\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) graph.put(i, new HashSet<>());\\n        \\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(v).add(u);\\n            graph.get(u).add(v);\\n        }\\n        \\n        // 1. find path\\n        dfs(bob, 0, graph, new ArrayList<Integer>(){{add(bob); }}, new HashSet<Integer>(){{add(bob); }});\\n\\n        // 2. modify tree\\n        for (int i = 0; i < b2a.size() / 2; i++) {\\n            amount[b2a.get(i)] = 0;\\n        }\\n        if (b2a.size() % 2 != 0) {\\n            int m = b2a.get(b2a.size() / 2);\\n            amount[m] /= 2;\\n        }\\n        \\n        // 3. get result\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        maxPathSum(0, graph, amount, visited, amount[0]);\\n        return maxSum;\\n    }\\n    \\n    private boolean dfs(int root, int target,  Map<Integer, Set<Integer>> graph, List<Integer> currPath, Set<Integer> visited) {\\n        if (root == target) {\\n            b2a = new ArrayList<>(currPath);\\n            return true;\\n        }\\n        \\n        for (int neighbor : graph.get(root)) {\\n            if (visited.contains(neighbor)) continue;\\n            visited.add(neighbor);\\n            currPath.add(neighbor);\\n            \\n            if (dfs(neighbor, target, graph, currPath, visited)) return true;\\n            \\n            currPath.remove(currPath.size() - 1);\\n            visited.remove(neighbor);\\n        }\\n        return false;\\n    }\\n    \\n    private void maxPathSum(int root, Map<Integer, Set<Integer>> graph, int[] amount, Set<Integer> visited, int currSum) {\\n        int cnt = 0;\\n        for (int child : graph.get(root)) {\\n            if (visited.contains(child)) continue;\\n            \\n            visited.add(child);\\n            maxPathSum(child, graph, amount, visited, currSum + amount[child]);\\n            visited.remove(child);\\n            cnt++;\\n            \\n        }\\n        // leafNode\\n        if (cnt == 0) maxSum = Math.max(maxSum, currSum);\\n        return;\\n    }\\n    \\n    /*\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nleft half nodes to 0 (bob reaches first),  if exact middle node exist, make it half (reaching same time)\\n```\n```java\\nclass Solution {\\n\\n    List<Integer> b2a = new ArrayList<>();\\n    int maxSum = Integer.MIN_VALUE;\\n    \\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n = amount.length;\\n\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) graph.put(i, new HashSet<>());\\n        \\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(v).add(u);\\n            graph.get(u).add(v);\\n        }\\n        \\n        // 1. find path\\n        dfs(bob, 0, graph, new ArrayList<Integer>(){{add(bob); }}, new HashSet<Integer>(){{add(bob); }});\\n\\n        // 2. modify tree\\n        for (int i = 0; i < b2a.size() / 2; i++) {\\n            amount[b2a.get(i)] = 0;\\n        }\\n        if (b2a.size() % 2 != 0) {\\n            int m = b2a.get(b2a.size() / 2);\\n            amount[m] /= 2;\\n        }\\n        \\n        // 3. get result\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        maxPathSum(0, graph, amount, visited, amount[0]);\\n        return maxSum;\\n    }\\n    \\n    private boolean dfs(int root, int target,  Map<Integer, Set<Integer>> graph, List<Integer> currPath, Set<Integer> visited) {\\n        if (root == target) {\\n            b2a = new ArrayList<>(currPath);\\n            return true;\\n        }\\n        \\n        for (int neighbor : graph.get(root)) {\\n            if (visited.contains(neighbor)) continue;\\n            visited.add(neighbor);\\n            currPath.add(neighbor);\\n            \\n            if (dfs(neighbor, target, graph, currPath, visited)) return true;\\n            \\n            currPath.remove(currPath.size() - 1);\\n            visited.remove(neighbor);\\n        }\\n        return false;\\n    }\\n    \\n    private void maxPathSum(int root, Map<Integer, Set<Integer>> graph, int[] amount, Set<Integer> visited, int currSum) {\\n        int cnt = 0;\\n        for (int child : graph.get(root)) {\\n            if (visited.contains(child)) continue;\\n            \\n            visited.add(child);\\n            maxPathSum(child, graph, amount, visited, currSum + amount[child]);\\n            visited.remove(child);\\n            cnt++;\\n            \\n        }\\n        // leafNode\\n        if (cnt == 0) maxSum = Math.max(maxSum, currSum);\\n        return;\\n    }\\n    \\n    /*\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816518,
                "title": "one-pass",
                "content": "We traverse the tree, tracking the max profit and the current distance `dist` to node `0`.\\n\\nIf we step on node `bob`, it means that `open = dist + 1` nodes (this one and previous) are opened.\\n\\nWe return `{res, open - 2}` to track the maximum `res` and the number of opened nodes.\\n\\n**C++**\\n```cpp\\npair<int, int> dfs(int i, int prev, int dist, int bob, vector<vector<int>> &al, vector<int>& amount) {\\n    int res = INT_MIN, open = i == bob ? dist + 1 : 0;\\n    for (auto j : al[i])\\n        if (j != prev) {\\n            auto res_j = dfs(j, i, dist + 1, bob, al, amount);\\n            res = max(res, res_j.first);\\n            open = max(open, res_j.second);\\n        }\\n    if (open)\\n        amount[i] = open == 1 ? amount[i] / 2 : 0;\\n    return {(res == INT_MIN ? 0 : res) + amount[i], open - 2 };\\n}\\nint mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n    vector<vector<int>> al(amount.size());\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    return dfs(0, -1, 0, bob, al, amount).first;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\npair<int, int> dfs(int i, int prev, int dist, int bob, vector<vector<int>> &al, vector<int>& amount) {\\n    int res = INT_MIN, open = i == bob ? dist + 1 : 0;\\n    for (auto j : al[i])\\n        if (j != prev) {\\n            auto res_j = dfs(j, i, dist + 1, bob, al, amount);\\n            res = max(res, res_j.first);\\n            open = max(open, res_j.second);\\n        }\\n    if (open)\\n        amount[i] = open == 1 ? amount[i] / 2 : 0;\\n    return {(res == INT_MIN ? 0 : res) + amount[i], open - 2 };\\n}\\nint mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n    vector<vector<int>> al(amount.size());\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    return dfs(0, -1, 0, bob, al, amount).first;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807219,
                "title": "double-dfs-level-checking-easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int>g[100005];\\n    int level_bob[100005];\\n    bool vis[100005];\\n    \\n    int pa[100005];\\n    \\n    long long max_amount=-1e9;\\n    vector<int>Amount;\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        Amount = amount;\\n        for(auto v: edges){\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n        \\n        for(int i=0; i<edges.size()+1; i++) level_bob[i]=1e9;\\n        memset(vis, false , sizeof(vis));\\n        level_bob[bob]=0;\\n        dfs_bob(bob, -1);\\n        \\n       \\n        /// Path from 0 to bob\\'s node and mark these node using map\\n        map<int, bool>mpp;\\n        int node=0;\\n        while(pa[node]!=-1){\\n            mpp[node]=true;\\n            node =pa[node];\\n        }\\n        mpp[bob]=true;\\n        \\n        for(int i=0; i<edges.size()+1; i++)\\n        {\\n            if(!mpp[i]){ /// if this node isn\\'t in the bob\\'s path then set level to MAX_INT\\n                level_bob[i]=1e9;\\n            }\\n        }\\n        \\n       \\n        \\n        memset(vis, false, sizeof(vis)); /// clear vis array\\n        int level=0;\\n        long long sum_amount=0;\\n        dfs_alice(0, level, sum_amount);\\n        \\n        return (int)max_amount;\\n    }\\n    \\n    void dfs_bob(int u, int p)\\n    {\\n        vis[u]=true;\\n        pa[u]=p;  /// parent set\\n        for(auto v: g[u]){\\n            if(!vis[v]){\\n                level_bob[v]=level_bob[u]+1; /// level update\\n                dfs_bob(v, u);\\n            }\\n        }\\n    }\\n    \\n    void dfs_alice(int u, int level, long long sum_amount)\\n    {\\n        vis[u]=true;\\n        if(level<level_bob[u]) sum_amount+=Amount[u]; /// if alice\\'s current level is lower then it means that bob didn\\'t reach this node before alice thats why add the Amount\\n        else if(level==level_bob[u]) sum_amount+=(Amount[u]/2); /// if alice\\'s current level is equal to bob that means they are in that node at the same time thats why they will share amount so half goes to alice\\n     \\n        if( u!=0 && g[u].size()==1){ /// if this node is leaf node not the 0 node\\n            max_amount=max(max_amount, sum_amount); /// max_amount update\\n        }\\n        for(auto v: g[u]){\\n            if(!vis[v]){\\n                dfs_alice(v, level+1, sum_amount);\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>g[100005];\\n    int level_bob[100005];\\n    bool vis[100005];\\n    \\n    int pa[100005];\\n    \\n    long long max_amount=-1e9;\\n    vector<int>Amount;\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        Amount = amount;\\n        for(auto v: edges){\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n        \\n        for(int i=0; i<edges.size()+1; i++) level_bob[i]=1e9;\\n        memset(vis, false , sizeof(vis));\\n        level_bob[bob]=0;\\n        dfs_bob(bob, -1);\\n        \\n       \\n        /// Path from 0 to bob\\'s node and mark these node using map\\n        map<int, bool>mpp;\\n        int node=0;\\n        while(pa[node]!=-1){\\n            mpp[node]=true;\\n            node =pa[node];\\n        }\\n        mpp[bob]=true;\\n        \\n        for(int i=0; i<edges.size()+1; i++)\\n        {\\n            if(!mpp[i]){ /// if this node isn\\'t in the bob\\'s path then set level to MAX_INT\\n                level_bob[i]=1e9;\\n            }\\n        }\\n        \\n       \\n        \\n        memset(vis, false, sizeof(vis)); /// clear vis array\\n        int level=0;\\n        long long sum_amount=0;\\n        dfs_alice(0, level, sum_amount);\\n        \\n        return (int)max_amount;\\n    }\\n    \\n    void dfs_bob(int u, int p)\\n    {\\n        vis[u]=true;\\n        pa[u]=p;  /// parent set\\n        for(auto v: g[u]){\\n            if(!vis[v]){\\n                level_bob[v]=level_bob[u]+1; /// level update\\n                dfs_bob(v, u);\\n            }\\n        }\\n    }\\n    \\n    void dfs_alice(int u, int level, long long sum_amount)\\n    {\\n        vis[u]=true;\\n        if(level<level_bob[u]) sum_amount+=Amount[u]; /// if alice\\'s current level is lower then it means that bob didn\\'t reach this node before alice thats why add the Amount\\n        else if(level==level_bob[u]) sum_amount+=(Amount[u]/2); /// if alice\\'s current level is equal to bob that means they are in that node at the same time thats why they will share amount so half goes to alice\\n     \\n        if( u!=0 && g[u].size()==1){ /// if this node is leaf node not the 0 node\\n            max_amount=max(max_amount, sum_amount); /// max_amount update\\n        }\\n        for(auto v: g[u]){\\n            if(!vis[v]){\\n                dfs_alice(v, level+1, sum_amount);\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820110,
                "title": "simple-dfs-traversal",
                "content": "//Mayank Jain\\n\\nThe idea is to construct parent vector firstly and setting parent value for each of the nodes. This will be helpful for Bob while traversing in upwards direction towards source node 0. \\n\\n-> We will do a DFS graph traversal for both Alice (starting node as 0) & Bob (starting node as bob) and will mark visiting nodes as true during traversal.\\n-> If Alice and Bob are on the same nodes, then Alice can take half of the contribution in total sum value else if Alice visits a node already been visited by Bob, then nothing will be added in total sum.\\n-> We will have to check for all the leaf nodes optimally as to maximize total sum value stored in ans variable in the end.\\n\\n```\\n//Mayank Jain\\n\\nclass Solution {\\npublic:\\n    vector<int> parent; \\n    vector<vector<int>> graph;\\n    vector<bool> vis;\\n    int ans = INT_MIN; //value that has to be maximized before returning\\n\\t\\n    void solve(int src,int par){ //setting parent of each node\\n        parent[src] = par;\\n        for(auto itr:graph[src]){\\n            if(itr!=parent[src]) solve(itr,src);\\n        }\\n    }\\n\\t\\n    void solve2(int src,int end,vector<int>&amt,int sum){\\n        int sum2 = sum;\\n        if(vis[src]==false){ //visiting node for the first time\\n            vis[src] = true;\\n            if(src==end){ //If Alice and Bob are on the same nod\\n                sum2+= amt[src]/2;\\n            }\\n            else sum2+= amt[src];\\n        }\\n        for(auto itr:graph[src]){\\n            if(itr!=parent[src]){ //Alice has to move down towards the leaf node\\n                int res =  -1;\\n                if(end!=-1){\\n                    res = parent[end]; //Bob has to move upwards towards src node 0\\n\\t\\t\\t\\t\\t//Note that there is always only one unique path for Bob\\n                    vis[end] = true; //marking node where Bob stands as true\\n                }\\n                solve2(itr,res,amt,sum2); \\n                if(end!=-1) vis[end] = false;\\n            }\\n        }\\n        if(graph[src].size()<=1 && parent[src]!=-1) ans = max(ans,sum2); //Leaf node case where ans value needs to be checked and maximized\\n        vis[src] = false;\\n    }\\n\\t\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        parent.resize(100001,-1);  \\n        graph.resize(edges.size()+1);\\n        for(int i=0;i<edges.size();i++){ //constructing graph from edges vector\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        solve(0,-1); //function to set parent of each node \\n\\t\\t//Note that parent of src node 0 is set to -1\\n\\t\\t\\n        vis.resize(100001,false); //boolean vector vis to keep track of all visited nodes\\n        solve2(0,bob,amount,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//Mayank Jain\\n\\nclass Solution {\\npublic:\\n    vector<int> parent; \\n    vector<vector<int>> graph;\\n    vector<bool> vis;\\n    int ans = INT_MIN; //value that has to be maximized before returning\\n\\t\\n    void solve(int src,int par){ //setting parent of each node\\n        parent[src] = par;\\n        for(auto itr:graph[src]){\\n            if(itr!=parent[src]) solve(itr,src);\\n        }\\n    }\\n\\t\\n    void solve2(int src,int end,vector<int>&amt,int sum){\\n        int sum2 = sum;\\n        if(vis[src]==false){ //visiting node for the first time\\n            vis[src] = true;\\n            if(src==end){ //If Alice and Bob are on the same nod\\n                sum2+= amt[src]/2;\\n            }\\n            else sum2+= amt[src];\\n        }\\n        for(auto itr:graph[src]){\\n            if(itr!=parent[src]){ //Alice has to move down towards the leaf node\\n                int res =  -1;\\n                if(end!=-1){\\n                    res = parent[end]; //Bob has to move upwards towards src node 0\\n\\t\\t\\t\\t\\t//Note that there is always only one unique path for Bob\\n                    vis[end] = true; //marking node where Bob stands as true\\n                }\\n                solve2(itr,res,amt,sum2); \\n                if(end!=-1) vis[end] = false;\\n            }\\n        }\\n        if(graph[src].size()<=1 && parent[src]!=-1) ans = max(ans,sum2); //Leaf node case where ans value needs to be checked and maximized\\n        vis[src] = false;\\n    }\\n\\t\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        parent.resize(100001,-1);  \\n        graph.resize(edges.size()+1);\\n        for(int i=0;i<edges.size();i++){ //constructing graph from edges vector\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        solve(0,-1); //function to set parent of each node \\n\\t\\t//Note that parent of src node 0 is set to -1\\n\\t\\t\\n        vis.resize(100001,false); //boolean vector vis to keep track of all visited nodes\\n        solve2(0,bob,amount,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807527,
                "title": "java-visit-one-level-at-the-time-o-n",
                "content": "* We first build the tree from the root so that each node has its children and parent set\\n* Then we start from root, and then we visit each level at the time. \\n* While Alice goes down one level, Bob goes up one level. If Bob is at the same node, we split the amount. Once Bob visits a node, we set its amount to 0\\n* For each node we visit, we store the income to arrive there. We keep the max income of all leaf nodes\\n\\nWe don\\'t need to keep any distance since we are processing the two in parallel.\\n\\n```\\nclass Solution {\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amounts) {\\n        Node[] nodes = buildTree(edges, amounts);\\n\\n        List<Node> level = new ArrayList<>();\\n\\n        Node bobNode = nodes[bob];\\n\\n        int max = Integer.MIN_VALUE;\\n\\n        level.add(nodes[0]);\\n\\n        while(!level.isEmpty()){\\n            List<Node> nextLevel = new ArrayList<>();\\n            for (Node node : level) {\\n                int amount = bobNode == node ?  node.amount/2 : node.amount;\\n                node.income = (node.parent == null ? 0 : node.parent.income) + amount;\\n\\n                // leaf\\n                if(node.children.isEmpty()) max = Math.max(node.income, max);\\n\\n                nextLevel.addAll(node.children);\\n            }\\n\\n            // bob has visited this node, so the gate is open now\\n            bobNode.amount = 0;\\n            if(bobNode.parent != null) bobNode = bobNode.parent;\\n\\n            level = nextLevel;\\n        }\\n\\n        return max;\\n\\n    }\\n\\n    private Node[] buildTree(int[][] edges,  int[] amounts) {\\n        int n = amounts.length;\\n\\n        // for O(1) lookup\\n        Map<Integer, Set<Integer>> neighbors = new HashMap<>();\\n        for (int[] edge : edges) {\\n            neighbors.computeIfAbsent(edge[0], _k -> new HashSet<>()).add(edge[1]);\\n            neighbors.computeIfAbsent(edge[1], _k -> new HashSet<>()).add(edge[0]);\\n        }\\n\\n\\n        Node[] nodes = new Node[n];\\n        for (int i = 0; i < n; i++) {\\n            nodes[i] = new Node(amounts[i]);\\n        }\\n\\n        List<Integer> level = new ArrayList<>();\\n\\n        level.add(0);\\n\\n        // build tree level by level\\n        while(!level.isEmpty()){\\n            List<Integer> nextLevel = new ArrayList<>();\\n            for (int i : level) {\\n                Node node = nodes[i];\\n                for (int u : neighbors.get(i)) {\\n                    Node other = nodes[u];\\n                    node.children.add(other);\\n                    other.parent = node;\\n\\n                    // we already added this edge and its inverse (the parent), so we remove its inverse from the map\\n                    neighbors.get(u).remove(i);\\n\\n                    nextLevel.add(u);\\n                }\\n            }\\n            level = nextLevel;\\n        }\\n\\n        return nodes;\\n    }\\n\\n    private class Node{\\n        int amount;\\n        List<Node> children = new ArrayList<>();\\n        Node parent;\\n        int income;\\n\\n        public Node(int amount) {\\n            this.amount = amount;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amounts) {\\n        Node[] nodes = buildTree(edges, amounts);\\n\\n        List<Node> level = new ArrayList<>();\\n\\n        Node bobNode = nodes[bob];\\n\\n        int max = Integer.MIN_VALUE;\\n\\n        level.add(nodes[0]);\\n\\n        while(!level.isEmpty()){\\n            List<Node> nextLevel = new ArrayList<>();\\n            for (Node node : level) {\\n                int amount = bobNode == node ?  node.amount/2 : node.amount;\\n                node.income = (node.parent == null ? 0 : node.parent.income) + amount;\\n\\n                // leaf\\n                if(node.children.isEmpty()) max = Math.max(node.income, max);\\n\\n                nextLevel.addAll(node.children);\\n            }\\n\\n            // bob has visited this node, so the gate is open now\\n            bobNode.amount = 0;\\n            if(bobNode.parent != null) bobNode = bobNode.parent;\\n\\n            level = nextLevel;\\n        }\\n\\n        return max;\\n\\n    }\\n\\n    private Node[] buildTree(int[][] edges,  int[] amounts) {\\n        int n = amounts.length;\\n\\n        // for O(1) lookup\\n        Map<Integer, Set<Integer>> neighbors = new HashMap<>();\\n        for (int[] edge : edges) {\\n            neighbors.computeIfAbsent(edge[0], _k -> new HashSet<>()).add(edge[1]);\\n            neighbors.computeIfAbsent(edge[1], _k -> new HashSet<>()).add(edge[0]);\\n        }\\n\\n\\n        Node[] nodes = new Node[n];\\n        for (int i = 0; i < n; i++) {\\n            nodes[i] = new Node(amounts[i]);\\n        }\\n\\n        List<Integer> level = new ArrayList<>();\\n\\n        level.add(0);\\n\\n        // build tree level by level\\n        while(!level.isEmpty()){\\n            List<Integer> nextLevel = new ArrayList<>();\\n            for (int i : level) {\\n                Node node = nodes[i];\\n                for (int u : neighbors.get(i)) {\\n                    Node other = nodes[u];\\n                    node.children.add(other);\\n                    other.parent = node;\\n\\n                    // we already added this edge and its inverse (the parent), so we remove its inverse from the map\\n                    neighbors.get(u).remove(i);\\n\\n                    nextLevel.add(u);\\n                }\\n            }\\n            level = nextLevel;\\n        }\\n\\n        return nodes;\\n    }\\n\\n    private class Node{\\n        int amount;\\n        List<Node> children = new ArrayList<>();\\n        Node parent;\\n        int income;\\n\\n        public Node(int amount) {\\n            this.amount = amount;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815943,
                "title": "easy-intuitive-js-solution-1-bfs-1-dfs-backtracking",
                "content": "### Easy intuitive JS solution using backtracking\\n* First determine Bob\\'s path to Root\\n* Do a short BFS and then constrcut the path using prev array\\n* Once you have Bob\\'s step outlined we can just use backtracking to seek out all the paths and find the one with max profits\\n```\\n/**\\n * @param {number[][]} edges\\n * @param {number} bob\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar mostProfitablePath = function(edges, bob, amount) {\\n    // Construct graph\\n    const graph = Array(edges.length + 1).fill(0).map(ele => []);\\n    edges.forEach(([node1, node2]) => {\\n        graph[node1].push(node2);\\n        graph[node2].push(node1);\\n        \\n    });\\n    // Get Bob path to Root node\\n    let queue = [bob];\\n    const prev = Array(graph.length).fill(null);\\n    let visited = initVisited(graph.length);\\n    while(queue.length){\\n        const popped = queue.shift();\\n        for(const neighbor of graph[popped]){\\n            if(!visited[neighbor]){\\n                visited[neighbor] = true;\\n                prev[neighbor] = popped;\\n                queue.push(neighbor);\\n            }\\n        }\\n        if(visited[0])\\n            break;\\n    }\\n    // construct bob\\'s path to root\\n    const bobPath = [0];\\n    let dest = 0;\\n    while(dest !== bob){\\n        bobPath.push(prev[dest]);\\n        dest = prev[dest]\\n    }\\n    bobPath.reverse();\\n    const maxIncome = [Number.MIN_SAFE_INTEGER];\\n    visited = initVisited(graph.length);\\n    finalDfs(graph, 0, 0, 0, amount, visited, bobPath, maxIncome);\\n    return maxIncome[0];\\n};\\n\\nfunction finalDfs(graph, node, step, currIncome, amount, visited, bobPath, maxIncome){\\n    // terminate if leaf node\\n    if(node !== 0 && graph[node].length === 1){\\n        maxIncome[0] = Math.max(maxIncome[0], currIncome + amount[node]);\\n        // console.log({node, max: maxIncome[0]})\\n        return;\\n    }\\n    if(!visited[node]){\\n        visited[node] = true;\\n        const storeAliceNodeAmount = amount[node];\\n        const storeBobNodeAmount = step < bobPath.length ? amount[bobPath[step]] : null;\\n        if(bobPath[step] === node){\\n            amount[node] = amount[node] / 2;\\n        }\\n        currIncome += amount[node];\\n        amount[node] = 0;\\n        if(step < bobPath.length)\\n            amount[bobPath[step]] = 0;\\n        for(const neighbor of graph[node]){\\n            if(!visited[neighbor]){\\n                finalDfs(graph, neighbor, step + 1, currIncome, amount, visited, bobPath, maxIncome);\\n            }\\n        }\\n        // Backtrack\\n        if(bobPath[step] === node){\\n            currIncome -= storeAliceNodeAmount / 2\\n        }else{\\n            currIncome -= storeAliceNodeAmount;\\n        }\\n        if(step < bobPath.length)\\n            amount[bobPath[step]] = storeBobNodeAmount;\\n        amount[node] = storeAliceNodeAmount;\\n    }\\n    \\n}\\n\\nfunction initVisited(len){\\n    return Array(len).fill(false);\\n}\\n```\\nIt is not the fastest solution out there but one that is easy to think through and come up with the solution in an interview.\\n`Runtime: 693 ms, faster than 51.72% of JavaScript online submissions for Most Profitable Path in a Tree.`",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} edges\\n * @param {number} bob\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar mostProfitablePath = function(edges, bob, amount) {\\n    // Construct graph\\n    const graph = Array(edges.length + 1).fill(0).map(ele => []);\\n    edges.forEach(([node1, node2]) => {\\n        graph[node1].push(node2);\\n        graph[node2].push(node1);\\n        \\n    });\\n    // Get Bob path to Root node\\n    let queue = [bob];\\n    const prev = Array(graph.length).fill(null);\\n    let visited = initVisited(graph.length);\\n    while(queue.length){\\n        const popped = queue.shift();\\n        for(const neighbor of graph[popped]){\\n            if(!visited[neighbor]){\\n                visited[neighbor] = true;\\n                prev[neighbor] = popped;\\n                queue.push(neighbor);\\n            }\\n        }\\n        if(visited[0])\\n            break;\\n    }\\n    // construct bob\\'s path to root\\n    const bobPath = [0];\\n    let dest = 0;\\n    while(dest !== bob){\\n        bobPath.push(prev[dest]);\\n        dest = prev[dest]\\n    }\\n    bobPath.reverse();\\n    const maxIncome = [Number.MIN_SAFE_INTEGER];\\n    visited = initVisited(graph.length);\\n    finalDfs(graph, 0, 0, 0, amount, visited, bobPath, maxIncome);\\n    return maxIncome[0];\\n};\\n\\nfunction finalDfs(graph, node, step, currIncome, amount, visited, bobPath, maxIncome){\\n    // terminate if leaf node\\n    if(node !== 0 && graph[node].length === 1){\\n        maxIncome[0] = Math.max(maxIncome[0], currIncome + amount[node]);\\n        // console.log({node, max: maxIncome[0]})\\n        return;\\n    }\\n    if(!visited[node]){\\n        visited[node] = true;\\n        const storeAliceNodeAmount = amount[node];\\n        const storeBobNodeAmount = step < bobPath.length ? amount[bobPath[step]] : null;\\n        if(bobPath[step] === node){\\n            amount[node] = amount[node] / 2;\\n        }\\n        currIncome += amount[node];\\n        amount[node] = 0;\\n        if(step < bobPath.length)\\n            amount[bobPath[step]] = 0;\\n        for(const neighbor of graph[node]){\\n            if(!visited[neighbor]){\\n                finalDfs(graph, neighbor, step + 1, currIncome, amount, visited, bobPath, maxIncome);\\n            }\\n        }\\n        // Backtrack\\n        if(bobPath[step] === node){\\n            currIncome -= storeAliceNodeAmount / 2\\n        }else{\\n            currIncome -= storeAliceNodeAmount;\\n        }\\n        if(step < bobPath.length)\\n            amount[bobPath[step]] = storeBobNodeAmount;\\n        amount[node] = storeAliceNodeAmount;\\n    }\\n    \\n}\\n\\nfunction initVisited(len){\\n    return Array(len).fill(false);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807832,
                "title": "java-2-solutions-dfs-bfs",
                "content": "# 2. one DFS\\n```\\n\\t//2. one DFS\\n    //Runtime: 82 ms, faster than 100.00% of Java online submissions for Most Profitable Path in a Tree.\\n    //Memory Usage: 185.1 MB, less than 25.00% of Java online submissions for Most Profitable Path in a Tree.\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        //Time: O(E); Space: O(N + E)\\n        //build graph\\n        List<Integer>[] graph = new ArrayList[amount.length];\\n        for (int i = 0; i < amount.length; i++) graph[i] = new ArrayList<>();\\n        for (int[] edge: edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        return helper_dfs(graph, 0, bob, amount, new boolean[amount.length], 1)[0];\\n    }\\n\\n    //Time: O(N); Space: O(N)\\n    private int[] helper_dfs(List<Integer>[] graph, int node, int bob, int[] amount, boolean[] seen, int height) {\\n        int res = Integer.MIN_VALUE;\\n        seen[node] = true;\\n\\n        int bobPathLen = node == bob ? 1 : 0;\\n\\n        for (int nextNode : graph[node]) {\\n            if (seen[nextNode] == true) continue;\\n            int[] tmp = helper_dfs(graph, nextNode, bob, amount, seen, height + 1);\\n            if (tmp[1] > 0) bobPathLen = tmp[1] + 1;\\n            res = Math.max(res, tmp[0]);\\n        }\\n\\n        if (bobPathLen > 0 && bobPathLen <= height){\\n            if (bobPathLen == height) amount[node] = amount[node] / 2;\\n            else amount[node] = 0;\\n        }\\n\\n        return new int[]{res == Integer.MIN_VALUE ? amount[node] : amount[node] + res, bobPathLen};\\n    }\\n\\n```\\n# 1. BFS + DFS\\n```\\n    //1. BFS + DFS\\n    //Runtime: 85 ms, faster than 100.00% of Java online submissions for Most Profitable Path in a Tree.\\n    //Memory Usage: 144 MB, less than 50.00% of Java online submissions for Most Profitable Path in a Tree.\\n    //Time: O(E + N); Space: O(E + N)\\n    public int mostProfitablePath_1(int[][] edges, int bob, int[] amount) {\\n        //Time: O(E); Space: O(N + E)\\n        //build graph\\n        List<Integer>[] graph = new ArrayList[amount.length];\\n        for (int i = 0; i < amount.length; i++) graph[i] = new ArrayList<>();\\n        for (int[] edge: edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        //update amount\\n        helper_bfs(graph, bob, amount);\\n        return helper_dfs(graph, 0, amount, new boolean[amount.length]);\\n    }\\n\\n    //Time: O(N); Space: O(N)\\n    private void helper_bfs(List<Integer>[] graph, int bob, int[] amount) {\\n        int[] preList = new int[amount.length];\\n        boolean[] seen = new boolean[amount.length];\\n        seen[bob] = true;\\n\\n        //Time: O(N); Space: O(N)\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(bob);\\n        while (!queue.isEmpty()) {\\n            int currNode = queue.poll();\\n            for (int nextNode : graph[currNode]) {\\n                if (seen[nextNode] == true) continue;\\n                preList[nextNode] = currNode;\\n                if (nextNode == 0) break;\\n\\n                queue.add(nextNode);\\n                seen[nextNode] = true;\\n            }\\n        }\\n\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n        int p = 0;\\n        while (p != bob) {\\n            p = preList[p]; list.add(p);\\n        }\\n\\n        int resListSize = list.size();\\n        for (int i = 0; i < resListSize / 2; i++) amount[list.get(list.size() - 1 - i)] = 0;\\n\\n        if (resListSize % 2 != 0) {\\n            int midIdx = resListSize / 2;\\n            amount[list.get(midIdx)] =  amount[list.get(midIdx)] / 2;\\n        }\\n    }\\n\\n    //Time: O(N); Space: O(N)\\n    private int helper_dfs(List<Integer>[] graph, int node, int[] amount, boolean[] seen) {\\n        int res = Integer.MIN_VALUE;\\n        seen[node] = true;\\n        for (int nextNode : graph[node]) {\\n            if (seen[nextNode] == true) continue;\\n            res = Math.max(res, helper_dfs(graph, nextNode, amount, seen));\\n        }\\n        return res == Integer.MIN_VALUE ? amount[node] : amount[node] + res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\t//2. one DFS\\n    //Runtime: 82 ms, faster than 100.00% of Java online submissions for Most Profitable Path in a Tree.\\n    //Memory Usage: 185.1 MB, less than 25.00% of Java online submissions for Most Profitable Path in a Tree.\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        //Time: O(E); Space: O(N + E)\\n        //build graph\\n        List<Integer>[] graph = new ArrayList[amount.length];\\n        for (int i = 0; i < amount.length; i++) graph[i] = new ArrayList<>();\\n        for (int[] edge: edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        return helper_dfs(graph, 0, bob, amount, new boolean[amount.length], 1)[0];\\n    }\\n\\n    //Time: O(N); Space: O(N)\\n    private int[] helper_dfs(List<Integer>[] graph, int node, int bob, int[] amount, boolean[] seen, int height) {\\n        int res = Integer.MIN_VALUE;\\n        seen[node] = true;\\n\\n        int bobPathLen = node == bob ? 1 : 0;\\n\\n        for (int nextNode : graph[node]) {\\n            if (seen[nextNode] == true) continue;\\n            int[] tmp = helper_dfs(graph, nextNode, bob, amount, seen, height + 1);\\n            if (tmp[1] > 0) bobPathLen = tmp[1] + 1;\\n            res = Math.max(res, tmp[0]);\\n        }\\n\\n        if (bobPathLen > 0 && bobPathLen <= height){\\n            if (bobPathLen == height) amount[node] = amount[node] / 2;\\n            else amount[node] = 0;\\n        }\\n\\n        return new int[]{res == Integer.MIN_VALUE ? amount[node] : amount[node] + res, bobPathLen};\\n    }\\n\\n```\n```\\n    //1. BFS + DFS\\n    //Runtime: 85 ms, faster than 100.00% of Java online submissions for Most Profitable Path in a Tree.\\n    //Memory Usage: 144 MB, less than 50.00% of Java online submissions for Most Profitable Path in a Tree.\\n    //Time: O(E + N); Space: O(E + N)\\n    public int mostProfitablePath_1(int[][] edges, int bob, int[] amount) {\\n        //Time: O(E); Space: O(N + E)\\n        //build graph\\n        List<Integer>[] graph = new ArrayList[amount.length];\\n        for (int i = 0; i < amount.length; i++) graph[i] = new ArrayList<>();\\n        for (int[] edge: edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        //update amount\\n        helper_bfs(graph, bob, amount);\\n        return helper_dfs(graph, 0, amount, new boolean[amount.length]);\\n    }\\n\\n    //Time: O(N); Space: O(N)\\n    private void helper_bfs(List<Integer>[] graph, int bob, int[] amount) {\\n        int[] preList = new int[amount.length];\\n        boolean[] seen = new boolean[amount.length];\\n        seen[bob] = true;\\n\\n        //Time: O(N); Space: O(N)\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(bob);\\n        while (!queue.isEmpty()) {\\n            int currNode = queue.poll();\\n            for (int nextNode : graph[currNode]) {\\n                if (seen[nextNode] == true) continue;\\n                preList[nextNode] = currNode;\\n                if (nextNode == 0) break;\\n\\n                queue.add(nextNode);\\n                seen[nextNode] = true;\\n            }\\n        }\\n\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n        int p = 0;\\n        while (p != bob) {\\n            p = preList[p]; list.add(p);\\n        }\\n\\n        int resListSize = list.size();\\n        for (int i = 0; i < resListSize / 2; i++) amount[list.get(list.size() - 1 - i)] = 0;\\n\\n        if (resListSize % 2 != 0) {\\n            int midIdx = resListSize / 2;\\n            amount[list.get(midIdx)] =  amount[list.get(midIdx)] / 2;\\n        }\\n    }\\n\\n    //Time: O(N); Space: O(N)\\n    private int helper_dfs(List<Integer>[] graph, int node, int[] amount, boolean[] seen) {\\n        int res = Integer.MIN_VALUE;\\n        seen[node] = true;\\n        for (int nextNode : graph[node]) {\\n            if (seen[nextNode] == true) continue;\\n            res = Math.max(res, helper_dfs(graph, nextNode, amount, seen));\\n        }\\n        return res == Integer.MIN_VALUE ? amount[node] : amount[node] + res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807632,
                "title": "video-explanation-zero-to-building-the-solution-itself-with-inutitions",
                "content": "https://www.youtube.com/watch?v=QBb8zUX2KlY\\n\\n[Click here if the preview doesn\\'t work](https://www.youtube.com/watch?v=QBb8zUX2KlY)",
                "solutionTags": [
                    "C++"
                ],
                "code": "https://www.youtube.com/watch?v=QBb8zUX2KlY\\n\\n[Click here if the preview doesn\\'t work](https://www.youtube.com/watch?v=QBb8zUX2KlY)",
                "codeTag": "Unknown"
            },
            {
                "id": 2807197,
                "title": "easy-short-efficient-clean-code",
                "content": "There exists exactly 1 path for Bob to reach 0. FIXED!\\nAny Alice path from 0 to a leaf will have some of its prefix common with Bob\\'s path. ( 0, a, b, ...)\\nSince the graph is undirected, therefore apart from this prefix, there cannot be any nod common between Bob\\'s path and Alice\\'s this path.\\nSo all that remains is to precompute timestamps for all nodes in Bob\\'s path, and then do a dfs for Alice.\\n```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\nvi(vi(ll))g; // graph\\nll n;\\nvi(ll)tsb; // timeStampsBob\\nbool bdfs(ll nd, ll ts, ll par){ //  dfs for Bob\\n    tsb[nd]=ts;\\n    if(nd==0){\\n        return 1;\\n    }\\n    for(ll child:g[nd]){\\n        if(child!=par && bdfs(child, ts+1, nd)){\\n            return 1;\\n        }\\n    }\\n    tsb[nd]=-1;\\n    return 0;\\n}\\nll adfs(ll par, ll nd, ll ts, const vi(int)&cost){ //  dfs for Alice\\n    ll ans=LLONG_MIN;\\n    for(ll child:g[nd]){\\n        if(child!=par){\\n            ans=max(ans, adfs(nd, child, ts+1, cost));\\n        }\\n    }\\n    if(ans==LLONG_MIN){\\n        ans=0;\\n    }\\n    if(tsb[nd]==-1 || tsb[nd]>ts){\\n        ans+=cost[nd];\\n    } // bob either never visited or visited later. Alice will have to unlock.\\n    else if(tsb[nd]==ts){\\n        ans+=cost[nd]/2; \\n    } // both arrived at same point, thus equally distribute\\n\\t/*else{\\n\\t\\tbob arrived earlier, nothing for alice to gain/lose at this node;\\n\\t}*/\\n    return ans;\\n}\\n    int mostProfitablePath(vector<vector<int>>&e, int bob, vector<int>&v) {\\n        n=v.size(), g.resize(n), tsb.assign(n, -1);\\n        for(const auto&edge:e){\\n            g[edge[0]].pb(edge[1]), g[edge[1]].pb(edge[0]);\\n        }\\n        bdfs(bob, 0, -1);\\n        return adfs(-1, 0, 0, v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\nvi(vi(ll))g; // graph\\nll n;\\nvi(ll)tsb; // timeStampsBob\\nbool bdfs(ll nd, ll ts, ll par){ //  dfs for Bob\\n    tsb[nd]=ts;\\n    if(nd==0){\\n        return 1;\\n    }\\n    for(ll child:g[nd]){\\n        if(child!=par && bdfs(child, ts+1, nd)){\\n            return 1;\\n        }\\n    }\\n    tsb[nd]=-1;\\n    return 0;\\n}\\nll adfs(ll par, ll nd, ll ts, const vi(int)&cost){ //  dfs for Alice\\n    ll ans=LLONG_MIN;\\n    for(ll child:g[nd]){\\n        if(child!=par){\\n            ans=max(ans, adfs(nd, child, ts+1, cost));\\n        }\\n    }\\n    if(ans==LLONG_MIN){\\n        ans=0;\\n    }\\n    if(tsb[nd]==-1 || tsb[nd]>ts){\\n        ans+=cost[nd];\\n    } // bob either never visited or visited later. Alice will have to unlock.\\n    else if(tsb[nd]==ts){\\n        ans+=cost[nd]/2; \\n    } // both arrived at same point, thus equally distribute\\n\\t/*else{\\n\\t\\tbob arrived earlier, nothing for alice to gain/lose at this node;\\n\\t}*/\\n    return ans;\\n}\\n    int mostProfitablePath(vector<vector<int>>&e, int bob, vector<int>&v) {\\n        n=v.size(), g.resize(n), tsb.assign(n, -1);\\n        for(const auto&edge:e){\\n            g[edge[0]].pb(edge[1]), g[edge[1]].pb(edge[0]);\\n        }\\n        bdfs(bob, 0, -1);\\n        return adfs(-1, 0, 0, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920251,
                "title": "dfs-bfs-easy-beginner-friendly-solution",
                "content": "we will find the path for bob from his current position to root with time stamp and as it\\'s given that it\\'s tree so their will be single path so it makes everything stright forward.\\nwe will use map <node -> time> to store info for easy access later\\n\\nnow once we are done with bob then come to alice \\nwe are gpoing to use queue <{node, amount, time}> \\n\\nwe will run level order traversal from root till leaves and at each current node we will check is this node is already visited /not visited or simultineously visited accordingly we will add amount \\nand also we will keep checking that the curr node is leaf node or not iff yess then take maxima with answer \\nand keep moving till the queue is empty\\n\\n```\\nUPVOTE IF U LIKE :)\\n```\\n\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> g;\\n    unordered_map<int,int> m;\\n    bool dfs(int s,int t)\\n    {\\n        m[s]=t;\\n        if(s==0) return true;\\n        \\n        for(auto i: g[s])\\n        {\\n            if(m.find(i)==m.end())\\n            {\\n                if(dfs(i,t+1)) return true;\\n            }\\n        }\\n        \\n        m.erase(s);// unmark bcz we didn\\'t reach destination\\n        return false;\\n        \\n        \\n    }\\n    \\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>&pr) \\n    {\\n        int n=edges.size()+1;\\n        \\n        g.resize(n);\\n        \\n        for(auto i: edges)\\n        {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        \\n        m.clear(); // conatins all path info with time after dfs\\n        dfs(bob,0);\\n        \\n        // for(auto i: m) cout<<i.first<<\" \"<<i.second<<endl;\\n        using vt=vector<int>;\\n        \\n        queue<vt> q;\\n        q.push({0,0,0}); //use level order to get all path from root to leaves,cdtion of leaves in undired grph is it has one connection only\\n        \\n        vector<int> v(n,0);\\n        v[0]=1;\\n        int ans=INT_MIN;\\n        while(!q.empty())\\n        {\\n            vt tem=q.front();\\n            q.pop();\\n            int t=tem[2];\\n            int p=tem[1];\\n            int curr=tem[0];\\n            v[curr]=1;\\n            if(m.find(curr)==m.end())// didn\\'t visited this\\n            {\\n                p+=pr[curr];\\n            }else if(m[curr]>t)// didn\\'t arrived yet\\n            {\\n                p+=pr[curr];\\n            }else if(m[curr]==t) p+=pr[curr]/2;// arrived at same time\\n            \\n            if(g[curr].size()==1 && curr!=0) // curr!=0   bcz   root is not a child but seems like when tree is  0->1->2->3 but it\\'s not\\n                ans= max(ans, p);\\n            \\n            for(auto i: g[curr])\\n            {\\n                if(v[i]==0)\\n                {\\n                    q.push({i,p,t+1});\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans;\\n            \\n            \\n        \\n        \\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nUPVOTE IF U LIKE :)\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> g;\\n    unordered_map<int,int> m;\\n    bool dfs(int s,int t)\\n    {\\n        m[s]=t;\\n        if(s==0) return true;\\n        \\n        for(auto i: g[s])\\n        {\\n            if(m.find(i)==m.end())\\n            {\\n                if(dfs(i,t+1)) return true;\\n            }\\n        }\\n        \\n        m.erase(s);// unmark bcz we didn\\'t reach destination\\n        return false;\\n        \\n        \\n    }\\n    \\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>&pr) \\n    {\\n        int n=edges.size()+1;\\n        \\n        g.resize(n);\\n        \\n        for(auto i: edges)\\n        {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        \\n        m.clear(); // conatins all path info with time after dfs\\n        dfs(bob,0);\\n        \\n        // for(auto i: m) cout<<i.first<<\" \"<<i.second<<endl;\\n        using vt=vector<int>;\\n        \\n        queue<vt> q;\\n        q.push({0,0,0}); //use level order to get all path from root to leaves,cdtion of leaves in undired grph is it has one connection only\\n        \\n        vector<int> v(n,0);\\n        v[0]=1;\\n        int ans=INT_MIN;\\n        while(!q.empty())\\n        {\\n            vt tem=q.front();\\n            q.pop();\\n            int t=tem[2];\\n            int p=tem[1];\\n            int curr=tem[0];\\n            v[curr]=1;\\n            if(m.find(curr)==m.end())// didn\\'t visited this\\n            {\\n                p+=pr[curr];\\n            }else if(m[curr]>t)// didn\\'t arrived yet\\n            {\\n                p+=pr[curr];\\n            }else if(m[curr]==t) p+=pr[curr]/2;// arrived at same time\\n            \\n            if(g[curr].size()==1 && curr!=0) // curr!=0   bcz   root is not a child but seems like when tree is  0->1->2->3 but it\\'s not\\n                ans= max(ans, p);\\n            \\n            for(auto i: g[curr])\\n            {\\n                if(v[i]==0)\\n                {\\n                    q.push({i,p,t+1});\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans;\\n            \\n            \\n        \\n        \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3910019,
                "title": "simple-two-traversal-dfs-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Just two traversals one for Bob and other for Alice**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- I first traversed to find the node from where Bob is starting and then marked the half path node vals as 0 and if some node is in between then making its val as half of the previous val as if Alice is also going through the same path he and Bob will encounter them in this particular node;\\n\\n- For finding that weather i will be on the upper half or the lower half i used count which is the current distance from the node 0;\\n\\n- Now from the node 0 I found the max node to leaf pathsum I can obtain;\\n\\n- And then simply returned this pathsum;\\n\\n# Complexity\\n- Time complexity: O(n) where n is the number of nodes in the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for making the map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> map;\\n    unordered_map<int, int> vis;\\n    int findbob(int bob, vector<int>& val, int ind=0, int count=1){\\n        if(ind==bob) {\\n            if(count==1) val[ind]/=2;\\n            else val[ind]=0;\\n            return count;\\n        }\\n        vis[ind]=1;\\n        for(auto &it: map[ind]){\\n            if(!vis.count(it)){\\n                int temp=findbob(bob, val, it, count+1);\\n                if(temp!=-1){\\n                    if(temp%2){\\n                        if(count>(temp+1)/2) val[ind]=0;\\n                        if(count==(temp+1)/2) val[ind]/=2;\\n                    }\\n                    else{\\n                        if(count>temp/2) val[ind]=0;\\n                    }\\n                    return temp;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int bestpath(vector<int>& val, int ind=0){\\n        int ans=-1e9;\\n        vis[ind]++;\\n        for(auto &it:map[ind]){\\n            if(!vis.count(it)){\\n                ans=max(ans, bestpath(val, it));\\n            }\\n        }\\n        if(ans==-1e9) ans=0;\\n        return ans+val[ind];\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        for(int i=0;i<edges.size();i++){\\n            map[edges[i][0]].push_back(edges[i][1]);\\n            map[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        findbob(bob, amount);\\n        vis.clear();\\n        int ans=bestpath(amount);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> map;\\n    unordered_map<int, int> vis;\\n    int findbob(int bob, vector<int>& val, int ind=0, int count=1){\\n        if(ind==bob) {\\n            if(count==1) val[ind]/=2;\\n            else val[ind]=0;\\n            return count;\\n        }\\n        vis[ind]=1;\\n        for(auto &it: map[ind]){\\n            if(!vis.count(it)){\\n                int temp=findbob(bob, val, it, count+1);\\n                if(temp!=-1){\\n                    if(temp%2){\\n                        if(count>(temp+1)/2) val[ind]=0;\\n                        if(count==(temp+1)/2) val[ind]/=2;\\n                    }\\n                    else{\\n                        if(count>temp/2) val[ind]=0;\\n                    }\\n                    return temp;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int bestpath(vector<int>& val, int ind=0){\\n        int ans=-1e9;\\n        vis[ind]++;\\n        for(auto &it:map[ind]){\\n            if(!vis.count(it)){\\n                ans=max(ans, bestpath(val, it));\\n            }\\n        }\\n        if(ans==-1e9) ans=0;\\n        return ans+val[ind];\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        for(int i=0;i<edges.size();i++){\\n            map[edges[i][0]].push_back(edges[i][1]);\\n            map[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        findbob(bob, amount);\\n        vis.clear();\\n        int ans=bestpath(amount);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727165,
                "title": "c-solution-using-bfs-and-dfs",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWhat is given to us is an undirected tree rooted at node `0`. Now, bob moves from a given node to the root `0`. In a tree, there is always only one path between any two nodes. Therefore, we can identify which nodes Bob passes through and also the times at which he does so. To do this, we root the tree at `0` and convert it into a directed tree. Doing this helps us identify the parent of each node (Each node in a tree has exactly one parent.) We use an array `parents` to keep track of each nodes parent and then we move backwards from bobs node to node `0` moving from child to parent. A map is used to keep track of the time each node in the path was visited. \\nNext we run DFS from the root node to find the maximum path to a leaf node while keeping track of the time at which we visit each node. If the current time is greater than the time at which bob had visited that node, then the amount at the node is `0`. If the current time is equal to the time at which bob had visited that node, then the amount at the node is divided by two. If Bob had not visited that node at all, then the amount remains the same.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&adj,int node,int t,map<int,int>&visited,vector<int>&amount){\\n        int currVal=amount[node];\\n        if(visited.count(node)){\\n            if(visited[node]<t) currVal=0;\\n            else if(visited[node]==t) currVal/=2;\\n        }\\n        if(adj[node].size()==0) return currVal;\\n        int res=INT_MIN;\\n        for(auto nbr:adj[node]){\\n            res=max(res,dfs(adj,nbr,t+1,visited,amount));\\n        }\\n        return currVal+res;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=edges.size()+1;\\n        vector<vector<int>>adj(n,vector<int>());\\n        vector<vector<int>>tree(n,vector<int>());\\n\\n        vector<int>parent(n,0);\\n        for(int i=0;i<n-1;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }   \\n        vector<int>added(n,0);\\n        queue<int>q;\\n        q.push(0);\\n        added[0]=1;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto nbr:adj[node]){\\n                if(!added[nbr]) {\\n                    added[nbr]++;\\n                    tree[node].push_back(nbr);\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(auto child:tree[i]){\\n                parent[child]=i;\\n            }\\n        }\\n        map<int,int>visited;\\n        int t=0;\\n        int node=bob;\\n        while(node!=0){\\n            visited[node]=t++;\\n            node=parent[node];\\n        }\\n        return dfs(tree,0,0,visited,amount);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&adj,int node,int t,map<int,int>&visited,vector<int>&amount){\\n        int currVal=amount[node];\\n        if(visited.count(node)){\\n            if(visited[node]<t) currVal=0;\\n            else if(visited[node]==t) currVal/=2;\\n        }\\n        if(adj[node].size()==0) return currVal;\\n        int res=INT_MIN;\\n        for(auto nbr:adj[node]){\\n            res=max(res,dfs(adj,nbr,t+1,visited,amount));\\n        }\\n        return currVal+res;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=edges.size()+1;\\n        vector<vector<int>>adj(n,vector<int>());\\n        vector<vector<int>>tree(n,vector<int>());\\n\\n        vector<int>parent(n,0);\\n        for(int i=0;i<n-1;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }   \\n        vector<int>added(n,0);\\n        queue<int>q;\\n        q.push(0);\\n        added[0]=1;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto nbr:adj[node]){\\n                if(!added[nbr]) {\\n                    added[nbr]++;\\n                    tree[node].push_back(nbr);\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(auto child:tree[i]){\\n                parent[child]=i;\\n            }\\n        }\\n        map<int,int>visited;\\n        int t=0;\\n        int node=bob;\\n        while(node!=0){\\n            visited[node]=t++;\\n            node=parent[node];\\n        }\\n        return dfs(tree,0,0,visited,amount);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983878,
                "title": "c-easy-medium-explained-with-diagram",
                "content": "# Intuition\\nThere is always a uniue path between two nodes in a tree.\\nSo we need to see the path between Alice and Bob , this will be the only path that will be affected by movement of both Alice and Bob , rest paths depend only on Alice.\\n\\n# Approach\\nFind the path between Alice and Bob , if this path contain odd number of nodes , reduce the amount of mid node to be half. Rest node after the mid will be 0 for Alice. Now run a simple dfs from root to check for the max valued path.\\n\\n![Untitled drawing.jpg](https://assets.leetcode.com/users/images/1cd31b4a-9956-43d2-95f5-0d7617de33f7_1672641059.3878973.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> adj[100007];\\n    bool vis[100007];\\n    int ans;\\n    int cur;\\n//dfs to find path between alice and bob\\n    void dfs(int x, int bob,vector<int> &v,vector<int> &path){\\n        v.push_back(x);\\n        \\n        if(!vis[x]&&x==bob){\\n            path = v;\\n            return;\\n        }\\n        vis[x]=1;\\n        for(auto y:adj[x]){\\n            if(!vis[y]){\\n                dfs(y,bob,v,path);\\n            }\\n        }\\n        v.pop_back();\\n        \\n    }\\n\\n// dfs to find the max valued path\\n    void dfs_max(int x, vector<int>& a){\\n        vis[x]=1;\\n        cur += a[x];\\n        for(auto y:adj[x]){\\n            if(!vis[y]){\\n                dfs_max(y,a);\\n            }\\n        }\\n        if(x&&adj[x].size()==1) // if x is a leaf node update answer\\n        ans = max(ans,cur);\\n        cur-=a[x];\\n    }\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        for(int i =0;i<n;i++) vis[i]=0;\\n        for(auto x: edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<int> v;\\n         vector<int>path;\\n        dfs(0,bob,v,path);\\n        int ps = path.size();\\n        int st;\\n        if(ps&1){\\n            amount[path[ps/2]]/=2;\\n            st = ps/2+1;\\n        }else{\\n            st = ps/2;\\n        }\\n        for(auto x: path) cout<<x<<\" \";\\n        for(int i =st;i<ps;i++){\\n            amount[path[i]]=0;\\n        }\\n        for(int i =0;i<n;i++) vis[i] = 0;\\n        ans  = INT_MIN;\\n        cur =0;\\n        dfs_max(0, amount);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[100007];\\n    bool vis[100007];\\n    int ans;\\n    int cur;\\n//dfs to find path between alice and bob\\n    void dfs(int x, int bob,vector<int> &v,vector<int> &path){\\n        v.push_back(x);\\n        \\n        if(!vis[x]&&x==bob){\\n            path = v;\\n            return;\\n        }\\n        vis[x]=1;\\n        for(auto y:adj[x]){\\n            if(!vis[y]){\\n                dfs(y,bob,v,path);\\n            }\\n        }\\n        v.pop_back();\\n        \\n    }\\n\\n// dfs to find the max valued path\\n    void dfs_max(int x, vector<int>& a){\\n        vis[x]=1;\\n        cur += a[x];\\n        for(auto y:adj[x]){\\n            if(!vis[y]){\\n                dfs_max(y,a);\\n            }\\n        }\\n        if(x&&adj[x].size()==1) // if x is a leaf node update answer\\n        ans = max(ans,cur);\\n        cur-=a[x];\\n    }\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        for(int i =0;i<n;i++) vis[i]=0;\\n        for(auto x: edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<int> v;\\n         vector<int>path;\\n        dfs(0,bob,v,path);\\n        int ps = path.size();\\n        int st;\\n        if(ps&1){\\n            amount[path[ps/2]]/=2;\\n            st = ps/2+1;\\n        }else{\\n            st = ps/2;\\n        }\\n        for(auto x: path) cout<<x<<\" \";\\n        for(int i =st;i<ps;i++){\\n            amount[path[i]]=0;\\n        }\\n        for(int i =0;i<n;i++) vis[i] = 0;\\n        ans  = INT_MIN;\\n        cur =0;\\n        dfs_max(0, amount);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2837032,
                "title": "tracking-bob",
                "content": "# Intuition\\nAs Bob is moving toward the root so it\\'s definite that there is only one path for Bob. \\nWhile Alice a varity of options dfs of the tree.\\nWe find that Path for Bob then we do dfs for Alice to find the maximum profitable path.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst Creating a bireacted graph to prepresnt the tree.\\nThen use Backtraking to find the path to the root for `bob`.\\nThen use Depth-First Search to find the Most profitable path use the path followed by Bob to know any open or shared paths.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define has(s, k) (s.find(k) != s.end())\\n\\nclass Solution {\\npublic:\\n    void findRoot(vector<vector<int>>& graph, vector<bool>& visited, int i, vector<int>& res, vector<int>& path) {\\n        path.push_back(i);\\n        \\n        if(i == 0) {\\n            res = path;\\n            path.pop_back();\\n            return;\\n        }\\n        visited[i] = true;\\n        \\n        for(int v: graph[i])\\n            if(!visited[v])\\n                findRoot(graph, visited, v, res, path);\\n        \\n        visited[i] = false;\\n        path.pop_back();\\n    }\\n    \\n    void dfsLeaf(vector<vector<int>>& graph, vector<bool>& visited, int u, int step, int profit, int& res, unordered_map<int, int>& bobp, vector<int>& amount) {\\n        bool isLeaf = true;\\n        visited[u] = true;\\n        \\n        if(has(bobp, u)) {\\n            int s = bobp[u];\\n            if(s == step)\\n                profit += amount[u] / 2;\\n            else if(s > step)\\n                profit += amount[u];\\n        }\\n        else\\n            profit += amount[u];\\n        \\n        for(int v: graph[u]) {\\n            if(!visited[v]) {\\n                dfsLeaf(graph, visited, v, step + 1, profit, res, bobp, amount);\\n                isLeaf = false;\\n            }\\n        }\\n        \\n        visited[u] = false;\\n        \\n        if(isLeaf)\\n            res = max(res, profit);\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        vector<vector<int>> graph(n + 1);\\n        for(vector<int>& edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        vector<int> bp, a;\\n        findRoot(graph, visited, bob, bp, a);\\n        unordered_map<int, int> bobp;\\n        for(int i = bp.size() - 1; i >= 0; i--)\\n            bobp[bp[i]] = i;\\n        int res = INT_MIN;\\n        dfsLeaf(graph, visited, 0, 0, 0, res, bobp, amount);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n#define has(s, k) (s.find(k) != s.end())\\n\\nclass Solution {\\npublic:\\n    void findRoot(vector<vector<int>>& graph, vector<bool>& visited, int i, vector<int>& res, vector<int>& path) {\\n        path.push_back(i);\\n        \\n        if(i == 0) {\\n            res = path;\\n            path.pop_back();\\n            return;\\n        }\\n        visited[i] = true;\\n        \\n        for(int v: graph[i])\\n            if(!visited[v])\\n                findRoot(graph, visited, v, res, path);\\n        \\n        visited[i] = false;\\n        path.pop_back();\\n    }\\n    \\n    void dfsLeaf(vector<vector<int>>& graph, vector<bool>& visited, int u, int step, int profit, int& res, unordered_map<int, int>& bobp, vector<int>& amount) {\\n        bool isLeaf = true;\\n        visited[u] = true;\\n        \\n        if(has(bobp, u)) {\\n            int s = bobp[u];\\n            if(s == step)\\n                profit += amount[u] / 2;\\n            else if(s > step)\\n                profit += amount[u];\\n        }\\n        else\\n            profit += amount[u];\\n        \\n        for(int v: graph[u]) {\\n            if(!visited[v]) {\\n                dfsLeaf(graph, visited, v, step + 1, profit, res, bobp, amount);\\n                isLeaf = false;\\n            }\\n        }\\n        \\n        visited[u] = false;\\n        \\n        if(isLeaf)\\n            res = max(res, profit);\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        vector<vector<int>> graph(n + 1);\\n        for(vector<int>& edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        vector<int> bp, a;\\n        findRoot(graph, visited, bob, bp, a);\\n        unordered_map<int, int> bobp;\\n        for(int i = bp.size() - 1; i >= 0; i--)\\n            bobp[bp[i]] = i;\\n        int res = INT_MIN;\\n        dfsLeaf(graph, visited, 0, 0, 0, res, bobp, amount);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811893,
                "title": "python-3-beats-100",
                "content": "\\tclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        adj = defaultdict(list)\\n        \\n        for a, b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        \\n        # Update the tree based on Bob\\n        bRoute = []\\n        visited = {bob}\\n        def findRoot(cur):\\n            nonlocal bRoute\\n            nonlocal visited\\n            \\n            if cur == 0:\\n                bRoute.append(cur)\\n                return True\\n            \\n            for nei in adj[cur]:\\n                if nei not in visited:\\n                    visited.add(nei)\\n                    if findRoot(nei):\\n                        bRoute.append(cur)\\n                        return True\\n            \\n            return False\\n        \\n        findRoot(bob)\\n        pathIds = bRoute[::-1]\\n        pathLen = len(bRoute)\\n        \\n        for i in range((pathLen+1)//2):\\n            if i == (pathLen+1)//2-1 and pathLen%2 == 1:\\n                amount[pathIds[i]] //= 2\\n            else:\\n                amount[pathIds[i]] = 0\\n        \\n        # Use bfs to find the maximum amount that A can get\\n        ans = float(\\'-inf\\')\\n        visited = {0}\\n        que = deque([(0, amount[0])])\\n        while que:\\n            cur, cum = que.popleft()\\n            isLeaf = True\\n            for nei in adj[cur]:\\n                if nei not in visited:\\n                    visited.add(nei)\\n                    que.append((nei, cum+amount[nei]))\\n                    isLeaf = False\\n            \\n            if isLeaf:\\n                ans = max(ans, cum)\\n        \\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        adj = defaultdict(list)\\n        \\n        for a, b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        \\n        # Update the tree based on Bob\\n        bRoute = []\\n        visited = {bob}",
                "codeTag": "Java"
            },
            {
                "id": 2809478,
                "title": "asked-in-intuit-coding-round-recently-see-my-solution",
                "content": "One month ago, I gave Intuit coding round for FTE. This exact problem had come in it. Wasn\\'t able to solve it then. Amazed to see it appear on Leetcode contest. xD! \\n```\\nclass Solution {\\nvoid dfs(int s,int par,vector<int> adj[],int p[]){\\n    p[s]=par;\\n    for(auto e:adj[s]){\\n       if(e==par)\\n           continue;\\n        dfs(e,s,adj,p);\\n    }\\n}\\n    \\n    void dfs1(int s,int p,vector<int>adj[],vector<int> &amount,int &ans){\\n      if(p!=-1)\\n          amount[s]+=amount[p];\\n        int cnt=0;\\n        for(auto e:adj[s]){\\n          if(e==p)\\n              continue;\\n           ++cnt;\\n            dfs1(e,s,adj,amount,ans);\\n        }\\n        \\n        if(cnt==0)\\n            ans=max(ans,amount[s]);\\n    }\\n    \\n    \\n    public:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<int>adj[n+1];\\n        \\n        for(auto e:edges){\\n           int u=e[0];\\n            int v=e[1];\\n            // --u;\\n            // --v;\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        \\n        int p[n];\\n        memset(p,-1,sizeof(p));\\n        \\n        dfs(0,-1,adj,p);\\n        \\n        vector<int>path;\\n       // bob--;\\n        int cur=bob;\\n        \\n        while(cur!=-1){\\n           path.push_back(cur);\\n            cur=p[cur];\\n        }\\n        \\n        for(int i=0;i<path.size()/2;i++){\\n            amount[path[i]]=0;\\n        }\\n        \\n      //  cout<<path.size()<<endl;\\n        \\n        if(path.size()%2){\\n            int x=(path.size())/2;\\n            \\n            amount[path[x]]/=2;\\n        }\\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<amount.size();i++)\\n            cout<<amount[i]<<endl;\\n        \\n        dfs1(0,-1,adj,amount,ans);\\n       \\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nvoid dfs(int s,int par,vector<int> adj[],int p[]){\\n    p[s]=par;\\n    for(auto e:adj[s]){\\n       if(e==par)\\n           continue;\\n        dfs(e,s,adj,p);\\n    }\\n}\\n    \\n    void dfs1(int s,int p,vector<int>adj[],vector<int> &amount,int &ans){\\n      if(p!=-1)\\n          amount[s]+=amount[p];\\n        int cnt=0;\\n        for(auto e:adj[s]){\\n          if(e==p)\\n              continue;\\n           ++cnt;\\n            dfs1(e,s,adj,amount,ans);\\n        }\\n        \\n        if(cnt==0)\\n            ans=max(ans,amount[s]);\\n    }\\n    \\n    \\n    public:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<int>adj[n+1];\\n        \\n        for(auto e:edges){\\n           int u=e[0];\\n            int v=e[1];\\n            // --u;\\n            // --v;\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        \\n        int p[n];\\n        memset(p,-1,sizeof(p));\\n        \\n        dfs(0,-1,adj,p);\\n        \\n        vector<int>path;\\n       // bob--;\\n        int cur=bob;\\n        \\n        while(cur!=-1){\\n           path.push_back(cur);\\n            cur=p[cur];\\n        }\\n        \\n        for(int i=0;i<path.size()/2;i++){\\n            amount[path[i]]=0;\\n        }\\n        \\n      //  cout<<path.size()<<endl;\\n        \\n        if(path.size()%2){\\n            int x=(path.size())/2;\\n            \\n            amount[path[x]]/=2;\\n        }\\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<amount.size();i++)\\n            cout<<amount[i]<<endl;\\n        \\n        dfs1(0,-1,adj,amount,ans);\\n       \\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2809411,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        path = [[bob, 0]]\\n        f = {}\\n        self.res = -1000000000\\n        \\n        def dfs1(pa, root, dep):#bob\\n            if root == 0:\\n                for p in path:\\n                    node = p[0]\\n                    step = p[1]\\n                    f[node] = step\\n                return\\n            for nxt in g[root]:\\n                if nxt == pa:\\n                    continue\\n                path.append([nxt, dep + 1])\\n                dfs1(root, nxt, dep + 1)  \\n                path.pop()\\n         \\n        \\n        def dfs2(pa, root, dep, score):#alice\\n            if (root not in f) or (f[root] > dep):\\n                score += amount[root]\\n            elif f[root] < dep:\\n                score += 0\\n            elif f[root] == dep:\\n                score += (amount[root] // 2)\\n    \\n            if len(g[root]) == 1 and root != 0: #leaf node\\n                self.res = max(self.res, score)\\n                return\\n            \\n            for nxt in g[root]:\\n                if nxt == pa:\\n                    continue\\n                dfs2(root, nxt, dep + 1, score)\\n        \\n        \\n        n = len(edges) + 1\\n        g = []\\n        for i in range(n):\\n            g.append([])\\n            \\n        for edge in edges:\\n            u = edge[0]\\n            v = edge[1]\\n            g[u].append(v)\\n            g[v].append(u)\\n        \\n        dfs1(-1, bob, 0)\\n        dfs2(-1, 0, 0, 0)\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        path = [[bob, 0]]\\n        f = {}\\n        self.res = -1000000000\\n        \\n        def dfs1(pa, root, dep):#bob\\n            if root == 0:\\n                for p in path:\\n                    node = p[0]\\n                    step = p[1]\\n                    f[node] = step\\n                return\\n            for nxt in g[root]:\\n                if nxt == pa:\\n                    continue\\n                path.append([nxt, dep + 1])\\n                dfs1(root, nxt, dep + 1)  \\n                path.pop()\\n         \\n        \\n        def dfs2(pa, root, dep, score):#alice\\n            if (root not in f) or (f[root] > dep):\\n                score += amount[root]\\n            elif f[root] < dep:\\n                score += 0\\n            elif f[root] == dep:\\n                score += (amount[root] // 2)\\n    \\n            if len(g[root]) == 1 and root != 0: #leaf node\\n                self.res = max(self.res, score)\\n                return\\n            \\n            for nxt in g[root]:\\n                if nxt == pa:\\n                    continue\\n                dfs2(root, nxt, dep + 1, score)\\n        \\n        \\n        n = len(edges) + 1\\n        g = []\\n        for i in range(n):\\n            g.append([])\\n            \\n        for edge in edges:\\n            u = edge[0]\\n            v = edge[1]\\n            g[u].append(v)\\n            g[v].append(u)\\n        \\n        dfs1(-1, bob, 0)\\n        dfs2(-1, 0, 0, 0)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808256,
                "title": "dfs-fully-explained-with-comments",
                "content": "**Approach:**\\nNOTE: Alice can Move only Down , Bob only Above as per Ques\\n1. Move Bob first from node B to node 0 , updating amount to 0(if Bob travels before Alice , as the gate is OPEN for Alice) **or** amount/2 (if both reach simultaneously)\\n2. Find Max path sum from node 0 to leaf Node (**answer may or may NOT include Bob path**) \\n```\\n    void dfs1(int node,int par,int disF0,vector<int>& distance,vector<int>& parent,vector<vector<int>>& adjM){\\n        \\n        distance[node] = disF0;\\n        parent[node] = par;\\n        \\n        for(auto v:adjM[node]){\\n            if(v == par){\\n                // node calling recursion on parent\\n                continue;\\n            }\\n            dfs1(v,node,disF0 +1,distance,parent,adjM);\\n        }\\n    }\\n    \\n    int dfs2(int node,int par,vector<vector<int>>& adjM,vector<int>& amount){\\n        \\n        int ans = INT_MIN;\\n        for(auto v:adjM[node]){\\n            //Find Max from either Left or Right\\n            if(v != par){\\n                ans = max(ans,dfs2(v,node,adjM,amount));\\n            }\\n        }\\n        \\n        if(ans == INT_MIN){\\n            return amount[node];\\n        }\\n        return ans + amount[node];\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();   // Number Of Nodes\\n        vector<int> parent(n,-1);  // Needed to Move Bob from node B to node 0\\n        vector<int> distance(n,0); // Needed to decide whether Alice moves first or Bob to current Node\\n        vector<vector<int>> adjM(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];  \\n            int v = edges[i][1];\\n            adjM[u].push_back(v);\\n            //Undirected Given in ques\\n            adjM[v].push_back(u);\\n\\n        }\\n        \\n        //Fill parent and distance , to help in Bob traversal , starting from node 0\\n        dfs1(0,-1,0,distance,parent,adjM);\\n        \\n        //Travel from Bob to 0\\n        int cur = bob ,curDisOfBob = 0;\\n        while(cur != 0){\\n            //Note: distance[cur] here denotes How away Alice in right now from Bob\\n            if(curDisOfBob < distance[cur]){\\n                //Bob already traversed , so gate open for ALice\\n                amount[cur] = 0;\\n            }\\n            else if(curDisOfBob == distance[cur]){\\n                //Both reaches simultaneously , divide equally (price(-) or reward(+))\\n                amount[cur] = amount[cur]/2;\\n            }\\n\\n\\n            cur = parent[cur];\\n            curDisOfBob++;\\n        }\\n        \\n        \\n        //Maximum sum from node 0 till leaf Node\\n       \\n        return dfs2(0,-1,adjM,amount);\\n    \\n    }\\n```\\n**TC:**\\nO[n] \\n\\n**SC:**\\nO[n]",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n    void dfs1(int node,int par,int disF0,vector<int>& distance,vector<int>& parent,vector<vector<int>>& adjM){\\n        \\n        distance[node] = disF0;\\n        parent[node] = par;\\n        \\n        for(auto v:adjM[node]){\\n            if(v == par){\\n                // node calling recursion on parent\\n                continue;\\n            }\\n            dfs1(v,node,disF0 +1,distance,parent,adjM);\\n        }\\n    }\\n    \\n    int dfs2(int node,int par,vector<vector<int>>& adjM,vector<int>& amount){\\n        \\n        int ans = INT_MIN;\\n        for(auto v:adjM[node]){\\n            //Find Max from either Left or Right\\n            if(v != par){\\n                ans = max(ans,dfs2(v,node,adjM,amount));\\n            }\\n        }\\n        \\n        if(ans == INT_MIN){\\n            return amount[node];\\n        }\\n        return ans + amount[node];\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();   // Number Of Nodes\\n        vector<int> parent(n,-1);  // Needed to Move Bob from node B to node 0\\n        vector<int> distance(n,0); // Needed to decide whether Alice moves first or Bob to current Node\\n        vector<vector<int>> adjM(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];  \\n            int v = edges[i][1];\\n            adjM[u].push_back(v);\\n            //Undirected Given in ques\\n            adjM[v].push_back(u);\\n\\n        }\\n        \\n        //Fill parent and distance , to help in Bob traversal , starting from node 0\\n        dfs1(0,-1,0,distance,parent,adjM);\\n        \\n        //Travel from Bob to 0\\n        int cur = bob ,curDisOfBob = 0;\\n        while(cur != 0){\\n            //Note: distance[cur] here denotes How away Alice in right now from Bob\\n            if(curDisOfBob < distance[cur]){\\n                //Bob already traversed , so gate open for ALice\\n                amount[cur] = 0;\\n            }\\n            else if(curDisOfBob == distance[cur]){\\n                //Both reaches simultaneously , divide equally (price(-) or reward(+))\\n                amount[cur] = amount[cur]/2;\\n            }\\n\\n\\n            cur = parent[cur];\\n            curDisOfBob++;\\n        }\\n        \\n        \\n        //Maximum sum from node 0 till leaf Node\\n       \\n        return dfs2(0,-1,adjM,amount);\\n    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807321,
                "title": "python-dfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlice can reach to Bob from one path only as no. of edges is n - 1 and it is given that it is a tree.\\n\\n**First DFS**\\nWe will first run a dfs to find the bob and in post order while returning from that path update the amount that will be bob\\'s contribution.\\n\\n**Second DFS**\\nThen run a second dfs to calculate the max income.\\n\\n# Approach\\nRun two dfs \\n- 1st to remove the bob\\'s contribution \\n- 2nd to calculate the max income which alice can get.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nimport math\\nfrom collections import deque, defaultdict\\nimport sys\\nsys.setrecursionlimit(10**5) \\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        visited = set()\\n        self.lvl = 0\\n        self.sum = 0\\n        self.max = -math.inf\\n        def remove_bob_income(src, bob, lvl):\\n            if src == bob:\\n                self.lvl = lvl\\n                amount[bob] = 0\\n                return True\\n            visited.add(src)\\n            for child in graph[src]:\\n                if child not in visited:\\n                    ans = remove_bob_income(child, bob, lvl + 1)\\n                    if ans:\\n                        if self.lvl & 1 and lvl == (self.lvl + 1)//2:\\n                            amount[src] //= 2\\n                        elif lvl > (self.lvl // 2):\\n                            amount[src] = 0\\n                        else:\\n                            self.sum += amount[src]   \\n                        return True\\n            return False\\n        \\n            visited.remove(src)\\n        \\n        def dfs(src, income, visited):\\n            if len(graph[src]) == 1 and src != 0:\\n                self.max = max(self.max, income)\\n                return\\n            visited.add(src)\\n            for child in graph[src]:\\n                if child not in visited:\\n                    dfs(child, income + amount[child], visited)\\n            visited.remove(src)\\n                \\n        remove_bob_income(0, bob, 1)\\n        dfs(0, amount[0], set())\\n        return self.max\\n            \\n             \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nimport math\\nfrom collections import deque, defaultdict\\nimport sys\\nsys.setrecursionlimit(10**5) \\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        visited = set()\\n        self.lvl = 0\\n        self.sum = 0\\n        self.max = -math.inf\\n        def remove_bob_income(src, bob, lvl):\\n            if src == bob:\\n                self.lvl = lvl\\n                amount[bob] = 0\\n                return True\\n            visited.add(src)\\n            for child in graph[src]:\\n                if child not in visited:\\n                    ans = remove_bob_income(child, bob, lvl + 1)\\n                    if ans:\\n                        if self.lvl & 1 and lvl == (self.lvl + 1)//2:\\n                            amount[src] //= 2\\n                        elif lvl > (self.lvl // 2):\\n                            amount[src] = 0\\n                        else:\\n                            self.sum += amount[src]   \\n                        return True\\n            return False\\n        \\n            visited.remove(src)\\n        \\n        def dfs(src, income, visited):\\n            if len(graph[src]) == 1 and src != 0:\\n                self.max = max(self.max, income)\\n                return\\n            visited.add(src)\\n            for child in graph[src]:\\n                if child not in visited:\\n                    dfs(child, income + amount[child], visited)\\n            visited.remove(src)\\n                \\n        remove_bob_income(0, bob, 1)\\n        dfs(0, amount[0], set())\\n        return self.max\\n            \\n             \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807315,
                "title": "c-dfs-bfs-time-100-faster-o-n-space-100-smaller-o-n",
                "content": "First step: Do DFS to find the Bob path (only one possible path)  to reach node 0, and save the path in Vpath_B \\nSecond step: Do BFS on Alice, while at each step of BFS move Bob a node further by deleting one node from Vpath_B\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> Adj;\\n    vector<int> visited;\\n    vector<int> Vpath_B;\\n    //DFS for Bob\\n    int find_path_B(int n){\\n        if(n == 0){Vpath_B.push_back(n); return 1;}\\n        \\n        if(visited[n] == 1){return 0;}\\n        visited[n] = 1;\\n        \\n        for(auto &v: Adj[n]){\\n            int flag = find_path_B(v);\\n            if(flag != 1){continue;}\\n            \\n            Vpath_B.push_back(n);\\n            return 1;\\n        }\\n        \\n        return 0;\\n    }\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        \\n        int len_n = amount.size();\\n        Adj.resize(len_n, vector<int>());\\n        for(auto &E:edges){\\n            int u = E[0], v = E[1];\\n            Adj[u].push_back(v);\\n            Adj[v].push_back(u);\\n        }\\n        \\n        //DFS of bob\\n        visited.resize(len_n, 0);\\n        find_path_B(bob);\\n \\n// vector<int> Vp2 = Vpath_B;\\n// for(int i = 0; i < Vp2.size(); i++){\\n//     cout << Vp2[i] << \" \";\\n// }\\n// cout << endl << endl;\\n        \\n        amount[bob] = 0;\\n        Vpath_B.pop_back();\\n        \\n        \\n        using pii = pair<int,int>;\\n        int val = amount[0];\\n        queue<pii> Q({{0,val}});\\n        int Max = INT_MIN;\\n        \\n        vector<int> visited2(len_n, 0);\\n        visited2[0] = 1;\\n        //BFS for Alice, while maintaing Bob location on its path\\n        while(!Q.empty()){\\n            int len_Q = Q.size();\\n\\t\\t\\t\\n\\t\\t\\t//maintaing Bob\\'s position\\n            int n_bob = -1;\\n            if(!Vpath_B.empty()){\\n                n_bob = Vpath_B.back();\\n                Vpath_B.pop_back();\\n            }\\n\\n\\t\\t\\t//Alice\\'s next move\\n            while(len_Q--){\\n                int u = Q.front().first;\\n                int val = Q.front().second;\\n                Q.pop();\\n                \\n         \\n                if(Adj[u].size() == 1 && u != 0){ //leaf\\n                    Max = max(Max, val);\\n                    continue;\\n                }\\n                \\n                for(int &v: Adj[u]){\\n                    if(visited2[v] == 1){continue;}\\n                    visited2[v] = 1; \\n                    \\n                    if(v != n_bob){\\n                        Q.push({v, val+ amount[v]});\\n                        continue;\\n                    }\\n                    \\n                    Q.push({v, val+amount[v]/2});\\n                }\\n            }\\n            \\n\\t\\t\\t//rewards and costs taken away by Bob\\n            if(n_bob != -1){amount[n_bob] = 0;}\\n        }\\n        \\n        return Max;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> Adj;\\n    vector<int> visited;\\n    vector<int> Vpath_B;\\n    //DFS for Bob\\n    int find_path_B(int n){\\n        if(n == 0){Vpath_B.push_back(n); return 1;}\\n        \\n        if(visited[n] == 1){return 0;}\\n        visited[n] = 1;\\n        \\n        for(auto &v: Adj[n]){\\n            int flag = find_path_B(v);\\n            if(flag != 1){continue;}\\n            \\n            Vpath_B.push_back(n);\\n            return 1;\\n        }\\n        \\n        return 0;\\n    }\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        \\n        int len_n = amount.size();\\n        Adj.resize(len_n, vector<int>());\\n        for(auto &E:edges){\\n            int u = E[0], v = E[1];\\n            Adj[u].push_back(v);\\n            Adj[v].push_back(u);\\n        }\\n        \\n        //DFS of bob\\n        visited.resize(len_n, 0);\\n        find_path_B(bob);\\n \\n// vector<int> Vp2 = Vpath_B;\\n// for(int i = 0; i < Vp2.size(); i++){\\n//     cout << Vp2[i] << \" \";\\n// }\\n// cout << endl << endl;\\n        \\n        amount[bob] = 0;\\n        Vpath_B.pop_back();\\n        \\n        \\n        using pii = pair<int,int>;\\n        int val = amount[0];\\n        queue<pii> Q({{0,val}});\\n        int Max = INT_MIN;\\n        \\n        vector<int> visited2(len_n, 0);\\n        visited2[0] = 1;\\n        //BFS for Alice, while maintaing Bob location on its path\\n        while(!Q.empty()){\\n            int len_Q = Q.size();\\n\\t\\t\\t\\n\\t\\t\\t//maintaing Bob\\'s position\\n            int n_bob = -1;\\n            if(!Vpath_B.empty()){\\n                n_bob = Vpath_B.back();\\n                Vpath_B.pop_back();\\n            }\\n\\n\\t\\t\\t//Alice\\'s next move\\n            while(len_Q--){\\n                int u = Q.front().first;\\n                int val = Q.front().second;\\n                Q.pop();\\n                \\n         \\n                if(Adj[u].size() == 1 && u != 0){ //leaf\\n                    Max = max(Max, val);\\n                    continue;\\n                }\\n                \\n                for(int &v: Adj[u]){\\n                    if(visited2[v] == 1){continue;}\\n                    visited2[v] = 1; \\n                    \\n                    if(v != n_bob){\\n                        Q.push({v, val+ amount[v]});\\n                        continue;\\n                    }\\n                    \\n                    Q.push({v, val+amount[v]/2});\\n                }\\n            }\\n            \\n\\t\\t\\t//rewards and costs taken away by Bob\\n            if(n_bob != -1){amount[n_bob] = 0;}\\n        }\\n        \\n        return Max;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2807134,
                "title": "dfs-bt",
                "content": "Perform DFS + BT (depth-first-search with back-tracking)\\n\\n1. Find Bob\\'s path to node `0` via DFS + BT\\n2. Then DFS + BT all possibilities for Alice\\'s path in parallel with each `i`<sup>th</sup> node of Bob\\'s path\\n\\nThere\\'s 3 possibilities for `cost` we can `take` which is accumulated onto what we `have`:\\n\\n1. if Alice and Bob are on the same node, we `take` half the `cost`\\n2. if Bob hasn\\'t seen Alice\\'s node, we `take` the full `cost`\\n3. otherwise we `take` nothing\\n\\nUpon reaching a leaf node in the set of `leaves`, we consider the maximum of what we `have` as the `best` answer.\\n\\n* Note: if node `0` is one of the `leaves` we remove it, since it is not a `leaf` node candidate\\n\\n---\\n\\n**\\u2B50\\uFE0F Back-Tracking (BT) example:**\\n\\n\"BT\" is back-tracking, ie. during our DFS traversal we `go()` visit adjacent nodes, if we arrive at a node which is a \"`fork` in the road\" we explore each unique path\\'s state by back-tracking to the node where the path forked as the recursive stack unwinds.  The recusive stack unwinds as the base cases (leaf nodes) are reached, ie. as we `return` from the recursive invocations of `go()`.  So before we `return`, we \"unset\" what was \"set\" in reverse to revert back to each previous state.\\n\\n**\\uD83D\\uDE80 What does it mean to recursively `go()` perform a Depth-First-Search (DFS) traversal?**\\n\\nLet each edge\\'s nodes be denoted as (`u`, `v`) pairs, ie. `u` --> `v`, then \"`here`\" is node `u` and \"`there`\" is node `v`.\\n\\u2022 See [\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) for more details and a picture, ie. \"`here`\" is relative to \"`there`\"\\n\\n![image](https://assets.leetcode.com/users/images/3f2e91a6-91d3-4afb-a996-4d30c5441ce8_1668277854.6015136.png)\\n\\nAn example of BT can be observed in the `find_bob_path` function (see comments below):\\n\\n```\\n        def find_bob_path(path = [bob], seen = set([bob])):\\n            nonlocal bob_path\\n            u = path[-1]\\n            if not u:\\n                bob_path = path[:]\\n            if len(bob_path):\\n                return\\n            for v in adj[u]:\\n                if v not in seen:\\n                    path.append(v); seen.add(v) # \\uD83D\\uDC49 forward-tracking (ie. \"set\" state here)\\n                    find_bob_path(path, seen)   # \\uD83D\\uDE80 recursively perform DFS traversal\\n                    path.pop(); seen.remove(v)  # \\uD83D\\uDC48 back-tracking (ie. \"unset\" state here)\\n```\\n\\n---\\n\\n*Python3*\\n```\\nclass Solution:\\n    def mostProfitablePath(self, E: List[List[int]], bob: int, cost: List[int]) -> int:\\n        N = len(cost)\\n        adj = defaultdict(list)\\n        for u, v in E:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        leaves = set()\\n        for u in range(N):\\n            if len(adj[u]) == 1:\\n                leaves.add(u)\\n        if 0 in leaves:\\n            leaves.remove(0)\\n        bob_path = []\\n        def find_bob_path(path = [bob], seen = set([bob])):\\n            nonlocal bob_path\\n            u = path[-1]\\n            if not u:\\n                bob_path = path[:]\\n            if len(bob_path):\\n                return\\n            for v in adj[u]:\\n                if v not in seen:\\n                    path.append(v); seen.add(v)\\n                    find_bob_path(path, seen)\\n                    path.pop(); seen.remove(v)\\n        find_bob_path()\\n        best = float(\\'-inf\\')\\n        def go(u = 0, i = 0, have = 0, seen_a = set([0]), seen_b = set([])):\\n            nonlocal best\\n            if i < len(bob_path):\\n                seen_b.add(bob_path[i])\\n            take = cost[u] // 2 if i < len(bob_path) and u == bob_path[i] else cost[u] if u not in seen_b else 0\\n            have += take\\n            if u in leaves:\\n                best = max(best, have)\\n            for v in adj[u]:\\n                if v not in seen_a:\\n                    seen_a.add(v)\\n                    go(v, i + 1, have, seen_a, seen_b)\\n                    seen_a.remove(v)\\n            if i < len(bob_path):\\n                seen_b.remove(bob_path[i])\\n        go()\\n        return best\\n```\\n",
                "solutionTags": [],
                "code": "```\\n        def find_bob_path(path = [bob], seen = set([bob])):\\n            nonlocal bob_path\\n            u = path[-1]\\n            if not u:\\n                bob_path = path[:]\\n            if len(bob_path):\\n                return\\n            for v in adj[u]:\\n                if v not in seen:\\n                    path.append(v); seen.add(v) # \\uD83D\\uDC49 forward-tracking (ie. \"set\" state here)\\n                    find_bob_path(path, seen)   # \\uD83D\\uDE80 recursively perform DFS traversal\\n                    path.pop(); seen.remove(v)  # \\uD83D\\uDC48 back-tracking (ie. \"unset\" state here)\\n```\n```\\nclass Solution:\\n    def mostProfitablePath(self, E: List[List[int]], bob: int, cost: List[int]) -> int:\\n        N = len(cost)\\n        adj = defaultdict(list)\\n        for u, v in E:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        leaves = set()\\n        for u in range(N):\\n            if len(adj[u]) == 1:\\n                leaves.add(u)\\n        if 0 in leaves:\\n            leaves.remove(0)\\n        bob_path = []\\n        def find_bob_path(path = [bob], seen = set([bob])):\\n            nonlocal bob_path\\n            u = path[-1]\\n            if not u:\\n                bob_path = path[:]\\n            if len(bob_path):\\n                return\\n            for v in adj[u]:\\n                if v not in seen:\\n                    path.append(v); seen.add(v)\\n                    find_bob_path(path, seen)\\n                    path.pop(); seen.remove(v)\\n        find_bob_path()\\n        best = float(\\'-inf\\')\\n        def go(u = 0, i = 0, have = 0, seen_a = set([0]), seen_b = set([])):\\n            nonlocal best\\n            if i < len(bob_path):\\n                seen_b.add(bob_path[i])\\n            take = cost[u] // 2 if i < len(bob_path) and u == bob_path[i] else cost[u] if u not in seen_b else 0\\n            have += take\\n            if u in leaves:\\n                best = max(best, have)\\n            for v in adj[u]:\\n                if v not in seen_a:\\n                    seen_a.add(v)\\n                    go(v, i + 1, have, seen_a, seen_b)\\n                    seen_a.remove(v)\\n            if i < len(bob_path):\\n                seen_b.remove(bob_path[i])\\n        go()\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557421,
                "title": "c-easiest-solution-detailed-solution-fully-explained-dfs-bfs-graph",
                "content": "# Intuition\\n1.First store the time take by bob to reach the node 0 and the nodes in the path mark their time when will bob reach at them while reaching 0\\n2.Now come to alice start his traversal and check who has first reached at that node alice or bob if alice reached then add the amount to alice if both at same time then divide it and if alice reach later than bob then add 0 or you can ignore that case\\n3.Third and most important update the ans only when you reach the leaf node \\n\\n# Approach\\n1.for the first step i did a dfs only special thing here was for storing time i used the map so that i can easily remove those nodes which are not the part of my path \\n2.now for second step simple bfs works just do as asked in the that\\n3. how to know it is leaf node see it does not have any child so you can say that in the adjacency list of leaf only one node will be there and hence adj[leaf].size()==0 thats it \\n\\n# Complexity\\n- Time complexity:\\nO(V+E) as it is simple dfs and bfs where v is no of vertices and e is no of edges\\n\\n- Space complexity:\\nO(V+E) for the adjcency list and O(V) for map and vis so overall it will be O(V+E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool dfs(int node,int t,vector<int> &vis,unordered_map<int,int> &path,vector<int> adj[]){\\n       vis[node]=1;\\n       path[node]=t;\\n       if(node==0){\\n           return true;\\n       }\\n       for(auto child:adj[node]){\\n           if(!vis[child]){\\n               if(dfs(child,t+1,vis,path,adj)){\\n                   return true;\\n               }\\n           }\\n       }\\n       path.erase(node);\\n       return false;\\n   }\\n\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<int> adj[n];\\n        for(auto it:edges){\\n            int x=it[0];\\n            int y=it[1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int> vis(n,0);\\n        unordered_map<int,int> path;\\n        dfs(bob,0,vis,path,adj);\\n\\n        queue<vector<int>> q;\\n        q.push({0,0,0}); // node time tot \\n        vis.assign(n,0);\\n\\n        int ans=INT_MIN;\\n        while(!q.empty()){\\n            vector<int> v=q.front();\\n            int node=v[0];\\n            int time=v[1];\\n            int tot=v[2];\\n            q.pop();\\n            vis[node]=1;\\n\\n            if(path.find(node)==path.end()){\\n                tot+=amount[node];\\n            }\\n            else{\\n\\n                if(time<path[node]){\\n                    tot+=amount[node];\\n                }\\n                else if(time==path[node]){\\n                    tot+=(amount[node]/2);\\n                }\\n            }\\n\\n            if(adj[node].size()==1 && node!=0){\\n                ans=max(ans,tot);\\n            }\\n\\n            for(auto child:adj[node]){\\n               if(!vis[child]){\\n                   q.push({child,time+1,tot});\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool dfs(int node,int t,vector<int> &vis,unordered_map<int,int> &path,vector<int> adj[]){\\n       vis[node]=1;\\n       path[node]=t;\\n       if(node==0){\\n           return true;\\n       }\\n       for(auto child:adj[node]){\\n           if(!vis[child]){\\n               if(dfs(child,t+1,vis,path,adj)){\\n                   return true;\\n               }\\n           }\\n       }\\n       path.erase(node);\\n       return false;\\n   }\\n\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<int> adj[n];\\n        for(auto it:edges){\\n            int x=it[0];\\n            int y=it[1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int> vis(n,0);\\n        unordered_map<int,int> path;\\n        dfs(bob,0,vis,path,adj);\\n\\n        queue<vector<int>> q;\\n        q.push({0,0,0}); // node time tot \\n        vis.assign(n,0);\\n\\n        int ans=INT_MIN;\\n        while(!q.empty()){\\n            vector<int> v=q.front();\\n            int node=v[0];\\n            int time=v[1];\\n            int tot=v[2];\\n            q.pop();\\n            vis[node]=1;\\n\\n            if(path.find(node)==path.end()){\\n                tot+=amount[node];\\n            }\\n            else{\\n\\n                if(time<path[node]){\\n                    tot+=amount[node];\\n                }\\n                else if(time==path[node]){\\n                    tot+=(amount[node]/2);\\n                }\\n            }\\n\\n            if(adj[node].size()==1 && node!=0){\\n                ans=max(ans,tot);\\n            }\\n\\n            for(auto child:adj[node]){\\n               if(!vis[child]){\\n                   q.push({child,time+1,tot});\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383537,
                "title": "simple-dfs-solution-bets-97-runtime",
                "content": "# Intuition\\n1) Calculate the distance of nodes in the path of bob from his initial position. \\n2) Make dfs call from 0 to get the maximum value.\\n3) Make sure to check for overflow and root node codition\\n\\nUpvote if you like the solution.\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n = amount.length;\\n        List<Integer>[] g = new ArrayList[n];\\n        for(int i=0;i<n;i++) g[i] = new ArrayList<>();\\n        for(int[] edge:edges){\\n            g[edge[0]].add(edge[1]);\\n            g[edge[1]].add(edge[0]);\\n        }\\n        int count = 0;\\n        int[] visited = new int[n];\\n        moveToZero(bob,-1,1,visited,g);\\n        return (int)dfs(0,-1,1,visited,g,amount);\\n    }\\n\\n    private boolean moveToZero(int src,int prnt,int level,int[] visited,List<Integer>[] g){\\n        if(src==0){\\n            visited[src] = level;\\n            return true;\\n        }\\n        visited[src] = level;\\n        for(int ngb:g[src]){\\n            if(ngb!=prnt){\\n                if(moveToZero(ngb,src,level+1,visited,g)) return true;\\n            }\\n        }\\n        // If current node is not in the path of bob to 0. Make sure to make it 0 again.\\n        visited[src] = 0;\\n        return false;\\n    }\\n\\n    private long dfs(int src,int prnt,int level,int[] visited,List<Integer>[] g,int[] amount){\\n        long cost = 0;\\n\\n        // Check if current node is already been visited or not.\\n        if(visited[src]==0) cost += amount[src];\\n        else if(visited[src]>level) cost += amount[src];\\n        else if(visited[src]==level) cost += (amount[src]/2);\\n\\n        // Maximum minimum value possible\\n        long current = -100_00_00_00_0;\\n        for(int ngb:g[src]){\\n            if(ngb!=prnt){\\n                current = Math.max(dfs(ngb,src,level+1,visited,g,amount),current);\\n            }\\n        }\\n        // Checks for root node condition \\n        if(current==(-100_00_00_00_0)) return cost;\\n        return cost+current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n = amount.length;\\n        List<Integer>[] g = new ArrayList[n];\\n        for(int i=0;i<n;i++) g[i] = new ArrayList<>();\\n        for(int[] edge:edges){\\n            g[edge[0]].add(edge[1]);\\n            g[edge[1]].add(edge[0]);\\n        }\\n        int count = 0;\\n        int[] visited = new int[n];\\n        moveToZero(bob,-1,1,visited,g);\\n        return (int)dfs(0,-1,1,visited,g,amount);\\n    }\\n\\n    private boolean moveToZero(int src,int prnt,int level,int[] visited,List<Integer>[] g){\\n        if(src==0){\\n            visited[src] = level;\\n            return true;\\n        }\\n        visited[src] = level;\\n        for(int ngb:g[src]){\\n            if(ngb!=prnt){\\n                if(moveToZero(ngb,src,level+1,visited,g)) return true;\\n            }\\n        }\\n        // If current node is not in the path of bob to 0. Make sure to make it 0 again.\\n        visited[src] = 0;\\n        return false;\\n    }\\n\\n    private long dfs(int src,int prnt,int level,int[] visited,List<Integer>[] g,int[] amount){\\n        long cost = 0;\\n\\n        // Check if current node is already been visited or not.\\n        if(visited[src]==0) cost += amount[src];\\n        else if(visited[src]>level) cost += amount[src];\\n        else if(visited[src]==level) cost += (amount[src]/2);\\n\\n        // Maximum minimum value possible\\n        long current = -100_00_00_00_0;\\n        for(int ngb:g[src]){\\n            if(ngb!=prnt){\\n                current = Math.max(dfs(ngb,src,level+1,visited,g,amount),current);\\n            }\\n        }\\n        // Checks for root node condition \\n        if(current==(-100_00_00_00_0)) return cost;\\n        return cost+current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007224,
                "title": "python3-easiest-dfs-bfs-o-n",
                "content": "# Intuition\\nSince this is a tree we know that there is only 1 path between any 2 given nodes. With this knowledge we now know that bob only has one path so we can actually record at what step bob reaches a given gate. Then we can traverse as Alice and take the amount accordingly.\\n\\n# Approach\\n1. Do a DFS and record at what step bob reaches a gate in his path.\\n2. Do a BFS and for each gate, find how much amount alice will get/give based on the number of steps she has taken.\\n    - If bob has not visited the gate or if bob has not visited the gate **yet**, then Alice will get/give the entire amount.\\n    - If bob and Alice have both taken same number of steps, then we split the amount.\\n    - And if bob has visited the gate before Alice could, then the amount Alice will get/give is 0.\\n3. When we reach a leaf gate (The gate where Alice starts which is 0 is also a leaf, so make sure you add a condition to check that gate should not be equal to 0) update the max_income.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)+O(N)$$ *for dfs and bfs*\\n\\n- Space complexity:\\n$$O(N)+O(N)$$ *for adj list and queue*\\n\\n# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        bobPath,adj = {},defaultdict(list)\\n        for u,v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n\\n        def bobTraverse(gate,parent,step):\\n            bobPath[gate] = step\\n            if gate==0: return True\\n            for nei in adj[gate]:\\n                if nei==parent: continue\\n                if bobTraverse(nei,gate,step+1): return True\\n            \\n            del bobPath[gate]\\n            return False\\n        \\n        bobTraverse(bob,-1,0)\\n        \\n        max_net_income,queue = float(\"-inf\"),deque()\\n        queue.append((0,-1,0,0))\\n        while queue:\\n            gate,parent,cur_net_income,step = queue.popleft()\\n            cur_net_income += self.getGateAmount(bobPath,gate,step,amount)\\n            if len(adj[gate])==1 and gate!=0:\\n                max_net_income = max(max_net_income,cur_net_income)\\n                \\n            for nei in adj[gate]:\\n                if nei==parent: continue\\n                queue.append((nei,gate,cur_net_income,step+1))\\n        \\n        return max_net_income\\n\\n    def getGateAmount(self,bobPath,gate,step,amount):\\n        if gate not in bobPath: return amount[gate]\\n        if bobPath[gate]>step: return amount[gate]\\n        if bobPath[gate]==step: return amount[gate]//2\\n        return 0\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        bobPath,adj = {},defaultdict(list)\\n        for u,v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n\\n        def bobTraverse(gate,parent,step):\\n            bobPath[gate] = step\\n            if gate==0: return True\\n            for nei in adj[gate]:\\n                if nei==parent: continue\\n                if bobTraverse(nei,gate,step+1): return True\\n            \\n            del bobPath[gate]\\n            return False\\n        \\n        bobTraverse(bob,-1,0)\\n        \\n        max_net_income,queue = float(\"-inf\"),deque()\\n        queue.append((0,-1,0,0))\\n        while queue:\\n            gate,parent,cur_net_income,step = queue.popleft()\\n            cur_net_income += self.getGateAmount(bobPath,gate,step,amount)\\n            if len(adj[gate])==1 and gate!=0:\\n                max_net_income = max(max_net_income,cur_net_income)\\n                \\n            for nei in adj[gate]:\\n                if nei==parent: continue\\n                queue.append((nei,gate,cur_net_income,step+1))\\n        \\n        return max_net_income\\n\\n    def getGateAmount(self,bobPath,gate,step,amount):\\n        if gate not in bobPath: return amount[gate]\\n        if bobPath[gate]>step: return amount[gate]\\n        if bobPath[gate]==step: return amount[gate]//2\\n        return 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000926,
                "title": "fast-easy-c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTravarsing one by one by bob(with saving timeStamp) and then alice(with calculating cost)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> timeMap;\\n    vector<bool> vis;\\n    unordered_map<int, vector<int>> g;\\n    int ans = INT_MIN;\\n\\n    bool callForBob(int bob, int sec){\\n        if(bob == 0){\\n            timeMap[bob] = sec;\\n            return true;\\n        }\\n\\n        vis[bob] = 1;\\n        bool canReach = 0;\\n        for(auto it:g[bob]){\\n            if(vis[it]) continue;\\n            if(callForBob(it, sec+1) == true){\\n                canReach = 1;\\n                break;\\n            }\\n        }\\n        vis[bob] = 0;\\n\\n        if(canReach == 1){\\n            timeMap[bob] = sec;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void callForAlice(int node, int sec, int cost, vector<int> &amount){\\n        vis[node] = 1;\\n\\n        if(timeMap[node] > sec)\\n            cost += amount[node];\\n        else if(timeMap[node] == sec)\\n            cost += (amount[node])/2;\\n        \\n        for(auto it:g[node]){\\n            if(vis[it]) continue;\\n            callForAlice(it, sec+1, cost, amount);\\n        }\\n        vis[node] = 0;\\n        if(node != 0 && g[node].size() == 1){\\n            ans = max(ans, cost);\\n        }\\n    }\\n\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        // forming the tree as a undirected graph\\n        for(auto it:edges){\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        // visited array of size n\\n        vis.resize(n);\\n        timeMap.resize(n, INT_MAX);\\n\\n        int sec = 0;\\n        callForBob(bob, sec);\\n\\n        callForAlice(0, sec, 0, amount);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> timeMap;\\n    vector<bool> vis;\\n    unordered_map<int, vector<int>> g;\\n    int ans = INT_MIN;\\n\\n    bool callForBob(int bob, int sec){\\n        if(bob == 0){\\n            timeMap[bob] = sec;\\n            return true;\\n        }\\n\\n        vis[bob] = 1;\\n        bool canReach = 0;\\n        for(auto it:g[bob]){\\n            if(vis[it]) continue;\\n            if(callForBob(it, sec+1) == true){\\n                canReach = 1;\\n                break;\\n            }\\n        }\\n        vis[bob] = 0;\\n\\n        if(canReach == 1){\\n            timeMap[bob] = sec;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void callForAlice(int node, int sec, int cost, vector<int> &amount){\\n        vis[node] = 1;\\n\\n        if(timeMap[node] > sec)\\n            cost += amount[node];\\n        else if(timeMap[node] == sec)\\n            cost += (amount[node])/2;\\n        \\n        for(auto it:g[node]){\\n            if(vis[it]) continue;\\n            callForAlice(it, sec+1, cost, amount);\\n        }\\n        vis[node] = 0;\\n        if(node != 0 && g[node].size() == 1){\\n            ans = max(ans, cost);\\n        }\\n    }\\n\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        // forming the tree as a undirected graph\\n        for(auto it:edges){\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        // visited array of size n\\n        vis.resize(n);\\n        timeMap.resize(n, INT_MAX);\\n\\n        int sec = 0;\\n        callForBob(bob, sec);\\n\\n        callForAlice(0, sec, 0, amount);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998981,
                "title": "dfs-java-soln",
                "content": "### Use pen and paper and Be patient it takes time ...\\n# Code\\n```\\nclass Solution {\\n    // creating adjacency matrix\\n    Map<Integer , List<Integer>> tree = new HashMap<>();\\n\\n    int[] parent = null;\\n    int[] dist = null;\\n\\n    private void constructTree(int[][] edges){\\n        int n = edges.length;\\n\\n        for(int i = 0; i < n; i++){ // checking every pair [ai , bi]\\n\\n            int n1 = edges[i][0]; // ith row 0th col\\n            int n2 = edges[i][1]; // ith row 1st col\\n\\n            if(!tree.containsKey(n1)){ // if n1 is not present in map\\n                tree.put(n1,new ArrayList<>()); // insert it into the map with a empty list\\n            }\\n            if(!tree.containsKey(n2)){ // same goes for n2 \\n                tree.put(n2,new ArrayList<>());\\n            }\\n            tree.get(n1).add(n2); // it is showing that n1 is connected with n2\\n            tree.get(n2).add(n1); // it is showing that n2 is connected with n1\\n        }\\n    }\\n\\n    private void dfsToFindParent(int curr , int currParent , int currDist){\\n        dist[curr] = currDist;\\n        parent[curr] = currParent;\\n\\n        for(Integer currNeighbour : tree.get(curr)){\\n            if(currNeighbour == currParent){ // if its visited skip it\\n                continue;\\n            }\\n            dfsToFindParent(currNeighbour , curr , currDist + 1); // call dfs for neighbours which are not visited yet\\n        }\\n\\n    }\\n\\n    Set<Integer> visited = new HashSet<>();\\n    int ans = 0;\\n    int maxAns = Integer.MIN_VALUE;\\n\\n    private void dfs(int curr , int[] amount){\\n\\n        visited.add(curr); // add it into the visitedSet\\n        ans = ans + amount[curr]; // calc currentProfit \\n        int trav = 0; // TO detect the leaf node (already the neighbour nodes for leaf node are visited)\\n        for(Integer currNeighbour : tree.get(curr)){ // if neighbour is already visited skip it (check it in set)\\n            if(visited.contains(currNeighbour)){\\n                continue; \\n            }\\n            trav++;\\n            dfs(currNeighbour,amount); // calling dfs for neighbours\\n        }\\n        if(trav == 0){ // reach the leaf node\\n        maxAns = Math.max(ans , maxAns); // calculate maxProfit\\n        }\\n        ans = ans - amount[curr]; // backtracking so that we can track other paths also \\n    }\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n\\n        constructTree(edges); // construct a adjacency matrix\\n        int n = edges.length;\\n        parent = new int[n + 1];\\n        dist = new int[n + 1];\\n\\n        Arrays.fill(parent,-1);\\n        Arrays.fill(dist,-1);\\n\\n        dfsToFindParent(0,0,0); // (curr , currParent , currdist)\\n\\n        int curr = bob;   // from bob to when curr reach 0\\n        int currDist = 0;\\n\\n        //update the parent and amount at each node \\n        while(curr != 0){\\n            if(dist[curr] > currDist){ // if dist of currNode from root node is greater than currDist from bob\\'s node\\n            // that means bob reaches first so alice is not concerned about this one at that particular time so amt[curr] = 0;\\n                amount[curr] = 0; \\n            }\\n            else if(dist[curr] == currDist){ // if both reach at same node simulataneously than divide the amount by 2 \\n                amount[curr] /= 2;\\n            }\\n            curr = parent[curr]; // update curr with parent of curr\\n            currDist++; // inc curDist\\n        }\\n        //Now find the max sum you can obtain when you start moving from root node to any one of the leaf node (dfs)\\n        dfs(0,amount);\\n\\n        return maxAns; // return the maximum profit \\n    }\\n}\\n```\\n\\n### UpVote if you like it...",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // creating adjacency matrix\\n    Map<Integer , List<Integer>> tree = new HashMap<>();\\n\\n    int[] parent = null;\\n    int[] dist = null;\\n\\n    private void constructTree(int[][] edges){\\n        int n = edges.length;\\n\\n        for(int i = 0; i < n; i++){ // checking every pair [ai , bi]\\n\\n            int n1 = edges[i][0]; // ith row 0th col\\n            int n2 = edges[i][1]; // ith row 1st col\\n\\n            if(!tree.containsKey(n1)){ // if n1 is not present in map\\n                tree.put(n1,new ArrayList<>()); // insert it into the map with a empty list\\n            }\\n            if(!tree.containsKey(n2)){ // same goes for n2 \\n                tree.put(n2,new ArrayList<>());\\n            }\\n            tree.get(n1).add(n2); // it is showing that n1 is connected with n2\\n            tree.get(n2).add(n1); // it is showing that n2 is connected with n1\\n        }\\n    }\\n\\n    private void dfsToFindParent(int curr , int currParent , int currDist){\\n        dist[curr] = currDist;\\n        parent[curr] = currParent;\\n\\n        for(Integer currNeighbour : tree.get(curr)){\\n            if(currNeighbour == currParent){ // if its visited skip it\\n                continue;\\n            }\\n            dfsToFindParent(currNeighbour , curr , currDist + 1); // call dfs for neighbours which are not visited yet\\n        }\\n\\n    }\\n\\n    Set<Integer> visited = new HashSet<>();\\n    int ans = 0;\\n    int maxAns = Integer.MIN_VALUE;\\n\\n    private void dfs(int curr , int[] amount){\\n\\n        visited.add(curr); // add it into the visitedSet\\n        ans = ans + amount[curr]; // calc currentProfit \\n        int trav = 0; // TO detect the leaf node (already the neighbour nodes for leaf node are visited)\\n        for(Integer currNeighbour : tree.get(curr)){ // if neighbour is already visited skip it (check it in set)\\n            if(visited.contains(currNeighbour)){\\n                continue; \\n            }\\n            trav++;\\n            dfs(currNeighbour,amount); // calling dfs for neighbours\\n        }\\n        if(trav == 0){ // reach the leaf node\\n        maxAns = Math.max(ans , maxAns); // calculate maxProfit\\n        }\\n        ans = ans - amount[curr]; // backtracking so that we can track other paths also \\n    }\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n\\n        constructTree(edges); // construct a adjacency matrix\\n        int n = edges.length;\\n        parent = new int[n + 1];\\n        dist = new int[n + 1];\\n\\n        Arrays.fill(parent,-1);\\n        Arrays.fill(dist,-1);\\n\\n        dfsToFindParent(0,0,0); // (curr , currParent , currdist)\\n\\n        int curr = bob;   // from bob to when curr reach 0\\n        int currDist = 0;\\n\\n        //update the parent and amount at each node \\n        while(curr != 0){\\n            if(dist[curr] > currDist){ // if dist of currNode from root node is greater than currDist from bob\\'s node\\n            // that means bob reaches first so alice is not concerned about this one at that particular time so amt[curr] = 0;\\n                amount[curr] = 0; \\n            }\\n            else if(dist[curr] == currDist){ // if both reach at same node simulataneously than divide the amount by 2 \\n                amount[curr] /= 2;\\n            }\\n            curr = parent[curr]; // update curr with parent of curr\\n            currDist++; // inc curDist\\n        }\\n        //Now find the max sum you can obtain when you start moving from root node to any one of the leaf node (dfs)\\n        dfs(0,amount);\\n\\n        return maxAns; // return the maximum profit \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998287,
                "title": "c-dfs-simple-approach-fully-explained",
                "content": "##### Easy **DFS** approach explained in code with comments\\n```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& e, int bob, vector<int>& a)\\n    {\\n        int n = size(a);\\n        vector<vector<int>> g(n);\\n        // make a graph out of given edges\\n        for(auto &x: e)\\n        {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        \\n        //now find a path from bob to root(0)\\n        \\n        vector<int> path;\\n        findPath(0,g,path,bob,-1);\\n        \\n        //if length of path is odd then bob and alice will meet at some point\\n        // so just divide amount of meeting point of alice and bob by 2\\n        \\n        // if length is even alice and bob will never meet\\n        \\n        if(size(path) % 2)a[path[size(path)/2]] /= 2;\\n        \\n        //now update amount of nodes that are visited by bob first (before alice visits them) to 0\\n        \\n        \\n        for(int i = 0; i < (size(path) / 2); i++)a[path[i]] = 0;\\n        \\n        // after that just find the maximum path from root to all leaf nodes using dfs\\n        \\n        return dfs(0,g,a,-1);\\n    }\\n    private:\\n    int dfs(int src, vector<vector<int>>& g, vector<int>& a, int par)\\n    {\\n        int res = INT_MIN;\\n        for(auto &x: g[src])\\n        {\\n            // do not call dfs to its parent\\n            \\n            if(x == par)continue;\\n            \\n            res = max(res,dfs(x,g,a,src));\\n        }\\n        \\n        //if the node is leaf we just return its amount\\n        \\n        if(res == INT_MIN)return a[src];\\n        \\n        // else return total amount of path;\\n        \\n        return res+a[src];\\n    }\\n    bool findPath(int src, vector<vector<int>>& g, vector<int>& path, int bob, int par)\\n    {\\n        if(src == bob)\\n        {\\n            path.push_back(src);return true;\\n        }\\n        \\n        for(auto &x: g[src])\\n        {\\n            // do not call dfs to its parent\\n            \\n            if(x == par)continue;\\n            \\n            if(findPath(x,g,path,bob,src))\\n            {\\n                path.push_back(src);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& e, int bob, vector<int>& a)\\n    {\\n        int n = size(a);\\n        vector<vector<int>> g(n);\\n        // make a graph out of given edges\\n        for(auto &x: e)\\n        {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        \\n        //now find a path from bob to root(0)\\n        \\n        vector<int> path;\\n        findPath(0,g,path,bob,-1);\\n        \\n        //if length of path is odd then bob and alice will meet at some point\\n        // so just divide amount of meeting point of alice and bob by 2\\n        \\n        // if length is even alice and bob will never meet\\n        \\n        if(size(path) % 2)a[path[size(path)/2]] /= 2;\\n        \\n        //now update amount of nodes that are visited by bob first (before alice visits them) to 0\\n        \\n        \\n        for(int i = 0; i < (size(path) / 2); i++)a[path[i]] = 0;\\n        \\n        // after that just find the maximum path from root to all leaf nodes using dfs\\n        \\n        return dfs(0,g,a,-1);\\n    }\\n    private:\\n    int dfs(int src, vector<vector<int>>& g, vector<int>& a, int par)\\n    {\\n        int res = INT_MIN;\\n        for(auto &x: g[src])\\n        {\\n            // do not call dfs to its parent\\n            \\n            if(x == par)continue;\\n            \\n            res = max(res,dfs(x,g,a,src));\\n        }\\n        \\n        //if the node is leaf we just return its amount\\n        \\n        if(res == INT_MIN)return a[src];\\n        \\n        // else return total amount of path;\\n        \\n        return res+a[src];\\n    }\\n    bool findPath(int src, vector<vector<int>>& g, vector<int>& path, int bob, int par)\\n    {\\n        if(src == bob)\\n        {\\n            path.push_back(src);return true;\\n        }\\n        \\n        for(auto &x: g[src])\\n        {\\n            // do not call dfs to its parent\\n            \\n            if(x == par)continue;\\n            \\n            if(findPath(x,g,path,bob,src))\\n            {\\n                path.push_back(src);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992253,
                "title": "2-dfs-simple-approach",
                "content": "```\\nint ans=INT_MIN;\\n    int profit=0;\\n    \\n    void dfsToCalculateMaxProfit(int i, vector<vector<int>>& tree, vector<int>& vis,vector<int>& amount)\\n    {\\n        vis[i]=1;\\n        profit+=amount[i];\\n        int trav=0;\\n        for(auto ele:tree[i])\\n        {\\n            if(!vis[ele])\\n            {\\n                trav++;\\n                vis[ele]=1;\\n                dfsToCalculateMaxProfit(ele,tree,vis,amount);\\n                vis[ele]=0;\\n            }\\n        }\\n        if(trav==0) ans=max(ans,profit);  //if trav is 0 means this is the leaf node and we update our ans\\n        profit-=amount[i];\\n    }\\n    \\n    void findParentAndDistance(int i, vector<vector<int>>& tree, unordered_map<int,int>& Parent,unordered_map<int,int>& DistanceFromAlice,int currdis,vector<int>& vis)\\n    {\\n        vis[i]=1;\\n        DistanceFromAlice[i]=currdis;\\n        for(auto ele:tree[i])\\n        {\\n            if(!vis[ele]) {\\n                Parent[ele]=i;\\n                findParentAndDistance(ele,tree,Parent,DistanceFromAlice,currdis+1,vis);\\n            }\\n        }\\n        vis[i]=0;\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        \\n        vector<vector<int>>tree(edges.size()+1);         //construct tree using adjacency list\\n        for(auto edge:edges)                             //construct tree using adjacency list\\n        {                                                //construct tree using adjacency list\\n            tree[edge[0]].push_back(edge[1]);            //construct tree using adjacency list\\n            tree[edge[1]].push_back(edge[0]);            //construct tree using adjacency list\\n        }\\n        \\n        \\n        vector<int>vis(edges.size()+1,0);\\n        unordered_map<int,int>Parent;\\n        unordered_map<int,int>DistanceFromAlice;\\n        Parent[0]=0;\\n        findParentAndDistance(0,tree,Parent,DistanceFromAlice,0,vis);    //Parent,Distance using dfs\\n        \\n        int currNode = bob;\\n        int DisFromBob=0;\\n        while(currNode!=0)       //updating amount of the common path of alice and bob\\n        {\\n            if(DistanceFromAlice[currNode]>DisFromBob)\\n            {\\n                amount[currNode]=0;    //for alice no profit is there because bob will open gate first\\n            }\\n            else if(DistanceFromAlice[currNode]==DisFromBob)\\n            {\\n                amount[currNode]/=2;  //both alice and bob will get 50% amount as they open gate at same time\\n            }\\n            currNode = Parent[currNode];\\n            DisFromBob++;\\n        }\\n        for(int i=0;i<vis.size();i++) vis[i]=0;\\n        dfsToCalculateMaxProfit(0,tree,vis,amount);  //calculating profit for every path from 0 to leaf node\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nint ans=INT_MIN;\\n    int profit=0;\\n    \\n    void dfsToCalculateMaxProfit(int i, vector<vector<int>>& tree, vector<int>& vis,vector<int>& amount)\\n    {\\n        vis[i]=1;\\n        profit+=amount[i];\\n        int trav=0;\\n        for(auto ele:tree[i])\\n        {\\n            if(!vis[ele])\\n            {\\n                trav++;\\n                vis[ele]=1;\\n                dfsToCalculateMaxProfit(ele,tree,vis,amount);\\n                vis[ele]=0;\\n            }\\n        }\\n        if(trav==0) ans=max(ans,profit);  //if trav is 0 means this is the leaf node and we update our ans\\n        profit-=amount[i];\\n    }\\n    \\n    void findParentAndDistance(int i, vector<vector<int>>& tree, unordered_map<int,int>& Parent,unordered_map<int,int>& DistanceFromAlice,int currdis,vector<int>& vis)\\n    {\\n        vis[i]=1;\\n        DistanceFromAlice[i]=currdis;\\n        for(auto ele:tree[i])\\n        {\\n            if(!vis[ele]) {\\n                Parent[ele]=i;\\n                findParentAndDistance(ele,tree,Parent,DistanceFromAlice,currdis+1,vis);\\n            }\\n        }\\n        vis[i]=0;\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        \\n        vector<vector<int>>tree(edges.size()+1);         //construct tree using adjacency list\\n        for(auto edge:edges)                             //construct tree using adjacency list\\n        {                                                //construct tree using adjacency list\\n            tree[edge[0]].push_back(edge[1]);            //construct tree using adjacency list\\n            tree[edge[1]].push_back(edge[0]);            //construct tree using adjacency list\\n        }\\n        \\n        \\n        vector<int>vis(edges.size()+1,0);\\n        unordered_map<int,int>Parent;\\n        unordered_map<int,int>DistanceFromAlice;\\n        Parent[0]=0;\\n        findParentAndDistance(0,tree,Parent,DistanceFromAlice,0,vis);    //Parent,Distance using dfs\\n        \\n        int currNode = bob;\\n        int DisFromBob=0;\\n        while(currNode!=0)       //updating amount of the common path of alice and bob\\n        {\\n            if(DistanceFromAlice[currNode]>DisFromBob)\\n            {\\n                amount[currNode]=0;    //for alice no profit is there because bob will open gate first\\n            }\\n            else if(DistanceFromAlice[currNode]==DisFromBob)\\n            {\\n                amount[currNode]/=2;  //both alice and bob will get 50% amount as they open gate at same time\\n            }\\n            currNode = Parent[currNode];\\n            DisFromBob++;\\n        }\\n        for(int i=0;i<vis.size();i++) vis[i]=0;\\n        dfsToCalculateMaxProfit(0,tree,vis,amount);  //calculating profit for every path from 0 to leaf node\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981399,
                "title": "c-dfs-approach-simple-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>graph;\\n    vector<int>parent;\\n    vector<int>subtree;\\n    vector<int>dist;\\n    vector<int>value;\\n    \\n    // first DFS function will calculate the smallest distance of the current node from the root node.\\n    \\n    void dfs1(int u,int p,int lvl){\\n        parent[u] = p;\\n        dist[u] = lvl;\\n        for(int v:graph[u]){\\n            if(v==p) continue;\\n            dfs1(v,u,lvl+1);\\n        }\\n    }\\n    \\n    // Second DFS function calculates the path with maximum amount from the root node to any of the possible leaf nodes.\\n    \\n    int dfs2(int u,int p){\\n        int maxi = -1e9;\\n        int curr = value[u];\\n        for(int v:graph[u]){\\n            if(v==p) continue;\\n            maxi = max(maxi,dfs2(v,u));\\n        }\\n        if(maxi==-1e9) return curr;\\n        else return curr + maxi;\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        \\n        int n = amount.size();\\n        \\n        graph.resize(n);\\n        parent.resize(n,-1);\\n        subtree.resize(n,0);\\n        value.resize(n,0);\\n        dist.resize(n,0);\\n        \\n        \\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        dfs1(0,-1,0);\\n        \\n        int node = bob;\\n        int bob_dist = 0;\\n        \\n        // Now we need to update the path from the root node to any of the leaf node optimally by cosidering the effect of bob\\'s movement .\\n        \\n        while(node!=0){\\n            \\n            if(dist[node] > bob_dist) amount[node] = 0;\\n            else if(dist[node] == bob_dist) amount[node]/=2;\\n            \\n            node = parent[node];\\n            bob_dist++;\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            value[i] = amount[i];\\n        }\\n        \\n        return dfs2(0,-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>graph;\\n    vector<int>parent;\\n    vector<int>subtree;\\n    vector<int>dist;\\n    vector<int>value;\\n    \\n    // first DFS function will calculate the smallest distance of the current node from the root node.\\n    \\n    void dfs1(int u,int p,int lvl){\\n        parent[u] = p;\\n        dist[u] = lvl;\\n        for(int v:graph[u]){\\n            if(v==p) continue;\\n            dfs1(v,u,lvl+1);\\n        }\\n    }\\n    \\n    // Second DFS function calculates the path with maximum amount from the root node to any of the possible leaf nodes.\\n    \\n    int dfs2(int u,int p){\\n        int maxi = -1e9;\\n        int curr = value[u];\\n        for(int v:graph[u]){\\n            if(v==p) continue;\\n            maxi = max(maxi,dfs2(v,u));\\n        }\\n        if(maxi==-1e9) return curr;\\n        else return curr + maxi;\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        \\n        int n = amount.size();\\n        \\n        graph.resize(n);\\n        parent.resize(n,-1);\\n        subtree.resize(n,0);\\n        value.resize(n,0);\\n        dist.resize(n,0);\\n        \\n        \\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        dfs1(0,-1,0);\\n        \\n        int node = bob;\\n        int bob_dist = 0;\\n        \\n        // Now we need to update the path from the root node to any of the leaf node optimally by cosidering the effect of bob\\'s movement .\\n        \\n        while(node!=0){\\n            \\n            if(dist[node] > bob_dist) amount[node] = 0;\\n            else if(dist[node] == bob_dist) amount[node]/=2;\\n            \\n            node = parent[node];\\n            bob_dist++;\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            value[i] = amount[i];\\n        }\\n        \\n        return dfs2(0,-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950428,
                "title": "easy-c-solution-one-dfs-time-beats-99-42",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> dfs(vector<vector<int>> &adj,vector<int> &amt,int cur,int pre,int curH,int bob,int &high){\\n        int isBob = -1,ans=INT_MIN;\\n        pair<int,int> p;\\n        for(int i=0;i<adj[cur].size();i++){\\n            if(adj[cur][i]!=pre){\\n                p = dfs(adj,amt,adj[cur][i],cur,curH+1,bob,high);\\n                isBob = max(isBob,p.second);\\n                ans = max(ans,p.first);\\n            }\\n        }\\n        if(ans==INT_MIN) ans =0;\\n        if(cur==bob){\\n            high = curH;\\n            isBob = (curH+1)/2;\\n        }\\n        if(isBob==-1) return {ans+amt[cur],-1};\\n        if(isBob==0){\\n            ans += high%2==0 ? (amt[cur]/2) : amt[cur];\\n            return {ans,-1};\\n        }\\n        return {ans,isBob-1};\\n    }\\n    int mostProfitablePath(vector<vector<int>>& ed, int bob, vector<int>& amount) {\\n        int n = ed.size()+1,height=0;\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n-1;i++){\\n            adj[ed[i][0]].push_back(ed[i][1]);\\n            adj[ed[i][1]].push_back(ed[i][0]);\\n        }\\n        return dfs(adj,amount,0,-1,0,bob,height).first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> dfs(vector<vector<int>> &adj,vector<int> &amt,int cur,int pre,int curH,int bob,int &high){\\n        int isBob = -1,ans=INT_MIN;\\n        pair<int,int> p;\\n        for(int i=0;i<adj[cur].size();i++){\\n            if(adj[cur][i]!=pre){\\n                p = dfs(adj,amt,adj[cur][i],cur,curH+1,bob,high);\\n                isBob = max(isBob,p.second);\\n                ans = max(ans,p.first);\\n            }\\n        }\\n        if(ans==INT_MIN) ans =0;\\n        if(cur==bob){\\n            high = curH;\\n            isBob = (curH+1)/2;\\n        }\\n        if(isBob==-1) return {ans+amt[cur],-1};\\n        if(isBob==0){\\n            ans += high%2==0 ? (amt[cur]/2) : amt[cur];\\n            return {ans,-1};\\n        }\\n        return {ans,isBob-1};\\n    }\\n    int mostProfitablePath(vector<vector<int>>& ed, int bob, vector<int>& amount) {\\n        int n = ed.size()+1,height=0;\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n-1;i++){\\n            adj[ed[i][0]].push_back(ed[i][1]);\\n            adj[ed[i][1]].push_back(ed[i][0]);\\n        }\\n        return dfs(adj,amount,0,-1,0,bob,height).first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869248,
                "title": "c-2-dfs-clearcut-explanation-simple-clean-code-faster-than-98-10",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE :)**\\nSo bob has to go from from the node bob is currently at, to node 0 and bob has only a single path.. So at first make gate vector to store the time at when bob came to that node.. Now Alice will start from node 0. From node 0 run a DFS to every leaf node. And during the DFS path if any node is previously visited by bob or not, we will get this info from gate vector.\\n\\nMeans if gate[node] is strictly greater than the the time alice is currently at, that means either bob didn\\'t visit that node or bob visited that node after alice\\'s visit so full amount[node] should be added. If gate[node] is equal to the time alice is currently at, that\\'s means bob and alice visit that node at same time so amount[node]/2 will be added and if gate[node] is strictly smaller than the time alice is currently at, that\\'s means bob previously visited that node and gate is opened so 0 amount will be added.. and at the end of every path ans will be the maximum amount that can be achieved.\\n\\nFull Code:\\n```\\nclass Solution {\\nprivate:\\n    bool findBobsPath(int node, int time, vector<int> *adj, vector<int> &vis, vector<int> &gate){\\n        gate[node]=time;\\n        vis[node]=1;\\n        if(node==0) return true;\\n        \\n        for(int i=0; i<adj[node].size(); i++){\\n            int curNode=adj[node][i];\\n            if(!vis[curNode]){\\n                if(!findBobsPath(curNode,time+1,adj,vis,gate)){\\n                    gate[curNode]=INT_MAX;\\n                }else{\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void findAlicesPath(int node, int time, vector<int> *adj, vector<int> &vis, vector<int> &gate, vector<int> &amount, int tempAns, int &ans){\\n        vis[node]=1;\\n        bool ok=false;\\n        if(gate[node]==time){\\n            tempAns+=amount[node]/2;\\n        }else if(gate[node]>time){\\n            tempAns+=amount[node];\\n        }\\n        \\n        for(int i=0; i<adj[node].size(); i++){\\n            int curNode=adj[node][i];\\n            if(!vis[curNode]){\\n                ok=true;\\n                findAlicesPath(curNode,time+1,adj,vis,gate,amount,tempAns,ans);\\n            }\\n        }\\n        \\n        if(!ok) ans=max(ans,tempAns);\\n    }\\n    \\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int> gate(n,INT_MAX),vis(n,0);\\n        findBobsPath(bob,1,adj,vis,gate);\\n        \\n        for(int i=0; i<n; i++) vis[i]=0;        \\n        int ans=INT_MIN;\\n        findAlicesPath(0,1,adj,vis,gate,amount,0,ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool findBobsPath(int node, int time, vector<int> *adj, vector<int> &vis, vector<int> &gate){\\n        gate[node]=time;\\n        vis[node]=1;\\n        if(node==0) return true;\\n        \\n        for(int i=0; i<adj[node].size(); i++){\\n            int curNode=adj[node][i];\\n            if(!vis[curNode]){\\n                if(!findBobsPath(curNode,time+1,adj,vis,gate)){\\n                    gate[curNode]=INT_MAX;\\n                }else{\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void findAlicesPath(int node, int time, vector<int> *adj, vector<int> &vis, vector<int> &gate, vector<int> &amount, int tempAns, int &ans){\\n        vis[node]=1;\\n        bool ok=false;\\n        if(gate[node]==time){\\n            tempAns+=amount[node]/2;\\n        }else if(gate[node]>time){\\n            tempAns+=amount[node];\\n        }\\n        \\n        for(int i=0; i<adj[node].size(); i++){\\n            int curNode=adj[node][i];\\n            if(!vis[curNode]){\\n                ok=true;\\n                findAlicesPath(curNode,time+1,adj,vis,gate,amount,tempAns,ans);\\n            }\\n        }\\n        \\n        if(!ok) ans=max(ans,tempAns);\\n    }\\n    \\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int> gate(n,INT_MAX),vis(n,0);\\n        findBobsPath(bob,1,adj,vis,gate);\\n        \\n        for(int i=0; i<n; i++) vis[i]=0;        \\n        int ans=INT_MIN;\\n        findAlicesPath(0,1,adj,vis,gate,amount,0,ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823092,
                "title": "easy-explained-c-dfs-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void AliceDfs(int node,int par,int dis,vector<int> &parent,\\n                  vector<int> &distance, vector<int> adj[])\\n    {\\n        parent[node]=par;\\n        distance[node]=dis;\\n        for(auto it : adj[node])\\n        {\\n            if(it!=par) AliceDfs(it,node,dis+1,parent,distance,adj);\\n        }\\n    }\\n    void BobDfs(int node,int dis,vector<int> &amount,\\n                  vector<int> &distance,vector<int> &parent, vector<int> adj[])\\n    {\\n        if(dis<distance[node]) amount[node]=0;\\n        if(dis==distance[node]) amount[node] /=2;\\n        if(node==0) return ;\\n        BobDfs(parent[node],dis+1,amount,distance,parent,adj);\\n    }\\n    int CollectAmount(int node,vector<int> &amount,vector<int> &visited,\\n                      vector<int> adj[])\\n    {\\n        visited[node]=1;\\n        int res = amount[node];\\n        int maxi=INT_MIN;\\n        for(auto it : adj[node])\\n        {\\n            if(visited[it]==0)\\n            maxi=max(maxi,CollectAmount(it,amount,visited,adj)); \\n            \\n        }\\n        if(maxi==INT_MIN) return res;\\n        return res + maxi;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) \\n    {\\n        int n = edges.size()+1;\\n        vector<int> adj[n];\\n        vector<int> parent(n,0);\\n        vector<int> visited(n,0);\\n        vector<int> distance(n,0);\\n        for(auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        AliceDfs(0,0,0,parent,distance,adj);\\n        BobDfs(bob,0,amount,distance,parent,adj);\\n        return CollectAmount(0,amount,visited,adj);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void AliceDfs(int node,int par,int dis,vector<int> &parent,\\n                  vector<int> &distance, vector<int> adj[])\\n    {\\n        parent[node]=par;\\n        distance[node]=dis;\\n        for(auto it : adj[node])\\n        {\\n            if(it!=par) AliceDfs(it,node,dis+1,parent,distance,adj);\\n        }\\n    }\\n    void BobDfs(int node,int dis,vector<int> &amount,\\n                  vector<int> &distance,vector<int> &parent, vector<int> adj[])\\n    {\\n        if(dis<distance[node]) amount[node]=0;\\n        if(dis==distance[node]) amount[node] /=2;\\n        if(node==0) return ;\\n        BobDfs(parent[node],dis+1,amount,distance,parent,adj);\\n    }\\n    int CollectAmount(int node,vector<int> &amount,vector<int> &visited,\\n                      vector<int> adj[])\\n    {\\n        visited[node]=1;\\n        int res = amount[node];\\n        int maxi=INT_MIN;\\n        for(auto it : adj[node])\\n        {\\n            if(visited[it]==0)\\n            maxi=max(maxi,CollectAmount(it,amount,visited,adj)); \\n            \\n        }\\n        if(maxi==INT_MIN) return res;\\n        return res + maxi;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) \\n    {\\n        int n = edges.size()+1;\\n        vector<int> adj[n];\\n        vector<int> parent(n,0);\\n        vector<int> visited(n,0);\\n        vector<int> distance(n,0);\\n        for(auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        AliceDfs(0,0,0,parent,distance,adj);\\n        BobDfs(bob,0,amount,distance,parent,adj);\\n        return CollectAmount(0,amount,visited,adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811225,
                "title": "python-3-dfs-backtracking-with-explanation",
                "content": "Since the undirected tree has $$n$$ nodes and $$n-1$$ edges, there is only one path from bob to root $$0$$. The path from bob to root 0 as well as the time Bob reaches each node on the path is used to compute the reward (price) Alice gets at each node. \\n\\nWe will first use a DFS backtracking to determine Bob\\'s path. The second backtracking is then implemented to compute the incomes Alice has when she travels to each leaf node.\\n\\nInline explanation is provided in the code. The code looks long but the two backtracking functions are quite similar, so the code is actually easy to understand.\\n\\nTime complexity: $$O(n)$$.\\n\\n# Python\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = len(amount) # number of nodes\\n        graph = [set() for _ in range(n)] # adjacency list presentation of the tree\\n        for i,j in edges:\\n            graph[i].add(j)\\n            graph[j].add(i)\\n        bobpath = dict() # use hashmap to record nodes on the path from bob to root 0 \\n                         # as well as time: node = key, time = value\\n        self.stop = False # True when Bob reaches root 0, this helps stop the DFS\\n        visited = [False]*n # True if node is visited, initialized as False for all nodes\\n        def backtrackbob(node,time): # the first backtracking, with time at each node\\n            bobpath[node] = time # add node:time to the hashmap\\n            visited[node] = True # mark node as visited\\n            if node==0: # root 0 is reached\\n                self.stop = True # this helps stop the DFS\\n                return None\\n            count = 0 # this helps determine if a node is leaf node\\n            for nei in graph[node]: \\n                if not visited[nei]:\\n                    count += 1\\n                    break\\n            if count==0: # node is leaf node if all neighbors are already visited\\n                del bobpath[node] # delete leaf node from hashmap before retreating from leaf node\\n                return None\\n            for nei in graph[node]: # explore unvisited neighbors of node\\n                if self.stop: return None # if root 0 is already reached, stop the DFS\\n                if not visited[nei]:\\n                    backtrackbob(nei,time+1)\\n            if not self.stop: # if root 0 is reached, keep node in the hashmap when backtracking\\n                del bobpath[node] # otherwise, delete node before retreating\\n            return None\\n\\n        backtrackbob(bob,0) # execute the first backtracking, time at bob is initialized = 0\\n\\n        self.ans = float(-inf) # answer of the problem\\n        self.income = 0 # income of Alice when travelling to leaf nodes, initialized = 0\\n        visited = [False]*n # True if node is visited, initialized as False for all nodes\\n        def backtrackalice(node,time): # second backtracking, with time at each node\\n            visited[node] = True\\n            if node in bobpath: # if the node Alice visits is on Bob\\'s path, there are 3 cases\\n                if time == bobpath[node]: # Alice and Bob reach the node at the same time\\n                    reward = amount[node]//2\\n                elif time<bobpath[node]: # Alice reachs node before Bob\\n                    reward = amount[node]\\n                else: # Alice reachs node after Bob\\n                    reward = 0\\n            else: # if the node Alice visits is not on Bob\\'s path\\n                reward = amount[node]\\n            self.income += reward # add the reward (price) at this node to the income\\n            count = 0 # this helps determine if a node is leaf node\\n            for nei in graph[node]:\\n                if not visited[nei]:\\n                    count += 1\\n                    break\\n            if count==0: # node is leaf node if all neighbors are already visited\\n                self.ans = max(self.ans,self.income) # update the answer\\n                self.income -= reward # remove the reward (price) at leaf node before backtracking\\n                return None\\n            for nei in graph[node]: # explore unvisited neighbors of node\\n                if not visited[nei]:\\n                    backtrackalice(nei,time+1)\\n            self.income -= reward # remove the reward (price) at this node before retreating\\n            return None\\n\\n        backtrackalice(0,0) # execute the second backtracking, time at root 0 is initialized = 0\\n\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = len(amount) # number of nodes\\n        graph = [set() for _ in range(n)] # adjacency list presentation of the tree\\n        for i,j in edges:\\n            graph[i].add(j)\\n            graph[j].add(i)\\n        bobpath = dict() # use hashmap to record nodes on the path from bob to root 0 \\n                         # as well as time: node = key, time = value\\n        self.stop = False # True when Bob reaches root 0, this helps stop the DFS\\n        visited = [False]*n # True if node is visited, initialized as False for all nodes\\n        def backtrackbob(node,time): # the first backtracking, with time at each node\\n            bobpath[node] = time # add node:time to the hashmap\\n            visited[node] = True # mark node as visited\\n            if node==0: # root 0 is reached\\n                self.stop = True # this helps stop the DFS\\n                return None\\n            count = 0 # this helps determine if a node is leaf node\\n            for nei in graph[node]: \\n                if not visited[nei]:\\n                    count += 1\\n                    break\\n            if count==0: # node is leaf node if all neighbors are already visited\\n                del bobpath[node] # delete leaf node from hashmap before retreating from leaf node\\n                return None\\n            for nei in graph[node]: # explore unvisited neighbors of node\\n                if self.stop: return None # if root 0 is already reached, stop the DFS\\n                if not visited[nei]:\\n                    backtrackbob(nei,time+1)\\n            if not self.stop: # if root 0 is reached, keep node in the hashmap when backtracking\\n                del bobpath[node] # otherwise, delete node before retreating\\n            return None\\n\\n        backtrackbob(bob,0) # execute the first backtracking, time at bob is initialized = 0\\n\\n        self.ans = float(-inf) # answer of the problem\\n        self.income = 0 # income of Alice when travelling to leaf nodes, initialized = 0\\n        visited = [False]*n # True if node is visited, initialized as False for all nodes\\n        def backtrackalice(node,time): # second backtracking, with time at each node\\n            visited[node] = True\\n            if node in bobpath: # if the node Alice visits is on Bob\\'s path, there are 3 cases\\n                if time == bobpath[node]: # Alice and Bob reach the node at the same time\\n                    reward = amount[node]//2\\n                elif time<bobpath[node]: # Alice reachs node before Bob\\n                    reward = amount[node]\\n                else: # Alice reachs node after Bob\\n                    reward = 0\\n            else: # if the node Alice visits is not on Bob\\'s path\\n                reward = amount[node]\\n            self.income += reward # add the reward (price) at this node to the income\\n            count = 0 # this helps determine if a node is leaf node\\n            for nei in graph[node]:\\n                if not visited[nei]:\\n                    count += 1\\n                    break\\n            if count==0: # node is leaf node if all neighbors are already visited\\n                self.ans = max(self.ans,self.income) # update the answer\\n                self.income -= reward # remove the reward (price) at leaf node before backtracking\\n                return None\\n            for nei in graph[node]: # explore unvisited neighbors of node\\n                if not visited[nei]:\\n                    backtrackalice(nei,time+1)\\n            self.income -= reward # remove the reward (price) at this node before retreating\\n            return None\\n\\n        backtrackalice(0,0) # execute the second backtracking, time at root 0 is initialized = 0\\n\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810796,
                "title": "most-profitable-path-in-a-tree-c-dfs-with-explaination",
                "content": "**Approach:**\\namount has the amount which has to be added to total \\nwe calculate distance of every node from 0 doing dfs and we make vector parent to get parent of every node so that we can use that for calculation of bobs distance and updating the amount and also there are multiple paths so we donot use the vector visited(n) of size n to keep track of visited nodes \\ndistance vector stores the distance of every node from 0 i.e distance of alice from every node \\nthe path of bob is fixed he moves from his node to 0 so the nodes close to bob will be covered by bob definately  so we make amount  = 0 at that position but the nodes which are equidistant from both of them then we divide the amount / 2 where bobDistance == distance[currBobPosition].\\nwe do another dfs to calcualte the final maximum profit by doing dfs and visiting every node and adding the updated amount after bobs goes to 0\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    //calculates the maximum profit path for alice \\n    int calProfit(vector<vector<int>>& adj,int startVertex,int parent,vector<int> &amount) {\\n        //get the current profit irrespective of whether positive or negetive we need to add it to check for max profit path\\n        int currProfit = amount[startVertex];\\n        int ans = INT_MIN;\\n        //do dfs and ans is the maximum profit after doing dfs \\n        for(auto &nbr : adj[startVertex]) {\\n            //if the neighbour is the current node itself or the parent node then we skip rest since it will create self loop\\n            if(nbr == startVertex || nbr == parent) continue;\\n            ans = max(ans , calProfit(adj,nbr,startVertex,amount));\\n        }\\n        // base case if ans is INT_MIN means we have reached the leaf node then we return the profit amount at that node \\n        if(ans == INT_MIN) return currProfit;\\n        //else we add the current profit to the ans and return it \\n        else return currProfit + ans;\\n    }\\n    //do dfs and update parent of everynode along with distance \\n    void dfs(int startVertex , int p, int d ,vector<vector<int>> &adj,vector<int> &distance , vector<int> &parent) {\\n        //distance is minimum of currentdistance and the newdistance(distance if we follow different path)\\n        distance[startVertex] = min(distance[startVertex] ,d);\\n        //initially the parent is 0  and startvertex is 0 so parent of 0 is 0 . In recursive call it gets updated \\n        parent[startVertex] = p;\\n        for(auto &nbr : adj[startVertex]) {\\n            //check for valid neighbour to avoid self loop \\n            if(nbr == startVertex || nbr == p) continue;\\n            //if valid then increase distance visit that neighbor the current node becomes parent and ne startVertex is now neighbor \\n            dfs(nbr,startVertex,d+1,adj,distance,parent);\\n        }\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        vector<vector<int>> adj(n);\\n        //create the adjacency list \\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        //set the distance to max for every node since we want minimum distance for every node for alice in distance vector\\n        vector<int> distance(n,INT_MAX);\\n        //parent stores the parent so that we can track path to 0 for bob \\n        vector<int> parent(n);\\n        dfs(0,0,0,adj,distance,parent);\\n        //initialdistance of bob is 0 ofc he is at his starting place \\n        int bobDistance = 0;\\n        //set the current bobpostion to bob \\n        int currBobPosition = bob;\\n        //we search untill currBobPosition is not 0 means bob has not reached 0 \\n        while(currBobPosition != 0) {\\n            //if the distance of node from alice is more than the distance from bob and it is in path to 0 then bob will definately cover it \\n            if(bobDistance < distance[currBobPosition]) {\\n                //so we make the amount of profit which alice can make from this node to 0 \\n                amount[currBobPosition] = 0;\\n            }\\n            //if the distance of node from alice and bob are same and in path of bob from his node to 0 then they both can cover this node \\n            else if(bobDistance == distance[currBobPosition]) {\\n                //so the amount which alice can get from this node if he visits is amount[currBobPosition] /2 \\n                amount[currBobPosition] = amount[currBobPosition]/2;\\n            } \\n            //update the bobs postion to next position \\n            currBobPosition = parent[currBobPosition];\\n            //increase the distance of bob as we move to the next node \\n            bobDistance++;\\n        }\\n        //ans stores the ans \\n        int ans = calProfit(adj,0,0,amount);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //calculates the maximum profit path for alice \\n    int calProfit(vector<vector<int>>& adj,int startVertex,int parent,vector<int> &amount) {\\n        //get the current profit irrespective of whether positive or negetive we need to add it to check for max profit path\\n        int currProfit = amount[startVertex];\\n        int ans = INT_MIN;\\n        //do dfs and ans is the maximum profit after doing dfs \\n        for(auto &nbr : adj[startVertex]) {\\n            //if the neighbour is the current node itself or the parent node then we skip rest since it will create self loop\\n            if(nbr == startVertex || nbr == parent) continue;\\n            ans = max(ans , calProfit(adj,nbr,startVertex,amount));\\n        }\\n        // base case if ans is INT_MIN means we have reached the leaf node then we return the profit amount at that node \\n        if(ans == INT_MIN) return currProfit;\\n        //else we add the current profit to the ans and return it \\n        else return currProfit + ans;\\n    }\\n    //do dfs and update parent of everynode along with distance \\n    void dfs(int startVertex , int p, int d ,vector<vector<int>> &adj,vector<int> &distance , vector<int> &parent) {\\n        //distance is minimum of currentdistance and the newdistance(distance if we follow different path)\\n        distance[startVertex] = min(distance[startVertex] ,d);\\n        //initially the parent is 0  and startvertex is 0 so parent of 0 is 0 . In recursive call it gets updated \\n        parent[startVertex] = p;\\n        for(auto &nbr : adj[startVertex]) {\\n            //check for valid neighbour to avoid self loop \\n            if(nbr == startVertex || nbr == p) continue;\\n            //if valid then increase distance visit that neighbor the current node becomes parent and ne startVertex is now neighbor \\n            dfs(nbr,startVertex,d+1,adj,distance,parent);\\n        }\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        vector<vector<int>> adj(n);\\n        //create the adjacency list \\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        //set the distance to max for every node since we want minimum distance for every node for alice in distance vector\\n        vector<int> distance(n,INT_MAX);\\n        //parent stores the parent so that we can track path to 0 for bob \\n        vector<int> parent(n);\\n        dfs(0,0,0,adj,distance,parent);\\n        //initialdistance of bob is 0 ofc he is at his starting place \\n        int bobDistance = 0;\\n        //set the current bobpostion to bob \\n        int currBobPosition = bob;\\n        //we search untill currBobPosition is not 0 means bob has not reached 0 \\n        while(currBobPosition != 0) {\\n            //if the distance of node from alice is more than the distance from bob and it is in path to 0 then bob will definately cover it \\n            if(bobDistance < distance[currBobPosition]) {\\n                //so we make the amount of profit which alice can make from this node to 0 \\n                amount[currBobPosition] = 0;\\n            }\\n            //if the distance of node from alice and bob are same and in path of bob from his node to 0 then they both can cover this node \\n            else if(bobDistance == distance[currBobPosition]) {\\n                //so the amount which alice can get from this node if he visits is amount[currBobPosition] /2 \\n                amount[currBobPosition] = amount[currBobPosition]/2;\\n            } \\n            //update the bobs postion to next position \\n            currBobPosition = parent[currBobPosition];\\n            //increase the distance of bob as we move to the next node \\n            bobDistance++;\\n        }\\n        //ans stores the ans \\n        int ans = calProfit(adj,0,0,amount);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809977,
                "title": "bfs-update-and-bfs",
                "content": "```cpp\\nint n = amount.size();\\nvector<vector<int>> adj(n);\\n\\nfor (auto& e : edges)\\n{\\n\\tadj[e[0]].push_back(e[1]);\\n\\tadj[e[1]].push_back(e[0]);\\n}\\n\\n// construct path from root to leaves\\nvector<int> dst(n);\\nvector<int> par(n);\\nqueue<int> que;\\nque.push(0);\\n\\npar[0] = -1;\\ndst[0] = 0;\\n\\nwhile (que.size())\\n{\\n\\tint u = que.front();\\n\\tque.pop();\\n\\n\\tfor (int v : adj[u])\\n\\t{\\n\\t\\tif (v == par[u])\\n\\t\\t\\tcontinue;\\n\\n\\t\\tpar[v] = u;\\n\\t\\tdst[v] = dst[u] + 1;\\n\\t\\tque.push(v);\\n\\t}\\n}\\n\\n// travel reverse path from bob to root\\nint ptr = bob;\\nint d = 0;\\n\\nwhile (ptr)\\n{\\n\\tif (dst[ptr] > d)\\n\\t\\tamount[ptr] = 0;\\n\\telse if (dst[ptr] == d)\\n\\t\\tamount[ptr] /= 2;\\n\\t\\n\\tptr = par[ptr];\\n\\t++ d;\\n}\\n\\n// a final bfs to find the max profit.\\nint ret = INT_MIN;\\nque.push(0);\\n\\nwhile (que.size())\\n{\\n\\tint u = que.front();\\n\\tque.pop();\\n\\tint s = que.size();\\n\\t\\n\\tfor (int v : adj[u])\\n\\t{\\n\\t\\t// visited\\n\\t\\tif (amount[v] == INT_MIN)\\n\\t\\t\\tcontinue;\\n\\t\\t\\n\\t\\t// accumulate profit to child\\n\\t\\tamount[v] += amount[u];\\n\\t\\tque.push(v);\\n\\t}\\n\\t\\n\\t// have no child.\\n\\tif (s == que.size())\\n\\t\\tret = max(ret, amount[u]);\\n\\t\\n\\t// mark as visited\\n\\tamount[u] = INT_MIN;\\n}\\n\\nreturn ret;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nint n = amount.size();\\nvector<vector<int>> adj(n);\\n\\nfor (auto& e : edges)\\n{\\n\\tadj[e[0]].push_back(e[1]);\\n\\tadj[e[1]].push_back(e[0]);\\n}\\n\\n// construct path from root to leaves\\nvector<int> dst(n);\\nvector<int> par(n);\\nqueue<int> que;\\nque.push(0);\\n\\npar[0] = -1;\\ndst[0] = 0;\\n\\nwhile (que.size())\\n{\\n\\tint u = que.front();\\n\\tque.pop();\\n\\n\\tfor (int v : adj[u])\\n\\t{\\n\\t\\tif (v == par[u])\\n\\t\\t\\tcontinue;\\n\\n\\t\\tpar[v] = u;\\n\\t\\tdst[v] = dst[u] + 1;\\n\\t\\tque.push(v);\\n\\t}\\n}\\n\\n// travel reverse path from bob to root\\nint ptr = bob;\\nint d = 0;\\n\\nwhile (ptr)\\n{\\n\\tif (dst[ptr] > d)\\n\\t\\tamount[ptr] = 0;\\n\\telse if (dst[ptr] == d)\\n\\t\\tamount[ptr] /= 2;\\n\\t\\n\\tptr = par[ptr];\\n\\t++ d;\\n}\\n\\n// a final bfs to find the max profit.\\nint ret = INT_MIN;\\nque.push(0);\\n\\nwhile (que.size())\\n{\\n\\tint u = que.front();\\n\\tque.pop();\\n\\tint s = que.size();\\n\\t\\n\\tfor (int v : adj[u])\\n\\t{\\n\\t\\t// visited\\n\\t\\tif (amount[v] == INT_MIN)\\n\\t\\t\\tcontinue;\\n\\t\\t\\n\\t\\t// accumulate profit to child\\n\\t\\tamount[v] += amount[u];\\n\\t\\tque.push(v);\\n\\t}\\n\\t\\n\\t// have no child.\\n\\tif (s == que.size())\\n\\t\\tret = max(ret, amount[u]);\\n\\t\\n\\t// mark as visited\\n\\tamount[u] = INT_MIN;\\n}\\n\\nreturn ret;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808263,
                "title": "python-dfs-iterative",
                "content": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        #creating adjacency list\\n        adj={}\\n        l=len(amount)\\n        for a,b in edges:\\n            if a not in adj:\\n                adj[a]=[]\\n            adj[a].append(b)\\n            if b not in adj:\\n                adj[b]=[]\\n            adj[b].append(a)\\n        #print(adj)\\n        \\n        #finding parent and distance from root for each node\\n        par={}\\n        dis={}\\n        \\n        stack=[(0,0,0)]\\n        while stack:\\n            u,p,d=stack.pop()\\n            par[u]=p\\n            dis[u]=d\\n            for i in adj[u]:\\n                #print(i,u)\\n                if i==p:\\n                    continue\\n                stack.append((i,u,d+1))\\n        #print(par,dis)\\n        \\n        #updating the amounts based on bob\\'s position\\n        cur=bob\\n        bobdis=0\\n        while cur:\\n            if dis[cur]>bobdis:\\n                amount[cur]=0\\n            if dis[cur]==bobdis:\\n                amount[cur]//=2\\n            cur=par[cur]\\n            bobdis+=1\\n        #print(amount)\\n        \\n        stack=[(0,0,amount[0])]\\n        #profit=amount[0]\\n        \\n        #return profit\\n        #finding leaf nodes and taking max from them\\n        #leaf has only one value in its adjacency list except the root\\n        leaf=set()\\n        for k,v in adj.items():\\n            if len(v)==1 and k:\\n                leaf.add(k)\\n        #print(leaf)\\n        \\n        profit=-100000\\n        \\n        while stack:\\n            n,p,sm=stack.pop()\\n            #profit=max(profit,sm)\\n            if n in leaf:\\n                profit=max(profit,sm)\\n                \\n            for i in adj[n]:\\n                if i==p:\\n                    continue\\n                stack.append((i,n,sm+amount[i]))\\n        \\n        return profit\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        #creating adjacency list\\n        adj={}\\n        l=len(amount)\\n        for a,b in edges:\\n            if a not in adj:\\n                adj[a]=[]\\n            adj[a].append(b)\\n            if b not in adj:\\n                adj[b]=[]\\n            adj[b].append(a)\\n        #print(adj)\\n        \\n        #finding parent and distance from root for each node\\n        par={}\\n        dis={}\\n        \\n        stack=[(0,0,0)]\\n        while stack:\\n            u,p,d=stack.pop()\\n            par[u]=p\\n            dis[u]=d\\n            for i in adj[u]:\\n                #print(i,u)\\n                if i==p:\\n                    continue\\n                stack.append((i,u,d+1))\\n        #print(par,dis)\\n        \\n        #updating the amounts based on bob\\'s position\\n        cur=bob\\n        bobdis=0\\n        while cur:\\n            if dis[cur]>bobdis:\\n                amount[cur]=0\\n            if dis[cur]==bobdis:\\n                amount[cur]//=2\\n            cur=par[cur]\\n            bobdis+=1\\n        #print(amount)\\n        \\n        stack=[(0,0,amount[0])]\\n        #profit=amount[0]\\n        \\n        #return profit\\n        #finding leaf nodes and taking max from them\\n        #leaf has only one value in its adjacency list except the root\\n        leaf=set()\\n        for k,v in adj.items():\\n            if len(v)==1 and k:\\n                leaf.add(k)\\n        #print(leaf)\\n        \\n        profit=-100000\\n        \\n        while stack:\\n            n,p,sm=stack.pop()\\n            #profit=max(profit,sm)\\n            if n in leaf:\\n                profit=max(profit,sm)\\n                \\n            for i in adj[n]:\\n                if i==p:\\n                    continue\\n                stack.append((i,n,sm+amount[i]))\\n        \\n        return profit\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807815,
                "title": "python-3-top-down-dfs-and-bottom-up-bfs",
                "content": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        \\n        g = defaultdict(set)\\n        par = {}\\n        for a, b in edges:\\n            g[a].add(b)\\n            g[b].add(a)\\n\\t\\t\\n\\t\\t# build parent graph and traverse Bob upwards towrads root\\n        q = [0]\\n        while q:\\n            new_q = []\\n            for x in q:\\n                for nei in g[x]:\\n                    if nei == par.get(x, -1): continue\\n                    par[nei] = x\\n                    new_q.append(nei)\\n            q = new_q\\n    \\n        bob_path = [bob]\\n        while bob_path[-1] != 0:\\n            bob_path.append(par[bob_path[-1]])\\n        \\n        \\n        # Nodes reached by bob at time t\\n        bob_path = {x: i for i, x in enumerate(bob_path)}\\n        \\n\\t\\t# top down DFS for Alice from root\\n        @cache\\n        def dp(i, par, cur):\\n            \\n            bob_t = bob_path.get(cur, float(\\'inf\\'))\\n            cur_amount = amount[cur]\\n\\t\\t\\t# reach the node at the same time as Bob\\n            if i == bob_t:\\n                cur_amount //= 2\\n\\t\\t\\t# nodes already reached by Bob earlier\\n            elif i > bob_t:\\n                cur_amount = 0\\n            \\n\\t\\t\\t# reach leaf nodes\\n            nei = [x for x in g[cur] if x != par]\\n            if not nei:                \\n                return cur_amount\\n            \\n            ans = float(\\'-inf\\')\\n            for x in nei:\\n                ans = max(ans, cur_amount + dp(i+1, cur, x))\\n            return ans\\n                \\n            \\n        return dp(0, None, 0)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        \\n        g = defaultdict(set)\\n        par = {}",
                "codeTag": "Java"
            },
            {
                "id": 2807546,
                "title": "dfs-c",
                "content": "class Solution {\\npublic:\\n    vector<int>r;\\n    int n=100002;\\n    void dfs1(int i,vector<int>v[],vector<int>v1[],vector<int>&vis)\\n    {\\n        vis[i]=1;\\n        for(auto j:v[i])\\n        {\\n            if(vis[j]==0)\\n            {\\n                v1[i].push_back(j);\\n            dfs1(j,v,v1,vis);\\n            }\\n        }\\n    }\\n    void dfs2(int i,int bob,vector<int>&amount,vector<int>v1[],bool &f,int c)\\n    {\\n        c++;\\n        if(i==bob)\\n        {\\n            f=true;\\n            n=c;\\n            return;\\n        }\\n        for(auto j:v1[i])\\n        {\\n            dfs2(j,bob,amount,v1,f,c);\\n            if(n%2==1&&c==(n/2+1))\\n                amount[i]=amount[i]/2;\\n            else if(c>(n/2))\\n                amount[i]=0;\\n            if(f==true)\\n                break;\\n        }\\n    }\\n    int dfs3(int bob,vector<int>&amount,vector<int>v1[])\\n    {\\n        int s=0;\\n        int ans=INT_MIN;\\n        for(auto j:v1[bob])\\n        {\\n            s=amount[bob]+dfs3(j,amount,v1);\\n            ans=max(s,ans);\\n        }\\n        if(v1[bob].size()==0)\\n            ans=amount[bob];\\n        return ans;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n         vector<int>v[amount.size()];\\n        vector<int>v1[amount.size()];\\n        vector<int>vis(amount.size());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            v[edges[i][0]].push_back(edges[i][1]);\\n            v[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs1(0,v,v1,vis);\\n        bool f=false;\\n        dfs2(0,bob,amount,v1,f,0);\\n       amount[bob]=0;\\n        int ans=dfs3(0,amount,v1);\\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int>r;\\n    int n=100002;\\n    void dfs1(int i,vector<int>v[],vector<int>v1[],vector<int>&vis)\\n    {\\n        vis[i]=1;\\n        for(auto j:v[i])\\n        {\\n            if(vis[j]==0)\\n            {\\n                v1[i].push_back(j);\\n            dfs1(j,v,v1,vis);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2807359,
                "title": "python-3-bob-modifies-the-tree-and-alice-traverses-it",
                "content": "First, from the given graph, construct a tree with parent and children specified for each node. Record the leave nodes for Alice to traverse at the end.\\n\\nThen let bob walk toward the root to get his path. Bob modifies first half of the nodes\\' amount on his way to the root because these nodes are the gates he arrives ahead of Alice (or at the same time).\\n\\nThen the tree is ready for Alice to pick her max profit. She goes leaves to root, use cache, otherwise TLE.\\n\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        n = len(graph)\\n        pars = [None] * n\\n        chd = [0] * n\\n        \\n        leaves = []\\n        stk = deque([0])\\n        while stk:\\n            cur = stk.popleft()\\n            par = pars[cur]\\n            for nxt in graph[cur]:\\n                if nxt != par:\\n                    pars[nxt] = cur\\n                    chd[cur] += 1\\n                    stk.append(nxt)\\n            if not chd[cur]:\\n                leaves.append(cur)\\n        \\n        cur = bob\\n        path = []\\n        while True:\\n            path.append(cur)\\n            if pars[cur] == None:\\n                break\\n            cur = pars[cur]\\n            \\n        m = len(path)\\n        for i in range(m // 2):\\n            amount[path[i]] = 0\\n        if m & 1:\\n            amount[path[m // 2]] //= 2\\n        \\n        @cache\\n        def dp(cur):\\n            res = amount[cur]\\n            par = pars[cur]\\n            if par == None:\\n                return res\\n            return res + dp(par)\\n        \\n        return max(dp(x) for x in leaves)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        n = len(graph)\\n        pars = [None] * n\\n        chd = [0] * n\\n        \\n        leaves = []\\n        stk = deque([0])\\n        while stk:\\n            cur = stk.popleft()\\n            par = pars[cur]\\n            for nxt in graph[cur]:\\n                if nxt != par:\\n                    pars[nxt] = cur\\n                    chd[cur] += 1\\n                    stk.append(nxt)\\n            if not chd[cur]:\\n                leaves.append(cur)\\n        \\n        cur = bob\\n        path = []\\n        while True:\\n            path.append(cur)\\n            if pars[cur] == None:\\n                break\\n            cur = pars[cur]\\n            \\n        m = len(path)\\n        for i in range(m // 2):\\n            amount[path[i]] = 0\\n        if m & 1:\\n            amount[path[m // 2]] //= 2\\n        \\n        @cache\\n        def dp(cur):\\n            res = amount[cur]\\n            par = pars[cur]\\n            if par == None:\\n                return res\\n            return res + dp(par)\\n        \\n        return max(dp(x) for x in leaves)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807224,
                "title": "python-2-dfs",
                "content": "\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        adjList = defaultdict(list)\\n        for u,v in edges :\\n            adjList[u].append(v)\\n            adjList[v].append(u)\\n        \\n        n = len(adjList)\\n        time = [0]*n\\n        time[bob] = 1\\n        \\n\\t\\t# dfs to calculate time to reach node from bob\\n        def dfs1(node,par):\\n            if node == bob :\\n                return time[bob]\\n            res = 0\\n            for adj in adjList[node]:\\n                if adj == par :\\n                    continue\\n                flag = dfs1(adj,node)\\n                if flag != 0  :\\n                    res = 1 + flag\\n            time[node] = res\\n            return time[node]\\n        dfs1(0,None)\\n        \\n        \\n        self.res = float(\"-inf\")\\n        def dfs2(node,par,t,income):\\n            for adj in adjList[node]:\\n                if adj == par :\\n                    continue\\n                newTime = t + 1\\n                newIncome = income\\n                if time[adj] == 0 or newTime < time[adj] :\\n                    newIncome += amount[adj]\\n                elif newTime == time[adj] :\\n                    newIncome += amount[adj]//2\\n                if len(adjList[adj]) == 1 :\\n                    self.res = max(self.res,newIncome)\\n                dfs2(adj,node,newTime,newIncome)\\n                \\n        \\n        dfs2(0,None,1,amount[0])\\n        return self.res\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        adjList = defaultdict(list)\\n        for u,v in edges :\\n            adjList[u].append(v)\\n            adjList[v].append(u)\\n        \\n        n = len(adjList)\\n        time = [0]*n\\n        time[bob] = 1\\n        \\n\\t\\t# dfs to calculate time to reach node from bob\\n        def dfs1(node,par):\\n            if node == bob :\\n                return time[bob]\\n            res = 0\\n            for adj in adjList[node]:\\n                if adj == par :\\n                    continue\\n                flag = dfs1(adj,node)\\n                if flag != 0  :\\n                    res = 1 + flag\\n            time[node] = res\\n            return time[node]\\n        dfs1(0,None)\\n        \\n        \\n        self.res = float(\"-inf\")\\n        def dfs2(node,par,t,income):\\n            for adj in adjList[node]:\\n                if adj == par :\\n                    continue\\n                newTime = t + 1\\n                newIncome = income\\n                if time[adj] == 0 or newTime < time[adj] :\\n                    newIncome += amount[adj]\\n                elif newTime == time[adj] :\\n                    newIncome += amount[adj]//2\\n                if len(adjList[adj]) == 1 :\\n                    self.res = max(self.res,newIncome)\\n                dfs2(adj,node,newTime,newIncome)\\n                \\n        \\n        dfs2(0,None,1,amount[0])\\n        return self.res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 4075012,
                "title": "python-substract-bob-s-contribution-find-max-path-sum-for-alice",
                "content": "There are multiple solutions. This one is the easiest IMHO.\\n\\n1. Substract Bob\\'s path contribution:\\n\\t* Bob\\'s `1/2` of path will be taken by Bob and will leave for Alice `0`.\\n\\t* If there\\'s a `tie`, Bob will take `1/2` of middle node\\'s value and leave `1/2` for Alice\\n2. Find a path with max `0-leaf` sum.\\n3. Celebrate!!!\\n\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        def substract_bob(node=0, level=0, parent=None):\\n            res = [False, 0]\\n            for nei in tree[node]:\\n                if node == bob:\\n                    amount[node] = 0\\n                    return [True, level + 1]\\n                if nei != parent and (res := substract_bob(nei, level + 1, node))[0]:\\n                    bob_path_len = res[1]\\n                    if level == bob_path_len // 2 and bob_path_len % 2:\\n                        amount[node] //= 2\\n                    elif level >= bob_path_len // 2:\\n                        amount[node] = 0\\n                    return res\\n            return res\\n            \\n        def calc_max_path_sum(node=0, parent=None):\\n            res = float(-inf)\\n            for nei in tree[node]:\\n                if nei != parent:\\n                    res = max(res, calc_max_path_sum(nei, node))\\n            if res == float(-inf):\\n                res = 0\\n            return res + amount[node]\\n        \\n        tree = defaultdict(list)\\n        for u,v in edges:\\n            tree[u].append(v)\\n            tree[v].append(u)\\n        substract_bob()\\n        return calc_max_path_sum()\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        def substract_bob(node=0, level=0, parent=None):\\n            res = [False, 0]\\n            for nei in tree[node]:\\n                if node == bob:\\n                    amount[node] = 0\\n                    return [True, level + 1]\\n                if nei != parent and (res := substract_bob(nei, level + 1, node))[0]:\\n                    bob_path_len = res[1]\\n                    if level == bob_path_len // 2 and bob_path_len % 2:\\n                        amount[node] //= 2\\n                    elif level >= bob_path_len // 2:\\n                        amount[node] = 0\\n                    return res\\n            return res\\n            \\n        def calc_max_path_sum(node=0, parent=None):\\n            res = float(-inf)\\n            for nei in tree[node]:\\n                if nei != parent:\\n                    res = max(res, calc_max_path_sum(nei, node))\\n            if res == float(-inf):\\n                res = 0\\n            return res + amount[node]\\n        \\n        tree = defaultdict(list)\\n        for u,v in edges:\\n            tree[u].append(v)\\n            tree[v].append(u)\\n        substract_bob()\\n        return calc_max_path_sum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072937,
                "title": "single-dfs-o-v-e",
                "content": "# Intuition\\nCalculating steps of alice and bob both and check the conditiions given in question\\n# Approach\\nWe start dfs from 0 and calculate the steps of alice as we go down in tree and while returing from the dfs calls we calculate the steps of bob.\\nWe return the tuple: (max collection till now, steps travelled by bob) from dfs calls.\\nThe conditions are applied for adding the amount for current node and calculation of steps of bob before returning from dfs call \\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n\\n- Space complexity: O(V+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict \\n\\nclass Solution:\\n\\n    def dfs(self, graph, amount, bob, src, parent, steps): \\n        \\n        ans = float(\\'-inf\\')\\n        bob_step = 0\\n        for b in graph[src]: \\n            if b == parent: \\n                continue\\n            temp_an, temp_bob = self.dfs(graph, amount, bob, b, src, steps+1)\\n            ans = max(ans, temp_an)\\n            bob_step = max(bob_step, temp_bob)\\n        if ans == float(\\'-inf\\'):\\n            ans = 0            \\n\\n        if bob_step == steps: \\n            ans += amount[src]//2 \\n            return ans, bob_step+1\\n        \\n        if bob == src: \\n            return ans, 1\\n\\n        if bob_step: \\n            ans += amount[src] if steps < bob_step else 0\\n            return ans, bob_step+1\\n        \\n        else: \\n            ans += amount[src]\\n            return ans, 0\\n\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for a,b in edges: \\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        ans, _ = self.dfs(graph, amount, bob, 0, 0, 0)\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict \\n\\nclass Solution:\\n\\n    def dfs(self, graph, amount, bob, src, parent, steps): \\n        \\n        ans = float(\\'-inf\\')\\n        bob_step = 0\\n        for b in graph[src]: \\n            if b == parent: \\n                continue\\n            temp_an, temp_bob = self.dfs(graph, amount, bob, b, src, steps+1)\\n            ans = max(ans, temp_an)\\n            bob_step = max(bob_step, temp_bob)\\n        if ans == float(\\'-inf\\'):\\n            ans = 0            \\n\\n        if bob_step == steps: \\n            ans += amount[src]//2 \\n            return ans, bob_step+1\\n        \\n        if bob == src: \\n            return ans, 1\\n\\n        if bob_step: \\n            ans += amount[src] if steps < bob_step else 0\\n            return ans, bob_step+1\\n        \\n        else: \\n            ans += amount[src]\\n            return ans, 0\\n\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for a,b in edges: \\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        ans, _ = self.dfs(graph, amount, bob, 0, 0, 0)\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043274,
                "title": "dfs-simple",
                "content": "```\\n\\nclass Solution {\\n    vector<int> bobpath;\\n    unordered_map<int, unordered_set<int> > m;\\n    int n;\\n    int ans;\\n    \\npublic:\\n    bool constructBobPath(int curr, int parent){\\n        if(curr==0){\\n            return true;\\n        }\\n        if(m.find(curr) == m.end()){\\n            return false;\\n        }\\n        \\n        for(auto it: m[curr]){\\n            if(it != parent){\\n                bobpath.push_back(it);\\n                bool temp = constructBobPath(it, curr);\\n                if(temp){\\n                    return true;\\n                }\\n                bobpath.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void dfs(int curr, int parent, int val, vector<int>& amount){\\n        if(m.find(curr) == m.end()){\\n            ans=max(ans,val);\\n        }\\n        \\n        bool isleaf = true;\\n        for(auto it: m[curr]){\\n            if(it != parent){\\n                dfs(it, curr, val+amount[it], amount);\\n                isleaf = false;\\n            }\\n        }\\n        if(isleaf){\\n            ans=max(ans,val);\\n        }\\n    }\\n        \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int i,j,bobpathsize;\\n        n=amount.size();\\n        \\n        for(auto it: edges){\\n            m[it[0]].insert(it[1]);\\n            m[it[1]].insert(it[0]);\\n        }\\n        \\n        // find bobs path\\n        bobpath.push_back(bob);\\n        constructBobPath(bob, -1);\\n        bobpathsize=bobpath.size();\\n        \\n        ans=(-n)*(1e4);//minimum value of answer\\n        \\n        \\n        //iterate over bobs path and update amount to 0 upto middle\\n        i=0;j=bobpathsize-1;\\n        while(i<=j){\\n            if(i==j){\\n                amount[bobpath[i]] = amount[bobpath[i]]/2;\\n            }\\n            else{\\n                amount[bobpath[i]] = 0;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        //dfs from 0 to leafs and find max sum\\n        dfs(0, -1, amount[0], amount);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    vector<int> bobpath;\\n    unordered_map<int, unordered_set<int> > m;\\n    int n;\\n    int ans;\\n    \\npublic:\\n    bool constructBobPath(int curr, int parent){\\n        if(curr==0){\\n            return true;\\n        }\\n        if(m.find(curr) == m.end()){\\n            return false;\\n        }\\n        \\n        for(auto it: m[curr]){\\n            if(it != parent){\\n                bobpath.push_back(it);\\n                bool temp = constructBobPath(it, curr);\\n                if(temp){\\n                    return true;\\n                }\\n                bobpath.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void dfs(int curr, int parent, int val, vector<int>& amount){\\n        if(m.find(curr) == m.end()){\\n            ans=max(ans,val);\\n        }\\n        \\n        bool isleaf = true;\\n        for(auto it: m[curr]){\\n            if(it != parent){\\n                dfs(it, curr, val+amount[it], amount);\\n                isleaf = false;\\n            }\\n        }\\n        if(isleaf){\\n            ans=max(ans,val);\\n        }\\n    }\\n        \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int i,j,bobpathsize;\\n        n=amount.size();\\n        \\n        for(auto it: edges){\\n            m[it[0]].insert(it[1]);\\n            m[it[1]].insert(it[0]);\\n        }\\n        \\n        // find bobs path\\n        bobpath.push_back(bob);\\n        constructBobPath(bob, -1);\\n        bobpathsize=bobpath.size();\\n        \\n        ans=(-n)*(1e4);//minimum value of answer\\n        \\n        \\n        //iterate over bobs path and update amount to 0 upto middle\\n        i=0;j=bobpathsize-1;\\n        while(i<=j){\\n            if(i==j){\\n                amount[bobpath[i]] = amount[bobpath[i]]/2;\\n            }\\n            else{\\n                amount[bobpath[i]] = 0;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        //dfs from 0 to leafs and find max sum\\n        dfs(0, -1, amount[0], amount);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028909,
                "title": "2-times-dfs-straightforward-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: build graph O(E) + 2 times dfs O(V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: build graph O(E + V) + 2 times dfs O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int res = Integer.MIN_VALUE;\\n    int[] b;\\n    List<Integer>[] graph;\\n    int[] amount;\\n    \\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n = amount.length;\\n        this.b = new int[n];\\n        this.amount = amount;\\n        this.graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n            b[i] = n + 1;\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        dfsBob(bob, -1, 0); //calculate shortest distance from Bob to node i, but dfs starting from 0\\n        dfsAlice(0, 0, -1, 0); //calculate scores from 0(Alice) to a leaf\\n        return res;\\n    }\\n\\n    private void dfsBob(int bob, int parent, int cur) {\\n        if (cur == bob) {\\n            b[cur] = 0;\\n            return;\\n        }\\n        for (int next : graph[cur]) {\\n            if (next == parent) continue;\\n            dfsBob(bob, cur, next);\\n            b[cur] = Math.min(b[cur], b[next] + 1);\\n        }\\n    }\\n\\n    private void dfsAlice(int level, int score, int parent, int cur) {\\n        if (level == b[cur]) score += amount[cur] / 2; //Alice and Bob arrive this node at the same time\\n        else if (level < b[cur]) score += amount[cur]; //Alice arrives earlier than Bob\\n\\n        if (graph[cur].size() == 1 && graph[cur].get(0) == parent) { //Alice arrives at the leaf node\\n            res = Math.max(res, score);\\n            return;\\n        }\\n        for (int next : graph[cur]) {\\n            if (next == parent) continue;\\n            dfsAlice(level + 1, score, cur, next);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = Integer.MIN_VALUE;\\n    int[] b;\\n    List<Integer>[] graph;\\n    int[] amount;\\n    \\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n = amount.length;\\n        this.b = new int[n];\\n        this.amount = amount;\\n        this.graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n            b[i] = n + 1;\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        dfsBob(bob, -1, 0); //calculate shortest distance from Bob to node i, but dfs starting from 0\\n        dfsAlice(0, 0, -1, 0); //calculate scores from 0(Alice) to a leaf\\n        return res;\\n    }\\n\\n    private void dfsBob(int bob, int parent, int cur) {\\n        if (cur == bob) {\\n            b[cur] = 0;\\n            return;\\n        }\\n        for (int next : graph[cur]) {\\n            if (next == parent) continue;\\n            dfsBob(bob, cur, next);\\n            b[cur] = Math.min(b[cur], b[next] + 1);\\n        }\\n    }\\n\\n    private void dfsAlice(int level, int score, int parent, int cur) {\\n        if (level == b[cur]) score += amount[cur] / 2; //Alice and Bob arrive this node at the same time\\n        else if (level < b[cur]) score += amount[cur]; //Alice arrives earlier than Bob\\n\\n        if (graph[cur].size() == 1 && graph[cur].get(0) == parent) { //Alice arrives at the leaf node\\n            res = Math.max(res, score);\\n            return;\\n        }\\n        for (int next : graph[cur]) {\\n            if (next == parent) continue;\\n            dfsAlice(level + 1, score, cur, next);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017777,
                "title": "straight-forward-dfs-backtracking-commented-solution",
                "content": "# Intuition\\n\\nObservation : First thing to observe is : since it is a tree , so the path of Bob will be unique to reach the 0th node , this will help us to store the time at which the Bob has reached that node, which we will store in the hashmap.\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nstep 1 )  First we will start the Bob journey , we will start the dfs with bob node and will traverse until the 0th node is found . Once it gets found we will return true and stop the dfs , but in the mean time, as we reach the nodes in our path to 0th node, we will store the time at which we are reaching \\n\\nNow , one point to be taken care of is : there could be many paths which will not lead to 0th node, so while backtracking from those paths  , we will erasen the times taken to reach that node (SO THIS IS KIND OF BACKTRACKING STEP ) -- better understanding in the code .\\n\\nNow at this point the Bob travesal is complete, now let us start the Alice journey \\n\\nOne thing to observer is, once we are done with the Bob traversal , the problem has been reduced to find the path which gives the maximum total amount , now next critical step is to calculate the amount gained by each node  . here we will be using the hashmap of time which we generated duing the Bobs traversal.\\n\\n\\nNow we will start the dfs from 0th node, and once we go to a node, we will check that time taken to reach that node by Alice is same as of Bob, if it is then we will divide the amount and proceed to next node  ,and if the time taken by Bob to reach that node is less than Alice, which means that Bob has already travelled it before , so he has already taken its amount, so in this case we will not add any amount to the Alice and then proceed to next node, and there can be one more case when Bob hasn\\'t visited that node ever, so in that case , all amount will go to Alice .In this way we keep on adding the amount for Alice and once we reach the leaf node, we will see one of the above conditions for leaf node as well and then we will return . \\nAfter traversing all the paths ,we will return the minimum of all as our answer \\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\n// Bob\\'s dfs \\n    bool bdfs(int start, int parent, vector<vector<int>> &graph, unordered_map<int, int> &bobtime, int currtime)\\n    {\\n\\n        if (start == 0) // if we reach the start node ,we will return true \\n            return true;\\n\\n        bobtime[start] = currtime;  // once reaching the node, we will add the time taken to reach that node and store in hashamp\\n        //dfs calling for other node\\n        for (int child : graph[start])\\n        {\\n            if (child != parent)\\n            {\\n                if (bdfs(child, start, graph, bobtime, currtime + 1))  // if the dfs returns true , which means we have got the 0th node , we will simply return from this path \\n                    return true;\\n            }\\n        }\\n\\n    // this is BACKTRACKING STEP ,if this path does not lead us to the 0th node, we will erase all  node times from our hashmap and return false\\n        bobtime.erase(start);\\n        return false;\\n    }\\n\\n// Alice dfs\\n\\n    long long int adfs(int start, int parent, vector<vector<int>> &graph, vector<int> &amount, unordered_map<int, int> &bobtime, int currtime)\\n    {\\n        long long int mina = INT_MIN;  // this stores the  minimum amount needed to reach any lead node from that node \\n\\n        //dfs \\n        for (int child : graph[start])\\n        {\\n            if (child != parent)\\n            {\\n\\n                // if the Bob has never visited that node in his path to the 0th node , we will simply add the amount and go to next child\\n                if (bobtime.find(start) == bobtime.end())\\n                    mina = max(mina, amount[start] + adfs(child, start, graph, amount, bobtime, currtime + 1));\\n                else\\n                {\\n                    // if the bob visiting time is before the Alice , we will simply not add anything and proceed to next node \\n                    if (bobtime[start] < currtime)\\n                        mina = max(mina, adfs(child, start, graph, amount, bobtime, currtime + 1));\\n                    // if Bob and Alice visit the node at the same time , we will share the amount to both of them and proceed to next node \\n                    else if (bobtime[start] == currtime)\\n                        mina = max(mina, amount[start] / 2 + adfs(child, start, graph, amount, bobtime, currtime + 1));\\n                        // if Alice is visiting the node before the Bob, the whole amount will go the Alice.\\n                    else\\n                        mina = max(mina, amount[start] + adfs(child, start, graph, amount, bobtime, currtime + 1));\\n                }\\n            }\\n        }\\n\\n\\n// now here comes the leaf node case , leaf node has no child , so the leaf node min value will never gets updated, so we will check \\n// if Bob has visited that node or not and at what time.\\n        long long int ans;\\n        if (mina == INT_MIN)\\n\\n        {\\n\\n            if (bobtime.find(start) == bobtime.end())\\n                ans = amount[start];\\n            else\\n            {\\n                if (bobtime[start] == currtime)\\n                    ans = amount[start] / 2;\\n                else\\n                    ans = 0;\\n            }\\n\\n            \\n        }\\n// if ans !=INT_MIN  , this means that this node is not the leaf node, in this case , we will return the minimum answer calcualted.\\n        else\\n            ans = mina;\\n\\n        return ans;\\n    }\\n\\n    int mostProfitablePath(vector<vector<int>> &edges, int bob, vector<int> &amount)\\n    {\\n\\n        // constructing graph\\n        vector<vector<int>> graph(amount.size());\\n        for (auto i : edges)\\n        {\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n\\n        // this hashmap will the store the time at which the bob has traversed each node in his path \\n        unordered_map<int, int> bobtime;\\n\\n        // bob dfs\\n        bdfs(bob, -1, graph, bobtime, 0);\\n\\n        // Alice dfs\\n        return adfs(0, -1, graph, amount, bobtime, 0);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\n// Bob\\'s dfs \\n    bool bdfs(int start, int parent, vector<vector<int>> &graph, unordered_map<int, int> &bobtime, int currtime)\\n    {\\n\\n        if (start == 0) // if we reach the start node ,we will return true \\n            return true;\\n\\n        bobtime[start] = currtime;  // once reaching the node, we will add the time taken to reach that node and store in hashamp\\n        //dfs calling for other node\\n        for (int child : graph[start])\\n        {\\n            if (child != parent)\\n            {\\n                if (bdfs(child, start, graph, bobtime, currtime + 1))  // if the dfs returns true , which means we have got the 0th node , we will simply return from this path \\n                    return true;\\n            }\\n        }\\n\\n    // this is BACKTRACKING STEP ,if this path does not lead us to the 0th node, we will erase all  node times from our hashmap and return false\\n        bobtime.erase(start);\\n        return false;\\n    }\\n\\n// Alice dfs\\n\\n    long long int adfs(int start, int parent, vector<vector<int>> &graph, vector<int> &amount, unordered_map<int, int> &bobtime, int currtime)\\n    {\\n        long long int mina = INT_MIN;  // this stores the  minimum amount needed to reach any lead node from that node \\n\\n        //dfs \\n        for (int child : graph[start])\\n        {\\n            if (child != parent)\\n            {\\n\\n                // if the Bob has never visited that node in his path to the 0th node , we will simply add the amount and go to next child\\n                if (bobtime.find(start) == bobtime.end())\\n                    mina = max(mina, amount[start] + adfs(child, start, graph, amount, bobtime, currtime + 1));\\n                else\\n                {\\n                    // if the bob visiting time is before the Alice , we will simply not add anything and proceed to next node \\n                    if (bobtime[start] < currtime)\\n                        mina = max(mina, adfs(child, start, graph, amount, bobtime, currtime + 1));\\n                    // if Bob and Alice visit the node at the same time , we will share the amount to both of them and proceed to next node \\n                    else if (bobtime[start] == currtime)\\n                        mina = max(mina, amount[start] / 2 + adfs(child, start, graph, amount, bobtime, currtime + 1));\\n                        // if Alice is visiting the node before the Bob, the whole amount will go the Alice.\\n                    else\\n                        mina = max(mina, amount[start] + adfs(child, start, graph, amount, bobtime, currtime + 1));\\n                }\\n            }\\n        }\\n\\n\\n// now here comes the leaf node case , leaf node has no child , so the leaf node min value will never gets updated, so we will check \\n// if Bob has visited that node or not and at what time.\\n        long long int ans;\\n        if (mina == INT_MIN)\\n\\n        {\\n\\n            if (bobtime.find(start) == bobtime.end())\\n                ans = amount[start];\\n            else\\n            {\\n                if (bobtime[start] == currtime)\\n                    ans = amount[start] / 2;\\n                else\\n                    ans = 0;\\n            }\\n\\n            \\n        }\\n// if ans !=INT_MIN  , this means that this node is not the leaf node, in this case , we will return the minimum answer calcualted.\\n        else\\n            ans = mina;\\n\\n        return ans;\\n    }\\n\\n    int mostProfitablePath(vector<vector<int>> &edges, int bob, vector<int> &amount)\\n    {\\n\\n        // constructing graph\\n        vector<vector<int>> graph(amount.size());\\n        for (auto i : edges)\\n        {\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n\\n        // this hashmap will the store the time at which the bob has traversed each node in his path \\n        unordered_map<int, int> bobtime;\\n\\n        // bob dfs\\n        bdfs(bob, -1, graph, bobtime, 0);\\n\\n        // Alice dfs\\n        return adfs(0, -1, graph, amount, bobtime, 0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989664,
                "title": "2-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple sa fanda...pehle path nikalo fir bob se half path tk k amount ko zero krdo as bob gate khol dega..uske baad simple dfs\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>adj[],vector<int>v,vector<bool>& visi,vector<vector<int>>& path,int st,int ed){\\n        if(st==ed){\\n            v.push_back(st);\\n            path.push_back(v);\\n            return;\\n        }\\n        visi[st]=true;\\n        v.push_back(st);\\n        for(auto it:adj[st]){\\n            if(!visi[it]) solve(adj,v,visi,path,it,ed);\\n        }\\n        visi[st]=false;\\n        v.pop_back();\\n    }\\n    int dfs(vector<int>adj[],vector<int>& amount,int node,int parent,vector<bool>& visi){\\n        if(adj[node].size()==1 and parent!=-1 and visi[parent]){\\n            return amount[node];\\n        }\\n        visi[node]=true;\\n        int ans=INT_MIN;\\n        for(auto it:adj[node]){\\n            if(!visi[it]){\\n                ans=max(ans,amount[node]+dfs(adj,amount,it,node,visi));\\n            }\\n        }\\n        return ans;\\n    }\\n    bool solve1(vector<int>adj[],int src,int par,vector<int>& path){\\n        if(src==0){\\n            path.push_back(src);\\n            return true;\\n        }\\n        for(auto &it:adj[src]){\\n            if(it==par) continue;\\n            if(solve1(adj,it,src,path)){\\n                path.push_back(src);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        vector<int>adj[amount.size()];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>path;\\n        vector<bool>visi(amount.size(),false);\\n        solve1(adj,bob,-1,path);\\n        for(auto it:path){\\n            cout<<it<<\" \";\\n        }\\n        reverse(path.begin(),path.end());\\n        for(int i=0;i<path.size()/2;i++){\\n            amount[path[i]]=0;\\n        }\\n        \\n        if(path.size()%2!=0){\\n            amount[path[path.size()/2]]=amount[path[path.size()/2]]/2;\\n        }\\n        // // for(auto it:amount){\\n        // //     cout<<it<<\" \";\\n        // // }\\n        int ans=dfs(adj,amount,0,-1,visi);\\n        // //cout<<ans;\\n        return ans;\\n        // return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>adj[],vector<int>v,vector<bool>& visi,vector<vector<int>>& path,int st,int ed){\\n        if(st==ed){\\n            v.push_back(st);\\n            path.push_back(v);\\n            return;\\n        }\\n        visi[st]=true;\\n        v.push_back(st);\\n        for(auto it:adj[st]){\\n            if(!visi[it]) solve(adj,v,visi,path,it,ed);\\n        }\\n        visi[st]=false;\\n        v.pop_back();\\n    }\\n    int dfs(vector<int>adj[],vector<int>& amount,int node,int parent,vector<bool>& visi){\\n        if(adj[node].size()==1 and parent!=-1 and visi[parent]){\\n            return amount[node];\\n        }\\n        visi[node]=true;\\n        int ans=INT_MIN;\\n        for(auto it:adj[node]){\\n            if(!visi[it]){\\n                ans=max(ans,amount[node]+dfs(adj,amount,it,node,visi));\\n            }\\n        }\\n        return ans;\\n    }\\n    bool solve1(vector<int>adj[],int src,int par,vector<int>& path){\\n        if(src==0){\\n            path.push_back(src);\\n            return true;\\n        }\\n        for(auto &it:adj[src]){\\n            if(it==par) continue;\\n            if(solve1(adj,it,src,path)){\\n                path.push_back(src);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        vector<int>adj[amount.size()];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>path;\\n        vector<bool>visi(amount.size(),false);\\n        solve1(adj,bob,-1,path);\\n        for(auto it:path){\\n            cout<<it<<\" \";\\n        }\\n        reverse(path.begin(),path.end());\\n        for(int i=0;i<path.size()/2;i++){\\n            amount[path[i]]=0;\\n        }\\n        \\n        if(path.size()%2!=0){\\n            amount[path[path.size()/2]]=amount[path[path.size()/2]]/2;\\n        }\\n        // // for(auto it:amount){\\n        // //     cout<<it<<\" \";\\n        // // }\\n        int ans=dfs(adj,amount,0,-1,visi);\\n        // //cout<<ans;\\n        return ans;\\n        // return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3976340,
                "title": "see-if-it-helps-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid dfs(int node,vector<int>&vis,vector<int>adj[],vector<int>&path,vector<int>&ans){\\n\\nvis[node]=1;\\npath.push_back(node);\\nif(node==0){\\n    ans=path;\\n    return;\\n}\\nfor(auto &it:adj[node]){\\n    if(!vis[it])\\n    dfs(it,vis,adj,path,ans);\\n}\\npath.pop_back();\\n}\\n\\n\\nvoid dfsalice(int node,int t,unordered_map<int,int>&m,vector<int>&vis,vector<int>adj[],vector<int>& amount,int &cost,int &ans){\\n\\nvis[node]=1;\\nint addvalue=0;\\nif(m.find(node)==m.end())\\naddvalue=amount[node];\\nelse if(m[node]>t)\\naddvalue=amount[node];\\nelse if(m[node]==t)\\naddvalue=amount[node]/2;\\nelse if(m[node]<t)\\naddvalue=0;\\n\\ncost+=addvalue;\\n\\n// Leaf node\\nif(adj[node].size()==1 && node!=0){\\n    ans=max(ans,cost);\\n    cost-=addvalue;\\n    return;\\n}\\nfor(auto &it:adj[node]){\\n    if(!vis[it])\\n    dfsalice(it,t+1,m,vis,adj,amount,cost,ans);\\n}\\ncost-=addvalue;\\n\\n}\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n// Make Adjacency List\\nvector<int>adj[n];\\nfor(auto &it:edges){\\n    int u=it[0];\\n    int v=it[1];\\n    adj[u].push_back(v);\\n    adj[v].push_back(u);\\n}\\n\\n\\n        // Find path of bob and store kaun se time par bob kaun se node par tha (ie. map node to time)\\nvector<int>path,bobpath; vector<int>vis(n,0);\\ndfs(bob,vis,adj,path,bobpath);\\n// Making map  (map node to time)\\nunordered_map<int,int>m;\\nfor(int i=0;i<bobpath.size();i++){\\n    m[bobpath[i]]=i;\\n}\\n\\n\\n// fir se vis ka kaam hai to naya banane se achcha hai vaapas sabko 0 kar do\\nvis.assign(n,0);\\n\\n// Now Alice path\\nint cost=0,ans=INT_MIN;\\ndfsalice(0,0,m,vis,adj,amount,cost,ans);\\n\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid dfs(int node,vector<int>&vis,vector<int>adj[],vector<int>&path,vector<int>&ans){\\n\\nvis[node]=1;\\npath.push_back(node);\\nif(node==0){\\n    ans=path;\\n    return;\\n}\\nfor(auto &it:adj[node]){\\n    if(!vis[it])\\n    dfs(it,vis,adj,path,ans);\\n}\\npath.pop_back();\\n}\\n\\n\\nvoid dfsalice(int node,int t,unordered_map<int,int>&m,vector<int>&vis,vector<int>adj[],vector<int>& amount,int &cost,int &ans){\\n\\nvis[node]=1;\\nint addvalue=0;\\nif(m.find(node)==m.end())\\naddvalue=amount[node];\\nelse if(m[node]>t)\\naddvalue=amount[node];\\nelse if(m[node]==t)\\naddvalue=amount[node]/2;\\nelse if(m[node]<t)\\naddvalue=0;\\n\\ncost+=addvalue;\\n\\n// Leaf node\\nif(adj[node].size()==1 && node!=0){\\n    ans=max(ans,cost);\\n    cost-=addvalue;\\n    return;\\n}\\nfor(auto &it:adj[node]){\\n    if(!vis[it])\\n    dfsalice(it,t+1,m,vis,adj,amount,cost,ans);\\n}\\ncost-=addvalue;\\n\\n}\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n// Make Adjacency List\\nvector<int>adj[n];\\nfor(auto &it:edges){\\n    int u=it[0];\\n    int v=it[1];\\n    adj[u].push_back(v);\\n    adj[v].push_back(u);\\n}\\n\\n\\n        // Find path of bob and store kaun se time par bob kaun se node par tha (ie. map node to time)\\nvector<int>path,bobpath; vector<int>vis(n,0);\\ndfs(bob,vis,adj,path,bobpath);\\n// Making map  (map node to time)\\nunordered_map<int,int>m;\\nfor(int i=0;i<bobpath.size();i++){\\n    m[bobpath[i]]=i;\\n}\\n\\n\\n// fir se vis ka kaam hai to naya banane se achcha hai vaapas sabko 0 kar do\\nvis.assign(n,0);\\n\\n// Now Alice path\\nint cost=0,ans=INT_MIN;\\ndfsalice(0,0,m,vis,adj,amount,cost,ans);\\n\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969603,
                "title": "java-o-n-modify-tree-and-get-max",
                "content": "# Code\\n```\\nclass Solution {\\n    List<Integer>[] graph;\\n    int N;\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        N = edges.length+1;\\n        graph = new ArrayList[N];\\n        for (int i = 0; i < N; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        bobTraverse(0, -1, 1, bob, amount);\\n        return getMax(0, -1, 1, amount);\\n    }\\n\\n\\n    public int getMax(int cur, int prev, int step, int[] amount) {\\n        int max = Integer.MIN_VALUE;\\n        for (int e : graph[cur]) {\\n            if (e == prev) {\\n                continue;\\n            }\\n            max = Math.max(max, getMax(e, cur, step+1, amount));\\n        }\\n        return (max == Integer.MIN_VALUE) ? amount[cur] : max+amount[cur];\\n    }\\n\\n    public int bobTraverse(int cur, int prev, int step, int bob, int[] amount) {\\n        if (cur == bob) {\\n            amount[cur] = (step == 1) ? amount[cur]/2 : 0;\\n            return 1;\\n        }\\n        for (int e : graph[cur]) {\\n            if (e == prev) {\\n                continue;\\n            }\\n            int res = bobTraverse(e, cur, step+1, bob, amount);\\n            if (res > 0) {\\n                res++;\\n                if (step == res) {\\n                    amount[cur] /= 2;\\n                } else if (step > res) {\\n                    amount[cur] = 0;\\n                }\\n                return res;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer>[] graph;\\n    int N;\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        N = edges.length+1;\\n        graph = new ArrayList[N];\\n        for (int i = 0; i < N; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        bobTraverse(0, -1, 1, bob, amount);\\n        return getMax(0, -1, 1, amount);\\n    }\\n\\n\\n    public int getMax(int cur, int prev, int step, int[] amount) {\\n        int max = Integer.MIN_VALUE;\\n        for (int e : graph[cur]) {\\n            if (e == prev) {\\n                continue;\\n            }\\n            max = Math.max(max, getMax(e, cur, step+1, amount));\\n        }\\n        return (max == Integer.MIN_VALUE) ? amount[cur] : max+amount[cur];\\n    }\\n\\n    public int bobTraverse(int cur, int prev, int step, int bob, int[] amount) {\\n        if (cur == bob) {\\n            amount[cur] = (step == 1) ? amount[cur]/2 : 0;\\n            return 1;\\n        }\\n        for (int e : graph[cur]) {\\n            if (e == prev) {\\n                continue;\\n            }\\n            int res = bobTraverse(e, cur, step+1, bob, amount);\\n            if (res > 0) {\\n                res++;\\n                if (step == res) {\\n                    amount[cur] /= 2;\\n                } else if (step > res) {\\n                    amount[cur] = 0;\\n                }\\n                return res;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955948,
                "title": "100-fast-very-easy-and-basic-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe basic approach is to think of a function which find a way from bob to root and on its way it keep marking the distance from starting node and the nodes which are not on its way to root are left unmarked\\n\\nnow think of second functon dfs which will calcualte the maximum cost from root to leaf but with conditon that it will take the cost of the node only if it reach that node first(distance of node i to node 0<distance mark by prev function )so basically it means that alice rech that gate first and take half price if bot distnaces are equal and take 0 if distance is greaater than calculated one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool helper(vector<vector<int>> &g,int si,int k,int p,vector<int> &score)\\n    {\\n        if((g[si].size()==1 && k) || si==0)\\n        {\\n            if(si==0)\\n            {\\n            score[si]=k;\\n            return true;\\n\\n            }\\n            return false;\\n        }\\n        score[si]=k;\\n        bool op1=false;\\n        for(auto it:g[si])\\n        {\\n          if(it!=p)  \\n          {\\n              op1=op1 || helper(g,it,k+1,si,score);\\n              \\n          }\\n\\n        }\\n        if(!op1)score[si]=1e4;\\n        return op1;\\n\\n    }\\n\\nint get(vector<vector<int>> &g,int si,int p,vector<int> &amount,vector<int> &score,int k)\\n{\\n    if(g[si].size()==1 && si!=0)\\n    {\\n        if(k<score[si])return amount[si];\\n        if(k==score[si])return amount[si]/2;\\n        return 0;\\n    }\\n    int op1=-1e9;\\n    for(auto it:g[si])\\n\\n    {\\n        if(it!=p)\\n        {\\n            int a=0;\\n            if(k<score[si])a=amount[si]+get(g,it,si,amount,score,k+1);\\n           else if(k==score[si])a=amount[si]/2+get(g,it,si,amount,score,k+1);\\n            else a=get(g,it,si,amount,score,k+1);\\n            op1=max(op1,a);\\n\\n        }\\n    }\\n    return op1;\\n}\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<int>score(n,1e4);\\n        vector<vector<int>>g(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        helper(g,bob,0,-1,score);\\n        // for(int i=0;i<n;i++)cout<<i<<\" \"<<score[i]<<endl;\\n        return get(g,0,-1,amount,score,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool helper(vector<vector<int>> &g,int si,int k,int p,vector<int> &score)\\n    {\\n        if((g[si].size()==1 && k) || si==0)\\n        {\\n            if(si==0)\\n            {\\n            score[si]=k;\\n            return true;\\n\\n            }\\n            return false;\\n        }\\n        score[si]=k;\\n        bool op1=false;\\n        for(auto it:g[si])\\n        {\\n          if(it!=p)  \\n          {\\n              op1=op1 || helper(g,it,k+1,si,score);\\n              \\n          }\\n\\n        }\\n        if(!op1)score[si]=1e4;\\n        return op1;\\n\\n    }\\n\\nint get(vector<vector<int>> &g,int si,int p,vector<int> &amount,vector<int> &score,int k)\\n{\\n    if(g[si].size()==1 && si!=0)\\n    {\\n        if(k<score[si])return amount[si];\\n        if(k==score[si])return amount[si]/2;\\n        return 0;\\n    }\\n    int op1=-1e9;\\n    for(auto it:g[si])\\n\\n    {\\n        if(it!=p)\\n        {\\n            int a=0;\\n            if(k<score[si])a=amount[si]+get(g,it,si,amount,score,k+1);\\n           else if(k==score[si])a=amount[si]/2+get(g,it,si,amount,score,k+1);\\n            else a=get(g,it,si,amount,score,k+1);\\n            op1=max(op1,a);\\n\\n        }\\n    }\\n    return op1;\\n}\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<int>score(n,1e4);\\n        vector<vector<int>>g(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        helper(g,bob,0,-1,score);\\n        // for(int i=0;i<n;i++)cout<<i<<\" \"<<score[i]<<endl;\\n        return get(g,0,-1,amount,score,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3929116,
                "title": "rust-solution-using-bfs-dfs",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nstruct Helper {\\n  memo: Vec<usize>,\\n}\\n\\nimpl Helper {\\n  fn dfs(&mut self, g:&Vec<Vec<usize>>, stack: &mut Vec<usize>, ci:usize, li:usize)  {\\n    if ci == 0 {\\n      self.memo = stack.clone();\\n      self.memo.push(ci);\\n      return\\n    }\\n\\n    for &ni in &g[ci] {\\n      if ni == li { continue }\\n      stack.push(ci);\\n      self.dfs(g, stack, ni, ci);\\n      stack.pop();\\n    }\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn most_profitable_path(edges: Vec<Vec<i32>>, bob: i32, amount: Vec<i32>) -> i32 {\\n    let n = edges.len() + 1;\\n    let bob = bob as usize;\\n\\n    let mut g = vec![vec![];n];\\n    for arr in edges {\\n      let a = arr[0] as usize;\\n      let b = arr[1] as usize;\\n      g[a].push(b);\\n      g[b].push(a);\\n    }\\n\\n    let mut stack = vec![];\\n    let mut helper = Helper { memo: vec![] };\\n    helper.dfs(&g, &mut stack, bob, 1_000_000_000);\\n    let bob_route = helper.memo;\\n\\n    let mut seen = vec![false;n];\\n    let mut time = 0;\\n    let mut stack = vec![(0,amount[0],1_000_000_000)];\\n\\n    // println!(\"{:?}\", &bob_route);\\n    seen[bob] = true;\\n    let mut result = -10i32.pow(9)-5;\\n    while !stack.is_empty() {\\n      let mut new_stack = vec![];\\n\\n      let bob_index = if time < bob_route.len() - 1 {\\n        Some(bob_route[time+1])\\n      } else {\\n        None\\n      };\\n\\n      // println!(\"{:?}\", &stack);\\n      while let Some((ci, cv, li)) = stack.pop() {\\n        if g[ci].len() == 1 && ci != 0 {\\n          result = result.max(cv);\\n          continue\\n        }\\n\\n        for &ni in &g[ci] {\\n          if ni == li { continue }\\n          let anv = cv + if seen[ni] {\\n            0\\n          } else if let Some(bni) = bob_index {\\n            if ni == bni {\\n              amount[ni] / 2\\n            } else {\\n              amount[ni]\\n            }\\n          } else {\\n            amount[ni]\\n          };\\n          seen[ni] = true;\\n          new_stack.push((ni,anv,ci));\\n        }\\n        seen[ci] = true;\\n      }\\n\\n      if time < bob_route.len()-1 {\\n        seen[bob_route[time+1]] = true;\\n      }\\n      stack = new_stack;\\n      time += 1;\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nstruct Helper {\\n  memo: Vec<usize>,\\n}\\n\\nimpl Helper {\\n  fn dfs(&mut self, g:&Vec<Vec<usize>>, stack: &mut Vec<usize>, ci:usize, li:usize)  {\\n    if ci == 0 {\\n      self.memo = stack.clone();\\n      self.memo.push(ci);\\n      return\\n    }\\n\\n    for &ni in &g[ci] {\\n      if ni == li { continue }\\n      stack.push(ci);\\n      self.dfs(g, stack, ni, ci);\\n      stack.pop();\\n    }\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn most_profitable_path(edges: Vec<Vec<i32>>, bob: i32, amount: Vec<i32>) -> i32 {\\n    let n = edges.len() + 1;\\n    let bob = bob as usize;\\n\\n    let mut g = vec![vec![];n];\\n    for arr in edges {\\n      let a = arr[0] as usize;\\n      let b = arr[1] as usize;\\n      g[a].push(b);\\n      g[b].push(a);\\n    }\\n\\n    let mut stack = vec![];\\n    let mut helper = Helper { memo: vec![] };\\n    helper.dfs(&g, &mut stack, bob, 1_000_000_000);\\n    let bob_route = helper.memo;\\n\\n    let mut seen = vec![false;n];\\n    let mut time = 0;\\n    let mut stack = vec![(0,amount[0],1_000_000_000)];\\n\\n    // println!(\"{:?}\", &bob_route);\\n    seen[bob] = true;\\n    let mut result = -10i32.pow(9)-5;\\n    while !stack.is_empty() {\\n      let mut new_stack = vec![];\\n\\n      let bob_index = if time < bob_route.len() - 1 {\\n        Some(bob_route[time+1])\\n      } else {\\n        None\\n      };\\n\\n      // println!(\"{:?}\", &stack);\\n      while let Some((ci, cv, li)) = stack.pop() {\\n        if g[ci].len() == 1 && ci != 0 {\\n          result = result.max(cv);\\n          continue\\n        }\\n\\n        for &ni in &g[ci] {\\n          if ni == li { continue }\\n          let anv = cv + if seen[ni] {\\n            0\\n          } else if let Some(bni) = bob_index {\\n            if ni == bni {\\n              amount[ni] / 2\\n            } else {\\n              amount[ni]\\n            }\\n          } else {\\n            amount[ni]\\n          };\\n          seen[ni] = true;\\n          new_stack.push((ni,anv,ci));\\n        }\\n        seen[ci] = true;\\n      }\\n\\n      if time < bob_route.len()-1 {\\n        seen[bob_route[time+1]] = true;\\n      }\\n      stack = new_stack;\\n      time += 1;\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929115,
                "title": "rust-solution-using-bfs-dfs",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nstruct Helper {\\n  memo: Vec<usize>,\\n}\\n\\nimpl Helper {\\n  fn dfs(&mut self, g:&Vec<Vec<usize>>, stack: &mut Vec<usize>, ci:usize, li:usize)  {\\n    if ci == 0 {\\n      self.memo = stack.clone();\\n      self.memo.push(ci);\\n      return\\n    }\\n\\n    for &ni in &g[ci] {\\n      if ni == li { continue }\\n      stack.push(ci);\\n      self.dfs(g, stack, ni, ci);\\n      stack.pop();\\n    }\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn most_profitable_path(edges: Vec<Vec<i32>>, bob: i32, amount: Vec<i32>) -> i32 {\\n    let n = edges.len() + 1;\\n    let bob = bob as usize;\\n\\n    let mut g = vec![vec![];n];\\n    for arr in edges {\\n      let a = arr[0] as usize;\\n      let b = arr[1] as usize;\\n      g[a].push(b);\\n      g[b].push(a);\\n    }\\n\\n    let mut stack = vec![];\\n    let mut helper = Helper { memo: vec![] };\\n    helper.dfs(&g, &mut stack, bob, 1_000_000_000);\\n    let bob_route = helper.memo;\\n\\n    let mut seen = vec![false;n];\\n    let mut time = 0;\\n    let mut stack = vec![(0,amount[0],1_000_000_000)];\\n\\n    // println!(\"{:?}\", &bob_route);\\n    seen[bob] = true;\\n    let mut result = -10i32.pow(9)-5;\\n    while !stack.is_empty() {\\n      let mut new_stack = vec![];\\n\\n      let bob_index = if time < bob_route.len() - 1 {\\n        Some(bob_route[time+1])\\n      } else {\\n        None\\n      };\\n\\n      // println!(\"{:?}\", &stack);\\n      while let Some((ci, cv, li)) = stack.pop() {\\n        if g[ci].len() == 1 && ci != 0 {\\n          result = result.max(cv);\\n          continue\\n        }\\n\\n        for &ni in &g[ci] {\\n          if ni == li { continue }\\n          let anv = cv + if seen[ni] {\\n            0\\n          } else if let Some(bni) = bob_index {\\n            if ni == bni {\\n              amount[ni] / 2\\n            } else {\\n              amount[ni]\\n            }\\n          } else {\\n            amount[ni]\\n          };\\n          seen[ni] = true;\\n          new_stack.push((ni,anv,ci));\\n        }\\n        seen[ci] = true;\\n      }\\n\\n      if time < bob_route.len()-1 {\\n        seen[bob_route[time+1]] = true;\\n      }\\n      stack = new_stack;\\n      time += 1;\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nstruct Helper {\\n  memo: Vec<usize>,\\n}\\n\\nimpl Helper {\\n  fn dfs(&mut self, g:&Vec<Vec<usize>>, stack: &mut Vec<usize>, ci:usize, li:usize)  {\\n    if ci == 0 {\\n      self.memo = stack.clone();\\n      self.memo.push(ci);\\n      return\\n    }\\n\\n    for &ni in &g[ci] {\\n      if ni == li { continue }\\n      stack.push(ci);\\n      self.dfs(g, stack, ni, ci);\\n      stack.pop();\\n    }\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn most_profitable_path(edges: Vec<Vec<i32>>, bob: i32, amount: Vec<i32>) -> i32 {\\n    let n = edges.len() + 1;\\n    let bob = bob as usize;\\n\\n    let mut g = vec![vec![];n];\\n    for arr in edges {\\n      let a = arr[0] as usize;\\n      let b = arr[1] as usize;\\n      g[a].push(b);\\n      g[b].push(a);\\n    }\\n\\n    let mut stack = vec![];\\n    let mut helper = Helper { memo: vec![] };\\n    helper.dfs(&g, &mut stack, bob, 1_000_000_000);\\n    let bob_route = helper.memo;\\n\\n    let mut seen = vec![false;n];\\n    let mut time = 0;\\n    let mut stack = vec![(0,amount[0],1_000_000_000)];\\n\\n    // println!(\"{:?}\", &bob_route);\\n    seen[bob] = true;\\n    let mut result = -10i32.pow(9)-5;\\n    while !stack.is_empty() {\\n      let mut new_stack = vec![];\\n\\n      let bob_index = if time < bob_route.len() - 1 {\\n        Some(bob_route[time+1])\\n      } else {\\n        None\\n      };\\n\\n      // println!(\"{:?}\", &stack);\\n      while let Some((ci, cv, li)) = stack.pop() {\\n        if g[ci].len() == 1 && ci != 0 {\\n          result = result.max(cv);\\n          continue\\n        }\\n\\n        for &ni in &g[ci] {\\n          if ni == li { continue }\\n          let anv = cv + if seen[ni] {\\n            0\\n          } else if let Some(bni) = bob_index {\\n            if ni == bni {\\n              amount[ni] / 2\\n            } else {\\n              amount[ni]\\n            }\\n          } else {\\n            amount[ni]\\n          };\\n          seen[ni] = true;\\n          new_stack.push((ni,anv,ci));\\n        }\\n        seen[ci] = true;\\n      }\\n\\n      if time < bob_route.len()-1 {\\n        seen[bob_route[time+1]] = true;\\n      }\\n      stack = new_stack;\\n      time += 1;\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3920693,
                "title": "c-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&adj, vector<int>&path, int curr, int prev)\\n    {\\n        if(curr==0){return true;}\\n        for(int x:adj[curr])\\n        {\\n            if(x!=prev)\\n            {\\n                path.push_back(x);\\n                if(dfs(adj, path, x, curr)){return true;}\\n                path.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void rec(vector<vector<int>>&adj, vector<int>&st, vector<int>&amount, int curr, int prev, int tim, int&ans, int val)\\n    {\\n        bool ch = false;\\n        for(int x:adj[curr])\\n        {\\n            if(x!=prev)\\n            {\\n                ch=true;\\n                int y = st[curr];\\n                if(y==-1){rec(adj, st, amount, x, curr, tim+1, ans, val+amount[curr]);}\\n                else if(y==tim){rec(adj, st, amount, x, curr, tim+1, ans, val+amount[curr]/2);}\\n                else if(y<tim){rec(adj, st, amount, x, curr, tim+1, ans, val);}\\n                else if(y>tim){rec(adj, st, amount, x, curr, tim+1, ans, val+amount[curr]);}\\n            }\\n        }\\n        if(ch==false)\\n        {\\n            int y = st[curr];\\n            if(y==-1){ans=max(ans, val+amount[curr]);}\\n            else if(y==tim){ans=max(ans, val+amount[curr]/2);}\\n            else if(y<tim){ans=max(ans, val);}\\n            else if(y>tim){ans=max(ans, val+amount[curr]);}\\n        }\\n        return;\\n    }\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount)\\n    {\\n        int n = edges.size();\\n        n++;\\n        vector<vector<int>> adj(n);\\n        for(vector<int>&e: edges){adj[e[0]].push_back(e[1]);adj[e[1]].push_back(e[0]);}\\n        vector<int>path = {bob};\\n        dfs(adj, path, bob, -1);\\n        vector<int> st(n, -1);\\n        for(int i=0;i<path.size();i++){st[path[i]]=i;}\\n        int ans = INT_MIN;\\n        rec(adj, st, amount, 0, -1, 0, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&adj, vector<int>&path, int curr, int prev)\\n    {\\n        if(curr==0){return true;}\\n        for(int x:adj[curr])\\n        {\\n            if(x!=prev)\\n            {\\n                path.push_back(x);\\n                if(dfs(adj, path, x, curr)){return true;}\\n                path.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void rec(vector<vector<int>>&adj, vector<int>&st, vector<int>&amount, int curr, int prev, int tim, int&ans, int val)\\n    {\\n        bool ch = false;\\n        for(int x:adj[curr])\\n        {\\n            if(x!=prev)\\n            {\\n                ch=true;\\n                int y = st[curr];\\n                if(y==-1){rec(adj, st, amount, x, curr, tim+1, ans, val+amount[curr]);}\\n                else if(y==tim){rec(adj, st, amount, x, curr, tim+1, ans, val+amount[curr]/2);}\\n                else if(y<tim){rec(adj, st, amount, x, curr, tim+1, ans, val);}\\n                else if(y>tim){rec(adj, st, amount, x, curr, tim+1, ans, val+amount[curr]);}\\n            }\\n        }\\n        if(ch==false)\\n        {\\n            int y = st[curr];\\n            if(y==-1){ans=max(ans, val+amount[curr]);}\\n            else if(y==tim){ans=max(ans, val+amount[curr]/2);}\\n            else if(y<tim){ans=max(ans, val);}\\n            else if(y>tim){ans=max(ans, val+amount[curr]);}\\n        }\\n        return;\\n    }\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount)\\n    {\\n        int n = edges.size();\\n        n++;\\n        vector<vector<int>> adj(n);\\n        for(vector<int>&e: edges){adj[e[0]].push_back(e[1]);adj[e[1]].push_back(e[0]);}\\n        vector<int>path = {bob};\\n        dfs(adj, path, bob, -1);\\n        vector<int> st(n, -1);\\n        for(int i=0;i<path.size();i++){st[path[i]]=i;}\\n        int ans = INT_MIN;\\n        rec(adj, st, amount, 0, -1, 0, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913373,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->here bob will always move toward 0 so we know its path and while bob is going we can mark the time stamps on the node where the bob reaches and then we can run dfs from 0 that is alice position and we can check the time taken to reach at that node by alice if it is equal or more or less if less then add that amount if equal then add half of the amount and if more than no amount add. and then at last return the max.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid level(int node,int par,vector<int>&lvl,vector<int>adj[]){\\n     if(par==-1){\\n        lvl[node]=0;\\n     }\\n     else {\\n         lvl[node]=lvl[par]+1;\\n     }\\n     for(auto child:adj[node]){\\n         if(child!=par){\\n             level(child,node,lvl,adj);\\n         }\\n     }\\n     return;\\n}\\nvoid track(int bob,vector<int>adj[],vector<int>&time,vector<int>&lvl){\\n    for(auto child:adj[bob]){\\n        if((lvl[bob]-lvl[child])==1){\\n            time[child]=time[bob]+1;\\n            track(child,adj,time,lvl);\\n        }\\n    }\\n    return;\\n}\\nint dfs(int node,int par,vector<int>adj[],vector<int>&amount,int c,vector<int>&time){\\n    \\n    int ans =-1e6;\\n    if(adj[node].size()==1&&adj[node][0]==par){\\n        if(c==time[node]){\\n              return amount[node]/2;\\n            }\\n            else if(c<time[node]){\\n              return amount[node];\\n            }\\n            else {\\n              return 0;\\n            }\\n    }\\n    for(auto child:adj[node]){\\n        \\n        if(child!=par){\\n            if(c==time[node]){\\n              ans=max(amount[node]/2+dfs(child,node,adj,amount,c+1,time),ans);\\n            }\\n            else if(c<time[node]){\\n              ans=max(ans,amount[node]+dfs(child,node,adj,amount,c+1,time));\\n            }\\n            else {\\n              ans=max(ans,dfs(child,node,adj,amount,c+1,time));\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=-1;\\n        for(auto it :edges){\\n            n=max({n,it[0],it[1]});\\n        }\\n        n++;\\n        vector<int>adj[n];\\n        for(auto it :edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>lvl(n);\\n        level(0,-1,lvl,adj);\\n        vector<int>time(n,INT_MAX);\\n        time[bob]=0;\\n        track(bob,adj,time,lvl);\\n        return dfs(0,-1,adj,amount,0,time);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid level(int node,int par,vector<int>&lvl,vector<int>adj[]){\\n     if(par==-1){\\n        lvl[node]=0;\\n     }\\n     else {\\n         lvl[node]=lvl[par]+1;\\n     }\\n     for(auto child:adj[node]){\\n         if(child!=par){\\n             level(child,node,lvl,adj);\\n         }\\n     }\\n     return;\\n}\\nvoid track(int bob,vector<int>adj[],vector<int>&time,vector<int>&lvl){\\n    for(auto child:adj[bob]){\\n        if((lvl[bob]-lvl[child])==1){\\n            time[child]=time[bob]+1;\\n            track(child,adj,time,lvl);\\n        }\\n    }\\n    return;\\n}\\nint dfs(int node,int par,vector<int>adj[],vector<int>&amount,int c,vector<int>&time){\\n    \\n    int ans =-1e6;\\n    if(adj[node].size()==1&&adj[node][0]==par){\\n        if(c==time[node]){\\n              return amount[node]/2;\\n            }\\n            else if(c<time[node]){\\n              return amount[node];\\n            }\\n            else {\\n              return 0;\\n            }\\n    }\\n    for(auto child:adj[node]){\\n        \\n        if(child!=par){\\n            if(c==time[node]){\\n              ans=max(amount[node]/2+dfs(child,node,adj,amount,c+1,time),ans);\\n            }\\n            else if(c<time[node]){\\n              ans=max(ans,amount[node]+dfs(child,node,adj,amount,c+1,time));\\n            }\\n            else {\\n              ans=max(ans,dfs(child,node,adj,amount,c+1,time));\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=-1;\\n        for(auto it :edges){\\n            n=max({n,it[0],it[1]});\\n        }\\n        n++;\\n        vector<int>adj[n];\\n        for(auto it :edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>lvl(n);\\n        level(0,-1,lvl,adj);\\n        vector<int>time(n,INT_MAX);\\n        time[bob]=0;\\n        track(bob,adj,time,lvl);\\n        return dfs(0,-1,adj,amount,0,time);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890720,
                "title": "c-commented-easiest-dfs",
                "content": "\\n# Approach\\nThere is only 1 path that Bob will follow from start to the root node. While Alice can follow multiple paths from the root to any leaf node.\\n\\nIn the first DFS call, we go from the root node to all the leaf nodes and at each node, we store the parent of this node and the time it\\ntook to reach this node from the root node.\\n\\nNow for each node, we have the time it takes Alice to reach this node.\\n\\nNow we traverse the path of Bob. If bob reaches the node before Alice does, then make amount of the node = 0. If both reach it at the same\\ntime, then make it amount/2.\\nElse Alice will reach it first and collect the amount here.\\n\\nNow we run 2nd DFS from root node to each leaf node and for each path, find the total amount collected in this path and return the max value.\\n\\n\\n**Upvote If This Helped!! :))**\\n\\n\\n# Code\\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n\\nmap<int, vector<int>> adj;   // adjacency list to store the tree\\n\\nvector<int> par;   // par[i]: parent of ith node\\nvector<int> dis;   // dist[i]: time taken by Alice to reach this node starting from the root node.\\n\\n\\n\\n\\n\\n// find the parent and distance from node 0\\n// u: current node\\n// p: parent of u\\n// d: distance of u from root node\\nvoid dfs(int u,int p,int d){\\n    \\n    dis[u] = d;\\n    par[u] = p;\\n\\n    // call DFS on all nbrs\\n    for(int nbr: adj[u]){\\n        if(nbr==p){\\n            continue;\\n        }\\n\\n        dfs(nbr, u, d+1);\\n\\n    }\\n\\n\\n    return;\\n\\n}\\n\\n\\n\\n\\n\\n\\n\\n// u: current node we are on\\n// p: parent of u\\n// ans: max root to leaf path till now\\n// curr: sum of current path we are on\\nvoid dfs2(int u, vector<int> &amount, int par, int &ans, int &curr){\\n\\n    // include current node in path\\n    curr += amount[u];\\n\\n    // if current node is a leaf node, then update ans\\n    if(adj[u].size()==1 && par!=-1){\\n        ans = max(ans, curr);\\n        curr -= amount[u];\\n        return;\\n    }\\n\\n    for(auto nbr: adj[u]){\\n        if(nbr != par){\\n            dfs2(nbr, amount, u, ans, curr);\\n        }\\n    }\\n\\n    curr -= amount[u];\\n    return;\\n\\n}\\n\\n\\n\\n\\n\\nint mostProfitablePath(vector<vector<int>> &edges, int bob, vector<int> &amount){\\n    \\n    int n = amount.size();   // total nodes\\n\\n    for(auto &e: edges){\\n        adj[e[0]].push_back(e[1]);\\n        adj[e[1]].push_back(e[0]);\\n    }\\n\\n    par.resize(n);\\n    dis.resize(n);\\n\\n    // run DFS to find the parents of all nodes and the first time we reach the node from the root node\\n    dfs(0, -1, 0);\\n\\n    // traverse the path of Bob to root node and if Bob reaches a node before Alice, then make the amount 0 ...\\n    int curr = bob;   // current node we are on\\n    int bob_dis = 0;\\n    while(curr != 0){\\n        if(dis[curr]>bob_dis){\\n            amount[curr] = 0;\\n        }\\n        else if(dis[curr] == bob_dis){\\n            amount[curr]/=2;\\n        }\\n\\n        curr = par[curr];\\n        bob_dis++;\\n\\n    }\\n\\n    // run 2nd DFS to explore all paths from root to all leafs and return the max sum of all such paths\\n    int ans = INT_MIN;\\n    curr = 0;   // sum of current path\\n    dfs2(0, amount, -1, ans, curr);\\n    return ans;\\n\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n\\nmap<int, vector<int>> adj;   // adjacency list to store the tree\\n\\nvector<int> par;   // par[i]: parent of ith node\\nvector<int> dis;   // dist[i]: time taken by Alice to reach this node starting from the root node.\\n\\n\\n\\n\\n\\n// find the parent and distance from node 0\\n// u: current node\\n// p: parent of u\\n// d: distance of u from root node\\nvoid dfs(int u,int p,int d){\\n    \\n    dis[u] = d;\\n    par[u] = p;\\n\\n    // call DFS on all nbrs\\n    for(int nbr: adj[u]){\\n        if(nbr==p){\\n            continue;\\n        }\\n\\n        dfs(nbr, u, d+1);\\n\\n    }\\n\\n\\n    return;\\n\\n}\\n\\n\\n\\n\\n\\n\\n\\n// u: current node we are on\\n// p: parent of u\\n// ans: max root to leaf path till now\\n// curr: sum of current path we are on\\nvoid dfs2(int u, vector<int> &amount, int par, int &ans, int &curr){\\n\\n    // include current node in path\\n    curr += amount[u];\\n\\n    // if current node is a leaf node, then update ans\\n    if(adj[u].size()==1 && par!=-1){\\n        ans = max(ans, curr);\\n        curr -= amount[u];\\n        return;\\n    }\\n\\n    for(auto nbr: adj[u]){\\n        if(nbr != par){\\n            dfs2(nbr, amount, u, ans, curr);\\n        }\\n    }\\n\\n    curr -= amount[u];\\n    return;\\n\\n}\\n\\n\\n\\n\\n\\nint mostProfitablePath(vector<vector<int>> &edges, int bob, vector<int> &amount){\\n    \\n    int n = amount.size();   // total nodes\\n\\n    for(auto &e: edges){\\n        adj[e[0]].push_back(e[1]);\\n        adj[e[1]].push_back(e[0]);\\n    }\\n\\n    par.resize(n);\\n    dis.resize(n);\\n\\n    // run DFS to find the parents of all nodes and the first time we reach the node from the root node\\n    dfs(0, -1, 0);\\n\\n    // traverse the path of Bob to root node and if Bob reaches a node before Alice, then make the amount 0 ...\\n    int curr = bob;   // current node we are on\\n    int bob_dis = 0;\\n    while(curr != 0){\\n        if(dis[curr]>bob_dis){\\n            amount[curr] = 0;\\n        }\\n        else if(dis[curr] == bob_dis){\\n            amount[curr]/=2;\\n        }\\n\\n        curr = par[curr];\\n        bob_dis++;\\n\\n    }\\n\\n    // run 2nd DFS to explore all paths from root to all leafs and return the max sum of all such paths\\n    int ans = INT_MIN;\\n    curr = 0;   // sum of current path\\n    dfs2(0, amount, -1, ans, curr);\\n    return ans;\\n\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867025,
                "title": "simple-dfs-96-7-faster-than-c-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe intution behind the solution is we mark the nodes from bob to node 0 with the time it occurs on that node since this is tree there is only one path \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnow we move alice and explore all path which ever gives the maximum amount we return it\\nbut before adding or subtracting the value we must take care of some conditions:-\\n1)if the level (which is time alice reach node) is greater than time of bob we doesn\\'t add something\\n2)if the level is less than the time of bob or if bob never visit that node(v[i]==0) we add it\\n3)if the level ==time of bob we add half the value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>v,par;\\n    void dfs(int node,int parent,vector<vector<int>>&adj,int n){\\n        par[node]=parent;\\n        for(int nbr:adj[node]){\\n            if(nbr!=parent){\\n                dfs(nbr,node,adj,n);\\n            }\\n        }\\n    }\\n    long long func(int node,int parent,int l,int n,vector<vector<int>>&adj,vector<int>&amount){\\n        long long ans=-1e10;\\n        for(int nbr:adj[node]){\\n            if(nbr!=parent){\\n                ans=max(ans,func(nbr,node,l+1,n,adj,amount));\\n            }\\n        }\\n        if(ans==-1e10)ans=0;\\n        if(v[node]>0&&v[node]==l){\\n            ans+=(amount[node]/2);\\n        }\\n        else if(l<v[node]||v[node]==0)ans+=amount[node];\\n        // cout<<node<<\" \"<<ans<<endl;\\n        return ans;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<vector<int>>adj(n);\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        v.resize(n);\\n        par.resize(n,-1);\\n        dfs(0,-1,adj,n);\\n        int cnt=1;\\n        while(bob!=-1){\\n            v[bob]=cnt++;\\n            bob=par[bob];\\n        }\\n        return func(0,-1,1,n,adj,amount);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v,par;\\n    void dfs(int node,int parent,vector<vector<int>>&adj,int n){\\n        par[node]=parent;\\n        for(int nbr:adj[node]){\\n            if(nbr!=parent){\\n                dfs(nbr,node,adj,n);\\n            }\\n        }\\n    }\\n    long long func(int node,int parent,int l,int n,vector<vector<int>>&adj,vector<int>&amount){\\n        long long ans=-1e10;\\n        for(int nbr:adj[node]){\\n            if(nbr!=parent){\\n                ans=max(ans,func(nbr,node,l+1,n,adj,amount));\\n            }\\n        }\\n        if(ans==-1e10)ans=0;\\n        if(v[node]>0&&v[node]==l){\\n            ans+=(amount[node]/2);\\n        }\\n        else if(l<v[node]||v[node]==0)ans+=amount[node];\\n        // cout<<node<<\" \"<<ans<<endl;\\n        return ans;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<vector<int>>adj(n);\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        v.resize(n);\\n        par.resize(n,-1);\\n        dfs(0,-1,adj,n);\\n        int cnt=1;\\n        while(bob!=-1){\\n            v[bob]=cnt++;\\n            bob=par[bob];\\n        }\\n        return func(0,-1,1,n,adj,amount);\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3852190,
                "title": "dfs-approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create graph out of edges\\n2. add bob place as visited\\n3. create an array which contains **level** for all the nodes that bob traversed\\n4. foreach node connected to the current node in the graph,if bob has not visited yet, please visit by calling same bobpath function. \\n5. when bob reach root node, for each node bob visited, add it to the bobpath by incrementing the **level**\\n\\n\\n**alice path**---------------------------------------\\n6.add 0 (he starts from root) to visited \\n7. \\n8.  find sum-- calculated based on level, if same level has been reached by bob before at the same level of alice then sum/2 otherwise full amount.\\n8. for each node that is connected to curnode(0) from graph find alicepath if node is not visited before\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n=edges.Length+1;\\n        var graph=new List<int>[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            graph[i]=new List<int>();\\n        }\\n        foreach(var edge in edges)\\n        {\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n        var visited=new HashSet<int>(){bob};\\n        var bobpath=new int[n];\\n        Array.Fill(bobpath, int.MaxValue);\\n        bobpath[bob]=0;\\n        var found=false;\\n        BobPath(graph,bob,bobpath,amount,visited, ref found);\\n        return AlicePath(graph,0,bobpath,amount,0,new HashSet<int>(){0});\\n    }\\n    int AlicePath(List<int>[] graph,int cur ,int[] bobpath,int[] amount,int level,  HashSet<int> visited)\\n    {\\n       int sum= level<bobpath[cur]?amount[cur]:level==bobpath[cur]?amount[cur]/2:0;\\n       int max= int.MinValue;\\n       foreach(var next in graph[cur])\\n       {\\n           if(!visited.Add(next)) continue;\\n           max=Math.Max(max,AlicePath(graph, next, bobpath,amount, level+1,visited));\\n           visited.Remove(next);\\n\\n       }\\n      return max==int.MinValue?sum:sum+max;\\n    }\\n   void BobPath(List<int>[] graph,int cur,int[] bobpath,int[] amount,HashSet<int> visited, ref bool found)\\n    {\\n        if(found)return ;\\n        if(cur==0)\\n        {\\n            var level=0;\\n            foreach(var node in visited)\\n            bobpath[node]=level++;\\n            found=true;\\n            return ;\\n        }\\n        foreach(var  next in graph[cur])\\n        {\\n            if(!visited.Add(next)) continue ;\\n            BobPath(graph,next,bobpath,amount,visited,ref found);\\n            visited.Remove(next);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n=edges.Length+1;\\n        var graph=new List<int>[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            graph[i]=new List<int>();\\n        }\\n        foreach(var edge in edges)\\n        {\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n        var visited=new HashSet<int>(){bob};\\n        var bobpath=new int[n];\\n        Array.Fill(bobpath, int.MaxValue);\\n        bobpath[bob]=0;\\n        var found=false;\\n        BobPath(graph,bob,bobpath,amount,visited, ref found);\\n        return AlicePath(graph,0,bobpath,amount,0,new HashSet<int>(){0});\\n    }\\n    int AlicePath(List<int>[] graph,int cur ,int[] bobpath,int[] amount,int level,  HashSet<int> visited)\\n    {\\n       int sum= level<bobpath[cur]?amount[cur]:level==bobpath[cur]?amount[cur]/2:0;\\n       int max= int.MinValue;\\n       foreach(var next in graph[cur])\\n       {\\n           if(!visited.Add(next)) continue;\\n           max=Math.Max(max,AlicePath(graph, next, bobpath,amount, level+1,visited));\\n           visited.Remove(next);\\n\\n       }\\n      return max==int.MinValue?sum:sum+max;\\n    }\\n   void BobPath(List<int>[] graph,int cur,int[] bobpath,int[] amount,HashSet<int> visited, ref bool found)\\n    {\\n        if(found)return ;\\n        if(cur==0)\\n        {\\n            var level=0;\\n            foreach(var node in visited)\\n            bobpath[node]=level++;\\n            found=true;\\n            return ;\\n        }\\n        foreach(var  next in graph[cur])\\n        {\\n            if(!visited.Add(next)) continue ;\\n            BobPath(graph,next,bobpath,amount,visited,ref found);\\n            visited.Remove(next);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843466,
                "title": "c-bfs-dfs-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet Alice reach all the leaf nodes. As for Bob, let him reach the node 0. Keep a vector of time for each node that Bob visits. When Alice starts to move, she will check if the current node she is at has beeen visited by Bob or not. If it is visited by Bob, there will be either gain of 0 value or the amount will be halved (time[alice reaching a node]==time[bob reaching that node]).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    vector<int> par;\\n    vector<int> time;\\n    void updateParent(int src, int parent){\\n        for(int nbr: adj[src]){\\n            if(nbr==parent){\\n                continue;\\n            }\\n            par[nbr]=src;\\n            updateParent(nbr,src);\\n        }\\n    }\\n    void moveUpBob(int src, int t){\\n        time[src]=t;\\n        if(src==0){\\n            return;\\n        }\\n        moveUpBob(par[src],t+1);\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount){\\n        \\n        int ans = INT_MIN;\\n        int n = amount.size();\\n        adj = vector<vector<int>>(n);\\n        par = vector<int>(n,-1);\\n        time = vector<int>(n,1e9);\\n\\n        for(auto &i:edges){\\n            int u = i[0];\\n            int v = i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        //first update the parent array\\n        updateParent(0,-1);\\n        //first move bob to the top place\\n        moveUpBob(bob,0);\\n        //now start moving alice towards all leaf node\\n        queue<vector<int>> q;\\n        q.push({0,0,0});\\n\\n        while(!q.empty()){\\n            vector<int> t = q.front();  q.pop();\\n            //check if the time of reaching this node is earlier, same or later than bob\\n            int node = t[0];\\n            int tm = t[1];\\n            int val = t[2];\\n            int cnt = 0;\\n\\n            if(tm<time[node]){\\n                //Alice reached this node before Bob\\n                val+=amount[node];\\n            }\\n            if(tm==time[node]){\\n                //Bob reached this node together with Alice\\n                val+=(amount[node]/2);\\n            }\\n            //now check for all the neighbours of node\\n            for(int nbr:adj[node]){\\n                if(nbr==par[node]){\\n                    continue;\\n                }\\n                q.push({nbr,tm+1,val});\\n                cnt++;\\n            }\\n            if(cnt==0){\\n                //it is a leaf node\\n                ans = max(ans, val);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    vector<int> par;\\n    vector<int> time;\\n    void updateParent(int src, int parent){\\n        for(int nbr: adj[src]){\\n            if(nbr==parent){\\n                continue;\\n            }\\n            par[nbr]=src;\\n            updateParent(nbr,src);\\n        }\\n    }\\n    void moveUpBob(int src, int t){\\n        time[src]=t;\\n        if(src==0){\\n            return;\\n        }\\n        moveUpBob(par[src],t+1);\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount){\\n        \\n        int ans = INT_MIN;\\n        int n = amount.size();\\n        adj = vector<vector<int>>(n);\\n        par = vector<int>(n,-1);\\n        time = vector<int>(n,1e9);\\n\\n        for(auto &i:edges){\\n            int u = i[0];\\n            int v = i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        //first update the parent array\\n        updateParent(0,-1);\\n        //first move bob to the top place\\n        moveUpBob(bob,0);\\n        //now start moving alice towards all leaf node\\n        queue<vector<int>> q;\\n        q.push({0,0,0});\\n\\n        while(!q.empty()){\\n            vector<int> t = q.front();  q.pop();\\n            //check if the time of reaching this node is earlier, same or later than bob\\n            int node = t[0];\\n            int tm = t[1];\\n            int val = t[2];\\n            int cnt = 0;\\n\\n            if(tm<time[node]){\\n                //Alice reached this node before Bob\\n                val+=amount[node];\\n            }\\n            if(tm==time[node]){\\n                //Bob reached this node together with Alice\\n                val+=(amount[node]/2);\\n            }\\n            //now check for all the neighbours of node\\n            for(int nbr:adj[node]){\\n                if(nbr==par[node]){\\n                    continue;\\n                }\\n                q.push({nbr,tm+1,val});\\n                cnt++;\\n            }\\n            if(cnt==0){\\n                //it is a leaf node\\n                ans = max(ans, val);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800223,
                "title": "c-dfs-bfs-simple-approach",
                "content": "\\n# Approach\\nFirst allow Bob to go to 0 node. Maintain a distance vector for it.\\nNow allow Alice to move in graph\\nif(alice.time < distance[bob]) give point to Alice\\nelse if (alice.time > distance[bob]) give point to bob\\nelse if (both equal) split the amount \\nelse give amount to alice \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    vector<vector<int>> rev_graph;\\n    vector<bool> visited;\\n    vector<int> distance;\\n    vector<int> amount;\\n    int time;\\n    int n;\\n\\n    int dfs(int bob, int time){\\n        visited[bob] = true;\\n        distance[bob] = time;\\n\\n        if(bob == 0){\\n            return 0;\\n        }\\n\\n        bool isThere = false;\\n        \\n        for(auto child : graph[bob]){\\n            if(!visited[child]){\\n                int hasFound = dfs(child, time + 1);\\n                if(hasFound != 0){\\n                    distance[child] = -1;\\n                }else {\\n                    isThere = true;\\n                }\\n            }\\n        }\\n\\n        if(isThere) return 0;\\n        return bob;\\n\\n    }\\n    \\n    int bfs(){\\n        int ans = INT_MIN;\\n\\n        int aliceCost = amount[0];\\n        queue<vector<int>> q;\\n        q.push({0, 0, aliceCost}); // (node, time, cost)\\n        visited[0] = true;\\n\\n        while(q.size()){\\n            vector<int> fr = q.front();\\n            q.pop();\\n\\n            int node = fr[0], time = fr[1], cost = fr[2];\\n            bool there = false;\\n            if(graph[node].size() == 1){\\n                for(auto child : graph[node]){\\n                    if(visited[child]){\\n                        ans = max(ans, cost);\\n                        there = true;\\n                        break;\\n                    }\\n                }\\n                if(there){\\n                    continue;\\n                }\\n            }\\n            for(auto child : graph[node]){\\n                if(!visited[child]){\\n                    if(distance[child] != -1 && time + 1 < distance[child]){\\n                        q.push({child, time + 1, cost + amount[child]});\\n                    }else if(distance[child] != -1 && time + 1 > distance[child]){\\n                        q.push({child, time + 1, cost});\\n                    }else if (distance[child] != -1 && time + 1 == distance[child]){\\n                        int newCost = cost + (amount[child] / 2);\\n                        q.push({child, time + 1, newCost});\\n                    }else{\\n                        q.push({child, time + 1, cost + amount[child]});\\n                    }\\n                    visited[child] = true;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        this->n = amount.size();\\n        graph.resize(n);\\n        rev_graph.resize(n);\\n        visited.assign(n, false);\\n        distance.assign(n, -1);\\n        this->amount = amount;\\n        for(int i = 0; i < edges.size() ; i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        time = 0;\\n        dfs(bob, 0);\\n        visited.clear();\\n        visited.assign(n, false);\\n        return bfs();    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    vector<vector<int>> rev_graph;\\n    vector<bool> visited;\\n    vector<int> distance;\\n    vector<int> amount;\\n    int time;\\n    int n;\\n\\n    int dfs(int bob, int time){\\n        visited[bob] = true;\\n        distance[bob] = time;\\n\\n        if(bob == 0){\\n            return 0;\\n        }\\n\\n        bool isThere = false;\\n        \\n        for(auto child : graph[bob]){\\n            if(!visited[child]){\\n                int hasFound = dfs(child, time + 1);\\n                if(hasFound != 0){\\n                    distance[child] = -1;\\n                }else {\\n                    isThere = true;\\n                }\\n            }\\n        }\\n\\n        if(isThere) return 0;\\n        return bob;\\n\\n    }\\n    \\n    int bfs(){\\n        int ans = INT_MIN;\\n\\n        int aliceCost = amount[0];\\n        queue<vector<int>> q;\\n        q.push({0, 0, aliceCost}); // (node, time, cost)\\n        visited[0] = true;\\n\\n        while(q.size()){\\n            vector<int> fr = q.front();\\n            q.pop();\\n\\n            int node = fr[0], time = fr[1], cost = fr[2];\\n            bool there = false;\\n            if(graph[node].size() == 1){\\n                for(auto child : graph[node]){\\n                    if(visited[child]){\\n                        ans = max(ans, cost);\\n                        there = true;\\n                        break;\\n                    }\\n                }\\n                if(there){\\n                    continue;\\n                }\\n            }\\n            for(auto child : graph[node]){\\n                if(!visited[child]){\\n                    if(distance[child] != -1 && time + 1 < distance[child]){\\n                        q.push({child, time + 1, cost + amount[child]});\\n                    }else if(distance[child] != -1 && time + 1 > distance[child]){\\n                        q.push({child, time + 1, cost});\\n                    }else if (distance[child] != -1 && time + 1 == distance[child]){\\n                        int newCost = cost + (amount[child] / 2);\\n                        q.push({child, time + 1, newCost});\\n                    }else{\\n                        q.push({child, time + 1, cost + amount[child]});\\n                    }\\n                    visited[child] = true;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        this->n = amount.size();\\n        graph.resize(n);\\n        rev_graph.resize(n);\\n        visited.assign(n, false);\\n        distance.assign(n, -1);\\n        this->amount = amount;\\n        for(int i = 0; i < edges.size() ; i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        time = 0;\\n        dfs(bob, 0);\\n        visited.clear();\\n        visited.assign(n, false);\\n        return bfs();    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766219,
                "title": "double-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(list)\\n        \\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        n = len(graph)\\n        vis = set()\\n        parent = [0]*n\\n        dist = [0]*n\\n        #print(n)\\n        #print(graph)\\n        def dfs(node,p,d):\\n            if node in vis:\\n                return\\n            vis.add(node)\\n            parent[node] = p\\n            dist[node] = d\\n            for c in graph[node]:\\n                dfs(c,node,d+1)\\n        dfs(0,-1,0)\\n        time = 0\\n        while bob!=0:\\n            if time<dist[bob]:\\n                amount[bob] = 0\\n            elif time == dist[bob]:\\n                amount[bob]//=2\\n            time+=1\\n            bob = parent[bob]\\n        p = set(parent)\\n        self.ans = float(\\'-inf\\')\\n        visited = set()\\n        def fun(node,x):\\n            if node in visited:\\n                return\\n            if node not in p:\\n                self.ans = max(self.ans,x)\\n                return\\n            visited.add(node)\\n            for c in graph[node]:\\n                fun(c,x+amount[c])\\n            \\n        fun(0,amount[0])\\n        return self.ans\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(list)\\n        \\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        n = len(graph)\\n        vis = set()\\n        parent = [0]*n\\n        dist = [0]*n\\n        #print(n)\\n        #print(graph)\\n        def dfs(node,p,d):\\n            if node in vis:\\n                return\\n            vis.add(node)\\n            parent[node] = p\\n            dist[node] = d\\n            for c in graph[node]:\\n                dfs(c,node,d+1)\\n        dfs(0,-1,0)\\n        time = 0\\n        while bob!=0:\\n            if time<dist[bob]:\\n                amount[bob] = 0\\n            elif time == dist[bob]:\\n                amount[bob]//=2\\n            time+=1\\n            bob = parent[bob]\\n        p = set(parent)\\n        self.ans = float(\\'-inf\\')\\n        visited = set()\\n        def fun(node,x):\\n            if node in visited:\\n                return\\n            if node not in p:\\n                self.ans = max(self.ans,x)\\n                return\\n            visited.add(node)\\n            for c in graph[node]:\\n                fun(c,x+amount[c])\\n            \\n        fun(0,amount[0])\\n        return self.ans\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734222,
                "title": "python-linear-two-dfs-with-explanation",
                "content": "# Intuition\\nOne thing we have to notice is that Alice can do many different paths while Bob does not have a choice. So lets first find how Bob will move. To do this we do dfs (`dfs_bob`) until we find a path from his starting position to 0. As this is a tree, there can be only one path and once we find it we check at what time will we be at what node.\\n\\nNow after this we do dfs for Alice (`dfs_alice`) maintaing her current total sum and the time it reached that node. In her case we check whether the node is visited by Bob (if not we add this value to curr sum). Now if the node was visited we need to see who visited it first. And we have 3 options (based on description):\\n - if Bob, then there is nothing to get there\\n - if Alice, she gets full reward\\n - if both, then you get the half\\n\\nYou can probably do this shorter, but the point here is clarity and those functions clearly show what they do\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n\\n  def __init__(self):\\n    self.g = {}\\n    self.bob_arrival = {}\\n    self.best_res = -float(\\'inf\\')\\n\\n  def build_graph(self, edges: List[List[int]]):\\n    g = defaultdict(list)\\n    for v1, v2 in edges:\\n      g[v1].append(v2)\\n      g[v2].append(v1)\\n    self.g = g\\n\\n  def dfs_bob(self, path):\\n    if self.bob_arrival:\\n      return\\n\\n    node_from = -1 if len(path) == 1 else path[-2]\\n    for node_to in self.g[path[-1]]:\\n      if node_to != node_from:\\n        path.append(node_to)\\n        if node_to == 0:\\n          for t, n in enumerate(path):\\n            self.bob_arrival[n] = t\\n          return\\n\\n        self.dfs_bob(path)\\n        path.pop()\\n\\n  def dfs_alice(self, node_curr: int, node_from: int, curr_sum: int, ts: int):\\n    if node_curr not in self.bob_arrival:\\n      curr_sum += self.amount[node_curr]\\n    else:\\n      ts_b = self.bob_arrival[node_curr]\\n      if ts_b == ts:\\n        curr_sum += self.amount[node_curr] // 2\\n      elif ts < ts_b:\\n        curr_sum += self.amount[node_curr]\\n\\n    is_final = True\\n    for node_to in self.g[node_curr]:\\n      if node_to != node_from:\\n        is_final = False\\n        self.dfs_alice(node_to, node_curr, curr_sum, ts + 1)\\n    \\n    if is_final and curr_sum > self.best_res:\\n      self.best_res = curr_sum\\n\\n\\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n    self.amount = amount\\n    self.build_graph(edges)\\n    self.dfs_bob([bob])\\n    self.dfs_alice(0, -1, 0, 0)\\n\\n    return self.best_res\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n\\n  def __init__(self):\\n    self.g = {}\\n    self.bob_arrival = {}\\n    self.best_res = -float(\\'inf\\')\\n\\n  def build_graph(self, edges: List[List[int]]):\\n    g = defaultdict(list)\\n    for v1, v2 in edges:\\n      g[v1].append(v2)\\n      g[v2].append(v1)\\n    self.g = g\\n\\n  def dfs_bob(self, path):\\n    if self.bob_arrival:\\n      return\\n\\n    node_from = -1 if len(path) == 1 else path[-2]\\n    for node_to in self.g[path[-1]]:\\n      if node_to != node_from:\\n        path.append(node_to)\\n        if node_to == 0:\\n          for t, n in enumerate(path):\\n            self.bob_arrival[n] = t\\n          return\\n\\n        self.dfs_bob(path)\\n        path.pop()\\n\\n  def dfs_alice(self, node_curr: int, node_from: int, curr_sum: int, ts: int):\\n    if node_curr not in self.bob_arrival:\\n      curr_sum += self.amount[node_curr]\\n    else:\\n      ts_b = self.bob_arrival[node_curr]\\n      if ts_b == ts:\\n        curr_sum += self.amount[node_curr] // 2\\n      elif ts < ts_b:\\n        curr_sum += self.amount[node_curr]\\n\\n    is_final = True\\n    for node_to in self.g[node_curr]:\\n      if node_to != node_from:\\n        is_final = False\\n        self.dfs_alice(node_to, node_curr, curr_sum, ts + 1)\\n    \\n    if is_final and curr_sum > self.best_res:\\n      self.best_res = curr_sum\\n\\n\\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n    self.amount = amount\\n    self.build_graph(edges)\\n    self.dfs_bob([bob])\\n    self.dfs_alice(0, -1, 0, 0)\\n\\n    return self.best_res\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718566,
                "title": "c-dfs-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst do a DFS and find the path for Bob. These are the gates opnened by Bob. Now traverse the graph for Alice starting from 0 and check the if the gate has been opened by Bob before Alice arrives there if not count the money and return it using a BFS traversal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. find the DFS traversal of Bob and store it in a array `bobTraversal`. \\n2. find the gates opened by Bob and store them in array `gateOpenedBob`. The indices of this array represent the nodes and the value is in the form of <bool, time>. True means opened and false for closed.\\n3. declare a Queue for Alice BFS traversal that stores the node, money, time \\n    a. If the current Node where Alice is and the node traversed by Bob are same @ time t then divide the money between them.\\n    b. If the nodes are not same then check if the Gate has been opened by Bob before Alice arrives there, if so ignore the cost there else consider the entire cost.\\n    c. If the node is a leaf then it will have only 1 node in its adjancency list, if so update the answer. \\n    d. Explore the children of the node and push into the queue.\\n    e. Repeat these steps untill the Queue is empty.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nDFS = O(n + e) \\nBFS = O(n + e)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool dfs(int node, int time, vector<int> adj[], vector<int> &bobVisited, vector<int> &bobTraversal)\\n    { \\n        bobVisited[node] = 1;\\n        bobTraversal.push_back(node);\\n\\n        //base case\\n        if(node == 0)\\n            return true;\\n\\n        for(auto e : adj[node])\\n        {\\n            if(bobVisited[e] == 0)\\n            {\\n                if(dfs(e,time+1,adj,bobVisited,bobTraversal) == true)\\n                    return true;\\n            }\\n        }\\n        bobTraversal.pop_back();\\n        bobVisited[node] = 0;\\n        return false;\\n    }\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n\\n        //create the graph..\\n        vector<int> adj[n];\\n        for(auto e : edges)\\n        {\\n            int from = e[0];\\n            int to = e[1];\\n\\n            adj[from].push_back(to);\\n            adj[to].push_back(from);\\n        }\\n\\n        //finding the traversal of bob with time..\\n        vector<int> bobVisited(n,0);\\n        vector< pair<bool,int> > gateOpenedBob(n,{false,-1});       //stores info about which gates are opened by Bob @ what time..\\n        vector<int> bobTraversal;\\n\\n        dfs(bob,0,adj,bobVisited,bobTraversal);\\n\\n        for(int i=0;i<bobTraversal.size();i++)\\n        {\\n            int n = bobTraversal[i];\\n            gateOpenedBob[n] = {true,i};\\n        }\\n\\n        //Alice traversal to find the maximum net income..\\n        vector<int> aliceVisited(n,0);\\n        queue< pair< pair<int,int>, int> > q;       //store the node money and time.\\n        \\n        q.push({{0,0},0});\\n        aliceVisited[0] = 1;\\n        int ans = INT_MIN;\\n\\n        while(!q.empty())\\n        {\\n            auto it = q.front();\\n            q.pop();\\n\\n            int node = it.first.first;\\n            int money = it.first.second;\\n            int time = it.second;\\n\\n            //check if they are at the same nodes or not during this time.. also check if Bob has already visited this node before Alice visiting it\\n            if(time < bobTraversal.size()  and node == bobTraversal[time])\\n                money += amount[node]/2;\\n            else \\n            {\\n                if(gateOpenedBob[node].first == true and gateOpenedBob[node].second > time )\\n                    money += amount[node];\\n                else if(gateOpenedBob[node].first == false)\\n                    money += amount[node];\\n            }\\n                \\n\\n            //update answer only when it is a leaf node ..\\n            if(node != 0 and adj[node].size() == 1)\\n                ans = max(ans,money);\\n\\n            //explore its children \\n            for(auto e : adj[node])\\n            {\\n                if(aliceVisited[e] == 0)\\n                {\\n                    aliceVisited[e] = 1;\\n                    q.push({{e,money},time+1});\\n                }\\n            }    \\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(int node, int time, vector<int> adj[], vector<int> &bobVisited, vector<int> &bobTraversal)\\n    { \\n        bobVisited[node] = 1;\\n        bobTraversal.push_back(node);\\n\\n        //base case\\n        if(node == 0)\\n            return true;\\n\\n        for(auto e : adj[node])\\n        {\\n            if(bobVisited[e] == 0)\\n            {\\n                if(dfs(e,time+1,adj,bobVisited,bobTraversal) == true)\\n                    return true;\\n            }\\n        }\\n        bobTraversal.pop_back();\\n        bobVisited[node] = 0;\\n        return false;\\n    }\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n\\n        //create the graph..\\n        vector<int> adj[n];\\n        for(auto e : edges)\\n        {\\n            int from = e[0];\\n            int to = e[1];\\n\\n            adj[from].push_back(to);\\n            adj[to].push_back(from);\\n        }\\n\\n        //finding the traversal of bob with time..\\n        vector<int> bobVisited(n,0);\\n        vector< pair<bool,int> > gateOpenedBob(n,{false,-1});       //stores info about which gates are opened by Bob @ what time..\\n        vector<int> bobTraversal;\\n\\n        dfs(bob,0,adj,bobVisited,bobTraversal);\\n\\n        for(int i=0;i<bobTraversal.size();i++)\\n        {\\n            int n = bobTraversal[i];\\n            gateOpenedBob[n] = {true,i};\\n        }\\n\\n        //Alice traversal to find the maximum net income..\\n        vector<int> aliceVisited(n,0);\\n        queue< pair< pair<int,int>, int> > q;       //store the node money and time.\\n        \\n        q.push({{0,0},0});\\n        aliceVisited[0] = 1;\\n        int ans = INT_MIN;\\n\\n        while(!q.empty())\\n        {\\n            auto it = q.front();\\n            q.pop();\\n\\n            int node = it.first.first;\\n            int money = it.first.second;\\n            int time = it.second;\\n\\n            //check if they are at the same nodes or not during this time.. also check if Bob has already visited this node before Alice visiting it\\n            if(time < bobTraversal.size()  and node == bobTraversal[time])\\n                money += amount[node]/2;\\n            else \\n            {\\n                if(gateOpenedBob[node].first == true and gateOpenedBob[node].second > time )\\n                    money += amount[node];\\n                else if(gateOpenedBob[node].first == false)\\n                    money += amount[node];\\n            }\\n                \\n\\n            //update answer only when it is a leaf node ..\\n            if(node != 0 and adj[node].size() == 1)\\n                ans = max(ans,money);\\n\\n            //explore its children \\n            for(auto e : adj[node])\\n            {\\n                if(aliceVisited[e] == 0)\\n                {\\n                    aliceVisited[e] = 1;\\n                    q.push({{e,money},time+1});\\n                }\\n            }    \\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712331,
                "title": "easy-java-solution-beats-95",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n = amount.length;\\n\\n        List<Integer>[] g = new ArrayList[n];\\n        for(int i=0;i<n;i++) g[i] = new ArrayList<>();\\n        for(int[] edge:edges){\\n            g[edge[0]].add(edge[1]);\\n            g[edge[1]].add(edge[0]);\\n        }\\n\\n        int cnt = 0;\\n        int[] vis = new int[n];\\n        moveToZero(bob, -1, 1, vis, g);\\n        return (int) dfs(0, -1, 1, vis, g, amount);\\n    }\\n\\n    boolean moveToZero(int src,int parent,int level,int[] vis,List<Integer>[] g){\\n        if(src==0){\\n            vis[src] = level;\\n            return true;\\n        }\\n\\n        vis[src] = level;\\n\\n        for(int n : g[src]){\\n            if(parent != n){\\n                if(moveToZero(n, src, level + 1, vis, g) == true) return true;\\n            }\\n        }\\n\\n        vis[src] = 0;\\n        return false;\\n    }\\n\\n    long dfs(int src, int parent, int level, int[] vis, List<Integer>[] g, int[] amt){\\n        long cost = 0;\\n\\n        if(vis[src] == 0){\\n            cost = cost + amt[src];\\n        }\\n        else if(vis[src] > level){\\n            cost = cost + amt[src];\\n        }\\n        else if(vis[src] == level){\\n            cost = cost + amt[src]/2;\\n        }\\n\\n        long current = -1000000000;\\n        for(int n:g[src]){\\n            if(n!=parent){\\n                current = Math.max(dfs(n,src,level+1,vis,g,amt),current);\\n            }\\n        }\\n\\n        if(current == -1000000000){\\n            return cost;\\n        }\\n        return cost + current;\\n\\n    }\\n\\n\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n = amount.length;\\n\\n        List<Integer>[] g = new ArrayList[n];\\n        for(int i=0;i<n;i++) g[i] = new ArrayList<>();\\n        for(int[] edge:edges){\\n            g[edge[0]].add(edge[1]);\\n            g[edge[1]].add(edge[0]);\\n        }\\n\\n        int cnt = 0;\\n        int[] vis = new int[n];\\n        moveToZero(bob, -1, 1, vis, g);\\n        return (int) dfs(0, -1, 1, vis, g, amount);\\n    }\\n\\n    boolean moveToZero(int src,int parent,int level,int[] vis,List<Integer>[] g){\\n        if(src==0){\\n            vis[src] = level;\\n            return true;\\n        }\\n\\n        vis[src] = level;\\n\\n        for(int n : g[src]){\\n            if(parent != n){\\n                if(moveToZero(n, src, level + 1, vis, g) == true) return true;\\n            }\\n        }\\n\\n        vis[src] = 0;\\n        return false;\\n    }\\n\\n    long dfs(int src, int parent, int level, int[] vis, List<Integer>[] g, int[] amt){\\n        long cost = 0;\\n\\n        if(vis[src] == 0){\\n            cost = cost + amt[src];\\n        }\\n        else if(vis[src] > level){\\n            cost = cost + amt[src];\\n        }\\n        else if(vis[src] == level){\\n            cost = cost + amt[src]/2;\\n        }\\n\\n        long current = -1000000000;\\n        for(int n:g[src]){\\n            if(n!=parent){\\n                current = Math.max(dfs(n,src,level+1,vis,g,amt),current);\\n            }\\n        }\\n\\n        if(current == -1000000000){\\n            return cost;\\n        }\\n        return cost + current;\\n\\n    }\\n\\n\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709992,
                "title": "simple-c-solution-bfs-incoming-and-outgoing-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        vector<int>sides[amount.size()];\\n        for(int i=0;i<edges.size();i++){\\n            sides[edges[i][0]].push_back(edges[i][1]);\\n            sides[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        queue<int>q;\\n        vector<int>visited(amount.size(),0);\\n vector<int>parents(amount.size(),-1);\\n vector<int>time_bob(amount.size(),-1);     \\n q.push(0);\\n visited[0]=-1;\\n while(q.size()!=0){\\n     auto it=q.front();\\n     q.pop();\\n     for(int i=0;i<sides[it].size();i++){\\n         if(visited[sides[it][i]]!=-1){\\n             visited[sides[it][i]]=-1;\\n             q.push(sides[it][i]);\\n             parents[sides[it][i]]=it;\\n         }\\n     }\\n }  \\n queue<pair<int,int>>qbob;\\n qbob.push({bob,0});\\n time_bob[bob]=0;\\n while(qbob.size()!=0){\\n     auto it=qbob.front();\\n     int node=it.first;\\n     int time=it.second;\\n     qbob.pop();\\n     if(node==0)break;\\n     int next=parents[node];\\n     time_bob[next]=time+1;\\n     qbob.push({parents[node],time+1});\\n }\\n queue<pair<int,pair<int,int>>>qalice;\\n qalice.push({0,{0,amount[0]}});\\n int ans=-1e9;\\n  vector<int>valice(amount.size(),0);\\n  valice[0]=-1;\\n while(qalice.size()!=0){\\n     auto it=qalice.front();\\n     int node=it.first;\\n     int time=it.second.first;\\n     int score=it.second.second;\\n     qalice.pop();\\n     if(sides[node].size()==1 && node!=0){\\n         ans=max(ans,score);\\n     }\\n     for(int i=0;i<sides[node].size();i++){\\n         if(valice[sides[node][i]]!=-1){\\n             int tbob=time_bob[sides[node][i]];\\n             int talice=time+1;\\n             if(tbob==-1){\\n                 qalice.push({sides[node][i],{time+1,score+amount[sides[node][i]]}});\\n                 valice[sides[node][i]]=-1;\\n             }   \\n             else if(tbob!=-1){\\n                 if(talice==tbob){\\n            qalice.push({sides[node][i],{time+1,score+(amount[sides[node][i]])/2}});\\n                 valice[sides[node][i]]=-1;\\n                 }\\n                 else if(talice>tbob){\\n                     qalice.push({sides[node][i],{time+1,score}});\\n                 valice[sides[node][i]]=-1;\\n                 }\\n                 else if(talice<tbob){\\n                     qalice.push({sides[node][i],{time+1,score+amount[sides[node][i]]}});\\n                 valice[sides[node][i]]=-1;\\n                 }\\n             }\\n         }\\n         \\n     }\\n }\\n \\n return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        vector<int>sides[amount.size()];\\n        for(int i=0;i<edges.size();i++){\\n            sides[edges[i][0]].push_back(edges[i][1]);\\n            sides[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        queue<int>q;\\n        vector<int>visited(amount.size(),0);\\n vector<int>parents(amount.size(),-1);\\n vector<int>time_bob(amount.size(),-1);     \\n q.push(0);\\n visited[0]=-1;\\n while(q.size()!=0){\\n     auto it=q.front();\\n     q.pop();\\n     for(int i=0;i<sides[it].size();i++){\\n         if(visited[sides[it][i]]!=-1){\\n             visited[sides[it][i]]=-1;\\n             q.push(sides[it][i]);\\n             parents[sides[it][i]]=it;\\n         }\\n     }\\n }  \\n queue<pair<int,int>>qbob;\\n qbob.push({bob,0});\\n time_bob[bob]=0;\\n while(qbob.size()!=0){\\n     auto it=qbob.front();\\n     int node=it.first;\\n     int time=it.second;\\n     qbob.pop();\\n     if(node==0)break;\\n     int next=parents[node];\\n     time_bob[next]=time+1;\\n     qbob.push({parents[node],time+1});\\n }\\n queue<pair<int,pair<int,int>>>qalice;\\n qalice.push({0,{0,amount[0]}});\\n int ans=-1e9;\\n  vector<int>valice(amount.size(),0);\\n  valice[0]=-1;\\n while(qalice.size()!=0){\\n     auto it=qalice.front();\\n     int node=it.first;\\n     int time=it.second.first;\\n     int score=it.second.second;\\n     qalice.pop();\\n     if(sides[node].size()==1 && node!=0){\\n         ans=max(ans,score);\\n     }\\n     for(int i=0;i<sides[node].size();i++){\\n         if(valice[sides[node][i]]!=-1){\\n             int tbob=time_bob[sides[node][i]];\\n             int talice=time+1;\\n             if(tbob==-1){\\n                 qalice.push({sides[node][i],{time+1,score+amount[sides[node][i]]}});\\n                 valice[sides[node][i]]=-1;\\n             }   \\n             else if(tbob!=-1){\\n                 if(talice==tbob){\\n            qalice.push({sides[node][i],{time+1,score+(amount[sides[node][i]])/2}});\\n                 valice[sides[node][i]]=-1;\\n                 }\\n                 else if(talice>tbob){\\n                     qalice.push({sides[node][i],{time+1,score}});\\n                 valice[sides[node][i]]=-1;\\n                 }\\n                 else if(talice<tbob){\\n                     qalice.push({sides[node][i],{time+1,score+amount[sides[node][i]]}});\\n                 valice[sides[node][i]]=-1;\\n                 }\\n             }\\n         }\\n         \\n     }\\n }\\n \\n return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663792,
                "title": "c-dfs-bfs-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int node,int time,vector<int> &vis,map<int,int>&path,vector<int> adj[]){\\n        vis[node]=1;\\n        path[node]=time;\\n        if(node==0){\\n            return true;\\n        }\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                if(dfs(it,time+1,vis,path,adj)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        path.erase(node);\\n        return false;\\n    } \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n    int n=amount.size();\\n    vector<int>adj[n];\\n    for(auto it:edges){\\n        adj[it[0]].push_back(it[1]);\\n        adj[it[1]].push_back(it[0]);\\n    }\\n    vector<int> vis(n,0);\\n    map<int,int> path; //path and time\\n    dfs(bob,0,vis,path,adj);\\n\\n\\n    queue<vector<int>>q;\\n    q.push({0,0,0});\\n    vector<int> vis1(n,0);\\n    int ans=INT_MIN;\\n    while(!q.empty()){  //Alice traversal\\n    vector<int> v=q.front();\\n    int node=v[0];\\n    int time=v[1];\\n    int tot=v[2];\\n    q.pop();\\n    vis1[node]=1;\\n    if(path.find(node)==path.end()){\\n       tot+=amount[node]; \\n    } else{\\n        if(time<path[node]){\\n            tot+=amount[node];\\n        } else if(time==path[node]){\\n            tot+=(amount[node]/2);\\n        }\\n    } // else bob will not pay as it is already open\\n\\n    if(adj[node].size()==1 and node!=0){ //reach last and not further connected  node 0\\n        ans=max(ans,tot);\\n    } \\n    for(auto it:adj[node]){\\n        if(!vis1[it]){\\n            q.push({it,time+1,tot});\\n        }\\n    }\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int node,int time,vector<int> &vis,map<int,int>&path,vector<int> adj[]){\\n        vis[node]=1;\\n        path[node]=time;\\n        if(node==0){\\n            return true;\\n        }\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                if(dfs(it,time+1,vis,path,adj)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        path.erase(node);\\n        return false;\\n    } \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n    int n=amount.size();\\n    vector<int>adj[n];\\n    for(auto it:edges){\\n        adj[it[0]].push_back(it[1]);\\n        adj[it[1]].push_back(it[0]);\\n    }\\n    vector<int> vis(n,0);\\n    map<int,int> path; //path and time\\n    dfs(bob,0,vis,path,adj);\\n\\n\\n    queue<vector<int>>q;\\n    q.push({0,0,0});\\n    vector<int> vis1(n,0);\\n    int ans=INT_MIN;\\n    while(!q.empty()){  //Alice traversal\\n    vector<int> v=q.front();\\n    int node=v[0];\\n    int time=v[1];\\n    int tot=v[2];\\n    q.pop();\\n    vis1[node]=1;\\n    if(path.find(node)==path.end()){\\n       tot+=amount[node]; \\n    } else{\\n        if(time<path[node]){\\n            tot+=amount[node];\\n        } else if(time==path[node]){\\n            tot+=(amount[node]/2);\\n        }\\n    } // else bob will not pay as it is already open\\n\\n    if(adj[node].size()==1 and node!=0){ //reach last and not further connected  node 0\\n        ans=max(ans,tot);\\n    } \\n    for(auto it:adj[node]){\\n        if(!vis1[it]){\\n            q.push({it,time+1,tot});\\n        }\\n    }\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633407,
                "title": "simple-dfs-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int src,unordered_map<int,vector<int>> &mp,vector<int>&visi,vector<int> &time,int t){\\n        visi[src]=1;\\n        if(src==0){\\n            time[0]=t;\\n            return true;\\n        }\\n        bool f = false;\\n        for(auto x:mp[src]){\\n            if(!visi[x]){\\n                if(dfs(x,mp,visi,time,t+1)){\\n                    f = true;\\n                }\\n            }\\n        }\\n        if(f){\\n            time[src]=t;\\n        }\\n        return f;\\n    }\\n    int ans = INT_MIN;\\n    void dfs2(int src,unordered_map<int,vector<int>> &mp,vector<int>&visi,vector<int> &time,int t,vector<int>&amt,int sum){\\n        visi[src]=1;\\n        if(time[src]==-1){\\n            sum+=amt[src];\\n        }\\n        else{\\n            if(time[src]>t){\\n                sum+=amt[src];\\n            }\\n            else if(time[src]==t){\\n                sum+= (amt[src]/2);\\n            }\\n            else{\\n                sum+=0;\\n            }\\n        }\\n        int c = 0;\\n        for(auto x:mp[src]){\\n            if(!visi[x]){\\n                c++;\\n                dfs2(x,mp,visi,time,t+1,amt,sum);\\n            }\\n        }\\n        if(c==0){\\n            ans = max(ans,sum);\\n        }\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = amount.size();\\n        for(auto x:edges){\\n            mp[x[0]].push_back(x[1]);\\n            mp[x[1]].push_back(x[0]);\\n        }\\n        vector<int> visi(n,0);\\n        vector<int> time(n,-1);\\n        dfs(bob,mp,visi,time,0);\\n        for(auto& x:visi){\\n            x=0;\\n        }\\n        dfs2(0,mp,visi,time,0,amount,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int src,unordered_map<int,vector<int>> &mp,vector<int>&visi,vector<int> &time,int t){\\n        visi[src]=1;\\n        if(src==0){\\n            time[0]=t;\\n            return true;\\n        }\\n        bool f = false;\\n        for(auto x:mp[src]){\\n            if(!visi[x]){\\n                if(dfs(x,mp,visi,time,t+1)){\\n                    f = true;\\n                }\\n            }\\n        }\\n        if(f){\\n            time[src]=t;\\n        }\\n        return f;\\n    }\\n    int ans = INT_MIN;\\n    void dfs2(int src,unordered_map<int,vector<int>> &mp,vector<int>&visi,vector<int> &time,int t,vector<int>&amt,int sum){\\n        visi[src]=1;\\n        if(time[src]==-1){\\n            sum+=amt[src];\\n        }\\n        else{\\n            if(time[src]>t){\\n                sum+=amt[src];\\n            }\\n            else if(time[src]==t){\\n                sum+= (amt[src]/2);\\n            }\\n            else{\\n                sum+=0;\\n            }\\n        }\\n        int c = 0;\\n        for(auto x:mp[src]){\\n            if(!visi[x]){\\n                c++;\\n                dfs2(x,mp,visi,time,t+1,amt,sum);\\n            }\\n        }\\n        if(c==0){\\n            ans = max(ans,sum);\\n        }\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = amount.size();\\n        for(auto x:edges){\\n            mp[x[0]].push_back(x[1]);\\n            mp[x[1]].push_back(x[0]);\\n        }\\n        vector<int> visi(n,0);\\n        vector<int> time(n,-1);\\n        dfs(bob,mp,visi,time,0);\\n        for(auto& x:visi){\\n            x=0;\\n        }\\n        dfs2(0,mp,visi,time,0,amount,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618090,
                "title": "trees-java-dfs-3-traversal-max-path",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\nList<List<Integer>>Graph=new ArrayList<>();\\n\\n        int n=edges.length;\\n        for(int i=0;i<=n;i++){\\n\\n            Graph.add(new ArrayList<Integer>());\\n\\n        }\\n\\n        for(int []e:edges){\\n            int u=e[0];\\n            int v=e[1];\\n            Graph.get(u).add(v);\\n            Graph.get(v).add(u);\\n        }\\n\\n     \\n\\n        int min=minDistance(0,-1,Graph,0,bob);\\n      find(0,-1,Graph,0,bob,min,amount);\\n      return minScore(0,-1,Graph,amount);\\n    }\\n\\n    public int minDistance(int root,int parent,List<List<Integer>>Graph,int dis,int target){\\n\\n        if(root==target){\\n            return dis;\\n        }\\n        int max=Integer.MIN_VALUE;\\n\\n        for(int nbr:Graph.get(root)){\\n\\n            if(nbr!=parent){\\n         max=Math.max(max,minDistance(nbr,root,Graph,dis+1,target));\\n            }\\n\\n        }\\n\\n        return max;\\n    }\\n\\n    public boolean find(int root,int parent,List<List<Integer>>Graph,int dis,int target,int min,int []amount){\\n\\n        if(root==target){\\n\\n            if(dis==0){\\n                amount[root]/=2;\\n            }\\n            else{\\n             amount[root]=0;\\n            }   \\n            return true;\\n\\n\\n        }\\n\\n        for(int nbr:Graph.get(root)){\\n\\n            if(nbr!=parent){\\n   boolean f=find(nbr,root,Graph,dis+1,target,min,amount);\\n\\n   if(f){\\n\\n       if(dis>min/2){\\n           amount[root]=0;\\n       }\\n\\n       if(dis==min/2){\\n           if(min%2==0){\\n               amount[root]/=2;\\n           }\\n           \\n\\n       }\\n\\n       return true;\\n   }\\n            }\\n         \\n        }\\n\\n\\n        return false;\\n\\n    }\\n\\n\\npublic int minScore(int root,int parent,List<List<Integer>>Graph,int []amount){\\n\\n    if(parent!=-1&&Graph.get(root).size()==1){\\n        // System.out.println(\"leaf\"+\" \"+root);\\n        return amount[root];\\n    }\\n    \\n    int max=Integer.MIN_VALUE;\\n    for(int nbr:Graph.get(root)){\\n\\n        if(nbr!=parent){\\n  int x1=amount[root]+minScore(nbr,root,Graph,amount);\\n\\nmax=Math.max(max,x1);\\n        }\\n    }\\nreturn max;\\n\\n\\n}\\n\\n\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\nList<List<Integer>>Graph=new ArrayList<>();\\n\\n        int n=edges.length;\\n        for(int i=0;i<=n;i++){\\n\\n            Graph.add(new ArrayList<Integer>());\\n\\n        }\\n\\n        for(int []e:edges){\\n            int u=e[0];\\n            int v=e[1];\\n            Graph.get(u).add(v);\\n            Graph.get(v).add(u);\\n        }\\n\\n     \\n\\n        int min=minDistance(0,-1,Graph,0,bob);\\n      find(0,-1,Graph,0,bob,min,amount);\\n      return minScore(0,-1,Graph,amount);\\n    }\\n\\n    public int minDistance(int root,int parent,List<List<Integer>>Graph,int dis,int target){\\n\\n        if(root==target){\\n            return dis;\\n        }\\n        int max=Integer.MIN_VALUE;\\n\\n        for(int nbr:Graph.get(root)){\\n\\n            if(nbr!=parent){\\n         max=Math.max(max,minDistance(nbr,root,Graph,dis+1,target));\\n            }\\n\\n        }\\n\\n        return max;\\n    }\\n\\n    public boolean find(int root,int parent,List<List<Integer>>Graph,int dis,int target,int min,int []amount){\\n\\n        if(root==target){\\n\\n            if(dis==0){\\n                amount[root]/=2;\\n            }\\n            else{\\n             amount[root]=0;\\n            }   \\n            return true;\\n\\n\\n        }\\n\\n        for(int nbr:Graph.get(root)){\\n\\n            if(nbr!=parent){\\n   boolean f=find(nbr,root,Graph,dis+1,target,min,amount);\\n\\n   if(f){\\n\\n       if(dis>min/2){\\n           amount[root]=0;\\n       }\\n\\n       if(dis==min/2){\\n           if(min%2==0){\\n               amount[root]/=2;\\n           }\\n           \\n\\n       }\\n\\n       return true;\\n   }\\n            }\\n         \\n        }\\n\\n\\n        return false;\\n\\n    }\\n\\n\\npublic int minScore(int root,int parent,List<List<Integer>>Graph,int []amount){\\n\\n    if(parent!=-1&&Graph.get(root).size()==1){\\n        // System.out.println(\"leaf\"+\" \"+root);\\n        return amount[root];\\n    }\\n    \\n    int max=Integer.MIN_VALUE;\\n    for(int nbr:Graph.get(root)){\\n\\n        if(nbr!=parent){\\n  int x1=amount[root]+minScore(nbr,root,Graph,amount);\\n\\nmax=Math.max(max,x1);\\n        }\\n    }\\nreturn max;\\n\\n\\n}\\n\\n\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592649,
                "title": "backtracking-bfs-dfs",
                "content": "- # Intuition\\nThis is an excellent problem that tests your understanding of graphs, how to build graphs, backtracking, dfs, bfs and when to use what. \\nBob can take only one path from his start node all the way to the root since the nodes form a tree. Alice can choose multiple paths and the cost Alice incurs will be impacted by bob\\'s path. (As both will share the costs when they reach the nodes at the same time, or Alice will pay nil if bob has already visited that node.) So can we find Bob\\'s path first and calculate the distances (time) that he will reach each node on his path as a first step?\\nThen as a next step can we also find the times when Alice will reach every other node of the graph from her starting point?\\nOnce we have these two pieces, we can adjust the amount that Alice will incur for each node. Finally we need to find the maximum profitable path for Alice.\\n\\nThis is an undirected graph. \\nWhich algorithm comes to mind to find a path straight-up from a node to its root? Bob cannot spread out to other leaves, he just needs to go upward to the root. [Backtracking with DFS]\\nWhich algorithm can we use to find distances of each node from Alice\\'s start node, remember she can choose any path and this is an undirected, unweighted graph? [BFS] \\nWhich algorithm can we use to aggregate path sums from root to leaves? [DFS]\\n\\nWhat data structures can we use to build the graph? I chose an adjacency map. An undirected graph implies we add edges from a->b and b->a while building the graph.\\nWhat other data structures do we need? \\na) The tree is modeled as an undirected graph, so we need to keep a track of visited nodes during graph traversal. \\nb) We need an arrayList to store Bob\\'s path during backtracking and we need to keep track of Bob and Alice\\'s distances from their start nodes - so we can use 2 arrays. \\n\\n# Approach\\n1. Build Graph\\n2. Initialize distance array for alice and bob\\n3. Run Backtracking + DFS to calculate Bob\\'s path\\n4. Build bob\\'s distance array using this path. [Calculate the depth of each node from Bob\\'s starting point, on this path. ]\\n5. Run BFS from root to calculate Alice\\'s distances to each node\\n6. Update the amount array to reflect the cost incurred by Alice. For \\neach node, if alice reaches first, nothing changes, but if they reach at the same time or if bob reaches first, alice has an advantage. \\n7. Finally run a DFS to aggregate path sums and find max profitable path for Alice.\\n\\nI don\\'t know if this is the most optimal solution. \\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n = amount.length; \\n        \\n        //build graph\\n        Map<Integer, List<Integer>> graph = buildGraph(edges);\\n        \\n        //initialize distance array for alice and bob\\n        int[] aliceDis = new int[n];\\n        Arrays.fill(aliceDis, -1);\\n        int[] bobDis = new int[n];\\n        Arrays.fill(bobDis, -1);\\n\\n        //run DFS to calculate bob\\'s path\\n        List<Integer> bobPath = new ArrayList<>();\\n        findBobsPath(bob, graph, new HashSet<Integer>(), new ArrayList<>(), bobPath);\\n\\n        //now calculate the distance of each node on bob\\'s path from the start node \\n        for (int i = 0; i < bobPath.size(); i++) {\\n            bobDis[bobPath.get(i)] = i;\\n        }\\n        \\n        //run BFS from root to calculate alice\\'s distances to each node\\n        bfs(0, graph, aliceDis);\\n\\n        //update amounts of node for alice as per bob\\'s path\\n        //for each node, if alice reaches first, nothing changes, but if they reach at the same time or if bob reaches first, alice has an advantage. \\n        for (int i = 0; i < n; i++) {\\n            if (bobDis[i] == -1) {\\n                continue;\\n            }  else if (aliceDis[i] == bobDis[i]) { //both alice and bob will share the debit/credit for equidistant nodes\\n                amount[i]/=2; \\n            } else if (aliceDis[i] > bobDis[i]) { //bob will open the gates for all nodes that he can reach earlier than alice\\n                amount[i] = 0;\\n            }\\n        }\\n\\n        //run a dfs from 0 and return max path sum for Alice\\n        Set<Integer> visited = new HashSet<>();\\n        return maxPathSum(0, graph, amount, visited);\\n    }\\n\\n    //backtracking + DFS\\n    private void findBobsPath(int node, Map<Integer, List<Integer>> graph,  Set<Integer> visited, List<Integer> path, List<Integer> bobPath){\\n        visited.add(node);\\n        path.add(node);\\n        if(node == 0) { //bob has reached destination, report unique path to result\\n            bobPath.addAll(path);\\n            return;\\n        }\\n        for (int neighbour : graph.get(node)) {\\n            if (!visited.contains(neighbour)) {\\n                findBobsPath(neighbour, graph, visited, path, bobPath);\\n            }\\n        }\\n        path.remove(path.size()-1);\\n    }\\n\\n    private Map<Integer, List<Integer>> buildGraph(int[][] edges) {\\n        int n = edges.length;\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n+1; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for (int[] e : edges){\\n            graph.get(e[0]).add(e[1]);\\n            graph.get(e[1]).add(e[0]);\\n        }\\n        return graph;\\n    }\\n\\n    private void bfs(int start, Map<Integer, List<Integer>> graph, int[] distances) {\\n        int n = distances.length;\\n        distances[start] = 0;\\n        Deque<Integer> q = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n];\\n        int level = 0;\\n        q.offer(start);\\n        visited[start] = true;\\n        while (!q.isEmpty()) {\\n            int qSize = q.size();\\n            for (int i = 0; i < qSize; i++) {\\n                int node = q.poll();\\n                distances[node] = level;\\n                for (int neighbour : graph.get(node)) {\\n                    if (!visited[neighbour]) {\\n                        q.offer(neighbour);\\n                        visited[neighbour] = true;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    }\\n\\n    //DFS\\n    private int maxPathSum(int node, Map<Integer, List<Integer>> graph, int[] amount, Set<Integer> visited) {\\n        visited.add(node);\\n        int maxSum = Integer.MIN_VALUE;\\n        for (int neighbour : graph.get(node)) {\\n            if (!visited.contains(neighbour)) {\\n                int maxForwardSum = maxPathSum(neighbour, graph, amount, visited);\\n                maxSum = Math.max(maxSum, maxForwardSum);\\n            }\\n        }\\n        return maxSum == Integer.MIN_VALUE ? amount[node] : maxSum + amount[node];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n = amount.length; \\n        \\n        //build graph\\n        Map<Integer, List<Integer>> graph = buildGraph(edges);\\n        \\n        //initialize distance array for alice and bob\\n        int[] aliceDis = new int[n];\\n        Arrays.fill(aliceDis, -1);\\n        int[] bobDis = new int[n];\\n        Arrays.fill(bobDis, -1);\\n\\n        //run DFS to calculate bob\\'s path\\n        List<Integer> bobPath = new ArrayList<>();\\n        findBobsPath(bob, graph, new HashSet<Integer>(), new ArrayList<>(), bobPath);\\n\\n        //now calculate the distance of each node on bob\\'s path from the start node \\n        for (int i = 0; i < bobPath.size(); i++) {\\n            bobDis[bobPath.get(i)] = i;\\n        }\\n        \\n        //run BFS from root to calculate alice\\'s distances to each node\\n        bfs(0, graph, aliceDis);\\n\\n        //update amounts of node for alice as per bob\\'s path\\n        //for each node, if alice reaches first, nothing changes, but if they reach at the same time or if bob reaches first, alice has an advantage. \\n        for (int i = 0; i < n; i++) {\\n            if (bobDis[i] == -1) {\\n                continue;\\n            }  else if (aliceDis[i] == bobDis[i]) { //both alice and bob will share the debit/credit for equidistant nodes\\n                amount[i]/=2; \\n            } else if (aliceDis[i] > bobDis[i]) { //bob will open the gates for all nodes that he can reach earlier than alice\\n                amount[i] = 0;\\n            }\\n        }\\n\\n        //run a dfs from 0 and return max path sum for Alice\\n        Set<Integer> visited = new HashSet<>();\\n        return maxPathSum(0, graph, amount, visited);\\n    }\\n\\n    //backtracking + DFS\\n    private void findBobsPath(int node, Map<Integer, List<Integer>> graph,  Set<Integer> visited, List<Integer> path, List<Integer> bobPath){\\n        visited.add(node);\\n        path.add(node);\\n        if(node == 0) { //bob has reached destination, report unique path to result\\n            bobPath.addAll(path);\\n            return;\\n        }\\n        for (int neighbour : graph.get(node)) {\\n            if (!visited.contains(neighbour)) {\\n                findBobsPath(neighbour, graph, visited, path, bobPath);\\n            }\\n        }\\n        path.remove(path.size()-1);\\n    }\\n\\n    private Map<Integer, List<Integer>> buildGraph(int[][] edges) {\\n        int n = edges.length;\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n+1; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for (int[] e : edges){\\n            graph.get(e[0]).add(e[1]);\\n            graph.get(e[1]).add(e[0]);\\n        }\\n        return graph;\\n    }\\n\\n    private void bfs(int start, Map<Integer, List<Integer>> graph, int[] distances) {\\n        int n = distances.length;\\n        distances[start] = 0;\\n        Deque<Integer> q = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n];\\n        int level = 0;\\n        q.offer(start);\\n        visited[start] = true;\\n        while (!q.isEmpty()) {\\n            int qSize = q.size();\\n            for (int i = 0; i < qSize; i++) {\\n                int node = q.poll();\\n                distances[node] = level;\\n                for (int neighbour : graph.get(node)) {\\n                    if (!visited[neighbour]) {\\n                        q.offer(neighbour);\\n                        visited[neighbour] = true;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    }\\n\\n    //DFS\\n    private int maxPathSum(int node, Map<Integer, List<Integer>> graph, int[] amount, Set<Integer> visited) {\\n        visited.add(node);\\n        int maxSum = Integer.MIN_VALUE;\\n        for (int neighbour : graph.get(node)) {\\n            if (!visited.contains(neighbour)) {\\n                int maxForwardSum = maxPathSum(neighbour, graph, amount, visited);\\n                maxSum = Math.max(maxSum, maxForwardSum);\\n            }\\n        }\\n        return maxSum == Integer.MIN_VALUE ? amount[node] : maxSum + amount[node];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526971,
                "title": "c-based-easy-solution-o-v-time-o-v-space",
                "content": "# Intuition\\n The things to be observed here are :\\n1. The given graph is a tree (undirected,cyclic,connected)\\n2. Bob constantly moves in one direction i.e. to approach the root node 0.\\n\\n# Approach\\nAs the given graph is a tree there exists a unique path between 0 and bob. Because bob always moves towards 0 his actions are defined during the game.\\nlet the vertices visited by bob be v1,v2,v3....vl consisting of l vertices where v1=0 and vl=bob.\\nNow alice has multiple paths to reach a leaf. Had the question not involved bob we could have computed maxpathsum easily. But with the involvement of Bob we can still apply the same procedure but we would have to modify the amount array accordingly.\\nThe problem arises only in cases where the path containing bob is involved.\\nso we modify the array as follows:\\nif(l is even): we set amount of later half of array to 0\\nelse: we set amount of middle element as half and later half as 0\\n\\n# Complexity\\n- Time complexity:\\ngraph construction =O(V) (as it is a tree number of edges=V-1);\\npath finding =O(V);\\nchanging amount array: O(V/2) (as path length can at max be V);\\ncomputing sums : O(V);\\noverall linear complexity\\n- Space complexity:\\nO(V) for adjacency list;\\nO(V) for path;\\nO(V) call stack of fetch_path;\\nO(V) call stack of function f;\\n**VISITED ARRAY CAN BE AVOIDED AS IT IS A TREE. MAINTAINING A PARENT WOULD BE ENOUGH**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool fetch_path(int sv,vector<int>&path,int parent,vector<vector<int>>&adj,int bob){\\n        path.push_back(sv);\\n        if(sv==bob){\\n            return true;\\n        }\\n        for(int i=0;i<adj[sv].size();i++){\\n            if(adj[sv][i]!=parent){\\n                if(fetch_path(adj[sv][i],path,sv,adj,bob)){\\n                    return true;\\n                }\\n            }\\n        }\\n        path.pop_back();\\n        return false;\\n    }\\n    int f(int sv,vector<int>&amount,vector<vector<int>>&adj,int parent){\\n        int current=amount[sv];\\n        int ans=INT_MIN;\\n        for(int i=0;i<adj[sv].size();i++){\\n            if(adj[sv][i]!=parent){\\n                ans=max(ans,f(adj[sv][i],amount,adj,sv));\\n            }\\n        }\\n        if(ans==INT_MIN){\\n            return current;\\n        }\\n        return ans+current;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // vector<int>visited(n,0);\\n        vector<int>path;\\n        fetch_path(0,path,-1,adj,bob);\\n        int l=path.size();\\n        if(l%2==0){\\n            for(int i=l/2;i<l;i++){\\n                amount[path[i]]=0;\\n            }\\n        }\\n        else{\\n            amount[path[l/2]]=(amount[path[l/2]])/2;\\n            for(int i=(l+1)/2;i<l;i++){\\n                amount[path[i]]=0;\\n            }\\n        }\\n        //vector<int>visited2(n,0);\\n        return f(0,amount,adj,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool fetch_path(int sv,vector<int>&path,int parent,vector<vector<int>>&adj,int bob){\\n        path.push_back(sv);\\n        if(sv==bob){\\n            return true;\\n        }\\n        for(int i=0;i<adj[sv].size();i++){\\n            if(adj[sv][i]!=parent){\\n                if(fetch_path(adj[sv][i],path,sv,adj,bob)){\\n                    return true;\\n                }\\n            }\\n        }\\n        path.pop_back();\\n        return false;\\n    }\\n    int f(int sv,vector<int>&amount,vector<vector<int>>&adj,int parent){\\n        int current=amount[sv];\\n        int ans=INT_MIN;\\n        for(int i=0;i<adj[sv].size();i++){\\n            if(adj[sv][i]!=parent){\\n                ans=max(ans,f(adj[sv][i],amount,adj,sv));\\n            }\\n        }\\n        if(ans==INT_MIN){\\n            return current;\\n        }\\n        return ans+current;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // vector<int>visited(n,0);\\n        vector<int>path;\\n        fetch_path(0,path,-1,adj,bob);\\n        int l=path.size();\\n        if(l%2==0){\\n            for(int i=l/2;i<l;i++){\\n                amount[path[i]]=0;\\n            }\\n        }\\n        else{\\n            amount[path[l/2]]=(amount[path[l/2]])/2;\\n            for(int i=(l+1)/2;i<l;i++){\\n                amount[path[i]]=0;\\n            }\\n        }\\n        //vector<int>visited2(n,0);\\n        return f(0,amount,adj,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524965,
                "title": "easy-python-solution-w-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n\\n        res = float(-inf)\\n\\n        adjList = defaultdict(list)\\n        for node1, node2 in edges:\\n            # adj list for tree\\n            adjList[node1].append(node2)\\n            adjList[node2].append(node1)\\n\\n        bobPath = {}\\n\\n        # create bob path\\n        def createBobPath(curNode, curPath, steps):\\n            # if reached root, copy curPath to bobPath\\n            if curNode == 0:\\n                nonlocal bobPath\\n                bobPath = curPath.copy()\\n                return\\n\\n            # iterate through all possible adjNodes \\n            for adjNode in adjList[curNode]:\\n                # make sure to repeat nodes in cur path\\n                if adjNode not in curPath:\\n                    curPath[adjNode] = steps+1 \\n                    createBobPath(adjNode, curPath, steps+1)\\n                    del curPath[adjNode]\\n\\n        createBobPath(bob, {bob:0}, 0)\\n\\n        def alice(curNode, curAmt, curSteps, visited):\\n            # create the amt gained from current node based off of bobs path\\n            amtFromCurNode = 0\\n            # if curNode not in  bobPath or curSteps < his steps we got there before him, take full amount\\n            if curNode not in bobPath or curSteps < bobPath[curNode]:\\n                amtFromCurNode = amount[curNode]\\n            # if equal, we are there at same time, take half\\n            elif curSteps == bobPath[curNode]:\\n                amtFromCurNode = amount[curNode]//2\\n\\n            # if leaf node, see if its max\\n            if len(adjList[curNode]) == 1 and adjList[curNode][0] in visited:\\n                nonlocal res\\n                res = max(res, curAmt+amtFromCurNode)\\n\\n            # visit all adj nodes\\n            for childNode in adjList[curNode]:\\n                if childNode not in visited:\\n                    visited.add(childNode)\\n                    alice(childNode, curAmt+amtFromCurNode, curSteps+1, visited)\\n                    visited.remove(childNode)\\n\\n        alice(0, 0, 0, {0})\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n\\n        res = float(-inf)\\n\\n        adjList = defaultdict(list)\\n        for node1, node2 in edges:\\n            # adj list for tree\\n            adjList[node1].append(node2)\\n            adjList[node2].append(node1)\\n\\n        bobPath = {}\\n\\n        # create bob path\\n        def createBobPath(curNode, curPath, steps):\\n            # if reached root, copy curPath to bobPath\\n            if curNode == 0:\\n                nonlocal bobPath\\n                bobPath = curPath.copy()\\n                return\\n\\n            # iterate through all possible adjNodes \\n            for adjNode in adjList[curNode]:\\n                # make sure to repeat nodes in cur path\\n                if adjNode not in curPath:\\n                    curPath[adjNode] = steps+1 \\n                    createBobPath(adjNode, curPath, steps+1)\\n                    del curPath[adjNode]\\n\\n        createBobPath(bob, {bob:0}, 0)\\n\\n        def alice(curNode, curAmt, curSteps, visited):\\n            # create the amt gained from current node based off of bobs path\\n            amtFromCurNode = 0\\n            # if curNode not in  bobPath or curSteps < his steps we got there before him, take full amount\\n            if curNode not in bobPath or curSteps < bobPath[curNode]:\\n                amtFromCurNode = amount[curNode]\\n            # if equal, we are there at same time, take half\\n            elif curSteps == bobPath[curNode]:\\n                amtFromCurNode = amount[curNode]//2\\n\\n            # if leaf node, see if its max\\n            if len(adjList[curNode]) == 1 and adjList[curNode][0] in visited:\\n                nonlocal res\\n                res = max(res, curAmt+amtFromCurNode)\\n\\n            # visit all adj nodes\\n            for childNode in adjList[curNode]:\\n                if childNode not in visited:\\n                    visited.add(childNode)\\n                    alice(childNode, curAmt+amtFromCurNode, curSteps+1, visited)\\n                    visited.remove(childNode)\\n\\n        alice(0, 0, 0, {0})\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519655,
                "title": "easy-java-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst search for the path from $$0$$ to $$bob$$ using dfs ,while doing the same keep the array d,to keep track of when will the bob come to that node(in the reverse order of going from  $$0$$ to $$bob$$ so i use the return value from the function).\\nThen again do $$dfs$$ for $$Alice$$ where he checks whether bob comes to that node or not,if he comes when will he come using $$d$$ array.Accordingly calculates the amount.Then it is the simple dfs..\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N+N+2*N)~O(2*N) for adjacency List..\\n\\n# Code\\n```\\nclass Solution {\\n    int[] d;\\n    int df(List<List<Integer>>l, int i,int[]v,int B){\\n        if(i==B){\\n            d[i]=1;\\n            return 1;\\n        }\\n        v[i]=1;\\n        for(int j=0;j<l.get(i).size();j++){\\n            if(v[l.get(i).get(j)]==0){\\n                int x= df(l,l.get(i).get(j),v,B);\\n                if(x!=0){\\n                d[i]=x+1;\\n                break;}\\n            }\\n        }\\n        return d[i]==0?0:d[i];\\n    }\\n    int dfs(List<List<Integer>> l,int i,int c,int[] a,int[] v){\\n        v[i]=1;\\n        int cost =a[i];\\n            if(d[i]==c)\\n            cost=(a[i]/2);\\n            if(d[i]!=0 && d[i]<c)cost=0;\\n        int x=0,g=Integer.MIN_VALUE;\\n        for(int j:l.get(i)){\\n            if(v[j]==0){                \\n                g = Math.max(g,cost+dfs(l,j,c+1,a,v));\\n            }\\n        }\\n        return g==Integer.MIN_VALUE?cost:g;\\n    }\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        d =new int[amount.length];\\n        List<List<Integer>> l = new ArrayList<>();\\n        for(int i=0;i<amount.length;i++)\\n        l.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++){\\n            l.get(edges[i][0]).add(edges[i][1]);\\n            l.get(edges[i][1]).add(edges[i][0]);\\n\\n        }\\n        int[] v = new int[amount.length];\\n        df(l,0,v,bob);\\n        Arrays.fill(v,0);\\n        return dfs(l,0,1,amount,v);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] d;\\n    int df(List<List<Integer>>l, int i,int[]v,int B){\\n        if(i==B){\\n            d[i]=1;\\n            return 1;\\n        }\\n        v[i]=1;\\n        for(int j=0;j<l.get(i).size();j++){\\n            if(v[l.get(i).get(j)]==0){\\n                int x= df(l,l.get(i).get(j),v,B);\\n                if(x!=0){\\n                d[i]=x+1;\\n                break;}\\n            }\\n        }\\n        return d[i]==0?0:d[i];\\n    }\\n    int dfs(List<List<Integer>> l,int i,int c,int[] a,int[] v){\\n        v[i]=1;\\n        int cost =a[i];\\n            if(d[i]==c)\\n            cost=(a[i]/2);\\n            if(d[i]!=0 && d[i]<c)cost=0;\\n        int x=0,g=Integer.MIN_VALUE;\\n        for(int j:l.get(i)){\\n            if(v[j]==0){                \\n                g = Math.max(g,cost+dfs(l,j,c+1,a,v));\\n            }\\n        }\\n        return g==Integer.MIN_VALUE?cost:g;\\n    }\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        d =new int[amount.length];\\n        List<List<Integer>> l = new ArrayList<>();\\n        for(int i=0;i<amount.length;i++)\\n        l.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++){\\n            l.get(edges[i][0]).add(edges[i][1]);\\n            l.get(edges[i][1]).add(edges[i][0]);\\n\\n        }\\n        int[] v = new int[amount.length];\\n        df(l,0,v,bob);\\n        Arrays.fill(v,0);\\n        return dfs(l,0,1,amount,v);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460877,
                "title": "java-dfs-clean-and-modular",
                "content": "(or at least I claim this is clean/modular.)\\n# Approach\\nBob will always go through the same path, so we can first calculate at what time he will get to a node/gate. \\n\\nNow, when Alice goes, given the current time, we can tell whether or not bob has been in the node by looking at the previous data structure.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n + e)$$ (i.e. number of nodes + number of edges in graph)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        Map<Integer, List<Integer>> graph = buildGraph(edges);\\n        int[] bobTimestamps = new int[graph.size()];\\n        goBob(graph, bob, -1, 1, bobTimestamps);\\n        return goAlice(graph, 0, -1, 1, bobTimestamps, amount);\\n    }\\n\\n    Map<Integer, List<Integer>> buildGraph(int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            graph.computeIfAbsent(edge[0], k -> new LinkedList<>()).add(edge[1]);\\n            graph.computeIfAbsent(edge[1], k -> new LinkedList<>()).add(edge[0]);\\n        }\\n        return graph;\\n    }\\n\\n    boolean goBob(\\n            Map<Integer, List<Integer>> graph, \\n            int bob, \\n            int prev, \\n            int time, \\n            int[] bobTimestamps) {\\n        bobTimestamps[bob] = time;\\n        if (bob == 0) { return true; }\\n\\n        for (int next : graph.get(bob)) {\\n            if (next == prev) { continue; }\\n            if (goBob(graph, next, bob, time + 1, bobTimestamps)) { \\n                return true; \\n            }\\n        }\\n\\n        bobTimestamps[bob] = 0;\\n        return false;\\n    }\\n\\n    int goAlice(\\n            Map<Integer, List<Integer>> graph, \\n            int alice, \\n            int prev, \\n            int time, \\n            int[] bobTimestamps,\\n            int[] amount) {\\n        int max = Integer.MIN_VALUE;\\n        for (int next : graph.get(alice)) {\\n            if (next == prev) { continue; }\\n            max = Math.max(max, goAlice(graph, next, alice, time + 1, bobTimestamps, amount));\\n        }\\n\\n        int reward = (time < bobTimestamps[alice] || bobTimestamps[alice] == 0)\\n                ? amount[alice]\\n                : time == bobTimestamps[alice]\\n                    ? amount[alice] / 2\\n                    : 0;\\n        return (max == Integer.MIN_VALUE ? 0 : max) + reward;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        Map<Integer, List<Integer>> graph = buildGraph(edges);\\n        int[] bobTimestamps = new int[graph.size()];\\n        goBob(graph, bob, -1, 1, bobTimestamps);\\n        return goAlice(graph, 0, -1, 1, bobTimestamps, amount);\\n    }\\n\\n    Map<Integer, List<Integer>> buildGraph(int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            graph.computeIfAbsent(edge[0], k -> new LinkedList<>()).add(edge[1]);\\n            graph.computeIfAbsent(edge[1], k -> new LinkedList<>()).add(edge[0]);\\n        }\\n        return graph;\\n    }\\n\\n    boolean goBob(\\n            Map<Integer, List<Integer>> graph, \\n            int bob, \\n            int prev, \\n            int time, \\n            int[] bobTimestamps) {\\n        bobTimestamps[bob] = time;\\n        if (bob == 0) { return true; }\\n\\n        for (int next : graph.get(bob)) {\\n            if (next == prev) { continue; }\\n            if (goBob(graph, next, bob, time + 1, bobTimestamps)) { \\n                return true; \\n            }\\n        }\\n\\n        bobTimestamps[bob] = 0;\\n        return false;\\n    }\\n\\n    int goAlice(\\n            Map<Integer, List<Integer>> graph, \\n            int alice, \\n            int prev, \\n            int time, \\n            int[] bobTimestamps,\\n            int[] amount) {\\n        int max = Integer.MIN_VALUE;\\n        for (int next : graph.get(alice)) {\\n            if (next == prev) { continue; }\\n            max = Math.max(max, goAlice(graph, next, alice, time + 1, bobTimestamps, amount));\\n        }\\n\\n        int reward = (time < bobTimestamps[alice] || bobTimestamps[alice] == 0)\\n                ? amount[alice]\\n                : time == bobTimestamps[alice]\\n                    ? amount[alice] / 2\\n                    : 0;\\n        return (max == Integer.MIN_VALUE ? 0 : max) + reward;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360404,
                "title": "python-dfs",
                "content": "# Approach\\n1. use DFS to find the path from root to Bob\\n2. update amounts, half the value at midway, clear the values from midway to bob\\n3. use DFS to find max profit for Alice\\nIf you like my approach please upvote, thanks!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        def find_bob() -> bool:\\n            node = path2bob[-1]\\n            seen.add(node)\\n            for i in graph[node]:\\n                if i in seen:\\n                    continue\\n                if i == bob:\\n                    path2bob.append(bob)\\n                    return True\\n                path2bob.append(i)\\n                if find_bob():\\n                    return True\\n                path2bob.pop()\\n\\n        def dfs(alice: int, profit: int):\\n            nonlocal r\\n            seen.add(alice)\\n            profit += amount[alice]\\n            if alice and len(graph[alice]) == 1:\\n                # leaf node\\n                r = max(r, profit)\\n                return\\n            for j in graph[alice]:\\n                if j in seen:\\n                    continue\\n                dfs(j, profit)\\n\\n        n = len(amount)\\n        graph = [[] for _ in range(n)]\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        seen = set()\\n        alice = 0\\n        path2bob = [alice]\\n        find_bob()\\n        meetat = len(path2bob) // 2\\n        if len(path2bob) & 1:\\n            amount[path2bob[meetat]] //= 2\\n        for i in range(meetat):\\n            amount[path2bob[-i-1]] = 0\\n        seen.clear()\\n        r = -math.inf\\n        dfs(alice, 0)\\n        return r\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        def find_bob() -> bool:\\n            node = path2bob[-1]\\n            seen.add(node)\\n            for i in graph[node]:\\n                if i in seen:\\n                    continue\\n                if i == bob:\\n                    path2bob.append(bob)\\n                    return True\\n                path2bob.append(i)\\n                if find_bob():\\n                    return True\\n                path2bob.pop()\\n\\n        def dfs(alice: int, profit: int):\\n            nonlocal r\\n            seen.add(alice)\\n            profit += amount[alice]\\n            if alice and len(graph[alice]) == 1:\\n                # leaf node\\n                r = max(r, profit)\\n                return\\n            for j in graph[alice]:\\n                if j in seen:\\n                    continue\\n                dfs(j, profit)\\n\\n        n = len(amount)\\n        graph = [[] for _ in range(n)]\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        seen = set()\\n        alice = 0\\n        path2bob = [alice]\\n        find_bob()\\n        meetat = len(path2bob) // 2\\n        if len(path2bob) & 1:\\n            amount[path2bob[meetat]] //= 2\\n        for i in range(meetat):\\n            amount[path2bob[-i-1]] = 0\\n        seen.clear()\\n        r = -math.inf\\n        dfs(alice, 0)\\n        return r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353762,
                "title": "backtracking-dfs-python-solution-with-comments",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        res = float(\"-inf\")\\n        g = defaultdict(list)\\n        for u , v in edges :\\n            g[u].append(v) ; g[v].append(u)\\n        vis = {0}\\n        def modify(): // modify the amount list\\n            Path = [0] // path from 0 --> bob node\\n            vis = {0} // hashmap to store visited node -->prevent cycles\\n            def find(path , bob , x): // return required path\\n                nonlocal Path\\n                if x == bob : \\n                    Path += path\\n                    return \\n                for node in g[x] :\\n                    if node not in vis :\\n                       vis.add(node) // first add node\\n                       path.append(node) // add node to path\\n                       find(path , bob , node) // go to the end of road reachable from this node\\n                       path.pop() // remove node from path at end(discover new road)\\n            find([] , bob , 0)\\n            amount[bob] = 0\\n            n = len(Path) // 2\\n            if len(Path)%2 : // they will meet if path lenght is odd\\n                amount[Path[n]] //= 2 \\n            else :\\n                n -= 1\\n            for x in Path[n+1:]: // from mid to end of road will be discovered first by bob\\n                amount[x] = 0\\n        def dfs(x , val) :\\n            nonlocal res\\n            if len(g[x]) == 1 : // leaf node connected only to one node --> update res if this road value is more than others\\n                res = max(res , val)\\n            for node in g[x] : // Simple Dfs approch\\n                if node not in vis :\\n                    vis.add(node)\\n                    curr = amount[node]\\n                    dfs(node , val+curr)\\n        modify()\\n        dfs(0 , amount[0])\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        res = float(\"-inf\")\\n        g = defaultdict(list)\\n        for u , v in edges :\\n            g[u].append(v) ; g[v].append(u)\\n        vis = {0}\\n        def modify(): // modify the amount list\\n            Path = [0] // path from 0 --> bob node\\n            vis = {0} // hashmap to store visited node -->prevent cycles\\n            def find(path , bob , x): // return required path\\n                nonlocal Path\\n                if x == bob : \\n                    Path += path\\n                    return \\n                for node in g[x] :\\n                    if node not in vis :\\n                       vis.add(node) // first add node\\n                       path.append(node) // add node to path\\n                       find(path , bob , node) // go to the end of road reachable from this node\\n                       path.pop() // remove node from path at end(discover new road)\\n            find([] , bob , 0)\\n            amount[bob] = 0\\n            n = len(Path) // 2\\n            if len(Path)%2 : // they will meet if path lenght is odd\\n                amount[Path[n]] //= 2 \\n            else :\\n                n -= 1\\n            for x in Path[n+1:]: // from mid to end of road will be discovered first by bob\\n                amount[x] = 0\\n        def dfs(x , val) :\\n            nonlocal res\\n            if len(g[x]) == 1 : // leaf node connected only to one node --> update res if this road value is more than others\\n                res = max(res , val)\\n            for node in g[x] : // Simple Dfs approch\\n                if node not in vis :\\n                    vis.add(node)\\n                    curr = amount[node]\\n                    dfs(node , val+curr)\\n        modify()\\n        dfs(0 , amount[0])\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322298,
                "title": "python-dfs",
                "content": "All solutions had garbage editorials & I ended up solving myself.\\n\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        g = defaultdict(list)\\n        for frm, to in edges:\\n            g[frm].append(to)\\n            g[to].append(frm)\\n            \\n        tv = defaultdict(int)\\n        def dfs(c: int, graph: dict, t: int, v: set) -> bool:\\n            if c == 0:\\n                return True\\n            v.add(current)\\n            f = False\\n            for nei in g[c]:\\n                if nei not in v:\\n                    if dfs(nei, g, t + 1, v):\\n                        f = True\\n                        tv[c] = t\\n            return f\\n\\t\\t\\t\\n        dfs(bob, g, 0, set())\\n        \\n        r = None\\n\\n        def dfs2(c: int, g: dict, t: int, v: set, c: int):\\n            nonlocal result\\n            v.add(current)\\n            o = 0\\n            nc = c \\n            if c not in tv or time < tv[c]:\\n                nc += amount[c]\\n            elif time == time_visited[c]:\\n                nc += (amount[c] // 2)\\n            for nei in g[c]:\\n                if nei not in v:  \\n                    dfs2(nei, g, t + 1, v, nc)\\n                    o += 1\\n            if o == 0:\\n                if r is None or nc > r:\\n                    r = nc\\n        dfs2(0, g, 0, set(), 0)\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        g = defaultdict(list)\\n        for frm, to in edges:\\n            g[frm].append(to)\\n            g[to].append(frm)\\n            \\n        tv = defaultdict(int)\\n        def dfs(c: int, graph: dict, t: int, v: set) -> bool:\\n            if c == 0:\\n                return True\\n            v.add(current)\\n            f = False\\n            for nei in g[c]:\\n                if nei not in v:\\n                    if dfs(nei, g, t + 1, v):\\n                        f = True\\n                        tv[c] = t\\n            return f\\n\\t\\t\\t\\n        dfs(bob, g, 0, set())\\n        \\n        r = None\\n\\n        def dfs2(c: int, g: dict, t: int, v: set, c: int):\\n            nonlocal result\\n            v.add(current)\\n            o = 0\\n            nc = c \\n            if c not in tv or time < tv[c]:\\n                nc += amount[c]\\n            elif time == time_visited[c]:\\n                nc += (amount[c] // 2)\\n            for nei in g[c]:\\n                if nei not in v:  \\n                    dfs2(nei, g, t + 1, v, nc)\\n                    o += 1\\n            if o == 0:\\n                if r is None or nc > r:\\n                    r = nc\\n        dfs2(0, g, 0, set(), 0)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312792,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for x,y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        x = []\\n        def dfs(node,Path,parent):\\n\\n            Path.append(node)\\n            if node == 0:\\n                x.extend(Path)\\n                return\\n            for neigh in graph[node]:\\n                if neigh == parent:continue\\n                dfs(neigh,Path,node)\\n                Path.pop()\\n\\n        dfs(bob,[],-1)\\n\\n        for i in range(len(x)//2):\\n            amount[x[i]] = 0\\n        if len(x) % 2 : amount[x[len(x)//2]] //= 2\\n\\n        def mostprofit(node,parent):\\n            if len(graph[node]) == 1 and graph[node][0] == parent:\\n                return amount[node]\\n            mx = -inf\\n            for neigh in graph[node]:\\n                if neigh ==  parent:continue\\n                mx = max(mx , mostprofit(neigh,node))\\n            return mx + amount[node]\\n\\n        return mostprofit(0,parent = -1)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for x,y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        x = []\\n        def dfs(node,Path,parent):\\n\\n            Path.append(node)\\n            if node == 0:\\n                x.extend(Path)\\n                return\\n            for neigh in graph[node]:\\n                if neigh == parent:continue\\n                dfs(neigh,Path,node)\\n                Path.pop()\\n\\n        dfs(bob,[],-1)\\n\\n        for i in range(len(x)//2):\\n            amount[x[i]] = 0\\n        if len(x) % 2 : amount[x[len(x)//2]] //= 2\\n\\n        def mostprofit(node,parent):\\n            if len(graph[node]) == 1 and graph[node][0] == parent:\\n                return amount[node]\\n            mx = -inf\\n            for neigh in graph[node]:\\n                if neigh ==  parent:continue\\n                mx = max(mx , mostprofit(neigh,node))\\n            return mx + amount[node]\\n\\n        return mostprofit(0,parent = -1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276962,
                "title": "java-bfs-dfs-easy-to-understand-code",
                "content": "```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int V = edges.length + 1;\\n        for(int i = 0 ; i < V ; i++) adj.add(new ArrayList<>());\\n        for(int i = 0 ; i < edges.length ; i++){\\n            int s = edges[i][0];\\n            int e = edges[i][1];\\n            adj.get(s).add(e);\\n            adj.get(e).add(s);\\n        }\\n        \\n        int[] parent = new int[V];\\n        for(int i = 0 ; i < V ; i++){\\n            parent[i] = i;\\n        }\\n        int distance = getBobDistance(bob , adj , V , parent);\\n        ArrayList<Integer> path = new ArrayList<>();\\n        int i = bob;\\n        while(i != parent[i]){\\n            path.add(i);\\n            i = parent[i];\\n        }\\n        path.add(0);\\n        \\n        for(int j = 0 ; j < path.size() / 2 ; j++){\\n            int ele = path.get(j);\\n            amount[ele] = 0;\\n        }\\n        if(path.size() % 2 != 0){\\n            amount[path.get(path.size() / 2)] = amount[path.get(path.size() / 2)] / 2;\\n        }\\n        \\n        boolean[] isVis = new boolean[V];\\n        isVis[0] = true;\\n        return (int) getMax(0 , adj , isVis , amount);\\n    }\\n    private long getMax(int curNode , ArrayList<ArrayList<Integer>> adj , boolean[] isVis , int[] amount){\\n        long max = -10000000;\\n        for(int ele : adj.get(curNode)){\\n            if(!isVis[ele]){\\n                isVis[ele] = true;\\n                max = Math.max(max , getMax(ele , adj , isVis , amount));\\n            }\\n        }\\n        if(max == -10000000){\\n            max = 0;\\n        }\\n        max += amount[curNode];\\n        return max;\\n    }\\n    private int getBobDistance(int bob , ArrayList<ArrayList<Integer>> adj , int V , int[] parent){\\n        boolean[] isVis = new boolean[V];\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int ans = 1;\\n        isVis[0] = true;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int curNode = queue.poll();\\n                if(curNode == bob) return ans;\\n                for(int ele : adj.get(curNode)){\\n                    if(!isVis[ele]){\\n                        isVis[ele] = true;\\n                        parent[ele] = curNode;\\n                        queue.offer(ele);\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int V = edges.length + 1;\\n        for(int i = 0 ; i < V ; i++) adj.add(new ArrayList<>());\\n        for(int i = 0 ; i < edges.length ; i++){\\n            int s = edges[i][0];\\n            int e = edges[i][1];\\n            adj.get(s).add(e);\\n            adj.get(e).add(s);\\n        }\\n        \\n        int[] parent = new int[V];\\n        for(int i = 0 ; i < V ; i++){\\n            parent[i] = i;\\n        }\\n        int distance = getBobDistance(bob , adj , V , parent);\\n        ArrayList<Integer> path = new ArrayList<>();\\n        int i = bob;\\n        while(i != parent[i]){\\n            path.add(i);\\n            i = parent[i];\\n        }\\n        path.add(0);\\n        \\n        for(int j = 0 ; j < path.size() / 2 ; j++){\\n            int ele = path.get(j);\\n            amount[ele] = 0;\\n        }\\n        if(path.size() % 2 != 0){\\n            amount[path.get(path.size() / 2)] = amount[path.get(path.size() / 2)] / 2;\\n        }\\n        \\n        boolean[] isVis = new boolean[V];\\n        isVis[0] = true;\\n        return (int) getMax(0 , adj , isVis , amount);\\n    }\\n    private long getMax(int curNode , ArrayList<ArrayList<Integer>> adj , boolean[] isVis , int[] amount){\\n        long max = -10000000;\\n        for(int ele : adj.get(curNode)){\\n            if(!isVis[ele]){\\n                isVis[ele] = true;\\n                max = Math.max(max , getMax(ele , adj , isVis , amount));\\n            }\\n        }\\n        if(max == -10000000){\\n            max = 0;\\n        }\\n        max += amount[curNode];\\n        return max;\\n    }\\n    private int getBobDistance(int bob , ArrayList<ArrayList<Integer>> adj , int V , int[] parent){\\n        boolean[] isVis = new boolean[V];\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int ans = 1;\\n        isVis[0] = true;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int curNode = queue.poll();\\n                if(curNode == bob) return ans;\\n                for(int ele : adj.get(curNode)){\\n                    if(!isVis[ele]){\\n                        isVis[ele] = true;\\n                        parent[ele] = curNode;\\n                        queue.offer(ele);\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243355,
                "title": "c-2-approaches-large-code-but-simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe want alice\\'s score to be as max as possible as she is a girl (;-)\\n\\nthere can be two condition for alice\\'s score to be maximum \\n1. if we reach to +amnt node earlier than bob then we get all reward.\\n2. if bob reach to a -amnt node earlier than alice then alice won\\'t have to spend any money on the gate as it is already opened by bob.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **TWO BFS**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edgess, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n\\n        vector<vector<int>> edges(n);\\n        vector<int> ans(n , 0);\\n\\n        for(auto vec : edgess) {\\n            edges[vec[0]].push_back(vec[1]);\\n            edges[vec[1]].push_back(vec[0]);\\n        }\\n\\n        vector<int> a_dist(n , INT_MAX) , b_dist(n , INT_MAX);\\n\\n        queue<int> q;\\n\\n        q.push(bob);\\n        b_dist[bob] = 0;\\n        vector<int> vis(n , 0);\\n\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n\\n            if(vis[node]) continue;\\n\\n            vis[node] = 1;\\n            for(auto next : edges[node]) {\\n                if(vis[next]) continue;\\n                if(b_dist[next] > b_dist[node] + 1) {\\n                    b_dist[next] = b_dist[node] + 1;\\n                    q.push(next);\\n                }\\n            }\\n        }\\n        int res = INT_MIN;\\n\\n        q.push(0);\\n        a_dist[0] = 0;\\n        vis.clear();\\n        vis.resize(n , 0);\\n        ans[0] = amount[0];\\n\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n\\n            if(vis[node]) continue;\\n\\n            vis[node] = 1;\\n\\n            if(node != 0 && edges[node].size() == 1) {\\n                res = max(res , ans[node]);\\n            }\\n\\n            for(auto next : edges[node]) {\\n                if(vis[next]) continue;\\n                if(a_dist[next] > a_dist[node] + 1) {\\n                    a_dist[next] = a_dist[node] + 1;\\n                    if(b_dist[next] > b_dist[node]) {\\n                        ans[next] = ans[node] + amount[next];\\n                    }\\n                    else if(a_dist[next] == b_dist[next]) {\\n                        ans[next] = ans[node] + (amount[next] / 2);\\n                    }\\n                    else if(a_dist[next] < b_dist[next]) {\\n                        ans[next] = ans[node] + amount[next];\\n                    }\\n                    else ans[next] = ans[node];\\n                    q.push(next);\\n                }\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n\\n2. DFS + BFS + DFS\\n\\nNOTE:- Explaination is wrong\\n\\n```\\n\\n**1st dfs :-**\\n\\nit stores the bob\\'s distance to every nodes in the direction 0.\\n\\n**bfs :-**\\n\\nit stores the nodes which bob can visit at a level because if bob and alice both are reaching to a +amnt node at the same time then for alice\\'s score to be maximum we want bob to take an alternate path so that alice can have all the reward for herself (she is greedy).\\n\\n**2nd dfs :-**\\n\\nit calculates the final result the logic is simple :-\\n\\nat any node check for both alice and bob\\'s distances and also if bob has any alternate path at any level.\\n\\nIf still any doubt please let me know in the comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V + E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define INT_MAX 1e5\\nclass Solution {\\npublic:\\n\\n    vector<int> db;\\n\\n    int dfs(int node , int ed , vector<vector<int>> &edges , vector<int> &vis) {\\n        if(node == ed) {\\n            return 0;\\n        }\\n        vis[node] = 1;\\n        int dist = INT_MAX;\\n        for(auto next : edges[node]) {\\n            if(vis[next]) continue;\\n            dist = min(dist , 1 + dfs(next , ed , edges , vis));\\n        }\\n        return (db[node] = dist);\\n\\n    }\\n\\n    unordered_map<int , int> isLeaf;\\n\\n    int dfs2(int node , vector<vector<int>> &edges , vector<int> &vis , int dist , vector<int> &amnt , vector<int> &lvl) {\\n\\n        if(isLeaf[node]) {\\n            int res;\\n            if(amnt[node] < 0) {\\n            if(db[node] < dist) {\\n                res = 0;\\n            }\\n            else if(db[node] == dist) res = amnt[node] / 2;\\n            else res = amnt[node];\\n        }\\n        else {\\n            if(db[node] < dist) {\\n                if(lvl[node] > 1) {\\n                    res = amnt[node];\\n                }\\n                else res = 0;\\n            }\\n            else if(db[node] == dist) {\\n                if(lvl[node] > 1)\\n                res = amnt[node];\\n                else res = amnt[node] / 2;\\n            }\\n            else res = amnt[node];\\n        }\\n            return res;\\n        }\\n\\n        vis[node] = 1;\\n\\n        int ans = INT_MIN , res;\\n\\n        if(amnt[node] < 0) {\\n            if(db[node] < dist) {\\n                res = 0;\\n            }\\n            else if(db[node] == dist) res = amnt[node] / 2;\\n            else res = amnt[node];\\n        }\\n        else {\\n            if(db[node] < dist) {\\n                if(lvl[node] > 1) {\\n                    res = amnt[node];\\n                }\\n                else res = 0;\\n            }\\n            else if(db[node] == dist) {\\n                if(lvl[node] > 1)\\n                res = amnt[node];\\n                else res = amnt[node] / 2;\\n            }\\n            else res = amnt[node];\\n        }\\n\\n        for(auto next : edges[node]) {\\n            if(vis[next]) continue;\\n            ans = max(ans , res + dfs2(next , edges , vis , dist + 1 , amnt , lvl));\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size() , m;\\n\\n        vector<vector<int>> edgess(n);\\n        \\n        int in[n];\\n\\n        memset(in , 0 , n * sizeof(int));\\n\\n        for(auto vec : edges) {\\n            edgess[vec[0]].push_back(vec[1]);\\n            edgess[vec[1]].push_back(vec[0]);\\n            in[vec[1]]++;\\n            in[vec[0]]++;\\n        }\\n\\n        for(int i = 0 ; i < n ; i++) {\\n            if(i && in[i] == 1) {\\n                isLeaf[i] = 1;\\n            } \\n\\n        }\\n\\n        queue<int> q; \\n        q.push(0);\\n        vector<int> lvl(n , 0);\\n        int lv = 0 , sz = 1;\\n\\n        vector<int> vis(n + 1 , 0);\\n        db.resize(n + 1 , INT_MAX);\\n        dfs(0 , bob , edgess , vis);\\n        db[bob] = 0;\\n        vis.assign(n , 0);\\n\\n        while(!q.empty()) {\\n           int lsz = 0;            \\n            while(sz--) {\\n                int node = q.front();\\n                q.pop();\\n                if(vis[node]) continue;\\n\\n                if(db[node] != INT_MAX) {\\n                    lvl[lv]++;\\n                }\\n\\n                vis[node] = 1;\\n                for(auto next : edgess[node]) {\\n                    if(vis[next]) continue;\\n                    q.push(next);\\n                    lsz++;\\n                }\\n            }\\n            lv++;\\n            sz = lsz;\\n        }\\n        vis.assign(n , 0);\\n\\n        return dfs2(0 , edgess , vis , 0 , amount , lvl);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edgess, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n\\n        vector<vector<int>> edges(n);\\n        vector<int> ans(n , 0);\\n\\n        for(auto vec : edgess) {\\n            edges[vec[0]].push_back(vec[1]);\\n            edges[vec[1]].push_back(vec[0]);\\n        }\\n\\n        vector<int> a_dist(n , INT_MAX) , b_dist(n , INT_MAX);\\n\\n        queue<int> q;\\n\\n        q.push(bob);\\n        b_dist[bob] = 0;\\n        vector<int> vis(n , 0);\\n\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n\\n            if(vis[node]) continue;\\n\\n            vis[node] = 1;\\n            for(auto next : edges[node]) {\\n                if(vis[next]) continue;\\n                if(b_dist[next] > b_dist[node] + 1) {\\n                    b_dist[next] = b_dist[node] + 1;\\n                    q.push(next);\\n                }\\n            }\\n        }\\n        int res = INT_MIN;\\n\\n        q.push(0);\\n        a_dist[0] = 0;\\n        vis.clear();\\n        vis.resize(n , 0);\\n        ans[0] = amount[0];\\n\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n\\n            if(vis[node]) continue;\\n\\n            vis[node] = 1;\\n\\n            if(node != 0 && edges[node].size() == 1) {\\n                res = max(res , ans[node]);\\n            }\\n\\n            for(auto next : edges[node]) {\\n                if(vis[next]) continue;\\n                if(a_dist[next] > a_dist[node] + 1) {\\n                    a_dist[next] = a_dist[node] + 1;\\n                    if(b_dist[next] > b_dist[node]) {\\n                        ans[next] = ans[node] + amount[next];\\n                    }\\n                    else if(a_dist[next] == b_dist[next]) {\\n                        ans[next] = ans[node] + (amount[next] / 2);\\n                    }\\n                    else if(a_dist[next] < b_dist[next]) {\\n                        ans[next] = ans[node] + amount[next];\\n                    }\\n                    else ans[next] = ans[node];\\n                    q.push(next);\\n                }\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n\\n2. DFS + BFS + DFS\\n\\nNOTE:- Explaination is wrong\\n\\n```\n```\\n#define INT_MAX 1e5\\nclass Solution {\\npublic:\\n\\n    vector<int> db;\\n\\n    int dfs(int node , int ed , vector<vector<int>> &edges , vector<int> &vis) {\\n        if(node == ed) {\\n            return 0;\\n        }\\n        vis[node] = 1;\\n        int dist = INT_MAX;\\n        for(auto next : edges[node]) {\\n            if(vis[next]) continue;\\n            dist = min(dist , 1 + dfs(next , ed , edges , vis));\\n        }\\n        return (db[node] = dist);\\n\\n    }\\n\\n    unordered_map<int , int> isLeaf;\\n\\n    int dfs2(int node , vector<vector<int>> &edges , vector<int> &vis , int dist , vector<int> &amnt , vector<int> &lvl) {\\n\\n        if(isLeaf[node]) {\\n            int res;\\n            if(amnt[node] < 0) {\\n            if(db[node] < dist) {\\n                res = 0;\\n            }\\n            else if(db[node] == dist) res = amnt[node] / 2;\\n            else res = amnt[node];\\n        }\\n        else {\\n            if(db[node] < dist) {\\n                if(lvl[node] > 1) {\\n                    res = amnt[node];\\n                }\\n                else res = 0;\\n            }\\n            else if(db[node] == dist) {\\n                if(lvl[node] > 1)\\n                res = amnt[node];\\n                else res = amnt[node] / 2;\\n            }\\n            else res = amnt[node];\\n        }\\n            return res;\\n        }\\n\\n        vis[node] = 1;\\n\\n        int ans = INT_MIN , res;\\n\\n        if(amnt[node] < 0) {\\n            if(db[node] < dist) {\\n                res = 0;\\n            }\\n            else if(db[node] == dist) res = amnt[node] / 2;\\n            else res = amnt[node];\\n        }\\n        else {\\n            if(db[node] < dist) {\\n                if(lvl[node] > 1) {\\n                    res = amnt[node];\\n                }\\n                else res = 0;\\n            }\\n            else if(db[node] == dist) {\\n                if(lvl[node] > 1)\\n                res = amnt[node];\\n                else res = amnt[node] / 2;\\n            }\\n            else res = amnt[node];\\n        }\\n\\n        for(auto next : edges[node]) {\\n            if(vis[next]) continue;\\n            ans = max(ans , res + dfs2(next , edges , vis , dist + 1 , amnt , lvl));\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size() , m;\\n\\n        vector<vector<int>> edgess(n);\\n        \\n        int in[n];\\n\\n        memset(in , 0 , n * sizeof(int));\\n\\n        for(auto vec : edges) {\\n            edgess[vec[0]].push_back(vec[1]);\\n            edgess[vec[1]].push_back(vec[0]);\\n            in[vec[1]]++;\\n            in[vec[0]]++;\\n        }\\n\\n        for(int i = 0 ; i < n ; i++) {\\n            if(i && in[i] == 1) {\\n                isLeaf[i] = 1;\\n            } \\n\\n        }\\n\\n        queue<int> q; \\n        q.push(0);\\n        vector<int> lvl(n , 0);\\n        int lv = 0 , sz = 1;\\n\\n        vector<int> vis(n + 1 , 0);\\n        db.resize(n + 1 , INT_MAX);\\n        dfs(0 , bob , edgess , vis);\\n        db[bob] = 0;\\n        vis.assign(n , 0);\\n\\n        while(!q.empty()) {\\n           int lsz = 0;            \\n            while(sz--) {\\n                int node = q.front();\\n                q.pop();\\n                if(vis[node]) continue;\\n\\n                if(db[node] != INT_MAX) {\\n                    lvl[lv]++;\\n                }\\n\\n                vis[node] = 1;\\n                for(auto next : edgess[node]) {\\n                    if(vis[next]) continue;\\n                    q.push(next);\\n                    lsz++;\\n                }\\n            }\\n            lv++;\\n            sz = lsz;\\n        }\\n        vis.assign(n , 0);\\n\\n        return dfs2(0 , edgess , vis , 0 , amount , lvl);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228197,
                "title": "c",
                "content": "```\\nclass Solution {\\n    vector<vector<int>>graph ;\\n    vector<int>b ;\\n    int ret = INT_MIN/2 ;    \\n    int bob ;\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size() ;\\n        this->bob = bob; \\n        graph.resize(n) ;\\n        b.resize(n, INT_MAX/2) ;\\n        for(auto& e : edges){\\n            graph[e[0]].push_back(e[1]) ;\\n            graph[e[1]].push_back(e[0]) ;\\n        }\\n        \\n        //build bob to root path ;\\n        dfs(0, -1, 0) ;\\n        \\n        //evaluate maximum score\\n        dfs2(0, -1, 0, 0, amount) ;\\n        return ret ;\\n    }\\n    \\n    void dfs(int cur, int prev, int step){\\n        if(cur == bob){\\n            b[cur] = 0 ;\\n            return  ;\\n        }\\n        int toBob = INT_MAX/2 ;\\n        for(auto& next : graph[cur]){\\n            if(next == prev)\\n                continue ;\\n            dfs(next, cur, step+1) ;\\n            toBob = min(toBob, b[next] + 1) ;\\n        }\\n        b[cur] = toBob ;\\n    }\\n    \\n    void dfs2(int cur, int prev, int step, int score, vector<int>& amount){\\n        if(step == b[cur]){\\n            score += amount[cur]/2 ;\\n        }\\n        else if(step < b[cur])\\n            score += amount[cur] ;\\n \\n        if(graph[cur].size() == 1 && graph[cur][0] == prev){  // make sure is leaf not root\\n            ret = max(ret, score) ;\\n            return ;\\n        }\\n        for(auto& next : graph[cur]){\\n            if(next == prev)\\n                continue ;\\n            dfs2(next, cur, step+1, score, amount) ;\\n        }\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>>graph ;\\n    vector<int>b ;\\n    int ret = INT_MIN/2 ;    \\n    int bob ;\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size() ;\\n        this->bob = bob; \\n        graph.resize(n) ;\\n        b.resize(n, INT_MAX/2) ;\\n        for(auto& e : edges){\\n            graph[e[0]].push_back(e[1]) ;\\n            graph[e[1]].push_back(e[0]) ;\\n        }\\n        \\n        //build bob to root path ;\\n        dfs(0, -1, 0) ;\\n        \\n        //evaluate maximum score\\n        dfs2(0, -1, 0, 0, amount) ;\\n        return ret ;\\n    }\\n    \\n    void dfs(int cur, int prev, int step){\\n        if(cur == bob){\\n            b[cur] = 0 ;\\n            return  ;\\n        }\\n        int toBob = INT_MAX/2 ;\\n        for(auto& next : graph[cur]){\\n            if(next == prev)\\n                continue ;\\n            dfs(next, cur, step+1) ;\\n            toBob = min(toBob, b[next] + 1) ;\\n        }\\n        b[cur] = toBob ;\\n    }\\n    \\n    void dfs2(int cur, int prev, int step, int score, vector<int>& amount){\\n        if(step == b[cur]){\\n            score += amount[cur]/2 ;\\n        }\\n        else if(step < b[cur])\\n            score += amount[cur] ;\\n \\n        if(graph[cur].size() == 1 && graph[cur][0] == prev){  // make sure is leaf not root\\n            ret = max(ret, score) ;\\n            return ;\\n        }\\n        for(auto& next : graph[cur]){\\n            if(next == prev)\\n                continue ;\\n            dfs2(next, cur, step+1, score, amount) ;\\n        }\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204646,
                "title": "java-easy-to-understand-2-dfs",
                "content": "```\\nclass Solution {\\n    private void findForAlice(List<List<Integer>> graph, int n, int p, int[] parent, int[] distance){\\n        if(p != -1) distance[n] = distance[p] + 1;\\n        List<Integer> neighbours = graph.get(n);\\n        for(int neighbour: neighbours){\\n            if(neighbour != p){\\n                findForAlice(graph, neighbour, n, parent, distance);\\n            }\\n        }\\n        parent[n] = p;\\n    }\\n    private int findProfitForAlice(List<List<Integer>> graph, int n, int p, int[] distance, int[] path, int[] amount){\\n        List<Integer> neighbours = graph.get(n);\\n        int maxPrice = Integer.MIN_VALUE;\\n        for(int neighbour: neighbours){\\n            if(neighbour != p){\\n                int temp = 0;\\n                if(distance[neighbour] == path[neighbour]) temp = amount[neighbour] / 2;\\n                else if(path[neighbour] < 0 || path[neighbour] > distance[neighbour]) temp = amount[neighbour];\\n                maxPrice = Math.max(maxPrice, temp + findProfitForAlice(graph, neighbour, n, distance, path, amount));\\n            }\\n        }\\n        if(maxPrice == Integer.MIN_VALUE) return 0;\\n        return maxPrice;\\n    }\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int[] parent = new int[amount.length];\\n        int[] distance = new int[amount.length];\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i = 0; i < amount.length; i++) graph.add(new ArrayList<>());\\n        for(int[] edge: edges){\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        findForAlice(graph, 0, -1, parent, distance);\\n        int[] path = new int[parent.length];\\n        Arrays.fill(path, -2);\\n        int p = -1;\\n        while(bob != -1){\\n            path[bob] = ++p;\\n            bob = parent[bob];\\n        }\\n        return amount[0] + findProfitForAlice(graph, 0, -1, distance, path, amount);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private void findForAlice(List<List<Integer>> graph, int n, int p, int[] parent, int[] distance){\\n        if(p != -1) distance[n] = distance[p] + 1;\\n        List<Integer> neighbours = graph.get(n);\\n        for(int neighbour: neighbours){\\n            if(neighbour != p){\\n                findForAlice(graph, neighbour, n, parent, distance);\\n            }\\n        }\\n        parent[n] = p;\\n    }\\n    private int findProfitForAlice(List<List<Integer>> graph, int n, int p, int[] distance, int[] path, int[] amount){\\n        List<Integer> neighbours = graph.get(n);\\n        int maxPrice = Integer.MIN_VALUE;\\n        for(int neighbour: neighbours){\\n            if(neighbour != p){\\n                int temp = 0;\\n                if(distance[neighbour] == path[neighbour]) temp = amount[neighbour] / 2;\\n                else if(path[neighbour] < 0 || path[neighbour] > distance[neighbour]) temp = amount[neighbour];\\n                maxPrice = Math.max(maxPrice, temp + findProfitForAlice(graph, neighbour, n, distance, path, amount));\\n            }\\n        }\\n        if(maxPrice == Integer.MIN_VALUE) return 0;\\n        return maxPrice;\\n    }\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int[] parent = new int[amount.length];\\n        int[] distance = new int[amount.length];\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i = 0; i < amount.length; i++) graph.add(new ArrayList<>());\\n        for(int[] edge: edges){\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        findForAlice(graph, 0, -1, parent, distance);\\n        int[] path = new int[parent.length];\\n        Arrays.fill(path, -2);\\n        int p = -1;\\n        while(bob != -1){\\n            path[bob] = ++p;\\n            bob = parent[bob];\\n        }\\n        return amount[0] + findProfitForAlice(graph, 0, -1, distance, path, amount);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183319,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> Adj;\\n    vector<int> visited;\\n    vector<int> Vpath_B;\\n    int find_path_B(int n){\\n        if(n == 0){Vpath_B.push_back(n); return 1;}\\n        \\n        if(visited[n] == 1){return 0;}\\n        visited[n] = 1;\\n        \\n        for(auto &v: Adj[n]){\\n            int flag = find_path_B(v);\\n            if(flag != 1){continue;}\\n            \\n            Vpath_B.push_back(n);\\n            return 1;\\n        }\\n        \\n        return 0;\\n    }\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        \\n        int len_n = amount.size();\\n        Adj.resize(len_n, vector<int>());\\n        for(auto &E:edges){\\n            int u = E[0], v = E[1];\\n            Adj[u].push_back(v);\\n            Adj[v].push_back(u);\\n        }\\n        \\n        visited.resize(len_n, 0);\\n        find_path_B(bob);\\n \\n\\n        amount[bob] = 0;\\n        Vpath_B.pop_back();\\n        \\n        \\n        using pii = pair<int,int>;\\n        int val = amount[0];\\n        queue<pii> Q({{0,val}});\\n        int Max = INT_MIN;\\n        \\n        vector<int> visited2(len_n, 0);\\n        visited2[0] = 1;\\n        while(!Q.empty()){\\n            int len_Q = Q.size();\\n\\t\\t\\t\\n            int n_bob = -1;\\n            if(!Vpath_B.empty()){\\n                n_bob = Vpath_B.back();\\n                Vpath_B.pop_back();\\n            }\\n\\n            while(len_Q--){\\n                int u = Q.front().first;\\n                int val = Q.front().second;\\n                Q.pop();\\n                \\n         \\n                if(Adj[u].size() == 1 && u != 0){ \\n                    Max = max(Max, val);\\n                    continue;\\n                }\\n                \\n                for(int &v: Adj[u]){\\n                    if(visited2[v] == 1){continue;}\\n                    visited2[v] = 1; \\n                    \\n                    if(v != n_bob){\\n                        Q.push({v, val+ amount[v]});\\n                        continue;\\n                    }\\n                    \\n                    Q.push({v, val+amount[v]/2});\\n                }\\n            }\\n            \\n            if(n_bob != -1){amount[n_bob] = 0;}\\n        }\\n        \\n        return Max;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> Adj;\\n    vector<int> visited;\\n    vector<int> Vpath_B;\\n    int find_path_B(int n){\\n        if(n == 0){Vpath_B.push_back(n); return 1;}\\n        \\n        if(visited[n] == 1){return 0;}\\n        visited[n] = 1;\\n        \\n        for(auto &v: Adj[n]){\\n            int flag = find_path_B(v);\\n            if(flag != 1){continue;}\\n            \\n            Vpath_B.push_back(n);\\n            return 1;\\n        }\\n        \\n        return 0;\\n    }\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        \\n        int len_n = amount.size();\\n        Adj.resize(len_n, vector<int>());\\n        for(auto &E:edges){\\n            int u = E[0], v = E[1];\\n            Adj[u].push_back(v);\\n            Adj[v].push_back(u);\\n        }\\n        \\n        visited.resize(len_n, 0);\\n        find_path_B(bob);\\n \\n\\n        amount[bob] = 0;\\n        Vpath_B.pop_back();\\n        \\n        \\n        using pii = pair<int,int>;\\n        int val = amount[0];\\n        queue<pii> Q({{0,val}});\\n        int Max = INT_MIN;\\n        \\n        vector<int> visited2(len_n, 0);\\n        visited2[0] = 1;\\n        while(!Q.empty()){\\n            int len_Q = Q.size();\\n\\t\\t\\t\\n            int n_bob = -1;\\n            if(!Vpath_B.empty()){\\n                n_bob = Vpath_B.back();\\n                Vpath_B.pop_back();\\n            }\\n\\n            while(len_Q--){\\n                int u = Q.front().first;\\n                int val = Q.front().second;\\n                Q.pop();\\n                \\n         \\n                if(Adj[u].size() == 1 && u != 0){ \\n                    Max = max(Max, val);\\n                    continue;\\n                }\\n                \\n                for(int &v: Adj[u]){\\n                    if(visited2[v] == 1){continue;}\\n                    visited2[v] = 1; \\n                    \\n                    if(v != n_bob){\\n                        Q.push({v, val+ amount[v]});\\n                        continue;\\n                    }\\n                    \\n                    Q.push({v, val+amount[v]/2});\\n                }\\n            }\\n            \\n            if(n_bob != -1){amount[n_bob] = 0;}\\n        }\\n        \\n        return Max;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142388,
                "title": "most-profitable-path-in-the-tree-java",
                "content": "# Code\\n```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        ArrayList<Node> nodes=new ArrayList<>();\\n        int n=amount.length;\\n        for(int i=0;i<n;i++){\\n            nodes.add(new Node(i,amount[i]));\\n        }\\n\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int []e:edges){\\n            int s=e[0];\\n            int d=e[1];\\n\\n            adj.get(s).add(d);\\n            adj.get(d).add(s);\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            if(adj.get(i).size()==1){\\n                nodes.get(i).leaf=true;\\n            }\\n        }\\n\\n        \\n        int []dist=new int[n];\\n        nodes.get(0).par=0;\\n        setParent(nodes,adj,dist,0,0);\\n\\n        int curr=bob;\\n        int currDist=0;\\n\\n        while(curr!=0){\\n            if(dist[curr]>currDist){\\n                nodes.get(curr).amt=0;\\n            }else if(dist[curr]==currDist){\\n                nodes.get(curr).amt/=2;\\n            }\\n\\n            curr=nodes.get(curr).par;\\n            currDist++;\\n        }\\n\\n        dfs(nodes,adj,nodes.get(0).amt,0);\\n        return max;\\n    }\\n\\n    public void setParent(ArrayList<Node> nodes,ArrayList<ArrayList<Integer>> adj,int []dist,int currN, int currD){\\n        dist[currN]=currD;\\n\\n        for(int nbr:adj.get(currN)){\\n            if(nodes.get(nbr).par==-1){\\n                nodes.get(nbr).par=currN;\\n                setParent(nodes,adj,dist,nbr,currD+1);\\n            }\\n        }\\n    }\\n\\n    public void dfs(ArrayList<Node> nodes,ArrayList<ArrayList<Integer>> adj,int cost,int i){\\n        if(nodes.get(i).vis){\\n            return;\\n        }\\n\\n        nodes.get(i).vis=true;\\n        if(nodes.get(i).leaf){\\n            System.out.println(cost);\\n            max=Math.max(max,cost);\\n            return;\\n        }\\n\\n        for(int nbr:adj.get(i)){\\n            if(nodes.get(nbr).vis){\\n                continue;\\n            }\\n\\n        dfs(nodes,adj,cost+nodes.get(nbr).amt,nbr);\\n        }\\n    }\\n}\\n\\nclass Node{\\n    int idx;\\n    int amt;\\n    boolean vis;\\n    boolean leaf;\\n    int par;\\n\\n    public Node(int idx,int amt){\\n        this.idx=idx;\\n        this.amt=amt;\\n        this.vis=false;\\n        this.leaf=false;\\n        this.par=-1;\\n    }\\n}\\n\\nclass Pair{\\n    Node node;\\n    int cost;\\n\\n    public Pair(Node node, int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        ArrayList<Node> nodes=new ArrayList<>();\\n        int n=amount.length;\\n        for(int i=0;i<n;i++){\\n            nodes.add(new Node(i,amount[i]));\\n        }\\n\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int []e:edges){\\n            int s=e[0];\\n            int d=e[1];\\n\\n            adj.get(s).add(d);\\n            adj.get(d).add(s);\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            if(adj.get(i).size()==1){\\n                nodes.get(i).leaf=true;\\n            }\\n        }\\n\\n        \\n        int []dist=new int[n];\\n        nodes.get(0).par=0;\\n        setParent(nodes,adj,dist,0,0);\\n\\n        int curr=bob;\\n        int currDist=0;\\n\\n        while(curr!=0){\\n            if(dist[curr]>currDist){\\n                nodes.get(curr).amt=0;\\n            }else if(dist[curr]==currDist){\\n                nodes.get(curr).amt/=2;\\n            }\\n\\n            curr=nodes.get(curr).par;\\n            currDist++;\\n        }\\n\\n        dfs(nodes,adj,nodes.get(0).amt,0);\\n        return max;\\n    }\\n\\n    public void setParent(ArrayList<Node> nodes,ArrayList<ArrayList<Integer>> adj,int []dist,int currN, int currD){\\n        dist[currN]=currD;\\n\\n        for(int nbr:adj.get(currN)){\\n            if(nodes.get(nbr).par==-1){\\n                nodes.get(nbr).par=currN;\\n                setParent(nodes,adj,dist,nbr,currD+1);\\n            }\\n        }\\n    }\\n\\n    public void dfs(ArrayList<Node> nodes,ArrayList<ArrayList<Integer>> adj,int cost,int i){\\n        if(nodes.get(i).vis){\\n            return;\\n        }\\n\\n        nodes.get(i).vis=true;\\n        if(nodes.get(i).leaf){\\n            System.out.println(cost);\\n            max=Math.max(max,cost);\\n            return;\\n        }\\n\\n        for(int nbr:adj.get(i)){\\n            if(nodes.get(nbr).vis){\\n                continue;\\n            }\\n\\n        dfs(nodes,adj,cost+nodes.get(nbr).amt,nbr);\\n        }\\n    }\\n}\\n\\nclass Node{\\n    int idx;\\n    int amt;\\n    boolean vis;\\n    boolean leaf;\\n    int par;\\n\\n    public Node(int idx,int amt){\\n        this.idx=idx;\\n        this.amt=amt;\\n        this.vis=false;\\n        this.leaf=false;\\n        this.par=-1;\\n    }\\n}\\n\\nclass Pair{\\n    Node node;\\n    int cost;\\n\\n    public Pair(Node node, int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100679,
                "title": "dfs-c",
                "content": "# Intuition\\n<!--\\nhere I first run dfs on bob and kept track of all the paths that comes between bob node and root node ans whenever I reach to node 0 from bob from each path I call the dfs for alice and by using bob timestamp and alice timestamp I decide whether to take that amount or not or whether they share the credit or not while return it goes the maximum income that alice got. \\n -->\\n\\n# Approach\\n<!-- here I created two dfs one is for bob and other is for alice as when every path from bob node to 0 node gets It calls the alice dfs algorithm  -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alicedfs(int node,int steps,vector<int> *adj,vector<int> &bob, vector<int> &amount, vector<int> &vis){\\n        vis[node]=steps;\\n        int res=0;\\n        if(bob[node]==steps){\\n            res=amount[node]/2;\\n        }\\n        else if(bob[node]==-1 || steps<bob[node]){\\n            res=amount[node];\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(int i:adj[node]){\\n            if(vis[i]==-1){\\n                ans=max(ans,alicedfs(i,steps+1,adj,bob,amount,vis));\\n            }\\n        }\\n        vis[node]=-1;\\n        if(ans==INT_MIN) return res;\\n        return res+ans;\\n        \\n    }\\n    int bobdfs(int node,vector<int> *adj,vector<int> &vis,vector<int> &amount,int steps,int alice){\\n        int income=INT_MIN;\\n        vis[node]=steps;\\n        for(int i:adj[node]){\\n            if(vis[i]==-1){\\n                income=max(income,bobdfs(i,adj,vis,amount,steps+1,alice));\\n            }\\n        }\\n        \\n        if(node==0){\\n            vector<int> alicevis(amount.size(),-1);\\n            return alicedfs(alice,1,adj,vis,amount,alicevis);\\n        }\\n        vis[node]=-1;\\n        \\n        return income;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<int> vis(n,-1);\\n        int ans=bobdfs(bob,adj,vis,amount,1,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alicedfs(int node,int steps,vector<int> *adj,vector<int> &bob, vector<int> &amount, vector<int> &vis){\\n        vis[node]=steps;\\n        int res=0;\\n        if(bob[node]==steps){\\n            res=amount[node]/2;\\n        }\\n        else if(bob[node]==-1 || steps<bob[node]){\\n            res=amount[node];\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(int i:adj[node]){\\n            if(vis[i]==-1){\\n                ans=max(ans,alicedfs(i,steps+1,adj,bob,amount,vis));\\n            }\\n        }\\n        vis[node]=-1;\\n        if(ans==INT_MIN) return res;\\n        return res+ans;\\n        \\n    }\\n    int bobdfs(int node,vector<int> *adj,vector<int> &vis,vector<int> &amount,int steps,int alice){\\n        int income=INT_MIN;\\n        vis[node]=steps;\\n        for(int i:adj[node]){\\n            if(vis[i]==-1){\\n                income=max(income,bobdfs(i,adj,vis,amount,steps+1,alice));\\n            }\\n        }\\n        \\n        if(node==0){\\n            vector<int> alicevis(amount.size(),-1);\\n            return alicedfs(alice,1,adj,vis,amount,alicevis);\\n        }\\n        vis[node]=-1;\\n        \\n        return income;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<int> vis(n,-1);\\n        int ans=bobdfs(bob,adj,vis,amount,1,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099045,
                "title": "java-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList();\\n        int n = amount.length;\\n        for(int i=0;i<n;i++) adj.add(new ArrayList());\\n        for(int[] edge : edges){\\n            int a = edge[0];\\n            int b = edge[1];\\n            adj.get(a).add(b);\\n            adj.get(b).add(a);\\n        }\\n        helper(adj, amount, bob, 0, -1, 0);\\n        return dfs(adj, amount, 0, -1);\\n\\n    }\\n\\n    private double helper(ArrayList<ArrayList<Integer>> adj,int[] amount, int target, int root, int parent, double dist){\\n        if (target == root) {\\n            amount[root] = 0;\\n            return dist;\\n        }\\n\\n        for(int child : adj.get(root)){\\n\\n            if (child == parent) continue;\\n            double ans = helper(adj, amount, target, child, root, dist+1);\\n            if (ans>0) {\\n                if (dist > ans/2) amount[root] = 0;\\n                else if (dist==ans/2) amount[root] /= 2;\\n                return ans;\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n\\n    private int dfs( ArrayList<ArrayList<Integer>> adj, int[] amount, int root, int parent){\\n        int max = Integer.MIN_VALUE;\\n        for(int child : adj.get(root)){\\n            if (child == parent) continue;\\n            max = Math.max(max, dfs(adj, amount, child, root));\\n        }\\n        return amount[root] + (max == Integer.MIN_VALUE ? 0 : max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList();\\n        int n = amount.length;\\n        for(int i=0;i<n;i++) adj.add(new ArrayList());\\n        for(int[] edge : edges){\\n            int a = edge[0];\\n            int b = edge[1];\\n            adj.get(a).add(b);\\n            adj.get(b).add(a);\\n        }\\n        helper(adj, amount, bob, 0, -1, 0);\\n        return dfs(adj, amount, 0, -1);\\n\\n    }\\n\\n    private double helper(ArrayList<ArrayList<Integer>> adj,int[] amount, int target, int root, int parent, double dist){\\n        if (target == root) {\\n            amount[root] = 0;\\n            return dist;\\n        }\\n\\n        for(int child : adj.get(root)){\\n\\n            if (child == parent) continue;\\n            double ans = helper(adj, amount, target, child, root, dist+1);\\n            if (ans>0) {\\n                if (dist > ans/2) amount[root] = 0;\\n                else if (dist==ans/2) amount[root] /= 2;\\n                return ans;\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n\\n    private int dfs( ArrayList<ArrayList<Integer>> adj, int[] amount, int root, int parent){\\n        int max = Integer.MIN_VALUE;\\n        for(int child : adj.get(root)){\\n            if (child == parent) continue;\\n            max = Math.max(max, dfs(adj, amount, child, root));\\n        }\\n        return amount[root] + (max == Integer.MIN_VALUE ? 0 : max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095166,
                "title": "python-one-dfs-explanation",
                "content": "**The Logic**:\\n\\nI solved the task with DFS. The inputs are the current node, its parent, and the depth of the level.\\nDFS returns how many steps Bob makes to go towards 0 and the `res` - the maximum profit below the current node. \\nLet\\'s consider the path from the root to Bob: if it happens, that the current depth is higher than the Bob steps, it means Bob was already there, and that is why he opened all gates. If they are equal, we are on the same node with Bob and share the profit, and if the current depth is lower than Bob\\'s steps, then we open that gate.\\nBut what happens for other paths which do not intersect with the Bob (but they will anyway intersect at least at node 0)? \\nFor them, we return Bob\\'s path as `bob_depth = len(edges) + 1` - it is the maximum possible path Bob can make plus one. Why - answer later. So, all our depths will be always lower than Bob\\'s steps and that is why we will open the gate.\\nWhy ` len(edges) + 1`. We have a tree. Let\\'s imagine it is not balanced - only one child for each tree. The depth will be len(edges) according to the algorithm below. But we assign `bob_depth = len(edges) + 1`. \\n\\n\\n```\\nfrom collections import deque, defaultdict\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        G = defaultdict(list)\\n        for v1, v2 in edges:\\n            G[v1].append(v2)\\n            G[v2].append(v1)\\n            \\n        def dfs(v, par, dep):\\n            nonlocal edges\\n            bob_depth = len(edges) + 1\\n            res = float(\\'-inf\\')\\n            for ch in G[v]:\\n                if ch == par:\\n                    continue\\n                cur_bob_depth, cur_res = dfs(ch, v, dep + 1)\\n                bob_depth = min(bob_depth, cur_bob_depth)\\n                res = max(res, cur_res)\\n            if bob == v:\\n                bob_depth = 0\\n            if res == float(\\'-inf\\'):\\n                res = 0\\n            if dep < bob_depth:\\n                res += amount[v]\\n            elif dep == bob_depth:\\n                res += amount[v] // 2\\n            return bob_depth + 1, res\\n        _, ans = dfs(0, -1, 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        G = defaultdict(list)\\n        for v1, v2 in edges:\\n            G[v1].append(v2)\\n            G[v2].append(v1)\\n            \\n        def dfs(v, par, dep):\\n            nonlocal edges\\n            bob_depth = len(edges) + 1\\n            res = float(\\'-inf\\')\\n            for ch in G[v]:\\n                if ch == par:\\n                    continue\\n                cur_bob_depth, cur_res = dfs(ch, v, dep + 1)\\n                bob_depth = min(bob_depth, cur_bob_depth)\\n                res = max(res, cur_res)\\n            if bob == v:\\n                bob_depth = 0\\n            if res == float(\\'-inf\\'):\\n                res = 0\\n            if dep < bob_depth:\\n                res += amount[v]\\n            elif dep == bob_depth:\\n                res += amount[v] // 2\\n            return bob_depth + 1, res\\n        _, ans = dfs(0, -1, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094990,
                "title": "dfs-based-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    1.  1-DFS \\n\\t\\ta. Approach inspired from Lee\\'s Discuss post\\n\\t\\tb. Simulatenously update the maximum amount in bottom up fashion\\n\\t\\t\\n\\tint INF = 1e9;\\n    vector<vector<int>> adj;\\n    vector<int> dfs(int i, int par, int time, int target,const vector<int>& a){\\n        int res = -INF, db = INF;\\n        if(i == target){\\n            db = 0;\\n        }\\n        for(int &ch : adj[i]){\\n            if(ch != par){\\n                auto ret = dfs(ch, i, time + 1, target, a);\\n                res = max(res, ret[0]);\\n                db = min(db, ret[1]);\\n            }\\n        }\\n        if(res == -INF){\\n            res = 0;\\n        }\\n        if(time == db){\\n            res += a[i]/2;\\n        } else if(time < db){\\n            res += a[i];\\n        } else {\\n            // do nothing\\n        }\\n        return {res, db + 1};\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        adj.resize(n);\\n        for(auto& v : edges){\\n            int to = v[0], from = v[1];\\n            adj[from].push_back(to);\\n            adj[to].push_back(from);\\n        }\\n        auto ret = dfs(0, -1, 0, bob, amount);\\n        return ret[0];\\n    }\\n\\t\\n\\t\\n    2.  2-DFS based solution\\n\\t\\ta. Figure out at what time does Bob visit a node. \\n\\t\\tb. Now when A starts to move, if his visiting time is less than the visitng time of Bob , then A can collect the amount. \\n\\t\\t   If he visits later than Bob then there\\'s nothing for A. If the time at which they visit is equal then they share the amount.\\n\\t\\t\\n    int INF = 1e9, ans = INT_MIN;\\n    vector<vector<int>> adj;\\n    vector<int> time;\\n    vector<int> trace(int i, int target, int par){\\n        vector<int> ans;\\n        if(i == target){\\n            ans.push_back(i);\\n            return ans;\\n        }\\n        for(int &ch : adj[i]){\\n            if(ch != par){\\n                auto ret = trace(ch, target, i);\\n                if(ret.size() > 0){\\n                    ans.push_back(i);\\n                    ans.insert(ans.end(), ret.begin(), ret.end());\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    void dfs(int i, int par, vector<int>& a, int t, int sum){\\n        if(t == time[i]){\\n            sum += a[i]/2;\\n        } else if(t > time[i]){\\n            // nothing will happen here\\n        } else if(t < time[i]) {\\n            sum += a[i];\\n        }\\n        bool isroot = true;\\n        for(int &ch : adj[i]){\\n            if(ch != par){\\n                isroot = false;\\n                dfs(ch, i, a, t + 1, sum);\\n            }\\n        }\\n        if(isroot){\\n            ans = max(ans, sum);\\n        }\\n        return;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        time.resize(n, INF);\\n        adj.resize(n);\\n        for(auto& v : edges){\\n            int to = v[0], from = v[1];\\n            adj[from].push_back(to);\\n            adj[to].push_back(from);\\n        }\\n\\t\\t// tracing the path Bob takes and calculating time it takes for Bob to visit those nodes in the path\\n        vector<int> path = trace(0, bob, -1);\\n        for(int i = path.size() - 1, t = 0; i >= 0; --i, t++){\\n            time[path[i]] = t;\\n        }\\n\\t\\t\\n        ans = -INF;\\n        dfs(0, -1, amount, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    1.  1-DFS \\n\\t\\ta. Approach inspired from Lee\\'s Discuss post\\n\\t\\tb. Simulatenously update the maximum amount in bottom up fashion\\n\\t\\t\\n\\tint INF = 1e9;\\n    vector<vector<int>> adj;\\n    vector<int> dfs(int i, int par, int time, int target,const vector<int>& a){\\n        int res = -INF, db = INF;\\n        if(i == target){\\n            db = 0;\\n        }\\n        for(int &ch : adj[i]){\\n            if(ch != par){\\n                auto ret = dfs(ch, i, time + 1, target, a);\\n                res = max(res, ret[0]);\\n                db = min(db, ret[1]);\\n            }\\n        }\\n        if(res == -INF){\\n            res = 0;\\n        }\\n        if(time == db){\\n            res += a[i]/2;\\n        } else if(time < db){\\n            res += a[i];\\n        } else {\\n            // do nothing\\n        }\\n        return {res, db + 1};\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        adj.resize(n);\\n        for(auto& v : edges){\\n            int to = v[0], from = v[1];\\n            adj[from].push_back(to);\\n            adj[to].push_back(from);\\n        }\\n        auto ret = dfs(0, -1, 0, bob, amount);\\n        return ret[0];\\n    }\\n\\t\\n\\t\\n    2.  2-DFS based solution\\n\\t\\ta. Figure out at what time does Bob visit a node. \\n\\t\\tb. Now when A starts to move, if his visiting time is less than the visitng time of Bob , then A can collect the amount. \\n\\t\\t   If he visits later than Bob then there\\'s nothing for A. If the time at which they visit is equal then they share the amount.\\n\\t\\t\\n    int INF = 1e9, ans = INT_MIN;\\n    vector<vector<int>> adj;\\n    vector<int> time;\\n    vector<int> trace(int i, int target, int par){\\n        vector<int> ans;\\n        if(i == target){\\n            ans.push_back(i);\\n            return ans;\\n        }\\n        for(int &ch : adj[i]){\\n            if(ch != par){\\n                auto ret = trace(ch, target, i);\\n                if(ret.size() > 0){\\n                    ans.push_back(i);\\n                    ans.insert(ans.end(), ret.begin(), ret.end());\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    void dfs(int i, int par, vector<int>& a, int t, int sum){\\n        if(t == time[i]){\\n            sum += a[i]/2;\\n        } else if(t > time[i]){\\n            // nothing will happen here\\n        } else if(t < time[i]) {\\n            sum += a[i];\\n        }\\n        bool isroot = true;\\n        for(int &ch : adj[i]){\\n            if(ch != par){\\n                isroot = false;\\n                dfs(ch, i, a, t + 1, sum);\\n            }\\n        }\\n        if(isroot){\\n            ans = max(ans, sum);\\n        }\\n        return;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        time.resize(n, INF);\\n        adj.resize(n);\\n        for(auto& v : edges){\\n            int to = v[0], from = v[1];\\n            adj[from].push_back(to);\\n            adj[to].push_back(from);\\n        }\\n\\t\\t// tracing the path Bob takes and calculating time it takes for Bob to visit those nodes in the path\\n        vector<int> path = trace(0, bob, -1);\\n        for(int i = path.size() - 1, t = 0; i >= 0; --i, t++){\\n            time[path[i]] = t;\\n        }\\n\\t\\t\\n        ans = -INF;\\n        dfs(0, -1, amount, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094157,
                "title": "dfs-map-c-easy-understanding",
                "content": "//First we will make adjacency list.\\n//Then we will find a unique path for bob to the root node,\\n//we count the steps for bob ,\\n//Node :0,Steps Count :2\\n//Node :1,Steps Count :1\\n//Node :3,Steps Count :0.for given First example\\n//edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6].\\n\\n```\\npublic:\\nint mx=INT_MIN;//for comparing max value path.\\nbool bobPath(int node,int parent,int steps,unordered_map &BobPathStep,vector> &adj){\\nBobPathStep[node]=steps;\\nif(node==0){\\nreturn true;\\n}\\n\\n    for(int next_node:adj[node]){\\n        if(next_node==parent) continue;\\n        if(bobPath(next_node,node,steps+1,BobPathStep,adj)){\\n            return true;\\n        }\\n    }\\n    BobPathStep.erase(node);\\n    return false;\\n}\\nvoid alicePath(int node,int parent,int netIncome,int steps,vector& amount,unordered_map &BobPathStep,vector> &adj){\\n    if(BobPathStep.find(node)!=BobPathStep.end()){\\n        int aliceStep=steps;\\n        int bobStep=BobPathStep[node];\\n        if(aliceStep==bobStep){\\n            netIncome+=amount[node]/2;\\n        }\\n        else if(bobStep>aliceStep){\\n            netIncome+=amount[node];\\n        }\\n    }\\n    else{\\n        netIncome+=amount[node];\\n    }\\n    if(adj[node].size()==1&&adj[node][0]==parent){//for leaf node\\n        mx=max(mx,netIncome);\\n        return;\\n    }\\n    for(int next_node:adj[node]){\\n        if(next_node==parent) continue;\\n        alicePath(next_node,node,netIncome,steps+1,amount,BobPathStep,adj);\\n    }\\n}\\nint mostProfitablePath(vector>& edges, int bob, vector& amount) {\\n    unordered_map BobPathStep;//save steps for bob which travels through the node\\n    //we use this for alice \\n    vector> adj(amount.size(),vector());\\n    for(vector edge:edges){\\n        adj[edge[0]].push_back(edge[1]);\\n        adj[edge[1]].push_back(edge[0]);\\n    }\\n    bobPath(bob,-1,0,BobPathStep,adj);\\n    alicePath(0,-1,0,0,amount,BobPathStep,adj);\\n    return mx;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\npublic:\\nint mx=INT_MIN;//for comparing max value path.\\nbool bobPath(int node,int parent,int steps,unordered_map &BobPathStep,vector> &adj){\\nBobPathStep[node]=steps;\\nif(node==0){\\nreturn true;\\n}\\n\\n    for(int next_node:adj[node]){\\n        if(next_node==parent) continue;\\n        if(bobPath(next_node,node,steps+1,BobPathStep,adj)){\\n            return true;\\n        }\\n    }\\n    BobPathStep.erase(node);\\n    return false;\\n}\\nvoid alicePath(int node,int parent,int netIncome,int steps,vector& amount,unordered_map &BobPathStep,vector> &adj){\\n    if(BobPathStep.find(node)!=BobPathStep.end()){\\n        int aliceStep=steps;\\n        int bobStep=BobPathStep[node];\\n        if(aliceStep==bobStep){\\n            netIncome+=amount[node]/2;\\n        }\\n        else if(bobStep>aliceStep){\\n            netIncome+=amount[node];\\n        }\\n    }\\n    else{\\n        netIncome+=amount[node];\\n    }\\n    if(adj[node].size()==1&&adj[node][0]==parent){//for leaf node\\n        mx=max(mx,netIncome);\\n        return;\\n    }\\n    for(int next_node:adj[node]){\\n        if(next_node==parent) continue;\\n        alicePath(next_node,node,netIncome,steps+1,amount,BobPathStep,adj);\\n    }\\n}\\nint mostProfitablePath(vector>& edges, int bob, vector& amount) {\\n    unordered_map BobPathStep;//save steps for bob which travels through the node\\n    //we use this for alice \\n    vector> adj(amount.size(),vector());\\n    for(vector edge:edges){\\n        adj[edge[0]].push_back(edge[1]);\\n        adj[edge[1]].push_back(edge[0]);\\n    }\\n    bobPath(bob,-1,0,BobPathStep,adj);\\n    alicePath(0,-1,0,0,amount,BobPathStep,adj);\\n    return mx;\\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3065266,
                "title": "python-super-easy-two-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n    n = len(amount)\\n    tree = collections.defaultdict(list)\\n    parent = [0] * n\\n    alice_dist = [-1] * n\\n\\n    for u, v in edges:\\n      tree[u].append(v)\\n      tree[v].append(u)\\n\\n\\n    def dfs(u: int, prev: int, d: int) -> None:\\n      parent[u] = prev\\n      alice_dist[u] = d\\n      for v in tree[u]:\\n        if alice_dist[v] == -1:\\n          dfs(v, u, d + 1)\\n\\n    dfs(0, -1, 0)\\n\\n\\n    u = bob\\n    d = 0\\n    while u != 0:\\n      if d < alice_dist[u]:\\n        amount[u] = 0\\n      elif d == alice_dist[u]:\\n        amount[u] //= 2\\n      u = parent[u]\\n      d += 1\\n\\n    visit = set()\\n    def dfs(root):\\n        visit.add(root)\\n        d = amount[root]\\n        l = float(\"-inf\")\\n        for v in tree[root]:\\n            if v not in visit:\\n                l = max(l, d + dfs(v))\\n        return l if l != float(\"-inf\") else d\\n       \\n    return dfs(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n    n = len(amount)\\n    tree = collections.defaultdict(list)\\n    parent = [0] * n\\n    alice_dist = [-1] * n\\n\\n    for u, v in edges:\\n      tree[u].append(v)\\n      tree[v].append(u)\\n\\n\\n    def dfs(u: int, prev: int, d: int) -> None:\\n      parent[u] = prev\\n      alice_dist[u] = d\\n      for v in tree[u]:\\n        if alice_dist[v] == -1:\\n          dfs(v, u, d + 1)\\n\\n    dfs(0, -1, 0)\\n\\n\\n    u = bob\\n    d = 0\\n    while u != 0:\\n      if d < alice_dist[u]:\\n        amount[u] = 0\\n      elif d == alice_dist[u]:\\n        amount[u] //= 2\\n      u = parent[u]\\n      d += 1\\n\\n    visit = set()\\n    def dfs(root):\\n        visit.add(root)\\n        d = amount[root]\\n        l = float(\"-inf\")\\n        for v in tree[root]:\\n            if v not in visit:\\n                l = max(l, d + dfs(v))\\n        return l if l != float(\"-inf\") else d\\n       \\n    return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051686,
                "title": "2-dfs-simple-c-solution",
                "content": "# Approach\\nIn first dfs we will store how much time bob will take to reach a particular node in order to reach root(0).\\nThen we will start moving alice and will find amount respectively\\n\\n# Complexity\\n- Time complexity: O(2N)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> path, amount;   \\n    bool dfs1(int node,int par,int dist,vector<int> adj[]){\\n        bool dec = false;\\n        for(auto child : adj[node]){\\n            if(child == par) continue;\\n            dec |= dfs1(child,node,dist+1,adj);\\n        }\\n        if(dec or !node) path[node] = min(path[node],dist);\\n        return !node or dec;\\n    }\\n    int dfs2(int node,int par,int dist,vector<int> adj[]){\\n        int ans = -1e9;\\n        for(auto child : adj[node]){\\n            if(child == par) continue;\\n            ans = max(ans,dfs2(child,node,dist+1,adj));\\n        }\\n        int net_profit;\\n        if(path[node] < dist){\\n            net_profit = 0;\\n        }else if(path[node] == dist){\\n            net_profit = amount[node]/2;\\n        }else{\\n            net_profit = amount[node];\\n        }\\n        return net_profit + (ans == -1e9 ? 0 : ans);\\n    }\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        path.resize(edges.size()+1,1e9);\\n        this->amount = amount;\\n        vector<int> adj[edges.size()+1];\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        dfs1(bob,-1,0,adj);\\n        return dfs2(0,-1,0,adj);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> path, amount;   \\n    bool dfs1(int node,int par,int dist,vector<int> adj[]){\\n        bool dec = false;\\n        for(auto child : adj[node]){\\n            if(child == par) continue;\\n            dec |= dfs1(child,node,dist+1,adj);\\n        }\\n        if(dec or !node) path[node] = min(path[node],dist);\\n        return !node or dec;\\n    }\\n    int dfs2(int node,int par,int dist,vector<int> adj[]){\\n        int ans = -1e9;\\n        for(auto child : adj[node]){\\n            if(child == par) continue;\\n            ans = max(ans,dfs2(child,node,dist+1,adj));\\n        }\\n        int net_profit;\\n        if(path[node] < dist){\\n            net_profit = 0;\\n        }else if(path[node] == dist){\\n            net_profit = amount[node]/2;\\n        }else{\\n            net_profit = amount[node];\\n        }\\n        return net_profit + (ans == -1e9 ? 0 : ans);\\n    }\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        path.resize(edges.size()+1,1e9);\\n        this->amount = amount;\\n        vector<int> adj[edges.size()+1];\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        dfs1(bob,-1,0,adj);\\n        return dfs2(0,-1,0,adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047935,
                "title": "java-intuitive-solution-dfs-backtracking-time-o-v-e-and-space-o-v-e",
                "content": "# Intuition\\nInitial thoughts were this may a pretty straighforward DFS for Bob first then Alice. It turned out to be little more than simple DFS as it required backtracking with a couple of edge cases. It was little tougher than I initially expected but good for practicing edge cases coding. I could have made this code little simpler by separating the bob\\'s DFS and alice\\'s DFS in separate functions. I would have separated them if I knew there were this many edges beforehand but since I realized after I started coding I didn\\'t bother doing that.\\n\\n# Approach\\n1) DFS for bob first and maintain the list of visit steps for each node only in the right path -> I did this by using a global variable to check if bob reached his goal and if he didn\\'t backtrack.\\n\\n2) DFS for alice and check if alice\\'s visit step matches with bob\\'s then take half of the amout at the node, if bob\\'s visit step is larger than alice\\'s than take full amount or else don\\'t take anything since bob would have already taken it first.\\n\\n3) Backtracking is the key here with a special case for bob\\'s wrong path.\\n\\n# Complexity\\n- Time complexity:\\nO(V+E)\\n\\n- Space complexity:\\nO(V+E)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private List<List<Integer>> ADJENCY = new ArrayList<>();\\n    private boolean[] INDIVIDUAL_VISIT;\\n    private int[] VISIT_BY_BOB;\\n    private int MAX_INCOME_ALICE = Integer.MIN_VALUE;\\n    private int BOB;\\n    private boolean BOB_REACHED_GOAL = false;\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        for(int i = 0; i <= edges.length; i++)     \\n            this.ADJENCY.add(new ArrayList<>());\\n        \\n        this.VISIT_BY_BOB = new int[edges.length+1];\\n        Arrays.fill(this.VISIT_BY_BOB, -1);\\n\\n        this.BOB = bob;\\n        this.INDIVIDUAL_VISIT = new boolean[edges.length+1];\\n\\n        for(int[] edge: edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n\\n            this.ADJENCY.get(a).add(b);\\n            this.ADJENCY.get(b).add(a);\\n        }\\n\\n        this.VISIT_BY_BOB[bob] = 0;\\n        dfs(bob, 0, 1, 0, amount);\\n        \\n        this.INDIVIDUAL_VISIT = new boolean[edges.length+1];\\n        dfs(0, amount[0], 0, 0, amount);\\n\\n        return this.MAX_INCOME_ALICE;\\n    }\\n\\n    private void dfs(int source, int incomeSoFar, int person, int visitStep, int[] amount) {\\n        \\n        if(person == 0) {\\n            if(this.ADJENCY.get(source).size() == 1 && source != 0) {\\n                this.MAX_INCOME_ALICE = Math.max(this.MAX_INCOME_ALICE, incomeSoFar);\\n                return;\\n            } \\n        } else if(person == 1) {\\n            if(source == 0 ) {\\n                this.BOB_REACHED_GOAL = true;\\n                return;\\n            } else if(this.ADJENCY.get(source).size() == 1 && source != this.BOB) {\\n                return;\\n            }\\n        }\\n\\n        if(this.INDIVIDUAL_VISIT[source])\\n            return;\\n\\n        this.INDIVIDUAL_VISIT[source] = true;\\n\\n        for(Integer destination : this.ADJENCY.get(source)) {\\n            if(person == 1 && this.VISIT_BY_BOB[destination] == -1 && this.BOB_REACHED_GOAL == false) {\\n                this.VISIT_BY_BOB[destination] = visitStep+1;\\n\\n                dfs(destination, incomeSoFar, person, visitStep+1, amount);\\n\\n                if(this.BOB_REACHED_GOAL == false)\\n                    this.VISIT_BY_BOB[destination] = -1;\\n                    \\n            } else if(person == 0) {\\n\\n                int half = 0;\\n                int full = 0;\\n\\n                if(this.VISIT_BY_BOB[destination] == visitStep+1 && this.INDIVIDUAL_VISIT[destination] == false) {\\n                    half = amount[destination]/2;\\n                    incomeSoFar += half;\\n                } else if(this.VISIT_BY_BOB[destination] > visitStep+1 || this.VISIT_BY_BOB[destination] == -1) {\\n                    full = amount[destination];\\n                    incomeSoFar += full;\\n                }\\n\\n                dfs(destination, incomeSoFar, person, visitStep+1, amount);\\n\\n                if(this.VISIT_BY_BOB[destination] == visitStep+1) {\\n                    incomeSoFar -= half;\\n                } else if(this.VISIT_BY_BOB[destination] > visitStep+1 || this.VISIT_BY_BOB[destination] == -1) {\\n                    incomeSoFar -= full;\\n                }\\n            }\\n        }\\n\\n        this.INDIVIDUAL_VISIT[source] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private List<List<Integer>> ADJENCY = new ArrayList<>();\\n    private boolean[] INDIVIDUAL_VISIT;\\n    private int[] VISIT_BY_BOB;\\n    private int MAX_INCOME_ALICE = Integer.MIN_VALUE;\\n    private int BOB;\\n    private boolean BOB_REACHED_GOAL = false;\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        for(int i = 0; i <= edges.length; i++)     \\n            this.ADJENCY.add(new ArrayList<>());\\n        \\n        this.VISIT_BY_BOB = new int[edges.length+1];\\n        Arrays.fill(this.VISIT_BY_BOB, -1);\\n\\n        this.BOB = bob;\\n        this.INDIVIDUAL_VISIT = new boolean[edges.length+1];\\n\\n        for(int[] edge: edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n\\n            this.ADJENCY.get(a).add(b);\\n            this.ADJENCY.get(b).add(a);\\n        }\\n\\n        this.VISIT_BY_BOB[bob] = 0;\\n        dfs(bob, 0, 1, 0, amount);\\n        \\n        this.INDIVIDUAL_VISIT = new boolean[edges.length+1];\\n        dfs(0, amount[0], 0, 0, amount);\\n\\n        return this.MAX_INCOME_ALICE;\\n    }\\n\\n    private void dfs(int source, int incomeSoFar, int person, int visitStep, int[] amount) {\\n        \\n        if(person == 0) {\\n            if(this.ADJENCY.get(source).size() == 1 && source != 0) {\\n                this.MAX_INCOME_ALICE = Math.max(this.MAX_INCOME_ALICE, incomeSoFar);\\n                return;\\n            } \\n        } else if(person == 1) {\\n            if(source == 0 ) {\\n                this.BOB_REACHED_GOAL = true;\\n                return;\\n            } else if(this.ADJENCY.get(source).size() == 1 && source != this.BOB) {\\n                return;\\n            }\\n        }\\n\\n        if(this.INDIVIDUAL_VISIT[source])\\n            return;\\n\\n        this.INDIVIDUAL_VISIT[source] = true;\\n\\n        for(Integer destination : this.ADJENCY.get(source)) {\\n            if(person == 1 && this.VISIT_BY_BOB[destination] == -1 && this.BOB_REACHED_GOAL == false) {\\n                this.VISIT_BY_BOB[destination] = visitStep+1;\\n\\n                dfs(destination, incomeSoFar, person, visitStep+1, amount);\\n\\n                if(this.BOB_REACHED_GOAL == false)\\n                    this.VISIT_BY_BOB[destination] = -1;\\n                    \\n            } else if(person == 0) {\\n\\n                int half = 0;\\n                int full = 0;\\n\\n                if(this.VISIT_BY_BOB[destination] == visitStep+1 && this.INDIVIDUAL_VISIT[destination] == false) {\\n                    half = amount[destination]/2;\\n                    incomeSoFar += half;\\n                } else if(this.VISIT_BY_BOB[destination] > visitStep+1 || this.VISIT_BY_BOB[destination] == -1) {\\n                    full = amount[destination];\\n                    incomeSoFar += full;\\n                }\\n\\n                dfs(destination, incomeSoFar, person, visitStep+1, amount);\\n\\n                if(this.VISIT_BY_BOB[destination] == visitStep+1) {\\n                    incomeSoFar -= half;\\n                } else if(this.VISIT_BY_BOB[destination] > visitStep+1 || this.VISIT_BY_BOB[destination] == -1) {\\n                    incomeSoFar -= full;\\n                }\\n            }\\n        }\\n\\n        this.INDIVIDUAL_VISIT[source] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031890,
                "title": "easy-java-solution-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        // 1. create a undirected graph\\n        // 2. find the path from 0 to bob \\n        // 3. DFS traversal \\n\\n        //1.\\n        List<List<Integer>>adj=new ArrayList<>();\\n        int n =amount.length;\\n\\n        for(int i =0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        \\n        for(int i =0;i<edges.length;i++){\\n\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        //2. find path from 0 to bob\\n        List<Integer>path=new ArrayList<>();\\n        int parent[]=new int [n];\\n        dfs1(adj,parent,0,-1);\\n        int bobCopy=bob;\\n        path.add(bob);\\n        while(parent[bobCopy]!=-1){\\n            path.add(parent[bobCopy]);\\n            bobCopy=parent[bobCopy];\\n        }\\n        //System.out.println(path);\\n\\n        //3 .dfs\\n        boolean vis[]=new boolean[n];\\n        dfs(adj,amount,path,vis,0,0,-1);\\n        return max;\\n    }\\n    int itr=0;\\n    void dfs(List<List<Integer>>adj,int amt[],List<Integer>path,boolean[] vis,int sum,int i,int parent){\\n        \\n        if(itr<path.size() && path.get(itr)==i){\\n            sum+=amt[i]/2;\\n        }\\n        else if(!vis[i])\\n            sum+=amt[i];\\n\\n        if(adj.get(i).size()==1 && adj.get(i).get(0)==parent)\\n            max=Math.max(max,sum);\\n             \\n        //marking visited elements\\n        vis[i]=true;\\n        if(itr++<path.size())\\n            vis[path.get(itr-1)]=true;\\n        \\n        for(int neigh:adj.get(i)){\\n            if(parent==neigh)\\n                continue;\\n            dfs(adj,amt,path,vis,sum,neigh,i);\\n        }\\n\\n        vis[i]=false;\\n        itr--;\\n        if(itr<path.size())\\n            vis[path.get(itr)]=false;\\n    }\\n\\n    void dfs1(List<List<Integer>>adj,int par[],int i,int parent){\\n        par[i]=parent;\\n        for(int neigh:adj.get(i)){\\n            if(neigh==parent)\\n                continue;\\n            dfs1(adj,par,neigh,i);\\n        }\\n    }\\n}\\n```\\nRuntime :104ms Beats 73% \\nSpace : 85.1MB Beats 100%\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        // 1. create a undirected graph\\n        // 2. find the path from 0 to bob \\n        // 3. DFS traversal \\n\\n        //1.\\n        List<List<Integer>>adj=new ArrayList<>();\\n        int n =amount.length;\\n\\n        for(int i =0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        \\n        for(int i =0;i<edges.length;i++){\\n\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        //2. find path from 0 to bob\\n        List<Integer>path=new ArrayList<>();\\n        int parent[]=new int [n];\\n        dfs1(adj,parent,0,-1);\\n        int bobCopy=bob;\\n        path.add(bob);\\n        while(parent[bobCopy]!=-1){\\n            path.add(parent[bobCopy]);\\n            bobCopy=parent[bobCopy];\\n        }\\n        //System.out.println(path);\\n\\n        //3 .dfs\\n        boolean vis[]=new boolean[n];\\n        dfs(adj,amount,path,vis,0,0,-1);\\n        return max;\\n    }\\n    int itr=0;\\n    void dfs(List<List<Integer>>adj,int amt[],List<Integer>path,boolean[] vis,int sum,int i,int parent){\\n        \\n        if(itr<path.size() && path.get(itr)==i){\\n            sum+=amt[i]/2;\\n        }\\n        else if(!vis[i])\\n            sum+=amt[i];\\n\\n        if(adj.get(i).size()==1 && adj.get(i).get(0)==parent)\\n            max=Math.max(max,sum);\\n             \\n        //marking visited elements\\n        vis[i]=true;\\n        if(itr++<path.size())\\n            vis[path.get(itr-1)]=true;\\n        \\n        for(int neigh:adj.get(i)){\\n            if(parent==neigh)\\n                continue;\\n            dfs(adj,amt,path,vis,sum,neigh,i);\\n        }\\n\\n        vis[i]=false;\\n        itr--;\\n        if(itr<path.size())\\n            vis[path.get(itr)]=false;\\n    }\\n\\n    void dfs1(List<List<Integer>>adj,int par[],int i,int parent){\\n        par[i]=parent;\\n        for(int neigh:adj.get(i)){\\n            if(neigh==parent)\\n                continue;\\n            dfs1(adj,par,neigh,i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022812,
                "title": "javascript-one-pass-dfs",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nvar mostProfitablePath = function(edges, bob, amount) {\\n    const graph = Array.from({ length: edges.length + 1 }, () => []);\\n\\n    for (const [i, j] of edges)\\n        graph[i].push(j), graph[j].push(i);\\n    \\n    function aliceMoves(node, parent, time) {\\n        let totalBobTime = node == bob ? 0 : Infinity, newScore = -Infinity;\\n\\n        for (const child of graph[node]) {\\n            if (child == parent) continue;\\n\\n            const [score, bobTime] = aliceMoves(child, node, time + 1);\\n            totalBobTime = Math.min(totalBobTime, bobTime + 1);\\n            newScore = Math.max(newScore, score)\\n        }\\n\\n        if (newScore == -Infinity) newScore = 0;\\n        if (time < totalBobTime) newScore += amount[node];\\n        else if (time == totalBobTime) newScore += amount[node] / 2;\\n\\n        return [newScore, totalBobTime];\\n    }\\n    \\n    return aliceMoves(0, -1, 0)[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostProfitablePath = function(edges, bob, amount) {\\n    const graph = Array.from({ length: edges.length + 1 }, () => []);\\n\\n    for (const [i, j] of edges)\\n        graph[i].push(j), graph[j].push(i);\\n    \\n    function aliceMoves(node, parent, time) {\\n        let totalBobTime = node == bob ? 0 : Infinity, newScore = -Infinity;\\n\\n        for (const child of graph[node]) {\\n            if (child == parent) continue;\\n\\n            const [score, bobTime] = aliceMoves(child, node, time + 1);\\n            totalBobTime = Math.min(totalBobTime, bobTime + 1);\\n            newScore = Math.max(newScore, score)\\n        }\\n\\n        if (newScore == -Infinity) newScore = 0;\\n        if (time < totalBobTime) newScore += amount[node];\\n        else if (time == totalBobTime) newScore += amount[node] / 2;\\n\\n        return [newScore, totalBobTime];\\n    }\\n    \\n    return aliceMoves(0, -1, 0)[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011832,
                "title": "simple-dfs-80-faster-solution-based-on-hints",
                "content": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        \"\"\"\\n        Bob travels along a fixed path (from node \\u201Cbob\\u201D to node 0).\\n        \"\"\"\\n        edge_map = {i: set() for i in range(len(amount))}\\n        leaves = {i for i in range(len(amount))}\\n        for edge in edges:\\n            edge_map[edge[0]].add(edge[1])\\n            edge_map[edge[1]].add(edge[0])\\n            if edge[0] in leaves and len(edge_map[edge[0]]) > 1:\\n                leaves.remove(edge[0])\\n            if edge[1] in leaves and len(edge_map[edge[1]]) > 1:\\n                leaves.remove(edge[1])\\n\\n        bob_path = {}\\n        # bob\\'s travel\\n        def dfs(node=bob, parent=None, level=0):\\n            bob_path[node] = level\\n            if node == 0:\\n                return True\\n            for nei in edge_map[node]:\\n                if parent != nei:\\n                    if dfs(nei, node, level+1):\\n                        return True\\n            del bob_path[node]\\n            return False\\n        dfs()\\n        # remove 0 from leaves\\n        # Alice travel\\n        self.max_alice_score = float(\\'-inf\\')\\n        def dfs_alice(node, parent, level, score_so_far):\\n            if level < bob_path.get(node, float(\\'inf\\')):\\n                score_so_far += amount[node]\\n            elif level == bob_path.get(node, float(\\'inf\\')):\\n                score_so_far += amount[node]//2\\n\\n            if node in leaves and node != 0:\\n                self.max_alice_score = max(score_so_far, self.max_alice_score)\\n            for nei in edge_map[node]: \\n                if parent != nei:\\n                    dfs_alice(nei, node, level+1, score_so_far)\\n        dfs_alice(0, None, 0, 0)\\n        return self.max_alice_score\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        \"\"\"\\n        Bob travels along a fixed path (from node \\u201Cbob\\u201D to node 0).\\n        \"\"\"\\n        edge_map = {i: set() for i in range(len(amount))}\\n        leaves = {i for i in range(len(amount))}\\n        for edge in edges:\\n            edge_map[edge[0]].add(edge[1])\\n            edge_map[edge[1]].add(edge[0])\\n            if edge[0] in leaves and len(edge_map[edge[0]]) > 1:\\n                leaves.remove(edge[0])\\n            if edge[1] in leaves and len(edge_map[edge[1]]) > 1:\\n                leaves.remove(edge[1])\\n\\n        bob_path = {}\\n        # bob\\'s travel\\n        def dfs(node=bob, parent=None, level=0):\\n            bob_path[node] = level\\n            if node == 0:\\n                return True\\n            for nei in edge_map[node]:\\n                if parent != nei:\\n                    if dfs(nei, node, level+1):\\n                        return True\\n            del bob_path[node]\\n            return False\\n        dfs()\\n        # remove 0 from leaves\\n        # Alice travel\\n        self.max_alice_score = float(\\'-inf\\')\\n        def dfs_alice(node, parent, level, score_so_far):\\n            if level < bob_path.get(node, float(\\'inf\\')):\\n                score_so_far += amount[node]\\n            elif level == bob_path.get(node, float(\\'inf\\')):\\n                score_so_far += amount[node]//2\\n\\n            if node in leaves and node != 0:\\n                self.max_alice_score = max(score_so_far, self.max_alice_score)\\n            for nei in edge_map[node]: \\n                if parent != nei:\\n                    dfs_alice(nei, node, level+1, score_so_far)\\n        dfs_alice(0, None, 0, 0)\\n        return self.max_alice_score\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008542,
                "title": "c-o-n-logn-using-dijkstra-s-algorithm-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>path;\\n    void dfs(int node,vector<int>adj[],vector<int>&vis,vector<int>&v){\\n        if(!path.empty())return;\\n        vis[node]=1;\\n        v.push_back(node);\\n        if(node==0){\\n            path=v;\\n            v.pop_back();\\n            return;\\n        }\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,adj,vis,v);\\n            }\\n        }\\n        v.pop_back();\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=edges.size()+1;\\n        vector<int>adj[n];\\n        for(int i=0;i<n-1;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>steps(n,INT_MAX);\\n        vector<int>v;\\n        vector<int>vis(n,0);\\n        dfs(bob,adj,vis,v);\\n        for(int i=0;i<path.size();i++){\\n            steps[path[i]]=i;\\n        }\\n        vector<int>step(n,INT_MAX);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        q.push({-amount[0],0});\\n        for(int i=0;i<n;i++)vis[i]=0;\\n        vis[0]=1;\\n        step[0]=0;\\n        int ans=INT_MAX;\\n        while(!q.empty()){\\n            int node=q.top().second;\\n            int d=q.top().first;\\n            q.pop();\\n            int cnt=0;\\n            for(auto it:adj[node]){\\n                if(!vis[it]){\\n                    cnt++;\\n                    step[it]=step[node]+1;\\n                    vis[it]=1;\\n                    int d1=d;\\n                    if(steps[it]<step[it]){\\n                        d1+=0;\\n                    }\\n                    else if(steps[it]==step[it]){\\n                        d1+=(-(amount[it]/2));\\n                    }\\n                    else{\\n                        d1+=-amount[it];\\n                    }\\n                    q.push({d1,it});\\n                }\\n            }\\n            if(cnt==0){\\n                ans=min(ans,d);\\n            }\\n        }\\n        return -ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>path;\\n    void dfs(int node,vector<int>adj[],vector<int>&vis,vector<int>&v){\\n        if(!path.empty())return;\\n        vis[node]=1;\\n        v.push_back(node);\\n        if(node==0){\\n            path=v;\\n            v.pop_back();\\n            return;\\n        }\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,adj,vis,v);\\n            }\\n        }\\n        v.pop_back();\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=edges.size()+1;\\n        vector<int>adj[n];\\n        for(int i=0;i<n-1;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>steps(n,INT_MAX);\\n        vector<int>v;\\n        vector<int>vis(n,0);\\n        dfs(bob,adj,vis,v);\\n        for(int i=0;i<path.size();i++){\\n            steps[path[i]]=i;\\n        }\\n        vector<int>step(n,INT_MAX);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        q.push({-amount[0],0});\\n        for(int i=0;i<n;i++)vis[i]=0;\\n        vis[0]=1;\\n        step[0]=0;\\n        int ans=INT_MAX;\\n        while(!q.empty()){\\n            int node=q.top().second;\\n            int d=q.top().first;\\n            q.pop();\\n            int cnt=0;\\n            for(auto it:adj[node]){\\n                if(!vis[it]){\\n                    cnt++;\\n                    step[it]=step[node]+1;\\n                    vis[it]=1;\\n                    int d1=d;\\n                    if(steps[it]<step[it]){\\n                        d1+=0;\\n                    }\\n                    else if(steps[it]==step[it]){\\n                        d1+=(-(amount[it]/2));\\n                    }\\n                    else{\\n                        d1+=-amount[it];\\n                    }\\n                    q.push({d1,it});\\n                }\\n            }\\n            if(cnt==0){\\n                ans=min(ans,d);\\n            }\\n        }\\n        return -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004051,
                "title": "most-profitable-path-in-a-tree-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(list)\\n        \\n        for edge in edges:\\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        \\n        def bob_dfs(curr_node, prev_node, count):\\n            if curr_node == 0:\\n                return count\\n            if prev_node != None and len(graph[curr_node]) == 1 and curr_node != 0:\\n                return -1\\n            \\n            for node in graph[curr_node]:\\n                if node == prev_node:\\n                    continue\\n                res = bob_dfs(node, curr_node, count + 1)\\n                if res != -1:\\n                    if count < (res + 1) // 2:\\n                        amount[curr_node] = 0\\n                    if res % 2 == 0 and res // 2 == count:\\n                        amount[curr_node] /= 2\\n                    return res\\n            return -1  \\n        \\n        bob_dfs(bob, None, 0)\\n        leafs_res = []\\n        \\n        def sum_dfs(curr_node, curr_sum, prev_node):\\n            if len(graph[curr_node]) == 1 and curr_node != 0:\\n                leafs_res.append(curr_sum + amount[curr_node])\\n            \\n            for node in graph[curr_node]:\\n                if node == prev_node:\\n                    continue\\n                sum_dfs(node, curr_sum + amount[curr_node], curr_node)\\n        \\n        sum_dfs(0, 0, None)\\n        \\n        res = max(leafs_res)\\n        if res % 1 == 0:\\n            return int(res)\\n        else:\\n            return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(list)\\n        \\n        for edge in edges:\\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        \\n        def bob_dfs(curr_node, prev_node, count):\\n            if curr_node == 0:\\n                return count\\n            if prev_node != None and len(graph[curr_node]) == 1 and curr_node != 0:\\n                return -1\\n            \\n            for node in graph[curr_node]:\\n                if node == prev_node:\\n                    continue\\n                res = bob_dfs(node, curr_node, count + 1)\\n                if res != -1:\\n                    if count < (res + 1) // 2:\\n                        amount[curr_node] = 0\\n                    if res % 2 == 0 and res // 2 == count:\\n                        amount[curr_node] /= 2\\n                    return res\\n            return -1  \\n        \\n        bob_dfs(bob, None, 0)\\n        leafs_res = []\\n        \\n        def sum_dfs(curr_node, curr_sum, prev_node):\\n            if len(graph[curr_node]) == 1 and curr_node != 0:\\n                leafs_res.append(curr_sum + amount[curr_node])\\n            \\n            for node in graph[curr_node]:\\n                if node == prev_node:\\n                    continue\\n                sum_dfs(node, curr_sum + amount[curr_node], curr_node)\\n        \\n        sum_dfs(0, 0, None)\\n        \\n        res = max(leafs_res)\\n        if res % 1 == 0:\\n            return int(res)\\n        else:\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003633,
                "title": "approach-explained-c-logical-answer",
                "content": "# Intuition\\nwe are here not intrested in points by bob but we are just intrested in number of steps in which we reach to a \\nnode . we also know its tree to no self loop will be ther e and for bob to reach the zero/root there exactly one path.\\n\\n# Approach\\nLet the bob first reach the root and store number of steps required to by bob along correct path to reach the zero and if a reaches the node before bob then we will give him point as per condition mentioned.\\n\\n# Complexity\\n- Time complexity:\\n- $$O(v+E)$$ ===>O(v+v-1)====>O(N)\\n\\n- Space complexity:\\n- $$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) \\n    {\\n       vector<int>stepsByBobToReach(amount.size(),1e9);\\n       vector<int>adj[amount.size()];\\n       for(auto &it:edges)\\n       {\\n           adj[it[0]].push_back(it[1]);\\n           adj[it[1]].push_back(it[0]);\\n       }\\n       walkOfBob(adj,stepsByBobToReach,bob,0,bob);\\n       return MaximumpointByAlice(amount,stepsByBobToReach,adj,0,0,0);\\n            \\n    }\\n    bool walkOfBob(vector<int>adj[],vector<int>&reached,int bob,int steps,int parent)\\n    {\\n        if (bob==0)\\n        {\\n            reached[bob]=steps;\\n            return 1;\\n        }\\n        reached[bob]=steps;\\n        for(auto &it:adj[bob])\\n        {\\n            if (it!=parent)\\n            {\\n                if (walkOfBob(adj,reached,it,steps+1,bob))\\n                {\\n                    return 1;\\n                }\\n            }\\n        }\\n        reached[bob]=1e9;\\n        return 0;\\n    }\\n    int MaximumpointByAlice(vector<int>& amount,vector<int>&stepsB,vector<int>adj[],int node,int step,int parent)\\n    {\\n        int ans=0;\\n        if (step<stepsB[node])\\n        {\\n            ans+=amount[node];\\n        }\\n        if (step==stepsB[node])\\n        {\\n            ans+=amount[node]/2;\\n        }\\n        int temp=-1e9;\\n        for(auto &it:adj[node])\\n        {\\n            if (it==parent)\\n            {\\n                continue;\\n            }\\n            temp=max(temp,MaximumpointByAlice(amount,stepsB,adj,it,step+1,node));\\n        }\\n        return temp==-1e9? ans : ans+temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) \\n    {\\n       vector<int>stepsByBobToReach(amount.size(),1e9);\\n       vector<int>adj[amount.size()];\\n       for(auto &it:edges)\\n       {\\n           adj[it[0]].push_back(it[1]);\\n           adj[it[1]].push_back(it[0]);\\n       }\\n       walkOfBob(adj,stepsByBobToReach,bob,0,bob);\\n       return MaximumpointByAlice(amount,stepsByBobToReach,adj,0,0,0);\\n            \\n    }\\n    bool walkOfBob(vector<int>adj[],vector<int>&reached,int bob,int steps,int parent)\\n    {\\n        if (bob==0)\\n        {\\n            reached[bob]=steps;\\n            return 1;\\n        }\\n        reached[bob]=steps;\\n        for(auto &it:adj[bob])\\n        {\\n            if (it!=parent)\\n            {\\n                if (walkOfBob(adj,reached,it,steps+1,bob))\\n                {\\n                    return 1;\\n                }\\n            }\\n        }\\n        reached[bob]=1e9;\\n        return 0;\\n    }\\n    int MaximumpointByAlice(vector<int>& amount,vector<int>&stepsB,vector<int>adj[],int node,int step,int parent)\\n    {\\n        int ans=0;\\n        if (step<stepsB[node])\\n        {\\n            ans+=amount[node];\\n        }\\n        if (step==stepsB[node])\\n        {\\n            ans+=amount[node]/2;\\n        }\\n        int temp=-1e9;\\n        for(auto &it:adj[node])\\n        {\\n            if (it==parent)\\n            {\\n                continue;\\n            }\\n            temp=max(temp,MaximumpointByAlice(amount,stepsB,adj,it,step+1,node));\\n        }\\n        return temp==-1e9? ans : ans+temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000521,
                "title": "possibility-the-most-clean-code-for-single-pass-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that Bob\\'s path is fixed as it moves towards 0th node and alice choses most optimal path to a leaf node\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMove Bob first from node B to node 0 , updating amount to 0(if Bob travels before Alice , as the gate is OPEN for Alice) or amount/2 (if both reach simultaneously)\\n\\nReturn ans as cost to open the gate + ans (if not traveled before)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N+E)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ for dis to bob vector and O(N+E) for Adjacency List\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int dfs(int node, int parentEdge, int dept, vector<int> &disToBob, vector<int>adj[], vector<int>& amount){\\n        int ans=INT_MIN; \\n        for(auto &edge:adj[node]){\\n            if(edge!=parentEdge){\\n                ans=max(ans, dfs(edge, node, dept+1, disToBob, adj, amount));\\n                disToBob[node]=min(disToBob[node], disToBob[edge]+1);\\n            }\\n        }\\n        int cosTOpen=0;\\n        if(disToBob[node]>dept)cosTOpen=amount[node]; //If Bob reaches a Node Prior to Alice\\n        else if(disToBob[node]==dept)cosTOpen=amount[node]/2; //If Both Bob & Alice reaches a Node Simultaneously\\n        return (ans==INT_MIN)?cosTOpen:ans+cosTOpen;\\n    }\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        //No. Of nodes in Graph\\n        int n=amount.size();\\n        //Build Graph Adjacency list\\n        vector<int>adj[n];\\n        for(auto &it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>disToBob(n, n); //To measure of Bob from Alice to a node\\n        disToBob[bob]=0;\\n        return dfs(0, 0, 0, disToBob,adj, amount);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(int node, int parentEdge, int dept, vector<int> &disToBob, vector<int>adj[], vector<int>& amount){\\n        int ans=INT_MIN; \\n        for(auto &edge:adj[node]){\\n            if(edge!=parentEdge){\\n                ans=max(ans, dfs(edge, node, dept+1, disToBob, adj, amount));\\n                disToBob[node]=min(disToBob[node], disToBob[edge]+1);\\n            }\\n        }\\n        int cosTOpen=0;\\n        if(disToBob[node]>dept)cosTOpen=amount[node]; //If Bob reaches a Node Prior to Alice\\n        else if(disToBob[node]==dept)cosTOpen=amount[node]/2; //If Both Bob & Alice reaches a Node Simultaneously\\n        return (ans==INT_MIN)?cosTOpen:ans+cosTOpen;\\n    }\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        //No. Of nodes in Graph\\n        int n=amount.size();\\n        //Build Graph Adjacency list\\n        vector<int>adj[n];\\n        for(auto &it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>disToBob(n, n); //To measure of Bob from Alice to a node\\n        disToBob[bob]=0;\\n        return dfs(0, 0, 0, disToBob,adj, amount);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999876,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = len(amount) \\n\\n        # creating adjacency list\\n        graph = {i:[] for i in range(n)}\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        parent = [-1 for i in range(n)]\\n        dist = [0 for i in range(n)]\\n\\n        def findDistancefromStart(cur, curParent):\\n            for it in graph[cur]:\\n                if it != curParent:\\n                    dist[it] = dist[cur] + 1\\n                    findDistancefromStart(it, cur)\\n                    parent[it] = cur\\n\\n        def modifyAmount(curBob, curDist):\\n            while curBob != 0:\\n                if curDist < dist[curBob]: # current distance is less than the actual distance of bob from the start\\n                    amount[curBob] = 0\\n                elif curDist == dist[curBob]: \\n                    amount[curBob] = amount[curBob] // 2\\n                curBob = parent[curBob]\\n                curDist += 1\\n\\n        visited = set()\\n        cost = 0\\n        income = float(\\'-inf\\')\\n        def findMaxProfitPath(cur):\\n            nonlocal cost\\n            nonlocal income\\n            visited.add(cur)\\n            cost += amount[cur]\\n            trav = 0 # to check if this is leaf node\\n            for it in graph[cur]:\\n                if it in visited:\\n                    continue\\n                trav += 1 # this shows that this is not a leaf node\\n                findMaxProfitPath(it)\\n\\n            if trav == 0:\\n                income = max(cost, income)\\n            cost -= amount[cur]\\n\\n        findDistancefromStart(0, -1)\\n        modifyAmount(bob, 0)\\n        findMaxProfitPath(0)\\n\\n        return income\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = len(amount) \\n\\n        # creating adjacency list\\n        graph = {i:[] for i in range(n)}\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        parent = [-1 for i in range(n)]\\n        dist = [0 for i in range(n)]\\n\\n        def findDistancefromStart(cur, curParent):\\n            for it in graph[cur]:\\n                if it != curParent:\\n                    dist[it] = dist[cur] + 1\\n                    findDistancefromStart(it, cur)\\n                    parent[it] = cur\\n\\n        def modifyAmount(curBob, curDist):\\n            while curBob != 0:\\n                if curDist < dist[curBob]: # current distance is less than the actual distance of bob from the start\\n                    amount[curBob] = 0\\n                elif curDist == dist[curBob]: \\n                    amount[curBob] = amount[curBob] // 2\\n                curBob = parent[curBob]\\n                curDist += 1\\n\\n        visited = set()\\n        cost = 0\\n        income = float(\\'-inf\\')\\n        def findMaxProfitPath(cur):\\n            nonlocal cost\\n            nonlocal income\\n            visited.add(cur)\\n            cost += amount[cur]\\n            trav = 0 # to check if this is leaf node\\n            for it in graph[cur]:\\n                if it in visited:\\n                    continue\\n                trav += 1 # this shows that this is not a leaf node\\n                findMaxProfitPath(it)\\n\\n            if trav == 0:\\n                income = max(cost, income)\\n            cost -= amount[cur]\\n\\n        findDistancefromStart(0, -1)\\n        modifyAmount(bob, 0)\\n        findMaxProfitPath(0)\\n\\n        return income\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996956,
                "title": "explanation-for-each-line-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have created two functions, one calculates time for bob to reach each node int it\\'s path towards 0 node\\nAnother calculates net income of alice\\nUpvote if this helps.\\nFull explanation is there in code, for each line.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nDON\\'T GET SCARED because of the length of the code, it\\'s long becuase of the comments.\\n```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n= edges.length+1;\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n\\n// 1st  step : graph building\\n        for(int i=0; i<n; i++)\\n            graph[i] = new ArrayList<Integer>();\\n\\n        for(int[] e : edges)\\n        {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n\\n// creating a map which will store time taken by bob to reach each node\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\n//to keep track of visited nodes\\n        boolean[] visited = new boolean[n];\\n\\n// calculating time taken by bob to reach each node and storing it in map\\n        dfsdist(bob, 0, 0, visited, graph, map);\\n        // now we are done with bob\\n\\n// ALICE\"S TURN\\n        // taking array because integer is a call by value\\n        int netincome[] = new int[1];\\n        netincome[0] = Integer.MIN_VALUE;\\n        // there may bemultiple number of leafnodes, so we will calculate total income of each leaf node and store each of them in income, and the maximumof them all will be stored in netincome\\n        int income=0;\\n        // reusing visited array\\n        visited=new boolean[n];\\n        /// to calculate correct value of netincome\\n        maxSum(0,0, graph, visited, map, netincome, income, amount);\\n\\n        return netincome[0];\\n    }\\n\\n    public void maxSum(int src, int time, ArrayList<Integer>[] graph, boolean[] visited,  HashMap<Integer, Integer> map, int netincome[], int income, int[] amount){\\n\\n// set visited[src] = true for node being visited\\n        visited[src] = true;\\n\\n// adding amount in income\\n        // if bob haven\\'t visited the node or if bob take more time to reach the node than Alice then Alice will have to do full payment\\'\\n        if(map.get(src) == null || time < map.get(src))\\n            income+=amount[src];\\n        // if both alice and bob reach the node at the same time then alice will have to pay half only\\n        else if(time == map.get(src))\\n            income+= amount[src]/2;\\n        \\n        // leaf node condition\\n        // a node is a leaf node only when it has only one node connected to it and it\\'s not the source itself\\n        if(src!=0 && graph[src].size()==1){\\n            // updating netIncome value for each node\\n            netincome[0] = Math.max(netincome[0], income);\\n        }\\n\\n    // visiting all the non-visited nodes in the path to perform above oprations\\n        for(int v : graph[src])\\n        {\\n            if(!visited[v])\\n                maxSum(v, time+1, graph, visited, map, netincome, income, amount);\\n        }\\n    } \\n\\n    // Basically, src or desst jab same hoga to it\\'ll return true\\n    // or ye src se given dest pahunchne ka time store kare ja raha hai map mein jo ki we are using above\\n\\n    public boolean dfsdist(int src, int time, int dest, boolean[] visited, ArrayList<Integer>[] graph,  HashMap<Integer, Integer> map){\\n        \\n        // set visited true for the node\\n        visited[src] = true;\\n        // put time in the map for reaching src for bob from its initial position\\n        map.put(src, time);\\n        // if src==dest then it means we have reached destination so return true\\n        if(src == dest) return true;\\n\\n        // repeat the process for all non-visited nodes in the path\\n        for(Integer adj :graph[src] )\\n        {\\n            if(!visited[adj])\\n               if(dfsdist(adj, time+1, dest,visited, graph, map))\\n                return true;\\n        }\\n\\n        // remove from map and return false if we do not reach dest \\n        map.remove(src);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n= edges.length+1;\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n\\n// 1st  step : graph building\\n        for(int i=0; i<n; i++)\\n            graph[i] = new ArrayList<Integer>();\\n\\n        for(int[] e : edges)\\n        {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n\\n// creating a map which will store time taken by bob to reach each node\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\n//to keep track of visited nodes\\n        boolean[] visited = new boolean[n];\\n\\n// calculating time taken by bob to reach each node and storing it in map\\n        dfsdist(bob, 0, 0, visited, graph, map);\\n        // now we are done with bob\\n\\n// ALICE\"S TURN\\n        // taking array because integer is a call by value\\n        int netincome[] = new int[1];\\n        netincome[0] = Integer.MIN_VALUE;\\n        // there may bemultiple number of leafnodes, so we will calculate total income of each leaf node and store each of them in income, and the maximumof them all will be stored in netincome\\n        int income=0;\\n        // reusing visited array\\n        visited=new boolean[n];\\n        /// to calculate correct value of netincome\\n        maxSum(0,0, graph, visited, map, netincome, income, amount);\\n\\n        return netincome[0];\\n    }\\n\\n    public void maxSum(int src, int time, ArrayList<Integer>[] graph, boolean[] visited,  HashMap<Integer, Integer> map, int netincome[], int income, int[] amount){\\n\\n// set visited[src] = true for node being visited\\n        visited[src] = true;\\n\\n// adding amount in income\\n        // if bob haven\\'t visited the node or if bob take more time to reach the node than Alice then Alice will have to do full payment\\'\\n        if(map.get(src) == null || time < map.get(src))\\n            income+=amount[src];\\n        // if both alice and bob reach the node at the same time then alice will have to pay half only\\n        else if(time == map.get(src))\\n            income+= amount[src]/2;\\n        \\n        // leaf node condition\\n        // a node is a leaf node only when it has only one node connected to it and it\\'s not the source itself\\n        if(src!=0 && graph[src].size()==1){\\n            // updating netIncome value for each node\\n            netincome[0] = Math.max(netincome[0], income);\\n        }\\n\\n    // visiting all the non-visited nodes in the path to perform above oprations\\n        for(int v : graph[src])\\n        {\\n            if(!visited[v])\\n                maxSum(v, time+1, graph, visited, map, netincome, income, amount);\\n        }\\n    } \\n\\n    // Basically, src or desst jab same hoga to it\\'ll return true\\n    // or ye src se given dest pahunchne ka time store kare ja raha hai map mein jo ki we are using above\\n\\n    public boolean dfsdist(int src, int time, int dest, boolean[] visited, ArrayList<Integer>[] graph,  HashMap<Integer, Integer> map){\\n        \\n        // set visited true for the node\\n        visited[src] = true;\\n        // put time in the map for reaching src for bob from its initial position\\n        map.put(src, time);\\n        // if src==dest then it means we have reached destination so return true\\n        if(src == dest) return true;\\n\\n        // repeat the process for all non-visited nodes in the path\\n        for(Integer adj :graph[src] )\\n        {\\n            if(!visited[adj])\\n               if(dfsdist(adj, time+1, dest,visited, graph, map))\\n                return true;\\n        }\\n\\n        // remove from map and return false if we do not reach dest \\n        map.remove(src);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992827,
                "title": "very-easy-intuitive-commented-well-explained-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        vector<int> adj[n];\\n        //making adjacency matrix\\n        for(auto &e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> par(n), dist(n);\\n        queue<int> q;\\n        q.push(0);\\n        par[0] = -1;\\n        dist[0] = 0;\\n        //making parent array and computing distance of every node from 0 \\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int node = q.front();q.pop();\\n                for(int child:adj[node]){\\n                    if(child == par[node]) continue;\\n                    q.push(child);\\n                    par[child] = node;\\n                    dist[child] = dist[node] + 1;\\n                }\\n            }\\n        }\\n        //bob\\'s run toward node 0\\n        int ptr = bob;\\n        int d = 0;\\n        while(ptr){\\n            if(dist[ptr] > d) amount[ptr] = 0;\\n            else if(dist[ptr] == d) amount[ptr] /= 2;\\n            ptr = par[ptr];\\n            ++d;\\n        } \\n        //now calculating maximum cost obtained by reaching any leaf node\\n        q.push(0);\\n        int res = -1e8;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int node = q.front();q.pop();\\n                bool f=false;\\n                for(int nbr:adj[node]){\\n                    if(nbr == par[node]) continue;\\n                    f=true;\\n                    amount[nbr] += amount[node];\\n                    q.push(nbr);\\n                }\\n                if(f==false) res=max(res,amount[node]);\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        vector<int> adj[n];\\n        //making adjacency matrix\\n        for(auto &e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> par(n), dist(n);\\n        queue<int> q;\\n        q.push(0);\\n        par[0] = -1;\\n        dist[0] = 0;\\n        //making parent array and computing distance of every node from 0 \\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int node = q.front();q.pop();\\n                for(int child:adj[node]){\\n                    if(child == par[node]) continue;\\n                    q.push(child);\\n                    par[child] = node;\\n                    dist[child] = dist[node] + 1;\\n                }\\n            }\\n        }\\n        //bob\\'s run toward node 0\\n        int ptr = bob;\\n        int d = 0;\\n        while(ptr){\\n            if(dist[ptr] > d) amount[ptr] = 0;\\n            else if(dist[ptr] == d) amount[ptr] /= 2;\\n            ptr = par[ptr];\\n            ++d;\\n        } \\n        //now calculating maximum cost obtained by reaching any leaf node\\n        q.push(0);\\n        int res = -1e8;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int node = q.front();q.pop();\\n                bool f=false;\\n                for(int nbr:adj[node]){\\n                    if(nbr == par[node]) continue;\\n                    f=true;\\n                    amount[nbr] += amount[node];\\n                    q.push(nbr);\\n                }\\n                if(f==false) res=max(res,amount[node]);\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986609,
                "title": "simple-c-solution-bfs-o-n-time-o-n-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) find the route of bob\\n2) bfs on alice route\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    vector<int>v;\\n    bool dfs(vector<int>adj[],int ind,vector<int>&vis){\\n        \\n        vis[ind] = 1;\\n        v.push_back(ind);\\n        \\n        if(ind == 0){\\n            return true;\\n        }\\n        \\n        for(auto it : adj[ind]){\\n            if(vis[it] == 0 and dfs(adj,it,vis)){\\n                return true;\\n            }\\n        }\\n        \\n        v.pop_back();\\n        return false;\\n    }\\n   \\n    \\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n\\n        // graph\\n        vector<int>adj[n+1];\\n        for(auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        // find bob route\\n        vector<int>vis(n+1,0);\\n        dfs(adj,bob,vis);\\n\\n        // for alice route\\n        vector<int>vis1(n+1,0);\\n\\n        // bob route\\n        vector<int>vis2(n+1,0);\\n\\n        int alice = 0;\\n        int ans = INT_MIN;\\n        int amt = 0;\\n        int len = 0;\\n\\n        queue<vector<int>>q;\\n        q.push({0,0,0,0});\\n\\n        // bob route\\n        for(auto it : v){\\n            vis2[it] = true;\\n        }        \\n\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            amt = temp[0];\\n            alice = temp[1];\\n            bob = temp[2];\\n            len = temp[3];\\n            vis1[alice] = true;\\n\\n            // check alice and bob on same route or not\\n            if(bob<v.size()){\\n                // both visited simultaneously\\n                if(alice == v[bob]){\\n                    amt += amount[alice]/2;\\n                }\\n                // bob already visited it\\n                else if(vis2[alice] and len >= (v.size())/2){\\n                    // ***** do nothing :) \\n                }\\n                // alice visited first\\n                else{\\n                    amt += amount[alice];\\n                }\\n            }\\n            else{\\n                amt += amount[alice];\\n            }\\n\\n            // to check curr node is a leaf node or not\\n            bool flag = true;\\n            for(auto it : adj[alice]){\\n                // already visited\\n                if(vis1[it]) continue;\\n\\n                q.push({amt,it,bob+1,len+1});\\n                flag = false;\\n            }\\n\\n            // leaf node\\n            if(flag){\\n                ans = max(ans,amt);\\n            }\\n\\n        }\\n        return ans;        \\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    vector<int>v;\\n    bool dfs(vector<int>adj[],int ind,vector<int>&vis){\\n        \\n        vis[ind] = 1;\\n        v.push_back(ind);\\n        \\n        if(ind == 0){\\n            return true;\\n        }\\n        \\n        for(auto it : adj[ind]){\\n            if(vis[it] == 0 and dfs(adj,it,vis)){\\n                return true;\\n            }\\n        }\\n        \\n        v.pop_back();\\n        return false;\\n    }\\n   \\n    \\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n\\n        // graph\\n        vector<int>adj[n+1];\\n        for(auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        // find bob route\\n        vector<int>vis(n+1,0);\\n        dfs(adj,bob,vis);\\n\\n        // for alice route\\n        vector<int>vis1(n+1,0);\\n\\n        // bob route\\n        vector<int>vis2(n+1,0);\\n\\n        int alice = 0;\\n        int ans = INT_MIN;\\n        int amt = 0;\\n        int len = 0;\\n\\n        queue<vector<int>>q;\\n        q.push({0,0,0,0});\\n\\n        // bob route\\n        for(auto it : v){\\n            vis2[it] = true;\\n        }        \\n\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            amt = temp[0];\\n            alice = temp[1];\\n            bob = temp[2];\\n            len = temp[3];\\n            vis1[alice] = true;\\n\\n            // check alice and bob on same route or not\\n            if(bob<v.size()){\\n                // both visited simultaneously\\n                if(alice == v[bob]){\\n                    amt += amount[alice]/2;\\n                }\\n                // bob already visited it\\n                else if(vis2[alice] and len >= (v.size())/2){\\n                    // ***** do nothing :) \\n                }\\n                // alice visited first\\n                else{\\n                    amt += amount[alice];\\n                }\\n            }\\n            else{\\n                amt += amount[alice];\\n            }\\n\\n            // to check curr node is a leaf node or not\\n            bool flag = true;\\n            for(auto it : adj[alice]){\\n                // already visited\\n                if(vis1[it]) continue;\\n\\n                q.push({amt,it,bob+1,len+1});\\n                flag = false;\\n            }\\n\\n            // leaf node\\n            if(flag){\\n                ans = max(ans,amt);\\n            }\\n\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986401,
                "title": "java-easy-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    static class Edge{\\n        int vtc;\\n        int nbr;\\n        int amt;\\n        Edge(int vtc,int nbr,int amt){\\n            this.vtc=vtc;\\n            this.nbr=nbr;\\n            this.amt=amt;\\n        }\\n    }\\n    static class Pair{\\n        int nd;\\n        int time;\\n        int income;\\n        Pair(int nd,int time,int income){\\n            this.nd=nd;\\n            this.time=time;\\n            this.income=income;\\n        }\\n    }\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        //Let\\'s make  a Graph First\\n\\n        //The graph stores the node its neighbour and the weight\\n        ArrayList<Edge>[] graph=new ArrayList[amount.length];\\n        for(int i=0;i<amount.length;i++){\\n            graph[i]=new ArrayList<>();\\n        }\\n\\n        for(int i=0;i<edges.length;i++){\\n            graph[edges[i][0]].add(new Edge(edges[i][0],edges[i][1],amount[i]));\\n            graph[edges[i][1]].add(new Edge(edges[i][1],edges[i][0],amount[i]));\\n        }\\n\\n        //Now we want to move Bob to the top so we move that via dfs \\n        boolean[] visited=new boolean[amount.length];\\n        //What we do here is that we store the path in a hashmap representing node and the time it reaches the node\\n        //For first node the node is bob and time is 0\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n\\n        dfs(graph,bob,0,visited,map,0);\\n\\n        System.out.println(map);\\n\\n        //Lets store the max value right now as Integer.MIN_VALUE\\n        int ans=Integer.MIN_VALUE;\\n\\n\\n        //Now we use BFS for traversing the Alice\\n\\n        //We create a Pair Class for storing the node,time and the income\\n        //We create the root Pair and a queue\\n        visited=new boolean[amount.length];\\n        ArrayDeque<Pair> q=new ArrayDeque<>();\\n        q.add(new Pair(0,0,0));\\n\\n        while(q.size()>0){\\n            Pair rm=q.remove();\\n            int node=rm.nd;\\n            visited[node]=true;\\n            int time=rm.time;\\n            int income=rm.income;\\n            //the node is not traversed by Bob\\n            if(map.get(node)==null){\\n                income+=amount[node];\\n            }\\n            else{\\n                //the node is traversed by Alice before\\n                if(time<map.get(node)){\\n                    income+=amount[node];\\n                }\\n                //the node is traversed at the same time\\n                else if(time==map.get(node)){\\n                    income+=amount[node]/2;\\n                }\\n                else{\\n                    //the node is traversed later\\n                    income+=0;\\n                }\\n            }\\n            //if leaf node,find the answer\\n            if(node!=0 && graph[node].size()==1){\\n                ans=Math.max(ans,income);\\n            }\\n            //add all the edges to queue\\n            for(Edge e:graph[node]){\\n                if(visited[e.nbr]==false){\\n                    q.add(new Pair(e.nbr,time+1,income));\\n                }\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n    public static boolean dfs(ArrayList<Edge>[] graph,int src,int dest,boolean[] visited,HashMap<Integer,Integer> map,int time){\\n        map.put(src,time);\\n        if(src==dest){\\n            return true;\\n        }\\n        visited[src]=true;\\n\\n        for(Edge e:graph[src]){\\n            if(visited[e.nbr]==false){\\n                boolean f=dfs(graph,e.nbr,dest,visited,map,time+1);\\n                if(f==true){\\n                    return true;\\n                }\\n            }\\n        }\\n        map.remove(src);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    static class Edge{\\n        int vtc;\\n        int nbr;\\n        int amt;\\n        Edge(int vtc,int nbr,int amt){\\n            this.vtc=vtc;\\n            this.nbr=nbr;\\n            this.amt=amt;\\n        }\\n    }\\n    static class Pair{\\n        int nd;\\n        int time;\\n        int income;\\n        Pair(int nd,int time,int income){\\n            this.nd=nd;\\n            this.time=time;\\n            this.income=income;\\n        }\\n    }\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        //Let\\'s make  a Graph First\\n\\n        //The graph stores the node its neighbour and the weight\\n        ArrayList<Edge>[] graph=new ArrayList[amount.length];\\n        for(int i=0;i<amount.length;i++){\\n            graph[i]=new ArrayList<>();\\n        }\\n\\n        for(int i=0;i<edges.length;i++){\\n            graph[edges[i][0]].add(new Edge(edges[i][0],edges[i][1],amount[i]));\\n            graph[edges[i][1]].add(new Edge(edges[i][1],edges[i][0],amount[i]));\\n        }\\n\\n        //Now we want to move Bob to the top so we move that via dfs \\n        boolean[] visited=new boolean[amount.length];\\n        //What we do here is that we store the path in a hashmap representing node and the time it reaches the node\\n        //For first node the node is bob and time is 0\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n\\n        dfs(graph,bob,0,visited,map,0);\\n\\n        System.out.println(map);\\n\\n        //Lets store the max value right now as Integer.MIN_VALUE\\n        int ans=Integer.MIN_VALUE;\\n\\n\\n        //Now we use BFS for traversing the Alice\\n\\n        //We create a Pair Class for storing the node,time and the income\\n        //We create the root Pair and a queue\\n        visited=new boolean[amount.length];\\n        ArrayDeque<Pair> q=new ArrayDeque<>();\\n        q.add(new Pair(0,0,0));\\n\\n        while(q.size()>0){\\n            Pair rm=q.remove();\\n            int node=rm.nd;\\n            visited[node]=true;\\n            int time=rm.time;\\n            int income=rm.income;\\n            //the node is not traversed by Bob\\n            if(map.get(node)==null){\\n                income+=amount[node];\\n            }\\n            else{\\n                //the node is traversed by Alice before\\n                if(time<map.get(node)){\\n                    income+=amount[node];\\n                }\\n                //the node is traversed at the same time\\n                else if(time==map.get(node)){\\n                    income+=amount[node]/2;\\n                }\\n                else{\\n                    //the node is traversed later\\n                    income+=0;\\n                }\\n            }\\n            //if leaf node,find the answer\\n            if(node!=0 && graph[node].size()==1){\\n                ans=Math.max(ans,income);\\n            }\\n            //add all the edges to queue\\n            for(Edge e:graph[node]){\\n                if(visited[e.nbr]==false){\\n                    q.add(new Pair(e.nbr,time+1,income));\\n                }\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n    public static boolean dfs(ArrayList<Edge>[] graph,int src,int dest,boolean[] visited,HashMap<Integer,Integer> map,int time){\\n        map.put(src,time);\\n        if(src==dest){\\n            return true;\\n        }\\n        visited[src]=true;\\n\\n        for(Edge e:graph[src]){\\n            if(visited[e.nbr]==false){\\n                boolean f=dfs(graph,e.nbr,dest,visited,map,time+1);\\n                if(f==true){\\n                    return true;\\n                }\\n            }\\n        }\\n        map.remove(src);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980324,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dfs1(self,edges,bob):\\n        dict1 = collections.defaultdict(set)\\n\\n        for i,j in edges:\\n            dict1[i].add(j)\\n            dict1[j].add(i)\\n\\n        parent_graph = collections.defaultdict(int)\\n\\n        stack = [0]\\n\\n        while stack:\\n            next_level = []\\n\\n            for x in stack:\\n                for neighbor in dict1[x]:\\n                    if neighbor != parent_graph[x]:\\n                        parent_graph[neighbor] = x\\n                        next_level.append(neighbor)\\n\\n            stack = next_level\\n\\n        path = [bob]\\n\\n        while path[-1] != 0:\\n            path.append(parent_graph[path[-1]])\\n\\n        bob_path = {x:i for i,x in enumerate(path)}\\n\\n        return bob_path\\n\\n    def mostProfitablePath(self, edges, bob, amount):\\n        dict3 = collections.defaultdict(set)\\n\\n        for i,j in edges:\\n            dict3[i].add(j)\\n            dict3[j].add(i)\\n\\n        dict2 = self.dfs1(edges,bob)\\n\\n        @lru_cache(None)\\n        def dfs(i,parent,current):\\n            bob_time = dict2.get(current,float(\"inf\"))\\n\\n            cur_amount = amount[current]\\n\\n            if i == bob_time:\\n                cur_amount = cur_amount//2\\n            elif i > bob_time:\\n                cur_amount = 0\\n\\n            result = [i for i in dict3[current] if i != parent]\\n\\n            if not result:\\n                return cur_amount\\n\\n            max_val = float(\"-inf\")\\n\\n            for j in result:\\n                max_val = max(max_val,cur_amount+dfs(i+1,current,j))\\n\\n            return max_val\\n\\n        return dfs(0,None,0)\\n\\n        \\n\\n\\n\\n\\n\\n\\n            \\n\\n\\n            \\n\\n            \\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dfs1(self,edges,bob):\\n        dict1 = collections.defaultdict(set)\\n\\n        for i,j in edges:\\n            dict1[i].add(j)\\n            dict1[j].add(i)\\n\\n        parent_graph = collections.defaultdict(int)\\n\\n        stack = [0]\\n\\n        while stack:\\n            next_level = []\\n\\n            for x in stack:\\n                for neighbor in dict1[x]:\\n                    if neighbor != parent_graph[x]:\\n                        parent_graph[neighbor] = x\\n                        next_level.append(neighbor)\\n\\n            stack = next_level\\n\\n        path = [bob]\\n\\n        while path[-1] != 0:\\n            path.append(parent_graph[path[-1]])\\n\\n        bob_path = {x:i for i,x in enumerate(path)}\\n\\n        return bob_path\\n\\n    def mostProfitablePath(self, edges, bob, amount):\\n        dict3 = collections.defaultdict(set)\\n\\n        for i,j in edges:\\n            dict3[i].add(j)\\n            dict3[j].add(i)\\n\\n        dict2 = self.dfs1(edges,bob)\\n\\n        @lru_cache(None)\\n        def dfs(i,parent,current):\\n            bob_time = dict2.get(current,float(\"inf\"))\\n\\n            cur_amount = amount[current]\\n\\n            if i == bob_time:\\n                cur_amount = cur_amount//2\\n            elif i > bob_time:\\n                cur_amount = 0\\n\\n            result = [i for i in dict3[current] if i != parent]\\n\\n            if not result:\\n                return cur_amount\\n\\n            max_val = float(\"-inf\")\\n\\n            for j in result:\\n                max_val = max(max_val,cur_amount+dfs(i+1,current,j))\\n\\n            return max_val\\n\\n        return dfs(0,None,0)\\n\\n        \\n\\n\\n\\n\\n\\n\\n            \\n\\n\\n            \\n\\n            \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978448,
                "title": "easy-dfs-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->In In a tree we have only one path from one node to another node we can calculate the time require by bob to reach to parent and time require by alice to reach the corresponding node then we can simply add the cost or cost/2 or 0 to the current ans according to the condition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS algorithm is used to calculate the maximum cost. We calculated the time at which bob reach from his current node to every node to the root\\nthe function maxCostAlice determines the maximum cost alice can gain it takes argument graph which is the tree, current node, parent and the time currently she is\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(v + e)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(v + e)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCostAlice(vector<vector<int>>&graph, int curr, int par, int aliceTime, vector<int>&ammount, vector<int>&time)\\n    {\\n        int currentCost;\\n        if(aliceTime > time[curr]) currentCost = 0;\\n        else if(aliceTime == time[curr]) currentCost = ammount[curr] / 2;\\n        else currentCost = ammount[curr];\\n\\n        int addedCost = INT_MIN;\\n        for(int child : graph[curr])\\n        {\\n            if(child == par) continue;\\n            addedCost = max(addedCost, maxCostAlice(graph, child, curr, aliceTime + 1, ammount, time));\\n        }\\n        if(addedCost == INT_MIN) addedCost = 0;\\n\\n        return addedCost + currentCost;\\n    }\\n    void find_par(vector<vector<int>>&graph, int curr, int parent, vector<int>&par)\\n    {\\n        par[curr] = parent;\\n        for(int child: graph[curr]) if(child != parent) find_par(graph, child, curr, par);\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size() + 1;\\n        vector<int>time(n, n + 1);\\n        vector<int>par(n, -1);\\n        vector<vector<int>>graph(n);\\n        for(auto edge: edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        find_par(graph, 0, -1, par);\\n        int bob_time = 0;\\n        while(bob != 0)\\n        {\\n            time[bob] = bob_time;\\n            bob_time ++;\\n            bob = par[bob];\\n        }\\n\\n        int ans = maxCostAlice(graph, 0, -1, 0, amount, time);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCostAlice(vector<vector<int>>&graph, int curr, int par, int aliceTime, vector<int>&ammount, vector<int>&time)\\n    {\\n        int currentCost;\\n        if(aliceTime > time[curr]) currentCost = 0;\\n        else if(aliceTime == time[curr]) currentCost = ammount[curr] / 2;\\n        else currentCost = ammount[curr];\\n\\n        int addedCost = INT_MIN;\\n        for(int child : graph[curr])\\n        {\\n            if(child == par) continue;\\n            addedCost = max(addedCost, maxCostAlice(graph, child, curr, aliceTime + 1, ammount, time));\\n        }\\n        if(addedCost == INT_MIN) addedCost = 0;\\n\\n        return addedCost + currentCost;\\n    }\\n    void find_par(vector<vector<int>>&graph, int curr, int parent, vector<int>&par)\\n    {\\n        par[curr] = parent;\\n        for(int child: graph[curr]) if(child != parent) find_par(graph, child, curr, par);\\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size() + 1;\\n        vector<int>time(n, n + 1);\\n        vector<int>par(n, -1);\\n        vector<vector<int>>graph(n);\\n        for(auto edge: edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        find_par(graph, 0, -1, par);\\n        int bob_time = 0;\\n        while(bob != 0)\\n        {\\n            time[bob] = bob_time;\\n            bob_time ++;\\n            bob = par[bob];\\n        }\\n\\n        int ans = maxCostAlice(graph, 0, -1, 0, amount, time);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971708,
                "title": "bsf-dfs",
                "content": "# Intuition\\n since it is a tree so any 2 nodes will only have a single path between them\\n# Approach\\nrecord the path from bob to 0 node and record the distance of each node in this path from bob intial position (dfs function do this)\\n\\n then do bfs from node 0(alice) positon to every leaf node if a node distance from bob intial postion < the distance from 0 --> value of this node =0;\\n\\nif at equal distance the. value of this node if half\\nelse no change to the value\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>gr[],int b,vector<int>&vis,vector<int>&dis,int t)\\n    {\\n       dis[b]=t;\\n       vis[b]=1;\\n\\n       if(b==0)\\n         return true;\\n\\n       bool ans=false;\\n       for(int j=0;j<gr[b].size();j++)\\n       {\\n           int v=gr[b][j];\\n\\n           if(!vis[v])\\n           {\\n              ans|= dfs(gr,v,vis,dis,t+1);\\n           }\\n       }\\n\\n       if(!ans)\\n        dis[b]=-1;\\n\\n       return ans;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& ed, int b, vector<int>& amt) {\\n        \\n        int n=ed.size();\\n\\n        vector<int>gr[n+1];\\n\\n        vector<int>leaf(n+1);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            gr[ed[i][0]].push_back(ed[i][1]);\\n            gr[ed[i][1]].push_back(ed[i][0]);\\n            leaf[ed[i][0]]++;\\n            leaf[ed[i][1]]++;\\n        }\\n        leaf[0]++;\\n\\n        vector<int>vis(n+1);\\n        vector<int>dis(n+1,-1);// dis of each node from bob orignal position  -->dis[x]==-1 mean nide x is not in path from bob to zero\\n\\n        dfs(gr,b,vis,dis,0);\\n\\n        for(int i=0;i<=n;i++)\\n        vis[i]=0;\\n\\n       queue<pair<int,int>>q;\\n       q.push({0,amt[0]});\\n    \\n       vis[0]=1;\\n       \\n       int ans=INT_MIN;\\n       int t=1; // distance of each node from 0;\\ns\\n\\n       while(!q.empty())\\n       {\\n\\n           int s=q.size();\\n    \\n           for(int i=0;i<s;i++)\\n           {\\n                pair<int,int>p = q.front();\\n                q.pop();\\n\\n                if(leaf[p.first]==1)\\n                   ans=max(ans,p.second);\\n\\n                int w=p.second;\\n                int x=p.first;\\n\\n                for(int j=0;j<gr[x].size();j++)\\n                {\\n                  int v=gr[x][j];\\n                  \\n                  if(!vis[v])\\n                  {\\n                      int val;\\n                      if(dis[v]==t)\\n                        val=amt[v]/2;\\n                      else if(dis[v]!=-1 && dis[v]<t)\\n                        val=0;\\n                      else \\n                        val=amt[v];\\n                      \\n                      q.push({v,w+val});\\n                      vis[v]=1;\\n                  }\\n\\n                }\\n           }\\n           t++;\\n       }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>gr[],int b,vector<int>&vis,vector<int>&dis,int t)\\n    {\\n       dis[b]=t;\\n       vis[b]=1;\\n\\n       if(b==0)\\n         return true;\\n\\n       bool ans=false;\\n       for(int j=0;j<gr[b].size();j++)\\n       {\\n           int v=gr[b][j];\\n\\n           if(!vis[v])\\n           {\\n              ans|= dfs(gr,v,vis,dis,t+1);\\n           }\\n       }\\n\\n       if(!ans)\\n        dis[b]=-1;\\n\\n       return ans;\\n    }\\n    int mostProfitablePath(vector<vector<int>>& ed, int b, vector<int>& amt) {\\n        \\n        int n=ed.size();\\n\\n        vector<int>gr[n+1];\\n\\n        vector<int>leaf(n+1);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            gr[ed[i][0]].push_back(ed[i][1]);\\n            gr[ed[i][1]].push_back(ed[i][0]);\\n            leaf[ed[i][0]]++;\\n            leaf[ed[i][1]]++;\\n        }\\n        leaf[0]++;\\n\\n        vector<int>vis(n+1);\\n        vector<int>dis(n+1,-1);// dis of each node from bob orignal position  -->dis[x]==-1 mean nide x is not in path from bob to zero\\n\\n        dfs(gr,b,vis,dis,0);\\n\\n        for(int i=0;i<=n;i++)\\n        vis[i]=0;\\n\\n       queue<pair<int,int>>q;\\n       q.push({0,amt[0]});\\n    \\n       vis[0]=1;\\n       \\n       int ans=INT_MIN;\\n       int t=1; // distance of each node from 0;\\ns\\n\\n       while(!q.empty())\\n       {\\n\\n           int s=q.size();\\n    \\n           for(int i=0;i<s;i++)\\n           {\\n                pair<int,int>p = q.front();\\n                q.pop();\\n\\n                if(leaf[p.first]==1)\\n                   ans=max(ans,p.second);\\n\\n                int w=p.second;\\n                int x=p.first;\\n\\n                for(int j=0;j<gr[x].size();j++)\\n                {\\n                  int v=gr[x][j];\\n                  \\n                  if(!vis[v])\\n                  {\\n                      int val;\\n                      if(dis[v]==t)\\n                        val=amt[v]/2;\\n                      else if(dis[v]!=-1 && dis[v]<t)\\n                        val=0;\\n                      else \\n                        val=amt[v];\\n                      \\n                      q.push({v,w+val});\\n                      vis[v]=1;\\n                  }\\n\\n                }\\n           }\\n           t++;\\n       }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946279,
                "title": "java-solution",
                "content": "ArrayList<Edge>[] graph=new ArrayList[edges.length+1];",
                "solutionTags": [],
                "code": "ArrayList<Edge>[] graph=new ArrayList[edges.length+1];",
                "codeTag": "Unknown"
            },
            {
                "id": 2945442,
                "title": "simple-java-approach-dfs-parent-bfs",
                "content": "# Intuition\\nSimple Approach : \\n1. get all nodes parents \\n2. Move Bob to parent nodes as BFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       class Node {\\n        int nd;\\n        int amount;\\n\\n        public Node(int nd, int amount) {\\n            this.amount = amount;\\n            this.nd = nd;\\n        }\\n    }\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int m = edges.length;\\n\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>();\\n        Set<Integer> opened = new HashSet<>();\\n        Map<Integer, Integer> parent = new HashMap<>();\\n        parent.put(0, -1);\\n        for (int i = 0; i < m; i++) {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            graph.putIfAbsent(a, new ArrayList<>());\\n            graph.putIfAbsent(b, new ArrayList<>());\\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        updateParent(graph, visited, 0, parent);\\n        visited.clear();\\n        Queue<Node> queue = new LinkedList<>();\\n\\n        queue.add(new Node(0, amount[0]));\\n        int max = Integer.MIN_VALUE;\\n\\n        while (!queue.isEmpty()) {\\n            if (bob != -1) {\\n                opened.add(bob);\\n                bob = parent.get(bob);\\n            }\\n            int l = queue.size();\\n            while (l > 0) {\\n                Node node = queue.poll();\\n                visited.add(node.nd);\\n                int val1 = node.amount;\\n                boolean isLeaf = true;\\n                for (Integer nd : graph.getOrDefault(node.nd,new ArrayList<>())) {\\n                    if (!visited.contains(nd)) {\\n                        isLeaf = false;\\n                        int val = val1;\\n                        if (!opened.contains(nd)) {\\n                            if (bob == nd) {\\n                                val += amount[nd] / 2;\\n                            } else {\\n                                val += amount[nd];\\n                            }\\n                        }\\n                        queue.add(new Node(nd, val));\\n                    }\\n                }\\n                if (isLeaf) {\\n                    max = Math.max(max, node.amount);\\n                }\\n                l--;\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private void updateParent(Map<Integer, List<Integer>> graph, Set<Integer> visited,\\n                           int node, Map<Integer, Integer> parent) {\\n\\n        if (visited.contains(node)) return;\\n        visited.add(node);\\n        for (Integer nd : graph.get(node)) {\\n\\n            if(!visited.contains(nd)){\\n                parent.put(nd, node);\\n                updateParent(graph, visited, nd, parent);\\n            }\\n\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       class Node {\\n        int nd;\\n        int amount;\\n\\n        public Node(int nd, int amount) {\\n            this.amount = amount;\\n            this.nd = nd;\\n        }\\n    }\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int m = edges.length;\\n\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>();\\n        Set<Integer> opened = new HashSet<>();\\n        Map<Integer, Integer> parent = new HashMap<>();\\n        parent.put(0, -1);\\n        for (int i = 0; i < m; i++) {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            graph.putIfAbsent(a, new ArrayList<>());\\n            graph.putIfAbsent(b, new ArrayList<>());\\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        updateParent(graph, visited, 0, parent);\\n        visited.clear();\\n        Queue<Node> queue = new LinkedList<>();\\n\\n        queue.add(new Node(0, amount[0]));\\n        int max = Integer.MIN_VALUE;\\n\\n        while (!queue.isEmpty()) {\\n            if (bob != -1) {\\n                opened.add(bob);\\n                bob = parent.get(bob);\\n            }\\n            int l = queue.size();\\n            while (l > 0) {\\n                Node node = queue.poll();\\n                visited.add(node.nd);\\n                int val1 = node.amount;\\n                boolean isLeaf = true;\\n                for (Integer nd : graph.getOrDefault(node.nd,new ArrayList<>())) {\\n                    if (!visited.contains(nd)) {\\n                        isLeaf = false;\\n                        int val = val1;\\n                        if (!opened.contains(nd)) {\\n                            if (bob == nd) {\\n                                val += amount[nd] / 2;\\n                            } else {\\n                                val += amount[nd];\\n                            }\\n                        }\\n                        queue.add(new Node(nd, val));\\n                    }\\n                }\\n                if (isLeaf) {\\n                    max = Math.max(max, node.amount);\\n                }\\n                l--;\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private void updateParent(Map<Integer, List<Integer>> graph, Set<Integer> visited,\\n                           int node, Map<Integer, Integer> parent) {\\n\\n        if (visited.contains(node)) return;\\n        visited.add(node);\\n        for (Integer nd : graph.get(node)) {\\n\\n            if(!visited.contains(nd)){\\n                parent.put(nd, node);\\n                updateParent(graph, visited, nd, parent);\\n            }\\n\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942920,
                "title": "2-bfs-approach",
                "content": "# Approcah-\\nFirst we are going to construct a sort of undirected graph corresponding to given vertices.\\nThen We will do a bfs and find parent of each node, keeping the parent of root node as -1.\\nThen for all those **nodes which are parent of no other nodes will be a leaf node** for sure.\\nWe will empty the vertices list for all such nodes.\\n\\nNow We have the tree ready.\\n\\nTo handle the case between alice and bob we will do a traversal from bob\\'s node to alice node.\\nSay the path length of alice to bob is ***path*** :\\npath->even : value of first path/2 nodes will be assigned as 0.\\npath->odd : value of first path/2 nodes will be assigned as 0 and the middle node\\'s value will be halved.\\n\\nNow We have modified amount.\\n\\nA simple bfs will give us the answer and while traversing each node we will be addidng the cost of its parent. And So on.\\n\\n# Code\\n```\\nvoid modify(vector<int>& parent ,int bob, vector<int>& amount){\\n    int path =0,t=bob;\\n       while(t!=-1){\\n           ++path;\\n           t=parent[t];\\n       }\\n       int lo=0,up=path-1;\\n       while(lo<=up){\\n           if(lo==up){ amount[bob]=amount[bob]/2; break; }\\n           amount[bob]=0;\\n           bob=parent[bob];\\n           ++lo;\\n           --up;\\n       }\\n}\\n\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n\\n       int n=edges.size()+1,res=INT_MIN;\\n       vector<int>parent(n,-1);\\n       vector<bool>isParent(n,0);\\n       vector<vector<int>>tree(n);\\n        \\n        for(int i=0;i<edges.size();i++) {\\n           tree[edges[i][0]].push_back(edges[i][1]);\\n           tree[edges[i][1]].push_back(edges[i][0]);\\n       }\\n       queue<int>q;\\n       q.push(0);\\n       while(!q.empty()){\\n           int t=q.front();\\n           q.pop();\\n           for(auto x:tree[t]){\\n               if(parent[x]==-1 && x!=0) { parent[x]=t; q.push(x); isParent[t]=1; }\\n           }\\n       }\\n        for(int i=0;i<n;i++){\\n            if(!isParent[i]) tree[i].clear();\\n        }\\n\\n        modify(parent,bob,amount);\\n\\n        q.push(0);\\n        while(!q.empty()){\\n            int t=q.front();\\n            q.pop();\\n            for(int i=0;i<tree[t].size();i++)\\n            {\\n                if(tree[t][i]!=parent[t]){\\n                q.push(tree[t][i]);\\n                amount[tree[t][i]]+=amount[parent[tree[t][i]]];\\n                }\\n            }\\n            if(tree[t].empty()) res=max(res,amount[t]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvoid modify(vector<int>& parent ,int bob, vector<int>& amount){\\n    int path =0,t=bob;\\n       while(t!=-1){\\n           ++path;\\n           t=parent[t];\\n       }\\n       int lo=0,up=path-1;\\n       while(lo<=up){\\n           if(lo==up){ amount[bob]=amount[bob]/2; break; }\\n           amount[bob]=0;\\n           bob=parent[bob];\\n           ++lo;\\n           --up;\\n       }\\n}\\n\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n\\n       int n=edges.size()+1,res=INT_MIN;\\n       vector<int>parent(n,-1);\\n       vector<bool>isParent(n,0);\\n       vector<vector<int>>tree(n);\\n        \\n        for(int i=0;i<edges.size();i++) {\\n           tree[edges[i][0]].push_back(edges[i][1]);\\n           tree[edges[i][1]].push_back(edges[i][0]);\\n       }\\n       queue<int>q;\\n       q.push(0);\\n       while(!q.empty()){\\n           int t=q.front();\\n           q.pop();\\n           for(auto x:tree[t]){\\n               if(parent[x]==-1 && x!=0) { parent[x]=t; q.push(x); isParent[t]=1; }\\n           }\\n       }\\n        for(int i=0;i<n;i++){\\n            if(!isParent[i]) tree[i].clear();\\n        }\\n\\n        modify(parent,bob,amount);\\n\\n        q.push(0);\\n        while(!q.empty()){\\n            int t=q.front();\\n            q.pop();\\n            for(int i=0;i<tree[t].size();i++)\\n            {\\n                if(tree[t][i]!=parent[t]){\\n                q.push(tree[t][i]);\\n                amount[tree[t][i]]+=amount[parent[tree[t][i]]];\\n                }\\n            }\\n            if(tree[t].empty()) res=max(res,amount[t]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941204,
                "title": "bfs-dfs-backtracking",
                "content": "# Intuition\\nAlice can go to different leaf nodes to end the game, but bob has only one path to follow(towards the root node). So we need to find that path.\\n\\n# Approach\\nFinding bob\\'s path is easy. Just find the parent or each node in the tree (Using DFS or BFS). Bob will follow the parent node on every step of the game to reach the root node from where further movement is not possible.\\n\\n->After finding parents of each node. Do DFS for alice (strating from 0) while also moving bob with every step.\\n->keep track of nodes visted by bob separately so we can decide if the amount needs to be added or not.\\n->also check if bob and alice are in the same node at each step. In that case add half of amount. \\n->When Backtracking from child to parent (or while returning from recursive DFS call), make sure to undo visited operation of bob if needed.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void getParents( vector<vector<int>> &adjMat, vector<int> &parent){\\n        int n = adjMat.size();\\n        queue<int> q;\\n        vector<int> visited(n,0);\\n        q.push(0);\\n        while(!q.empty()){\\n            int curr = q.front();\\n            visited[curr] = 1;\\n            q.pop();\\n            vector<int> &neighbors = adjMat[curr];\\n            for(int neighbor: neighbors){\\n                if(!visited[neighbor]){\\n                    parent[neighbor] = curr;\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int curr, vector<vector<int>> &adjMat, vector<int>& amount, int bob,vector<int> &parent, int &maxIncome,int alexIncome,\\n    vector<int> &visited, vector<int> &visitedByBob){\\n    \\n        if(curr == bob){\\n            alexIncome+= amount[curr]/2;\\n        }else{\\n            if( !visitedByBob[curr]){\\n                alexIncome += amount[curr];\\n            }\\n        }\\n        if(curr != 0 && adjMat[curr].size() == 1){\\n\\n            maxIncome =max(maxIncome, alexIncome);\\n        }\\n        visited[curr] = 1;\\n        if(bob>=0)\\n        visitedByBob[bob] = 1;\\n        vector<int> &neighbors = adjMat[curr];\\n        for(int neighbor: neighbors){\\n            if(!visited[neighbor]){\\n                if(bob >=0)\\n                dfs(neighbor, adjMat,amount,parent[bob], parent, maxIncome, alexIncome,visited, visitedByBob);\\n                else\\n                dfs(neighbor, adjMat,amount,-1, parent, maxIncome, alexIncome,visited, visitedByBob);\\n            }\\n        }\\n        if(bob>=0){\\n            visitedByBob[bob] = 0;\\n        }\\n    }\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size()+1;\\n        vector<vector<int>> adjMat(n);\\n        for(int i=0;i<n-1;i++){\\n            adjMat[edges[i][0]].push_back(edges[i][1]);\\n            adjMat[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> parent(n,-1);\\n        getParents(adjMat, parent);\\n        int maxIncome = INT_MIN, alexIncome = 0;\\n        vector<int> visited(n,0), visitedByBob(n,0);\\n        dfs(0,adjMat, amount, bob, parent, maxIncome, alexIncome , visited, visitedByBob);\\n        return maxIncome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void getParents( vector<vector<int>> &adjMat, vector<int> &parent){\\n        int n = adjMat.size();\\n        queue<int> q;\\n        vector<int> visited(n,0);\\n        q.push(0);\\n        while(!q.empty()){\\n            int curr = q.front();\\n            visited[curr] = 1;\\n            q.pop();\\n            vector<int> &neighbors = adjMat[curr];\\n            for(int neighbor: neighbors){\\n                if(!visited[neighbor]){\\n                    parent[neighbor] = curr;\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int curr, vector<vector<int>> &adjMat, vector<int>& amount, int bob,vector<int> &parent, int &maxIncome,int alexIncome,\\n    vector<int> &visited, vector<int> &visitedByBob){\\n    \\n        if(curr == bob){\\n            alexIncome+= amount[curr]/2;\\n        }else{\\n            if( !visitedByBob[curr]){\\n                alexIncome += amount[curr];\\n            }\\n        }\\n        if(curr != 0 && adjMat[curr].size() == 1){\\n\\n            maxIncome =max(maxIncome, alexIncome);\\n        }\\n        visited[curr] = 1;\\n        if(bob>=0)\\n        visitedByBob[bob] = 1;\\n        vector<int> &neighbors = adjMat[curr];\\n        for(int neighbor: neighbors){\\n            if(!visited[neighbor]){\\n                if(bob >=0)\\n                dfs(neighbor, adjMat,amount,parent[bob], parent, maxIncome, alexIncome,visited, visitedByBob);\\n                else\\n                dfs(neighbor, adjMat,amount,-1, parent, maxIncome, alexIncome,visited, visitedByBob);\\n            }\\n        }\\n        if(bob>=0){\\n            visitedByBob[bob] = 0;\\n        }\\n    }\\n\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size()+1;\\n        vector<vector<int>> adjMat(n);\\n        for(int i=0;i<n-1;i++){\\n            adjMat[edges[i][0]].push_back(edges[i][1]);\\n            adjMat[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> parent(n,-1);\\n        getParents(adjMat, parent);\\n        int maxIncome = INT_MIN, alexIncome = 0;\\n        vector<int> visited(n,0), visitedByBob(n,0);\\n        dfs(0,adjMat, amount, bob, parent, maxIncome, alexIncome , visited, visitedByBob);\\n        return maxIncome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936776,
                "title": "c-dfs-backtracking-solution",
                "content": "Applying DFS or (Recursion + Backtrack) on BOB and ALICE simultaneously, Bob will have only one way to reach \\'0\\'th node (this solved main headache). Rest should be pretty understandable\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int> mp;\\n    \\n      void solve(int src,int par, vector<vector<int>> &adj){ \\n        mp[src] = par;\\n        for(auto itr:adj[src]){\\n            if(itr!=mp[src]) solve(itr,src, adj);\\n        }\\n    }\\n    \\n   int ans= INT_MIN;\\n    \\n\\n   void dfs(int sum, int alice, int bob, vector<vector<int>> &adj, vector<int> &vis, vector<int> &amount){\\n       if(adj[alice].size()==1 and alice!=0){\\n           if(!vis[alice])sum+=amount[alice];\\n           ans= max(ans, sum);\\n           return;\\n       }\\n    \\n       \\n       if(bob<0)bob=0;\\n      \\n       vis[bob]=1;\\n\\n       for(auto it: adj[alice]){\\n           if(bob==alice and it!=mp[alice] ){\\n               dfs(sum+(amount[alice])/2, it, mp[bob], adj, vis, amount);\\n           }\\n           else if(it!=mp[alice] and !vis[alice])dfs(sum+amount[alice], it, mp[bob], adj, vis, amount);\\n           else if(it!=mp[alice]) dfs(sum, it, mp[bob], adj, vis, amount);\\n       }\\n       \\n       vis[bob]=0;\\n       \\n   }\\n    \\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n       int n= edges.size()+1;\\n       vector<vector<int>> adj(n);\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n   \\n       solve(0,-1,adj);\\n     \\n        \\n       vector<int> vis(n,0);\\n       dfs(0, 0, bob, adj, vis, amount);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int> mp;\\n    \\n      void solve(int src,int par, vector<vector<int>> &adj){ \\n        mp[src] = par;\\n        for(auto itr:adj[src]){\\n            if(itr!=mp[src]) solve(itr,src, adj);\\n        }\\n    }\\n    \\n   int ans= INT_MIN;\\n    \\n\\n   void dfs(int sum, int alice, int bob, vector<vector<int>> &adj, vector<int> &vis, vector<int> &amount){\\n       if(adj[alice].size()==1 and alice!=0){\\n           if(!vis[alice])sum+=amount[alice];\\n           ans= max(ans, sum);\\n           return;\\n       }\\n    \\n       \\n       if(bob<0)bob=0;\\n      \\n       vis[bob]=1;\\n\\n       for(auto it: adj[alice]){\\n           if(bob==alice and it!=mp[alice] ){\\n               dfs(sum+(amount[alice])/2, it, mp[bob], adj, vis, amount);\\n           }\\n           else if(it!=mp[alice] and !vis[alice])dfs(sum+amount[alice], it, mp[bob], adj, vis, amount);\\n           else if(it!=mp[alice]) dfs(sum, it, mp[bob], adj, vis, amount);\\n       }\\n       \\n       vis[bob]=0;\\n       \\n   }\\n    \\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n       int n= edges.size()+1;\\n       vector<vector<int>> adj(n);\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n   \\n       solve(0,-1,adj);\\n     \\n        \\n       vector<int> vis(n,0);\\n       dfs(0, 0, bob, adj, vis, amount);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936082,
                "title": "two-way-trees-marking-out-bob-s-steps-finding-best-path",
                "content": "# Intuition\\nAt first I thought that we need to define the best path at each particular step (like in checkmate). It works for simple examples but drops at bigger trees.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Graph\\n- Tree as a Collection\\n- Backward parent list tree\\n- Excluding all posible Bob\\'s visits\\n- Walking through the tree to find the best path\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ at worst\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Edges = [number, number][]\\ntype Amount = (number | null)[]\\ntype Graph = number[][]\\ntype Collection = Map<number, Record<string, number>>\\ntype ParentsList = Map<number, number>\\n\\nfunction createGraph(edges: Edges): Graph {\\n    return edges.reduce((graph, [s,e]) => {\\n        graph[s].push(e);\\n        graph[e].push(s);\\n        return graph\\n    }, [...Array(edges.length + 1).keys()].map(() => []) as unknown as Edges)\\n}\\n\\nfunction treeMapFromGraph(graph: Graph): Collection {\\n    // Here we create a tree without duplicates from graph\\n    // For that I used stack approach with marking each node we\\'ve visited so far\\n    // to avoid entry overriding\\n    const tree = new Map()\\n    const stack = [0]\\n    const visited = {}\\n\\n    while(stack.length) {\\n        const popped = stack.shift()\\n        visited[popped] = true\\n        const neighbours = graph[popped]\\n\\n        if(!tree.has(popped)) {\\n            tree.set(popped, {})\\n        }\\n\\n        for(const n of neighbours) {\\n            if(!visited[n]) {\\n                tree.set(popped, Object.assign(tree.get(popped), { [n]: n }))\\n                stack.push(n)\\n            }\\n        }\\n\\n        const entry = tree.get(popped)\\n\\n        if(Object.keys(entry).length === 0) {\\n            tree.delete(popped)\\n        }\\n    }\\n\\n    return tree\\n}\\n\\nfunction treeMapParentsList(collection: Collection): ParentsList {\\n    // This auxiliary collection was made to enhance time performance\\n    // When I want to get Bob\\'s next step I simply get it with 0(1)\\n    // as we have a \\'childNode => parentNode\\' structure\\n\\n    const parentsCollection  = new Map()\\n\\n    for (let [key, value] of collection.entries()) {\\n        const values = Object.values(value)\\n\\n        if(values.length === 1) {\\n            parentsCollection.set(values[0], key)\\n        } else {\\n            for(const v of values) {\\n                parentsCollection.set(v, key)\\n            }\\n        }\\n    }\\n\\n    return parentsCollection\\n}\\n\\nfunction bobNextStep(collection: ParentsList, currentNode: number): number {\\n    // Left this function here for better perception\\n    return collection.get(currentNode)\\n}\\n\\nfunction excludeBobsVisitedEdges(collection: Collection, bob: number, amount: Amount): Amount {\\n    // Walk from Bob\\'s initial node directly to node 0\\n    // After we completed we remove all the node\\'s costs and check\\n    // if the middle one should be divided by 2 as it might be\\n    // the node where Alice & Bob face each other simultaneously\\n\\n    const visited = [bob]\\n    let node = bob\\n    const parentsCollection = treeMapParentsList(collection)\\n\\n    while(node !== 0) {\\n        node = bobNextStep(parentsCollection, node)\\n        visited.push(node)\\n    }\\n\\n    const isVisitedEven = visited.length % 2 === 0\\n    const mid = Math.floor(visited.length / 2)\\n\\n    for (let node of visited.slice(0, mid)) {\\n        if(node !== 0) {\\n            amount[node] = null\\n        }\\n    }\\n\\n    if(!isVisitedEven && amount[visited[mid]] !== null) {\\n        amount[visited[mid]] /= 2\\n    }\\n\\n    return amount\\n}\\n\\nfunction calcCounter(amountPointer: number, amount: Amount, counter: number): number {\\n    return (amount[amountPointer] === null ? counter : counter + amount[amountPointer])\\n}\\n\\nfunction calculateMostProfitablePath(collection: Collection, amount: Amount,  node: number = 0, counter: number = amount[node]): number {\\n    // Here we recursively walk and compare the most\\n    // profitable path possible for Alice\\n    \\n    const entry = collection.get(node)\\n\\n    if(entry === undefined) return counter\\n\\n    const entryOptions = Object.keys(entry)\\n    const [singleEntry] = entryOptions\\n\\n    if(entryOptions.length > 1) {\\n        return entryOptions.reduce((acc, cur) => {\\n            const pathCounter = calculateMostProfitablePath(collection, amount, +cur, calcCounter(+cur, amount, counter))\\n            return pathCounter > acc ? pathCounter : acc\\n        }, -Infinity)\\n    }\\n\\n    return calculateMostProfitablePath(collection, amount, +singleEntry, calcCounter(+singleEntry, amount, counter))\\n}\\n\\nfunction mostProfitablePath(edges: Edges, bob: number, amount: Amount): number {\\n    // Create a tree out of graph of edges\\n    // Helps with improper edges sequences\\n    const tree = treeMapFromGraph(createGraph(edges))\\n\\n    // As Bob only has single availiable path we can exclude all the\\n    // steps he can possibly make\\n    const amountWithExclusions = excludeBobsVisitedEdges(tree, bob, amount)\\n\\n    // Now we can walk through our tree to find the most valuable path\\n    return calculateMostProfitablePath(tree, amountWithExclusions)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Edges = [number, number][]\\ntype Amount = (number | null)[]\\ntype Graph = number[][]\\ntype Collection = Map<number, Record<string, number>>\\ntype ParentsList = Map<number, number>\\n\\nfunction createGraph(edges: Edges): Graph {\\n    return edges.reduce((graph, [s,e]) => {\\n        graph[s].push(e);\\n        graph[e].push(s);\\n        return graph\\n    }, [...Array(edges.length + 1).keys()].map(() => []) as unknown as Edges)\\n}\\n\\nfunction treeMapFromGraph(graph: Graph): Collection {\\n    // Here we create a tree without duplicates from graph\\n    // For that I used stack approach with marking each node we\\'ve visited so far\\n    // to avoid entry overriding\\n    const tree = new Map()\\n    const stack = [0]\\n    const visited = {}\\n\\n    while(stack.length) {\\n        const popped = stack.shift()\\n        visited[popped] = true\\n        const neighbours = graph[popped]\\n\\n        if(!tree.has(popped)) {\\n            tree.set(popped, {})\\n        }\\n\\n        for(const n of neighbours) {\\n            if(!visited[n]) {\\n                tree.set(popped, Object.assign(tree.get(popped), { [n]: n }))\\n                stack.push(n)\\n            }\\n        }\\n\\n        const entry = tree.get(popped)\\n\\n        if(Object.keys(entry).length === 0) {\\n            tree.delete(popped)\\n        }\\n    }\\n\\n    return tree\\n}\\n\\nfunction treeMapParentsList(collection: Collection): ParentsList {\\n    // This auxiliary collection was made to enhance time performance\\n    // When I want to get Bob\\'s next step I simply get it with 0(1)\\n    // as we have a \\'childNode => parentNode\\' structure\\n\\n    const parentsCollection  = new Map()\\n\\n    for (let [key, value] of collection.entries()) {\\n        const values = Object.values(value)\\n\\n        if(values.length === 1) {\\n            parentsCollection.set(values[0], key)\\n        } else {\\n            for(const v of values) {\\n                parentsCollection.set(v, key)\\n            }\\n        }\\n    }\\n\\n    return parentsCollection\\n}\\n\\nfunction bobNextStep(collection: ParentsList, currentNode: number): number {\\n    // Left this function here for better perception\\n    return collection.get(currentNode)\\n}\\n\\nfunction excludeBobsVisitedEdges(collection: Collection, bob: number, amount: Amount): Amount {\\n    // Walk from Bob\\'s initial node directly to node 0\\n    // After we completed we remove all the node\\'s costs and check\\n    // if the middle one should be divided by 2 as it might be\\n    // the node where Alice & Bob face each other simultaneously\\n\\n    const visited = [bob]\\n    let node = bob\\n    const parentsCollection = treeMapParentsList(collection)\\n\\n    while(node !== 0) {\\n        node = bobNextStep(parentsCollection, node)\\n        visited.push(node)\\n    }\\n\\n    const isVisitedEven = visited.length % 2 === 0\\n    const mid = Math.floor(visited.length / 2)\\n\\n    for (let node of visited.slice(0, mid)) {\\n        if(node !== 0) {\\n            amount[node] = null\\n        }\\n    }\\n\\n    if(!isVisitedEven && amount[visited[mid]] !== null) {\\n        amount[visited[mid]] /= 2\\n    }\\n\\n    return amount\\n}\\n\\nfunction calcCounter(amountPointer: number, amount: Amount, counter: number): number {\\n    return (amount[amountPointer] === null ? counter : counter + amount[amountPointer])\\n}\\n\\nfunction calculateMostProfitablePath(collection: Collection, amount: Amount,  node: number = 0, counter: number = amount[node]): number {\\n    // Here we recursively walk and compare the most\\n    // profitable path possible for Alice\\n    \\n    const entry = collection.get(node)\\n\\n    if(entry === undefined) return counter\\n\\n    const entryOptions = Object.keys(entry)\\n    const [singleEntry] = entryOptions\\n\\n    if(entryOptions.length > 1) {\\n        return entryOptions.reduce((acc, cur) => {\\n            const pathCounter = calculateMostProfitablePath(collection, amount, +cur, calcCounter(+cur, amount, counter))\\n            return pathCounter > acc ? pathCounter : acc\\n        }, -Infinity)\\n    }\\n\\n    return calculateMostProfitablePath(collection, amount, +singleEntry, calcCounter(+singleEntry, amount, counter))\\n}\\n\\nfunction mostProfitablePath(edges: Edges, bob: number, amount: Amount): number {\\n    // Create a tree out of graph of edges\\n    // Helps with improper edges sequences\\n    const tree = treeMapFromGraph(createGraph(edges))\\n\\n    // As Bob only has single availiable path we can exclude all the\\n    // steps he can possibly make\\n    const amountWithExclusions = excludeBobsVisitedEdges(tree, bob, amount)\\n\\n    // Now we can walk through our tree to find the most valuable path\\n    return calculateMostProfitablePath(tree, amountWithExclusions)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2934672,
                "title": "long-but-easy-to-understand-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int [] nodeDegree;\\n    int maxP = Integer.MIN_VALUE;\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        \\n        int [] distOfBob =   new int[amount.length];\\n        Arrays.fill(distOfBob, Integer.MAX_VALUE);\\n        int n = amount.length;\\n        \\n        List<Integer> [] adj = new ArrayList[amount.length];\\n        for(int i = 0; i < amount.length; i++) adj[i] = new ArrayList<>();\\n        \\n        nodeDegree = new int[n];\\n        Arrays.fill(nodeDegree, 0);\\n        for(int [] e : edges){\\n            \\n            adj[e[0]].add(e[1]);\\n            adj[e[1]].add(e[0]);\\n            //To identify if the given node is leaf node\\n            //In case node degree is 1 then its a leaf node.\\n            nodeDegree[e[0]]++;\\n            nodeDegree[e[1]]++;\\n        }\\n        \\n        boolean [] visAlice = new boolean[n];\\n        boolean [] visbob =  new boolean[n];\\n        Set<Integer> path = new HashSet<>();\\n        /*\\n            Do DFS from Bob\\'s Location to root 0;\\n            and Find the Distance of each node from bob location.\\n        */\\n        dfsBob(adj, bob,visbob, distOfBob, 0, path);\\n        // Now Makr all node distance from bob location to INF if bob have not visited it.\\n        for(int i = 0; i < n; i++) {\\n            if(!path.contains(i)){\\n                distOfBob[i] = Integer.MAX_VALUE;\\n            }\\n        }\\n        dfsAlice(adj,  0, visAlice, distOfBob , 0 , 0, amount);\\n\\n        return maxP;\\n        \\n    }\\n    //Find the bob path from its location to root node and compute the distance.\\n    boolean dfsBob(List<Integer> [] adj, int bob, boolean [] visbob, int [] distOfBobc, int d, Set<Integer> path){\\n        visbob[bob] = true;\\n        distOfBobc[bob] = d;\\n        if(bob == 0){\\n            path.add(bob);\\n            return true;\\n        }\\n        path.add(bob);\\n        for(int nextNode : adj[bob]){\\n            if(!visbob[nextNode]){\\n                visbob[nextNode] = true;\\n                if(dfsBob(adj,nextNode, visbob, distOfBobc, d + 1, path)) return true;\\n            }   \\n        }\\n        path.remove(bob);\\n        return false;\\n    }\\n    void dfsAlice(List<Integer> [] adj, int alice, boolean [] visAlice,int []  distOfBob , int d, int score, int[] amount){\\n\\n        //Compute the score for Alice.\\n        visAlice[alice] = true;\\n        if(d == distOfBob[alice]){\\n            score+=(amount[alice]/2);\\n        }\\n        else if(d < distOfBob[alice]){\\n            score+=(amount[alice]);\\n        }\\n        else if(d == 0){\\n            score+=(amount[alice]);\\n        }\\n        for(int nextNode : adj[alice]){\\n            if(!visAlice[nextNode]){\\n                visAlice[nextNode] = true;\\n                dfsAlice(adj, nextNode, visAlice,distOfBob, d + 1, score, amount);\\n            }   \\n        }\\n        //If nodeDegree is 1 its definately a leafe node , compute the score.\\n        if(nodeDegree[alice] == 1 && alice!= 0){\\n            maxP = Math.max(score, maxP);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int [] nodeDegree;\\n    int maxP = Integer.MIN_VALUE;\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        \\n        int [] distOfBob =   new int[amount.length];\\n        Arrays.fill(distOfBob, Integer.MAX_VALUE);\\n        int n = amount.length;\\n        \\n        List<Integer> [] adj = new ArrayList[amount.length];\\n        for(int i = 0; i < amount.length; i++) adj[i] = new ArrayList<>();\\n        \\n        nodeDegree = new int[n];\\n        Arrays.fill(nodeDegree, 0);\\n        for(int [] e : edges){\\n            \\n            adj[e[0]].add(e[1]);\\n            adj[e[1]].add(e[0]);\\n            //To identify if the given node is leaf node\\n            //In case node degree is 1 then its a leaf node.\\n            nodeDegree[e[0]]++;\\n            nodeDegree[e[1]]++;\\n        }\\n        \\n        boolean [] visAlice = new boolean[n];\\n        boolean [] visbob =  new boolean[n];\\n        Set<Integer> path = new HashSet<>();\\n        /*\\n            Do DFS from Bob\\'s Location to root 0;\\n            and Find the Distance of each node from bob location.\\n        */\\n        dfsBob(adj, bob,visbob, distOfBob, 0, path);\\n        // Now Makr all node distance from bob location to INF if bob have not visited it.\\n        for(int i = 0; i < n; i++) {\\n            if(!path.contains(i)){\\n                distOfBob[i] = Integer.MAX_VALUE;\\n            }\\n        }\\n        dfsAlice(adj,  0, visAlice, distOfBob , 0 , 0, amount);\\n\\n        return maxP;\\n        \\n    }\\n    //Find the bob path from its location to root node and compute the distance.\\n    boolean dfsBob(List<Integer> [] adj, int bob, boolean [] visbob, int [] distOfBobc, int d, Set<Integer> path){\\n        visbob[bob] = true;\\n        distOfBobc[bob] = d;\\n        if(bob == 0){\\n            path.add(bob);\\n            return true;\\n        }\\n        path.add(bob);\\n        for(int nextNode : adj[bob]){\\n            if(!visbob[nextNode]){\\n                visbob[nextNode] = true;\\n                if(dfsBob(adj,nextNode, visbob, distOfBobc, d + 1, path)) return true;\\n            }   \\n        }\\n        path.remove(bob);\\n        return false;\\n    }\\n    void dfsAlice(List<Integer> [] adj, int alice, boolean [] visAlice,int []  distOfBob , int d, int score, int[] amount){\\n\\n        //Compute the score for Alice.\\n        visAlice[alice] = true;\\n        if(d == distOfBob[alice]){\\n            score+=(amount[alice]/2);\\n        }\\n        else if(d < distOfBob[alice]){\\n            score+=(amount[alice]);\\n        }\\n        else if(d == 0){\\n            score+=(amount[alice]);\\n        }\\n        for(int nextNode : adj[alice]){\\n            if(!visAlice[nextNode]){\\n                visAlice[nextNode] = true;\\n                dfsAlice(adj, nextNode, visAlice,distOfBob, d + 1, score, amount);\\n            }   \\n        }\\n        //If nodeDegree is 1 its definately a leafe node , compute the score.\\n        if(nodeDegree[alice] == 1 && alice!= 0){\\n            maxP = Math.max(score, maxP);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934112,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn most_profitable_path(edges: Vec<Vec<i32>>, bob: i32, amount: Vec<i32>) -> i32 {\\n        fn find(graph: &Vec<Vec<usize>>, flag: &mut Vec<i32>, bob: usize, u: usize, path: &mut Vec<usize>) {\\n            let n = path.len();\\n            if n > 0 && path[n - 1] == bob {\\n                return;\\n            }\\n\\n            path.push(u);\\n            flag[u] = 1;\\n            for v in &graph[u] {\\n                if flag[*v] == 1 {\\n                    continue;\\n                }\\n                find(graph, flag, bob, *v, path);\\n            }\\n            if path[path.len() - 1] != bob {\\n                path.pop();\\n            }\\n        }\\n\\n        let n = amount.len();\\n        let mut graph = vec![vec![]; n];\\n        let mut amount = amount;\\n\\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n\\n        let mut path = vec![];\\n        let mut flag = vec![0; n];\\n\\n        find(&graph, &mut flag, bob as usize, 0, &mut path);\\n\\n        let mut flag = vec![0; n];\\n        let mut q: Vec<(usize, i32)> = vec![(0, amount[0])];\\n        let mut ret = i32::MIN;\\n        flag[0] = 1;\\n\\n        while !q.is_empty() {\\n            if let Some(x) = path.pop() {\\n                amount[x] = 0;\\n            }\\n            let mut temp = Vec::<(usize, i32)>::new();\\n\\n            while let Some((u, profit)) = q.pop() {\\n                if u != 0 && graph[u].len() == 1 {\\n                    ret = ret.max(profit);\\n                }\\n                let mut share = n;\\n                if !path.is_empty() {\\n                    share = path[path.len() - 1];\\n                }\\n\\n                for v in &graph[u] {\\n                    if flag[*v] == 1 {\\n                        continue;\\n                    }\\n\\n                    flag[*v] = 1;\\n                    let mut t = amount[*v];\\n                    if share == *v {\\n                        t /= 2;\\n                    }\\n                    temp.push((*v, profit + t));\\n                }\\n            }\\n            q = temp;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn most_profitable_path(edges: Vec<Vec<i32>>, bob: i32, amount: Vec<i32>) -> i32 {\\n        fn find(graph: &Vec<Vec<usize>>, flag: &mut Vec<i32>, bob: usize, u: usize, path: &mut Vec<usize>) {\\n            let n = path.len();\\n            if n > 0 && path[n - 1] == bob {\\n                return;\\n            }\\n\\n            path.push(u);\\n            flag[u] = 1;\\n            for v in &graph[u] {\\n                if flag[*v] == 1 {\\n                    continue;\\n                }\\n                find(graph, flag, bob, *v, path);\\n            }\\n            if path[path.len() - 1] != bob {\\n                path.pop();\\n            }\\n        }\\n\\n        let n = amount.len();\\n        let mut graph = vec![vec![]; n];\\n        let mut amount = amount;\\n\\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n\\n        let mut path = vec![];\\n        let mut flag = vec![0; n];\\n\\n        find(&graph, &mut flag, bob as usize, 0, &mut path);\\n\\n        let mut flag = vec![0; n];\\n        let mut q: Vec<(usize, i32)> = vec![(0, amount[0])];\\n        let mut ret = i32::MIN;\\n        flag[0] = 1;\\n\\n        while !q.is_empty() {\\n            if let Some(x) = path.pop() {\\n                amount[x] = 0;\\n            }\\n            let mut temp = Vec::<(usize, i32)>::new();\\n\\n            while let Some((u, profit)) = q.pop() {\\n                if u != 0 && graph[u].len() == 1 {\\n                    ret = ret.max(profit);\\n                }\\n                let mut share = n;\\n                if !path.is_empty() {\\n                    share = path[path.len() - 1];\\n                }\\n\\n                for v in &graph[u] {\\n                    if flag[*v] == 1 {\\n                        continue;\\n                    }\\n\\n                    flag[*v] = 1;\\n                    let mut t = amount[*v];\\n                    if share == *v {\\n                        t /= 2;\\n                    }\\n                    temp.push((*v, profit + t));\\n                }\\n            }\\n            q = temp;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2911163,
                "title": "tree-dfs",
                "content": "# Intuition\\nIf Bob was not around, Alice could simply evaluate the optimal\\nreward recursively using tree DFS starting from root 0. \\n\\nBob traveling in the tree effectively changes the reward of some of the nodes. \\n\\n# Approach\\nOne can first compute the modifications of the tree due to Bob\\'s\\nand afterwards the optimal reward. Since Bob travels upwards,\\nparent information is useful.\\n\\n# Complexity\\n- Time complexity: Tree-DFS $$O(n)$$, with n = #vertices\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        # Bob\\'s path is determined, all node vals up to middle set 0\\n        # if #nodes between Alice/Bob is odd, middle node gets halved\\n        # Alice chooses optimum in this modified tree\\n        if bob == 0: return amount[0]//2\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        # build parent information\\n        n = len(edges)+1\\n        parent = [0,]*n\\n        def dfs(node,par):\\n            parent[node] = par\\n            for child in graph[node]:\\n                if child == par: continue\\n                dfs(child,node)\\n        dfs(0,-1) # dfs from root 0\\n        # compute distance of bob to root 0\\n        curr, cnt = bob, 1\\n        while parent[curr] != -1:\\n            curr = parent[curr]\\n            cnt += 1\\n        # rewrite tree costs \\n        curr = bob\\n        for _ in range(cnt//2):\\n            amount[curr] = 0\\n            curr = parent[curr]\\n        if cnt%2: amount[curr] //= 2\\n        # now compute optimal reward in modified tree\\n        def maxprofit(node):\\n            return amount[node] + max((maxprofit(c) for c in graph[node] if c != parent[node]),default = 0)\\n        return maxprofit(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        # Bob\\'s path is determined, all node vals up to middle set 0\\n        # if #nodes between Alice/Bob is odd, middle node gets halved\\n        # Alice chooses optimum in this modified tree\\n        if bob == 0: return amount[0]//2\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        # build parent information\\n        n = len(edges)+1\\n        parent = [0,]*n\\n        def dfs(node,par):\\n            parent[node] = par\\n            for child in graph[node]:\\n                if child == par: continue\\n                dfs(child,node)\\n        dfs(0,-1) # dfs from root 0\\n        # compute distance of bob to root 0\\n        curr, cnt = bob, 1\\n        while parent[curr] != -1:\\n            curr = parent[curr]\\n            cnt += 1\\n        # rewrite tree costs \\n        curr = bob\\n        for _ in range(cnt//2):\\n            amount[curr] = 0\\n            curr = parent[curr]\\n        if cnt%2: amount[curr] //= 2\\n        # now compute optimal reward in modified tree\\n        def maxprofit(node):\\n            return amount[node] + max((maxprofit(c) for c in graph[node] if c != parent[node]),default = 0)\\n        return maxprofit(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897767,
                "title": "c-solution-beats-64-submission-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTree traversal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the path that Bob travels, such that each step is closer to node 0. Then, find all possible paths that Alice can take, apply the rules accordingly.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N log(N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const static int MAX = 1e5 + 10;\\n    int bobS[MAX];\\n    int bobSS[MAX];\\n    int aliceS[MAX];\\n    std::map<int, vector<int>> T;\\n    int income;\\n    bool in_m;\\n    void in_T(int a, int b) {\\n        if (T.find(a) == T.end()) { T[a] = { b }; }\\n        else { T[a].push_back(b); }\\n    }\\n    void bob_travel(int cur) {\\n        std::queue<int> Q = {};\\n        Q.push(cur);\\n        bobSS[cur] = -1;\\n        int step = 0;\\n        bool reach = false;\\n        while (!Q.empty()) {\\n            if (reach)\\n                break;\\n            int qlen = Q.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int cur = Q.front(); Q.pop();\\n                for (int d : T[cur]) {\\n                    if (bobSS[d] == MAX) {\\n                        bobSS[d] = cur;\\n                        if (d == 0) {\\n                            reach = true;\\n                        }\\n                        Q.push(d);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        int bmv = 0;\\n        while (bobSS[bmv] != -1) {\\n            bobS[bmv] = step;\\n            step--;\\n            bmv = bobSS[bmv];\\n        }\\n        bobS[bmv] = 0;\\n    }\\n    void opt(int cur, int val, int step, vector<int>& amt) {\\n        aliceS[cur] = step;\\n        if (bobS[cur] == aliceS[cur]) {\\n            val += amt[cur] / 2;\\n        }\\n        else if (bobS[cur] > aliceS[cur]) {\\n            val += amt[cur];\\n        }\\n        bool l = true;\\n        for (int des : T[cur]) {\\n            if (aliceS[des] == MAX) {\\n                l = false;\\n                opt(des, val, step + 1, amt);\\n            }\\n        }\\n        if (l) {\\n            if (!in_m) { in_m = true; income = val; }\\n            else { income = std::max(income, val); }\\n        }\\n        return; \\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        for (vector<int> e : edges) {\\n            in_T(e[0], e[1]);\\n            in_T(e[1], e[0]);\\n        }\\n        for (int i = 0; i < MAX; i++) {\\n            aliceS[i] = MAX;\\n            bobS[i] = MAX;\\n            bobSS[i] = MAX;\\n        }\\n        bob_travel(bob);\\n        income = 0;\\n        in_m = false;\\n        opt(0, 0, 0, amount);\\n        return income;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const static int MAX = 1e5 + 10;\\n    int bobS[MAX];\\n    int bobSS[MAX];\\n    int aliceS[MAX];\\n    std::map<int, vector<int>> T;\\n    int income;\\n    bool in_m;\\n    void in_T(int a, int b) {\\n        if (T.find(a) == T.end()) { T[a] = { b }; }\\n        else { T[a].push_back(b); }\\n    }\\n    void bob_travel(int cur) {\\n        std::queue<int> Q = {};\\n        Q.push(cur);\\n        bobSS[cur] = -1;\\n        int step = 0;\\n        bool reach = false;\\n        while (!Q.empty()) {\\n            if (reach)\\n                break;\\n            int qlen = Q.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int cur = Q.front(); Q.pop();\\n                for (int d : T[cur]) {\\n                    if (bobSS[d] == MAX) {\\n                        bobSS[d] = cur;\\n                        if (d == 0) {\\n                            reach = true;\\n                        }\\n                        Q.push(d);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        int bmv = 0;\\n        while (bobSS[bmv] != -1) {\\n            bobS[bmv] = step;\\n            step--;\\n            bmv = bobSS[bmv];\\n        }\\n        bobS[bmv] = 0;\\n    }\\n    void opt(int cur, int val, int step, vector<int>& amt) {\\n        aliceS[cur] = step;\\n        if (bobS[cur] == aliceS[cur]) {\\n            val += amt[cur] / 2;\\n        }\\n        else if (bobS[cur] > aliceS[cur]) {\\n            val += amt[cur];\\n        }\\n        bool l = true;\\n        for (int des : T[cur]) {\\n            if (aliceS[des] == MAX) {\\n                l = false;\\n                opt(des, val, step + 1, amt);\\n            }\\n        }\\n        if (l) {\\n            if (!in_m) { in_m = true; income = val; }\\n            else { income = std::max(income, val); }\\n        }\\n        return; \\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        for (vector<int> e : edges) {\\n            in_T(e[0], e[1]);\\n            in_T(e[1], e[0]);\\n        }\\n        for (int i = 0; i < MAX; i++) {\\n            aliceS[i] = MAX;\\n            bobS[i] = MAX;\\n            bobSS[i] = MAX;\\n        }\\n        bob_travel(bob);\\n        income = 0;\\n        in_m = false;\\n        opt(0, 0, 0, amount);\\n        return income;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897732,
                "title": "c-double-depth-first-search",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\t1. first node = 0 (Alice initial position) and second node = bob (Bob initial position)\\n\\t2. Initialize all the depth[node] w.r.t node = 0 \\n\\t2. They will meet at a certain point when nodes between them is odd including them think by drawing it:) else they will never meet\\n\\t3. So, if they meet then the point will be at distance dis[bob] / 2 from the bob.\\n\\t4. I can find it by simple backtrack\\n\\t5. Initialize all the values from that point to bob with 0 when they never meet else the point they meet will be A[node] / 2.\\n\\t6. Now our question becomes need to find maximum path sum to any leave :)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const static int N = 1e5 + 1;\\n    int ans = -1e9 - 7;\\n    vector<int> g[N];\\n    int d[N], par[N], dp[N];\\n    \\n    void dfs1(int node, int parent, int lvl) {\\n        d[node] = lvl;\\n        par[node] = parent;\\n        for(int child : g[node]) {\\n            if(child == parent) {\\n                continue;\\n            }\\n            dfs1(child, node, lvl + 1);\\n        }\\n    }\\n    \\n    void dfs2(int node, int parent, int prefix, vector<int>& A) {\\n        dp[node] = A[node];\\n        int to_add = -1e9 - 7;\\n        for(int child : g[node]) {\\n            if(child == parent) {\\n                continue;\\n            }\\n            dfs2(child, node, prefix + A[node], A);\\n            to_add = max(to_add, dp[child]);\\n        }\\n        if(to_add == -1e9 - 7) {\\n            dp[node] = A[node];\\n        }\\n        else {\\n            dp[node] = to_add + A[node];\\n        }\\n        ans = max(ans, dp[node] + prefix);\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& A) {\\n        for(auto P : edges) {\\n            int u = P[0];\\n            int v = P[1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        dfs1(0, -1, 0);\\n        int bob_lite = bob;\\n        int to = d[bob];\\n        to /= 2;\\n        while(to--) {\\n            bob_lite = par[bob_lite];\\n        }\\n        int node = bob;\\n        while(node != bob_lite) {\\n            A[node] = 0;\\n            node = par[node];\\n        }\\n        if(d[bob] % 2 == 0) {\\n            A[node] /= 2;\\n        }\\n        else {\\n            A[node] = 0;\\n        }\\n        ans = -1e9 - 7;\\n        dfs2(0, -1, 0, A);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const static int N = 1e5 + 1;\\n    int ans = -1e9 - 7;\\n    vector<int> g[N];\\n    int d[N], par[N], dp[N];\\n    \\n    void dfs1(int node, int parent, int lvl) {\\n        d[node] = lvl;\\n        par[node] = parent;\\n        for(int child : g[node]) {\\n            if(child == parent) {\\n                continue;\\n            }\\n            dfs1(child, node, lvl + 1);\\n        }\\n    }\\n    \\n    void dfs2(int node, int parent, int prefix, vector<int>& A) {\\n        dp[node] = A[node];\\n        int to_add = -1e9 - 7;\\n        for(int child : g[node]) {\\n            if(child == parent) {\\n                continue;\\n            }\\n            dfs2(child, node, prefix + A[node], A);\\n            to_add = max(to_add, dp[child]);\\n        }\\n        if(to_add == -1e9 - 7) {\\n            dp[node] = A[node];\\n        }\\n        else {\\n            dp[node] = to_add + A[node];\\n        }\\n        ans = max(ans, dp[node] + prefix);\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& A) {\\n        for(auto P : edges) {\\n            int u = P[0];\\n            int v = P[1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        dfs1(0, -1, 0);\\n        int bob_lite = bob;\\n        int to = d[bob];\\n        to /= 2;\\n        while(to--) {\\n            bob_lite = par[bob_lite];\\n        }\\n        int node = bob;\\n        while(node != bob_lite) {\\n            A[node] = 0;\\n            node = par[node];\\n        }\\n        if(d[bob] % 2 == 0) {\\n            A[node] /= 2;\\n        }\\n        else {\\n            A[node] = 0;\\n        }\\n        ans = -1e9 - 7;\\n        dfs2(0, -1, 0, A);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891508,
                "title": "simple-dfs-easy-to-understand-solution-c",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // Here undirected tree will not be a graph    \\n    unordered_map<int,vector<int>> mp;\\n    int height=0,maxAns=INT_MIN;\\n    \\n    // Calculate Height from node 0 to node Bob\\n    void setHeight(int node,int bob,int h,vector<int>&visited){\\n        if(node==bob){\\n            height=h;\\n            return;\\n        }\\n        visited[node]=true;\\n        for(auto it:mp[node])\\n          if(!visited[it])\\n            setHeight(it,bob,h+1,visited);\\n    }\\n    \\n    bool updateValues(int node,int bob,int&count,bool even,vector<int>& amount,vector<int>&visited){\\n        if(node==bob){\\n           if(count==0){\\n            // if height is even, then we have to update one extra node   \\n              if(even)\\n                amount[node]/=2;\\n            }\\n            else if(count>0){\\n                amount[node]=0;\\n            }\\n            count--;\\n            return true;\\n        }\\n        \\n        visited[node]=true;\\n\\n        for(auto it:mp[node]){\\n            if(!visited[it])\\n            if(updateValues(it,bob,count,even,amount,visited)){\\n                if(count==0){\\n                // if height is even, then we have to update one extra node   \\n                if(even)\\n                      amount[node]/=2;\\n                }\\n                // if count > 0, means that path is covered by bob first, so make them zero\\n                else if(count>0){\\n                    amount[node]=0;\\n                }\\n                count--;\\n               return true; \\n            }    \\n        }\\n        \\n        return false;\\n    }\\n    \\n    // Do simple DFS to determine max path sum from node 0 to leaf nodes\\n    void DFS(int node,int sum,vector<int>& amount,vector<int>&visited){\\n        \\n        // Leaf node and node 0 has vector.size()=1, so add an extra condition of node!=0\\n        int next=mp[node].size();\\n        if((next==1)&&node!=0){\\n            maxAns=max(maxAns,sum);\\n            return;\\n        }\\n        \\n        visited[node]=true;\\n        for(auto it:mp[node]){\\n            if(!visited[it])\\n                DFS(it,sum+amount[it],amount,visited);\\n        }\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        for(auto it:edges){\\n            mp[it[0]].push_back(it[1]);\\n            mp[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<int> visited1(amount.size(),0),visited2(amount.size(),0),visited3(amount.size(),0);\\n        setHeight(0,bob,0,visited1);\\n        int h=(height+1)/2;\\n        \\n        if(height&1)\\n            updateValues(0,bob,h,false,amount,visited2);\\n        else updateValues(0,bob,h,true,amount,visited2);\\n        \\n        DFS(0,amount[0],amount,visited3);\\n        return maxAns;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Here undirected tree will not be a graph    \\n    unordered_map<int,vector<int>> mp;\\n    int height=0,maxAns=INT_MIN;\\n    \\n    // Calculate Height from node 0 to node Bob\\n    void setHeight(int node,int bob,int h,vector<int>&visited){\\n        if(node==bob){\\n            height=h;\\n            return;\\n        }\\n        visited[node]=true;\\n        for(auto it:mp[node])\\n          if(!visited[it])\\n            setHeight(it,bob,h+1,visited);\\n    }\\n    \\n    bool updateValues(int node,int bob,int&count,bool even,vector<int>& amount,vector<int>&visited){\\n        if(node==bob){\\n           if(count==0){\\n            // if height is even, then we have to update one extra node   \\n              if(even)\\n                amount[node]/=2;\\n            }\\n            else if(count>0){\\n                amount[node]=0;\\n            }\\n            count--;\\n            return true;\\n        }\\n        \\n        visited[node]=true;\\n\\n        for(auto it:mp[node]){\\n            if(!visited[it])\\n            if(updateValues(it,bob,count,even,amount,visited)){\\n                if(count==0){\\n                // if height is even, then we have to update one extra node   \\n                if(even)\\n                      amount[node]/=2;\\n                }\\n                // if count > 0, means that path is covered by bob first, so make them zero\\n                else if(count>0){\\n                    amount[node]=0;\\n                }\\n                count--;\\n               return true; \\n            }    \\n        }\\n        \\n        return false;\\n    }\\n    \\n    // Do simple DFS to determine max path sum from node 0 to leaf nodes\\n    void DFS(int node,int sum,vector<int>& amount,vector<int>&visited){\\n        \\n        // Leaf node and node 0 has vector.size()=1, so add an extra condition of node!=0\\n        int next=mp[node].size();\\n        if((next==1)&&node!=0){\\n            maxAns=max(maxAns,sum);\\n            return;\\n        }\\n        \\n        visited[node]=true;\\n        for(auto it:mp[node]){\\n            if(!visited[it])\\n                DFS(it,sum+amount[it],amount,visited);\\n        }\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        for(auto it:edges){\\n            mp[it[0]].push_back(it[1]);\\n            mp[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<int> visited1(amount.size(),0),visited2(amount.size(),0),visited3(amount.size(),0);\\n        setHeight(0,bob,0,visited1);\\n        int h=(height+1)/2;\\n        \\n        if(height&1)\\n            updateValues(0,bob,h,false,amount,visited2);\\n        else updateValues(0,bob,h,true,amount,visited2);\\n        \\n        DFS(0,amount[0],amount,visited3);\\n        return maxAns;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886863,
                "title": "python-detailed-explanation-dfs-backtracking-codeplug",
                "content": "Explained in comments. **Upvote if you liked the solution :)**\\n# Complexity\\n- Time complexity:\\nO(n) since there is not cycle in graph\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```python []\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        adjMat, n = defaultdict(list), len(amount)\\n\\n        for u, v in edges:\\n            adjMat[u].append(v)\\n            adjMat[v].append(u)\\n\\n        bobPath, bobPathVisited = None, set()\\n\\n        def findBobPath(node, currPath): # find shortest bob path to root\\n            currPath.append(node)\\n            bobPathVisited.add(node)\\n            if node == 0:\\n                nonlocal bobPath\\n                if bobPath is None or len(currPath) < bobPath: bobPath = currPath[:]\\n                return\\n\\n            for nei in adjMat[node]:\\n                if nei not in bobPathVisited: findBobPath(nei, currPath)\\n            currPath.pop()\\n\\n        findBobPath(bob, [])\\n        res, visited, bobVisited = -inf, set(), set()\\n\\n        def solveAlice(node, alice, i): # consider i as time, alice is the score accumulated, node is the current node of alice\\n            visited.add(node)\\n\\n            if node > 0 and len(adjMat[node]) == 1:\\n                nonlocal res\\n                if node in bobVisited: pass\\n                elif i < len(bobPath) and bobPath[i] == node: alice += amount[node] // 2\\n                else: alice += amount[node]\\n                res = max(res, alice)\\n                return\\n\\n            if node in bobVisited: pass # if node already visited by bob ignore the amount\\n            elif i < len(bobPath) and bobPath[i] == node: alice += amount[node] // 2 # if at a given time i, both alice and bob are at same node, only add half of amount to alice\\n            else: alice += amount[node] # if node not visited by bob by given time i, add full amount to alice\\n\\n            if i < len(bobPath): bobVisited.add(bobPath[i]) # if i < len(bobPath) means bob has not yet reached the root, so add the node at time i in bobPath to bobVisited\\n\\n            for nei in adjMat[node]:\\n                if nei not in visited: solveAlice(nei, alice, i + 1)\\n\\n            if i < len(bobPath): bobVisited.discard(bobPath[i]) # backtrack bobVisited according to time i\\n\\n        solveAlice(0, 0, 0)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```python []\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        adjMat, n = defaultdict(list), len(amount)\\n\\n        for u, v in edges:\\n            adjMat[u].append(v)\\n            adjMat[v].append(u)\\n\\n        bobPath, bobPathVisited = None, set()\\n\\n        def findBobPath(node, currPath): # find shortest bob path to root\\n            currPath.append(node)\\n            bobPathVisited.add(node)\\n            if node == 0:\\n                nonlocal bobPath\\n                if bobPath is None or len(currPath) < bobPath: bobPath = currPath[:]\\n                return\\n\\n            for nei in adjMat[node]:\\n                if nei not in bobPathVisited: findBobPath(nei, currPath)\\n            currPath.pop()\\n\\n        findBobPath(bob, [])\\n        res, visited, bobVisited = -inf, set(), set()\\n\\n        def solveAlice(node, alice, i): # consider i as time, alice is the score accumulated, node is the current node of alice\\n            visited.add(node)\\n\\n            if node > 0 and len(adjMat[node]) == 1:\\n                nonlocal res\\n                if node in bobVisited: pass\\n                elif i < len(bobPath) and bobPath[i] == node: alice += amount[node] // 2\\n                else: alice += amount[node]\\n                res = max(res, alice)\\n                return\\n\\n            if node in bobVisited: pass # if node already visited by bob ignore the amount\\n            elif i < len(bobPath) and bobPath[i] == node: alice += amount[node] // 2 # if at a given time i, both alice and bob are at same node, only add half of amount to alice\\n            else: alice += amount[node] # if node not visited by bob by given time i, add full amount to alice\\n\\n            if i < len(bobPath): bobVisited.add(bobPath[i]) # if i < len(bobPath) means bob has not yet reached the root, so add the node at time i in bobPath to bobVisited\\n\\n            for nei in adjMat[node]:\\n                if nei not in visited: solveAlice(nei, alice, i + 1)\\n\\n            if i < len(bobPath): bobVisited.discard(bobPath[i]) # backtrack bobVisited according to time i\\n\\n        solveAlice(0, 0, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885871,
                "title": "find-bob-s-path-and-check-all-alice-paths-with-bfs",
                "content": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def bfs(self, graph, root, parent):\\n        q = deque([root])\\n        v = {root}\\n        while len(q) > 0:\\n            curr = q.pop()\\n            for j in graph[curr]:\\n                if j not in v:\\n                    v.add(j)\\n                    parent[j] = curr\\n                    q.appendleft(j)\\n    \\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = len(amount)\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        parent = {}\\n        self.bfs(graph, bob, parent)\\n        curr = 0\\n        path = [curr]\\n        while curr in parent:\\n            curr = parent[curr]\\n            path.append(curr)\\n        path.reverse()\\n        exists = [0]\\n        for i in range(len(path) - 1):\\n            exists.append(exists[-1])\\n            exists[-1] |= 1 << path[i]\\n        q = deque([(0, 0, 0)])\\n        v = {0}\\n        res = float(\\'-inf\\')\\n        while len(q) > 0:\\n            curr, t, cost = q.pop()\\n            c = amount[curr]\\n            if t < len(path):\\n                if path[t] == curr:\\n                    c //= 2\\n                elif exists[t] & (1 << curr):\\n                    c = 0\\n            if len(graph[curr]) == 1 and curr != 0:\\n                res = max(res, cost + c)\\n            for j in graph[curr]:\\n                if j not in v:\\n                    v.add(j)\\n                    q.appendleft((j, t + 1, cost + c))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def bfs(self, graph, root, parent):\\n        q = deque([root])\\n        v = {root}\\n        while len(q) > 0:\\n            curr = q.pop()\\n            for j in graph[curr]:\\n                if j not in v:\\n                    v.add(j)\\n                    parent[j] = curr\\n                    q.appendleft(j)\\n    \\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = len(amount)\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        parent = {}\\n        self.bfs(graph, bob, parent)\\n        curr = 0\\n        path = [curr]\\n        while curr in parent:\\n            curr = parent[curr]\\n            path.append(curr)\\n        path.reverse()\\n        exists = [0]\\n        for i in range(len(path) - 1):\\n            exists.append(exists[-1])\\n            exists[-1] |= 1 << path[i]\\n        q = deque([(0, 0, 0)])\\n        v = {0}\\n        res = float(\\'-inf\\')\\n        while len(q) > 0:\\n            curr, t, cost = q.pop()\\n            c = amount[curr]\\n            if t < len(path):\\n                if path[t] == curr:\\n                    c //= 2\\n                elif exists[t] & (1 << curr):\\n                    c = 0\\n            if len(graph[curr]) == 1 and curr != 0:\\n                res = max(res, cost + c)\\n            for j in graph[curr]:\\n                if j not in v:\\n                    v.add(j)\\n                    q.appendleft((j, t + 1, cost + c))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874572,
                "title": "dfs-c",
                "content": "\\n\\n# Approach\\nDFS\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n          int n = edges.size()+1;\\n          vector<vector<int>> graph(n);\\n          for(vector<int>& edge: edges){\\n              graph[edge[0]].push_back(edge[1]);\\n              graph[edge[1]].push_back(edge[0]);\\n          }\\n\\n         vector<int> path_bob;\\n         findPathToBob(path_bob, 0, -1, graph, bob);\\n         int mid = path_bob.size()/2;\\n         for(int i=path_bob.size()-1;i>=mid;i--){\\n              if(i>mid){\\n                amount[path_bob[i]] = 0;\\n              }else if(i==mid){\\n                  if(path_bob.size()%2==0){\\n                      amount[path_bob[mid]] = 0;\\n                  }else{\\n                      amount[path_bob[mid]] = amount[path_bob[mid]]/2;\\n                  }\\n              }\\n\\n         }\\n\\n        return findMaxProf(graph, 0, -1, amount);\\n    }\\n    \\n    int findMaxProf(vector<vector<int>>& graph, int cur, int parent, vector<int>& amount){\\n        int res = INT_MIN;\\n\\n        for(auto& child: graph[cur]){\\n            if(child != parent){\\n                int temp = findMaxProf(graph, child, cur, amount);\\n                temp += amount[cur];\\n                res = max(temp, res);\\n            }\\n        }\\n\\n        if(res == INT_MIN){\\n            return amount[cur];\\n        }\\n\\n        return res;\\n\\n    }\\n\\n    bool findPathToBob(vector<int>& path, int cur_node, int parent, vector<vector<int>>& graph, int bob){\\n             path.push_back(cur_node);\\n\\n             if(cur_node == bob){\\n                 return true;\\n             }\\n             \\n\\n             for(auto& child: graph[cur_node]){\\n                 if(child != parent){\\n                     bool check = findPathToBob(path, child, cur_node, graph, bob);\\n                     if(check){\\n                         return true;\\n                     }\\n                 }\\n             }\\n             \\n             path.pop_back();\\n             return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n          int n = edges.size()+1;\\n          vector<vector<int>> graph(n);\\n          for(vector<int>& edge: edges){\\n              graph[edge[0]].push_back(edge[1]);\\n              graph[edge[1]].push_back(edge[0]);\\n          }\\n\\n         vector<int> path_bob;\\n         findPathToBob(path_bob, 0, -1, graph, bob);\\n         int mid = path_bob.size()/2;\\n         for(int i=path_bob.size()-1;i>=mid;i--){\\n              if(i>mid){\\n                amount[path_bob[i]] = 0;\\n              }else if(i==mid){\\n                  if(path_bob.size()%2==0){\\n                      amount[path_bob[mid]] = 0;\\n                  }else{\\n                      amount[path_bob[mid]] = amount[path_bob[mid]]/2;\\n                  }\\n              }\\n\\n         }\\n\\n        return findMaxProf(graph, 0, -1, amount);\\n    }\\n    \\n    int findMaxProf(vector<vector<int>>& graph, int cur, int parent, vector<int>& amount){\\n        int res = INT_MIN;\\n\\n        for(auto& child: graph[cur]){\\n            if(child != parent){\\n                int temp = findMaxProf(graph, child, cur, amount);\\n                temp += amount[cur];\\n                res = max(temp, res);\\n            }\\n        }\\n\\n        if(res == INT_MIN){\\n            return amount[cur];\\n        }\\n\\n        return res;\\n\\n    }\\n\\n    bool findPathToBob(vector<int>& path, int cur_node, int parent, vector<vector<int>>& graph, int bob){\\n             path.push_back(cur_node);\\n\\n             if(cur_node == bob){\\n                 return true;\\n             }\\n             \\n\\n             for(auto& child: graph[cur_node]){\\n                 if(child != parent){\\n                     bool check = findPathToBob(path, child, cur_node, graph, bob);\\n                     if(check){\\n                         return true;\\n                     }\\n                 }\\n             }\\n             \\n             path.pop_back();\\n             return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872126,
                "title": "java-easy-solution-commented-code",
                "content": "```\\nclass Solution {\\n    HashMap<Integer,ArrayList<Integer>> graph;\\n    int max = Integer.MIN_VALUE;\\n    ArrayList<Integer> path = new ArrayList<>();\\n    \\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        graph = new HashMap<>();\\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[0], x -> new ArrayList<>()).add(e[1]);\\n            graph.computeIfAbsent(e[1], x -> new ArrayList<>()).add(e[0]);\\n        }\\n        \\n        //step 1 find the path from bob to 0\\n        path(bob , 0, new ArrayList<>(){{add(bob);}}, new HashSet<>(){{add(bob);}});\\n        \\n        //now we have the path starting from bob as bob will also start with alice bob will reach before the mid element , and will have all the profit so make them 0 as alice can\\'t have it\\n        for(int i = 0; i < path.size() / 2; i++)\\n            amount[path.get(i)] = 0;\\n        \\n        //now there might be the case that in path there are even or odd elements if odd then the mid will be divided among bob and alice so make it half if odd only\\n        if(path.size() % 2 != 0)\\n            amount[path.get(path.size() / 2)] /= 2;\\n        \\n        //now we have preprocessed bob to alice path now just do dfs for alice to get the ans\\n        DFS(0, amount, new HashSet<>(){{ add(0); }}, amount[0]);\\n        return max;\\n    }\\n    \\n    //1. method to find the path from BOB to ALICE(0)\\n    public boolean path(int current , int target, ArrayList<Integer> route, HashSet<Integer> visited){\\n        //if we reach from bob to alice posn i.e is 0 record the path\\n        if(current == target){\\n            path = new ArrayList<>(route);\\n            return true;\\n        }\\n        \\n        for(int nbr : graph.getOrDefault(current, new ArrayList<>())){\\n            if(visited.contains(nbr))\\n                continue;\\n            route.add(nbr);\\n            visited.add(nbr);\\n            \\n            //path found then return from here only\\n            if(path(nbr, target, route, visited) == true)\\n                return true;\\n            \\n            //backtrack if path not found\\n            visited.remove(nbr);\\n            route.remove(route.size() - 1);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    //2. method to traverse from alice to leaf and find the max profit possible\\n    public void DFS(int current, int[] amount, HashSet<Integer> visited, int profit){\\n        boolean leaf = true;\\n        \\n        for(int nbr : graph.getOrDefault(current, new ArrayList<>())){\\n            if(visited.contains(nbr) == true)\\n                continue;\\n            \\n            //as not visited so current is not leaf\\n            leaf = false;\\n            visited.add(nbr);\\n            DFS(nbr, amount, visited, profit + amount[nbr]);\\n        }\\n        \\n        if(leaf)\\n            max = Math.max(max, profit);\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    //Doesn\\'t work this way\\n    public int mostProfitablePath__(int[][] edges, int bob, int[] amount) {\\n        graph = new HashMap<>();\\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[0], x -> new ArrayList<>()).add(e[1]);\\n            graph.computeIfAbsent(e[1], x -> new ArrayList<>()).add(e[0]);\\n        }\\n        \\n        HashSet<Integer> visited = new HashSet<>();\\n        solve(0, amount[0], amount, 0 == bob, bob, visited);\\n        return max; \\n    }\\n    \\n    void solve(int node,int curr,int[] amount, boolean bob, int bobs, HashSet<Integer> set){\\n        if(set.contains(node))\\n            return;\\n        set.add(node);\\n        boolean done = true;\\n        bob = (node == bobs);\\n        System.out.println(node + \" \" + bob + \" \" + curr);\\n        for(int nbr : graph.getOrDefault(node, new ArrayList<>())){\\n            if(set.contains(nbr) == false){\\n                done = false;\\n                if(bob){\\n                    if(amount[node] < 0){\\n                        curr -= (amount[nbr] / 2);\\n                    }else{\\n                        curr += (amount[nbr] / 2);\\n                    }\\n                }else{\\n                    curr += amount[nbr];\\n                }\\n                solve(nbr, curr, amount, bob, bobs, set);\\n            }\\n        }\\n        \\n        if(done){\\n            max = Math.max(max, curr);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,ArrayList<Integer>> graph;\\n    int max = Integer.MIN_VALUE;\\n    ArrayList<Integer> path = new ArrayList<>();\\n    \\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        graph = new HashMap<>();\\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[0], x -> new ArrayList<>()).add(e[1]);\\n            graph.computeIfAbsent(e[1], x -> new ArrayList<>()).add(e[0]);\\n        }\\n        \\n        //step 1 find the path from bob to 0\\n        path(bob , 0, new ArrayList<>(){{add(bob);}}, new HashSet<>(){{add(bob);}});\\n        \\n        //now we have the path starting from bob as bob will also start with alice bob will reach before the mid element , and will have all the profit so make them 0 as alice can\\'t have it\\n        for(int i = 0; i < path.size() / 2; i++)\\n            amount[path.get(i)] = 0;\\n        \\n        //now there might be the case that in path there are even or odd elements if odd then the mid will be divided among bob and alice so make it half if odd only\\n        if(path.size() % 2 != 0)\\n            amount[path.get(path.size() / 2)] /= 2;\\n        \\n        //now we have preprocessed bob to alice path now just do dfs for alice to get the ans\\n        DFS(0, amount, new HashSet<>(){{ add(0); }}, amount[0]);\\n        return max;\\n    }\\n    \\n    //1. method to find the path from BOB to ALICE(0)\\n    public boolean path(int current , int target, ArrayList<Integer> route, HashSet<Integer> visited){\\n        //if we reach from bob to alice posn i.e is 0 record the path\\n        if(current == target){\\n            path = new ArrayList<>(route);\\n            return true;\\n        }\\n        \\n        for(int nbr : graph.getOrDefault(current, new ArrayList<>())){\\n            if(visited.contains(nbr))\\n                continue;\\n            route.add(nbr);\\n            visited.add(nbr);\\n            \\n            //path found then return from here only\\n            if(path(nbr, target, route, visited) == true)\\n                return true;\\n            \\n            //backtrack if path not found\\n            visited.remove(nbr);\\n            route.remove(route.size() - 1);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    //2. method to traverse from alice to leaf and find the max profit possible\\n    public void DFS(int current, int[] amount, HashSet<Integer> visited, int profit){\\n        boolean leaf = true;\\n        \\n        for(int nbr : graph.getOrDefault(current, new ArrayList<>())){\\n            if(visited.contains(nbr) == true)\\n                continue;\\n            \\n            //as not visited so current is not leaf\\n            leaf = false;\\n            visited.add(nbr);\\n            DFS(nbr, amount, visited, profit + amount[nbr]);\\n        }\\n        \\n        if(leaf)\\n            max = Math.max(max, profit);\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    //Doesn\\'t work this way\\n    public int mostProfitablePath__(int[][] edges, int bob, int[] amount) {\\n        graph = new HashMap<>();\\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[0], x -> new ArrayList<>()).add(e[1]);\\n            graph.computeIfAbsent(e[1], x -> new ArrayList<>()).add(e[0]);\\n        }\\n        \\n        HashSet<Integer> visited = new HashSet<>();\\n        solve(0, amount[0], amount, 0 == bob, bob, visited);\\n        return max; \\n    }\\n    \\n    void solve(int node,int curr,int[] amount, boolean bob, int bobs, HashSet<Integer> set){\\n        if(set.contains(node))\\n            return;\\n        set.add(node);\\n        boolean done = true;\\n        bob = (node == bobs);\\n        System.out.println(node + \" \" + bob + \" \" + curr);\\n        for(int nbr : graph.getOrDefault(node, new ArrayList<>())){\\n            if(set.contains(nbr) == false){\\n                done = false;\\n                if(bob){\\n                    if(amount[node] < 0){\\n                        curr -= (amount[nbr] / 2);\\n                    }else{\\n                        curr += (amount[nbr] / 2);\\n                    }\\n                }else{\\n                    curr += amount[nbr];\\n                }\\n                solve(nbr, curr, amount, bob, bobs, set);\\n            }\\n        }\\n        \\n        if(done){\\n            max = Math.max(max, curr);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856525,
                "title": "c-code-for-beginners-2-dfs-approach",
                "content": "```\\nclass Solution {\\nprivate:\\n    list<int>* adj;\\n    vector<int> parent,time;\\npublic:\\n    void dfs(int node){\\n        for(auto nei: adj[node]){\\n            if(nei!=parent[node]){\\n                parent[nei]=node;\\n                dfs(nei);\\n            }\\n        }\\n    }\\n    \\n    int helper(int node, vector<int> &amount, int t){\\n        int res=INT_MIN;\\n        int temp=0;\\n        if(time[node]==t){  // Alice and bob reached in same time\\n            temp=amount[node]/2;\\n        }\\n        else if(time[node]>t){  // alice reached here earlier than bob \\n            temp=amount[node];\\n        }\\n        if(adj[node].size()==1 && parent[node]==*adj[node].begin()){  // leaf node condition\\n            return temp;\\n        }\\n        for(auto nei: adj[node]){\\n            if(nei!=parent[node]){\\n                res=max(res,temp+helper(nei,amount,t+1));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        adj=new list<int>[n];\\n        parent.resize(n,-1);\\n        for(auto edge: edges){  \\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        dfs(0);\\n        time.resize(n,INT_MAX);\\n        int node=bob;\\n        int t=0;\\n        while(node!=-1){ // using the parent array, mark the time it took for bob to reach at each node in his path back to 0\\n            time[node]=t++;\\n            node=parent[node];\\n        }\\n        return helper(0,amount,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    list<int>* adj;\\n    vector<int> parent,time;\\npublic:\\n    void dfs(int node){\\n        for(auto nei: adj[node]){\\n            if(nei!=parent[node]){\\n                parent[nei]=node;\\n                dfs(nei);\\n            }\\n        }\\n    }\\n    \\n    int helper(int node, vector<int> &amount, int t){\\n        int res=INT_MIN;\\n        int temp=0;\\n        if(time[node]==t){  // Alice and bob reached in same time\\n            temp=amount[node]/2;\\n        }\\n        else if(time[node]>t){  // alice reached here earlier than bob \\n            temp=amount[node];\\n        }\\n        if(adj[node].size()==1 && parent[node]==*adj[node].begin()){  // leaf node condition\\n            return temp;\\n        }\\n        for(auto nei: adj[node]){\\n            if(nei!=parent[node]){\\n                res=max(res,temp+helper(nei,amount,t+1));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=amount.size();\\n        adj=new list<int>[n];\\n        parent.resize(n,-1);\\n        for(auto edge: edges){  \\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        dfs(0);\\n        time.resize(n,INT_MAX);\\n        int node=bob;\\n        int t=0;\\n        while(node!=-1){ // using the parent array, mark the time it took for bob to reach at each node in his path back to 0\\n            time[node]=t++;\\n            node=parent[node];\\n        }\\n        return helper(0,amount,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851277,
                "title": "c-one-dfs",
                "content": "The idea is return bobs steps from the internal dfs: \\n\\n```\\npublic class Solution {\\n    Dictionary<int, List<int>> graph = new();\\n    bool[] visited;\\n    \\n    public int MostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        foreach(var edge in edges){\\n            graph.TryAdd(edge[0], new List<int>());\\n            graph.TryAdd(edge[1], new List<int>());\\n            \\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n        \\n        visited = new bool[amount.Length];\\n        var result = DFS(0, 1, bob, amount);\\n        \\n        return result[0];\\n    }\\n    \\n    private int[] DFS(int node, int steps,  int bobNode, int[] amount){     \\n        long cost = Int64.MinValue;\\n        int bobsSteps = 0;\\n        visited[node] = true;\\n        \\n        if(graph.ContainsKey(node)){\\n            foreach(int child in graph[node]){\\n                if(visited[child])\\n                    continue;\\n                \\n                var childResult =  DFS(child, steps +1, bobNode, amount);\\n                cost = Math.Max(cost, childResult[0]);\\n                bobsSteps = Math.Max(bobsSteps, childResult[1]);\\n                \\n            }\\n        }\\n        cost = cost == Int64.MinValue ?  0 : cost;\\n        \\n        if(bobsSteps == 0 && bobNode == node)\\n            bobsSteps = 1;\\n        \\n        int currCost = 0;\\n        \\n        if(bobsSteps == 0 || (steps < bobsSteps))\\n            currCost = amount[node];\\n        else if(steps == bobsSteps)\\n            currCost = amount[node]/2; \\n        \\n       // Console.WriteLine($\" at node {node}- steps: {steps}, bobsSteps: {bobsSteps}, cost {cost} , currentCost {currCost}/{amount[node]} \");\\n        return new int[]{(int)(currCost + cost), bobsSteps == 0 ? 0 : bobsSteps + 1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    Dictionary<int, List<int>> graph = new();\\n    bool[] visited;\\n    \\n    public int MostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        foreach(var edge in edges){\\n            graph.TryAdd(edge[0], new List<int>());\\n            graph.TryAdd(edge[1], new List<int>());\\n            \\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n        \\n        visited = new bool[amount.Length];\\n        var result = DFS(0, 1, bob, amount);\\n        \\n        return result[0];\\n    }\\n    \\n    private int[] DFS(int node, int steps,  int bobNode, int[] amount){     \\n        long cost = Int64.MinValue;\\n        int bobsSteps = 0;\\n        visited[node] = true;\\n        \\n        if(graph.ContainsKey(node)){\\n            foreach(int child in graph[node]){\\n                if(visited[child])\\n                    continue;\\n                \\n                var childResult =  DFS(child, steps +1, bobNode, amount);\\n                cost = Math.Max(cost, childResult[0]);\\n                bobsSteps = Math.Max(bobsSteps, childResult[1]);\\n                \\n            }\\n        }\\n        cost = cost == Int64.MinValue ?  0 : cost;\\n        \\n        if(bobsSteps == 0 && bobNode == node)\\n            bobsSteps = 1;\\n        \\n        int currCost = 0;\\n        \\n        if(bobsSteps == 0 || (steps < bobsSteps))\\n            currCost = amount[node];\\n        else if(steps == bobsSteps)\\n            currCost = amount[node]/2; \\n        \\n       // Console.WriteLine($\" at node {node}- steps: {steps}, bobsSteps: {bobsSteps}, cost {cost} , currentCost {currCost}/{amount[node]} \");\\n        return new int[]{(int)(currCost + cost), bobsSteps == 0 ? 0 : bobsSteps + 1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850247,
                "title": "my-ugly-python3-solution-but-pretty-much-efficient",
                "content": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(lambda:[])\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        visited = set()\\n        def bp(b):\\n            stack.append(b)\\n            # print(stack)\\n            if b == 0:\\n                # print(stack)\\n                return stack\\n            visited.add(b)\\n            for i in graph[b]:\\n                if i not in visited:\\n                    t = bp(i)\\n                    if t:\\n                        return t\\n            visited.remove(b)\\n            stack.pop()\\n            \\n         \\n        stack = []\\n        S=bp(bob)\\n        # print(S)\\n        blen = len(S)-1\\n        gate = [0]*(len(edges)+1)\\n        visited=set()\\n        self.income = float(\\'-inf\\')\\n        def dfs(alice, b, net):\\n            if len(graph[alice]) == 1 and graph[alice][0] in visited:\\n                self.income = max(self.income,net)\\n            \\n            visited.add(alice)   \\n            for n in graph[alice]:\\n                if n in visited:continue\\n                gate[S[min(b+1,blen)]] = 1\\n                if n == S[min(b+1,blen)]:\\n                    \\n                    dfs(n,min(b+1,blen),net + (amount[n]/2))\\n                else:\\n                    if gate[n]:\\n                        # print(net,n)\\n                        dfs(n,min(b+1,blen),net)\\n                    else:\\n                        # print(net,n)\\n                        dfs(n,min(b+1,blen),net + amount[n])\\n                gate[S[min(b+1,blen)]] = 0\\n            \\n            \\n        gate[bob] = 1   \\n        dfs(0,0,amount[0])\\n        \\n        return int(self.income)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        graph = defaultdict(lambda:[])\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        visited = set()\\n        def bp(b):\\n            stack.append(b)\\n            # print(stack)\\n            if b == 0:\\n                # print(stack)\\n                return stack\\n            visited.add(b)\\n            for i in graph[b]:\\n                if i not in visited:\\n                    t = bp(i)\\n                    if t:\\n                        return t\\n            visited.remove(b)\\n            stack.pop()\\n            \\n         \\n        stack = []\\n        S=bp(bob)\\n        # print(S)\\n        blen = len(S)-1\\n        gate = [0]*(len(edges)+1)\\n        visited=set()\\n        self.income = float(\\'-inf\\')\\n        def dfs(alice, b, net):\\n            if len(graph[alice]) == 1 and graph[alice][0] in visited:\\n                self.income = max(self.income,net)\\n            \\n            visited.add(alice)   \\n            for n in graph[alice]:\\n                if n in visited:continue\\n                gate[S[min(b+1,blen)]] = 1\\n                if n == S[min(b+1,blen)]:\\n                    \\n                    dfs(n,min(b+1,blen),net + (amount[n]/2))\\n                else:\\n                    if gate[n]:\\n                        # print(net,n)\\n                        dfs(n,min(b+1,blen),net)\\n                    else:\\n                        # print(net,n)\\n                        dfs(n,min(b+1,blen),net + amount[n])\\n                gate[S[min(b+1,blen)]] = 0\\n            \\n            \\n        gate[bob] = 1   \\n        dfs(0,0,amount[0])\\n        \\n        return int(self.income)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848890,
                "title": "2-dfs-easy-explanation",
                "content": "there are few points in this problem, \\n1- bob only has ONE path to the node-ZERO. means there are some nodes in his path never reach to. \\n2- to find out which node is leaf for alice, I said if the node has only one adjacent and the adj is already visited, means that was the parent and the node has no more connected node, so it is leaf. \\n3- we dont know which leaf gives the best net to Alice, so we have to try the whole tree for her too. \\n\\n**The algorithm**\\nI started from bob, and run a DFS to reach to node-ZERO. we have one vector for each person, which stores the level they can get to each node. \\n\\nThe reason I keep this levels is to see which player can reach to a node earlier and take the amount.  \\nIf Bob reach to end of a route and has not seen the node_ZERO, I will set the vb as -1. means bob will never reach to here. When bob reaches to node_ZERO, a bobDone becomes true, means the rest of journey is not necessary. \\n\\nThe Second DFS we run for Alice. for each node, we compare the level with VB, the bob DFS vector, for example if both are same means they can reach to node \\'n\\' at the same time. \\n\\nIf Alice reach to leaf , we update the MaxNet. \\n\\n```\\nbool bobDone;\\nint net;\\nvector<vector<int>> adj;\\nvoid dfsBob(int node, int level, vector<int>& vb, vector<bool>& visit)\\n{\\n\\tvb[node] = level;\\n\\tvisit[node] = true;\\n\\tif (node == 0)\\n\\t{\\n\\t\\tbobDone = true;  return;\\n\\t}\\n\\t\\n\\tfor (auto& x : adj[node])\\n\\t\\tif (visit[x] == false && bobDone == false)\\n\\t\\t\\tdfsBob(x, level + 1, vb, visit);\\n\\tif (bobDone == false)\\n\\t\\tvb[node] = -1;\\n}\\n\\n// cur = current amount that alice takes to this node \\nvoid dfsAlice(int cur, int node, int level, vector<int>& va, vector<int>& vb, vector<bool>& visit, vector<int>& amount)\\n{\\n\\tvisit[node] = true;\\n\\tif (vb[node] < level && vb[node] != -1)\\n\\t\\tva[node] = cur;\\n\\telse if (vb[node] == level)\\n\\t\\tva[node] = cur + amount[node] / 2;\\n\\telse if (vb[node] > level || vb[node] ==-1)\\n\\t\\tva[node] = cur + amount[node];\\n\\n\\tif (adj[node].size() == 1 && visit[adj[node][0]] == true) // means this is leaf and we have to update the best net income\\n\\t{\\n\\t\\tnet = max(net, va[node]);  return;\\n\\t}\\n\\n\\tfor (auto& x : adj[node])\\n\\t\\tif (visit[x] == false)\\n\\t\\t\\tdfsAlice(va[node], x, level + 1, va, vb, visit, amount);\\n}\\n\\nint mostProfitablePath(vector<vector<int>>& ed, int bob, vector<int>& amount)\\n{\\n\\tint n = ed.size() + 1;\\n\\tadj.resize(n, vector<int>());\\n\\tvector<int> vb(n, -1), va(n, 0);\\n\\tvector<bool> visit(n, false);\\n\\tbobDone = false;\\n\\tnet = INT_MIN;\\n\\tfor (int i = 0; i < ed.size(); i++)\\n\\t\\tadj[ed[i][0]].push_back(ed[i][1]) , adj[ed[i][1]].push_back(ed[i][0]);\\n\\n\\tdfsBob(bob, 0, vb, visit);\\n\\tvisit.clear();\\n\\tvisit.resize(n, false);\\n\\tdfsAlice(0, 0, 0, va, vb, visit, amount);\\n\\n\\treturn net;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool bobDone;\\nint net;\\nvector<vector<int>> adj;\\nvoid dfsBob(int node, int level, vector<int>& vb, vector<bool>& visit)\\n{\\n\\tvb[node] = level;\\n\\tvisit[node] = true;\\n\\tif (node == 0)\\n\\t{\\n\\t\\tbobDone = true;  return;\\n\\t}\\n\\t\\n\\tfor (auto& x : adj[node])\\n\\t\\tif (visit[x] == false && bobDone == false)\\n\\t\\t\\tdfsBob(x, level + 1, vb, visit);\\n\\tif (bobDone == false)\\n\\t\\tvb[node] = -1;\\n}\\n\\n// cur = current amount that alice takes to this node \\nvoid dfsAlice(int cur, int node, int level, vector<int>& va, vector<int>& vb, vector<bool>& visit, vector<int>& amount)\\n{\\n\\tvisit[node] = true;\\n\\tif (vb[node] < level && vb[node] != -1)\\n\\t\\tva[node] = cur;\\n\\telse if (vb[node] == level)\\n\\t\\tva[node] = cur + amount[node] / 2;\\n\\telse if (vb[node] > level || vb[node] ==-1)\\n\\t\\tva[node] = cur + amount[node];\\n\\n\\tif (adj[node].size() == 1 && visit[adj[node][0]] == true) // means this is leaf and we have to update the best net income\\n\\t{\\n\\t\\tnet = max(net, va[node]);  return;\\n\\t}\\n\\n\\tfor (auto& x : adj[node])\\n\\t\\tif (visit[x] == false)\\n\\t\\t\\tdfsAlice(va[node], x, level + 1, va, vb, visit, amount);\\n}\\n\\nint mostProfitablePath(vector<vector<int>>& ed, int bob, vector<int>& amount)\\n{\\n\\tint n = ed.size() + 1;\\n\\tadj.resize(n, vector<int>());\\n\\tvector<int> vb(n, -1), va(n, 0);\\n\\tvector<bool> visit(n, false);\\n\\tbobDone = false;\\n\\tnet = INT_MIN;\\n\\tfor (int i = 0; i < ed.size(); i++)\\n\\t\\tadj[ed[i][0]].push_back(ed[i][1]) , adj[ed[i][1]].push_back(ed[i][0]);\\n\\n\\tdfsBob(bob, 0, vb, visit);\\n\\tvisit.clear();\\n\\tvisit.resize(n, false);\\n\\tdfsAlice(0, 0, 0, va, vb, visit, amount);\\n\\n\\treturn net;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2846440,
                "title": "c-simple-two-pass-dfs-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        // Initialization\\n        int n = amount.size();\\n        tree.resize(n);\\n        build_tree(edges);\\n        a = & amount;\\n        \\n        // Adjust amount by traversing bob to tree root\\n        int depth = -1;\\n        bob_dfs(0, 0, -1, bob);\\n        \\n        // Traversing Alice from root to leaves\\n        int res = INT_MIN;\\n        alice_dfs(0, -1, 0, res);\\n        return res;\\n    }\\n    \\n    int bob_dfs(int id, int cur_depth, int par, int bob) {\\n        // current node is bob\\n        if (id == bob) {\\n            (*a)[id] = 0;\\n            return cur_depth;\\n        }\\n        // current node is not bob\\n        int depth = -1;\\n        for (int &k : tree[id]) {\\n            if (k == par) {\\n                continue;\\n            }\\n            depth = bob_dfs(k, cur_depth+1, id, bob);\\n            if (depth != -1) {\\n                // if current node is exactly the midpoint of the path\\n                // then divide the reward/cost by 2\\n                // else if current node is between the midpoint\\n                // and the starting point of bob, set the cost to 0\\n                if (cur_depth == depth/2 && depth % 2 == 0) {\\n                   (*a)[id]/=2; \\n                } else if (cur_depth > depth/2) {\\n                   (*a)[id]=0;\\n                }\\n                return depth;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    void alice_dfs(int id, int par, int cur, int& res) {\\n        cur += (*a)[id];\\n        if (tree[id].size() == 1 && tree[id][0] == par) {\\n            // if current node is a leaf, then update\\n            // the result by maximizing reward\\n            res = max(res, cur);\\n            return;\\n        }\\n        for (int i: tree[id]) {\\n            if (i == par) {continue;}\\n            alice_dfs(i, id, cur, res);\\n        }\\n    }\\n    \\n    void build_tree(vector<vector<int>>& edges) {\\n        for (auto & v: edges) {\\n            tree[v[0]].push_back(v[1]);\\n            tree[v[1]].push_back(v[0]);\\n        }\\n    }\\n    \\n    vector<vector<int>> tree;\\n    vector<int> * a;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        // Initialization\\n        int n = amount.size();\\n        tree.resize(n);\\n        build_tree(edges);\\n        a = & amount;\\n        \\n        // Adjust amount by traversing bob to tree root\\n        int depth = -1;\\n        bob_dfs(0, 0, -1, bob);\\n        \\n        // Traversing Alice from root to leaves\\n        int res = INT_MIN;\\n        alice_dfs(0, -1, 0, res);\\n        return res;\\n    }\\n    \\n    int bob_dfs(int id, int cur_depth, int par, int bob) {\\n        // current node is bob\\n        if (id == bob) {\\n            (*a)[id] = 0;\\n            return cur_depth;\\n        }\\n        // current node is not bob\\n        int depth = -1;\\n        for (int &k : tree[id]) {\\n            if (k == par) {\\n                continue;\\n            }\\n            depth = bob_dfs(k, cur_depth+1, id, bob);\\n            if (depth != -1) {\\n                // if current node is exactly the midpoint of the path\\n                // then divide the reward/cost by 2\\n                // else if current node is between the midpoint\\n                // and the starting point of bob, set the cost to 0\\n                if (cur_depth == depth/2 && depth % 2 == 0) {\\n                   (*a)[id]/=2; \\n                } else if (cur_depth > depth/2) {\\n                   (*a)[id]=0;\\n                }\\n                return depth;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    void alice_dfs(int id, int par, int cur, int& res) {\\n        cur += (*a)[id];\\n        if (tree[id].size() == 1 && tree[id][0] == par) {\\n            // if current node is a leaf, then update\\n            // the result by maximizing reward\\n            res = max(res, cur);\\n            return;\\n        }\\n        for (int i: tree[id]) {\\n            if (i == par) {continue;}\\n            alice_dfs(i, id, cur, res);\\n        }\\n    }\\n    \\n    void build_tree(vector<vector<int>>& edges) {\\n        for (auto & v: edges) {\\n            tree[v[0]].push_back(v[1]);\\n            tree[v[1]].push_back(v[0]);\\n        }\\n    }\\n    \\n    vector<vector<int>> tree;\\n    vector<int> * a;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844708,
                "title": "python-two-passes",
                "content": "```\\nimport collections\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n\\t    # situation\\n        # 1) bob moves to 0 (fixed path)\\n        # 2) alice moves to some leaf node (there are K paths for alice, K = count of leaf nodes)\\n        \\n\\t\\t# approach\\n        # 1) calculate bob\\'s path first\\n        # 2) calculate when each node is opened by bob        \\n        # 3) then move alice along each path\\n\\n        n = len(edges) + 1\\n        def build_graph():\\n            graph = collections.defaultdict(list)\\n            for a, b in edges:\\n                graph[a].append(b)\\n                graph[b].append(a)\\n            return graph\\n        \\n        graph = build_graph()\\n\\n        track = [bob]\\n        bob_path = None\\n        def move_bob(node, prev):\\n            nonlocal bob_path\\n            if bob_path:\\n                return\\n            if node == 0:\\n                bob_path = track[:]\\n                return\\n            for nxt in graph[node]:\\n                if nxt == prev:\\n                    continue\\n                track.append(nxt)\\n                move_bob(nxt, node)\\n                track.pop()\\n        move_bob(bob, -1)\\n\\n        bob_opening = [float(\\'inf\\')] * n # when each node is opened by bob\\n        for i, node in enumerate(bob_path):\\n            bob_opening[node] = i\\n\\n        max_income = -float(\\'inf\\')\\n        def move_alice():\\n            nonlocal max_income\\n            # dfs to find the max income\\n            queue = [(0, -1, 0, 0)] # node, prev, second, income\\n            while queue:\\n                node, prev, second, income = queue.pop()\\n                # calculate the reward or cost\\n                if bob_opening[node] > second:\\n                    income += amount[node]\\n                elif bob_opening[node] == second:\\n                    income += amount[node] // 2\\n    \\n                if second > 0 and len(graph[node]) == 1: # leaf node\\n                    max_income = max(max_income, income)\\n                    continue\\n\\n                for nxt in graph[node]:\\n                    if nxt == prev:\\n                        continue\\n                    queue.append((nxt, node, second + 1, income))\\n        move_alice()\\n        return max_income\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n\\t    # situation\\n        # 1) bob moves to 0 (fixed path)\\n        # 2) alice moves to some leaf node (there are K paths for alice, K = count of leaf nodes)\\n        \\n\\t\\t# approach\\n        # 1) calculate bob\\'s path first\\n        # 2) calculate when each node is opened by bob        \\n        # 3) then move alice along each path\\n\\n        n = len(edges) + 1\\n        def build_graph():\\n            graph = collections.defaultdict(list)\\n            for a, b in edges:\\n                graph[a].append(b)\\n                graph[b].append(a)\\n            return graph\\n        \\n        graph = build_graph()\\n\\n        track = [bob]\\n        bob_path = None\\n        def move_bob(node, prev):\\n            nonlocal bob_path\\n            if bob_path:\\n                return\\n            if node == 0:\\n                bob_path = track[:]\\n                return\\n            for nxt in graph[node]:\\n                if nxt == prev:\\n                    continue\\n                track.append(nxt)\\n                move_bob(nxt, node)\\n                track.pop()\\n        move_bob(bob, -1)\\n\\n        bob_opening = [float(\\'inf\\')] * n # when each node is opened by bob\\n        for i, node in enumerate(bob_path):\\n            bob_opening[node] = i\\n\\n        max_income = -float(\\'inf\\')\\n        def move_alice():\\n            nonlocal max_income\\n            # dfs to find the max income\\n            queue = [(0, -1, 0, 0)] # node, prev, second, income\\n            while queue:\\n                node, prev, second, income = queue.pop()\\n                # calculate the reward or cost\\n                if bob_opening[node] > second:\\n                    income += amount[node]\\n                elif bob_opening[node] == second:\\n                    income += amount[node] // 2\\n    \\n                if second > 0 and len(graph[node]) == 1: # leaf node\\n                    max_income = max(max_income, income)\\n                    continue\\n\\n                for nxt in graph[node]:\\n                    if nxt == prev:\\n                        continue\\n                    queue.append((nxt, node, second + 1, income))\\n        move_alice()\\n        return max_income\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842045,
                "title": "javascript-solution-with-backtracking",
                "content": "```\\n/**\\n * @param {number[][]} edges\\n * @param {number} bob\\n * @param {number[]} amount\\n * @return {number}\\n */\\n var mostProfitablePath = function(edges, bob, amount) {\\n    let res = 0;\\n    // save relation\\n    let map = new Map();\\n    for(let i=0; i<edges.length; i++){\\n        let e1 = edges[i][0];\\n        let e2 = edges[i][1];\\n\\n        if(map.has(e1)){\\n            let arr = map.get(e1);\\n            arr.push(e2);\\n            map.set(e1, arr);\\n        }else{\\n            map.set(e1, [e2]);\\n        }\\n\\n        if(map.has(e2)){\\n            let arr = map.get(e2);\\n            arr.push(e1);\\n            map.set(e2, arr);\\n        }else{\\n            map.set(e2, [e1]);\\n        }\\n    }\\n    // search the path from bob to 0\\n    let path = findPath(bob, [bob], map, []);\\n    path = path[0];\\n    // save time to reach every node\\n    let timeMap = new Map();\\n    for(let i=0; i<path.length; i++){\\n        timeMap.set(path[i], i);\\n    }\\n    // search all path start from 0 and find max\\n    let r = calcPath(0, [0], amount[0], map, timeMap, amount, []);\\n    res = Math.max(...r);\\n\\n    return res;      \\n};\\n\\nfunction findPath(node, arr, map, res){\\n    if(node === 0){\\n        res.push([...arr]);\\n        return res;\\n    }\\n    let nodeArr = map.has(node) ? map.get(node) : [];\\n    for(let i=0; i<nodeArr.length; i++){\\n        if(arr.indexOf(nodeArr[i]) === -1){\\n            arr.push(nodeArr[i]);\\n            res = findPath(nodeArr[i], arr, map, res);\\n            arr.pop();\\n\\n            if(res.length > 0){\\n                break;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n\\nfunction calcPath(node, arr, sum, map, timeMap, amount, res){\\n    if(node === null){\\n        res.push(sum);\\n        return res;\\n    }\\n    let a = map.has(node) ? map.get(node) : [];\\n    // mark if find the new path\\n    let flag = false;\\n    for(let i=0; i<a.length; i++){\\n        if(arr.indexOf(a[i]) === -1){\\n            flag = true;\\n            // check if search the node before\\n            if(timeMap.has(a[i])){\\n                let t = timeMap.get(a[i]);\\n                // Alice reach first\\n                if(arr.length < t){\\n                    arr.push(a[i]);\\n                    res = calcPath(a[i], arr, sum + amount[a[i]], map, timeMap, amount, res);\\n                    arr.pop();\\n                // Alice reach later\\n                }else if(arr.length > t){\\n                    arr.push(a[i]);\\n                    res = calcPath(a[i], arr, sum, map, timeMap, amount, res);\\n                    arr.pop();\\n                // reach at the same time\\n                }else{\\n                    arr.push(a[i]);\\n                    res = calcPath(a[i], arr, sum + amount[a[i]] / 2, map, timeMap, amount, res);\\n                    arr.pop();\\n                }\\n            }else{\\n                // first search\\n                timeMap.set(a[i], arr.length);\\n                arr.push(a[i]);\\n                res = calcPath(a[i], arr, sum + amount[a[i]], map, timeMap, amount, res);\\n                arr.pop();\\n            }  \\n        }\\n    }\\n    // not find means reach the end, then save path sum\\n    if(!flag){\\n        res.push(sum);\\n    }\\n    \\n    return res;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[][]} edges\\n * @param {number} bob\\n * @param {number[]} amount\\n * @return {number}\\n */\\n var mostProfitablePath = function(edges, bob, amount) {\\n    let res = 0;\\n    // save relation\\n    let map = new Map();\\n    for(let i=0; i<edges.length; i++){\\n        let e1 = edges[i][0];\\n        let e2 = edges[i][1];\\n\\n        if(map.has(e1)){\\n            let arr = map.get(e1);\\n            arr.push(e2);\\n            map.set(e1, arr);\\n        }else{\\n            map.set(e1, [e2]);\\n        }\\n\\n        if(map.has(e2)){\\n            let arr = map.get(e2);\\n            arr.push(e1);\\n            map.set(e2, arr);\\n        }else{\\n            map.set(e2, [e1]);\\n        }\\n    }\\n    // search the path from bob to 0\\n    let path = findPath(bob, [bob], map, []);\\n    path = path[0];\\n    // save time to reach every node\\n    let timeMap = new Map();\\n    for(let i=0; i<path.length; i++){\\n        timeMap.set(path[i], i);\\n    }\\n    // search all path start from 0 and find max\\n    let r = calcPath(0, [0], amount[0], map, timeMap, amount, []);\\n    res = Math.max(...r);\\n\\n    return res;      \\n};\\n\\nfunction findPath(node, arr, map, res){\\n    if(node === 0){\\n        res.push([...arr]);\\n        return res;\\n    }\\n    let nodeArr = map.has(node) ? map.get(node) : [];\\n    for(let i=0; i<nodeArr.length; i++){\\n        if(arr.indexOf(nodeArr[i]) === -1){\\n            arr.push(nodeArr[i]);\\n            res = findPath(nodeArr[i], arr, map, res);\\n            arr.pop();\\n\\n            if(res.length > 0){\\n                break;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n\\nfunction calcPath(node, arr, sum, map, timeMap, amount, res){\\n    if(node === null){\\n        res.push(sum);\\n        return res;\\n    }\\n    let a = map.has(node) ? map.get(node) : [];\\n    // mark if find the new path\\n    let flag = false;\\n    for(let i=0; i<a.length; i++){\\n        if(arr.indexOf(a[i]) === -1){\\n            flag = true;\\n            // check if search the node before\\n            if(timeMap.has(a[i])){\\n                let t = timeMap.get(a[i]);\\n                // Alice reach first\\n                if(arr.length < t){\\n                    arr.push(a[i]);\\n                    res = calcPath(a[i], arr, sum + amount[a[i]], map, timeMap, amount, res);\\n                    arr.pop();\\n                // Alice reach later\\n                }else if(arr.length > t){\\n                    arr.push(a[i]);\\n                    res = calcPath(a[i], arr, sum, map, timeMap, amount, res);\\n                    arr.pop();\\n                // reach at the same time\\n                }else{\\n                    arr.push(a[i]);\\n                    res = calcPath(a[i], arr, sum + amount[a[i]] / 2, map, timeMap, amount, res);\\n                    arr.pop();\\n                }\\n            }else{\\n                // first search\\n                timeMap.set(a[i], arr.length);\\n                arr.push(a[i]);\\n                res = calcPath(a[i], arr, sum + amount[a[i]], map, timeMap, amount, res);\\n                arr.pop();\\n            }  \\n        }\\n    }\\n    // not find means reach the end, then save path sum\\n    if(!flag){\\n        res.push(sum);\\n    }\\n    \\n    return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2840680,
                "title": "c-dfs-build-graph-level-bfs",
                "content": "```\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    void dfs(int root, vector<vector<int>>& graph, vector<bool>& vis, vector<int>& par, vector<vector<int>>& children) {\\n        vis[root] = true;\\n        for (int nei : graph[root]) {\\n            if (!vis[nei]) {\\n                par[nei] = root;\\n                children[root].push_back(nei);\\n                vis[nei] = true;\\n                dfs(nei, graph, vis, par, children);\\n            }\\n        }\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size() + 1;\\n        vector<vector<int>> graph(n);\\n        for (auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        vector<bool> vis(n, false);\\n        vector<int> par(n, -1);\\n        vector<vector<int>> children(n);\\n        dfs(0, graph, vis, par, children);\\n        vector<int> order(n, n + 1);\\n        int root = bob;\\n        int cur = 0;\\n        while (root != -1) {\\n            order[root] = cur++;\\n            root = par[root];\\n        }\\n        queue<pii> que;\\n        que.push({0, amount[0]});\\n        cur = 1;\\n        int ma = INT_MIN;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int i = 0; i < size; ++i) {\\n                auto front = que.front();\\n                // cout << front.first << \" \" << front.second << endl;\\n                que.pop();\\n                for (auto nei : children[front.first]) {\\n                    if (order[nei] > cur) {\\n                        // first arrive, get all reward\\n                        que.push({nei, front.second + amount[nei]});\\n                    } else if (order[nei] == cur) {\\n                        // simultaneous arrive, get half reward\\n                        que.push({nei, front.second + amount[nei] / 2});\\n                    } else {\\n                        // late arrive, get no reward\\n                        que.push({nei, front.second});\\n                    }\\n                }\\n                if (children[front.first].empty()) {\\n                    ma = max(ma, front.second);\\n                }\\n            }\\n            ++cur;\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    void dfs(int root, vector<vector<int>>& graph, vector<bool>& vis, vector<int>& par, vector<vector<int>>& children) {\\n        vis[root] = true;\\n        for (int nei : graph[root]) {\\n            if (!vis[nei]) {\\n                par[nei] = root;\\n                children[root].push_back(nei);\\n                vis[nei] = true;\\n                dfs(nei, graph, vis, par, children);\\n            }\\n        }\\n    }\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size() + 1;\\n        vector<vector<int>> graph(n);\\n        for (auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        vector<bool> vis(n, false);\\n        vector<int> par(n, -1);\\n        vector<vector<int>> children(n);\\n        dfs(0, graph, vis, par, children);\\n        vector<int> order(n, n + 1);\\n        int root = bob;\\n        int cur = 0;\\n        while (root != -1) {\\n            order[root] = cur++;\\n            root = par[root];\\n        }\\n        queue<pii> que;\\n        que.push({0, amount[0]});\\n        cur = 1;\\n        int ma = INT_MIN;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int i = 0; i < size; ++i) {\\n                auto front = que.front();\\n                // cout << front.first << \" \" << front.second << endl;\\n                que.pop();\\n                for (auto nei : children[front.first]) {\\n                    if (order[nei] > cur) {\\n                        // first arrive, get all reward\\n                        que.push({nei, front.second + amount[nei]});\\n                    } else if (order[nei] == cur) {\\n                        // simultaneous arrive, get half reward\\n                        que.push({nei, front.second + amount[nei] / 2});\\n                    } else {\\n                        // late arrive, get no reward\\n                        que.push({nei, front.second});\\n                    }\\n                }\\n                if (children[front.first].empty()) {\\n                    ma = max(ma, front.second);\\n                }\\n            }\\n            ++cur;\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2838006,
                "title": "bfs-graph-level-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBob path have to go closer to 0 for every step.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbuild gragh,\\nget path for Bob,\\nBFS to get all path costs for Alice\\nget max()\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        path_b = set([bob])\\n        lvl_b = {bob:0}\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        n = len(amount)\\n        node_lvl = [0] * n\\n        q = deque([0])\\n        \\n        lvl = 0\\n        seen = set([0])\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                u = q.popleft()\\n                node_lvl[u] = lvl\\n                for v in g[u]:\\n                    if v in seen:\\n                        continue\\n                    q.append(v)\\n                    seen.add(v)\\n            lvl += 1\\n        b = bob\\n        lvl = 1\\n        while b != 0:\\n            for v in g[b]:\\n                if node_lvl[v] > node_lvl[b]:\\n                    continue\\n                b = v\\n                cost = amount[b]\\n                path_b.add(b)\\n                lvl_b[b] = lvl\\n                break\\n            lvl += 1\\n        # print(f\"lvl_b {lvl_b} path_b {path_b}  \")\\n        cost_a = []\\n        q = deque([(0, amount[0])])\\n        seen = set([0])\\n        lvl = 1\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                u, pre_cost = q.popleft()\\n                child_cnt = 0\\n                for v in g[u]:\\n                    if v in seen:\\n                        continue\\n                    seen.add(v)\\n                    child_cnt += 1\\n                    cost = pre_cost\\n                    inc = amount[v]\\n                    if v in path_b:\\n                        if lvl_b[v] == lvl:\\n                            cost += inc//2\\n                        elif lvl_b[v] > lvl:\\n                            cost += inc\\n                        else:\\n                            cost += 0\\n                    else:\\n                        cost += amount[v]\\n                    q.append((v, cost))\\n                if child_cnt == 0:\\n                    cost_a.append(pre_cost)\\n            lvl += 1\\n        ans = max(cost_a)\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        path_b = set([bob])\\n        lvl_b = {bob:0}\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        n = len(amount)\\n        node_lvl = [0] * n\\n        q = deque([0])\\n        \\n        lvl = 0\\n        seen = set([0])\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                u = q.popleft()\\n                node_lvl[u] = lvl\\n                for v in g[u]:\\n                    if v in seen:\\n                        continue\\n                    q.append(v)\\n                    seen.add(v)\\n            lvl += 1\\n        b = bob\\n        lvl = 1\\n        while b != 0:\\n            for v in g[b]:\\n                if node_lvl[v] > node_lvl[b]:\\n                    continue\\n                b = v\\n                cost = amount[b]\\n                path_b.add(b)\\n                lvl_b[b] = lvl\\n                break\\n            lvl += 1\\n        # print(f\"lvl_b {lvl_b} path_b {path_b}  \")\\n        cost_a = []\\n        q = deque([(0, amount[0])])\\n        seen = set([0])\\n        lvl = 1\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                u, pre_cost = q.popleft()\\n                child_cnt = 0\\n                for v in g[u]:\\n                    if v in seen:\\n                        continue\\n                    seen.add(v)\\n                    child_cnt += 1\\n                    cost = pre_cost\\n                    inc = amount[v]\\n                    if v in path_b:\\n                        if lvl_b[v] == lvl:\\n                            cost += inc//2\\n                        elif lvl_b[v] > lvl:\\n                            cost += inc\\n                        else:\\n                            cost += 0\\n                    else:\\n                        cost += amount[v]\\n                    q.append((v, cost))\\n                if child_cnt == 0:\\n                    cost_a.append(pre_cost)\\n            lvl += 1\\n        ans = max(cost_a)\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835292,
                "title": "swift-bfs-graph",
                "content": "```\\nclass Solution {\\n    func mostProfitablePath(_ edges: [[Int]], _ bob: Int, _ amount: [Int]) -> Int {\\n        var amount = amount\\n        // make graph\\n        let adjs = makeAdjs(edges)\\n        \\n        // precompute\\n        let distMap = preCompute()\\n        \\n        // init\\n        var visited = Set<Int>([0])\\n        var aliceQueue = [0]\\n        var aliceAmtQueue = [amount[0]]\\n        var bob = bob\\n        amount[bob] = 0\\n        \\n        // run\\n        var ans = Int.min\\n        while aliceQueue.count > 0 {\\n            // run bob first\\n            bob = getNextBobMove(bob) // if bob already on root, it\\'s ok to stay on root\\n            amount[bob] /= 2 // bob take half first\\n            \\n            // run alice later\\n            for _ in 0..<aliceQueue.count {\\n                let aliceNode = aliceQueue.removeFirst()\\n                let aliceAmt = aliceAmtQueue.removeFirst()\\n                \\n                if checkLeaf(aliceNode) {\\n                    ans = max(ans, aliceAmt)\\n                }\\n                \\n                for nodeNei in adjs[aliceNode] ?? [] {\\n                    if visited.contains(nodeNei) { continue }\\n                    visited.insert(nodeNei)\\n                    aliceQueue.append(nodeNei)\\n                    aliceAmtQueue.append(aliceAmt + amount[nodeNei])\\n                }\\n            }\\n            \\n            // bob take remain regardless alice take or not\\n            amount[bob] = 0\\n        }\\n        \\n        func makeAdjs(_ edges: [[Int]]) -> [Int: [Int]] {\\n            var ans: [Int: [Int]] = [:]\\n            for edge in edges {\\n                ans[edge[0], default: []].append(edge[1])\\n                ans[edge[1], default: []].append(edge[0])\\n            }\\n            return ans\\n        }\\n        \\n\\t\\t// this dict to store the distance, that help Bob run toward to root node\\n        func preCompute() -> [Int: Int] {\\n            var ans: [Int: Int] = [:]\\n            var queue = [0]\\n            var visited = Set<Int>([0])\\n            \\n            var step = 0\\n            while queue.count > 0 {\\n                for _ in 0..<queue.count {\\n                    let node = queue.removeFirst()\\n                    ans[node] = step\\n                    for nei in adjs[node] ?? [] {\\n                        if visited.contains(nei) { continue }\\n                        visited.insert(nei)\\n                        queue.append(nei)\\n                    }\\n                }\\n                step += 1\\n            }\\n            return ans\\n        }\\n        \\n\\t\\t// run toward root node\\n        func getNextBobMove(_ node: Int) -> Int {\\n            var nextNode = node\\n            for nei in adjs[node] ?? [] {\\n                if (distMap[nei] ?? 0) < (distMap[nextNode] ?? 0) {\\n                    nextNode = nei\\n                }\\n            }\\n            return nextNode\\n        }\\n        \\n        func checkLeaf(_ node: Int) -> Bool {\\n            let neis = adjs[node] ?? []\\n            if neis.count != 1 { return false }\\n            return visited.contains(neis[0])\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mostProfitablePath(_ edges: [[Int]], _ bob: Int, _ amount: [Int]) -> Int {\\n        var amount = amount\\n        // make graph\\n        let adjs = makeAdjs(edges)\\n        \\n        // precompute\\n        let distMap = preCompute()\\n        \\n        // init\\n        var visited = Set<Int>([0])\\n        var aliceQueue = [0]\\n        var aliceAmtQueue = [amount[0]]\\n        var bob = bob\\n        amount[bob] = 0\\n        \\n        // run\\n        var ans = Int.min\\n        while aliceQueue.count > 0 {\\n            // run bob first\\n            bob = getNextBobMove(bob) // if bob already on root, it\\'s ok to stay on root\\n            amount[bob] /= 2 // bob take half first\\n            \\n            // run alice later\\n            for _ in 0..<aliceQueue.count {\\n                let aliceNode = aliceQueue.removeFirst()\\n                let aliceAmt = aliceAmtQueue.removeFirst()\\n                \\n                if checkLeaf(aliceNode) {\\n                    ans = max(ans, aliceAmt)\\n                }\\n                \\n                for nodeNei in adjs[aliceNode] ?? [] {\\n                    if visited.contains(nodeNei) { continue }\\n                    visited.insert(nodeNei)\\n                    aliceQueue.append(nodeNei)\\n                    aliceAmtQueue.append(aliceAmt + amount[nodeNei])\\n                }\\n            }\\n            \\n            // bob take remain regardless alice take or not\\n            amount[bob] = 0\\n        }\\n        \\n        func makeAdjs(_ edges: [[Int]]) -> [Int: [Int]] {\\n            var ans: [Int: [Int]] = [:]\\n            for edge in edges {\\n                ans[edge[0], default: []].append(edge[1])\\n                ans[edge[1], default: []].append(edge[0])\\n            }\\n            return ans\\n        }\\n        \\n\\t\\t// this dict to store the distance, that help Bob run toward to root node\\n        func preCompute() -> [Int: Int] {\\n            var ans: [Int: Int] = [:]\\n            var queue = [0]\\n            var visited = Set<Int>([0])\\n            \\n            var step = 0\\n            while queue.count > 0 {\\n                for _ in 0..<queue.count {\\n                    let node = queue.removeFirst()\\n                    ans[node] = step\\n                    for nei in adjs[node] ?? [] {\\n                        if visited.contains(nei) { continue }\\n                        visited.insert(nei)\\n                        queue.append(nei)\\n                    }\\n                }\\n                step += 1\\n            }\\n            return ans\\n        }\\n        \\n\\t\\t// run toward root node\\n        func getNextBobMove(_ node: Int) -> Int {\\n            var nextNode = node\\n            for nei in adjs[node] ?? [] {\\n                if (distMap[nei] ?? 0) < (distMap[nextNode] ?? 0) {\\n                    nextNode = nei\\n                }\\n            }\\n            return nextNode\\n        }\\n        \\n        func checkLeaf(_ node: Int) -> Bool {\\n            let neis = adjs[node] ?? []\\n            if neis.count != 1 { return false }\\n            return visited.contains(neis[0])\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834886,
                "title": "easy-to-understand-dfs-and-bfs-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>> &adj, vector<int> &path, int cur, int parent, int level) {\\n        // if reached the 0th node return\\n        if (cur == 0) {\\n            return true;\\n        }\\n        for (auto &n : adj[cur]) {\\n            // don\\'t go backward inorder to avoid loop\\n            if (n != parent) {\\n                path[n] = level+1;\\n                // Do dfs to get the next level\\n                // return true if we reached the terminal node\\n                if (dfs(adj,path,n,cur,level+1))\\n                    return true;\\n                path[n] = -1;\\n            }\\n        }\\n        return false;\\n    }\\n    using tp = tuple<int,int,int,int>;\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size()+1;\\n        vector<int> path(n,-1);\\n        vector<vector<int>> adj(n);\\n        for (auto &e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        path[bob] = 0;\\n        // figure out the path taken by Bob first\\n        dfs(adj,path,bob,-1,0);\\n        \\n        queue<tp> q;\\n        q.push({0,-1,0,0});\\n        int result = INT_MIN;\\n        \\n        // Do BFS on the Graph\\n        while(!q.empty()) {\\n            auto [cur,parent,level,amt] = q.front();\\n            q.pop();\\n            // If gate no opened by Bob or it is opened later by Bob\\n            // Alice bear the full cost\\n            if ((path[cur] == -1) || (path[cur] > level)) {\\n                amt += amount[cur];\\n            } else if (path[cur] == level) {\\n                // if at same level then share the amount\\n                amt += (amount[cur]/2);\\n            }\\n            \\n            // if terminal node then update the result\\n            if ((adj[cur].size() == 1) && (adj[cur][0] == parent)){\\n                result = max(result,amt);\\n            } else {\\n                for (auto &n : adj[cur]) {\\n                    // Do BFS for next level \\n                    if (n != parent) {\\n                        q.push({n,cur,level+1,amt});\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>> &adj, vector<int> &path, int cur, int parent, int level) {\\n        // if reached the 0th node return\\n        if (cur == 0) {\\n            return true;\\n        }\\n        for (auto &n : adj[cur]) {\\n            // don\\'t go backward inorder to avoid loop\\n            if (n != parent) {\\n                path[n] = level+1;\\n                // Do dfs to get the next level\\n                // return true if we reached the terminal node\\n                if (dfs(adj,path,n,cur,level+1))\\n                    return true;\\n                path[n] = -1;\\n            }\\n        }\\n        return false;\\n    }\\n    using tp = tuple<int,int,int,int>;\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size()+1;\\n        vector<int> path(n,-1);\\n        vector<vector<int>> adj(n);\\n        for (auto &e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        path[bob] = 0;\\n        // figure out the path taken by Bob first\\n        dfs(adj,path,bob,-1,0);\\n        \\n        queue<tp> q;\\n        q.push({0,-1,0,0});\\n        int result = INT_MIN;\\n        \\n        // Do BFS on the Graph\\n        while(!q.empty()) {\\n            auto [cur,parent,level,amt] = q.front();\\n            q.pop();\\n            // If gate no opened by Bob or it is opened later by Bob\\n            // Alice bear the full cost\\n            if ((path[cur] == -1) || (path[cur] > level)) {\\n                amt += amount[cur];\\n            } else if (path[cur] == level) {\\n                // if at same level then share the amount\\n                amt += (amount[cur]/2);\\n            }\\n            \\n            // if terminal node then update the result\\n            if ((adj[cur].size() == 1) && (adj[cur][0] == parent)){\\n                result = max(result,amt);\\n            } else {\\n                for (auto &n : adj[cur]) {\\n                    // Do BFS for next level \\n                    if (n != parent) {\\n                        q.push({n,cur,level+1,amt});\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831080,
                "title": "python3-dfs",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e8b87d04cc192c5227286692921910fe93fee05d) for solutions of biweekly 91. \\n\\nThis implementation reflects the solution give by @lee215 in this [post](https://leetcode.com/problems/most-profitable-path-in-a-tree/discuss/2807411/Python-One-DFS). \\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = 1 + len(edges)\\n        tree = [[] for _ in range(n)]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        seen = [False] * n\\n        \\n        def dfs(u, d): \\n            \"\"\"Return \"\"\"\\n            seen[u] = True\\n            ans = -inf \\n            dd = 0 if u == bob else n \\n            for v in tree[u]: \\n                if not seen[v]: \\n                    x, y = dfs(v, d+1)\\n                    ans = max(ans, x)\\n                    dd = min(dd, y)\\n            if ans == -inf: ans = 0\\n            if d == dd: ans += amount[u]//2\\n            if d < dd: ans += amount[u]\\n            return ans, dd+1\\n        \\n        return dfs(0, 0)[0]\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = 1 + len(edges)\\n        tree = [[] for _ in range(n)]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        seen = [False] * n\\n        \\n        def dfs(u, d): \\n            \"\"\"Return \"\"\"\\n            seen[u] = True\\n            ans = -inf \\n            dd = 0 if u == bob else n \\n            for v in tree[u]: \\n                if not seen[v]: \\n                    x, y = dfs(v, d+1)\\n                    ans = max(ans, x)\\n                    dd = min(dd, y)\\n            if ans == -inf: ans = 0\\n            if d == dd: ans += amount[u]//2\\n            if d < dd: ans += amount[u]\\n            return ans, dd+1\\n        \\n        return dfs(0, 0)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829290,
                "title": "simple-dfs-asked-in-intuit-oa-broken-the-problem-into-simpler-subproblems-c",
                "content": "```\\n/*\\nSteps (subproblems):\\n    1. Find the path travelled by Bob to reach node-0\\n    2. Update the points (or gates) of half of the nodes in the path travelled by Bob\\n    3. Apply BFS/DFS from 0 to find the max points Alice can get on her way to a leaf node\\n*/\\n\\nclass Solution {\\n\\t/*\\n\\t\\tDescription of function parameters:\\n\\t\\tadj -> adjacency list\\n\\t\\tbob -> current position of Bob\\n\\t\\tpathBob -> vector to store the nodes\\n\\t\\tvisited -> to avoid visiting the same nodes again\\n\\t*/\\n    bool findPathTo0(vector<int> adj[], int bob, vector<int> &pathBob, vector<bool> &visited) {\\n        if (bob == 0) {\\n\\t\\t\\t// We found a path to 0. Now we can go back and store the nodes travelled so far in a vector:)\\n            pathBob.push_back(bob);\\n            return 1;\\n        }\\n        \\n        visited[bob] = 1;\\n        bool flag = 0;\\n        for (int v: adj[bob]) {\\n            if (!visited[v])\\n                flag = findPathTo0(adj, v, pathBob, visited);\\n            \\n            if (flag) {\\n                pathBob.push_back(bob);\\n                return 1;\\n            }\\n        }\\n        \\n\\t\\t// This node can not get us to node-0 so return false:\\n        return 0;\\n    }\\n    \\n    int findOptimalPath(vector<int> adj[], vector<bool> &visited, vector<int>& amount, int node) {\\n        int res = INT_MIN;\\n        visited[node] = 1;\\n        \\n        for (int v: adj[node]) {\\n            if (!visited[v]) {\\n                res = max(res, amount[node] + findOptimalPath(adj, visited, amount, v));\\n            }\\n        }\\n        \\n\\t\\t// If we can go to any other node (i.e. it is a leaf node), then our \\'res\\' variable will have INT_MIN value\\n\\t\\t// In this case we need to return the value of gate at this node:\\n        if (res == INT_MIN) return amount[node];\\n        \\n\\t\\treturn res;\\n    }\\n    \\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size()+1;\\n        \\n        // form the adj list:\\n        vector<int> adj[n+1];\\n        for (int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        // Step-1: Find the path travelled by Bob to reach node-0\\n        vector<int> pathBob;\\n        vector<bool> visited(n+1, 0);\\n        findPathTo0(adj, bob, pathBob, visited);\\n\\n        \\n        // Step-2: Update the points (or gates) of half of the nodes in the path travelled by Bob\\n        reverse(pathBob.begin(), pathBob.end());\\n        for (int i = 0; i < pathBob.size()/2; i++)\\n            amount[pathBob[i]] = 0;\\n        \\n\\t\\t// If the path lenght is odd, both Alice and Bob will reach the middle node at same time. \\n\\t\\t// In this case, both Alice and Bob will get half the points this node offers\\n        if (pathBob.size() % 2)\\n            amount[pathBob[pathBob.size()/2]] /= 2;\\n        \\n        \\n        // Step-3: Apply DFS from 0 to find the max points Alice can get on her way to a leaf node\\n        visited = vector<bool> (n+1, 0);\\n        int ans = findOptimalPath(adj, visited, amount, 0);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nI got the exact same question in Intuit OA this year.",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\nSteps (subproblems):\\n    1. Find the path travelled by Bob to reach node-0\\n    2. Update the points (or gates) of half of the nodes in the path travelled by Bob\\n    3. Apply BFS/DFS from 0 to find the max points Alice can get on her way to a leaf node\\n*/\\n\\nclass Solution {\\n\\t/*\\n\\t\\tDescription of function parameters:\\n\\t\\tadj -> adjacency list\\n\\t\\tbob -> current position of Bob\\n\\t\\tpathBob -> vector to store the nodes\\n\\t\\tvisited -> to avoid visiting the same nodes again\\n\\t*/\\n    bool findPathTo0(vector<int> adj[], int bob, vector<int> &pathBob, vector<bool> &visited) {\\n        if (bob == 0) {\\n\\t\\t\\t// We found a path to 0. Now we can go back and store the nodes travelled so far in a vector:)\\n            pathBob.push_back(bob);\\n            return 1;\\n        }\\n        \\n        visited[bob] = 1;\\n        bool flag = 0;\\n        for (int v: adj[bob]) {\\n            if (!visited[v])\\n                flag = findPathTo0(adj, v, pathBob, visited);\\n            \\n            if (flag) {\\n                pathBob.push_back(bob);\\n                return 1;\\n            }\\n        }\\n        \\n\\t\\t// This node can not get us to node-0 so return false:\\n        return 0;\\n    }\\n    \\n    int findOptimalPath(vector<int> adj[], vector<bool> &visited, vector<int>& amount, int node) {\\n        int res = INT_MIN;\\n        visited[node] = 1;\\n        \\n        for (int v: adj[node]) {\\n            if (!visited[v]) {\\n                res = max(res, amount[node] + findOptimalPath(adj, visited, amount, v));\\n            }\\n        }\\n        \\n\\t\\t// If we can go to any other node (i.e. it is a leaf node), then our \\'res\\' variable will have INT_MIN value\\n\\t\\t// In this case we need to return the value of gate at this node:\\n        if (res == INT_MIN) return amount[node];\\n        \\n\\t\\treturn res;\\n    }\\n    \\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = edges.size()+1;\\n        \\n        // form the adj list:\\n        vector<int> adj[n+1];\\n        for (int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        // Step-1: Find the path travelled by Bob to reach node-0\\n        vector<int> pathBob;\\n        vector<bool> visited(n+1, 0);\\n        findPathTo0(adj, bob, pathBob, visited);\\n\\n        \\n        // Step-2: Update the points (or gates) of half of the nodes in the path travelled by Bob\\n        reverse(pathBob.begin(), pathBob.end());\\n        for (int i = 0; i < pathBob.size()/2; i++)\\n            amount[pathBob[i]] = 0;\\n        \\n\\t\\t// If the path lenght is odd, both Alice and Bob will reach the middle node at same time. \\n\\t\\t// In this case, both Alice and Bob will get half the points this node offers\\n        if (pathBob.size() % 2)\\n            amount[pathBob[pathBob.size()/2]] /= 2;\\n        \\n        \\n        // Step-3: Apply DFS from 0 to find the max points Alice can get on her way to a leaf node\\n        visited = vector<bool> (n+1, 0);\\n        int ans = findOptimalPath(adj, visited, amount, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821005,
                "title": "java-dfs-trees-easy-to-follow",
                "content": "\\n```\\nclass Solution {\\n    int []parent;\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n=edges.length;\\n        parent=new int[n+1];\\n        HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            int st=edges[i][0];\\n            int end=edges[i][1];\\n\\n            ArrayList<Integer>ls=map.getOrDefault(st,new ArrayList<>());\\n            ls.add(end);\\n            ArrayList<Integer>rs=map.getOrDefault(end,new ArrayList<>());\\n            rs.add(st);\\n            map.put(st,ls);\\n            map.put(end,rs);\\n\\n\\n\\n        }\\n\\n        int []dist=new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        int []Visited=new int[n+1];\\n        int []vis=new int[n+1];\\n        dfs(0,-1,Visited,map);\\n         dfsBob(bob,dist);\\n\\n        return getMax(0,map,dist,amount,0,vis);\\n\\n    }\\n    public void  dfs(int node,int previous,int []visited,HashMap<Integer,ArrayList<Integer>>map)\\n    {\\n\\n        visited[node]=1;\\n\\n        parent[node]=previous;\\n\\nArrayList<Integer>ls=map.get(node);\\n        for(int nbr:ls)\\n        {\\n            if(visited[nbr]!=1)\\n                dfs(nbr,node,visited,map);\\n        }\\n\\n    }\\n\\n    public void  dfsBob(int node,int []dist)\\n    {\\n        dist[node]=0;\\n        int steps=0;\\n        while(node!=0)\\n        {\\n            steps++;\\n\\n            int p=parent[node];\\n            node=p;\\n            dist[node]=steps;\\n\\n\\n        }\\n\\n    }\\n\\n    public int getMax(int node,HashMap<Integer,ArrayList<Integer>>map,int []dist,int []amount,int level,int []vis)\\n    {\\n        vis[node]=1;\\n        int score=0;\\n        if(level==dist[node])\\n        {\\n            score=amount[node]/2;\\n\\n\\n        }\\n        else if(level<dist[node])\\n        {\\n            score=amount[node];\\n        }\\nSystem.out.println(score);\\n        int max=Integer.MIN_VALUE;\\n        boolean f1=false;\\n        ArrayList<Integer>ls=map.get(node);\\n        for(int nbr:ls)\\n        {\\n\\n            if(vis[nbr]!=1)\\n            {\\n                f1=true;\\n                max=Math.max(score+ getMax(nbr,map,dist,amount,level+1,vis),max);\\n            }\\n\\n        }\\n        if(!f1)  // reached leaf  node as  all neighbours already visited\\n        {\\n            return score;\\n        }\\n\\n        return max;\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int []parent;\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        int n=edges.length;\\n        parent=new int[n+1];\\n        HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            int st=edges[i][0];\\n            int end=edges[i][1];\\n\\n            ArrayList<Integer>ls=map.getOrDefault(st,new ArrayList<>());\\n            ls.add(end);\\n            ArrayList<Integer>rs=map.getOrDefault(end,new ArrayList<>());\\n            rs.add(st);\\n            map.put(st,ls);\\n            map.put(end,rs);\\n\\n\\n\\n        }\\n\\n        int []dist=new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        int []Visited=new int[n+1];\\n        int []vis=new int[n+1];\\n        dfs(0,-1,Visited,map);\\n         dfsBob(bob,dist);\\n\\n        return getMax(0,map,dist,amount,0,vis);\\n\\n    }\\n    public void  dfs(int node,int previous,int []visited,HashMap<Integer,ArrayList<Integer>>map)\\n    {\\n\\n        visited[node]=1;\\n\\n        parent[node]=previous;\\n\\nArrayList<Integer>ls=map.get(node);\\n        for(int nbr:ls)\\n        {\\n            if(visited[nbr]!=1)\\n                dfs(nbr,node,visited,map);\\n        }\\n\\n    }\\n\\n    public void  dfsBob(int node,int []dist)\\n    {\\n        dist[node]=0;\\n        int steps=0;\\n        while(node!=0)\\n        {\\n            steps++;\\n\\n            int p=parent[node];\\n            node=p;\\n            dist[node]=steps;\\n\\n\\n        }\\n\\n    }\\n\\n    public int getMax(int node,HashMap<Integer,ArrayList<Integer>>map,int []dist,int []amount,int level,int []vis)\\n    {\\n        vis[node]=1;\\n        int score=0;\\n        if(level==dist[node])\\n        {\\n            score=amount[node]/2;\\n\\n\\n        }\\n        else if(level<dist[node])\\n        {\\n            score=amount[node];\\n        }\\nSystem.out.println(score);\\n        int max=Integer.MIN_VALUE;\\n        boolean f1=false;\\n        ArrayList<Integer>ls=map.get(node);\\n        for(int nbr:ls)\\n        {\\n\\n            if(vis[nbr]!=1)\\n            {\\n                f1=true;\\n                max=Math.max(score+ getMax(nbr,map,dist,amount,level+1,vis),max);\\n            }\\n\\n        }\\n        if(!f1)  // reached leaf  node as  all neighbours already visited\\n        {\\n            return score;\\n        }\\n\\n        return max;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818550,
                "title": "c-easiest-solution-of-all-well-commented-and-made-easy",
                "content": "# Code\\n```\\nclass Solution {\\nprivate: \\n    unordered_map<int, int> path;\\n    vector<bool> visited;\\n    \\n    bool find_dfs(vector<vector<int>>& graph, int src, int time, vector<int>& amount){\\n        visited[src] = true;\\n        path[src] = time;\\n        if(src == 0) return true;\\n        // Check in graph\\n        for(int i=0; i<graph[src].size(); i++)\\n            if(!visited[graph[src][i]]  &&  find_dfs(graph, graph[src][i], time+1, amount)) return true;\\n        \\n        // remove from map if 0 not found\\n        path.erase(src);\\n        return false;\\n    }\\n    \\npublic:\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        // build graph\\n        vector<vector<int>> graph(amount.size());     \\n        for(int i=0; i<edges.size(); i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // Check path for bob\\n        visited.resize(amount.size(), false);\\n        find_dfs(graph, bob, 0, amount);\\n        \\n        //Settings needed to check alice path with time\\n        visited = vector<bool>(amount.size(), false);\\n        int ans =INT_MIN;\\n        queue<vector<int>> qu;\\n        qu.push({0,0,0});  // curr, time, cost\\n        \\n        while(!qu.empty()){\\n            int curr = qu.front()[0];\\n            int time = qu.front()[1];\\n            int cost = qu.front()[2];\\n            qu.pop();\\n            visited[curr] = true;\\n            \\n            // If this path is takin my bob or not\\n            if(path.find(curr) == path.end()){\\n                cost += amount[curr];\\n            }else{\\n                // path taken by bob then check time stamps\\n                if(path[curr] > time) cost+= amount[curr];\\n                else if(path[curr] == time) cost += (amount[curr])/2;\\n            }\\n            \\n            // it is leafe, size is 1 because of its src path (except 0 which is src itself)\\n            if(graph[curr].size()==1 && curr!=0) {\\n                ans = max(ans, cost);\\n            }\\n            \\n            // Add in que to travel in garph\\n            for(int i=0; i<graph[curr].size(); i++){\\n                if(!visited[graph[curr][i]]) {\\n                    qu.push({graph[curr][i], time+1, cost});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n    unordered_map<int, int> path;\\n    vector<bool> visited;\\n    \\n    bool find_dfs(vector<vector<int>>& graph, int src, int time, vector<int>& amount){\\n        visited[src] = true;\\n        path[src] = time;\\n        if(src == 0) return true;\\n        // Check in graph\\n        for(int i=0; i<graph[src].size(); i++)\\n            if(!visited[graph[src][i]]  &&  find_dfs(graph, graph[src][i], time+1, amount)) return true;\\n        \\n        // remove from map if 0 not found\\n        path.erase(src);\\n        return false;\\n    }\\n    \\npublic:\\n    \\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        // build graph\\n        vector<vector<int>> graph(amount.size());     \\n        for(int i=0; i<edges.size(); i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // Check path for bob\\n        visited.resize(amount.size(), false);\\n        find_dfs(graph, bob, 0, amount);\\n        \\n        //Settings needed to check alice path with time\\n        visited = vector<bool>(amount.size(), false);\\n        int ans =INT_MIN;\\n        queue<vector<int>> qu;\\n        qu.push({0,0,0});  // curr, time, cost\\n        \\n        while(!qu.empty()){\\n            int curr = qu.front()[0];\\n            int time = qu.front()[1];\\n            int cost = qu.front()[2];\\n            qu.pop();\\n            visited[curr] = true;\\n            \\n            // If this path is takin my bob or not\\n            if(path.find(curr) == path.end()){\\n                cost += amount[curr];\\n            }else{\\n                // path taken by bob then check time stamps\\n                if(path[curr] > time) cost+= amount[curr];\\n                else if(path[curr] == time) cost += (amount[curr])/2;\\n            }\\n            \\n            // it is leafe, size is 1 because of its src path (except 0 which is src itself)\\n            if(graph[curr].size()==1 && curr!=0) {\\n                ans = max(ans, cost);\\n            }\\n            \\n            // Add in que to travel in garph\\n            for(int i=0; i<graph[curr].size(); i++){\\n                if(!visited[graph[curr][i]]) {\\n                    qu.push({graph[curr][i], time+1, cost});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817404,
                "title": "2dfs-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the Path for bob to move from his position to root and find all the paths from root to leaf by using dfs and moving bob 1 step at a time and updating the amount array accordingly \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\none dfs for finding path for bob .Using bob\\'s path update amount while performing dfs for finding path from root to leaf and trying all root to leaf path. It is slight modification to dfs.We can call it dynamic dfs I guess as amount is getting updated during moving of bob.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are visting all node once and doing seperatre dfs for bob\\nso time complexity will be O(2n) which is O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool find(int prev,int dst,int src,vector<int>&path_bob,vector<int>adj[]){\\n        if(src==dst){\\n            return true;\\n        }\\n        for(int i=0;i<adj[src].size();i++){\\n            if(prev!=adj[src][i]){\\n                path_bob.push_back(adj[src][i]);\\n                if(find(src,dst,adj[src][i],path_bob,adj))\\n                    return true;\\n                path_bob.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,vector<int>&amount,int prev,int src,int &ans,vector<int>&path_bob,int curr,vector<int>adj[]){\\n\\n        if(i==path_bob.size()){\\n            curr+=amount[src];\\n            int temp=amount[src];\\n            amount[src]=0;\\n            \\n            for(int k=0;k<adj[src].size();k++){\\n                if(prev!=adj[src][k]){\\n                    dfs(i,amount,src,adj[src][k],ans,path_bob,curr,adj);\\n                }\\n            }\\n            if(adj[src].size()==1&&adj[src][0]==prev){\\n                ans=max(ans,curr);\\n            }\\n            amount[src]=temp;\\n            return;\\n        }\\n        curr+=amount[src]/2;\\n        if(path_bob[i]!=src){\\n            curr+=amount[src]/2;\\n        }\\n        \\n        int temp=amount[src],temp2=amount[path_bob[i]];\\n        amount[src]=0;\\n        amount[path_bob[i]]=0;\\n        for(int k=0;k<adj[src].size();k++){\\n            if(prev!=adj[src][k]){\\n                dfs(i+1,amount,src,adj[src][k],ans,path_bob,curr,adj);\\n            }\\n        }\\n        if(adj[src].size()==1&&adj[src][0]==prev){\\n            ans=max(ans,curr);\\n        }\\n        amount[src]=temp;\\n        amount[path_bob[i]]=temp2;\\n    \\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=edges.size()+1;\\n        vector<int> adj[n];\\n        for(int i=0;i<n-1;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> path_bob;\\n        path_bob.push_back(bob);\\n        find(-1,0,bob,path_bob,adj);\\n        int ans=INT_MIN;\\n        dfs(0,amount,-1,0,ans,path_bob,0,adj);\\n        return ans;\\n    }\\n};\\n```\\nUpvote if helped",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(int prev,int dst,int src,vector<int>&path_bob,vector<int>adj[]){\\n        if(src==dst){\\n            return true;\\n        }\\n        for(int i=0;i<adj[src].size();i++){\\n            if(prev!=adj[src][i]){\\n                path_bob.push_back(adj[src][i]);\\n                if(find(src,dst,adj[src][i],path_bob,adj))\\n                    return true;\\n                path_bob.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,vector<int>&amount,int prev,int src,int &ans,vector<int>&path_bob,int curr,vector<int>adj[]){\\n\\n        if(i==path_bob.size()){\\n            curr+=amount[src];\\n            int temp=amount[src];\\n            amount[src]=0;\\n            \\n            for(int k=0;k<adj[src].size();k++){\\n                if(prev!=adj[src][k]){\\n                    dfs(i,amount,src,adj[src][k],ans,path_bob,curr,adj);\\n                }\\n            }\\n            if(adj[src].size()==1&&adj[src][0]==prev){\\n                ans=max(ans,curr);\\n            }\\n            amount[src]=temp;\\n            return;\\n        }\\n        curr+=amount[src]/2;\\n        if(path_bob[i]!=src){\\n            curr+=amount[src]/2;\\n        }\\n        \\n        int temp=amount[src],temp2=amount[path_bob[i]];\\n        amount[src]=0;\\n        amount[path_bob[i]]=0;\\n        for(int k=0;k<adj[src].size();k++){\\n            if(prev!=adj[src][k]){\\n                dfs(i+1,amount,src,adj[src][k],ans,path_bob,curr,adj);\\n            }\\n        }\\n        if(adj[src].size()==1&&adj[src][0]==prev){\\n            ans=max(ans,curr);\\n        }\\n        amount[src]=temp;\\n        amount[path_bob[i]]=temp2;\\n    \\n    }\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n=edges.size()+1;\\n        vector<int> adj[n];\\n        for(int i=0;i<n-1;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> path_bob;\\n        path_bob.push_back(bob);\\n        find(-1,0,bob,path_bob,adj);\\n        int ans=INT_MIN;\\n        dfs(0,amount,-1,0,ans,path_bob,0,adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816339,
                "title": "python-dfs-bfs-o-n-solution",
                "content": "```\\ndef mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        G = defaultdict(set)\\n        N = len(amount)\\n        for u, v in edges:\\n            G[u].add(v)\\n            G[v].add(u)\\n        \\n        par = [0] * N  # store parents of every node this will be helpful for traversing from bob to root\\n        def dfs(i, p = -1):\\n            par[i] = p \\n            for nei in G[i]:\\n                if p == nei: continue\\n                dfs(nei, i)\\n        \\n        dfs(0)\\n        dq = deque([[0, bob, 0, -1]])\\n        res = -inf\\n        vis = [0] * N\\n        while dq:\\n            ali, b, cost, ap = dq.popleft()\\n            if ali == b: # alice and bob at same postion\\n                cost += amount[ali] // 2\\n            elif not vis[ali]:   \\n                cost += amount[ali]   # alice reaching the current node first \\n            if b != -1: vis[b] = 1    # mark bob visited nodes\\n            if len(G[ali]) == 1 and ap in G[ali]:  # check for leaf node \\n                res = max(res, cost)  # store max net result of alice at every leaf node\\n            \\n            bp = -1 if b == -1 else par[b]   # if bob reaches root then there will no parent so take -1\\n            for nei in G[ali]:\\n                if ap == nei: continue\\n                dq.append([nei, bp, cost, ali])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        G = defaultdict(set)\\n        N = len(amount)\\n        for u, v in edges:\\n            G[u].add(v)\\n            G[v].add(u)\\n        \\n        par = [0] * N  # store parents of every node this will be helpful for traversing from bob to root\\n        def dfs(i, p = -1):\\n            par[i] = p \\n            for nei in G[i]:\\n                if p == nei: continue\\n                dfs(nei, i)\\n        \\n        dfs(0)\\n        dq = deque([[0, bob, 0, -1]])\\n        res = -inf\\n        vis = [0] * N\\n        while dq:\\n            ali, b, cost, ap = dq.popleft()\\n            if ali == b: # alice and bob at same postion\\n                cost += amount[ali] // 2\\n            elif not vis[ali]:   \\n                cost += amount[ali]   # alice reaching the current node first \\n            if b != -1: vis[b] = 1    # mark bob visited nodes\\n            if len(G[ali]) == 1 and ap in G[ali]:  # check for leaf node \\n                res = max(res, cost)  # store max net result of alice at every leaf node\\n            \\n            bp = -1 if b == -1 else par[b]   # if bob reaches root then there will no parent so take -1\\n            for nei in G[ali]:\\n                if ap == nei: continue\\n                dq.append([nei, bp, cost, ali])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2815323,
                "title": "where-is-the-root-of-the-tree",
                "content": "```\\n[[0,2],[0,5],[1,3],[1,5],[2,4]]\\n4\\n[5018,8388,6224,3466,3808,3456]\\n```",
                "solutionTags": [],
                "code": "```\\n[[0,2],[0,5],[1,3],[1,5],[2,4]]\\n4\\n[5018,8388,6224,3466,3808,3456]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2815052,
                "title": "golang-233-ms-21-2-mb",
                "content": "```\\nfunc max(a, b int) int {\\n\\tif a >= b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc fillParents(parentToChildren [][]int32, parents []int32, idx int32) {\\n\\tfor _, childIdx := range parentToChildren[idx] {\\n\\t\\tif parents[childIdx] == -1 {\\n\\t\\t\\tparents[childIdx] = idx\\n\\t\\t\\tfillParents(parentToChildren, parents, childIdx)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc mostProfitablePath(edges [][]int, bob int, amount []int) int {\\n\\tparentToChildren := make([][]int32, len(amount))\\n\\tfor _, edge := range edges {\\n\\t\\tparentToChildren[edge[0]] = append(parentToChildren[edge[0]], int32(edge[1]))\\n\\t\\tparentToChildren[edge[1]] = append(parentToChildren[edge[1]], int32(edge[0]))\\n\\t}\\n\\tparents := make([]int32, len(amount))\\n\\tparents[0] = -2\\n\\tfor i := 1; i < len(amount); i++ {\\n\\t\\tparents[i] = -1\\n\\t}\\n\\tfillParents(parentToChildren, parents, 0)\\n\\n\\tslow, fast := int32(bob), parents[bob]\\n\\tfor fast != 0 && parents[fast] != 0 {\\n\\t\\tamount[slow] = 0\\n\\t\\tslow = parents[slow]\\n\\t\\tfast = parents[parents[fast]]\\n\\t}\\n\\tamount[slow] = 0\\n\\tif fast != 0 {\\n\\t\\tamount[parents[slow]] >>= 1\\n\\t}\\n\\n\\tresult := math.MinInt\\n\\tcur := []int32{0}\\n\\tvar next []int32\\n\\tfor len(cur) != 0 {\\n\\t\\tfor _, parent := range cur {\\n\\t\\t\\tleaf := true\\n\\t\\t\\tfor _, child := range parentToChildren[parent] {\\n\\t\\t\\t\\tif parents[child] != parent {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleaf = false\\n\\t\\t\\t\\tamount[child] += amount[parent]\\n\\t\\t\\t\\tnext = append(next, child)\\n\\t\\t\\t}\\n\\t\\t\\tif leaf {\\n\\t\\t\\t\\tresult = max(result, amount[parent])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcur, next = next, cur[:0]\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc max(a, b int) int {\\n\\tif a >= b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc fillParents(parentToChildren [][]int32, parents []int32, idx int32) {\\n\\tfor _, childIdx := range parentToChildren[idx] {\\n\\t\\tif parents[childIdx] == -1 {\\n\\t\\t\\tparents[childIdx] = idx\\n\\t\\t\\tfillParents(parentToChildren, parents, childIdx)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc mostProfitablePath(edges [][]int, bob int, amount []int) int {\\n\\tparentToChildren := make([][]int32, len(amount))\\n\\tfor _, edge := range edges {\\n\\t\\tparentToChildren[edge[0]] = append(parentToChildren[edge[0]], int32(edge[1]))\\n\\t\\tparentToChildren[edge[1]] = append(parentToChildren[edge[1]], int32(edge[0]))\\n\\t}\\n\\tparents := make([]int32, len(amount))\\n\\tparents[0] = -2\\n\\tfor i := 1; i < len(amount); i++ {\\n\\t\\tparents[i] = -1\\n\\t}\\n\\tfillParents(parentToChildren, parents, 0)\\n\\n\\tslow, fast := int32(bob), parents[bob]\\n\\tfor fast != 0 && parents[fast] != 0 {\\n\\t\\tamount[slow] = 0\\n\\t\\tslow = parents[slow]\\n\\t\\tfast = parents[parents[fast]]\\n\\t}\\n\\tamount[slow] = 0\\n\\tif fast != 0 {\\n\\t\\tamount[parents[slow]] >>= 1\\n\\t}\\n\\n\\tresult := math.MinInt\\n\\tcur := []int32{0}\\n\\tvar next []int32\\n\\tfor len(cur) != 0 {\\n\\t\\tfor _, parent := range cur {\\n\\t\\t\\tleaf := true\\n\\t\\t\\tfor _, child := range parentToChildren[parent] {\\n\\t\\t\\t\\tif parents[child] != parent {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleaf = false\\n\\t\\t\\t\\tamount[child] += amount[parent]\\n\\t\\t\\t\\tnext = append(next, child)\\n\\t\\t\\t}\\n\\t\\t\\tif leaf {\\n\\t\\t\\t\\tresult = max(result, amount[parent])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcur, next = next, cur[:0]\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2814835,
                "title": "python3-two-dfs-traversal-explanation",
                "content": "# Intuition\\nWhichever node bob reaches first will make amount 0 for alice and node which they reach simultaneously will make amount = amount / 2.\\n\\n# Approach\\n1. Find all nodes distance from node 0. that is starting node for alice.\\n2. Find parent of all nodes starting from node 0 because this will help bob reach node 0 directly.\\n3. now start dfs from node Bob and compare current distance with distance calculated for alice and update amount accordingly.\\n4. Run dfs 1 more time starting from node 0 and check for maximum path sum from node 0 to any leaf node.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = len(amount)\\n        parent = [-1 for i in range(n)]\\n        dist = [0 for i in range(n)]\\n        graph = [[] for i in range(n)]\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        def findDistance(curr,currParent):\\n            for it in graph[curr]:\\n                if it!=currParent:\\n                    dist[it] = dist[curr] + 1\\n                    findDistance(it,curr)\\n                    parent[it] = curr\\n            return\\n        def modifyCost(currBob,currDist):\\n            while currBob!=0:\\n                if currDist < dist[currBob]:\\n                    amount[currBob] = 0\\n                elif currDist == dist[currBob]:\\n                    amount[currBob] = amount[currBob]//2\\n                currBob = parent[currBob]\\n                currDist+=1\\n            return\\n        def findMaxProfitPath(curr,currParent):\\n            if len(graph[curr]) == 1 and curr > 0:\\n                return amount[curr]\\n            val = -math.inf\\n            for it in graph[curr]:\\n                if it!=currParent:\\n                    val = max(val,findMaxProfitPath(it,curr))\\n            return val + amount[curr] \\n                    \\n        findDistance(0,-1)\\n        modifyCost(bob,0)\\n        return findMaxProfitPath(0,-1)\\n        \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\\n        n = len(amount)\\n        parent = [-1 for i in range(n)]\\n        dist = [0 for i in range(n)]\\n        graph = [[] for i in range(n)]\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        def findDistance(curr,currParent):\\n            for it in graph[curr]:\\n                if it!=currParent:\\n                    dist[it] = dist[curr] + 1\\n                    findDistance(it,curr)\\n                    parent[it] = curr\\n            return\\n        def modifyCost(currBob,currDist):\\n            while currBob!=0:\\n                if currDist < dist[currBob]:\\n                    amount[currBob] = 0\\n                elif currDist == dist[currBob]:\\n                    amount[currBob] = amount[currBob]//2\\n                currBob = parent[currBob]\\n                currDist+=1\\n            return\\n        def findMaxProfitPath(curr,currParent):\\n            if len(graph[curr]) == 1 and curr > 0:\\n                return amount[curr]\\n            val = -math.inf\\n            for it in graph[curr]:\\n                if it!=currParent:\\n                    val = max(val,findMaxProfitPath(it,curr))\\n            return val + amount[curr] \\n                    \\n        findDistance(0,-1)\\n        modifyCost(bob,0)\\n        return findMaxProfitPath(0,-1)\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814011,
                "title": "if-you-still-can-t-understand-the-high-vote-solution-here-re-some-key-points-might-helpful-to-you",
                "content": "# Code\\n```\\n/*\\n    1. Undirected\\n        -> adjacent list should add for two direction\\n    2. Input must form a valid tree\\n        -> No cyclic\\n        -> Take 0 as root -> Directed Graph\\n\\n    DAG (Directed acyclic graph)\\n    1. Bob only have one path to root -> we no need the whole tree, just need the parent links\\n    2. No inlimited traversal as recursive is directed and must end at leaf (no need visited set)\\n */\\n\\nclass Solution {\\n    var adjacentList = [Int: [Int]]()\\n    var parentLinks = [Int: Int]()\\n    var bobPath = [Int]()\\n    var amount = [Int]()\\n    var nodeDepth = [Int: Int]() // for update amount\\n    \\n    func mostProfitablePath(_ edges: [[Int]], _ bob: Int, _ amount: [Int]) -> Int {\\n        self.amount = amount\\n        updateAdjacentList(edges)\\n        updateParentLinks()\\n        updateBotPath(from: bob)\\n        updateAmount()\\n        return getAliceProfit()\\n    }\\n    \\n    func updateAdjacentList(_ edges: [[Int]]) {\\n        adjacentList.removeAll() // clear status for next test case\\n        for edge in edges {\\n            adjacentList[edge[0], default: []].append(edge[1])\\n            adjacentList[edge[1], default: []].append(edge[0])\\n        }\\n    }\\n    \\n    // The explain for why need depth paramter in the below method `updateAmount()`\\n    func updateParentLinks(vertex: Int = 0, parent: Int? = nil, depth: Int = 0) {\\n        if vertex == 0 {\\n            nodeDepth.removeAll()\\n            parentLinks.removeAll()\\n        }\\n        nodeDepth[vertex] = depth\\n        if let parent = parent {\\n            parentLinks[vertex] = parent\\n        }\\n        for next in adjacentList[vertex, default: []] {\\n            // although input is guarantee acyclic, but the adjacentList we build is undirected\\n            // skip the backward traversal to parent\\n            if next != parent {\\n                updateParentLinks(vertex: next, parent: vertex, depth: depth+1)    \\n            }\\n        }\\n    }\\n    \\n    // The bulild path is not safe guarantee\\n    // it works based on the assumption: parentLinks and graph are valid\\n    // must exist the path from bot to root, and no cyclic edge in the graph\\n    func updateBotPath(from bob: Int) {\\n        bobPath.removeAll()\\n        var pivot = bob\\n        while pivot != 0, let parent = parentLinks[pivot] {\\n            bobPath.append(pivot)\\n            pivot = parent\\n        }\\n        bobPath.append(0)\\n    }\\n    \\n    // The input constraints let us can udpate the amount first without dynamic check in each of Alice game\\n    // because there\\'s no second path could arrive the same vertex in the graph from root (Alice start)\\n    // analogy binbary tree, from root to any node only exist same path\\n    func updateAmount() {\\n        for bobSteps in 0..<bobPath.count {\\n            let vertex = bobPath[bobSteps]\\n            guard let aliceSteps = nodeDepth[vertex] else {\\n                fatalError(\"invalie input\")\\n            }\\n            if bobSteps == aliceSteps {\\n                amount[vertex] /= 2\\n            } else if bobSteps < aliceSteps {\\n                amount[vertex] = 0\\n            }\\n        }\\n    }\\n    \\n    /*\\n     If we didn\\'t do updateAmount at first\\n     we have to pass an increasing parameter `steps`\\n     and check the profit everytime, ex:\\n     ````\\n        var profit: Int = {\\n            if steps < bobPath.count {\\n                if bobPath[steps] == vertex {\\n                    return amount[vertex] / 2\\n                } else if bobPath[..<steps].contains(vertex) {\\n                    return 0\\n                }\\n            }\\n            return amount[vertex]\\n        }()\\n     ````\\n     */\\n    func getAliceProfit( _ vertex: Int = 0) -> Int {\\n        let profit = amount[vertex]\\n        var maxSubProfit = Int.min\\n        for next in adjacentList[vertex, default: []] {\\n            if next == parentLinks[vertex] {\\n                continue\\n            }\\n            maxSubProfit = max(\\n                maxSubProfit, \\n                getAliceProfit(next)\\n            )\\n        }\\n        if maxSubProfit > Int.min {\\n            return profit + maxSubProfit\\n        } else {\\n            return profit    \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/*\\n    1. Undirected\\n        -> adjacent list should add for two direction\\n    2. Input must form a valid tree\\n        -> No cyclic\\n        -> Take 0 as root -> Directed Graph\\n\\n    DAG (Directed acyclic graph)\\n    1. Bob only have one path to root -> we no need the whole tree, just need the parent links\\n    2. No inlimited traversal as recursive is directed and must end at leaf (no need visited set)\\n */\\n\\nclass Solution {\\n    var adjacentList = [Int: [Int]]()\\n    var parentLinks = [Int: Int]()\\n    var bobPath = [Int]()\\n    var amount = [Int]()\\n    var nodeDepth = [Int: Int]() // for update amount\\n    \\n    func mostProfitablePath(_ edges: [[Int]], _ bob: Int, _ amount: [Int]) -> Int {\\n        self.amount = amount\\n        updateAdjacentList(edges)\\n        updateParentLinks()\\n        updateBotPath(from: bob)\\n        updateAmount()\\n        return getAliceProfit()\\n    }\\n    \\n    func updateAdjacentList(_ edges: [[Int]]) {\\n        adjacentList.removeAll() // clear status for next test case\\n        for edge in edges {\\n            adjacentList[edge[0], default: []].append(edge[1])\\n            adjacentList[edge[1], default: []].append(edge[0])\\n        }\\n    }\\n    \\n    // The explain for why need depth paramter in the below method `updateAmount()`\\n    func updateParentLinks(vertex: Int = 0, parent: Int? = nil, depth: Int = 0) {\\n        if vertex == 0 {\\n            nodeDepth.removeAll()\\n            parentLinks.removeAll()\\n        }\\n        nodeDepth[vertex] = depth\\n        if let parent = parent {\\n            parentLinks[vertex] = parent\\n        }\\n        for next in adjacentList[vertex, default: []] {\\n            // although input is guarantee acyclic, but the adjacentList we build is undirected\\n            // skip the backward traversal to parent\\n            if next != parent {\\n                updateParentLinks(vertex: next, parent: vertex, depth: depth+1)    \\n            }\\n        }\\n    }\\n    \\n    // The bulild path is not safe guarantee\\n    // it works based on the assumption: parentLinks and graph are valid\\n    // must exist the path from bot to root, and no cyclic edge in the graph\\n    func updateBotPath(from bob: Int) {\\n        bobPath.removeAll()\\n        var pivot = bob\\n        while pivot != 0, let parent = parentLinks[pivot] {\\n            bobPath.append(pivot)\\n            pivot = parent\\n        }\\n        bobPath.append(0)\\n    }\\n    \\n    // The input constraints let us can udpate the amount first without dynamic check in each of Alice game\\n    // because there\\'s no second path could arrive the same vertex in the graph from root (Alice start)\\n    // analogy binbary tree, from root to any node only exist same path\\n    func updateAmount() {\\n        for bobSteps in 0..<bobPath.count {\\n            let vertex = bobPath[bobSteps]\\n            guard let aliceSteps = nodeDepth[vertex] else {\\n                fatalError(\"invalie input\")\\n            }\\n            if bobSteps == aliceSteps {\\n                amount[vertex] /= 2\\n            } else if bobSteps < aliceSteps {\\n                amount[vertex] = 0\\n            }\\n        }\\n    }\\n    \\n    /*\\n     If we didn\\'t do updateAmount at first\\n     we have to pass an increasing parameter `steps`\\n     and check the profit everytime, ex:\\n     ```\n````\\n     */\\n    func getAliceProfit( _ vertex: Int = 0) -> Int {\\n        let profit = amount[vertex]\\n        var maxSubProfit = Int.min\\n        for next in adjacentList[vertex, default: []] {\\n            if next == parentLinks[vertex] {\\n                continue\\n            }\\n            maxSubProfit = max(\\n                maxSubProfit, \\n                getAliceProfit(next)\\n            )\\n        }\\n        if maxSubProfit > Int.min {\\n            return profit + maxSubProfit\\n        } else {\\n            return profit    \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813626,
                "title": "c-two-dfs-beginners-clean-code-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First DFS: Find the fixed path to node `0` of Bob.\\n- Second DFS: Simulate Alice and Bob moving at the same time, find the max income of Alice. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        vector<vector<int>> graph(n);\\n        for (auto edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        // DFS: find the fixed path to node 0 of Bob\\n        visited = vector<bool>(n, false);\\n        dfsBob(graph, bob, 0);\\n        // DFS: find the max income of Alice\\n        visited = vector<bool>(n, false);\\n        dfsAlice(graph, 0, 0, amount);\\n        return maxIncome;\\n        \\n    }\\nprivate:\\n    vector<int> bobPath;\\n    vector<bool> visited;\\n    bool dfsBob(vector<vector<int>>& graph, int cur, int target) {\\n        if (cur == target) {\\n            bobPath.push_back(cur);\\n            return true;\\n        }\\n        visited[cur] = true;\\n        bobPath.push_back(cur);\\n        for (int v : graph[cur]) {\\n            if (!visited[v] && dfsBob(graph, v, target)) return true;\\n        }\\n        visited[cur] = false;\\n        bobPath.pop_back();\\n        return false;\\n    }\\n    \\n    vector<int> res;\\n    int maxIncome = INT_MIN;\\n    int pathIncome = 0;\\n    void dfsAlice(vector<vector<int>>& graph, int cur, int step, vector<int>& amount) {\\n        // Detemine if cur is a leaf\\n        bool leaf = true;\\n        for (int i = 0; i < graph[cur].size(); i++) {\\n            if (!visited[graph[cur][i]]) leaf = false;\\n        }\\n        if (leaf) {\\n            pathIncome += amount[cur];\\n            maxIncome = max(pathIncome, maxIncome);\\n            pathIncome -= amount[cur];\\n            return;\\n        }\\n        // Update income and amount by location of Alice and Bob\\n        visited[cur] = true;\\n        int curIncome = amount[cur];\\n        int curOldAmount = amount[cur];\\n        int bob, bobOldAmount;\\n        if (step < bobPath.size()) {\\n            bob = bobPath[step];\\n            if (bob == cur) curIncome /= 2;\\n            bobOldAmount = amount[bob];\\n            amount[bob] = 0;\\n        }\\n        pathIncome += curIncome;\\n        amount[cur] = 0;\\n        // Move to next step\\n        for (int v : graph[cur]) {\\n            if (!visited[v]) dfsAlice(graph, v, step + 1, amount);\\n        }\\n        // backtracking\\n        visited[cur] = false;\\n        pathIncome -= curIncome;\\n        amount[cur] = curOldAmount;\\n        if (step < bobPath.size()) amount[bob] = bobOldAmount;\\n    }  \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\\n        int n = amount.size();\\n        vector<vector<int>> graph(n);\\n        for (auto edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        // DFS: find the fixed path to node 0 of Bob\\n        visited = vector<bool>(n, false);\\n        dfsBob(graph, bob, 0);\\n        // DFS: find the max income of Alice\\n        visited = vector<bool>(n, false);\\n        dfsAlice(graph, 0, 0, amount);\\n        return maxIncome;\\n        \\n    }\\nprivate:\\n    vector<int> bobPath;\\n    vector<bool> visited;\\n    bool dfsBob(vector<vector<int>>& graph, int cur, int target) {\\n        if (cur == target) {\\n            bobPath.push_back(cur);\\n            return true;\\n        }\\n        visited[cur] = true;\\n        bobPath.push_back(cur);\\n        for (int v : graph[cur]) {\\n            if (!visited[v] && dfsBob(graph, v, target)) return true;\\n        }\\n        visited[cur] = false;\\n        bobPath.pop_back();\\n        return false;\\n    }\\n    \\n    vector<int> res;\\n    int maxIncome = INT_MIN;\\n    int pathIncome = 0;\\n    void dfsAlice(vector<vector<int>>& graph, int cur, int step, vector<int>& amount) {\\n        // Detemine if cur is a leaf\\n        bool leaf = true;\\n        for (int i = 0; i < graph[cur].size(); i++) {\\n            if (!visited[graph[cur][i]]) leaf = false;\\n        }\\n        if (leaf) {\\n            pathIncome += amount[cur];\\n            maxIncome = max(pathIncome, maxIncome);\\n            pathIncome -= amount[cur];\\n            return;\\n        }\\n        // Update income and amount by location of Alice and Bob\\n        visited[cur] = true;\\n        int curIncome = amount[cur];\\n        int curOldAmount = amount[cur];\\n        int bob, bobOldAmount;\\n        if (step < bobPath.size()) {\\n            bob = bobPath[step];\\n            if (bob == cur) curIncome /= 2;\\n            bobOldAmount = amount[bob];\\n            amount[bob] = 0;\\n        }\\n        pathIncome += curIncome;\\n        amount[cur] = 0;\\n        // Move to next step\\n        for (int v : graph[cur]) {\\n            if (!visited[v]) dfsAlice(graph, v, step + 1, amount);\\n        }\\n        // backtracking\\n        visited[cur] = false;\\n        pathIncome -= curIncome;\\n        amount[cur] = curOldAmount;\\n        if (step < bobPath.size()) amount[bob] = bobOldAmount;\\n    }  \\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1711082,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1827922,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1681163,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1772279,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1742334,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1681355,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1740996,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1690592,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 2058264,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 2038800,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1711082,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1827922,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1681163,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1772279,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1742334,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1681355,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1740996,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 1690592,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 2058264,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            },
            {
                "id": 2038800,
                "content": [
                    {
                        "username": "djslim",
                        "content": "This one should be marked hard"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "what if Alice and Bob reach the same door at the same time and fall in love with each other and never leave...?"
                    },
                    {
                        "username": "ironblade",
                        "content": "return child;"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Any suggestions on similar problems i can try before this?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "1. Try Dfs to find path between source and destination in a graph which have tree like structure (n-1) edges.\\n2. Try maximum path sum (using bfs ) between root and any leaf node in a graph which have tree like structure (n-1) edges.\\n3. then in the current problem you just have to follow the  condition and rule to collect rewards to reach the leaf node for Alice. \\nNOTE: whenever there is  graph which have tree like structure having (n-1) edges always have a single path between any  two nodes.\\n don\\'t be confused that there might be many path ( as we generally have in graph problems)."
                    },
                    {
                        "username": "AkhilSharma24",
                        "content": "Why this question is in medium level ?\\nThis is of hard level for sure"
                    },
                    {
                        "username": "asif_star_135",
                        "content": "Guyss....!!\\nLiterally this one is quite interesting and logical.... If you can think the approach, then you got it.. \\uD83D\\uDC4D\\nHere\\'s a goof tip :- You should move bob towards the root and save the time stamp in a vector/map, then travarse alice and compatre the time.."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\\nis the bob take path with maximum profit or just take shortest path to reach at 0??"
                    },
                    {
                        "username": "cpcdevar",
                        "content": "Please see this discussion post on mass cheating in Biweekly Contest 91 and kindly upvote it for LeetCode to notice.\\n[https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307](https://leetcode.com/discuss/general-discussion/2807133/Biweekly-Contest-91/1681307)"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can Alice or bob move back to their visited path"
                    },
                    {
                        "username": "terminator9788",
                        "content": "No. Any node must be visited only once in their respective path. "
                    },
                    {
                        "username": "dankCoder007",
                        "content": "At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. \\n"
                    },
                    {
                        "username": "user7784J",
                        "content": "I really think this question is kinda hard for \"medium\" as both are moving with the same pace + its a tree so there multiple options where Alice can end up (but needs to make max rewards)\\n\\nProbably this is less hard as there is no restrictions on bob (like no step count or max-min he can spend/ earn). Not sure. \\n\\nWhat do you guys think ?? \\n"
                    },
                    {
                        "username": "Kumar_11",
                        "content": "It\\'s an medium problem i think, Because there is only two type of of paths for alice and only one path for bob.\\nSo we can solve both cases separately"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Once you understand how alice and bob could move then it\\'s not hard to come up with the solution. But it was hard for me to get `At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.`\\nI had a time thought alice can go back to the previous node and get reward in some other path."
                    },
                    {
                        "username": "ZijiaDavid",
                        "content": "What happens if Bob has two upper nodes?  I think it is kind of ambiguous about the path that Bob take, is he aiming for maximizing his own profit or minimizing Alex\\'s profit?"
                    }
                ]
            }
        ]
    }
]