[
    {
        "title": "Generate Parentheses",
        "question_content": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n&nbsp;\nExample 1:\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\nExample 2:\nInput: n = 1\nOutput: [\"()\"]\n&nbsp;\nConstraints:\n\n\t1 <= n <= 8",
        "solutions": [
            {
                "id": 10100,
                "title": "easy-to-understand-java-backtracking-solution",
                "content": "     public List<String> generateParenthesis(int n) {\\n            List<String> list = new ArrayList<String>();\\n            backtrack(list, \"\", 0, 0, n);\\n            return list;\\n        }\\n        \\n        public void backtrack(List<String> list, String str, int open, int close, int max){\\n            \\n            if(str.length() == max*2){\\n                list.add(str);\\n                return;\\n            }\\n            \\n            if(open < max)\\n                backtrack(list, str+\"(\", open+1, close, max);\\n            if(close < open)\\n                backtrack(list, str+\")\", open, close+1, max);\\n        }\\n\\nThe idea here is to only add '(' and ')' that we know will guarantee us a solution (instead of adding 1 too many close). Once we add a '(' we will then discard it and try a ')' which can only close a valid '('. Each of these steps are recursively called.",
                "solutionTags": [
                    "Java"
                ],
                "code": "     public List<String> generateParenthesis(int n) {\\n            List<String> list = new ArrayList<String>();\\n            backtrack(list, \"\", 0, 0, n);\\n            return list;\\n        }\\n        \\n        public void backtrack(List<String> list, String str, int open, int close, int max){\\n            \\n            if(str.length() == max*2){\\n                list.add(str);\\n                return;\\n            }\\n            \\n            if(open < max)\\n                backtrack(list, str+\"(\", open+1, close, max);\\n            if(close < open)\\n                backtrack(list, str+\")\", open, close+1, max);\\n        }\\n\\nThe idea here is to only add '(' and ')' that we know will guarantee us a solution (instead of adding 1 too many close). Once we add a '(' we will then discard it and try a ')' which can only close a valid '('. Each of these steps are recursively called.",
                "codeTag": "Unknown"
            },
            {
                "id": 2542620,
                "title": "python-java-w-explanation-faster-than-96-w-proof-easy-to-understand",
                "content": "1. The idea is to add `\\')\\'` only after valid `\\'(\\'`\\n2. We use two integer variables `left` & `right` to see how many `\\'(\\'` & `\\')\\'` are in the current string\\n3. If `left < n` then we can add `\\'(\\'` to the current string\\n4. If `right < left` then we can add `\\')\\'` to the current string\\n\\n**Python Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tdef dfs(left, right, s):\\n\\t\\tif len(s) == n * 2:\\n\\t\\t\\tres.append(s)\\n\\t\\t\\treturn \\n\\n\\t\\tif left < n:\\n\\t\\t\\tdfs(left + 1, right, s + \\'(\\')\\n\\n\\t\\tif right < left:\\n\\t\\t\\tdfs(left, right + 1, s + \\')\\')\\n\\n\\tres = []\\n\\tdfs(0, 0, \\'\\')\\n\\treturn res\\n```\\n\\nFor` n = 2`, the recursion tree will be something like this,\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\t(0, 0, \\'\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t \\t    |\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(1, 0, \\'(\\')  \\n\\t\\t\\t\\t\\t\\t\\t\\t   /           \\\\\\n\\t\\t\\t\\t\\t\\t\\t(2, 0, \\'((\\')      (1, 1, \\'()\\')\\n\\t\\t\\t\\t\\t\\t\\t   /                 \\\\\\n\\t\\t\\t\\t\\t\\t(2, 1, \\'(()\\')           (2, 1, \\'()(\\')\\n\\t\\t\\t\\t\\t\\t   /                       \\\\\\n\\t\\t\\t\\t\\t(2, 2, \\'(())\\')                (2, 2, \\'()()\\')\\n\\t\\t\\t\\t\\t\\t      |\\t                             |\\n\\t\\t\\t\\t\\tres.append(\\'(())\\')             res.append(\\'()()\\')\\n   \\n```\\n\\n**Java Code:**\\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        recurse(res, 0, 0, \"\", n);\\n        return res;\\n    }\\n    \\n    public void recurse(List<String> res, int left, int right, String s, int n) {\\n        if (s.length() == n * 2) {\\n            res.add(s);\\n            return;\\n        }\\n        \\n        if (left < n) {\\n            recurse(res, left + 1, right, s + \"(\", n);\\n        }\\n        \\n        if (right < left) {\\n            recurse(res, left, right + 1, s + \")\", n);\\n        }\\n    }\\n\\t// See above tree diagram with parameters (left, right, s) for better understanding\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/7df8c537-35e6-42a5-8b91-e2f6ec9031d0_1662519743.7174962.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/227fc269-7b54-4e64-b490-66e6154a40cd_1662518370.2619233.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tdef dfs(left, right, s):\\n\\t\\tif len(s) == n * 2:\\n\\t\\t\\tres.append(s)\\n\\t\\t\\treturn \\n\\n\\t\\tif left < n:\\n\\t\\t\\tdfs(left + 1, right, s + \\'(\\')\\n\\n\\t\\tif right < left:\\n\\t\\t\\tdfs(left, right + 1, s + \\')\\')\\n\\n\\tres = []\\n\\tdfs(0, 0, \\'\\')\\n\\treturn res\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\t(0, 0, \\'\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t \\t    |\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(1, 0, \\'(\\')  \\n\\t\\t\\t\\t\\t\\t\\t\\t   /           \\\\\\n\\t\\t\\t\\t\\t\\t\\t(2, 0, \\'((\\')      (1, 1, \\'()\\')\\n\\t\\t\\t\\t\\t\\t\\t   /                 \\\\\\n\\t\\t\\t\\t\\t\\t(2, 1, \\'(()\\')           (2, 1, \\'()(\\')\\n\\t\\t\\t\\t\\t\\t   /                       \\\\\\n\\t\\t\\t\\t\\t(2, 2, \\'(())\\')                (2, 2, \\'()()\\')\\n\\t\\t\\t\\t\\t\\t      |\\t                             |\\n\\t\\t\\t\\t\\tres.append(\\'(())\\')             res.append(\\'()()\\')\\n   \\n```\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        recurse(res, 0, 0, \"\", n);\\n        return res;\\n    }\\n    \\n    public void recurse(List<String> res, int left, int right, String s, int n) {\\n        if (s.length() == n * 2) {\\n            res.add(s);\\n            return;\\n        }\\n        \\n        if (left < n) {\\n            recurse(res, left + 1, right, s + \"(\", n);\\n        }\\n        \\n        if (right < left) {\\n            recurse(res, left, right + 1, s + \")\", n);\\n        }\\n    }\\n\\t// See above tree diagram with parameters (left, right, s) for better understanding\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10105,
                "title": "concise-recursive-c-solution",
                "content": "The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n >0 and add a right parenthesis if m>0. Append the result and terminate recursive calls when both m and n are zero.\\n\\n    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> res;\\n            addingpar(res, \"\", n, 0);\\n            return res;\\n        }\\n        void addingpar(vector<string> &v, string str, int n, int m){\\n            if(n==0 && m==0) {\\n                v.push_back(str);\\n                return;\\n            }\\n            if(m > 0){ addingpar(v, str+\")\", n, m-1); }\\n            if(n > 0){ addingpar(v, str+\"(\", n-1, m+1); }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> res;\\n            addingpar(res, \"\", n, 0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 10096,
                "title": "4-7-lines-python",
                "content": "`p` is the parenthesis-string built so far, `left` and `right` tell the number of left and right parentheses still to add, and `parens` collects the parentheses.\\n\\n**Solution 1**\\n\\nI used a few \"tricks\"... how many can you find? :-)\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right, parens=[]):\\n            if left:         generate(p + '(', left-1, right)\\n            if right > left: generate(p + ')', left, right-1)\\n            if not right:    parens += p,\\n            return parens\\n        return generate('', n, n)\\n\\n**Solution 2**\\n\\nHere I wrote an actual Python generator. I allow myself to put the `yield q` at the end of the line because it's not that bad and because in \"real life\" I use Python 3 where I just say `yield from generate(...)`.\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right):\\n            if right >= left >= 0:\\n                if not right:\\n                    yield p\\n                for q in generate(p + '(', left-1, right): yield q\\n                for q in generate(p + ')', left, right-1): yield q\\n        return list(generate('', n, n))\\n\\n**Solution 3**\\n\\nImproved version of [this](https://leetcode.com/discuss/25725/7-lines-in-python-44-ms). Parameter `open` tells the number of \"already opened\" parentheses, and I continue the recursion as long as I still have to open parentheses (`n > 0`) and I haven't made a mistake yet (`open >= 0`).\\n\\n    def generateParenthesis(self, n, open=0):\\n        if n > 0 <= open:\\n            return ['(' + p for p in self.generateParenthesis(n-1, open+1)] + \\\\\\n                   [')' + p for p in self.generateParenthesis(n, open-1)]\\n        return [')' * open] * (not n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "`p` is the parenthesis-string built so far, `left` and `right` tell the number of left and right parentheses still to add, and `parens` collects the parentheses.\\n\\n**Solution 1**\\n\\nI used a few \"tricks\"... how many can you find? :-)\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right, parens=[]):\\n            if left:         generate(p + '(', left-1, right)\\n            if right > left: generate(p + ')', left, right-1)\\n            if not right:    parens += p,\\n            return parens\\n        return generate('', n, n)\\n\\n**Solution 2**\\n\\nHere I wrote an actual Python generator. I allow myself to put the `yield q` at the end of the line because it's not that bad and because in \"real life\" I use Python 3 where I just say `yield from generate(...)`.\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right):\\n            if right >= left >= 0:\\n                if not right:\\n                    yield p\\n                for q in generate(p + '(', left-1, right): yield q\\n                for q in generate(p + ')', left, right-1): yield q\\n        return list(generate('', n, n))\\n\\n**Solution 3**\\n\\nImproved version of [this](https://leetcode.com/discuss/25725/7-lines-in-python-44-ms). Parameter `open` tells the number of \"already opened\" parentheses, and I continue the recursion as long as I still have to open parentheses (`n > 0`) and I haven't made a mistake yet (`open >= 0`).\\n\\n    def generateParenthesis(self, n, open=0):\\n        if n > 0 <= open:\\n            return ['(' + p for p in self.generateParenthesis(n-1, open+1)] + \\\\\\n                   [')' + p for p in self.generateParenthesis(n, open-1)]\\n        return [')' * open] * (not n)",
                "codeTag": "Python3"
            },
            {
                "id": 10127,
                "title": "an-iterative-method",
                "content": "My method is DP. First consider how to get the result f(n) from previous result f(0)...f(n-1).\\nActually, the result f(n) will be put an extra () pair to f(n-1). Let the \"(\" always at the first position, to produce a valid result, we can only put \")\" in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair.\\n\\nLet us consider an example to get clear view:\\n\\nf(0):  \"\"\\n\\nf(1):  \"(\"f(0)\")\"\\n\\nf(2): \"(\"f(0)\")\"f(1), \"(\"f(1)\")\"\\n\\nf(3): \"(\"f(0)\")\"f(2), \"(\"f(1)\")\"f(1), \"(\"f(2)\")\"\\n\\nSo f(n) = \"(\"f(0)\")\"f(n-1) , \"(\"f(1)\")\"f(n-2) \"(\"f(2)\")\"f(n-3) ... \"(\"f(i)\")\"f(n-1-i) ... \"(f(n-1)\")\"\\n\\nBelow is my code:\\n\\n    public class Solution\\n    {\\n        public List<String> generateParenthesis(int n)\\n        {\\n            List<List<String>> lists = new ArrayList<>();\\n            lists.add(Collections.singletonList(\"\"));\\n            \\n            for (int i = 1; i <= n; ++i)\\n            {\\n                final List<String> list = new ArrayList<>();\\n                \\n                for (int j = 0; j < i; ++j)\\n                {\\n                    for (final String first : lists.get(j))\\n                    {\\n                        for (final String second : lists.get(i - 1 - j))\\n                        {\\n                            list.add(\"(\" + first + \")\" + second);\\n                        }\\n                    }\\n                }\\n                \\n                lists.add(list);\\n            }\\n            \\n            return lists.get(lists.size() - 1);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution\\n    {\\n        public List<String> generateParenthesis(int n)\\n        {\\n            List<List<String>> lists = new ArrayList<>();\\n            lists.add(Collections.singletonList(\"\"));\\n            \\n            for (int i = 1; i <= n; ++i)\\n            {\\n                final List<String> list = new ArrayList<>();\\n                \\n                for (int j = 0; j < i; ++j)\\n                {\\n                    for (final String first : lists.get(j))\\n                    {\\n                        for (final String second : lists.get(i - 1 - j))\\n                        {\\n                            list.add(\"(\" + first + \")\" + second);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 10369,
                "title": "clean-python-dp-solution",
                "content": "To generate all n-pair parentheses, we can do the following:\\n\\n1. Generate one pair: ()\\n2. Generate 0 pair inside, n - 1 afterward: () (...)...\\n\\n    Generate 1 pair inside, n - 2 afterward: (()) (...)...\\n\\n    ...\\n\\n    Generate n - 1 pair inside, 0 afterward: ((...)) \\n\\nI bet you see the overlapping subproblems here. Here is the code:\\n\\n(you could see in the code that `x` represents one j-pair solution and `y` represents one (i - j - 1) pair solution, and we are taking into account all possible of combinations of them)\\n\\n    class Solution(object):\\n        def generateParenthesis(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: List[str]\\n            \"\"\"\\n            dp = [[] for i in range(n + 1)]\\n            dp[0].append('')\\n            for i in range(n + 1):\\n                for j in range(i):\\n                    dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]]\\n            return dp[n]",
                "solutionTags": [],
                "code": "To generate all n-pair parentheses, we can do the following:\\n\\n1. Generate one pair: ()\\n2. Generate 0 pair inside, n - 1 afterward: () (...)...\\n\\n    Generate 1 pair inside, n - 2 afterward: (()) (...)...\\n\\n    ...\\n\\n    Generate n - 1 pair inside, 0 afterward: ((...)) \\n\\nI bet you see the overlapping subproblems here. Here is the code:\\n\\n(you could see in the code that `x` represents one j-pair solution and `y` represents one (i - j - 1) pair solution, and we are taking into account all possible of combinations of them)\\n\\n    class Solution(object):\\n        def generateParenthesis(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: List[str]\\n            \"\"\"\\n            dp = [[] for i in range(n + 1)]\\n            dp[0].append('')\\n            for i in range(n + 1):\\n                for j in range(i):\\n                    dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]]\\n            return dp[n]",
                "codeTag": "Java"
            },
            {
                "id": 1131364,
                "title": "clear-and-simple-explanation-with-intuition-100-faster",
                "content": "**Intuition:** Since we are asked to calculate all the possible permutations of brackets , hence we have to use backtracking\\n\\n**Concept:** In every backtracking problem , there are two things to keep in mind , which we will explore here as well :\\n*  Base Case: Every problem of backtracking has some base case which tells us at which point we have to stop with the recursion process. In our case, when the length of our string has reached the maximum length(`n*2`), we stop with the recursion for that case and that is our base case.\\n\\n*   Conditions: On observing carefully we find that there are two conditions present:\\n    *  For adding **`(`**:  If number of opening brackets(`open`) is less than the the given length(`n`) i.e.\\n        if `max`<`n`, then we can add **`(`**,else not.\\n\\t*  For adding **`)`**: If number of close brackets(`close`) is less than the opening brackets(`open`), i.e.\\n\\t    if `open`<`close`, we can add **`)`**, else not\\n\\t\\t\\nAnd thats it!!! Keeping these two things in mind here is the code: \\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string>result;\\n    \\n    void helper(int open,int close,int n,string current)\\n    {\\n        if(current.length()==n*2)\\n        {\\n            result.push_back(current);\\n            return;\\n        }\\n        if(open<n)  helper(open+1,close,n,current+\"(\");\\n        if(close<open)  helper(open,close+1,n,current+\")\");\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        helper(0,0,n,\"\");\\n        return result;\\n    }\\n};\\n```\\n\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**\\nHappy Coding :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>result;\\n    \\n    void helper(int open,int close,int n,string current)\\n    {\\n        if(current.length()==n*2)\\n        {\\n            result.push_back(current);\\n            return;\\n        }\\n        if(open<n)  helper(open+1,close,n,current+\"(\");\\n        if(close<open)  helper(open,close+1,n,current+\")\");\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        helper(0,0,n,\"\");\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290261,
                "title": "i-bet-you-will-understand-intutive-solution-beginner-friendly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is one of the classical recursion problems. \\nFor any given n, lets say n = 2, we have to fill four places in our output (\"_ _ _ _\"). And each of these places can be either filled by an open braces \"(\" or a closed braces \")\". \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n                                    \"_  _  _  _\"\\n                                    / \\\\     \\n                                  \\'(\\' \\')\\'\\n\\nFor every place we have two choices and 1 decision to make. \\nOur choices are to either use \\'(\\' or \\')\\'.\\n\\nNow lets try to visualize the recursive tree based upon the choices discussed above.\\n\\nInitially, we have:\\nFor n = 3\\ncurrent ouput = \"\"\\navailableOpenBracketsCnt = 3 and availableCloseBracketsCnt  = 3\\n\\nThe first choise is very simple. Since we can not start a balanced parenthesis sequence with \\')\\', we have only one choice in the begining. So our output will be \\'(\\' and count of open brackets left = 2 and count of closed brackets left = 3.\\n\\n                                        op      ip\\n                                        \"\"   O-3, C-3\\n                                \\n                                        \"(\",O-2,C-3\\n                        \\n                    \"((\",O-1,C-3                            \"()\", O-2,C-2\\n\\n        \"(((\",0,3             \"(()\",1,2                       \"()(\",1,2\\n\\n        \"((()\",0,2      \"(()(\",0,2    \"(())\",1,1        \"()((\",0,2      \"()()\",1,1\\n\\n        \"((())\",0,1     \"(()()\",0,1   \"(())(\",0,1       \"()(()\",0,1     \"()()(\",0,1\\n\\n        \"((()))\",0,0   \"(()())\",0,0   \"(())()\",0,0      \"()(())\",0,0    \"()()()\", 0,0\\n                            \\n\\n# Observation from the recursive tree\\n\\n - Whenever we have count of open brackets equal to the count of close brackets, we have only one choice - that is to use \\'(\\'. Because, all the brackets till now have been balanced. And we can not start a new sequence with \\')\\'. \\n - Whenever, count of close bracket is 0, we can only use \\'(\\'.\\n - Whenever, count of open bracket is 0, we can only use \\')\\'.\\n - And for all the remaining cases, we have both the choices.\\n - We get an answer, when count of open == 0 and count of close == 0.\\n\\nJust convert these 5 observations into an algorithm and write the code. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```\\n**Note** : I have kept the code implementation simple by just following the observations I mentioned. The same code can be made more compact by reducing some conditional statements (although the time and space complexity will remain the same).\\nTry to come up with your own compact version. Refer the comments of other peers for help.\\n\\n# Complexity Analysis: \\n- Time Complexity : $O(N*2^N)$ where N = 2*n\\n $O(2^N)$ : We have N = 2n places to fill and for every place we will have a maximum of 2 choices. \\n $O(N)$ : We will have to multiply our TC by a factor of N, as every time when we hit the base case, we will copy current op (which is of size N) into the answer vector.\\n- Space Complexity : $O(N)$ + Recursive Stack Space\\n We have used an extra string of size N for storing current output\\n# Please upvote the solution if you understood it.\\n\\n![NRRa.gif](https://assets.leetcode.com/users/images/ac16397a-5dda-46bb-8508-a6caf66f016b_1679243081.1794233.gif)\\n\\n**You can connect with me on linkedin, If you understood my solution :D**\\nhttps://www.linkedin.com/in/imraghavagr/\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10110,
                "title": "simple-python-dfs-solution-with-explanation",
                "content": "If you have two stacks, one for n \"(\", the other for n \")\", you generate a binary tree from these two stacks of left/right parentheses to form an output string. \\n\\n\\nThis means that whenever you traverse deeper, you pop one parentheses from one of stacks. When two stacks are empty, you form an output string.\\n\\nHow to form a legal string? Here is the simple observation:\\n\\n - For the output string to be right, stack of \")\" most be larger than stack of \"(\". If not, it creates string like \"())\"\\n - Since elements in each of stack are the same, we can simply express them with a number. For example, left = 3 is like a stacks [\"(\", \"(\", \"(\"]\\n\\nSo, here is my sample code in Python:\\n\\n    class Solution:\\n    # @param {integer} n\\n    # @return {string[]}\\n    def generateParenthesis(self, n):\\n        if not n:\\n            return []\\n        left, right, ans = n, n, []\\n        self.dfs(left,right, ans, \"\")\\n        return ans\\n\\n    def dfs(self, left, right, ans, string):\\n        if right < left:\\n            return\\n        if not left and not right:\\n            ans.append(string)\\n            return\\n        if left:\\n            self.dfs(left-1, right, ans, string + \"(\")\\n        if right:\\n            self.dfs(left, right-1, ans, string + \")\")",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 10099,
                "title": "time-complexity-to-generate-all-combinations-of-well-formed-parentheses",
                "content": "Generating all combinations of well formed paranthesis is a typical example of catalan numbers. You can use the links at the bottom here if you are not aware of the catalan numbers since they are at the heart of the exercise.\\nLet time complexity for the generating all combinations of well-formed parentheses is f(n), then\\nf(n) = g(n) * h(n) where g(n) is the time complexity for calculating nth catalan number, and h(n) is the time required to copy this combination to result array.\\nTherefore, f(n) = catalan(n) * O(n) which is O(4^n/n^1.5)*(n)). Broadly saying just remember that this is a typical example of catalan number and it's time complexity is similar to how catalan(n) is got.\\nFurther readings in to catalan numbers:\\nhttps://en.wikipedia.org/wiki/Catalan_number\\nhttps://www.youtube.com/watch?v=GlI17WaMrtw\\nhttps://www.youtube.com/watch?v=eoofvKI_Okg",
                "solutionTags": [],
                "code": "Generating all combinations of well formed paranthesis is a typical example of catalan numbers. You can use the links at the bottom here if you are not aware of the catalan numbers since they are at the heart of the exercise.\\nLet time complexity for the generating all combinations of well-formed parentheses is f(n), then\\nf(n) = g(n) * h(n) where g(n) is the time complexity for calculating nth catalan number, and h(n) is the time required to copy this combination to result array.\\nTherefore, f(n) = catalan(n) * O(n) which is O(4^n/n^1.5)*(n)). Broadly saying just remember that this is a typical example of catalan number and it's time complexity is similar to how catalan(n) is got.\\nFurther readings in to catalan numbers:\\nhttps://en.wikipedia.org/wiki/Catalan_number\\nhttps://www.youtube.com/watch?v=GlI17WaMrtw\\nhttps://www.youtube.com/watch?v=eoofvKI_Okg",
                "codeTag": "Unknown"
            },
            {
                "id": 10283,
                "title": "python-simple-stack-solution-without-recursion",
                "content": "    def generateParenthesis(self, n):\\n        res = []\\n        s = [(\"(\", 1, 0)]\\n        while s:\\n            x, l, r = s.pop()\\n            if l - r < 0 or l > n or r > n:\\n                continue\\n            if l == n and r == n:\\n                res.append(x)\\n            s.append((x+\"(\", l+1, r))\\n            s.append((x+\")\", l, r+1))\\n        return res\\n\\n\\nvariable l is current left parenthesis count\\n\\nvariable r is current right parenthesis count\\n\\nl - r < 0 means this is not a valid parenthesis",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "    def generateParenthesis(self, n):\\n        res = []\\n        s = [(\"(\", 1, 0)]\\n        while s:\\n            x, l, r = s.pop()\\n            if l - r < 0 or l > n or r > n:\\n                continue\\n            if l == n and r == n:\\n                res.append(x)\\n            s.append((x+\"(\", l+1, r))\\n            s.append((x+\")\", l, r+1))\\n        return res\\n\\n\\nvariable l is current left parenthesis count\\n\\nvariable r is current right parenthesis count\\n\\nl - r < 0 means this is not a valid parenthesis",
                "codeTag": "Python3"
            },
            {
                "id": 10098,
                "title": "java-dfs-way-solution",
                "content": "    public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        generateOneByOne(\"\", list, n, n);\\n        return list;\\n    }\\n    public void generateOneByOne(String sublist, List<String> list, int left, int right){\\n        if(left > right){\\n            return;\\n        }\\n        if(left > 0){\\n            generateOneByOne( sublist + \"(\" , list, left-1, right);\\n        }\\n        if(right > 0){\\n            generateOneByOne( sublist + \")\" , list, left, right-1);\\n        }\\n        if(left == 0 && right == 0){\\n            list.add(sublist);\\n            return;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        generateOneByOne(\"\", list, n, n);\\n        return list;\\n    }\\n    public void generateOneByOne(String sublist, List<String> list, int left, int right){\\n        if(left > right){\\n            return;\\n        }\\n        if(left > 0){\\n            generateOneByOne( sublist + \"(\" , list, left-1, right);\\n        }\\n        if(right > 0){\\n            generateOneByOne( sublist + \")\" , list, left, right-1);\\n        }\\n        if(left == 0 && right == 0){\\n            list.add(sublist);\\n            return;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10388,
                "title": "python-easy-to-understand-dfs-solution",
                "content": "        \\n    def generateParenthesis(self, n):\\n        res = []\\n        self.dfs(n, n, \"\", res)\\n        return res\\n            \\n    def dfs(self, leftRemain, rightRemain, path, res):\\n        if leftRemain > rightRemain or leftRemain < 0 or rightRemain < 0:\\n            return  # backtracking\\n        if leftRemain == 0 and rightRemain == 0:\\n            res.append(path)\\n            return \\n        self.dfs(leftRemain-1, rightRemain, path+\"(\", res)\\n        self.dfs(leftRemain, rightRemain-1, path+\")\", res)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "        \\n    def generateParenthesis(self, n):\\n        res = []\\n        self.dfs(n, n, \"\", res)\\n        return res\\n            \\n    def dfs(self, leftRemain, rightRemain, path, res):\\n        if leftRemain > rightRemain or leftRemain < 0 or rightRemain < 0:\\n            return  # backtracking\\n        if leftRemain == 0 and rightRemain == 0:\\n            res.append(path)\\n            return \\n        self.dfs(leftRemain-1, rightRemain, path+\"(\", res)\\n        self.dfs(leftRemain, rightRemain-1, path+\")\", res)",
                "codeTag": "Python3"
            },
            {
                "id": 139455,
                "title": "clean-javascript-backtracking-solution",
                "content": "**Solution 1**\\n\\n```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => {\\n    if (s.length === 2 * n) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l < n) go(l + 1, r, s + \\'(\\');\\n    if (r < l) go(l, r + 1, s + \\')\\');\\n  };\\n\\n  go(0, 0, \\'\\');\\n  return res;\\n};\\n```\\n\\n**Solution 2**\\n\\n```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => { // l: left remaining, r: right remaining\\n    if (l > r) return; // Validate by the number of \\'(\\' should be always >= \\')\\'\\n\\n    if (l === 0 && r === 0) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l > 0) go(l - 1, r, s + \\'(\\');\\n    if (r > 0) go(l, r - 1, s + \\')\\');\\n  };\\n\\n  go(n, n, \\'\\');\\n  return res;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => {\\n    if (s.length === 2 * n) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l < n) go(l + 1, r, s + \\'(\\');\\n    if (r < l) go(l, r + 1, s + \\')\\');\\n  };\\n\\n  go(0, 0, \\'\\');\\n  return res;\\n};\\n```\n```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => { // l: left remaining, r: right remaining\\n    if (l > r) return; // Validate by the number of \\'(\\' should be always >= \\')\\'\\n\\n    if (l === 0 && r === 0) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l > 0) go(l - 1, r, s + \\'(\\');\\n    if (r > 0) go(l, r - 1, s + \\')\\');\\n  };\\n\\n  go(n, n, \\'\\');\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276079,
                "title": "python-backtracking-complexity-analysis-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Naive Backtracking**\\n```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = []\\n        \\n        def isValidParenthesis(s):\\n            cntOpen = 0\\n            for c in s:\\n                if c == \\'(\\':\\n                    cntOpen += 1\\n                else:\\n                    if cntOpen == 0: return False  # Don\\'t have enough open to match with this close parentheses\\n                    cntOpen -= 1\\n            return cntOpen == 0  #\\xA0Fully match all open parentheses\\n        \\n        def bt(i, path):\\n            if i == 2 * n:\\n                if isValidParenthesis(path):\\n                    ans.append(path)\\n                return\\n            \\n            bt(i+1, path + \"(\")  # Add open\\n            bt(i+1, path + \")\")  # Add close\\n            \\n        bt(0, \"\")\\n        return ans\\n```\\nComplexity:\\n- Time: `O(2^m * m)`, where `m = 2n`, `n <= 8`\\n- Space: `n-th` Catalan Number.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Smart Backtracking**\\n```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        def backtracking(nOpen, nClose, path):\\n            if n == nClose:  # Found a valid n pairs of parentheses\\n                ans.append(path)\\n                return\\n\\n            if nOpen < n:  # Number of opening bracket up to `n`\\n                backtracking(nOpen + 1, nClose, path + \"(\")\\n            if nClose < nOpen:  # Number of closing bracket up to opening bracket\\n                backtracking(nOpen, nClose + 1, path + \")\")\\n\\n        ans = []\\n        backtracking(0, 0, \"\")\\n        return ans\\n```\\n**Complexity**\\n- Our complexity analysis based on how many elements there are in `generateParenthesis(n)`. \\n- This is the `n-th` [Catalan number](https://en.wikipedia.org/wiki/Catalan_number), where the first Catalan numbers for `n = 0, 1, 2, 3, ...` are `1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,...`\\n- Time & Space: `n-th` Catalan Number.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = []\\n        \\n        def isValidParenthesis(s):\\n            cntOpen = 0\\n            for c in s:\\n                if c == \\'(\\':\\n                    cntOpen += 1\\n                else:\\n                    if cntOpen == 0: return False  # Don\\'t have enough open to match with this close parentheses\\n                    cntOpen -= 1\\n            return cntOpen == 0  #\\xA0Fully match all open parentheses\\n        \\n        def bt(i, path):\\n            if i == 2 * n:\\n                if isValidParenthesis(path):\\n                    ans.append(path)\\n                return\\n            \\n            bt(i+1, path + \"(\")  # Add open\\n            bt(i+1, path + \")\")  # Add close\\n            \\n        bt(0, \"\")\\n        return ans\\n```\n```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        def backtracking(nOpen, nClose, path):\\n            if n == nClose:  # Found a valid n pairs of parentheses\\n                ans.append(path)\\n                return\\n\\n            if nOpen < n:  # Number of opening bracket up to `n`\\n                backtracking(nOpen + 1, nClose, path + \"(\")\\n            if nClose < nOpen:  # Number of closing bracket up to opening bracket\\n                backtracking(nOpen, nClose + 1, path + \")\")\\n\\n        ans = []\\n        backtracking(0, 0, \"\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10367,
                "title": "simple-2ms-c-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0);\\n        return result;\\n    }\\n\\n    /*  this hepler function insert result strings to \"vector<string> result\"\\n   \\t\\tWhen number of '(' less than \"n\", can append '(';\\n   \\t\\tWhen number of '(' is more than number of ')', can append ')';\\n\\n    \\tstring s : current string;\\n    \\tint leftpare_need : number of '(' that have not put into \"string s\";\\n    \\tint moreleft : number of '(' minus number of ')' in the \"string s\";\\n    */\\n\\n    void helper(string s, int leftpare_need, int moreleft)\\n    {\\n    \\tif(leftpare_need == 0 && moreleft == 0)\\n    \\t{\\n    \\t    result.push_back(s);\\n    \\t    return;\\n    \\t}\\n    \\tif(leftpare_need > 0)\\n    \\t\\thelper(s + \"(\", leftpare_need - 1, moreleft+1);\\n    \\tif(moreleft > 0)\\n    \\t\\thelper(s + \")\", leftpare_need, moreleft - 1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1561062,
                "title": "python3-recursive-approach-simple-logic-step-by-step-explanation",
                "content": "One thing we need to understand is, we need a way to add \\u201C(\\u201D and \\u201C)\\u201D to all possible cases and \\nthen find a way to validate so that we don\\u2019t generate the unnecessary ones.\\n\\nThe first condition is if there are more than 0 open / left brackets, we recurse with the right\\nones. And if we have more than 0 right brackets, we recurse with the left ones. Left and right\\nare initialized with` \\'n\\' `- the number given.\\n\\n\\n```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\\n\\n<br>\\n\\nThere\\u2019s a catch. We can\\u2019t add the \\u201C)\\u201D everytime we have `right>0` cause then it will not be\\nbalanced. We can balance that with a simple condition of `left<right.`\\n\\n```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\\n\\n<br>\\nSince this is a recursive approach we need to have a **BASE condition**,\\nand the base case is: \\n\\nWhen both right and left are 0, \\nwe have found one possible combination of parentheses \\n& we now need to append/add the `\\'s\\'` to `\\'ans\\'` list.\\n\\n```\\n\\t\\t\\tif left==0 and right==0:\\n                ans.append(s)\\n```\\n\\n<br>\\n<br>\\n\\n**Complete code**\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        \\n        def helper(ans, s, left, right):\\n            if left==0 and right==0:\\n                ans.append(s)\\n                \\n            if left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n        \\n        ans = []\\n        helper(ans, \\'\\', n, n)\\n        \\n        return ans\\n```\\n\\n\\n\\n<br>\\n<br>\\n*If this post seems to be helpful, please upvote!!*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\n```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\n```\\n\\t\\t\\tif left==0 and right==0:\\n                ans.append(s)\\n```\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        \\n        def helper(ans, s, left, right):\\n            if left==0 and right==0:\\n                ans.append(s)\\n                \\n            if left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n        \\n        ans = []\\n        helper(ans, \\'\\', n, n)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679907,
                "title": "easy-recursive-c-solution-clearly-explained",
                "content": "Hello all, \\n\\nBefore jumping to the code, go through the explanation. I have curated the explanation for your easy understanding. This will help you build a clear logic for many recursive problems moving forward.\\n\\nStep1: Identification of Problem\\nThe problem asks us to generate all the valid paranthesis sequences, the first thing that should come to mind is recursion. Hence recursion is the way forward.  \\n\\nStep2: Correctness of Solution\\nIt is really crucial to understand that the solution should be correct befire being optimized. \\n\\nStep3: Building Solution \\nWe start by maintaining a count for both the opening and closing paranthesis as\\n```\\n// count1 is used to flag the base case \\n// count2 is used to react to the base case \\ncount1=0 and count2=0 respectively.\\n\\n// following is the signature for the recursive function\\nsubseq(int count1,int count2,string v,vector<string> &ans,int n)\\n\\n// only the first three parameters are determining the state of each recursive call.\\n// vector<string> &ans   is passed with every recursive call to store the final valid strings\\n// int n   is used to check the base condition\\n```\\n\\nStep 4: Logic\\n\\n* A Valid sequence will include the closing paranthesis only when there are more opening paranthesis. Hence, the condition\\n```\\nif(count2<count1){\\n\\tsubseq(count1,count2+1,v+\")\",ans,n);    \\n}\\n```\\n* An opening paranthesis is always open to be the part of a valid paranthesis till it has a count less than n. \\n* As soon as the count of opening paranthesis reaches n, we push all the remaining closing paranthesis into the sequence, because there are no more opening paranthesis to add.\\n\\nStep5: Code\\n```\\nvoid subseq(int count1,int count2,string v,vector<string> &ans,int n){\\n        if(count1==n){\\n            // if there are n open \\'(\\', we simply push the rest closing \\')\\'\\n            while(count2<n){\\n                v+=\")\";\\n                count2+=1;\\n            }\\n\\t\\t\\t// v is pushed to the answer vector\\n\\t\\t\\t\\n            ans.push_back(v);\\n            return;\\n        }\\n\\t\\t\\n        subseq(count1+1,count2,v+\"(\",ans,n);\\n\\t\\t\\n        if(count2<count1){\\n            subseq(count1,count2+1,v+\")\",ans,n);    \\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string v;\\n        subseq(0,0,v,ans,n);\\n\\n        return ans;\\n    }\\n```\\n\\n**Please upvote, if the solution was of help to you. This will help other people in the community optimize their search for the best solution.**\\n\\nCheers!!\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// count1 is used to flag the base case \\n// count2 is used to react to the base case \\ncount1=0 and count2=0 respectively.\\n\\n// following is the signature for the recursive function\\nsubseq(int count1,int count2,string v,vector<string> &ans,int n)\\n\\n// only the first three parameters are determining the state of each recursive call.\\n// vector<string> &ans   is passed with every recursive call to store the final valid strings\\n// int n   is used to check the base condition\\n```\n```\\nif(count2<count1){\\n\\tsubseq(count1,count2+1,v+\")\",ans,n);    \\n}\\n```\n```\\nvoid subseq(int count1,int count2,string v,vector<string> &ans,int n){\\n        if(count1==n){\\n            // if there are n open \\'(\\', we simply push the rest closing \\')\\'\\n            while(count2<n){\\n                v+=\")\";\\n                count2+=1;\\n            }\\n\\t\\t\\t// v is pushed to the answer vector\\n\\t\\t\\t\\n            ans.push_back(v);\\n            return;\\n        }\\n\\t\\t\\n        subseq(count1+1,count2,v+\"(\",ans,n);\\n\\t\\t\\n        if(count2<count1){\\n            subseq(count1,count2+1,v+\")\",ans,n);    \\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string v;\\n        subseq(0,0,v,ans,n);\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594770,
                "title": "c-2-solutions-backtracking-and-dp",
                "content": "**Solution One**\\n\\nGiven a number n, we have to generate all valid `n` pairs of parenthesis. Since we have to generate all the valid combinations, the first solution which comes to our mind is backtracking (recursion). Given the constraint, I would say that is the best solution. \\n\\nWe start with number of open brackets `open = 0`, and number of close brackets `close = 0`. Now at any given recursion level, either we can put one open bracket or one close bracket. The constraints would be that `open can never be greater than n` and that `close < open` at all times. Below code is self explanatory. **Note I used string references to obtain a gain in speed**.\\n\\n```\\nclass Solution {\\npublic:\\n    void util(vector<string>& res, int open, int close, string& tmp, int n)\\n    {\\n        if(tmp.length()==2*n) {res.push_back(tmp); return;}\\n        if(open<n){\\n            tmp.push_back(\\'(\\');\\n            util(res,open+1,close,tmp,n);\\n            tmp.pop_back();\\n        }\\n        if(close<open){\\n            tmp.push_back(\\')\\');\\n            util(res,open,close+1,tmp,n);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open=0,close=0; // open -> number of open brackets\\n\\t\\t\\t\\t\\t\\t // close -> number of close brackets\\n        vector<string> res;\\n        if(n==0) return res;\\n        string temp=\"\";\\n        util(res,open,close,temp,n);\\n        return res;\\n    }\\n};\\n```\\n\\n*Time Complexity* - Very important for these kind of questions. Since recursion is a tree, and here there are two recursive calls possible at any level. Heigh of the tree will be `2*n`, since we are generating `2*n` number of brackets. So, **worst-case Time Complexity will be** ```O(2^(2n))```.\\n\\n*Space Complexity* - `O(2*n)` (Stack space after using recursion)\\n\\n**Solution Two**\\n\\nNow, given the constraints in the problem, backtracking is good. But what if, `n` is large. We can\\'t afford exponential solution. The next thought should be dynamic programming, and if there is a overlapping subproblems nature to it.\\n\\nSuppose `dp[i]` contains all the valid parentheses possible of length `2*i`. Suppose you got `dp[2]` which is `{ (()) , ()() }`. Now what will be `dp[3]`? It can be written as -\\n\\n`(` + dp[0] + `)` + dp[2] = `()(())` and `()()()`\\n`(` + dp[1] + `)` + dp[1] = `(())()`\\n`(` + dp[2] + `)` + dp[0] = `((()))` and `(()())`\\n\\nSo you see, we have an overlapping subproblems structure. It\\'s good to know here that this structure closely follows `Catalan Numbers`. (You can find the number of valid parentheses using Catalan Numbers).\\n\\n`dp[i] = \"(\" + dp[j] + \")\" + dp[i-j-1]`   (Recursive relation. Similar to a binary tree generation).\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n        vector<vector<string>> dp(n+1); // cache to store all generated strings\\n        dp[0] = {\"\"}; \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string> left = dp[j];\\n                vector<string> right = dp[i-j-1];\\n                for(int k=0;k<left.size();k++){\\n                    for(int l=0;l<right.size();l++){\\n                        dp[i].push_back(\"(\" + left[k] + \")\" + right[l]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n\\n*Time Complexity* - `O(n^4)`.\\n*Space Complexity* - `O(n)`.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void util(vector<string>& res, int open, int close, string& tmp, int n)\\n    {\\n        if(tmp.length()==2*n) {res.push_back(tmp); return;}\\n        if(open<n){\\n            tmp.push_back(\\'(\\');\\n            util(res,open+1,close,tmp,n);\\n            tmp.pop_back();\\n        }\\n        if(close<open){\\n            tmp.push_back(\\')\\');\\n            util(res,open,close+1,tmp,n);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open=0,close=0; // open -> number of open brackets\\n\\t\\t\\t\\t\\t\\t // close -> number of close brackets\\n        vector<string> res;\\n        if(n==0) return res;\\n        string temp=\"\";\\n        util(res,open,close,temp,n);\\n        return res;\\n    }\\n};\\n```\n```O(2^(2n))```\n```\\nvector<string> generateParenthesis(int n) {\\n        vector<vector<string>> dp(n+1); // cache to store all generated strings\\n        dp[0] = {\"\"}; \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string> left = dp[j];\\n                vector<string> right = dp[i-j-1];\\n                for(int k=0;k<left.size();k++){\\n                    for(int l=0;l<right.size();l++){\\n                        dp[i].push_back(\"(\" + left[k] + \")\" + right[l]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276579,
                "title": "short-easy-solution-w-explanation-beats-100",
                "content": "\\u2714\\uFE0F ***Solution - I (Brute - Force)***\\n\\nWe have `n` pair of parenthesis which means we are required to form a valid parenthesis string of `length == 2*n`. Let\\'s start with the brute-force way. At each position of the string, we can insert **`(`** or **`)`** brackets and so we will try both the options. Atlast, when the length of string becomes `2*n`, we will perform a check and insert into `ans` array if it is valid.\\n\\n```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup> * n)</code>**, for each index in string, we try both the parenthesis which is <code>2`*`2`*`2...2n times = O(2<sup>2n</sup>) = O(4<sup>n</sup>) </code> and lastly, we spend an `O(n)` time to check for the formed string\\'s validity. \\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>** (A tighter bound exists)\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Approach)***\\n\\nInstead of trying out both the brackets at each index of the string, we only try them at places which won\\'t outright invalidate the string. For eg. In the previous approach, we were trying to insert `)` even at the start which would surely not have generated a valid parenthesis. Here, we avoid that. We have 2 cases:\\n\\n* **`(`** can be inserted anywhere till its count is less than `n`\\n* **`)`** can be inserted whenever its count is less than `start` (number of openinig parenthesis)\\n\\nFinally, we will insert the string when its length reaches `2*n`.\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup>)</code>** Here we save the time for string validation at the end and also avoid the extra recursive calls which we know are invalid anyway. \\n**Note**: There exists a tighter bound - <code>O(4<sup>n</sup> / &radic;n)</code>  but without deep analysis of the recursion structure, it\\'s very hard to arrive at it. So, <code>O(4<sup>n</sup>)</code> is good enough for quick estimations\\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>**, Tighter bound - **<code>O(4<sup>n</sup> / &radic;n)</code>**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/001e3d19-b69f-4c1b-96c9-f760343aef54_1623844459.7738905.png  /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909785,
                "title": "beats-100-this-is-how-you-explain-it-to-your-interviewer",
                "content": "UPVOTE IT TO KEEP IT AT THE TOP!\\n\\n# Intuition\\nThis code aims to generate all valid combinations of balanced parentheses pairs given a positive integer n. The goal is to produce all possible strings of length 2*n, where each character is either \\'(\\' or \\')\\', and the resulting strings are valid parentheses expressions.\\n\\n# Approach\\nThe code uses a recursive approach to generate these combinations. The solve function is called recursively to build the strings while maintaining the count of open and closed parentheses. Here\\'s how it works:\\n\\nThe base case is when the index ind reaches or exceeds n * 2. At this point, the constructed string op is a valid combination of parentheses, so it\\'s added to the result vector ans.\\n\\nIf the count of open parentheses cnt1 is less than n and the current index ind is less than n * 2 - 1, a \\'(\\' character is added to the string op, and the solve function is called recursively with cnt1 incremented by 1 and the index increased by 1.\\n\\nIf the count of closed parentheses cnt2 is less than cnt1 and the current index ind is greater than 0, a \\')\\' character is added to the string op, and the solve function is called recursively with cnt2 incremented by 1 and the index increased by 1.\\n\\nAfter each recursive call, the last character is removed from the string op using op.pop_back() to backtrack and explore different combinations.\\n\\nThe generateParenthesis function initializes the result vector ans and calls the solve function with initial counts and index.\\n\\n# Complexity\\n- Time complexity: O(4^n / sqrt(n))\\nTime complexity: The recursive approach explores all possible combinations, and the total number of valid combinations is bounded by the nth Catalan number, which grows exponentially with n. Thus, the time complexity is exponential, approximately O(4^n / sqrt(n)).\\n\\n- Space complexity:  O(n)\\nSpace complexity: The space complexity is determined by the maximum recursion depth, which is proportional to n. Additionally, the space used by the string op in each recursive call contributes to the space complexity. Therefore, the space complexity is O(n) due to the recursion depth.\\n\\n\\n![5d0bae9a5411b.jpeg](https://assets.leetcode.com/users/images/7a8eeaa3-6860-49ad-a76b-c322ca710c63_1692032658.6172345.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    void solve(int cnt1,int cnt2,int n,vector<string> &ans,string &op,int ind)\\n    {\\n        if(ind>=n*2)\\n        {\\n            ans.push_back(op);\\n            return;}\\n        if(cnt1<n and ind<n*2-1)\\n        {\\n            op+=\\'(\\';\\n            solve(cnt1+1,cnt2,n,ans,op,ind+1);\\n            op.pop_back();\\n        }\\n        \\n        if(cnt2<cnt1 and ind>0)\\n        {\\n            op+=\\')\\';\\n \\n            solve(cnt1,cnt2+1,n,ans,op,ind+1);\\n            op.pop_back();\\n        }\\n        \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n         string op=\"\";\\n        vector<string> ans;\\n        solve(0,0,n,ans,op,0);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private:\\n    void solve(int cnt1,int cnt2,int n,vector<string> &ans,string &op,int ind)\\n    {\\n        if(ind>=n*2)\\n        {\\n            ans.push_back(op);\\n            return;}",
                "codeTag": "Java"
            },
            {
                "id": 10337,
                "title": "my-accepted-java-solution",
                "content": "For 2, it should place one \"()\" and add another one insert it but none tail it,\\n\\n'(' f(1) ')' f(0)\\n\\nor add none insert it but tail it by another one,\\n\\n'(' f(0) ')' f(1)\\n\\nThus for n,  we can insert f(i) and tail f(j) and i+j=n-1,\\n\\n'(' f(i) ')' f(j)              \\n\\n\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tresult.add(\"\");\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\t\\tList<String> insertSub = generateParenthesis(i);\\n\\t\\t\\t\\tList<String> tailSub = generateParenthesis(n - 1 - i);\\n\\t\\t\\t\\tfor (String insert : insertSub) {\\n\\t\\t\\t\\t\\tfor (String tail : tailSub) {\\n\\t\\t\\t\\t\\t\\tresult.add(\"(\" + insert + \")\" + tail);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "For 2, it should place one \"()\" and add another one insert it but none tail it,\\n\\n'(' f(1) ')' f(0)\\n\\nor add none insert it but tail it by another one,\\n\\n'(' f(0) ')' f(1)\\n\\nThus for n,  we can insert f(i) and tail f(j) and i+j=n-1,\\n\\n'(' f(i) ')' f(j)              \\n\\n\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tresult.add(\"\");\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\t\\tList<String> insertSub = generateParenthesis(i);\\n\\t\\t\\t\\tList<String> tailSub = generateParenthesis(n - 1 - i);\\n\\t\\t\\t\\tfor (String insert : insertSub) {\\n\\t\\t\\t\\t\\tfor (String tail : tailSub) {\\n\\t\\t\\t\\t\\t\\tresult.add(\"(\" + insert + \")\" + tail);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 313945,
                "title": "recursion-with-backtracking",
                "content": "The key to this problem is writing a recursive function that operates in a manner similar to how we would generate all valid pairs by hand.\\n\\nAt every step of the way, we choose to add either an open bracket or a close bracket. This can easily be implemented as part of the recursive call. The trick is to also implement the restraint, namely \\'dont add a close bracket if there isnt already an open bracket\\'. AKA: only add if right > left. The restraint for adding open brackets is simple, add one if there are still open brackets to be added.\\n\\nFollowing this logic allows us to only generate valid strings, and we are done generating a particular string when we dont have any more brackets left ot add.\\n\\nParameters:\\n\\t(int) left:       set to n, keep track of open brackets that need to be added\\n\\t(int) right:     set to n, keep track of close brackets that need to be add\\n\\t(str) curr:     set to \"\", used to store the current version of the string\\n\\t(dict()) res:  hold all valid strings, is returned by the function\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \\n\\t\\tdef paren(left, right, curr, res):\\n\\t\\t\\t# \\'evaluate current string\\n\\t\\t\\t# if we are out of brackets to add, we must be at a valid string\\n\\t\\t\\tif left == 0 and right == 0:\\n\\t\\t\\t\\tres.append(curr)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# recursive call: add either open or close\\n\\t\\t\\t# if adding open bracket is valid\\n\\t\\t\\tif left > 0:\\n\\t\\t\\t\\t# add open bracket, decr count\\n\\t\\t\\t\\tparen(left-1, right, curr + \"(\", res)\\n\\n\\t\\t\\t# if adding close bracket is valid\\n\\t\\t\\tif right > left:\\n\\t\\t\\t\\t# add close bracket, decr count\\n\\t\\t\\t\\tparen(left, right-1, curr + \")\", res)\\n\\n\\t\\t\\treturn res\\n\\t\\t# end paren()\\n\\n\\t\\tres = paren(n, n, \\'\\', [])\\n\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \\n\\t\\tdef paren(left, right, curr, res):\\n\\t\\t\\t# \\'evaluate current string\\n\\t\\t\\t# if we are out of brackets to add, we must be at a valid string\\n\\t\\t\\tif left == 0 and right == 0:\\n\\t\\t\\t\\tres.append(curr)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# recursive call: add either open or close\\n\\t\\t\\t# if adding open bracket is valid\\n\\t\\t\\tif left > 0:\\n\\t\\t\\t\\t# add open bracket, decr count\\n\\t\\t\\t\\tparen(left-1, right, curr + \"(\", res)\\n\\n\\t\\t\\t# if adding close bracket is valid\\n\\t\\t\\tif right > left:\\n\\t\\t\\t\\t# add close bracket, decr count\\n\\t\\t\\t\\tparen(left, right-1, curr + \")\", res)\\n\\n\\t\\t\\treturn res\\n\\t\\t# end paren()\\n\\n\\t\\tres = paren(n, n, \\'\\', [])\\n\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10299,
                "title": "c-recursive-iterative",
                "content": "**Recursive (backtracking)**\\n\\nWe use `l` and `r` to denote the number of `(`s and `)`s. If `l < n`, we can add a `(`. If `r < l`, we can add a `)`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parens;\\n        string paren;\\n        generate(n, 0, 0, paren, parens);\\n        return parens;\\n    }\\nprivate:\\n    void generate(int n, int l, int r, string paren, vector<string>& parens) {\\n        if (l == n && r == n) {\\n            parens.push_back(paren);\\n        } else {\\n            if (l < n) {\\n                generate(n, l + 1, r, paren + \\'(\\', parens);\\n            }\\n            if (r < l) {\\n                generate(n, l, r + 1, paren + \\')\\', parens);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\nThis idea is taken from the official solution.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (!n) {\\n            return {\"\"};\\n        }\\n        vector<string> parens;\\n        for (int i = 0; i < n; i++) {\\n            for (string l : generateParenthesis(i)) {\\n                for (string r : generateParenthesis(n - 1 - i)) {\\n                    parens.push_back(\\'(\\' + l + \\')\\' + r);\\n                }\\n            }\\n        }\\n        return parens;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parens;\\n        string paren;\\n        generate(n, 0, 0, paren, parens);\\n        return parens;\\n    }\\nprivate:\\n    void generate(int n, int l, int r, string paren, vector<string>& parens) {\\n        if (l == n && r == n) {\\n            parens.push_back(paren);\\n        } else {\\n            if (l < n) {\\n                generate(n, l + 1, r, paren + \\'(\\', parens);\\n            }\\n            if (r < l) {\\n                generate(n, l, r + 1, paren + \\')\\', parens);\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (!n) {\\n            return {\"\"};\\n        }\\n        vector<string> parens;\\n        for (int i = 0; i < n; i++) {\\n            for (string l : generateParenthesis(i)) {\\n                for (string r : generateParenthesis(n - 1 - i)) {\\n                    parens.push_back(\\'(\\' + l + \\')\\' + r);\\n                }\\n            }\\n        }\\n        return parens;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936271,
                "title": "simple-java-sol",
                "content": "\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList();\\n        findAll(\"(\",1,0,res,n);\\n\\n        return res;\\n    }\\n\\n    void findAll(String current,int op , int cl , List<String> res, int n){\\n        if(current.length()==2*n){\\n            res.add(current);\\n            return;\\n        }\\n        if(op<n)\\n        findAll(current+\"(\", op+1,cl,res,n);\\n        if(cl<op)\\n        findAll(current+\")\",op,cl+1,res,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList();\\n        findAll(\"(\",1,0,res,n);\\n\\n        return res;\\n    }\\n\\n    void findAll(String current,int op , int cl , List<String> res, int n){\\n        if(current.length()==2*n){\\n            res.add(current);\\n            return;\\n        }\\n        if(op<n)\\n        findAll(current+\"(\", op+1,cl,res,n);\\n        if(cl<op)\\n        findAll(current+\")\",op,cl+1,res,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370756,
                "title": "accepted-c-whiteboard-recursion-tree-easy-please-upvote",
                "content": "**Whiteboard Recursion Tree**\\nHere n = 3\\n* Star marks the string to be pushed in ans vector\\n* When open < close, only then we go further\\n* If open == 0 stop there, as opening parenthesis are exhausted\\n* If open < close, it means some of open are used so only now we can close\\n* If open == close == 0 then no more parenthesis left so add the string to ans vector and return\\n\\n![image](https://assets.leetcode.com/users/images/c33fedf4-ccdd-4ae6-a830-2c18943d1cb4_1627579698.6112955.jpeg)\\n\\nPardon my drawing \\uD83D\\uDE02\\uD83D\\uDE02\\nSuggestions are welcomed. \\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        f(\"\",n,n);\\n        return ans;\\n    }\\n    void f(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        f(\"\",n,n);\\n        return ans;\\n    }\\n    void f(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10400,
                "title": "6-lines-c-3-4-ms-super-easy-to-understand",
                "content": "    vector<string> result;\\n    \\n    void helper(string str, int left, int right){\\n        if(left == 0 && right == 0)  result.push_back(str);\\n        if(left!=0)                  helper(str+'(', left-1, right);\\n        if(right!=0 && right > left) helper(str+')', left, right-1);\\n    }    \\n    \\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\",n,n);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> result;\\n    \\n    void helper(string str, int left, int right){\\n        if(left == 0 && right == 0)  result.push_back(str);\\n        if(left!=0)                  helper(str+'(', left-1, right);\\n        if(right!=0 && right > left) helper(str+')', left, right-1);\\n    }    \\n    \\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\",n,n);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1276049,
                "title": "python-recursive-solution-with-dp-explained",
                "content": "For each valid parentheses there smallest `k`, for which the first `k` symbols compose well-formed parentheses: `(left)right`. Let us `ans[i]` be all valid parentheses of length `i`. Then we can generate them using recursion. For every `k in range(n+1)` and for every `i in range(k)` we choose left part and right part and append it to final answer. Because we memorize our intermediate results, we can also say that we use dp approach here.\\n\\n#### Complexity\\nTime complexity is `O(C_n * n) = O(4^n/n^0.5)`, where `C_n` is Catalan number. Space complexity is the same.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        ans = [[] for _ in range(n+1)]\\n        ans[0] = [\"\"]\\n        for k in range(n + 1):\\n            for i in range(k):\\n                for left in ans[i]:\\n                    for right in ans[k-i-1]:\\n                        ans[k].append(\"(\" + left + \")\" + right)\\n        \\n        return ans[-1]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        ans = [[] for _ in range(n+1)]\\n        ans[0] = [\"\"]\\n        for k in range(n + 1):\\n            for i in range(k):\\n                for left in ans[i]:\\n                    for right in ans[k-i-1]:\\n                        ans[k].append(\"(\" + left + \")\" + right)\\n        \\n        return ans[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10136,
                "title": "easy-java-solution",
                "content": "    public class Solution {\\n    private void helper(List<String> res, String present, int left, int right) {\\n        if (right == 0) {\\n            res.add(present);\\n        }\\n        if (left > 0) {\\n            helper(res, present + \"(\", left - 1, right);\\n        }\\n        if (right > left) {\\n            helper(res, present + \")\", left, right - 1);\\n        }\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        if (n == 0) {\\n            return res;\\n        }\\n        helper(res, \"\", n, n);\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private void helper(List<String> res, String present, int left, int right) {\\n        if (right == 0) {\\n            res.add(present);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3211825,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O((2^2*N)*N). For each of 2^2*N sequences, we need to create and validate the sequence,\\n    which takes O(N) work.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool valid(vector<char> temp){\\n        int balance = 0;\\n        for(auto c : temp){\\n            if(c == \\'(\\') balance++;\\n            else balance--;\\n            if(balance < 0) return false;\\n        }\\n        return balance == 0;\\n    }\\n    void generateAllParenthesis(vector<string>& parenthesesCombinations, vector<char> temp, int position){\\n        if(position == temp.size()){\\n            if(valid(temp)){\\n                string s(temp.begin(), temp.end());\\n                parenthesesCombinations.push_back(s);\\n            }\\n            return;\\n        }\\n        temp[position] = \\'(\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1);\\n        temp[position] = \\')\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1); \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parenthesesCombinations;\\n        vector<char> temp(2*n);\\n        generateAllParenthesis(parenthesesCombinations, temp, 0);\\n        return parenthesesCombinations;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(O(2^2*N)The time complexity of the above code is O(2^(2N)) since in the worst case we\\n    need to consider every possibility of opening and closing brackets where N = the number of pairs we need to\\n    form.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    void recurse(vector<string>& output, string s, int open, int close, int n){\\n        if(open==n and close==n){\\n            output.push_back(s);\\n            return;\\n        }\\n        if(open<n)\\n            recurse(output, s+\"(\" , open+1, close, n);\\n        if(close<open)\\n            recurse(output, s+\")\", open, close+1, n);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> output;\\n        recurse(output, \"\", 0, 0, n);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O((2^2*N)*N). For each of 2^2*N sequences, we need to create and validate the sequence,\\n    which takes O(N) work.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool valid(vector<char> temp){\\n        int balance = 0;\\n        for(auto c : temp){\\n            if(c == \\'(\\') balance++;\\n            else balance--;\\n            if(balance < 0) return false;\\n        }\\n        return balance == 0;\\n    }\\n    void generateAllParenthesis(vector<string>& parenthesesCombinations, vector<char> temp, int position){\\n        if(position == temp.size()){\\n            if(valid(temp)){\\n                string s(temp.begin(), temp.end());\\n                parenthesesCombinations.push_back(s);\\n            }\\n            return;\\n        }\\n        temp[position] = \\'(\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1);\\n        temp[position] = \\')\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1); \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parenthesesCombinations;\\n        vector<char> temp(2*n);\\n        generateAllParenthesis(parenthesesCombinations, temp, 0);\\n        return parenthesesCombinations;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(O(2^2*N)The time complexity of the above code is O(2^(2N)) since in the worst case we\\n    need to consider every possibility of opening and closing brackets where N = the number of pairs we need to\\n    form.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    void recurse(vector<string>& output, string s, int open, int close, int n){\\n        if(open==n and close==n){\\n            output.push_back(s);\\n            return;\\n        }\\n        if(open<n)\\n            recurse(output, s+\"(\" , open+1, close, n);\\n        if(close<open)\\n            recurse(output, s+\")\", open, close+1, n);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> output;\\n        recurse(output, \"\", 0, 0, n);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193155,
                "title": "python3-dp-solution-with-explanation-36-ms-beat-99-96",
                "content": "It\\'s intuitive to find the common subproblems, so dp is a natural choice.\\n\\ntwo base cases: \\nif n = 1, result = [\\'()\\']\\nif n = 2, result = [\\'(())\\', \\'()()\\']\\n\\nif n = 3, result = [\\n  \"((()))\",  # pattern: result of dp[2] is around by an outer \\'()\\'\\n  \"(()())\",  # the same pattern as above\\n  \"(())()\",  # pattern: result of dp[2] + result of dp[1]\\n  \"()(())\",  # the same pattern as above with another permutation order: dp[1] + dp[2]\\n  \"()()()\"  #  the same pattern as above\\n]\\n\\nwe can found the same recursive patterns for n > 3:\\n**pattern 1**: candidates = \\'(\\' + x + \\')\\' , where x is element of dp[n-1]\\n**pattern 2**: candidates = [x + y] , where x is element of dp[i] and y is element of dp[n-i] (the range of i is [0 : n])\\n\\n\\n```\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n                \\n        # 1 and 2 is base cases (set is used to deduplicate candidates)\\n        dp = {1: set([\\'()\\']), 2: set([\\'(())\\', \\'()()\\'])}\\n        for i in range(3, n+1):\\n            # pattern 1: outer parenthese + subproblem with length - 1\\n            dp[i] = set([\\'(\\' + x + \\')\\' for x in dp[i-1]])\\n            for j in range(1, i):\\n                # pattern 2: dp[i] is formed by dp[j] + dp[i-j]\\n                dp[i] = dp[i].union([x + y for x in dp[j] for y in dp[i-j]])\\n        return list(dp[n])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n                \\n        # 1 and 2 is base cases (set is used to deduplicate candidates)\\n        dp = {1: set([\\'()\\']), 2: set([\\'(())\\', \\'()()\\'])}\\n        for i in range(3, n+1):\\n            # pattern 1: outer parenthese + subproblem with length - 1\\n            dp[i] = set([\\'(\\' + x + \\')\\' for x in dp[i-1]])\\n            for j in range(1, i):\\n                # pattern 2: dp[i] is formed by dp[j] + dp[i-j]\\n                dp[i] = dp[i].union([x + y for x in dp[j] for y in dp[i-j]])\\n        return list(dp[n])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656798,
                "title": "solution-swift-generate-parentheses-test-cases",
                "content": "```swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        guard n > 0 else { return [\"\"] }\\n        \\n        var map: [Int:[String]] = [:], result: [String] = []\\n        if let parentheses = map[n] { return parentheses }\\n        \\n        for i in 0..<n {\\n            for l in generateParenthesis(i) {\\n                for r in generateParenthesis(n - 1 - i) {\\n                    result.append(\"(\" + l + \")\" + r)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateParenthesis(3)\\n        XCTAssertEqual(value, [\"()()()\",\"()(())\",\"(())()\",\"(()())\",\"((()))\"])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateParenthesis(1)\\n        XCTAssertEqual(value, [\"()\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        guard n > 0 else { return [\"\"] }\\n        \\n        var map: [Int:[String]] = [:], result: [String] = []\\n        if let parentheses = map[n] { return parentheses }\\n        \\n        for i in 0..<n {\\n            for l in generateParenthesis(i) {\\n                for r in generateParenthesis(n - 1 - i) {\\n                    result.append(\"(\" + l + \")\" + r)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateParenthesis(3)\\n        XCTAssertEqual(value, [\"()()()\",\"()(())\",\"(())()\",\"(()())\",\"((()))\"])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateParenthesis(1)\\n        XCTAssertEqual(value, [\"()\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617936,
                "title": "intuitive-javascript-solution-with-bracktracking",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n  const output = [];\\n  /**\\n   * Examples \\n   * n = 1\\n   *  ()\\n   *\\n   *  n = 2\\n   *  (())\\n   *  ()()\\n   *\\n   *  n = 3\\n   *  ((()))\\n   *  (()())\\n   *  (())()\\n   *  ()(())\\n   *  ()()()\\n   */\\n  const dfs = (str, open, close) => {\\n    // Close parentheses can not be more than open parentheses at any \\n    // given time to stay valid.\\n    if (open > close) {\\n      return;\\n    }\\n    // Base case. We now have n pairs of parentheses\\n    if (open === 0 && close === 0) {\\n      output.push(str);\\n      return;\\n    }\\n    // Insert open parenthsis and search for the next valid insertion.\\n    if (open > 0) {\\n      dfs(`${str}(`, open - 1, close);\\n    }\\n    // Insert close parenthsis and search for the next valid insertion.\\n    if (close > 0) {\\n      dfs(`${str})`, open, close - 1);\\n    }\\n  };\\n  dfs(\\'\\', n, n);\\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n  const output = [];\\n  /**\\n   * Examples \\n   * n = 1\\n   *  ()\\n   *\\n   *  n = 2\\n   *  (())\\n   *  ()()\\n   *\\n   *  n = 3\\n   *  ((()))\\n   *  (()())\\n   *  (())()\\n   *  ()(())\\n   *  ()()()\\n   */\\n  const dfs = (str, open, close) => {\\n    // Close parentheses can not be more than open parentheses at any \\n    // given time to stay valid.\\n    if (open > close) {\\n      return;\\n    }\\n    // Base case. We now have n pairs of parentheses\\n    if (open === 0 && close === 0) {\\n      output.push(str);\\n      return;\\n    }\\n    // Insert open parenthsis and search for the next valid insertion.\\n    if (open > 0) {\\n      dfs(`${str}(`, open - 1, close);\\n    }\\n    // Insert close parenthsis and search for the next valid insertion.\\n    if (close > 0) {\\n      dfs(`${str})`, open, close - 1);\\n    }\\n  };\\n  dfs(\\'\\', n, n);\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338278,
                "title": "c-easy-to-understand-fast-and-efficient-recursion",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        helper(ans,\"\",n,0);\\n        return ans;\\n    }\\n    void helper(vector<string> &v,string s,int n,int m)\\n    {\\n     if(n==0&&m==0)\\n     {\\n      v.push_back(s);\\n      return;\\n     }\\n      if(n>0)\\n      helper(v,s+\"(\",n-1,m+1);\\n      if(m>0)\\n       helper(v,s+\")\",n,m-1);   \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        helper(ans,\"\",n,0);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 10269,
                "title": "2ms-ac-java-solution-using-recursive-call",
                "content": "    public class Solution {\\n        public List<String> generateParenthesis(int n) {\\n            ArrayList<String> m=new ArrayList<>();\\n            generate(m, \"\", n, n);\\n            return m;\\n        }\\n        public void generate(ArrayList m, String s, int l, int r){\\n            if(l==0 && r==0){ \\n                m.add(s);\\n                return;\\n            }\\n            if(l>0) generate(m, s+\"(\",  l-1,  r);\\n            if(r>l) generate(m, s+\")\",  l,  r-1);\\n        }\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> generateParenthesis(int n) {\\n            ArrayList<String> m=new ArrayList<>();\\n            generate(m, \"\", n, n);\\n            return m;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3512769,
                "title": "c-java-python-javascript-using-recursion-with-explanation",
                "content": "# Intuition:\\nThe problem requires generating all possible combinations of well-formed parentheses of length 2n. To solve this, we can use a recursive approach. At each step, we have two choices: either add an opening parenthesis \"(\" or add a closing parenthesis \")\". However, we need to make sure that the number of opening parentheses is always greater than or equal to the number of closing parentheses, so that the parentheses remain well-formed.\\n\\n# Approach:\\n1. We define a helper function, `generateParentheses`, that takes the following parameters:\\n   - `result`: a reference to the vector of strings where we store the generated combinations.\\n   - `current`: the current combination being generated.\\n   - `open`: the count of opening parentheses \"(\" included in the current combination.\\n   - `close`: the count of closing parentheses \")\" included in the current combination.\\n   - `n`: the total number of pairs of parentheses to be included.\\n\\n2. In the `generateParentheses` function, we first check if the length of the `current` string is equal to 2n. If it is, we have generated a valid combination, so we add it to the `result` vector and return.\\n\\n3. If the length of `current` is not equal to 2n, we have two choices:\\n   - If the count of opening parentheses `open` is less than n, we can add an opening parenthesis to the current combination and make a recursive call to `generateParentheses`, incrementing the `open` count by 1.\\n   - If the count of closing parentheses `close` is less than the `open` count, we can add a closing parenthesis to the current combination and make a recursive call to `generateParentheses`, incrementing the `close` count by 1.\\n\\n4. In the `generateParenthesis` function, we initialize an empty `result` vector and call the `generateParentheses` function with the initial values of `current` as an empty string, `open` and `close` counts as 0, and `n` as the input value.\\n\\n5. Finally, we return the `result` vector containing all the generated combinations of well-formed parentheses.\\n\\n# Complexity:\\nThe time complexity of this solution is O(4^n / sqrt(n)), where n is the input number of pairs of parentheses.\\nThe space complexity of this solution is O(n). \\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    void generateParentheses(vector<string>& result, string current, int open, int close, int n) {\\n        if (current.size() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n};\\n```\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n\\n    private void generateParentheses(List<String> result, String current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.add(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.generateParentheses(result, \"\", 0, 0, n)\\n        return result\\n\\n    def generateParentheses(self, result, current, open, close, n):\\n        if len(current) == 2 * n:\\n            result.append(current)\\n            return\\n        if open < n:\\n            self.generateParentheses(result, current + \\'(\\', open + 1, close, n)\\n        if close < open:\\n            self.generateParentheses(result, current + \\')\\', open, close + 1, n)\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar generateParenthesis = function(n) {\\n  const result = [];\\n  generateParentheses(result, \\'\\', 0, 0, n);\\n  return result;\\n};\\n\\nconst generateParentheses = (result, current, open, close, n) => {\\n  if (current.length === 2 * n) {\\n    result.push(current);\\n    return;\\n  }\\n  if (open < n) {\\n    generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n  }\\n  if (close < open) {\\n    generateParentheses(result, current + \\')\\', open, close + 1, n);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateParentheses(vector<string>& result, string current, int open, int close, int n) {\\n        if (current.size() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n\\n    private void generateParentheses(List<String> result, String current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.add(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.generateParentheses(result, \"\", 0, 0, n)\\n        return result\\n\\n    def generateParentheses(self, result, current, open, close, n):\\n        if len(current) == 2 * n:\\n            result.append(current)\\n            return\\n        if open < n:\\n            self.generateParentheses(result, current + \\'(\\', open + 1, close, n)\\n        if close < open:\\n            self.generateParentheses(result, current + \\')\\', open, close + 1, n)\\n\\n```\n```\\nvar generateParenthesis = function(n) {\\n  const result = [];\\n  generateParentheses(result, \\'\\', 0, 0, n);\\n  return result;\\n};\\n\\nconst generateParentheses = (result, current, open, close, n) => {\\n  if (current.length === 2 * n) {\\n    result.push(current);\\n    return;\\n  }\\n  if (open < n) {\\n    generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n  }\\n  if (close < open) {\\n    generateParentheses(result, current + \\')\\', open, close + 1, n);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440974,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276139,
                "title": "js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWe can make short work of this problem with a basic branching **recursive** function (**dfs**). Our recursive function will iterate through the index positions (**pos**) of a possible result. At each **pos**, we can add an open parenthesis if there\\'s more remaining space than unclosed parentheses (**open**) and we can add a closed parenthesis if there are any unclosed parentheses. Once we reach the end of the result, we can add it to our answer array (**ans**).\\n\\nTo make things easier, we can use **bit manipulation** to pass the sequence of parentheses (**seq**) for our potential result as an integer to each new recursion level. Then we just have to translate **seq** to a parentheses string before adding it to **ans**.\\n\\nOnce we\\'re all done, we can just **return ans**.\\n\\n - _**Time Complexity: O((2 * N)!/(N! * N!)** reflecting the **2N choose N** possible arrangements of parentheses_\\n - _**Space Complexity: O(N)** for the recursion stack and **res**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 40.4MB** (beats 96% / 25%).\\n```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.3MB** (beats 96% / 96%).\\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 93%).\\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 13.7MB** (beats 100% / 57%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656411,
                "title": "c-simple-solution-beats-88",
                "content": "Runtime: 232 ms, faster than 88.71% of C# online submissions for Generate Parentheses.\\nMemory Usage: 32.8 MB, less than 12.50% of C# online submissions for Generate Parentheses.\\n```\\npublic class Solution \\n{\\n    List<string> result = new List<string>();\\n    int maxLen;\\n    \\n    public IList<string> GenerateParenthesis(int n) {\\n        maxLen = n;\\n        GenerateAndCheck(\"\", 0, 0);\\n        return result;\\n    }\\n    \\n    private void GenerateAndCheck(string str, int opened, int closed)\\n    {\\n        if(opened == closed && opened == maxLen)\\n        {\\n            result.Add(str);\\n            return;\\n        }\\n        \\n        if(opened < maxLen)\\n            GenerateAndCheck(str + \"(\", opened + 1, closed);\\n        if(closed < opened)\\n            GenerateAndCheck(str + \")\", opened, closed + 1);\\n    }\\n}\\n```\\n\\nInspired by: https://youtu.be/qBbZ3tS0McI",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    List<string> result = new List<string>();\\n    int maxLen;\\n    \\n    public IList<string> GenerateParenthesis(int n) {\\n        maxLen = n;\\n        GenerateAndCheck(\"\", 0, 0);\\n        return result;\\n    }\\n    \\n    private void GenerateAndCheck(string str, int opened, int closed)\\n    {\\n        if(opened == closed && opened == maxLen)\\n        {\\n            result.Add(str);\\n            return;\\n        }\\n        \\n        if(opened < maxLen)\\n            GenerateAndCheck(str + \"(\", opened + 1, closed);\\n        if(closed < opened)\\n            GenerateAndCheck(str + \")\", opened, closed + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601816,
                "title": "javascript-intuitive-code-with-detailed-explanation",
                "content": "The intuition for many explanations and code is actually the same:\\n- Backtracking and keep track of number of opening and closing brackets have been used either by incrementing or decrementing.\\n- You know you can only start with an opening: `(`\\n- At this point, you have 2 options: add more `(` or now you can add `)` to close it.\\n- When can you add more `(`? Whenever you haven\\'t used up all the `n` openings. `n` pairs = `n` openings and `n` closings. \\n- When can you add more `)`? Whenever you have more openings than closings.\\n- When can you add the combination to the list? When the string you\\'ve generated hits `2*n` length or there\\'s no more opening or closing left.\\n- If you just do it by hands, you\\'ll have something like this:\\n```\\n// Remember: you can either add more closing or opening if you\\'re still within the constraints:\\n\\'(\\'->\\'()\\'->\\'()(\\'->\\'()()\\'->\\'()()(\\'=>\\'()()()\\'\\n                ->\\'()((\\'->\\'()(()\\'=>\\'()(())\\'\\n   ->\\'((\\'->\\'(()\\'->\\'(()(\\'->\\'(()()\\'=>\\'(())())\\'\\n                ->\\'(())\\'->\\'(())(\\'=>\\'(())()\\'\\n         ->\\'(((\\'=>\\'((()))\\'\\n```\\n\\nThe code:\\n```javascript\\n/**\\n * Backtracking solution.\\n * Note: Time and Space complexity is complicated. Catalan number: 4^n/(n*sqrt(n))\\n * Time = O(n*Catalan) because we generat combinations through n steps, each\\n * step takes a Catalan number to backtrack.\\n * Time = O(4^n/(sqrt(n)))\\n * Space = O(4^n/(sqrt(n))) because we need n space to store the sequence.\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    const combinations = [];\\n    // Here we know we can only start with an opening bracket => use 1 open:\\n    // but we can also start with an empty string and 0 like so:\\n    // buildCombinationFrom(\\'\\', 0, 0, n, combinations);\\n    buildCombinationFrom(\\'(\\', 1, 0, n, combinations);\\n    return combinations;\\n};\\n\\n/**\\n * Helper method generates combinations uses backtracking.\\n * @param {string} string \\n * @param {number} openUsed \\n * @param {number} closeUsed \\n * @param {number} n \\n * @param {string[]} combinations \\n */\\nfunction buildCombinationFrom(string, openUsed, closeUsed, n, combinations) {\\n    // Base case: when we reach 2n length\\n    if (string.length === 2*n) {\\n        // Add the string to the list of combination:\\n        combinations.push(string);\\n        // Exit from this recursive call.\\n        return;\\n    }\\n    // Case: when we can add more opening bracket:\\n    // If we haven\\'t used all opening bracket (n pairs = n opens)\\n    if (openUsed < n) {\\n        // Add 1 opening, update opening used:\\n        buildCombinationFrom(string + \\'(\\', openUsed + 1, closeUsed, n, combinations);\\n    }\\n    // Case: when we can add more closing bracket:\\n    // If we have more opening than closing:\\n    if (openUsed > closeUsed) {\\n        // Add 1 closing, update closing used:\\n        buildCombinationFrom(string + \\')\\', openUsed, closeUsed + 1, n, combinations);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n// Remember: you can either add more closing or opening if you\\'re still within the constraints:\\n\\'(\\'->\\'()\\'->\\'()(\\'->\\'()()\\'->\\'()()(\\'=>\\'()()()\\'\\n                ->\\'()((\\'->\\'()(()\\'=>\\'()(())\\'\\n   ->\\'((\\'->\\'(()\\'->\\'(()(\\'->\\'(()()\\'=>\\'(())())\\'\\n                ->\\'(())\\'->\\'(())(\\'=>\\'(())()\\'\\n         ->\\'(((\\'=>\\'((()))\\'\\n```\n```javascript\\n/**\\n * Backtracking solution.\\n * Note: Time and Space complexity is complicated. Catalan number: 4^n/(n*sqrt(n))\\n * Time = O(n*Catalan) because we generat combinations through n steps, each\\n * step takes a Catalan number to backtrack.\\n * Time = O(4^n/(sqrt(n)))\\n * Space = O(4^n/(sqrt(n))) because we need n space to store the sequence.\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    const combinations = [];\\n    // Here we know we can only start with an opening bracket => use 1 open:\\n    // but we can also start with an empty string and 0 like so:\\n    // buildCombinationFrom(\\'\\', 0, 0, n, combinations);\\n    buildCombinationFrom(\\'(\\', 1, 0, n, combinations);\\n    return combinations;\\n};\\n\\n/**\\n * Helper method generates combinations uses backtracking.\\n * @param {string} string \\n * @param {number} openUsed \\n * @param {number} closeUsed \\n * @param {number} n \\n * @param {string[]} combinations \\n */\\nfunction buildCombinationFrom(string, openUsed, closeUsed, n, combinations) {\\n    // Base case: when we reach 2n length\\n    if (string.length === 2*n) {\\n        // Add the string to the list of combination:\\n        combinations.push(string);\\n        // Exit from this recursive call.\\n        return;\\n    }\\n    // Case: when we can add more opening bracket:\\n    // If we haven\\'t used all opening bracket (n pairs = n opens)\\n    if (openUsed < n) {\\n        // Add 1 opening, update opening used:\\n        buildCombinationFrom(string + \\'(\\', openUsed + 1, closeUsed, n, combinations);\\n    }\\n    // Case: when we can add more closing bracket:\\n    // If we have more opening than closing:\\n    if (openUsed > closeUsed) {\\n        // Add 1 closing, update closing used:\\n        buildCombinationFrom(string + \\')\\', openUsed, closeUsed + 1, n, combinations);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919932,
                "title": "easy-java-backtracking-explained-in-comments-1-ms",
                "content": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        String combination = \"\";    //declare and initialize an empty string to hold each valid combination\\n        List<String> listOfValidCombinations = new ArrayList<String>(); //ArrayList to store all the valid combinations\\n        int countOfOpen = 0;    //counter to keep track of no. of open (left) parentheses\\n        int countOfClose = 0;   // counter to keep track of no. of close(right) parentheses\\n        backtrack(listOfValidCombinations, combination, countOfOpen, countOfClose, n); //calling the backtracking method\\n        return listOfValidCombinations; //return the final list of valid combinations computed by the backtacking method\\n    }\\n    \\n    public void backtrack(List<String> listOfValidCombinations, String combination, int countOfOpen, int countOfClose, int maxCount){\\n        /* The main idea here is:\\n        1.  In order to generate valid combinations of parentheses, we need to make sure that\\n            there is a closing parentheses for every open parentheses. This can be achieved by\\n            taking care of the following points:\\n            a.  At any point, no. of open parentheses > no. of closing parentheses\\n            b.  If no. of open parentheses == no. of closing parentheses, we have obtained a valid pattern\\n                (this will be our terminating condition for recursion)\\n            \\n        2.  We can repeat the process in point 1, until we have obatained all the possible combinations.\\n        \\n        */\\n        \\n        /*if no. of open and closing parentheses is equal to n, add the  \\n        combination to the list and return (and thus end the recursion)*/\\n        \\n        if((countOfOpen == maxCount) && (countOfClose == maxCount)){    //terminating condition\\n            listOfValidCombinations.add(combination);   \\n            return;\\n        }\\n        \\n        /*If no. of open parentheses is equal to n, it means we can add\\n        another \\'(\\' to the exisiting pattern and increase the value of countOfOpen by 1*/\\n        \\n        if(countOfOpen < maxCount){\\n            backtrack(listOfValidCombinations, combination + \"(\", countOfOpen + 1, countOfClose, maxCount);\\n        }\\n        \\n        /*If no. of closing parentheses is less than the no. of \\n        open parentheses is equal to n, it means we can add another \\')\\' \\n        to the exisiting pattern and increase the value of countOfClose by 1.\\n        We need to understand here that the second if block will be executed\\n        after the recursion from the first if block ends. In this way, we would\\n        have tried all possible combinations possible at this stage by BACKTRACKING.\\n        This is how backtracking is implemented here.*/\\n        \\n        if(countOfClose < countOfOpen){\\n            backtrack(listOfValidCombinations, combination + \")\", countOfOpen, countOfClose + 1, maxCount);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        String combination = \"\";    //declare and initialize an empty string to hold each valid combination\\n        List<String> listOfValidCombinations = new ArrayList<String>(); //ArrayList to store all the valid combinations\\n        int countOfOpen = 0;    //counter to keep track of no. of open (left) parentheses\\n        int countOfClose = 0;   // counter to keep track of no. of close(right) parentheses\\n        backtrack(listOfValidCombinations, combination, countOfOpen, countOfClose, n); //calling the backtracking method\\n        return listOfValidCombinations; //return the final list of valid combinations computed by the backtacking method\\n    }\\n    \\n    public void backtrack(List<String> listOfValidCombinations, String combination, int countOfOpen, int countOfClose, int maxCount){\\n        /* The main idea here is:\\n        1.  In order to generate valid combinations of parentheses, we need to make sure that\\n            there is a closing parentheses for every open parentheses. This can be achieved by\\n            taking care of the following points:\\n            a.  At any point, no. of open parentheses > no. of closing parentheses\\n            b.  If no. of open parentheses == no. of closing parentheses, we have obtained a valid pattern\\n                (this will be our terminating condition for recursion)\\n            \\n        2.  We can repeat the process in point 1, until we have obatained all the possible combinations.\\n        \\n        */\\n        \\n        /*if no. of open and closing parentheses is equal to n, add the  \\n        combination to the list and return (and thus end the recursion)*/\\n        \\n        if((countOfOpen == maxCount) && (countOfClose == maxCount)){    //terminating condition\\n            listOfValidCombinations.add(combination);   \\n            return;\\n        }\\n        \\n        /*If no. of open parentheses is equal to n, it means we can add\\n        another \\'(\\' to the exisiting pattern and increase the value of countOfOpen by 1*/\\n        \\n        if(countOfOpen < maxCount){\\n            backtrack(listOfValidCombinations, combination + \"(\", countOfOpen + 1, countOfClose, maxCount);\\n        }\\n        \\n        /*If no. of closing parentheses is less than the no. of \\n        open parentheses is equal to n, it means we can add another \\')\\' \\n        to the exisiting pattern and increase the value of countOfClose by 1.\\n        We need to understand here that the second if block will be executed\\n        after the recursion from the first if block ends. In this way, we would\\n        have tried all possible combinations possible at this stage by BACKTRACKING.\\n        This is how backtracking is implemented here.*/\\n        \\n        if(countOfClose < countOfOpen){\\n            backtrack(listOfValidCombinations, combination + \")\", countOfOpen, countOfClose + 1, maxCount);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10403,
                "title": "a-simplified-c-dp-solution-4ms-8-lines",
                "content": "    //dp[0] = \"\"\\n    //dp[i]='('+ dp[k]+')'+dp[i-1-k],k=0..i-i\\n    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector< vector<string> > dp(n+1, vector<string>());\\n            dp[0].push_back(\"\");\\n            for(int i=1; i<=n; ++i){\\n                for(int k=0; k<i; ++k){\\n                    for(string s1: dp[k]){\\n                        for(string s2: dp[i-1-k])\\n                            dp[i].push_back(\"(\"+s1+\")\"+s2);\\n                    }\\n                }\\n            }\\n            return dp[n];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector< vector<string> > dp(n+1, vector<string>());\\n            dp[0].push_back(\"\");\\n            for(int i=1; i<=n; ++i){\\n                for(int k=0; k<i; ++k){\\n                    for(string s1: dp[k]){\\n                        for(string s2: dp[i-1-k])\\n                            dp[i].push_back(\"(\"+s1+\")\"+s2);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 683890,
                "title": "c-backtracking-10-lines-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void f(string s,int open,int close){        //open => \\'(\\' count remaining\\n        if(open==0&&close==0){                  //close=> \\')\\' count remaining\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);    //\\'(\\' must be placed before \\')\\'\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        f(\"\",n,n);                              //Balanced string will have\\n        return ans;                             //n-open and n-closing brackets\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void f(string s,int open,int close){        //open => \\'(\\' count remaining\\n        if(open==0&&close==0){                  //close=> \\')\\' count remaining\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);    //\\'(\\' must be placed before \\')\\'\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        f(\"\",n,n);                              //Balanced string will have\\n        return ans;                             //n-open and n-closing brackets\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450759,
                "title": "0-ms-java-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe time complexity of this solution is O(4^n / sqrt(n)) because there are 2n steps in the backtracking process, and in each step, we can choose to either open or close a bracket. This gives us a total of 2^n possibilities at each step. However, not all of these possibilities are valid since we must ensure that the number of closing brackets is less than or equal to the number of opening brackets at each step. Therefore, we can eliminate half of the possibilities at each step, giving us a total of 2^n / 2 possibilities per step or 2^(2n) / 2^n = 4^n / 2^n = 4^n / (2^(2 * sqrt(n))) = O(4^n / sqrt(n)) possibilities in total.\\n\\nThe space complexity is also O(4^n / sqrt(n)) because this is the maximum number of solutions that we could generate. Since each solution has a length of 2n, the maximum amount of space required to store all solutions is O(2n * 4^n / sqrt(n)) = O(4^n / sqrt(n)).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(4^n / sqrt(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(4^n / sqrt(n))\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/f30b6fb7-d111-4bb1-8f38-6591b7482293_1682345447.5071316.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>(); // initialize the result list\\n        generate(result, \"\", n, n); // call the recursive helper function\\n        return result; // return the result list\\n    }\\n    \\n    public void generate(List<String> result, String s, int left, int right){\\n        if(left == 0 && right == 0){ // base case: no more parentheses to add\\n            result.add(s); // add the generated string to the result list\\n            return; // exit the current recursive call\\n        }\\n        if(left > 0){ // if there are still left parentheses to add\\n            generate(result, s + \"(\", left - 1, right); // add a left parenthesis and recursively call the function\\n        }\\n        if(right > left){ // if there are still right parentheses to add and there are more left parentheses than right parentheses in the current string\\n            generate(result, s + \")\", left, right - 1); // add a right parenthesis and recursively call the function\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>(); // initialize the result list\\n        generate(result, \"\", n, n); // call the recursive helper function\\n        return result; // return the result list\\n    }\\n    \\n    public void generate(List<String> result, String s, int left, int right){\\n        if(left == 0 && right == 0){ // base case: no more parentheses to add\\n            result.add(s); // add the generated string to the result list\\n            return; // exit the current recursive call\\n        }\\n        if(left > 0){ // if there are still left parentheses to add\\n            generate(result, s + \"(\", left - 1, right); // add a left parenthesis and recursively call the function\\n        }\\n        if(right > left){ // if there are still right parentheses to add and there are more left parentheses than right parentheses in the current string\\n            generate(result, s + \")\", left, right - 1); // add a right parenthesis and recursively call the function\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694091,
                "title": "golang-0ms-100",
                "content": "```\\nfunc generateParenthesis(n int) []string {\\n\\tans := make([]string, 0)\\n\\tcurrent := make([]byte, n*2)\\n\\trec22(&ans, n, 0, 0, current)\\n\\treturn ans\\n}\\n```\\n\\n```\\nfunc rec22(ans *[]string, n int, left int, right int, current []byte) {\\n\\tif left+right == n*2 {\\n\\t\\t*ans = append(*ans, string(current))\\n\\t\\treturn\\n\\t}\\n\\n\\tif left < n {\\n\\t\\tcurrent[left+right] = \\'(\\'\\n\\t\\trec22(ans, n, left+1, right, current)\\n\\t}\\n\\n\\tif right < left {\\n\\t\\tcurrent[left+right] = \\')\\'\\n\\t\\trec22(ans, n, left, right+1, current)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateParenthesis(n int) []string {\\n\\tans := make([]string, 0)\\n\\tcurrent := make([]byte, n*2)\\n\\trec22(&ans, n, 0, 0, current)\\n\\treturn ans\\n}\\n```\n```\\nfunc rec22(ans *[]string, n int, left int, right int, current []byte) {\\n\\tif left+right == n*2 {\\n\\t\\t*ans = append(*ans, string(current))\\n\\t\\treturn\\n\\t}\\n\\n\\tif left < n {\\n\\t\\tcurrent[left+right] = \\'(\\'\\n\\t\\trec22(ans, n, left+1, right, current)\\n\\t}\\n\\n\\tif right < left {\\n\\t\\tcurrent[left+right] = \\')\\'\\n\\t\\trec22(ans, n, left, right+1, current)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 916464,
                "title": "python-backtracking-faster-than-98",
                "content": "```\\n# Note: these codes are a python version of this youtube video\\n# https://www.youtube.com/watch?v=qBbZ3tS0McI\\n\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def backtrack(ans, curr, openp, closep, maxp):\\n            if len(curr) == 2*maxp:\\n                ans.append(curr)\\n            if openp < maxp:\\n                backtrack(ans, curr+\\'(\\', openp+1, closep, maxp)\\n            if closep < openp:\\n                backtrack(ans, curr+\\')\\', openp, closep+1, maxp)\\n        \\n        ans = []\\n        openp, closep = 0, 0\\n        curr = \\'\\'\\n        backtrack(ans, curr, openp, closep, n)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n# Note: these codes are a python version of this youtube video\\n# https://www.youtube.com/watch?v=qBbZ3tS0McI\\n\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def backtrack(ans, curr, openp, closep, maxp):\\n            if len(curr) == 2*maxp:\\n                ans.append(curr)\\n            if openp < maxp:\\n                backtrack(ans, curr+\\'(\\', openp+1, closep, maxp)\\n            if closep < openp:\\n                backtrack(ans, curr+\\')\\', openp, closep+1, maxp)\\n        \\n        ans = []\\n        openp, closep = 0, 0\\n        curr = \\'\\'\\n        backtrack(ans, curr, openp, closep, n)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 10312,
                "title": "python-dfs-easy-to-understand",
                "content": "The idea is at every step, check if the current path is a valid path (base case 1) and whether the path has reached the end (base case 2). \\n\\nValid is defined as:\\n\\n 1. Number of left parentheses >= Number of right parentheses\\n 2. Number of left parentheses <= n\\n 3. Number of right parentheses <= n\\n\\nReaching the end is defined as:\\n\\n 1. Total number of parentheses = n*2 (every left parenthesis has to be matched with a right parenthesis)\\n\\nIf the current path is valid and has not reached the end yet, try adding another parenthesis (left and right), respectively) and do this recursively until the path is no longer valid or reached the end. Once we've exhausted all possible options, we can return all valid paths that has reached the end.\\n\\n----------\\n\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.dfs(n,result,'',0,0)\\n        return result\\n    \\n    def dfs(self,n,result,path,left,right):\\n        # check if the current path is valid\\n        if not self.isValid(left,right,n):\\n            return\\n        # check we are at the right length\\n        if len(path) == n*2:\\n            result.append(path)\\n            return\\n        self.dfs(n,result,path+'(',left+1,right)\\n        self.dfs(n,result,path+')',left,right+1)\\n        \\n    def isValid(self,left,right,n):\\n        # left paren <= right paren\\n        # left paren <= n\\n        # right paren >= n\\n        return left >= right and left <= n and right <= n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "The idea is at every step, check if the current path is a valid path (base case 1) and whether the path has reached the end (base case 2). \\n\\nValid is defined as:\\n\\n 1. Number of left parentheses >= Number of right parentheses\\n 2. Number of left parentheses <= n\\n 3. Number of right parentheses <= n\\n\\nReaching the end is defined as:\\n\\n 1. Total number of parentheses = n*2 (every left parenthesis has to be matched with a right parenthesis)\\n\\nIf the current path is valid and has not reached the end yet, try adding another parenthesis (left and right), respectively) and do this recursively until the path is no longer valid or reached the end. Once we've exhausted all possible options, we can return all valid paths that has reached the end.\\n\\n----------\\n\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.dfs(n,result,'',0,0)\\n        return result\\n    \\n    def dfs(self,n,result,path,left,right):\\n        # check if the current path is valid\\n        if not self.isValid(left,right,n):\\n            return\\n        # check we are at the right length\\n        if len(path) == n*2:\\n            result.append(path)\\n            return\\n        self.dfs(n,result,path+'(',left+1,right)\\n        self.dfs(n,result,path+')',left,right+1)\\n        \\n    def isValid(self,left,right,n):\\n        # left paren <= right paren\\n        # left paren <= n\\n        # right paren >= n\\n        return left >= right and left <= n and right <= n",
                "codeTag": "Python3"
            },
            {
                "id": 10425,
                "title": "javascript-solution-in-124ms",
                "content": "    var generateParenthesis = function(n) {\\n      var arr = [];\\n      compose(n, n, '');\\n      return arr;\\n    \\n      function compose(left, right, str) {\\n        if (!left && !right && str.length) return arr.push(str);\\n        if (left) compose(left - 1, right, str + '(');\\n        if (right > left) compose(left, right - 1, str + ')');\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var generateParenthesis = function(n) {\\n      var arr = [];\\n      compose(n, n, '');\\n      return arr;\\n    \\n      function compose(left, right, str) {\\n        if (!left && !right && str.length) return arr.push(str);\\n        if (left) compose(left - 1, right, str + '(');\\n        if (right > left) compose(left, right - 1, str + ')');\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3064146,
                "title": "easy-c-recursive-and-back-tracking-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo recursion and genrate all the possible sequences and also keep checking if open == close and when size of string becomes 2*n then push that string in answer vector.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Recusrive \\n2. Backtracking\\n# Complexity\\n- Time complexity:O(4^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(4^n)$$ recusirve stack + $$O(n)$$ for storing sequences \\n- actually it will be $$4^n/sqrt(n)$$ (it need some calculation but roughly we can take $$4^n$$)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Recursive Approach**\\n```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n)generate(open+1,close,n,s+\"(\");\\n       if(close<open)generate(open,close+1,n,s+\")\");\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```\\n**Back tracking Approach**\\n```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n){\\n           s+=\"(\";\\n           generate(open+1,close,n,s);\\n           s.pop_back();\\n       }\\n       if(close<open){\\n       s+=\")\";\\n       generate(open,close+1,n,s);\\n       s.pop_back();\\n       }\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n)generate(open+1,close,n,s+\"(\");\\n       if(close<open)generate(open,close+1,n,s+\")\");\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n){\\n           s+=\"(\";\\n           generate(open+1,close,n,s);\\n           s.pop_back();\\n       }\\n       if(close<open){\\n       s+=\")\";\\n       generate(open,close+1,n,s);\\n       s.pop_back();\\n       }\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712761,
                "title": "beautiful-iterative-python-solution-with-stack",
                "content": "The stack holds all subproblems. The stack gets popped every loop and the possible children of the popped item get appended back on. \\nThe items in the stack are tuples with the following makeup: [parenthesis string, open remaining, closed remaining]. \\nWe initialize the stack with [\"(\",n-1,n] because every valid parenthesis combination starts with \"(\". \\nOnce an item x is popped from the stack, we check if it is complete by checking if the number of open remaining and closed remaining are zero. If it is complete, we append the string stored in x[0] to the return array. \\nIf not, we move to the next step. In the next step, we check if the number of open remaining (x[1]) is less than n. If so, we can append an open parenthesis to x[1], decrement the number of open parentheses remaining, and push it back on the stack. \\nThen, we can check x again to see if the number of closed parentheses remaining (x[2]) is greater than the number of open parentheses remaining (x[1]). If it is, we append a closed parenthesis to x[0], decrement the closed parenthesis counter, then push it back on the stack.\\nOur program finishes when the stack is empty. We return the array of finished strings.\\n\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        rv = []\\n        stack = [(\"(\",n-1,n)]\\n        \\n        while stack:\\n            item = stack.pop()\\n            \\n            s = item[0]\\n            o = item[1]\\n            c = item[2]\\n            \\n            if o == 0 and c == 0:\\n                rv.append(s)\\n            else:\\n                if o != 0:\\n                    stack.append([s+\"(\",o-1,c])\\n                \\n                if o < c:\\n                    stack.append([s+\")\",o,c-1])\\n\\n        return rv\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        rv = []\\n        stack = [(\"(\",n-1,n)]\\n        \\n        while stack:\\n            item = stack.pop()\\n            \\n            s = item[0]\\n            o = item[1]\\n            c = item[2]\\n            \\n            if o == 0 and c == 0:\\n                rv.append(s)\\n            else:\\n                if o != 0:\\n                    stack.append([s+\"(\",o-1,c])\\n                \\n                if o < c:\\n                    stack.append([s+\")\",o,c-1])\\n\\n        return rv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842989,
                "title": "easy-to-understand-time-complexity-analysis-with-pictures",
                "content": "Here is a quick explanation why the time cost to generate all parentheses is `O(nCn)`, where `Cn` is the n-th Catalan number, `n` is the cost to add results.\\n\\nThis problem is very similar with the [95. unique binary search tree II](https://leetcode.com/problems/unique-binary-search-trees-ii/) problem. Let\\'s say `n = 3` and we generated unique binary tree having 3 nodes:\\n```\\nA:          B:              C:       D:        E:\\no            o               o       o          o\\n \\\\         /   \\\\           /          \\\\        /                              \\n  o       o     o         o            o      o             \\n   \\\\                     /            /        \\\\                    \\n    o                   o            o          o \\n```\\n\\nTo convert the unique tree structure to unique parentheses, we just need to apply following rules recursively:\\n* each node corresponds to a pair of parentheses `()`\\n* root node\\'s parentheses will encompass its left child\\'s parenthese (or right, its the same)\\n\\nUsing this rule, we can convert the 5 unique tree structures to unique parentheses:\\nA: `\"()()()\"`; B: `\"(())()\"`; C: `\"((()))\"`; D: `\"()(())\"`; E: `\"(()())\"`\\n\\nNow the question becomes: what is the time complexity of getting all the unique binary tree structure? For a tree with `n` nodes, it\\'s left tree can have `0` to `n - 1` nodes, and its right tree can also have `0` to `n - 1` nodes. So if we know `T(0)` to `T(n - 1)`, then `T(n) = sum_{i = 0}^{n - 1}T[i] * T[n - i - 1]`. This recurrence describes the Catalan number. Let `T[0] = 1` and we can calculate `T[n]` using this recurrence.\\n\\nCheck [problem 95](https://leetcode.com/problems/unique-binary-search-trees-ii/) and [problem 96](https://leetcode.com/problems/unique-binary-search-trees/) for more details!\\n",
                "solutionTags": [],
                "code": "```\\nA:          B:              C:       D:        E:\\no            o               o       o          o\\n \\\\         /   \\\\           /          \\\\        /                              \\n  o       o     o         o            o      o             \\n   \\\\                     /            /        \\\\                    \\n    o                   o            o          o \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327106,
                "title": "easy-to-understand-with-diagram",
                "content": "```\\n public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        backtrack(list, \"\", 0, 0, n);\\n        return list;\\n    }\\n```\\n    \\n    public void backtrack(List<String> list, String str, int open, int close, int max){\\n        \\n        if(str.length() == max*2){\\n            list.add(str);\\n            return;\\n        }\\n        \\n        if(open < max)\\n            backtrack(list, str+\"(\", open+1, close, max);\\n        if(close < open)\\n            backtrack(list, str+\")\", open, close+1, max);\\n    }\\n\\nThis is very easy to understand by first getting all permutations of perenthesis and eliminating based on case 1 and case 2\\n\\n![image](https://assets.leetcode.com/users/raghur/image_1562256962.png)\\n\\n![image](https://assets.leetcode.com/users/raghur/image_1562257162.png)\\n\\n![image](https://assets.leetcode.com/users/raghur/image_1562257179.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        backtrack(list, \"\", 0, 0, n);\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10250,
                "title": "simple-recursive-solution-0ms-in-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    void search(int left, int right, string path, vector<string>& v) {\\n        if(!left && !right) { v.push_back(path); return ; }\\n        if(left > 0) search(left-1, right, path+\"(\", v);\\n        if(left < right) search(left, right-1, path+\")\", v);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        search(n, n, \"\", v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void search(int left, int right, string path, vector<string>& v) {\\n        if(!left && !right) { v.push_back(path); return ; }\\n        if(left > 0) search(left-1, right, path+\"(\", v);\\n        if(left < right) search(left, right-1, path+\")\", v);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        search(n, n, \"\", v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235446,
                "title": "c-simple-very-easy",
                "content": "The idea is intuitive. Use two integers to count the remaining left parenthesis (left) and the right parenthesis (right) to be added.\\n**At each function call add a left parenthesis and add a right parenthesis if right>left. Add the result if left==0 and right==0.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void fun(int left,int right,string s)\\n    {\\n        if(left<0||right<0)\\n        {\\n          return;\\n        }\\n        if(left==0 and right==0)\\n        {\\n          ans.push_back(s);\\n          return;\\n        }\\n      \\n       fun(left-1,right,s+\"(\");\\n\\t   \\n       if(right>left)\\n\\t   {\\n\\t   fun(left,right-1,s+\")\");\\n\\t   }\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        fun(n,n,\"\");\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void fun(int left,int right,string s)\\n    {\\n        if(left<0||right<0)\\n        {\\n          return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1599246,
                "title": "python-with-detailed-explanation-faster-than-96-54-recursive-iterative-backtracking",
                "content": "##### Lets define our goal, choise and constraints\\n##### Goal (base case) (when to return from the recurresion) --> generate nx2 valid parentheses \\n\\t- to put n*2 valid parentheses\\n\\n##### Choise : (what to do at each recurssion)\\n\\tDo I open a bracket or do I close a bracket\\n\\n##### Constraints (guide the recurssion)\\n\\t- I can\\'t open a braket more than what I\\'ve given --> left < n\\n\\t- I can\\'t close bracket more than what I\\'ve opened --> right < left\\n\\n### Approach as shown in the figure --> this can easily be solved using DFS approach or backtracking\\n\\n### #Then build a recurssion tree using either\\n*  recursive (option 1)\\n* Iterative (option 2)\\n\\n![image](https://assets.leetcode.com/users/images/1e331a2b-7082-46fd-ab41-843d3065e72b_1638037786.9646535.png)\\n\\n#### Option -1 (Recursive)\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"        \\n        out = []\\n        def back_track(par=\\'\\', left=0,right=0):\\n            #base case --> if we generate parthenis with len 2*n we hit our goal\\n            if len(par) == 2*n:\\n                out.append(par)            \\n            if left < n: # if we still have less opened bracket than the allowed n value --> we can still open more\\n                back_track(par+\\'(\\', left+1,right)\\n            if right < left: # we can only close the opened brackets\\n                back_track(par+\\')\\', left, right+1)\\n                \\n        back_track()\\n        return out\\n```\\n\\n#### Option -2 (Iterative)\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        out = []\\n        stack = []\\n        stack.append([\\'(\\',1,0])\\n        while stack:\\n            val, left, right = stack.pop()\\n            if len(val) == 2*n:\\n                out.append(val)                \\n            if left < n:\\n                stack.append([val+\\'(\\', left+1,right])\\n            if right < left:\\n                stack.append([val+\\')\\', left, right+1])                \\n        return out\\n```\\n\\n### If this solution/explanation helps you, don\\'t forget to upvote as a sign of appreciation",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"        \\n        out = []\\n        def back_track(par=\\'\\', left=0,right=0):\\n            #base case --> if we generate parthenis with len 2*n we hit our goal\\n            if len(par) == 2*n:\\n                out.append(par)            \\n            if left < n: # if we still have less opened bracket than the allowed n value --> we can still open more\\n                back_track(par+\\'(\\', left+1,right)\\n            if right < left: # we can only close the opened brackets\\n                back_track(par+\\')\\', left, right+1)\\n                \\n        back_track()\\n        return out\\n```\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        out = []\\n        stack = []\\n        stack.append([\\'(\\',1,0])\\n        while stack:\\n            val, left, right = stack.pop()\\n            if len(val) == 2*n:\\n                out.append(val)                \\n            if left < n:\\n                stack.append([val+\\'(\\', left+1,right])\\n            if right < left:\\n                stack.append([val+\\')\\', left, right+1])                \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545154,
                "title": "java-tc-o-4-n-sqrt-n-sc-o-n-backtracking-iterative-solutions",
                "content": "**Backtracking solution**\\n```\\n/**\\n * Backtracking solution\\n *\\n * Time Complexity: Very loose Upper Bound O(2N * 2^(2N)). As each place has only 2 options.\\n *\\n * Since number of valid combinations is equal to n-th Catalan number. n-th\\n * Catalan number = 1/(n+1) * C(2n, n) which is bounded asymptotically by 4^N /\\n * (N * sqrt(N)). Thus time complexity will be O(4^N / sqrt(N)).\\n *\\n * Space Complexity: O(N) -> Recursion stack size. O(4^N / sqrt(N)) to save the\\n * valid combinations in result list.\\n *\\n * N = Input number.\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        if (n < 0) {\\n            return result;\\n        }\\n        generateParenthesisHelper(result, n, n, new StringBuilder());\\n        return result;\\n    }\\n\\n    private void generateParenthesisHelper(List<String> result, int open, int close, StringBuilder sb) {\\n        if (open == 0 && close == 0) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n\\n        if (open > 0) {\\n            sb.append(\"(\");\\n            generateParenthesisHelper(result, open - 1, close, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n        if (open < close) {\\n            sb.append(\")\");\\n            generateParenthesisHelper(result, open, close - 1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution**\\n\\n```java\\n/**\\n * Iterative Solution\\n *\\n * Time and Space Complexity\\n *      = C0 + 2 (1*C1 + 2*C2 + 3*C3 + 4*C4 + ... + N*CN)\\n *\\n * Where, C0 -> 0th Catalan Number\\n *        C1 -> 1st Catalan Number\\n *        ...\\n *        CN -> Nth Catalan Number = 1/(n+1) * C(2n, n)\\n *              Nth Catalan Number is bounded asymptotically by 4^N / (N * sqrt(N))\\n *\\n * N = Input number\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        if (n < 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        List<List<String>> lists = new ArrayList<>();\\n        lists.add(Collections.singletonList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> list = new ArrayList<>();\\n            for (int j = 0; j < i; j++) {\\n                for (String first : lists.get(j)) {\\n                    for (String second : lists.get(i - 1 - j)) {\\n                        StringBuilder sb = new StringBuilder(\"(\");\\n                        sb.append(first).append(\")\").append(second);\\n                        list.add(sb.toString());\\n                    }\\n                }\\n            }\\n            lists.add(list);\\n        }\\n\\n        return lists.get(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Backtracking solution\\n *\\n * Time Complexity: Very loose Upper Bound O(2N * 2^(2N)). As each place has only 2 options.\\n *\\n * Since number of valid combinations is equal to n-th Catalan number. n-th\\n * Catalan number = 1/(n+1) * C(2n, n) which is bounded asymptotically by 4^N /\\n * (N * sqrt(N)). Thus time complexity will be O(4^N / sqrt(N)).\\n *\\n * Space Complexity: O(N) -> Recursion stack size. O(4^N / sqrt(N)) to save the\\n * valid combinations in result list.\\n *\\n * N = Input number.\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        if (n < 0) {\\n            return result;\\n        }\\n        generateParenthesisHelper(result, n, n, new StringBuilder());\\n        return result;\\n    }\\n\\n    private void generateParenthesisHelper(List<String> result, int open, int close, StringBuilder sb) {\\n        if (open == 0 && close == 0) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n\\n        if (open > 0) {\\n            sb.append(\"(\");\\n            generateParenthesisHelper(result, open - 1, close, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n        if (open < close) {\\n            sb.append(\")\");\\n            generateParenthesisHelper(result, open, close - 1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Solution\\n *\\n * Time and Space Complexity\\n *      = C0 + 2 (1*C1 + 2*C2 + 3*C3 + 4*C4 + ... + N*CN)\\n *\\n * Where, C0 -> 0th Catalan Number\\n *        C1 -> 1st Catalan Number\\n *        ...\\n *        CN -> Nth Catalan Number = 1/(n+1) * C(2n, n)\\n *              Nth Catalan Number is bounded asymptotically by 4^N / (N * sqrt(N))\\n *\\n * N = Input number\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        if (n < 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        List<List<String>> lists = new ArrayList<>();\\n        lists.add(Collections.singletonList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> list = new ArrayList<>();\\n            for (int j = 0; j < i; j++) {\\n                for (String first : lists.get(j)) {\\n                    for (String second : lists.get(i - 1 - j)) {\\n                        StringBuilder sb = new StringBuilder(\"(\");\\n                        sb.append(first).append(\")\").append(second);\\n                        list.add(sb.toString());\\n                    }\\n                }\\n            }\\n            lists.add(list);\\n        }\\n\\n        return lists.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276140,
                "title": "generate-parentheses-js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWe can make short work of this problem with a basic branching **recursive** function (**dfs**). Our recursive function will iterate through the index positions (**pos**) of a possible result. At each **pos**, we can add an open parenthesis if there\\'s more remaining space than unclosed parentheses (**open**) and we can add a closed parenthesis if there are any unclosed parentheses. Once we reach the end of the result, we can add it to our answer array (**ans**).\\n\\nTo make things easier, we can use **bit manipulation** to pass the sequence of parentheses (**seq**) for our potential result as an integer to each new recursion level. Then we just have to translate **seq** to a parentheses string before adding it to **ans**.\\n\\nOnce we\\'re all done, we can just **return ans**.\\n\\n - _**Time Complexity: O((2 * N)!/(N! * N!)** reflecting the **2N choose N** possible arrangements of parentheses_\\n - _**Space Complexity: O(N)** for the recursion stack and **res**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 40.4MB** (beats 96% / 25%).\\n```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.3MB** (beats 96% / 96%).\\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 93%).\\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 13.7MB** (beats 100% / 57%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942530,
                "title": "from-naive-solution-to-optimal-using-dfs",
                "content": "To start, I wanted to use DFS to generate all combinations of parentheses, and then validate them after. Note for the DFS part, this does not generate **vaild parentheses**, just all combinations. Using DFS is pretty easy to generate them here.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const dfs = (str, n) => {\\n        if(n == 0) {\\n            res.push(str);\\n            return;\\n        }\\n        dfs(str+\"(\", n-1)\\n        dfs(str+\")\", n-1)\\n    }\\n    dfs(\"\", 2*n)\\n\\t// validate the combinations in the res array\\n    \\n    // ... some code to validate them, remove those that are invalid. \\n    // the solution to https://leetcode.com/problems/valid-parentheses/\\n\\n    // res contains valid combinations now\\n    return res\\n};\\n```\\n\\nWhile this is ok, we can do better. I started to think about the graph that was being genearted by DFS and where I could reduce further recursive calls and found some \\'base\\' cases.\\n\\n![image](https://assets.leetcode.com/users/images/563022d4-95f3-48d8-b30f-f81e5033a244_1605860755.9753644.png)\\n\\nWith this, I knew I could cut down on recursive calls for DFS with better base cases, esentially checking for the valid combinations as I generate them. I needed to translate my base cases into code.\\n\\nBefore, I was using `n` as my depth in DFS, terminating if n reached 0. I knew that the depth was correct for `n`, but I realized that I could keep better track of the number of `(` and `)` by using `n` for `(` and for `)` yeilding the same `2*n` I was using before. We can use those to track how many `(` and `)` have been used in any given call.\\n\\nKnowing this, I was able to translate my 2 additional base cases here, given that I can track the number of `(` and `)` current in use. For the left sub tree, since Its always possible to open with `(` the base case was to stop if the number of `(` exceeded 3. For the right sub tree, if there are more `)` than there currently are `(`, then it would not be possible to have a valid combination from this branch.\\n\\nWith this, we can write optimal code that validates combinations while using DFS\\n\\n```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const dfs = (str, left, right) => {\\n        if(left === 0 && right === 0) {\\n            res.push(str);\\n            return;\\n        }\\n        if(right < left) return\\n        if(left < 0) return\\n        dfs(str+\"(\", left - 1, right)\\n        dfs(str+\")\", left, right - 1)\\n    }\\n    dfs(\"\", n, n)\\n    return res\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const dfs = (str, n) => {\\n        if(n == 0) {\\n            res.push(str);\\n            return;\\n        }\\n        dfs(str+\"(\", n-1)\\n        dfs(str+\")\", n-1)\\n    }\\n    dfs(\"\", 2*n)\\n\\t// validate the combinations in the res array\\n    \\n    // ... some code to validate them, remove those that are invalid. \\n    // the solution to https://leetcode.com/problems/valid-parentheses/\\n\\n    // res contains valid combinations now\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925723,
                "title": "rust-backtracking-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Generate Parentheses.\\nMemory Usage: 2.4 MB, less than 100.00% of Rust online submissions for Generate Parentheses.\\n```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        fn back_track(s: String, open: i32, close: i32) -> Vec<String> {\\n            let mut res = vec![];\\n            if open == 0 && close == 0 {\\n                return vec![s];\\n            }\\n            if open > 0 {\\n                res.append(&mut back_track(s.clone()+\"(\", open-1, close+1));\\n            }\\n            if close > 0 {\\n                res.append(&mut back_track(s.clone()+\")\", open, close-1));\\n            }\\n            res\\n        }\\n        back_track(\"\".to_string(), n, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        fn back_track(s: String, open: i32, close: i32) -> Vec<String> {\\n            let mut res = vec![];\\n            if open == 0 && close == 0 {\\n                return vec![s];\\n            }\\n            if open > 0 {\\n                res.append(&mut back_track(s.clone()+\"(\", open-1, close+1));\\n            }\\n            if close > 0 {\\n                res.append(&mut back_track(s.clone()+\")\", open, close-1));\\n            }\\n            res\\n        }\\n        back_track(\"\".to_string(), n, 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10296,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> ret;\\n            string s = \"\";\\n            if (n <= 0)\\n                return ret;\\n                \\n            recurParenthesis(n, n, ret, s);\\n        }\\n        \\n        void recurParenthesis(int leftNum, int rightNum, vector<string> &ret, string temp)\\n        {\\n            //leftNum means the number of open parenthesis available,rightNum means the number of close parenthesis available\\n            if (leftNum == 0 && rightNum == 0)\\n            {\\n                ret.push_back(temp);\\n                return;\\n            }\\n                \\n            if (leftNum > 0)\\n                recurParenthesis(leftNum-1, rightNum, ret, temp+'(');\\n            \\n            if (rightNum > 0)\\n            {\\n                if (leftNum < rightNum)\\n                    recurParenthesis(leftNum, rightNum-1, ret, temp+')');\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> ret;\\n            string s = \"\";\\n            if (n <= 0)\\n                return ret;\\n                \\n            recurParenthesis(n, n, ret, s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3674015,
                "title": "cpp-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ninitially we have number of open bracket is n and closed is also n.\\n\\nnow we can add \\'(\\' in the resultant string(i.e s) without any condition and Decrease the count for this and make the recursive call.\\n\\nbut to add \\')\\' in the resultant string there is a condition. the condition is  we can  add \\')\\'  only when the no of open bracket (i.e noOfOpenBracket) is less then the no of closed bracket\\n (i.e noOfCloseBracket) because all the closed bracket should make  pair with corresponding open bracket.\\n\\nmeans  for n=3 the string \"( ) ****)**** ( ( )\" is not valid beacuse  the 2nd closed bracket doesn\\'t have the corresponding open bracket before it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<string> ans;\\n    void workfunc(int noOfOpenBracket,int noOfCloseBracket,string s)\\n    {\\n        if(noOfOpenBracket==0 && noOfCloseBracket==0)\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(noOfOpenBracket<noOfCloseBracket)\\n        {\\n            workfunc(noOfOpenBracket,noOfCloseBracket-1,s+\\')\\');\\n        }\\n        if(noOfOpenBracket>0)\\n        workfunc(noOfOpenBracket-1,noOfCloseBracket,s+\\'(\\');\\n    }\\n    \\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        workfunc(n,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\n    void workfunc(int noOfOpenBracket,int noOfCloseBracket,string s)\\n    {\\n        if(noOfOpenBracket==0 && noOfCloseBracket==0)\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(noOfOpenBracket<noOfCloseBracket)\\n        {\\n            workfunc(noOfOpenBracket,noOfCloseBracket-1,s+\\')\\');\\n        }\\n        if(noOfOpenBracket>0)\\n        workfunc(noOfOpenBracket-1,noOfCloseBracket,s+\\'(\\');\\n    }\\n    \\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        workfunc(n,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945298,
                "title": "java-backtracking-with-recursive-tree",
                "content": "**Steps**\\n\\n\\t\\t\\t\\u26ABMake a List ans to add valid strings.\\n\\t\\t\\t\\u26ABMake a recursive function for generating all the possible parentheses.\\n\\t\\t\\t\\u26ABif  String.lengh() == n*2, add the string to the ans list ans return.\\n\\n![image](https://assets.leetcode.com/users/images/b6ae94c1-f29b-46a0-9817-d07778b5b105_1649914093.6822052.jpeg)\\n\\n```\\n public List<String> generateParenthesis(int n) {\\n        ArrayList<String> ans = new ArrayList<>();\\n            bt(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\n    \\n    public void bt(ArrayList<String> ans, String p, int open, int close, int n){\\n        if(p.length() == n*2){\\n            ans.add(p);\\n            return;\\n        }\\n        \\n        if(open < n){\\n            bt(ans, p + \"(\", open + 1, close, n);\\n        }\\n        \\n        if(close < open){\\n            bt(ans, p + \")\", open, close + 1, n);\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public List<String> generateParenthesis(int n) {\\n        ArrayList<String> ans = new ArrayList<>();\\n            bt(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\n    \\n    public void bt(ArrayList<String> ans, String p, int open, int close, int n){\\n        if(p.length() == n*2){\\n            ans.add(p);\\n            return;\\n        }\\n        \\n        if(open < n){\\n            bt(ans, p + \"(\", open + 1, close, n);\\n        }\\n        \\n        if(close < open){\\n            bt(ans, p + \")\", open, close + 1, n);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1899635,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var res: [String] = []\\n\\n\\n        func backtrack(_ path: [String], _ target: Int) {\\n            var path = path\\n            var count = 0\\n\\n            if path.count == n * 2 {\\n                var string = \"\"\\n                for s in path { string += s }\\n                res.append(string)\\n                return\\n            }\\n\\n            for c in path where c == \"(\" { count += 1 }\\n            for c in [\"(\", \")\"] {\\n                if (c == \"(\" && count >= n) || (c == \")\" && path.count - count >= count)  { continue }\\n                path.append(c)\\n                backtrack(path, target - 1)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n\\n        backtrack([], n * 2)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var res: [String] = []\\n\\n\\n        func backtrack(_ path: [String], _ target: Int) {\\n            var path = path\\n            var count = 0\\n\\n            if path.count == n * 2 {\\n                var string = \"\"\\n                for s in path { string += s }\\n                res.append(string)\\n                return\\n            }\\n\\n            for c in path where c == \"(\" { count += 1 }\\n            for c in [\"(\", \")\"] {\\n                if (c == \"(\" && count >= n) || (c == \")\" && path.count - count >= count)  { continue }\\n                path.append(c)\\n                backtrack(path, target - 1)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n\\n        backtrack([], n * 2)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177483,
                "title": "dfs",
                "content": "**Recursive procedural helper**\\n```\\nclass Solution \\n{\\n    vector<string> out;\\n    \\n    void dfs(string s, int x, int y)\\n    {\\n        if(!y)  out.push_back(s);\\n        if(x)   dfs(s+\\'(\\', x-1, y);\\n        if(x<y) dfs(s+\\')\\', x,   y-1);\\n    }        \\npublic:\\n    vector<string> generateParenthesis(int n) \\n    {\\n        dfs(\"\"s, n, n);\\n        return out;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/0c8c9134-caf3-4ff5-996b-4ad1c2e696de_1619440710.3991406.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    vector<string> out;\\n    \\n    void dfs(string s, int x, int y)\\n    {\\n        if(!y)  out.push_back(s);\\n        if(x)   dfs(s+\\'(\\', x-1, y);\\n        if(x<y) dfs(s+\\')\\', x,   y-1);\\n    }        \\npublic:\\n    vector<string> generateParenthesis(int n) \\n    {\\n        dfs(\"\"s, n, n);\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034005,
                "title": "python-6-approches-visuals-iterative-recursive-dfs-bfs",
                "content": "\\n------------------------------\\n**Approach 1 : Brute-force : Iterative DFS with an explicit stack**\\n- Generate all combinations (geerate recursive tree)\\n- Test each combo (aka path in the space-tree) to see if it\\'s valid -> If yes, add to results\\n- ---------------------------\\n\\n**Idea:**\\n![image](https://assets.leetcode.com/users/images/ef4dec06-d495-4650-a97a-538c63f0db54_1611524590.783094.png)\\n\\n\\n**Big-O:**\\n* **Time**: `O(2^2n) + (4n^2)` \\n\\n\\t* Explanation:\\n\\t\\t* DFS traversal of the space-tree takes `O(E+V)`\\n\\t\\t* space-tree is a binary tree => number of edges is constant and is equal 2 => `E = 2`\\n\\t\\t* `V = number of verticies = (number of paths(leaves) in the space-tree)  * (number of nodes along each path )`  -- See NOTE [1] - choosing and counting\\n\\t\\t* ` V = 2^(2n) * (2n)` for the main logic\\n\\t\\t* Helper is invoked only at the leaves\\n\\t\\t\\t* There are `2n` leaves\\n\\t\\t\\t* A single invokation of `isValid()` costs `O(2n)`\\n\\t\\t\\t* Total cost for helper => `2n*2n` => `4n^2`\\n\\t\\t\\n\\t\\t* Overall big-O main: `O(2^2n)` + helper: `(4n^2)` \\n\\t\\t* **NOTE [1]**\\n\\t\\t![image](https://assets.leetcode.com/users/images/cc712e5e-c3a9-4d59-a7e2-7183d33d50bd_1611524625.0196075.png)\\n\\n\\t\\t\\n* **Space**:  `O(2n)`\\n\\t* Explanation: \\n\\t\\t* Stack contains max of 2n nodes at any given time => thus\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tstack = [(n*2, \"\")]\\n\\twhile stack:\\n\\t\\tbrackets, path = stack.pop()\\n\\t\\t# print(brackets, path)\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tstack.append((brackets-1, path+\")\"))\\n\\t\\t\\tstack.append((brackets-1, path+\"(\"))  \\n\\treturn res\\n```\\n\\n------------------------------\\n**Approach 2 : Brute-force : Iterative BFS with an queue**\\n- Generate all combinations (geerate recursive tree)\\n- Test each combo (aka path in the space-tree) to see if it\\'s valid -> If yes, add to results\\n- ---------------------------\\n**Idea:**\\n* Exactly the same idea as in `Approach 1` except the traversal is BFS using a queue\\n\\n**Big-O:**\\n* Time: `O(2^2n) + (4n^2)` \\n* Space:  `O(2n)`\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((n*2, \"\"))\\n\\twhile q:\\n\\t\\tbrackets, path = q.popleft()\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tq.append((brackets-1, path+\"(\")) \\n\\t\\t\\tq.append((brackets-1, path+\")\"))\\t\\n\\treturn res\\n```\\n------------------------------\\n**Approach 3 : Brute-force : Recursive : Implicit Stack**\\n- Generate all combinations (geerate recursive tree)\\n- Test each combo (aka path in the space-tree) to see if it\\'s valid -> If yes, add to results\\n- ---------------------------\\n\\n**Idea:**\\n* Exactly the same idea as in `Approach 1` except the traversal is done recursively using an implicit stack\\n\\n**Big-O:**\\n* Time: `O(2^2n) + (4n^2)` \\n* Space: `O(2n)` - length of `path`\\n\\n**Code:**\\n\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\t# isValid helper:\\n        def isValid(combo):\\n            stack = []\\n            for br in combo:\\n                if stack:\\n                    prev = stack[-1]\\n                    if prev == \"(\" and br == \")\":\\n                        stack.pop()\\n                    else:\\n                        stack.append(br)\\n                else:\\n                    stack.append(br)\\n            if not stack:\\n                return True\\n            return False\\n        \\n        # recursive helper\\n        def recursive(n, path=\"\", res=[]):\\n            if not n:\\n                if isValid(path):\\n                    res.append(path)\\n            else:\\n                recursive(n-1, path+\"(\", res)\\n                recursive(n-1, path+\")\", res)\\n                \\n            return res\\n            \\n        # main\\n        return recursive(2*n, \"\", [])\\n```\\n\\n\\n------------------------------\\n**Approach 4 : Prune and Search : Discard path As Soon As Possible : Iterative DFS with explicit stack** \\n- ---------------------------\\n**Idea:**\\n![image](https://assets.leetcode.com/users/images/2714606e-9558-48b9-a322-70702a0cb8e6_1611544722.8530722.png)\\n\\n* Don\\'t wait until an entrie combination/path is fully generated only to discard it at the end if proves to be invalid\\n* Instead, only generate comboniations that we know are valid and prune the ones that are invalid\\n\\t* \\tEverytime we add a bracket -> decrement n \\n\\t* \\tOnly add open bracket if open < n\\n\\t* \\tOny add close-bracket if does not exceed number of open-bracket\\n\\t* \\tn here is half the combo/path (aka number of pairs)\\n\\n* **This is Prunning, not backtracking**\\n\\t* For some reason, Leetcode posts insist on using the term \"backtracking\" when describing anything related to a recursive algorithm.\\n\\t* Backtracking is when you have to remove/delete a previous step to reach an earlier state of a solution. Period.\\n\\n**Big-O:**\\n* Time: `<` `O(2^2n * 2n)` - Since many branches will be pruned\\n* Space: `O(2n)` - size of the explicit stack (or, length of `path`)\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\t\\tstack = [(2*n,\"\", 0, 0)] # since out isValid function onlu needs to operate on the basis of (num of pairs / aka half the path) - as opposed to approach 2\\n\\n\\twhile stack:\\n\\t\\tbrackets, path, closeBr, openBr = stack.pop()\\n\\t\\tif not brackets:\\n\\t\\t\\tres.append(path)\\n\\n\\t\\telse:\\n\\t\\t\\tif closeBr < openBr:\\n\\t\\t\\t\\tstack.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\t\\tstack.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\n\\treturn res\\n```\\n\\n------------------------------\\n**Approach 5 : Prune and Search : Discard path As Soon As Possible : Iterative BFS with queue** \\n- ---------------------------\\n\\n**Idea:**\\n\\n**Big-O:**\\n* Time: `<` `O(2^2n * 2n)` - Since many branches will be pruned\\n* Space: `O(2n)` - size of the queue (or, length of `path`)\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((2*n,\"\", 0, 0)) \\n\\nwhile q:\\n\\tbrackets, path, closeBr, openBr = q.popleft()\\n\\tif not brackets:\\n\\t\\tres.append(path)\\n\\n\\telse:\\n\\t\\tif closeBr < openBr:\\n\\t\\t\\tq.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\tq.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\nreturn res\\n```\\n\\n------------------------------\\n**Approach 6 : Prune and Search : Discard path As Soon As Possible : Recursive DFS with Implicit Stack**\\n- ---------------------------\\n\\n**Idea:**\\n* Exactly like `Approach 4` except the traversal is done recursively using an implicit stack\\n\\n**Big-O:**\\n* Time: `<` `O(2^2n * 2n)` - Since many branches will be pruned\\n* Space: `O(2n)` - length of `path`\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\n\\t# --- recursive helper --- :\\n\\tdef recursive(brackets, path=\"\", res=[], left=0, right=0):\\n            # print(brackets, path, brackets//2, left, right)\\n            if not brackets:\\n                res.append(path)\\n            else:\\n                if right < left:\\n                    recursive(brackets-1, path+\")\", res, left, right+1)\\n                if left < n: # n should not be decremented as we decrement the number of brackets \\n                    recursive(brackets-1, path+\"(\", res, left+1, right)\\n                \\n            return res\\n        \\n\\t# --- main logic ---\\n\\treturn recursive(2*n, \"\", [], 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tstack = [(n*2, \"\")]\\n\\twhile stack:\\n\\t\\tbrackets, path = stack.pop()\\n\\t\\t# print(brackets, path)\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tstack.append((brackets-1, path+\")\"))\\n\\t\\t\\tstack.append((brackets-1, path+\"(\"))  \\n\\treturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((n*2, \"\"))\\n\\twhile q:\\n\\t\\tbrackets, path = q.popleft()\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tq.append((brackets-1, path+\"(\")) \\n\\t\\t\\tq.append((brackets-1, path+\")\"))\\t\\n\\treturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\t# isValid helper:\\n        def isValid(combo):\\n            stack = []\\n            for br in combo:\\n                if stack:\\n                    prev = stack[-1]\\n                    if prev == \"(\" and br == \")\":\\n                        stack.pop()\\n                    else:\\n                        stack.append(br)\\n                else:\\n                    stack.append(br)\\n            if not stack:\\n                return True\\n            return False\\n        \\n        # recursive helper\\n        def recursive(n, path=\"\", res=[]):\\n            if not n:\\n                if isValid(path):\\n                    res.append(path)\\n            else:\\n                recursive(n-1, path+\"(\", res)\\n                recursive(n-1, path+\")\", res)\\n                \\n            return res\\n            \\n        # main\\n        return recursive(2*n, \"\", [])\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\t\\tstack = [(2*n,\"\", 0, 0)] # since out isValid function onlu needs to operate on the basis of (num of pairs / aka half the path) - as opposed to approach 2\\n\\n\\twhile stack:\\n\\t\\tbrackets, path, closeBr, openBr = stack.pop()\\n\\t\\tif not brackets:\\n\\t\\t\\tres.append(path)\\n\\n\\t\\telse:\\n\\t\\t\\tif closeBr < openBr:\\n\\t\\t\\t\\tstack.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\t\\tstack.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\n\\treturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((2*n,\"\", 0, 0)) \\n\\nwhile q:\\n\\tbrackets, path, closeBr, openBr = q.popleft()\\n\\tif not brackets:\\n\\t\\tres.append(path)\\n\\n\\telse:\\n\\t\\tif closeBr < openBr:\\n\\t\\t\\tq.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\tq.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\nreturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\n\\t# --- recursive helper --- :\\n\\tdef recursive(brackets, path=\"\", res=[], left=0, right=0):\\n            # print(brackets, path, brackets//2, left, right)\\n            if not brackets:\\n                res.append(path)\\n            else:\\n                if right < left:\\n                    recursive(brackets-1, path+\")\", res, left, right+1)\\n                if left < n: # n should not be decremented as we decrement the number of brackets \\n                    recursive(brackets-1, path+\"(\", res, left+1, right)\\n                \\n            return res\\n        \\n\\t# --- main logic ---\\n\\treturn recursive(2*n, \"\", [], 0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 817715,
                "title": "easy-optimized-concise-and-faster-than-100-00-of-c-submissions",
                "content": "simple backtracking :\\n\\njust adding one by one opening and closing by generating all the combinations\\n\\nif (cur.size()==2*max )   :  we got one combination completely \\n\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\n        vector<string> v;  \\n        ok(v,\"\",0,0,n);\\n        return v;\\n\\t\\t\\n    }\\n    \\n    void ok(vector<string> &v,string cur,int open,int close,int max)\\n    {\\n        if(cur.size()==max*2) // we got the complete combination\\n        {\\n            v.push_back(cur);\\n            return ;\\n        }\\n        \\n        if(open<max) ok(v,cur+\\'(\\',open+1,close,max);     // add opening\\n        if(close<open) ok (v,cur+\\')\\',open,close+1,max);  //add closing\\n        \\n    }",
                "solutionTags": [],
                "code": "simple backtracking :\\n\\njust adding one by one opening and closing by generating all the combinations\\n\\nif (cur.size()==2*max )   :  we got one combination completely \\n\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\n        vector<string> v;  \\n        ok(v,\"\",0,0,n);\\n        return v;\\n\\t\\t\\n    }\\n    \\n    void ok(vector<string> &v,string cur,int open,int close,int max)\\n    {\\n        if(cur.size()==max*2) // we got the complete combination\\n        {\\n            v.push_back(cur);\\n            return ;\\n        }\\n        \\n        if(open<max) ok(v,cur+\\'(\\',open+1,close,max);     // add opening\\n        if(close<open) ok (v,cur+\\')\\',open,close+1,max);  //add closing\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10351,
                "title": "1-ms-beats-92-of-submissions-easy-java-space-optimized-solution",
                "content": "    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        char[] perm = new char[n*2];\\n        perms(n, n, perm, 0, res);\\n        return res;\\n    }\\n    \\n    private void perms(int open, int close, char[] perm, int i, List<String> res) {\\n        if (i == perm.length) {\\n            res.add(new String(perm));\\n            return;\\n        }\\n        if (open > 0 && close >= open) {\\n            perm[i] = '(';\\n            perms(open - 1, close, perm, i+1, res);\\n        }\\n        if (close > 0) {\\n            perm[i] = ')';\\n            perms(open, close - 1, perm, i+1, res);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        char[] perm = new char[n*2];\\n        perms(n, n, perm, 0, res);\\n        return res;\\n    }\\n    \\n    private void perms(int open, int close, char[] perm, int i, List<String> res) {\\n        if (i == perm.length) {\\n            res.add(new String(perm));\\n            return;\\n        }\\n        if (open > 0 && close >= open) {\\n            perm[i] = '(';\\n            perms(open - 1, close, perm, i+1, res);\\n        }\\n        if (close > 0) {\\n            perm[i] = ')';\\n            perms(open, close - 1, perm, i+1, res);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10393,
                "title": "7-lines-in-python-44-ms",
                "content": "n - how many parenthesis can still be opened\\nopen - how many parenthesis are opened\\n\\n    class Solution:\\n        def generateParenthesis(self, n, open=0):\\n            if n == 0: return [')'*open]\\n            if open == 0:\\n                return ['('+x for x in self.generateParenthesis(n-1, 1)]\\n            else:\\n                return [')'+x for x in self.generateParenthesis(n, open-1)] + ['('+x for x in self.generateParenthesis(n-1, open+1)]",
                "solutionTags": [],
                "code": "n - how many parenthesis can still be opened\\nopen - how many parenthesis are opened\\n\\n    class Solution:\\n        def generateParenthesis(self, n, open=0):\\n            if n == 0: return [')'*open]\\n            if open == 0:\\n                return ['('+x for x in self.generateParenthesis(n-1, 1)]\\n            else:\\n                return [')'+x for x in self.generateParenthesis(n, open-1)] + ['('+x for x in self.generateParenthesis(n-1, open+1)]",
                "codeTag": "Java"
            },
            {
                "id": 10198,
                "title": "does-anyone-come-up-with-a-non-recursion-solution",
                "content": "I used recursion as below:\\n\\n    class Solution:\\n    \\n        def generateParenthesis(self, n):\\n            if (n == 0):\\n                return []\\n            string = \"(\"\\n            result = []\\n            left_number = 1\\n            right_number = 0\\n            self.solve(left_number, right_number, string, n, result)\\n            return result\\n            \\n        def solve(self, l_n, r_n, string, n, result):\\n            if (l_n == r_n and r_n == n):\\n                result.append(string)\\n                return\\n            \\n            if (l_n < n):\\n                self.solve(l_n+1, r_n, string+'(', n, result)\\n                \\n            if (r_n < l_n):\\n                self.solve(l_n, r_n+1, string+')', n, result)\\n\\nI am trying to get an iteration solution but haven't got a clue yet.",
                "solutionTags": [],
                "code": "I used recursion as below:\\n\\n    class Solution:\\n    \\n        def generateParenthesis(self, n):\\n            if (n == 0):\\n                return []\\n            string = \"(\"\\n            result = []\\n            left_number = 1\\n            right_number = 0\\n            self.solve(left_number, right_number, string, n, result)\\n            return result\\n            \\n        def solve(self, l_n, r_n, string, n, result):\\n            if (l_n == r_n and r_n == n):\\n                result.append(string)\\n                return\\n            \\n            if (l_n < n):\\n                self.solve(l_n+1, r_n, string+'(', n, result)\\n                \\n            if (r_n < l_n):\\n                self.solve(l_n, r_n+1, string+')', n, result)\\n\\nI am trying to get an iteration solution but haven't got a clue yet.",
                "codeTag": "Java"
            },
            {
                "id": 2422357,
                "title": "everything-explained-using-comment-backtracking-recursion-c-java",
                "content": "```\\n// STEPS TO SOLVE THE PROBLEM:\\n\\n// Create a vector that will store the result.\\n// Call our backtracking function with empty string and initial number of opening and closing parentheses.\\n// Check the base case. If number of opening and closing parentheses are equal to n then we will add the string to the vector and return.\\n// If the base case does not meet then we will check if number of opening parentheses is less than n, If true, then we will add ( to the current string and increment the count of opening parenthesis.\\n// Check if number of closing parentheses is less than open parentheses then we will add ) to the current string and increment the count of closing parentheses.\\n\\n\\n// C++ Solution:\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        \\n        // Resultant vector\\n        vector<string> ans; \\n        /// Recursively generate parentheses\\n        generateParenthesis(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\nprivate:\\n    void generateParenthesis(vector<string> &ans,string s,int open, int close,int n){\\n    // Base case\\n        if (open == n && close == n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(ans, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(ans, s + \")\", open, close + 1, n);\\n        }\\n    }\\n};\\n\\n\\n\\n// JAVA Solution:\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        \\n        // Resultant list\\n        List<String> result = new ArrayList<>();\\n        \\n        /// Recursively generate parentheses\\n        generateParenthesis(result, \"\", 0, 0, n);\\n        \\n        return result;\\n    }\\n    private void generateParenthesis(List<String> result, String s, int open, int close, int n) {\\n        // Base case\\n        if (open == n && close == n) {\\n            result.add(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(result, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(result, s + \")\", open, close + 1, n);\\n        }\\n    }\\n}\\n\\n\\n/* \\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// STEPS TO SOLVE THE PROBLEM:\\n\\n// Create a vector that will store the result.\\n// Call our backtracking function with empty string and initial number of opening and closing parentheses.\\n// Check the base case. If number of opening and closing parentheses are equal to n then we will add the string to the vector and return.\\n// If the base case does not meet then we will check if number of opening parentheses is less than n, If true, then we will add ( to the current string and increment the count of opening parenthesis.\\n// Check if number of closing parentheses is less than open parentheses then we will add ) to the current string and increment the count of closing parentheses.\\n\\n\\n// C++ Solution:\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        \\n        // Resultant vector\\n        vector<string> ans; \\n        /// Recursively generate parentheses\\n        generateParenthesis(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\nprivate:\\n    void generateParenthesis(vector<string> &ans,string s,int open, int close,int n){\\n    // Base case\\n        if (open == n && close == n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(ans, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(ans, s + \")\", open, close + 1, n);\\n        }\\n    }\\n};\\n\\n\\n\\n// JAVA Solution:\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        \\n        // Resultant list\\n        List<String> result = new ArrayList<>();\\n        \\n        /// Recursively generate parentheses\\n        generateParenthesis(result, \"\", 0, 0, n);\\n        \\n        return result;\\n    }\\n    private void generateParenthesis(List<String> result, String s, int open, int close, int n) {\\n        // Base case\\n        if (open == n && close == n) {\\n            result.add(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(result, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(result, s + \")\", open, close + 1, n);\\n        }\\n    }\\n}\\n\\n\\n/* \\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737086,
                "title": "backtracking-solution-with-explanations-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Solve this using ***Backtracking***.\\n- We\\u2019ll have 2*n characters, including n open and n close bracket if it is a valid parenthesis.\\n- We\\u2019ll pass an empty string & open, close tag numbers left.\\n- Base condition: if both open & close equals 0, means we can\\u2019t add any more parenthesis.\\n- if **`open > 0`** means we can add an opening bracket, so add it and decrease its size by 1, **`help(s+\"(\", open-1, close)`.**\\n- if **`open < close`** means we already added 1 or more opening brackets, so now we can add closing one and decrease its size by 1, **`help(s+\")\", open, close-1)`.**\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        help(\"\",n,n);\\n        return ans;\\n    }\\n    void help(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open > 0) help(s+\"(\", open-1, close);\\n        if(open < close) help(s+\")\", open, close-1);\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        help(\"\",n,n);\\n        return ans;\\n    }\\n    void help(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open > 0) help(s+\"(\", open-1, close);\\n        if(open < close) help(s+\")\", open, close-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276582,
                "title": "generate-parentheses-short-easy-solution-w-explanation-beats-100",
                "content": "\\u2714\\uFE0F ***Solution - I (Brute - Force)***\\n\\nWe have `n` pair of parenthesis which means we are required to form a valid parenthesis string of `length == 2*n`. Let\\'s start with the brute-force way. At each position of the string, we can insert **`(`** or **`)`** brackets and so we will try both the options. Atlast, when the length of string becomes `2*n`, we will perform a check and insert into `ans` array if it is valid.\\n\\n```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup> * n)</code>**, for each index in string, we try both the parenthesis which is <code>2`*`2`*`2...2n times = O(2<sup>2n</sup>) = O(4<sup>n</sup>) </code> and lastly, we spend an `O(n)` time to check for the formed string\\'s validity. \\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>** (A tighter bound exists)\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Approach)***\\n\\nInstead of trying out both the brackets at each index of the string, we only try them at places which won\\'t outright invalidate the string. For eg. In the previous approach, we were trying to insert `)` even at the start which would surely not have generated a valid parenthesis. Here, we avoid that. We have 2 cases:\\n\\n* **`(`** can be inserted anywhere till its count is less than `n`\\n* **`)`** can be inserted whenever its count is less than `start` (number of openinig parenthesis)\\n\\nFinally, we will insert the string when its length reaches `2*n`.\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup>)</code>** Here we save the time for string validation at the end and also avoid the extra recursive calls which we know are invalid anyway. \\n**Note**: There exists a tighter bound - <code>O(4<sup>n</sup> / &radic;n)</code>  but without deep analysis of the recursion structure, it\\'s very hard to arrive at it. So, <code>O(4<sup>n</sup>)</code> is good enough for quick estimations\\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>**, Tighter bound - **<code>O(4<sup>n</sup> / &radic;n)</code>**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/001e3d19-b69f-4c1b-96c9-f760343aef54_1623844459.7738905.png  /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729851,
                "title": "no-backtracking-no-recursion-bfs-based-approach-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        //pair of pair, <current_buffer,<open count,closed count>>\\n        queue<pair<string,pair<int,int>>>q;\\n        q.push({\"\",{0,0}});\\n        vector<string>ans;\\n        while(!q.empty())\\n        {\\n            pair<string,pair<int,int>>p = q.front();\\n            q.pop();\\n            //if count of both open and closed parenthesis count is n, we found one permutation, add it to ans;\\n            if(p.second.first==n&&p.second.second==n){\\n                ans.push_back(p.first);\\n            }\\n            else\\n            {\\n                //add open parenthesis if open parenthesis count<n;\\n                if(p.second.first<n){\\n                    q.push({p.first+\"(\",{p.second.first+1,p.second.second}});\\n                }\\n                // add closing parenthesis if closedparenthesis count < open parenthesis count  \\n                if(p.second.second<p.second.first){\\n                    q.push({p.first+\")\",{p.second.first,p.second.second+1}});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThumbs up if you like it. Thanks!",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        //pair of pair, <current_buffer,<open count,closed count>>\\n        queue<pair<string,pair<int,int>>>q;\\n        q.push({\"\",{0,0}});\\n        vector<string>ans;\\n        while(!q.empty())\\n        {\\n            pair<string,pair<int,int>>p = q.front();\\n            q.pop();\\n            //if count of both open and closed parenthesis count is n, we found one permutation, add it to ans;\\n            if(p.second.first==n&&p.second.second==n){\\n                ans.push_back(p.first);\\n            }\\n            else\\n            {\\n                //add open parenthesis if open parenthesis count<n;\\n                if(p.second.first<n){\\n                    q.push({p.first+\"(\",{p.second.first+1,p.second.second}});\\n                }\\n                // add closing parenthesis if closedparenthesis count < open parenthesis count  \\n                if(p.second.second<p.second.first){\\n                    q.push({p.first+\")\",{p.second.first,p.second.second+1}});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248359,
                "title": "extremely-simple-java-dfs-beats-100",
                "content": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        build(n, \"\", output, n, n);\\n        return output;\\n    }\\n    \\n    \\n    public void build(int n, String cur, List output, int left, int right) {\\n        if(left > right) return;\\n        \\n        if((left == 0 && right == 0)) {\\n            output.add(cur);\\n            return;\\n        }\\n        \\n        if(left > 0) {\\n            build(n, cur + \"(\", output, left - 1, right);\\n        }\\n        \\n        \\n        if(right > 0) {\\n            build(n, cur + \")\", output, left, right - 1);\\n        }\\n    }\\n}\\n``",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        build(n, \"\", output, n, n);\\n        return output;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1471383,
                "title": "c-100-faster-than-others",
                "content": "**Please Upvote if like the Solution !**\\n\\n      vector<string> ans;\\n\\n    // Recursive function to generate valid parentheses combinations\\n     void Solve(int open, int close, string curr, int n) {\\n    // Base case: If the current combination\\'s length reaches 2*n, add it to the answer vector\\n    if (curr.size() == 2 * n) {\\n        ans.push_back(curr);\\n        return;\\n    }\\n    \\n    // If we can still add more opening parentheses, do so\\n    if (open < n) {\\n        Solve(open + 1, close, curr + \"(\", n);\\n    }\\n    \\n    // If we have more open parentheses than closing parentheses, add a closing parenthesis\\n    if (close < open) {\\n        Solve(open, close + 1, curr + \")\", n);\\n    }\\n    }\\n\\n    // Function to generate all valid combinations of parentheses\\n    vector<string> generateParenthesis(int n) {\\n    // Clear the answer vector and start generating combinations\\n    ans.clear();\\n    Solve(0, 0, \"\", n);\\n    return ans;\\n\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "**Please Upvote if like the Solution !**\\n\\n      vector<string> ans;\\n\\n    // Recursive function to generate valid parentheses combinations\\n     void Solve(int open, int close, string curr, int n) {\\n    // Base case: If the current combination\\'s length reaches 2*n, add it to the answer vector\\n    if (curr.size() == 2 * n) {\\n        ans.push_back(curr);\\n        return;\\n    }\\n    \\n    // If we can still add more opening parentheses, do so\\n    if (open < n) {\\n        Solve(open + 1, close, curr + \"(\", n);\\n    }\\n    \\n    // If we have more open parentheses than closing parentheses, add a closing parenthesis\\n    if (close < open) {\\n        Solve(open, close + 1, curr + \")\", n);\\n    }\\n    }\\n\\n    // Function to generate all valid combinations of parentheses\\n    vector<string> generateParenthesis(int n) {\\n    // Clear the answer vector and start generating combinations\\n    ans.clear();\\n    Solve(0, 0, \"\", n);\\n    return ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1400055,
                "title": "generate-parentheses-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        permutationBalancedParenthesis(n, n, \"\", output);\\n        return output;\\n    }\\n    \\n    public void permutationBalancedParenthesis(int open, int close, String balancedParentheses, List<String> output) {\\n        /* leaf node in recursive tree */\\n        if(open == 0 && close == 0){\\n            output.add(balancedParentheses);\\n            return;\\n        } \\n        \\n        /* If there is an opening bracket then it is always a choice */\\n        if(open > 0){\\n            String openingBracket = balancedParentheses + \"(\";\\n            permutationBalancedParenthesis(open - 1, close, openingBracket, output);\\n        } \\n        \\n        /* There must be an opening bracket previously, which is yet to be closed. */\\n        if(close > open){\\n            String closingBracket = balancedParentheses + \")\";\\n            permutationBalancedParenthesis(open, close - 1, closingBracket, output);\\n        }\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE .\\nHappy Coding and keep up the good work :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        permutationBalancedParenthesis(n, n, \"\", output);\\n        return output;\\n    }\\n    \\n    public void permutationBalancedParenthesis(int open, int close, String balancedParentheses, List<String> output) {\\n        /* leaf node in recursive tree */\\n        if(open == 0 && close == 0){\\n            output.add(balancedParentheses);\\n            return;\\n        } \\n        \\n        /* If there is an opening bracket then it is always a choice */\\n        if(open > 0){\\n            String openingBracket = balancedParentheses + \"(\";\\n            permutationBalancedParenthesis(open - 1, close, openingBracket, output);\\n        } \\n        \\n        /* There must be an opening bracket previously, which is yet to be closed. */\\n        if(close > open){\\n            String closingBracket = balancedParentheses + \")\";\\n            permutationBalancedParenthesis(open, close - 1, closingBracket, output);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368413,
                "title": "simple-python-backtracking",
                "content": "The idea is that we keep track of a \"sum\" for the current string as we build up towards a valid combination and we enforce \"add 1\" whenever we add a \"(\" and \"minus 1\" whenver we add a \")\". Clearly, with this design, we only need to make sure that 1) \"sum\" never goes to negative and 2)we are not using up available parenthesis to reach valid solution. \\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n        ret=[]\\n        def dfs(s,r_l,r_r,cur):\\n            if s<0 or r_l<0 or r_r<0:\\n                return\\n            if r_l ==0 and r_r==0:\\n                ret.append(cur)\\n            dfs(s+1,r_l-1,r_r,cur+\\'(\\')\\n            dfs(s-1,r_l,r_r-1,cur+\\')\\')\\n        \\n        \\n        dfs(0,n,n,\\'\\')\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n        ret=[]\\n        def dfs(s,r_l,r_r,cur):\\n            if s<0 or r_l<0 or r_r<0:\\n                return\\n            if r_l ==0 and r_r==0:\\n                ret.append(cur)\\n            dfs(s+1,r_l-1,r_r,cur+\\'(\\')\\n            dfs(s-1,r_l,r_r-1,cur+\\')\\')\\n        \\n        \\n        dfs(0,n,n,\\'\\')\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1181112,
                "title": "easy-to-understand-python-no-recursion",
                "content": "```\\n\"\"\"\\n. represents occurrence of () in new n\\nn = 1, () \\nn = 2, (.), (). = ()(), (())\\nn = 3, .()(), (.)(), ().(), ()(.), ()()., .(()), (.()), ((.)), (().), (()).\\n\\nAvoid duplicates by using a set\\n\"\"\"\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 1:\\n            return [\"()\"]\\n        syms = {\"()\"}\\n        for j in range(n-1):\\n            new_syms = set()\\n            for sym in syms:\\n                for i in range(len(sym)):\\n                    new_syms.add(sym[:i] + \"()\" + sym[i:])\\n            syms = new_syms\\n        return syms",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 1:\\n            return [\"()\"]\\n        syms = {\"()\"}",
                "codeTag": "Java"
            },
            {
                "id": 304042,
                "title": "c-100-91-85-beats-using-c",
                "content": "Beated 100% / 91.85% (0ms / 7.8MB) of C submissions on runtime / memory.\\n\\nIn my solution, there\\'re two highlight points:\\n1. Calculate the returnsize precisely, in order to save memory.\\n1. Use bitwise operation to make my code a beautiful art.\\n\\nTip: I calculate the returnSize by finding the pattern among n=1,2,3,4,5... with the help of OEIS. You can find the integer sequent at here: https://oeis.org/A000108\\n\\nAnd Here\\'s my code:\\n\\n```\\nint size(int);\\n\\nchar ** generateParenthesis(int n, int* returnSize) {\\n    // Calculate the returnSize first for memory saving\\n    *returnSize = size(n);\\n    \\n    // Initiate the answer\\'s memory\\n    char** ans = (char**)malloc(sizeof(char*) * (*returnSize));\\n    memset(ans, 0, sizeof(char*) * (*returnSize));\\n    \\n    // [Explain about each Variable]\\n    // \"sum\" | Checking whether the present result is valide\\n    //\\n    //   \"i\" | Whether every digit is \\'(\\' or \\')\\'\\n    //       | \"i\" can be understood in binary way:\\n    //       | E.g. When n=2 and i=3, then i=0b0011\\n    //       |      Let\\'s define \\'(\\' as 1 and \\')\\' as 0, then:\\n    //       |      0b0011 reverse => 1 1 0 0\\n    //       |                        \\u2193 \\u2193 \\u2193 \\u2193\\n    //       |                        ( ( ) )\\n    //\\n    //   \"j\" | Searching in the sequence\\n    //\\n    //   \"k\" | Count the present index of answer string\\n    int sum, j, k = 0;\\n    \\n    for(int i = 0; i < (1 << (2 * n)); i++) {\\n        // Check Validity\\n        sum = 0;\\n        for(j = 0; j < 2 * n; j++) {\\n            sum += (i&(1<<j)) ? 1 : -1;\\n            if(sum < 0)\\n                break;\\n        }\\n        \\n        // If Valid then Output\\n        if(!sum) {\\n            ans[k] = (char*)malloc(sizeof(char) * 2 * n + 1);\\n            for(j = 0; j < 2 * n; j++)\\n                ans[k][j] = ((i&(1<<j)) ? \\'(\\' : \\')\\');\\n            ans[k][j] = 0;\\n            k++;\\n        }\\n    }\\n    \\n    return ans;\\n}\\n\\n// You can calculate the size by integer sequence A000108 on OEIS \\n// refrence to https://oeis.org/A000108\\nint size(int n) {\\n    int ans = 1;\\n    for(int i = 0; i < n; i++)\\n        ans *= (2 * n - i);\\n    for(int i = 0; i < n; i++)\\n        ans /= (n + 1 - i);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint size(int);\\n\\nchar ** generateParenthesis(int n, int* returnSize) {\\n    // Calculate the returnSize first for memory saving\\n    *returnSize = size(n);\\n    \\n    // Initiate the answer\\'s memory\\n    char** ans = (char**)malloc(sizeof(char*) * (*returnSize));\\n    memset(ans, 0, sizeof(char*) * (*returnSize));\\n    \\n    // [Explain about each Variable]\\n    // \"sum\" | Checking whether the present result is valide\\n    //\\n    //   \"i\" | Whether every digit is \\'(\\' or \\')\\'\\n    //       | \"i\" can be understood in binary way:\\n    //       | E.g. When n=2 and i=3, then i=0b0011\\n    //       |      Let\\'s define \\'(\\' as 1 and \\')\\' as 0, then:\\n    //       |      0b0011 reverse => 1 1 0 0\\n    //       |                        \\u2193 \\u2193 \\u2193 \\u2193\\n    //       |                        ( ( ) )\\n    //\\n    //   \"j\" | Searching in the sequence\\n    //\\n    //   \"k\" | Count the present index of answer string\\n    int sum, j, k = 0;\\n    \\n    for(int i = 0; i < (1 << (2 * n)); i++) {\\n        // Check Validity\\n        sum = 0;\\n        for(j = 0; j < 2 * n; j++) {\\n            sum += (i&(1<<j)) ? 1 : -1;\\n            if(sum < 0)\\n                break;\\n        }\\n        \\n        // If Valid then Output\\n        if(!sum) {\\n            ans[k] = (char*)malloc(sizeof(char) * 2 * n + 1);\\n            for(j = 0; j < 2 * n; j++)\\n                ans[k][j] = ((i&(1<<j)) ? \\'(\\' : \\')\\');\\n            ans[k][j] = 0;\\n            k++;\\n        }\\n    }\\n    \\n    return ans;\\n}\\n\\n// You can calculate the size by integer sequence A000108 on OEIS \\n// refrence to https://oeis.org/A000108\\nint size(int n) {\\n    int ans = 1;\\n    for(int i = 0; i < n; i++)\\n        ans *= (2 * n - i);\\n    for(int i = 0; i < n; i++)\\n        ans /= (n + 1 - i);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3116283,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void fnc(vector<string> &ans,int n,int open,int close,string curr_str){\\n        if(curr_str.size()==n*2){\\n            ans.push_back(curr_str);\\n            return;\\n        }\\n        if(open<n){\\n            fnc(ans,n,open+1,close,curr_str +\\'(\\');\\n        }\\n         if(close<open){\\n            fnc(ans,n,open,close+1,curr_str +\\')\\');\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        fnc(ans,n,0,0,\"\");\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    void fnc(vector<string> &ans,int n,int open,int close,string curr_str){\\n        if(curr_str.size()==n*2){\\n            ans.push_back(curr_str);\\n            return;\\n        }\\n        if(open<n){\\n            fnc(ans,n,open+1,close,curr_str +\\'(\\');\\n        }\\n         if(close<open){\\n            fnc(ans,n,open,close+1,curr_str +\\')\\');\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        fnc(ans,n,0,0,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066382,
                "title": "99-72-javascript-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/8sZI4b0tlkc\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = []\\n\\n    let iterate = (str, open, close) =>{\\n        if(open > n || close >n || close >open) return;\\n        if(str.length == n *2 && open ==close){\\n            res.push(str)\\n            return;\\n        }\\n        iterate(str +\\'(\\',open+1,close)\\n        iterate(str + \\')\\', open, close+1)\\n    }\\n\\n    iterate(\\'\\',0,0)\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = []\\n\\n    let iterate = (str, open, close) =>{\\n        if(open > n || close >n || close >open) return;\\n        if(str.length == n *2 && open ==close){\\n            res.push(str)\\n            return;\\n        }\\n        iterate(str +\\'(\\',open+1,close)\\n        iterate(str + \\')\\', open, close+1)\\n    }\\n\\n    iterate(\\'\\',0,0)\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246389,
                "title": "c-backtracking-methods-with-recursive-tree",
                "content": "RECURSIVE TREE :\\n   for n=3:\\n   ![image](https://assets.leetcode.com/users/images/0a1dbcd3-89d8-4e77-8e7b-610e86c937f4_1657112179.3003967.jpeg)\\n\\nMETHOD_1\\nbacktraking is not invloved \\n```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n           \\n            solve(n,openings+1,closings,temp+\\'(\\',ans);\\n        }\\n        \\n        if(closings<openings){\\n            \\n            solve(n,openings,closings+1,temp+\\')\\',ans);\\n        }\\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD_2\\nbacktracking \\n```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n             temp+=\\'(\\';\\n            solve(n,openings+1,closings,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        if(closings<openings){\\n             temp+=\\')\\';\\n            solve(n,openings,closings+1,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        \\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n           \\n            solve(n,openings+1,closings,temp+\\'(\\',ans);\\n        }\\n        \\n        if(closings<openings){\\n            \\n            solve(n,openings,closings+1,temp+\\')\\',ans);\\n        }\\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n             temp+=\\'(\\';\\n            solve(n,openings+1,closings,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        if(closings<openings){\\n             temp+=\\')\\';\\n            solve(n,openings,closings+1,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        \\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043913,
                "title": "c-easy-solution-using-recursion",
                "content": "**[C++] Easy Solution Using Recursion**\\n**For Better Understanding take n=3 and dry run it and draw tree, using recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<string>&ss,string s,int o,int c)\\n    {\\n\\t    if(o==0 && c==0)\\n\\t    {\\n            ss.push_back(s);\\n\\t\\t    return;\\n    \\t}\\n\\t    if(o==c)\\n\\t        solve(ss,s+\"(\",o-1,c);\\n    \\telse if(o==0)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    \\telse if(c>1)\\n    \\t{   \\n\\t    \\tsolve(ss,s+\"(\",o-1,c);\\t\\n\\t    \\tsolve(ss,s+\")\",o,c-1);\\t    \\n    \\t}\\n    \\telse if(c==1)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> s;\\n        solve(s,\"(\",n-1,n);\\n        return s;\\n    }\\n};\\n```\\n**If you find it helpful kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string>&ss,string s,int o,int c)\\n    {\\n\\t    if(o==0 && c==0)\\n\\t    {\\n            ss.push_back(s);\\n\\t\\t    return;\\n    \\t}\\n\\t    if(o==c)\\n\\t        solve(ss,s+\"(\",o-1,c);\\n    \\telse if(o==0)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    \\telse if(c>1)\\n    \\t{   \\n\\t    \\tsolve(ss,s+\"(\",o-1,c);\\t\\n\\t    \\tsolve(ss,s+\")\",o,c-1);\\t    \\n    \\t}\\n    \\telse if(c==1)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> s;\\n        solve(s,\"(\",n-1,n);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446245,
                "title": "python3-backtracking-dp",
                "content": "Algorithm: \\nTo clarify, backtracking solves problems recursively by building solutions incrementally and removing those failing to satisfy constraints. For this problem, backtracking is implicitly taken care of by recursion. \\n\\nHere, we define a function `backtrack` which keeps track of remaining number of open & closing parenthesis (denoted as `m` and `n` respectively). If `m == n  == 0`, add the string to answer. If there are open parenthesis left (i.e. `m > 0`), it is possible to append an open parenthesis; if there are more closing parenthesis than open parenthesis (i.e. `n > m`), it is possible to append a closing parenthesis. \\n\\nImplementation (32ms, 90.57%):\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def fn(s, op, cl):\\n            \"\"\"Backtracking to collect parentheses\"\"\"\\n            if cl == n: return ans.append(s)\\n            if op <  n: fn(s+\"(\", op+1, cl)\\n            if cl < op: fn(s+\")\", op, cl+1)\\n                \\n        ans = []\\n        fn(\"\", 0, 0)\\n        return ans \\n```\\n\\nAnalysis:\\nTime complexity `O(4^n/n^1.5)` per [Wikipedia](https://en.wikipedia.org/wiki/Catalan_number) \\nSpace complexity `O(4^n/n^1.5)`\\n\\n+dynamic programming \\n\\nIt is also possible to solve the problem explicitly using dynamic programming. Define `f(n)` as the set of all valid parentheses when there are `n` opening parentheses. Then symbolically, `f(n+1)` follows below recursive equation, \\n`f(n+1) = (f(0))f(n) + (f(1))f(n-1) + ... + (f(n-1))f(1) + (f(n))f(0)` \\n(`(f(i))f(j)` means that the valid parentheses of `f(i)` added by a pair of parentheses outside concatenated with the valid parentheses of `f(j)`, i.e. this is a loop.) \\n\\nTop-down implementation\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(k):\\n            \"\"\"Return k pairs of parentheses\"\"\"\\n            if k == 0: return [\"\"]\\n            ans = []\\n            for i in range(k): ans.extend([f\\'({x}){y}\\' for x in fn(k-i-1) for y in fn(i)])\\n            return ans \\n        \\n        return fn(n)\\n```\\n\\nBottom-up implementation\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = [[\"\"]]\\n        for i in range(1, n+1): \\n            tmp = []\\n            for j in range(i):\\n                for x in ans[j]:\\n                    for y in ans[~j]: \\n                        tmp.append(f\"({x}){y}\")\\n            ans.append(tmp)\\n        return ans[-1]\\n```\\n\\nEdited on 10/31/2021\\n```\\nclass Solution:\\n    @cache\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 0: return [\"\"]\\n        ans = []\\n        for i in range(n):\\n            for x in self.generateParenthesis(n-1-i): \\n                for y in self.generateParenthesis(i): \\n                    ans.append(f\"({x}){y}\")\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def fn(s, op, cl):\\n            \"\"\"Backtracking to collect parentheses\"\"\"\\n            if cl == n: return ans.append(s)\\n            if op <  n: fn(s+\"(\", op+1, cl)\\n            if cl < op: fn(s+\")\", op, cl+1)\\n                \\n        ans = []\\n        fn(\"\", 0, 0)\\n        return ans \\n```\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(k):\\n            \"\"\"Return k pairs of parentheses\"\"\"\\n            if k == 0: return [\"\"]\\n            ans = []\\n            for i in range(k): ans.extend([f\\'({x}){y}\\' for x in fn(k-i-1) for y in fn(i)])\\n            return ans \\n        \\n        return fn(n)\\n```\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = [[\"\"]]\\n        for i in range(1, n+1): \\n            tmp = []\\n            for j in range(i):\\n                for x in ans[j]:\\n                    for y in ans[~j]: \\n                        tmp.append(f\"({x}){y}\")\\n            ans.append(tmp)\\n        return ans[-1]\\n```\n```\\nclass Solution:\\n    @cache\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 0: return [\"\"]\\n        ans = []\\n        for i in range(n):\\n            for x in self.generateParenthesis(n-1-i): \\n                for y in self.generateParenthesis(i): \\n                    ans.append(f\"({x}){y}\")\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 296338,
                "title": "python-recursive-solution",
                "content": "This is a Python solution based on ideas from other people\\'s solutions. Basically we rely on recursion to populate all the possible strings and add them to the \"results\" parameter, then return the \"results\" at the end after all the recursions. At each recursive step, we have a \"sofar\" parameter that keeps track of the string we have constructed so far. We add it to the \"results\" in the base case. Otherwise we make 2 recursive calls, with one appending an open paranthesis and the other appending a closing paranthesis.\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        results = []\\n        def helper(sofar, results, left, right):\\n            if left == 0 and right == 0:\\n                results.append(sofar)\\n            if left > 0:\\n                helper(sofar + \"(\", results, left-1, right)\\n            if right > left:\\n                helper(sofar + \")\", results, left, right-1)\\n        helper(\\'\\', results, n, n)\\n        return results\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        results = []\\n        def helper(sofar, results, left, right):\\n            if left == 0 and right == 0:\\n                results.append(sofar)\\n            if left > 0:\\n                helper(sofar + \"(\", results, left-1, right)\\n            if right > left:\\n                helper(sofar + \")\", results, left, right-1)\\n        helper(\\'\\', results, n, n)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222304,
                "title": "simple-java-dfs-solution",
                "content": "A simple Java DFS solution:\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        dfs(n, n, result, \"\");\\n        return result;\\n    }\\n\\n    private void dfs(int left, int right, List<String> result, String s) {\\n        if (left == 0 && right == 0) result.add(s);\\n        else {\\n            if (left > 0) dfs(left - 1, right, result, s + \"(\");\\n            if (right > left) dfs(left, right - 1, result, s + \")\");\\n        }\\n    }",
                "solutionTags": [],
                "code": "A simple Java DFS solution:\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        dfs(n, n, result, \"\");\\n        return result;\\n    }\\n\\n    private void dfs(int left, int right, List<String> result, String s) {\\n        if (left == 0 && right == 0) result.add(s);\\n        else {\\n            if (left > 0) dfs(left - 1, right, result, s + \"(\");\\n            if (right > left) dfs(left, right - 1, result, s + \")\");\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10185,
                "title": "3-lines-recursion-solution-beats-90",
                "content": "Welcome to tell me if anywhere is not clear and I will add some explanations.\\n```\\n def generateParenthesis(self, n, left=0, right=0, cur=\\'\\'):\\n        if left == n: return [cur + \\')\\' * (n - right)]\\n        if left == right: return self.generateParenthesis(n, left + 1, right, cur + \\'(\\')\\n        return self.generateParenthesis(n, left + 1, right, cur + \\'(\\') \\\\\\n            + self.generateParenthesis(n, left, right + 1, cur + \\')\\')\\n````",
                "solutionTags": [],
                "code": "```\\n def generateParenthesis(self, n, left=0, right=0, cur=\\'\\'):\\n        if left == n: return [cur + \\')\\' * (n - right)]\\n        if left == right: return self.generateParenthesis(n, left + 1, right, cur + \\'(\\')\\n        return self.generateParenthesis(n, left + 1, right, cur + \\'(\\') \\\\\\n            + self.generateParenthesis(n, left, right + 1, cur + \\')\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 10202,
                "title": "detailed-explanation-from-the-view-of-recursion-tree",
                "content": "Re: [Easy to understand Java backtracking solution](/topic/8724/easy-to-understand-java-backtracking-solution)\\n\\nI checked out several solutions. They're very nice and seems like a magic of recursion which I cannot understand and make me upset.\\nThen I try to dig into this problem and see how can I come up nice solution like them.\\n\\nFor this kind of combinatorial problem, typically we use Tree to represent the search space and generate all possible solutions by search.\\nTree is so powerful which is able to represent efficient dicitionary (BST), prefix compression (Trie) or recursion.\\nEssentially, it is **the representation of execution of program**. (In Theory of Computation, it's called Configuration Graph.)\\nTherefore, recursion tree is just a special case but sufficient for analyzing and solving this problem.\\n\\nSo we use Tree to represent the entire search space. Each node is the state of program at that point. What's the state of this problem?\\nSince we'd like to generate all valid parenthesis, **the state we concern is just the String we concat by now**.\\nThen each edge is the choice (precisely, one transition from Transition Function). We only have two options: concat '('' or ')'.\\nThus we can draw the entire tree as follows (which is unique, right?).\\n\\n![0_1482412702046_Untitled Diagram (1).png](/uploads/files/1482412702445-untitled-diagram-1.png) \\n\\nThe characteristic of the Tree is due to that of the problem: \\n\\n + We can choose '(' only if we didn't exceed the max limit\\n + We can choose ')' only if there aren't more )' than '(' by now (otherwise we cannot fix this no matter how we iterate in the following).  \\n\\nNow all those nice solutions seem to be very clear. They're different just because **they use different search technique on this unique tree**.\\nThe first and natural searching approach is DFS which is the green arrow in the diagram above. \\nSince this is not a Complete Tree, we need variables (left/right or open/close) to control.\\nThey help us not to reach non-existing node on the Tree which means syntax wrong state such as ')((())'.\\n\\n```\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ret = new ArrayList<>();\\n        generate(ret, new char[n * 2], 0, 0, n, 0);\\n        return ret;\\n    }\\n    \\n    private void generate(List<String> ret, char[] str, int left, int right, int max, int i) {\\n        if (left == max && right == left) {\\n            ret.add(String.valueOf(str));\\n            return;\\n        }\\n        \\n        if (left < max) {\\n            str[i] = '(';\\n            generate(ret, str, left + 1, right, max, i + 1);\\n        }\\n        if (right < left) {\\n            str[i] = ')';\\n            generate(ret, str, left, right + 1, max, i + 1);\\n        }\\n    }\\n```\\n\\nAt last, let's review the most upvoted solution and see if we can understand now.\\nhttps://discuss.leetcode.com/topic/4485/concise-recursive-c-solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> res;\\n        addingpar(res, \"\", n, 0);\\n        return res;\\n    }\\n    void addingpar(vector<string> &v, string str, int n, int m){\\n        if(n==0 && m==0) {\\n            v.push_back(str);\\n            return;\\n        }\\n        if(m > 0){ addingpar(v, str+\")\", n, m-1); }\\n        if(n > 0){ addingpar(v, str+\"(\", n-1, m+1); }\\n    }\\n};\\n```\\n\\nSee? They turn out to be the same. We start off with left(n)=n, right(m=0).\\nThen if right > 0, we go right. If left > 0, we go left meanwhile increase right by 1.\\nThe blue arrow show the order of this program.",
                "solutionTags": [],
                "code": "```\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ret = new ArrayList<>();\\n        generate(ret, new char[n * 2], 0, 0, n, 0);\\n        return ret;\\n    }\\n    \\n    private void generate(List<String> ret, char[] str, int left, int right, int max, int i) {\\n        if (left == max && right == left) {\\n            ret.add(String.valueOf(str));\\n            return;\\n        }\\n        \\n        if (left < max) {\\n            str[i] = '(';\\n            generate(ret, str, left + 1, right, max, i + 1);\\n        }\\n        if (right < left) {\\n            str[i] = ')';\\n            generate(ret, str, left, right + 1, max, i + 1);\\n        }\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> res;\\n        addingpar(res, \"\", n, 0);\\n        return res;\\n    }\\n    void addingpar(vector<string> &v, string str, int n, int m){\\n        if(n==0 && m==0) {\\n            v.push_back(str);\\n            return;\\n        }\\n        if(m > 0){ addingpar(v, str+\")\", n, m-1); }\\n        if(n > 0){ addingpar(v, str+\"(\", n-1, m+1); }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307006,
                "title": "dfs-with-go",
                "content": "```\\nfunc generateParenthesis(n int) []string {\\n    var res []string\\n    \\n    helper(n, 0, 0, \"\", &res)\\n    \\n    return res\\n}\\n\\nfunc helper(n int, openCount int, closeCount int, currentStr string, result *[]string) {\\n    if openCount == n && closeCount == n {\\n        *result = append(*result, currentStr)\\n        return\\n    }\\n    \\n    if openCount < n {\\n        helper(n, openCount + 1, closeCount, currentStr + \"(\", result)\\n    }\\n    \\n    if openCount > closeCount {\\n        helper(n, openCount, closeCount + 1, currentStr + \")\", result)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc generateParenthesis(n int) []string {\\n    var res []string\\n    \\n    helper(n, 0, 0, \"\", &res)\\n    \\n    return res\\n}\\n\\nfunc helper(n int, openCount int, closeCount int, currentStr string, result *[]string) {\\n    if openCount == n && closeCount == n {\\n        *result = append(*result, currentStr)\\n        return\\n    }\\n    \\n    if openCount < n {\\n        helper(n, openCount + 1, closeCount, currentStr + \"(\", result)\\n    }\\n    \\n    if openCount > closeCount {\\n        helper(n, openCount, closeCount + 1, currentStr + \")\", result)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787441,
                "title": "c-backtracking-simple-logic-explain",
                "content": "Here are few step need to follow\\n* **Till (open < N) We can put \\'(\\'**\\n* **If (Open>end) We can put \\')\\'**\\n\\n**\\u2B06\\uFE0F Please Upvote**\\n\\n```\\nclass Solution {\\n    vector<string>ans;\\n    void backTrack(int n, int open, int end, string s){\\n        if(open == n && end ==  n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        if(open<n) {\\n            s.push_back(\\'(\\');\\n            backTrack(n, open+1, end, s);\\n            s.pop_back();\\n        }\\n        if(end<open) {\\n            s.push_back(\\')\\');\\n            backTrack(n, open, end+1, s);\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        backTrack(n, 0, 0, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<string>ans;\\n    void backTrack(int n, int open, int end, string s){\\n        if(open == n && end ==  n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        if(open<n) {\\n            s.push_back(\\'(\\');\\n            backTrack(n, open+1, end, s);\\n            s.pop_back();\\n        }\\n        if(end<open) {\\n            s.push_back(\\')\\');\\n            backTrack(n, open, end+1, s);\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        backTrack(n, 0, 0, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754291,
                "title": "js-easy-heavily-commented-solution-using-backtracking-dfs",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    // Using backtracking and DFS\\n    let res = [];\\n    \\n    const dfs = (str, open, close) => {\\n        // Backtracking case: number of \\')\\' can\\'t be more than number of \\'(\\'\\n        if (open < close) return;\\n        \\n        // Base case: there are n number of open and close parenthesis\\n        if (open === n && close === n) {\\n            res.push(str);\\n            return;\\n        }\\n        \\n        // DFS traversal\\n        if (open < n) dfs(str + \\'(\\', open + 1, close);\\n        if (close < n) dfs(str + \\')\\', open, close + 1);\\n    }\\n    \\n    dfs(\\'\\', 0, 0);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    // Using backtracking and DFS\\n    let res = [];\\n    \\n    const dfs = (str, open, close) => {\\n        // Backtracking case: number of \\')\\' can\\'t be more than number of \\'(\\'\\n        if (open < close) return;\\n        \\n        // Base case: there are n number of open and close parenthesis\\n        if (open === n && close === n) {\\n            res.push(str);\\n            return;\\n        }\\n        \\n        // DFS traversal\\n        if (open < n) dfs(str + \\'(\\', open + 1, close);\\n        if (close < n) dfs(str + \\')\\', open, close + 1);\\n    }\\n    \\n    dfs(\\'\\', 0, 0);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1687595,
                "title": "c-beats-85-backtracking-easy-solution",
                "content": "Please Upvote if it helps you\\n```\\nclass Solution {\\npublic:\\n    void generateAll(vector<string> &ans,int n, int open,int close,string s){\\n\\t\\t// the number of close backets can never be greater than open Brackets as - \"( ) )\" is not valid string \\n        if(open < close || close> n || open>n){\\n            return;\\n        }\\n        if(close==n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        s+=\\'(\\';\\n        generateAll(ans,n,open+1,close,s);\\n        s.pop_back(); //backtrack\\n        \\n        s+=\\')\\';\\n        generateAll(ans,n,open,close+1,s);\\n        \\n    }\\n    vector<string> generateParenthesis(int n) {\\n        \\n        vector<string> ans;\\n        \\n        generateAll(ans,n,0,0,\"\");\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateAll(vector<string> &ans,int n, int open,int close,string s){\\n\\t\\t// the number of close backets can never be greater than open Brackets as - \"( ) )\" is not valid string \\n        if(open < close || close> n || open>n){\\n            return;\\n        }\\n        if(close==n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        s+=\\'(\\';\\n        generateAll(ans,n,open+1,close,s);\\n        s.pop_back(); //backtrack\\n        \\n        s+=\\')\\';\\n        generateAll(ans,n,open,close+1,s);\\n        \\n    }\\n    vector<string> generateParenthesis(int n) {\\n        \\n        vector<string> ans;\\n        \\n        generateAll(ans,n,0,0,\"\");\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402549,
                "title": "very-easy-recursion-aditya-verma",
                "content": "**Upvote,if you like it**\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\tvoid solve(int open,int close,string &op,vector<string> &ans)\\n    {\\n        if(open == 0 and close == 0)\\n        {\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        if(open != 0)\\n        {\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(open - 1,close,op1,ans);\\n        }\\n        \\n        if(close > open)\\n        {\\n            string op2 = op;\\n            op2.push_back(\\')\\');\\n            solve(open,close-1,op2,ans);\\n        }\\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        \\n        vector<string> ans;\\n        string op = \"\";\\n        int close = n;\\n        int open = n;\\n        solve(open,close,op,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\tvoid solve(int open,int close,string &op,vector<string> &ans)\\n    {\\n        if(open == 0 and close == 0)\\n        {\\n            ans.push_back(op);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1276105,
                "title": "c-simple-and-clean-recursive-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void rec(string curr, int open, int close) {\\n        if (open == 0 && close == 0) {\\n            res.push_back(curr);\\n            return;\\n        }\\n        \\n        if (open > 0) rec(curr + \"(\", open-1, close+1);\\n        if (close > 0) rec(curr + \")\", open, close-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        rec(\"\", n, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> res;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(string curr, int open, int close) {\\n        if (open == 0 && close == 0) {\\n            res.push_back(curr);\\n            return;\\n        }\\n        \\n        if (open > 0) rec(curr + \"(\", open-1, close+1);\\n        if (close > 0) rec(curr + \")\", open, close-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        rec(\"\", n, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166698,
                "title": "python-well-explained",
                "content": "In backtracking we use depth-first search to traverse the solution space. We undo previous actions in order to revert back to the state that we branch off from so that we can explore other branches coming from that state.\\n\\nWe backtrack when:\\n- we find a a valid solution (a goal state).\\n- when we find an invalid state.\\n\\nThe two main advantages of backtracking method are:\\n- It prevents us from branching off from invalid/unpromising states.\\n- It is typically space efficient.\\n\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t# Store the valid solutions we encounter\\n\\toutput = []\\n        \\n\\tdef dfs(open_brackets=0, closed_brackets=0, s=\\'\\'):\\n\\t    # If there are n opened and closed brackets\\n\\t    if open_brackets == n and closed_brackets == n:\\n\\t        # Append the valid solution to the output array\\n\\t        output.append(curr)\\n\\t        # Do not continue searching from this state\\n\\t        return\\n            \\n        # If we can place an open bracket\\n        if open_brackets < n:\\n            # Add an open bracket\\n            curr += \\'(\\'\\n            # Explore states based on this one\\n            dfs(open_brackets + 1, closed_brackets, curr)\\n            # Backtrack by removing the open bracket we placed\\n            curr = curr[:-1]\\n                \\n        # If we haven\\'t closed all open brackets\\n        if closed_brackets < open_brackets:\\n            # Add a close bracket\\n            curr += \\')\\'\\n            # Explore states based on this one\\n            dfs(open_brackets, closed_brackets + 1, curr)\\n            # Backtrack by removing the closed bracket\\n            curr = curr[:-1]\\n\\n    # Begin the depth-first search\\n    dfs()\\n        \\n    # Return the array of valid solutions\\n    return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t# Store the valid solutions we encounter\\n\\toutput = []\\n        \\n\\tdef dfs(open_brackets=0, closed_brackets=0, s=\\'\\'):\\n\\t    # If there are n opened and closed brackets\\n\\t    if open_brackets == n and closed_brackets == n:\\n\\t        # Append the valid solution to the output array\\n\\t        output.append(curr)\\n\\t        # Do not continue searching from this state\\n\\t        return\\n            \\n        # If we can place an open bracket\\n        if open_brackets < n:\\n            # Add an open bracket\\n            curr += \\'(\\'\\n            # Explore states based on this one\\n            dfs(open_brackets + 1, closed_brackets, curr)\\n            # Backtrack by removing the open bracket we placed\\n            curr = curr[:-1]\\n                \\n        # If we haven\\'t closed all open brackets\\n        if closed_brackets < open_brackets:\\n            # Add a close bracket\\n            curr += \\')\\'\\n            # Explore states based on this one\\n            dfs(open_brackets, closed_brackets + 1, curr)\\n            # Backtrack by removing the closed bracket\\n            curr = curr[:-1]\\n\\n    # Begin the depth-first search\\n    dfs()\\n        \\n    # Return the array of valid solutions\\n    return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 413718,
                "title": "simple-ruby-solution-using-backtracking",
                "content": "```\\ndef generate_parenthesis(n)\\n  @res = []\\n  backtrack(\"\", 0, 0, n)\\n  @res\\nend\\n\\ndef backtrack(curr, open, close, n)\\n  @res << curr and return if curr.length == n*2\\n  backtrack(curr+\\'(\\', open+1, close, n) if open < n\\n  backtrack(curr+\\')\\', open, close+1, n) if close < open\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Backtracking"
                ],
                "code": "```\\ndef generate_parenthesis(n)\\n  @res = []\\n  backtrack(\"\", 0, 0, n)\\n  @res\\nend\\n\\ndef backtrack(curr, open, close, n)\\n  @res << curr and return if curr.length == n*2\\n  backtrack(curr+\\'(\\', open+1, close, n) if open < n\\n  backtrack(curr+\\')\\', open, close+1, n) if close < open\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3906758,
                "title": "recurison-solution",
                "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION AND COMMENT FOR ANY DISCUSSION **\\n# Approach\\nFunction solve: This is a recursive helper function that generates all valid combinations of parentheses.\\n\\nThe base case is when the length of the temp string becomes equal to 2 * n. At this point, you\\'ve formed a valid combination, so you add it to the result vector and return.\\n\\nIf you can still add an opening parenthesis ( (i.e., if start < n), you recursively call solve with an incremented start and append an opening parenthesis to the temp string.\\n\\nIf you can add a closing parenthesis ) without making the combination invalid (i.e., if close < start), you recursively call solve with an incremented close and append a closing parenthesis to the temp string.\\n\\nFunction generateParenthesis: This is the main function that initializes the result vector and starts the recursion by calling the solve function.\\n\\nThe initial call to solve has start and close both set to 0, and an empty temp string.\\nThe idea behind this approach is to generate all possible combinations of parentheses by recursively adding an opening parenthesis when possible and a closing parenthesis when it won\\'t lead to an invalid combination. The recursion explores all possible paths of forming valid combinations.\\n\\nThe result will be a vector of strings containing all the valid combinations of parentheses for the given n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^(2n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(int n , int start , int close, string temp ,vector<string>&result)\\n{\\n    if(temp.size()==n*2)\\n    {\\n        result.push_back(temp);\\n        return ; \\n    }\\n    if(start < n)\\n    {\\n        solve(n,start + 1, close,temp + \"(\", result);\\n    }\\n     if(close < start )\\n    {\\n        solve(n,start, close + 1,temp + \")\", result);\\n    }\\n }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>result;\\n        solve(n,0, 0,\"\", result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(int n , int start , int close, string temp ,vector<string>&result)\\n{\\n    if(temp.size()==n*2)\\n    {\\n        result.push_back(temp);\\n        return ; \\n    }\\n    if(start < n)\\n    {\\n        solve(n,start + 1, close,temp + \"(\", result);\\n    }\\n     if(close < start )\\n    {\\n        solve(n,start, close + 1,temp + \")\", result);\\n    }\\n }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>result;\\n        solve(n,0, 0,\"\", result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855246,
                "title": "beginner-friendly-different-way-of-approach-using-recursion-and-stack",
                "content": "# Intuition\\nGenerate every possible string using recursion and check each string is valid or not.\\n\\n# Complexity\\n- Time complexity:\\nO(2^(2n)*2n).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(string &s){\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\') st.push(\\'(\\');\\n            else {\\n                if(!st.empty()) st.pop();\\n                 else return false;\\n                }\\n        }\\n        if(st.size()==0) return true;\\n        return false;\\n        \\n    }\\n    \\n   void solve(int n1,int n2,string s,vector<string> &ans){\\n        if(n1==0 && n2==0){\\n            if(isvalid(s)){\\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n        if(n1!=0) {s.push_back(\\'(\\');  solve(n1-1,n2,s,ans); s.pop_back();}\\n       \\n        if(n2!=0) {s.push_back(\\')\\'); solve(n1,n2-1,s,ans);}\\n       \\n   \\n        \\n}\\n\\n    vector<string> generateParenthesis(int n) {\\n\\n        vector<string> ans;\\n        solve(n,n,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(string &s){\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\') st.push(\\'(\\');\\n            else {\\n                if(!st.empty()) st.pop();\\n                 else return false;\\n                }\\n        }\\n        if(st.size()==0) return true;\\n        return false;\\n        \\n    }\\n    \\n   void solve(int n1,int n2,string s,vector<string> &ans){\\n        if(n1==0 && n2==0){\\n            if(isvalid(s)){\\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n        if(n1!=0) {s.push_back(\\'(\\');  solve(n1-1,n2,s,ans); s.pop_back();}\\n       \\n        if(n2!=0) {s.push_back(\\')\\'); solve(n1,n2-1,s,ans);}\\n       \\n   \\n        \\n}\\n\\n    vector<string> generateParenthesis(int n) {\\n\\n        vector<string> ans;\\n        solve(n,n,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772106,
                "title": "easy-solution-using-recursion-with-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gp(int left,int right,string &s,vector<string> &ans){\\n        if(left==0 && right==0)\\n        ans.push_back(s);\\n\\n        if(left>right || left<0 || right<0){\\n            return ;\\n        }\\n        s.push_back(\\'(\\');\\n        gp(left-1,right,s,ans);\\n        s.pop_back();\\n\\n        s.push_back(\\')\\');\\n        gp(left,right-1,s,ans);\\n        s.pop_back();\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s;\\n        gp(n,n,s,ans);\\n        return ans;\\n    }\\n};\\n/*UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU.*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gp(int left,int right,string &s,vector<string> &ans){\\n        if(left==0 && right==0)\\n        ans.push_back(s);\\n\\n        if(left>right || left<0 || right<0){\\n            return ;\\n        }\\n        s.push_back(\\'(\\');\\n        gp(left-1,right,s,ans);\\n        s.pop_back();\\n\\n        s.push_back(\\')\\');\\n        gp(left,right-1,s,ans);\\n        s.pop_back();\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s;\\n        gp(n,n,s,ans);\\n        return ans;\\n    }\\n};\\n/*UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU.*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613202,
                "title": "valid-parentheses-easy-hai-samjh-aa-jaega",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKch ni krna hai, ye socho ki obviously open bracket close bracket se pehle aaega, to condition open bracket ka lekr chalna hai, or bs code kr dena hai\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOpen bracket daalo, close bracket daalo, jb open N se aage jae ya close open se aage jae to ruk jaana hai, ni to 3 condition likha hai, dekho samjh aa jaega\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNI PTA, SAARA TEST CASE PASS HO GAYA HAI\\n<!-- Contact : c0deblooded   telegram username -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAB RETURN KRNA HAI TO ANS STRING TO BNANA PADEGA NA BHAI\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n\\n    void solve(int n, string &str, int open, int close){\\n        if(open == close and open == n - 1){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open < n){\\n            str.push_back(\\'(\\');\\n            solve(n, str, open + 1, close);\\n            str.pop_back();\\n\\n        }\\n        if(open > close){\\n            str.push_back(\\')\\');\\n            solve(n, str, open, close + 1);\\n            str.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        ans.resize(0);\\n        string str;\\n        solve(n+1, str, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n\\n    void solve(int n, string &str, int open, int close){\\n        if(open == close and open == n - 1){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open < n){\\n            str.push_back(\\'(\\');\\n            solve(n, str, open + 1, close);\\n            str.pop_back();\\n\\n        }\\n        if(open > close){\\n            str.push_back(\\')\\');\\n            solve(n, str, open, close + 1);\\n            str.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        ans.resize(0);\\n        string str;\\n        solve(n+1, str, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401851,
                "title": "100-detailed-explaination-with-pictures-in-c-java-python-recursion",
                "content": "\\n# Approach\\n- Here the approach is pretty simple Always the number of Open brackets must be Greater than or equal to the closed ones and in the end we must have a balanced parantheses.\\n>- The Decision tree of this approach would be like as shown below in the picture.\\n\\n![pic1.png](https://assets.leetcode.com/users/images/9ca0631b-cc21-4ebc-b3e8-d91f71cf61e8_1681154610.15714.png)\\n\\n- As Above we can observe how the recursion tree is constructed now we push the end product $i.e$ when `open == close == n` we would push the string into the vector of string and `return` the function.\\n\\n>This would be the most obvious way to solve these type of question and also there are some solution of a type where bitmasking is used in common but currently we stick on to this type of solution which is enough in most of the interviews.\\n\\n# Complexity\\n>- Time complexity: Here the Time complexity would be $$O(2^n)$$ and this is because we cannot optimise the recursion call via Creating a Dp array or something so we have to try all the possiblities which results in Exponential complexity i.e $$(2^n)$$.\\n\\n>- Space complexity:Here the Space complexity would Just be storage space complexity of $$O(n)$$ due to stack space and vector of string storage space.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void gen(vector<string>&vs , string &s , int n , int open  , int close)\\n    {\\n        if(open == close && open == n-1)\\n        {\\n            vs.push_back(s);\\n            return;\\n        }\\n        if(open < n)\\n        {\\n            s.push_back(\\'(\\');\\n            gen(vs, s , n , open + 1 ,close);\\n            s.pop_back();\\n        }\\n        if(close < open)\\n        {\\n            s.push_back(\\')\\');\\n            gen(vs,  s,  n , open , close + 1);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>vs;\\n        string s;\\n        gen(vs , s , n+1 , 0 , 0);\\n        return vs;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        dfs (n, 0, 0, 0, sb, result);\\n        return result;\\n    }\\n    private void dfs (int n, int left, int right, int index, StringBuilder sb, List<String> result) {\\n        if (left == n && right == n) {\\n            result.add (sb.toString());\\n            return;\\n        }\\n        if (left < n) {\\n            sb.append (\\'(\\');\\n            dfs (n, left + 1, right, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n\\n        if (right < left) {\\n            sb.append (\\')\\');\\n            dfs (n, left, right + 1, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n\\n        def dfs(left, right, s):\\n            if len(s) == n * 2:\\n                res.append(s)\\n                return \\n\\n            if left < n:\\n                dfs(left + 1, right, s + \\'(\\')\\n\\n            if right < left:\\n                dfs(left, right + 1, s + \\')\\')\\n\\n        res = []\\n        dfs(0, 0, \\'\\')\\n        return res\\n```\\n\\n\\n---\\n\\n\\n\\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/fd222420-993e-4879-87e3-68e203f44d2d_1681153859.3552585.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void gen(vector<string>&vs , string &s , int n , int open  , int close)\\n    {\\n        if(open == close && open == n-1)\\n        {\\n            vs.push_back(s);\\n            return;\\n        }\\n        if(open < n)\\n        {\\n            s.push_back(\\'(\\');\\n            gen(vs, s , n , open + 1 ,close);\\n            s.pop_back();\\n        }\\n        if(close < open)\\n        {\\n            s.push_back(\\')\\');\\n            gen(vs,  s,  n , open , close + 1);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>vs;\\n        string s;\\n        gen(vs , s , n+1 , 0 , 0);\\n        return vs;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        dfs (n, 0, 0, 0, sb, result);\\n        return result;\\n    }\\n    private void dfs (int n, int left, int right, int index, StringBuilder sb, List<String> result) {\\n        if (left == n && right == n) {\\n            result.add (sb.toString());\\n            return;\\n        }\\n        if (left < n) {\\n            sb.append (\\'(\\');\\n            dfs (n, left + 1, right, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n\\n        if (right < left) {\\n            sb.append (\\')\\');\\n            dfs (n, left, right + 1, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n\\n        def dfs(left, right, s):\\n            if len(s) == n * 2:\\n                res.append(s)\\n                return \\n\\n            if left < n:\\n                dfs(left + 1, right, s + \\'(\\')\\n\\n            if right < left:\\n                dfs(left, right + 1, s + \\')\\')\\n\\n        res = []\\n        dfs(0, 0, \\'\\')\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400123,
                "title": "shortest-c-solution-using-recursion",
                "content": "# Complexity\\n- Time complexity: O(4^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(4^n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, vector<string>& ans, string s) {\\n        if (open == 0 && close == 0) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > 0) solve(open - 1, close, ans, s + \\'(\\');\\n        if (close > 0 && close > open) solve(open, close - 1, ans, s + \\')\\');\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n, n, ans, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, vector<string>& ans, string s) {\\n        if (open == 0 && close == 0) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > 0) solve(open - 1, close, ans, s + \\'(\\');\\n        if (close > 0 && close > open) solve(open, close - 1, ans, s + \\')\\');\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n, n, ans, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152520,
                "title": "python-code-using-dp",
                "content": "# Intuition\\nwe can find all the elements which will come for n using the values of previous elements in n-1.\\neg. if we have [\"(())\",\"()()\"] for n == 2\\nand [\"()\"] for n == 1\\nthe we can find answer for n == 3 using the previous values.\\n\\n# Approach\\nfor n == 3 we can add the \"()\" in any place in elements belonging to n == 2\\neg. taking first value in n == 2 we have \"(())\"\\nnow we add the \"()\" in each index of \"(())\" we get \"()(())\",\"(()())\", and so on ,resulting in a valid parenthesis of n == 3 similarly we can do same for next elements.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        dp ={}\\n        dp[1] = [\"()\"]\\n        dp[2] = [\"(())\",\"()()\"]\\n        for i in range(3,n+1):\\n            d = {}\\n            arr = []\\n            for st in dp[i-1]:\\n                for j in range(0,len(st)):\\n                    new = st[0:j]+\"()\"+st[j:len(st)]\\n                    if new not in d:\\n                        d[new] = 1\\n                        arr.append(new)\\n            dp[i] = arr\\n        # print(dp[n])\\n        return dp[n]\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        dp ={}\\n        dp[1] = [\"()\"]\\n        dp[2] = [\"(())\",\"()()\"]\\n        for i in range(3,n+1):\\n            d = {}\\n            arr = []\\n            for st in dp[i-1]:\\n                for j in range(0,len(st)):\\n                    new = st[0:j]+\"()\"+st[j:len(st)]\\n                    if new not in d:\\n                        d[new] = 1\\n                        arr.append(new)\\n            dp[i] = arr\\n        # print(dp[n])\\n        return dp[n]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777911,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string &st, int fb, int sb, int mx) {\\n        if(st.size() == 2 * mx) {\\n            ans.push_back(st);\\n            return;\\n        }\\n        if(fb < mx) {\\n            st.push_back(\\'(\\');\\n            solve(st, fb+1, sb, mx);\\n            st.pop_back();\\n        }\\n        if(sb < fb) {\\n            st.push_back(\\')\\');\\n            solve(st, fb, sb+1, mx);\\n            st.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        string st;\\n        solve(st, 0, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string &st, int fb, int sb, int mx) {\\n        if(st.size() == 2 * mx) {\\n            ans.push_back(st);\\n            return;\\n        }\\n        if(fb < mx) {\\n            st.push_back(\\'(\\');\\n            solve(st, fb+1, sb, mx);\\n            st.pop_back();\\n        }\\n        if(sb < fb) {\\n            st.push_back(\\')\\');\\n            solve(st, fb, sb+1, mx);\\n            st.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        string st;\\n        solve(st, 0, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352433,
                "title": "recursive-c-solution-include-or-exclude",
                "content": "```\\nvoid generateParenthesis(int open, int close, string op, vector<string>& ans) {\\n        if(open == 0 && close == 0) {\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        if(open > 0) generateParenthesis(open-1, close, op+\"(\", ans);\\n        \\n        if(close > open) generateParenthesis(open, close-1, op+\")\", ans);\\n        \\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n         vector<string> ans;\\n        int open = n;\\n        int close = n;\\n        string op = \"\";\\n        generateParenthesis(open, close, op, ans);\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid generateParenthesis(int open, int close, string op, vector<string>& ans) {\\n        if(open == 0 && close == 0) {\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        if(open > 0) generateParenthesis(open-1, close, op+\"(\", ans);\\n        \\n        if(close > open) generateParenthesis(open, close-1, op+\")\", ans);\\n        \\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n         vector<string> ans;\\n        int open = n;\\n        int close = n;\\n        string op = \"\";\\n        generateParenthesis(open, close, op, ans);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2136726,
                "title": "aditya-verma-s-solution",
                "content": "```\\n//GOD ADITYA VERMA\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string op=\"\";\\n        vector<string> v;\\n        int o=n,c=n;\\n        solve(o,c,op,v);\\n        return v;\\n    }\\n    void solve(int open,int close,string &op,vector<string> &v)\\n    {\\n        if(open==0 && close==0)\\n        {\\n            v.push_back(op);\\n            return;\\n        }\\n        if(open!=0)\\n        {\\n            string op1=op;\\n            op1.push_back(\\'(\\');\\n            solve(open-1,close,op1,v);\\n            \\n        }\\n        if(close>open)\\n        {\\n            string op2=op;\\n            op2.push_back(\\')\\');\\n            solve(open,close-1,op2,v);\\n            \\n        }\\n    }\\n};\\n```\\n\\nPlease upvote!!",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//GOD ADITYA VERMA\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string op=\"\";\\n        vector<string> v;\\n        int o=n,c=n;\\n        solve(o,c,op,v);\\n        return v;\\n    }\\n    void solve(int open,int close,string &op,vector<string> &v)\\n    {\\n        if(open==0 && close==0)\\n        {\\n            v.push_back(op);\\n            return;\\n        }\\n        if(open!=0)\\n        {\\n            string op1=op;\\n            op1.push_back(\\'(\\');\\n            solve(open-1,close,op1,v);\\n            \\n        }\\n        if(close>open)\\n        {\\n            string op2=op;\\n            op2.push_back(\\')\\');\\n            solve(open,close-1,op2,v);\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806995,
                "title": "using-recursion-backtracking-with-comments-c",
                "content": "**Using Recursion & Backtracking\\nTime Complexity = O(2^N)\\nSpace Complexity = O(1), not considering the ans vector, bcz its a part of output**\\n```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, string output, vector<string> &ans){\\n        \\n        // base case\\n        if(open == 0 && close == 0){\\n            ans.push_back(output);\\n            return;\\n        }\\n        \\n        // always takes open, until & unless its 0\\n        // inside this just append the open bracket and decrease open by 1\\n        if(open != 0){\\n            string openOutput = output + \"(\";\\n            solve(open-1, close, openOutput, ans);    \\n        }\\n        \\n        // take close when close is greater than open, bcz when we will use open, then only we can use close\\n        // inside this just append the close bracket and decrease close by 1\\n        if(close > open){\\n            string closeOutput = output + \")\";\\n            solve(open, close-1, closeOutput, ans);\\n        }\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        \\n        // to store ans\\n        vector<string> ans;\\n        \\n        // we will be having n open & close brackets\\n        int open = n, close = n;\\n        \\n        // will store the combination into this\\n        string output = \"\";\\n        \\n        // helper function to solve the problem\\n        solve(open, close, output, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, string output, vector<string> &ans){\\n        \\n        // base case\\n        if(open == 0 && close == 0){\\n            ans.push_back(output);\\n            return;\\n        }\\n        \\n        // always takes open, until & unless its 0\\n        // inside this just append the open bracket and decrease open by 1\\n        if(open != 0){\\n            string openOutput = output + \"(\";\\n            solve(open-1, close, openOutput, ans);    \\n        }\\n        \\n        // take close when close is greater than open, bcz when we will use open, then only we can use close\\n        // inside this just append the close bracket and decrease close by 1\\n        if(close > open){\\n            string closeOutput = output + \")\";\\n            solve(open, close-1, closeOutput, ans);\\n        }\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        \\n        // to store ans\\n        vector<string> ans;\\n        \\n        // we will be having n open & close brackets\\n        int open = n, close = n;\\n        \\n        // will store the combination into this\\n        string output = \"\";\\n        \\n        // helper function to solve the problem\\n        solve(open, close, output, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688977,
                "title": "c-short-clean-easy-to-understand",
                "content": "**Please upvote if you find helpful:)**\\n\\n```\\nclass Solution {\\npublic:\\n    void generateAll(int n, int open, int close, vector<string>&v, string s)\\n    {\\n        if(open>n || close>n || close>open)\\n            return;\\n        if(open==n && close==n)\\n        {\\n            v.push_back(s);\\n            return;\\n        }\\n        generateAll(n, open+1, close, v, s+\\'(\\');\\n        generateAll(n, open, close+1, v, s+\\')\\');\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>v;\\n        generateAll(n, 0, 0, v, \"\");\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateAll(int n, int open, int close, vector<string>&v, string s)\\n    {\\n        if(open>n || close>n || close>open)\\n            return;\\n        if(open==n && close==n)\\n        {\\n            v.push_back(s);\\n            return;\\n        }\\n        generateAll(n, open+1, close, v, s+\\'(\\');\\n        generateAll(n, open, close+1, v, s+\\')\\');\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>v;\\n        generateAll(n, 0, 0, v, \"\");\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318087,
                "title": "easiest-solution-a-using-queue-beats-100-solves-5-problems",
                "content": "For questions like Generate paranthesis, Generate Permutations, Generate Subsets, Generate all bitstrings, Generate all strings without concecutive vowels, Queue approach will easily do the good. Same approach, but just changing the if conditions for adding children should be done relevantly to the question.\\n\\n**1. For Generate-Paranthesis**,\\nMaintain a Queue with [(str, opencount, closecount))] initially, front=0, qlength=1,\\nwhile front<qlength, peek the first element and add two children of it, (str+\\'(\\', opencount+1, closecount) and (str+\\')\\', opencount, closecount+1), increment front pointer. That\\'s all :)\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n    ans = []\\n    queue = [(\\'(\\', 1,0)]  # Item will contain (str, open_nos, close_nos)\\n    f = 0             # front_index\\n    l = 1            # queue_length\\n    while f<l:\\n        cur = queue[f]\\n        if cur[1]+cur[2]==2*n:\\n            ans.append(cur[0])\\n            f+=1\\n            continue\\n        if cur[1] < n:\\n            queue.append((cur[0]+\\'(\\', cur[1]+1, cur[2]))\\n            l+=1\\n        if cur[2] < cur[1]:\\n            queue.append((cur[0]+\\')\\', cur[1], cur[2]+1))\\n            l+=1\\n        f+=1\\n    return ans\\n```\\n\\n**2. For Generate-Permutations**,\\nHaving [(str, visitedchars, len)] as the Queue, its same like previous except that while adding the children to Queue we check if we\\'ve already used the character. \\n```\\ndef permute(self, nums: List[int]) -> List[List[int]]:\\n    n=len(nums)\\n    ans=[]\\n\\n    queue = []\\n    f = 0     # Queue front\\n    for i in nums:\\n        queue.append(([i], set([i]), 1))   # (str, visited_chars, len)\\n    l = len(queue)  # Queue length\\n\\t\\n    while f < l:\\n        cur = queue[f]\\n        if cur[2] == n:\\n            ans.append(cur[0])\\n        else:\\n            for i in nums:\\n                if i not in cur[1]:\\n                    queue.append((cur[0]+[i], cur[1].union([i]), cur[2]+1))\\n                    l += 1\\n        f+=1\\n\\t\\t\\n    return ans\\n```\\n\\n**3. For generating bitstrings of length n** Like n=3 -> 001, 010, 011, 100, 101, 110, 111\\nWe\\'ll have [(str, len)] in queue. Add [(str+\\'0\\', len+1)] and [(str+\\'1\\', len+1)] to the queue until len+1 not greater than n.\\n\\n**4. For generating subsets**, \\nGenerating binary bitstrings and appending the set bits to the ans is one solution. But again, in Queue approach, we\\'ll have [(set, len)] in Queue. Starting from [{}, 0] -> [[{1}, 1], [{2}, 1], ...]] -> [powerset, n] While going all the way to the powerset, we\\'ll add the intermediaries (\"cur\" in code) to the ans array.\\n\\n**5. For generating strings without consecutive vowels**, Like, for n=3, **Valid** strings are aba, abz, zzz, jka, eba. **Invalid** strings = aeb, poi, aaa, ..etc. because there are consecutive vowels\\nSame queue approach, but while adding children to the queue we need to make sure that we are **not** attaching a vowel after a vowel.\\n\\nThank youu :) Happy coding friends!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n    ans = []\\n    queue = [(\\'(\\', 1,0)]  # Item will contain (str, open_nos, close_nos)\\n    f = 0             # front_index\\n    l = 1            # queue_length\\n    while f<l:\\n        cur = queue[f]\\n        if cur[1]+cur[2]==2*n:\\n            ans.append(cur[0])\\n            f+=1\\n            continue\\n        if cur[1] < n:\\n            queue.append((cur[0]+\\'(\\', cur[1]+1, cur[2]))\\n            l+=1\\n        if cur[2] < cur[1]:\\n            queue.append((cur[0]+\\')\\', cur[1], cur[2]+1))\\n            l+=1\\n        f+=1\\n    return ans\\n```\n```\\ndef permute(self, nums: List[int]) -> List[List[int]]:\\n    n=len(nums)\\n    ans=[]\\n\\n    queue = []\\n    f = 0     # Queue front\\n    for i in nums:\\n        queue.append(([i], set([i]), 1))   # (str, visited_chars, len)\\n    l = len(queue)  # Queue length\\n\\t\\n    while f < l:\\n        cur = queue[f]\\n        if cur[2] == n:\\n            ans.append(cur[0])\\n        else:\\n            for i in nums:\\n                if i not in cur[1]:\\n                    queue.append((cur[0]+[i], cur[1].union([i]), cur[2]+1))\\n                    l += 1\\n        f+=1\\n\\t\\t\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1222114,
                "title": "java-clean-concise-optimal-code-backtracking-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public void generateAll (String s, int max, int openBracket, int closeBracket, List<String> answer) {\\n        \\n        if (s.length () == 2 * max) {\\n            answer.add (s);\\n        }\\n        if (openBracket < max) {\\n            generateAll (s + \\'(\\', max, openBracket + 1, closeBracket, answer);\\n        }\\n        if (closeBracket < openBracket) {\\n            generateAll (s + \\')\\', max, openBracket, closeBracket + 1, answer);\\n        }\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        generateAll (\"\", n, 0, 0, answer);\\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void generateAll (String s, int max, int openBracket, int closeBracket, List<String> answer) {\\n        \\n        if (s.length () == 2 * max) {\\n            answer.add (s);\\n        }\\n        if (openBracket < max) {\\n            generateAll (s + \\'(\\', max, openBracket + 1, closeBracket, answer);\\n        }\\n        if (closeBracket < openBracket) {\\n            generateAll (s + \\')\\', max, openBracket, closeBracket + 1, answer);\\n        }\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        generateAll (\"\", n, 0, 0, answer);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441884,
                "title": "8-lines-recursive-solution-in-scala",
                "content": "```\\ndef generateParenthesis(n: Int): List[String] = n match {\\n\\tcase 0 => List(\"\")\\n\\tcase n =>\\n\\t\\tfor {\\n\\t\\t\\tm <- (0 to n - 1).toList\\n\\t\\t\\tx <- generateParenthesis(m)\\n\\t\\t\\ty <- generateParenthesis(n-1-m)\\n\\t\\t} yield (\"(\" ++ x ++ \")\" ++ y)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef generateParenthesis(n: Int): List[String] = n match {\\n\\tcase 0 => List(\"\")\\n\\tcase n =>\\n\\t\\tfor {\\n\\t\\t\\tm <- (0 to n - 1).toList\\n\\t\\t\\tx <- generateParenthesis(m)\\n\\t\\t\\ty <- generateParenthesis(n-1-m)\\n\\t\\t} yield (\"(\" ++ x ++ \")\" ++ y)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 248837,
                "title": "python-dfs-short-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        return self.dfs(n, n, \"\", [])\\n\\n    def dfs(self, l, r, s, res):\\n        if l:\\n            self.dfs(l-1, r, s + \"(\", res)\\n        if r and l < r:          # l < r is important. \\n            self.dfs(l, r-1, s + \")\", res)\\n        if not r:\\n            res.append(s)\\n        return res\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        return self.dfs(n, n, \"\", [])\\n\\n    def dfs(self, l, r, s, res):\\n        if l:\\n            self.dfs(l-1, r, s + \"(\", res)\\n        if r and l < r:          # l < r is important. \\n            self.dfs(l, r-1, s + \")\", res)\\n        if not r:\\n            res.append(s)\\n        return res\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 139825,
                "title": "valid-parenthesis-invariant",
                "content": "Let\\'s define cntLeft as the number of \\'(\\' met so far, cntRight as the number of  \\')\\' met so far.\\n\\nThere is an **invariant** that a valid combination of parenthesis alwas hold **cntLeft >= cntRight**.\\n\\n```\\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> result = new LinkedList<>();\\n        generateParenthesisFrom(n, 0, 0, new StringBuilder(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void generateParenthesisFrom(int n, int cntLeft, int cntRight, StringBuilder temp, List<String> result) {\\n        \\n        if (cntLeft > n || cntRight > n || cntLeft < cntRight) {\\n            return;\\n        }       \\n        if ((cntLeft == n) && (cntRight == n)) {\\n            result.add(temp.toString());\\n            return;\\n        }\\n\\n        temp.append(\"(\");\\n        generateParenthesisFrom(n, cntLeft + 1, cntRight, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);      \\n        \\n        temp.append(\")\");\\n        generateParenthesisFrom(n, cntLeft, cntRight + 1, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);\\n    }\\n```\\nThanks for **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB)",
                "solutionTags": [],
                "code": "```\\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> result = new LinkedList<>();\\n        generateParenthesisFrom(n, 0, 0, new StringBuilder(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void generateParenthesisFrom(int n, int cntLeft, int cntRight, StringBuilder temp, List<String> result) {\\n        \\n        if (cntLeft > n || cntRight > n || cntLeft < cntRight) {\\n            return;\\n        }       \\n        if ((cntLeft == n) && (cntRight == n)) {\\n            result.add(temp.toString());\\n            return;\\n        }\\n\\n        temp.append(\"(\");\\n        generateParenthesisFrom(n, cntLeft + 1, cntRight, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);      \\n        \\n        temp.append(\")\");\\n        generateParenthesisFrom(n, cntLeft, cntRight + 1, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133250,
                "title": "backtracking-with-stringbuilder",
                "content": "```\\npublic List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        generate(0, 0, new StringBuilder(), res, n);\\n        return res;\\n    }\\n    private void generate(int open, int closed, StringBuilder sb, List<String> res, int n){\\n        if(closed > open || open > n || closed > n) return;\\n        if(open == closed && open == n){\\n            res.add(new String(sb));\\n            return;\\n        }\\n        sb.append(\"(\");\\n        generate(open+1, closed, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n        sb.append(\")\");\\n        generate(open, closed+1, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        generate(0, 0, new StringBuilder(), res, n);\\n        return res;\\n    }\\n    private void generate(int open, int closed, StringBuilder sb, List<String> res, int n){\\n        if(closed > open || open > n || closed > n) return;\\n        if(open == closed && open == n){\\n            res.add(new String(sb));\\n            return;\\n        }\\n        sb.append(\"(\");\\n        generate(open+1, closed, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n        sb.append(\")\");\\n        generate(open, closed+1, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10341,
                "title": "simple-c-sol-backtracking",
                "content": "\\n\\nclass Solution {\\n\\nprivate:\\n    \\nvector<string> res;\\n\\npublic:\\n\\n    void genP(int lc, int rc, string s){\\n        if(lc == 0 && rc ==0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(lc>0)\\n            genP(lc-1,rc,s+'(');\\n        if(rc>lc)\\n            genP(lc,rc-1,s+')');\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        genP(n,n,\"\");\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\nprivate:\\n    \\nvector<string> res;\\n\\npublic:\\n\\n    void genP(int lc, int rc, string s){\\n        if(lc == 0 && rc ==0){\\n            res.push_back(s);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 10385,
                "title": "an-easy-c-solution-using-recursion",
                "content": "    \\n\\n    class Solution {\\n    public:\\n        #include<vector>\\n        vector <string> ans;\\n        \\n        void para(int i,int open,int n,string s)\\n        {\\n            if(open < 0)    return;\\n            if(i==n)\\n            {\\n                if(open==0)\\n                    ans.push_back(s);\\n                return;\\n            }\\n            para(i+1,open+1,n,s+\"(\");   \\n            para(i+1,open-1,n,s+\")\");\\n        }\\n    \\n        vector<string> generateParenthesis(int n) {\\n            \\n            string s = \"\";\\n            para(0,0,2*n,s);\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        #include<vector>\\n        vector <string> ans;\\n        \\n        void para(int i,int open,int n,string s)\\n        {\\n            if(open < 0)    return;\\n            if(i==n)\\n            {\\n                if(open==0)\\n                    ans.push_back(s);\\n                return;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 10459,
                "title": "my-java-solution-using-recursive",
                "content": "    public class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        if(0 == n)\\n            return res;\\n        int l = n;\\n        int r = n;\\n        String item = new String();\\n        putIn(l,r,item,res);\\n        return res;\\n    }\\n    public void putIn(int l, int r, String item, List<String> res)\\n    {\\n        if(l==0 && r==0)\\n        {\\n            res.add(item);\\n            return;\\n        }\\n        if(l>0)\\n            putIn(l-1,r,item+\"(\",res);\\n        if(r>l)\\n            putIn(l,r-1,item+\")\",res);\\n    }\\n}\\n\\nThis is based on recursive thought, we can regard the Parenthesis in a set, when the set is empty, we add the string into result list, otherwise, we get a \"(\" from set and add it to the string, and get \")\" from set, add it to the string. Is this thinking better for us to understand?",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        if(0 == n)\\n            return res;\\n        int l = n;\\n        int r = n;\\n        String item = new String();\\n        putIn(l,r,item,res);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 10352,
                "title": "the-most-concise-solution-i-know-ever",
                "content": "    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            if(n==0) return vector<string>(1,\"\") ;\\n            if(n==1) return vector<string>(1,\"()\") ;\\n            vector<string> result;\\n            for(int i=0;i!=n;i++)\\n                for(auto inner: generateParenthesis(i))\\n                    for(auto outter:  generateParenthesis(n-i-1))\\n                        result.push_back(\"(\"+inner+\")\"+outter);\\n            return result;\\n        }\\n    };\\n\\nI think this solution must be the most concise one. The idea is very clear. \\n\\nPS: The author is not me. Just share it with you.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            if(n==0) return vector<string>(1,\"\") ;\\n            if(n==1) return vector<string>(1,\"()\") ;\\n            vector<string> result;\\n            for(int i=0;i!=n;i++)\\n                for(auto inner: generateParenthesis(i))\\n                    for(auto outter:  generateParenthesis(n-i-1))\\n                        result.push_back(\"(\"+inner+\")\"+outter);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3567408,
                "title": "generate-all-valid-parentheses-combinations-backtracking",
                "content": "# Intuition\\nAt first I thought about using part of the paranthesis checker from the last problem but I quickly realized that I needed a new algorithm for this, but I had no clue how to start. I was reading the discussion when I saw someone post a tree graph of the possibilities of one of the samples and I thought, okay, it\\'s possible with backtracking.\\n\\n# Approach\\n1. Create a helper function called **backtrack** that takes the following parameters: **result** (a vector of strings to store valid parentheses combinations), **current** (a string representing the current combination of parentheses), **open** (the count of open parentheses), **close** (the count of close parentheses), and **n** (the desired number of pairs of parentheses).\\n2. The base case of the recursion is when the length of the **current** string is equal to **2 * n**. In this case, all open and close parentheses have been used, so the **current** string represents a valid combination of parentheses. Add the **current** string to the **result** vector and return.\\n3. If the count of open parentheses (**open**) is less than **n**, it means there are still available open parentheses. Append an opening parenthesis \\'(\\' to the **current** string and make a recursive call to **backtrack**, incrementing **open** by 1. This explores the possibility of using an open parenthesis at this position.\\n4. If the count of close parentheses (**close**) is less than **open**, it means there are more open parentheses than close parentheses in the **current** string. Append a closing parenthesis \\')\\' to the **current** string and make a recursive call to **backtrack**, incrementing close by 1. This explores the possibility of using a **close** parenthesis to match an existing open parenthesis.\\n5. After each recursive call, remove the last character from the **current** string to revert it back to the previous state. This is necessary to explore other possibilities and combinations.\\n6. Call the **backtrack** function initially with an empty **current** string, and both **open** and **close** counts set to 0.\\n7. Finally, return the **result** vector containing all valid combinations of parentheses.\\n\\nThe backtracking algorithm explores all possible combinations of parentheses by making recursive calls, adding opening parentheses when there are still available, and adding closing parentheses when there are more openings than closings. This guarantees that all valid combinations of parentheses of length 2 * n are generated.\\n\\n# Complexity\\n- Time complexity:\\n$$O(C(n))$$, where $$C(n)$$ is the Catalan number, which is approximately $$4^n/n^{3/2}$$\\n\\n- Space complexity:\\n$$O(C(n))$$, where $$C(n)$$ is the Catalan number, which is approximately $$4^n/n^{3/2}$$\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    void backtrack(vector<string>& result, string& current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        \\n        if (open < n) {\\n            current.push_back(\\'(\\');\\n            backtrack(result, current, open + 1, close, n);\\n            current.pop_back();\\n        }\\n        \\n        if (close < open) {\\n            current.push_back(\\')\\');\\n            backtrack(result, current, open, close + 1, n);\\n            current.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        string current;\\n        \\n        backtrack(result, current, 0, 0, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void backtrack(vector<string>& result, string& current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        \\n        if (open < n) {\\n            current.push_back(\\'(\\');\\n            backtrack(result, current, open + 1, close, n);\\n            current.pop_back();\\n        }\\n        \\n        if (close < open) {\\n            current.push_back(\\')\\');\\n            backtrack(result, current, open, close + 1, n);\\n            current.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        string current;\\n        \\n        backtrack(result, current, 0, 0, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375419,
                "title": "typescript-javascript-recursive-approach-to-generate-valid-parens",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first i generated all combinations of parens and then filtered them down based on if it was valid\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBetter (this) approach is to add an open or closed paren if either one is a valid option. \\n\\nIf there are any open parens left to add, you can always add an open paren. \\n\\nif there are more open parens then closed ones, you can add a closed paren.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction generateParenthesis(n: number): string[] {\\n    /*\\n        create all possible valid combinations\\n        at each \\n    */\\n    const allCombos = []\\n\\n    function recurse(\\n        openParens: number, closedParens: number, combo: string\\n    ) {\\n        if (openParens === 0 && closedParens === 0) {\\n            allCombos.push(combo)\\n            return\\n        }\\n        \\n        // if there are open parens to close\\n        if (openParens < closedParens) {\\n            recurse(openParens, closedParens - 1, combo + \\')\\')\\n        }\\n\\n        // if there are open parens left to use\\n        if (openParens > 0) {\\n            recurse(openParens - 1, closedParens, combo + \\'(\\')\\n        }\\n    }\\n\\n    recurse(n, n, \\'\\')\\n\\n    return allCombos\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction generateParenthesis(n: number): string[] {\\n    /*\\n        create all possible valid combinations\\n        at each \\n    */\\n    const allCombos = []\\n\\n    function recurse(\\n        openParens: number, closedParens: number, combo: string\\n    ) {\\n        if (openParens === 0 && closedParens === 0) {\\n            allCombos.push(combo)\\n            return\\n        }\\n        \\n        // if there are open parens to close\\n        if (openParens < closedParens) {\\n            recurse(openParens, closedParens - 1, combo + \\')\\')\\n        }\\n\\n        // if there are open parens left to use\\n        if (openParens > 0) {\\n            recurse(openParens - 1, closedParens, combo + \\'(\\')\\n        }\\n    }\\n\\n    recurse(n, n, \\'\\')\\n\\n    return allCombos\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164881,
                "title": "easy-c-solution",
                "content": "# Intuition\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     void helper(vector<string> &v, int n, int oc, int cc, string s)\\n     {\\n         if(oc==n && cc==n){\\n             v.push_back(s);\\n             return ;\\n         }\\n         if(oc<n){\\n             helper(v,n,oc+1,cc,s+\"(\");\\n         }\\n         if(cc < oc){\\n             helper(v,n,oc, cc+1, s+\")\");\\n         }\\n\\n     }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        int oc=0, cc=0;\\n        helper(v,n,oc,cc,\"\");\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void helper(vector<string> &v, int n, int oc, int cc, string s)\\n     {\\n         if(oc==n && cc==n){\\n             v.push_back(s);\\n             return ;\\n         }\\n         if(oc<n){\\n             helper(v,n,oc+1,cc,s+\"(\");\\n         }\\n         if(cc < oc){\\n             helper(v,n,oc, cc+1, s+\")\");\\n         }\\n\\n     }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        int oc=0, cc=0;\\n        helper(v,n,oc,cc,\"\");\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035511,
                "title": "easiest-faang-method-ever",
                "content": "---\\n# \\uD83D\\uDE03***Please do Upvote if it helps \\u2764\\uFE0F***\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^n + n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void parentheses(int open, int closed, string &s, vector<string> &ans){\\n        if(open == 0 && closed == 0){\\n            ans.emplace_back(s);\\n            return;\\n        }\\n        if(open>0){\\n            s+=\"(\";\\n            parentheses(open-1, closed, s, ans);\\n            s.pop_back();\\n        }\\n        if(closed>0 && closed>open){\\n            s+=\")\";\\n            parentheses(open, closed-1, s, ans);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s=\"(\";\\n        int open = n-1;\\n        int closed = n;\\n        parentheses(open, closed, s, ans); \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void parentheses(int open, int closed, string &s, vector<string> &ans){\\n        if(open == 0 && closed == 0){\\n            ans.emplace_back(s);\\n            return;\\n        }\\n        if(open>0){\\n            s+=\"(\";\\n            parentheses(open-1, closed, s, ans);\\n            s.pop_back();\\n        }\\n        if(closed>0 && closed>open){\\n            s+=\")\";\\n            parentheses(open, closed-1, s, ans);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s=\"(\";\\n        int open = n-1;\\n        int closed = n;\\n        parentheses(open, closed, s, ans); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841085,
                "title": "simple-java-recursion-and-backtracking",
                "content": "\\nIdea is to recursively explore all valid combinations.\\n    There are 2 options in every step.\\n        \\n1. Open: if there are more paranthesis to open. if there is an open paranthesis, there must be a close paranthesis too. So increment closable by 1.\\n1. Cose: recursively do this iff there are any closable paranthesis left.\\n\\n```\\n\\nclass Solution {\\n    \\n    private List<String> res = new ArrayList<>();\\n    \\n    public List<String> generateParenthesis(int n) {\\n         rec(n,0,\"\");\\n        return res;\\n    }\\n\\t\\n    void rec(int rem, int closable, String cur){\\n        \\n        if(rem==0 && closable==0){\\n            res.add(cur);\\n            return;\\n        }\\n        \\n        if(rem>0)\\n            rec(rem-1, closable+1, cur+\"(\");\\n        \\n        if(closable>0)\\n            rec(rem,closable-1,cur+\")\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    private List<String> res = new ArrayList<>();\\n    \\n    public List<String> generateParenthesis(int n) {\\n         rec(n,0,\"\");\\n        return res;\\n    }\\n\\t\\n    void rec(int rem, int closable, String cur){\\n        \\n        if(rem==0 && closable==0){\\n            res.add(cur);\\n            return;\\n        }\\n        \\n        if(rem>0)\\n            rec(rem-1, closable+1, cur+\"(\");\\n        \\n        if(closable>0)\\n            rec(rem,closable-1,cur+\")\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518802,
                "title": "simple-solution-explained",
                "content": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        #Answer will be returned in this result array.\\n        result = []\\n        \\n        #openCount: How many open parentheses ie how many \"(\" are there in the string\\n        #closeCount: How many close parentheses ie how many \")\" are there in the string\\n        def generateSequence(string, openCount, closeCount):\\n            #if string length is 2n ie you have generated the required sequence. \\n            #Now you can add this to the result.\\n            if len(string) == 2*n:\\n                result.append(string)\\n                return\\n            \\n            #Add open parentheses only if openCount is less than 0\\n            #remember open and close count start from 0 and not from 1.\\n            if openCount < n:\\n                generateSequence(string+\"(\", openCount+1, closeCount)\\n            #Add close parentheses only if closeCount is less than 0 and also \\n            #close count is less than open count.\\n            #you cant have close parentheses before you have an open parenteses\\n            #This condition takes care of that. \\n            if closeCount < n and closeCount < openCount:\\n                generateSequence(string+\")\", openCount, closeCount+1)\\n            \\n        #Initially string is empty\\n        #and counts are both 0\\n        generateSequence(\"\", 0, 0)\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        #Answer will be returned in this result array.\\n        result = []\\n        \\n        #openCount: How many open parentheses ie how many \"(\" are there in the string\\n        #closeCount: How many close parentheses ie how many \")\" are there in the string\\n        def generateSequence(string, openCount, closeCount):\\n            #if string length is 2n ie you have generated the required sequence. \\n            #Now you can add this to the result.\\n            if len(string) == 2*n:\\n                result.append(string)\\n                return\\n            \\n            #Add open parentheses only if openCount is less than 0\\n            #remember open and close count start from 0 and not from 1.\\n            if openCount < n:\\n                generateSequence(string+\"(\", openCount+1, closeCount)\\n            #Add close parentheses only if closeCount is less than 0 and also \\n            #close count is less than open count.\\n            #you cant have close parentheses before you have an open parenteses\\n            #This condition takes care of that. \\n            if closeCount < n and closeCount < openCount:\\n                generateSequence(string+\")\", openCount, closeCount+1)\\n            \\n        #Initially string is empty\\n        #and counts are both 0\\n        generateSequence(\"\", 0, 0)\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 2299428,
                "title": "java-c-javascript-100-fully-explained-with-comments-very-easy",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        //Create a list that will store the solution\\n        List<String> sol = new ArrayList<>();\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", sol, n);\\n        return sol;\\n    }\\n    \\n    private void generator(int op, int cl, String str, List<String> sol, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.add(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    //Create a list that will store the solution\\n    vector<string> sol;\\n    \\n    void generator(int op, int cl, string str, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.push_back(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n)\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', n);\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl)\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', n);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", n);\\n        return sol;   \\n    }\\n};\\n```\\n\\n# **Javascript Solution:**\\n```\\nvar generateParenthesis = function(n) {\\n    //Create a list that will store the solution\\n    const sol = [];\\n    //Recursively call backtracking function\\n    generator(0, 0, \"\", sol, n);\\n    return sol;\\n};\\n\\nfunction generator(op, cl, str, sol, n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op === n && cl === n) {\\n            //add the string(str) to the list\\n            sol.push(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        //Create a list that will store the solution\\n        List<String> sol = new ArrayList<>();\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", sol, n);\\n        return sol;\\n    }\\n    \\n    private void generator(int op, int cl, String str, List<String> sol, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.add(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    //Create a list that will store the solution\\n    vector<string> sol;\\n    \\n    void generator(int op, int cl, string str, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.push_back(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n)\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', n);\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl)\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', n);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", n);\\n        return sol;   \\n    }\\n};\\n```\n```\\nvar generateParenthesis = function(n) {\\n    //Create a list that will store the solution\\n    const sol = [];\\n    //Recursively call backtracking function\\n    generator(0, 0, \"\", sol, n);\\n    return sol;\\n};\\n\\nfunction generator(op, cl, str, sol, n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op === n && cl === n) {\\n            //add the string(str) to the list\\n            sol.push(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140410,
                "title": "java-backtracking-detailed-explanation",
                "content": "```\\n/*\\nClassic Backtracking Problem\\nFor a Backtracking Problem : Remember the 3 Parts\\n1. Choices\\n2. Constraints\\n3. Goal Condition\\n\\n1. The Choices in this case is to either put a \"(\" or \")\"\\n2. The Constraints are\\n   (a) -> The number of openBrackets or ClosedBrackets cannot be more than n\\n   (b) -> A ClosedBracket cannot be added to an empty string, i.e. a corresponding open bracket is needed\\n   (c) -> The count of closedBracket cannot be more than that of OpenBracket at any given time\\n3. The Goal Condition is when the length of the string becomes 2*n\\n\\n*/\\n\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        backTrack(\"\",res,0,0,n);\\n        return res;\\n    }\\n    \\n    public void backTrack(String currWord, List<String> res,int openCount, int closedCount, int n){\\n        //If the Goal Condition is reached\\n        if(currWord.length()==n*2){\\n            res.add(currWord);\\n            return;\\n        }\\n        \\n        //If the number of openBrackets are less than n, keeping recursively calling\\n        if(openCount<n){\\n            backTrack(currWord + \"(\", res, openCount+1, closedCount, n);\\n        }\\n        \\n        //If the count of closedBrackets is less than openCount -> It is valid to add\\n        if(closedCount<openCount){\\n            backTrack(currWord + \")\", res, openCount, closedCount+1, n);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n/*\\nClassic Backtracking Problem\\nFor a Backtracking Problem : Remember the 3 Parts\\n1. Choices\\n2. Constraints\\n3. Goal Condition\\n\\n1. The Choices in this case is to either put a \"(\" or \")\"\\n2. The Constraints are\\n   (a) -> The number of openBrackets or ClosedBrackets cannot be more than n\\n   (b) -> A ClosedBracket cannot be added to an empty string, i.e. a corresponding open bracket is needed\\n   (c) -> The count of closedBracket cannot be more than that of OpenBracket at any given time\\n3. The Goal Condition is when the length of the string becomes 2*n\\n\\n*/\\n\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        backTrack(\"\",res,0,0,n);\\n        return res;\\n    }\\n    \\n    public void backTrack(String currWord, List<String> res,int openCount, int closedCount, int n){\\n        //If the Goal Condition is reached\\n        if(currWord.length()==n*2){\\n            res.add(currWord);\\n            return;\\n        }\\n        \\n        //If the number of openBrackets are less than n, keeping recursively calling\\n        if(openCount<n){\\n            backTrack(currWord + \"(\", res, openCount+1, closedCount, n);\\n        }\\n        \\n        //If the count of closedBrackets is less than openCount -> It is valid to add\\n        if(closedCount<openCount){\\n            backTrack(currWord + \")\", res, openCount, closedCount+1, n);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519267,
                "title": "brute-force-to-optimized-approach-c",
                "content": "# **Brute Force**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int n,vector<string>&res,int open=0,int close=0,string str=\"\"){\\n        if(open>n || close>n){\\n            return 0;\\n        }\\n        if(open+close==2*n){\\n            res.push_back(str);\\n            return 1;\\n        }\\n        int o=0,c=0;\\n        o=solve(n,res,open+1,close,str+\"(\");\\n        if(open>close){\\n            =solve(n,res,open,close+1,str+\")\");\\n        }\\n        \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>res;\\n        solve(n,res);\\n        return res;\\n    }\\n};\\n```\\n**Time Complexity is O(2^(2*N))** \\n**Space Complexity is O(2*N) (due to stack)**\\nNow this will pass because the constraint n is very small.\\nBut in case of larger n we will have to resort to Some other approach.\\n\\n# **Optimized approach**\\nWhen we look into the pattern we see that it forms overlaping subproblems.\\nSuppose dp[i] contains all the valid parentheses possible of length 2*i. \\nSuppose you got dp[2] which is { (()) , ()() }. Now what will be dp[3]? It can be written as -\\n\\n( + dp[0] + ) + dp[2] = ()(()) and ()()()\\n( + dp[1] + ) + dp[1] = (())()\\n( + dp[2] + ) + dp[0] = ((())) and (()())\\n\\nhere we see that instead of doing the recusion of we store these values \\n**Using Bottom Up DP**\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<vector<string>>dp(n+1);\\n        dp[0]={\"\"};\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**Time Complexity O(N^4)**\\n**Space Complexity O(N*N)**\\n\\n\\n# **Futher Optimization**\\nnow we can decalrte a global variable and checking in the first loop if that had been covered in previous iteration then skip it.\\nThus further reducing time complexity though it increases space complexity.\\n```\\nclass Solution {\\nvector<vector<string>>dp;\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        dp.resize(n+1);\\n        dp[0]={\"\"};\\n        for(int i=1;i<=n;i++){\\n            if(dp[i].size()){\\n                continue;\\n            }\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int n,vector<string>&res,int open=0,int close=0,string str=\"\"){\\n        if(open>n || close>n){\\n            return 0;\\n        }\\n        if(open+close==2*n){\\n            res.push_back(str);\\n            return 1;\\n        }\\n        int o=0,c=0;\\n        o=solve(n,res,open+1,close,str+\"(\");\\n        if(open>close){\\n            =solve(n,res,open,close+1,str+\")\");\\n        }\\n        \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>res;\\n        solve(n,res);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<vector<string>>dp(n+1);\\n        dp[0]={\"\"};\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\nvector<vector<string>>dp;\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        dp.resize(n+1);\\n        dp[0]={\"\"};\\n        for(int i=1;i<=n;i++){\\n            if(dp[i].size()){\\n                continue;\\n            }\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462096,
                "title": "dynamic-programming-java-memory-beats-85",
                "content": "Instead of using backtrack - which is a little bit hard to handle - I used a Dynamic Programming method that does not involve recursion. \\n\\nThe gist is as such:\\n\\nWe create the parenthesis array for n by adding \"()\" inside of, and in parallel with, another \"()\" for every string element in the \"n-1\" parenthesis array. \\n\\nThis may look a bit confusing. Let me explain using an example. \\n\\nThe \"n=1\" array is a single \"( )\".\\n\\nTo create the \"n=2\" array, we add another \"()\" both inside of, and in parrallel with the existing \"()\". Therefore we have such: [ \"( )( )\", \"(( ))\"]\\n\\nTo create the \"n=3\" array, we do the above operation to each and every element in the \"n=2\" array. \\n\\nSo, for \"( ) ( )\", we have \"( ) ( ) ( )\" , \"( ( ) ) ( )\", and \"( ) ( ( ) )\". \\nAnd for \"( ( ) ) \", we have \" ( ( ) ( ) ) \"and \"( ( ( ) ) )\".\\n\\nTherefore, for n=3 we have an array that reads :\\n\\n[\"( ) ( ) ( )\",  \"( ( ) ) ( )\", \"( ) ( ( ) )\",  \"( ( ) ) \", \" ( ( ) ( ) ) \", \"( ( ( ) ) )\"]\\n\\nNote that sometimes, you may end up creating duplicate entries. Luckily we can use a hashset to remove them automatically.\\n\\nwhen n =4, we repeat the same operation to EACH AND EVERY element in the n=3 array.\\n\\n```\\n  public List<String> generateParenthesis(int n) {\\n        List<String> first = Arrays.asList(\"()\");\\n        if (n == 1) return first;\\n        for (int i = 1; i < n; i++) {\\n            HashSet<String> set = this.processStrings(first);\\n            first = new ArrayList<>();\\n            for (String ss : set) {\\n//                System.out.println(ss);\\n                first.add(ss);\\n            }\\n        }\\n        for (String s : first) {\\n            System.out.println(s);\\n        }\\n\\n        return first;\\n    }\\n\\n\\n    private HashSet<String> processStrings(List<String> strings) {\\n\\n        HashSet<String> set = new HashSet<>();\\n\\n        for (String s : strings) {\\n            this.processString(s, set);\\n        }\\n        return set;\\n    }\\n\\n    private void processString(String s, HashSet<String> set) {\\n        int index = 0;\\n        while (s.indexOf(\"()\", index) != -1) {\\n\\n            index = s.indexOf(\"()\", index) + 1;\\n\\n            String newString;\\n            String newString2;\\n            if (index < s.length() - 1) {\\n\\n                s.substring(0, index);\\n                s.substring(index + 2);\\n                newString = s.substring(0, index - 1) + \"()()\" + s.substring(index + 1);\\n                newString2 = s.substring(0, index - 1) + \"(())\" + s.substring(index + 1);\\n\\n                set.add(newString);\\n                set.add(newString2);\\n\\n            } else if (index == s.length() - 1) {\\n                newString = s.substring(0, index - 1) + \"()()\";\\n                newString2 = s.substring(0, index - 1) + \"(())\";\\n\\n                set.add(newString);\\n                set.add(newString2);\\n            }\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n  public List<String> generateParenthesis(int n) {\\n        List<String> first = Arrays.asList(\"()\");\\n        if (n == 1) return first;\\n        for (int i = 1; i < n; i++) {\\n            HashSet<String> set = this.processStrings(first);\\n            first = new ArrayList<>();\\n            for (String ss : set) {\\n//                System.out.println(ss);\\n                first.add(ss);\\n            }\\n        }\\n        for (String s : first) {\\n            System.out.println(s);\\n        }\\n\\n        return first;\\n    }\\n\\n\\n    private HashSet<String> processStrings(List<String> strings) {\\n\\n        HashSet<String> set = new HashSet<>();\\n\\n        for (String s : strings) {\\n            this.processString(s, set);\\n        }\\n        return set;\\n    }\\n\\n    private void processString(String s, HashSet<String> set) {\\n        int index = 0;\\n        while (s.indexOf(\"()\", index) != -1) {\\n\\n            index = s.indexOf(\"()\", index) + 1;\\n\\n            String newString;\\n            String newString2;\\n            if (index < s.length() - 1) {\\n\\n                s.substring(0, index);\\n                s.substring(index + 2);\\n                newString = s.substring(0, index - 1) + \"()()\" + s.substring(index + 1);\\n                newString2 = s.substring(0, index - 1) + \"(())\" + s.substring(index + 1);\\n\\n                set.add(newString);\\n                set.add(newString2);\\n\\n            } else if (index == s.length() - 1) {\\n                newString = s.substring(0, index - 1) + \"()()\";\\n                newString2 = s.substring(0, index - 1) + \"(())\";\\n\\n                set.add(newString);\\n                set.add(newString2);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1361937,
                "title": "recursive-tree-and-implementation",
                "content": "![image](https://assets.leetcode.com/users/images/d795b906-b24a-4a0a-9297-11c542243397_1627219155.438998.png)\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void func(string &s , int open , int close){\\n        if (open == 0 and close == 0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > close or open < 0 or close < 0)\\n            return;\\n        s.push_back(\\'(\\');\\n        func(s , open-1 , close);\\n        s.pop_back();\\n        s.push_back(\\')\\');\\n        func(s , open , close-1);\\n        s.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        func(s , n , n);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void func(string &s , int open , int close){\\n        if (open == 0 and close == 0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > close or open < 0 or close < 0)\\n            return;\\n        s.push_back(\\'(\\');\\n        func(s , open-1 , close);\\n        s.pop_back();\\n        s.push_back(\\')\\');\\n        func(s , open , close-1);\\n        s.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        func(s , n , n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322204,
                "title": "c-solution-using-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n   static bool isValid(string m)\\n    {\\n        if(m[0]==\\')\\')\\n            return false;\\n        stack<string> s;\\n        for(int i =0;i<m.length();i++)\\n        {\\n            if(m[i]==\\'(\\')\\n                s.push(\"(\");\\n            else if(s.empty()&&m[i]==\\')\\')\\n                    return false;\\n            else if(m[i]==\\')\\')\\n                s.pop();\\n        }\\n        if(s.empty())\\n            return true;\\n        else\\n            return false;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        vector<string> v;\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\"(\";\\n        }\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\")\";\\n        }\\n        v.push_back(s);\\n        while(next_permutation(s.begin(),s.end()))\\n        {\\n            if(isValid(s))\\n                v.push_back(s);\\n        }      \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool isValid(string m)\\n    {\\n        if(m[0]==\\')\\')\\n            return false;\\n        stack<string> s;\\n        for(int i =0;i<m.length();i++)\\n        {\\n            if(m[i]==\\'(\\')\\n                s.push(\"(\");\\n            else if(s.empty()&&m[i]==\\')\\')\\n                    return false;\\n            else if(m[i]==\\')\\')\\n                s.pop();\\n        }\\n        if(s.empty())\\n            return true;\\n        else\\n            return false;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        vector<string> v;\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\"(\";\\n        }\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\")\";\\n        }\\n        v.push_back(s);\\n        while(next_permutation(s.begin(),s.end()))\\n        {\\n            if(isValid(s))\\n                v.push_back(s);\\n        }      \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295346,
                "title": "100-faster-c-i-e-0ms-with-explanation",
                "content": "\\n    vector<string> ans; //container of  all possible answers\\n    void dfs(string& path, int open, int close){\\n        if(open==0 and close==0){  // here we donot have either of the bracket so add it to our answer\\n            ans.push_back(path);\\n            return ;\\n        }\\n        if(open>0){ // here we still can add more open brackets in out answers\\n            path.push_back(\\'(\\');\\n            dfs(path, open-1, close); // now update the open \\n            path.pop_back(); // yes we did the backtrack here to try out all possibility\\n        }\\n        if(close>0 and open < close){ // if and only if we have close brackets and at this current sopt we have more number of open brackets than close ones.\\n            path.push_back(\\')\\');\\n            dfs(path,open,close-1);\\n            path.pop_back(); // here also we need to backtrack\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s; // initial path ie. blank\\n        // in starting we have n number of open and n number of close brackets \\n        dfs(s,n,n); // ran a sort of dfs tried out all possibility\\n        return ans; // return the ans at last when we are done\\n    }",
                "solutionTags": [],
                "code": "\\n    vector<string> ans; //container of  all possible answers\\n    void dfs(string& path, int open, int close){\\n        if(open==0 and close==0){  // here we donot have either of the bracket so add it to our answer\\n            ans.push_back(path);\\n            return ;\\n        }\\n        if(open>0){ // here we still can add more open brackets in out answers\\n            path.push_back(\\'(\\');\\n            dfs(path, open-1, close); // now update the open \\n            path.pop_back(); // yes we did the backtrack here to try out all possibility\\n        }\\n        if(close>0 and open < close){ // if and only if we have close brackets and at this current sopt we have more number of open brackets than close ones.\\n            path.push_back(\\')\\');\\n            dfs(path,open,close-1);\\n            path.pop_back(); // here also we need to backtrack\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s; // initial path ie. blank\\n        // in starting we have n number of open and n number of close brackets \\n        dfs(s,n,n); // ran a sort of dfs tried out all possibility\\n        return ans; // return the ans at last when we are done\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1191129,
                "title": "c-recursive-solution-with-detailed-explanation",
                "content": "An integer value N is given as input. Total number of opening brackets = Total number of closing brackets = N. A recursive function solve is called with parameters open(no. of opening brackets), close(no. of closing brackets), current string and final answer res which is passed by reference.\\n\\nIf number of opening brackets = number of closing brackets = n, this implies leaf node has been reached in recursion tree and thus it is added to the res. If no. of opening brackets is not equal to 0 add an opening bracket to the current string and decrement the count of open and recursively call the function for new values.\\n\\nIf no. of closing brackets is greater than number of opening brackets then a closing bracket is added to the current string and count of close is decremented by 1 and the function is recursively called for new values.\\n\\n\\n    void solve(int open, int close, string str, vector<string>& res)\\n    {\\n        if(open == 0 && close == 0)\\n        {\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(open != 0)\\n        {\\n            string str1 = str;\\n            str1.push_back(\\'(\\');\\n            solve(open - 1, close, str1, res);\\n        }\\n        \\n        if(close > open)\\n        {\\n            string str2 = str;\\n            str2.push_back(\\')\\');\\n            solve(open, close - 1, str2, res);\\n        }\\n        \\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) \\n    {\\n        vector<string> res;\\n        int open = n;\\n        int close = n;\\n        \\n        string str = \"\";\\n        \\n        solve(open, close, str, res);\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "An integer value N is given as input. Total number of opening brackets = Total number of closing brackets = N. A recursive function solve is called with parameters open(no. of opening brackets), close(no. of closing brackets), current string and final answer res which is passed by reference.\\n\\nIf number of opening brackets = number of closing brackets = n, this implies leaf node has been reached in recursion tree and thus it is added to the res. If no. of opening brackets is not equal to 0 add an opening bracket to the current string and decrement the count of open and recursively call the function for new values.\\n\\nIf no. of closing brackets is greater than number of opening brackets then a closing bracket is added to the current string and count of close is decremented by 1 and the function is recursively called for new values.\\n\\n\\n    void solve(int open, int close, string str, vector<string>& res)\\n    {\\n        if(open == 0 && close == 0)\\n        {\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(open != 0)\\n        {\\n            string str1 = str;\\n            str1.push_back(\\'(\\');\\n            solve(open - 1, close, str1, res);\\n        }\\n        \\n        if(close > open)\\n        {\\n            string str2 = str;\\n            str2.push_back(\\')\\');\\n            solve(open, close - 1, str2, res);\\n        }\\n        \\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) \\n    {\\n        vector<string> res;\\n        int open = n;\\n        int close = n;\\n        \\n        string str = \"\";\\n        \\n        solve(open, close, str, res);\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1134167,
                "title": "60ms-faster-than-100-of-js-submissions",
                "content": "```\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const go = (s=\"\",l=0,r=0)=>{\\n        if(s.length===2*n){\\n            res.push(s);\\n            return;\\n        }\\n        if(l<n) go(s+\\'(\\',l+1,r);\\n        if(r<l) go(s+\\')\\',l,r+1);\\n    }\\n    go();\\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const go = (s=\"\",l=0,r=0)=>{\\n        if(s.length===2*n){\\n            res.push(s);\\n            return;\\n        }\\n        if(l<n) go(s+\\'(\\',l+1,r);\\n        if(r<l) go(s+\\')\\',l,r+1);\\n    }\\n    go();\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1056871,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    \\n    List<String> arr = new ArrayList<String>();\\n    int finalLength;\\n    public List<String> generateParenthesis(int n) {\\n        this.finalLength = 2* n;\\n        helper(2*n, \"\");\\n        \\n        List<String> ans = new ArrayList<String>();\\n        for(String str: arr)\\n        {\\n            //System.out.println(str);\\n            if(check(str))\\n                ans.add(str);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    public void helper(int n, String str)\\n    {\\n        if(str.length() == finalLength)\\n            arr.add(str);\\n        if(n <= 0)\\n            return;\\n        \\n        String str1 = new String(str + \"(\");\\n        String str2 = new String(str + \")\");\\n        helper(n-1, str1);\\n        helper(n-1, str2);\\n        \\n    }\\n    \\n    \\n    public boolean check(String str)\\n    {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch: str.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n                stack.push(ch);\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty() || stack.peek()!=\\'(\\')\\n                    return false;\\n                stack.pop();\\n            }\\n        }\\n        if(!stack.isEmpty())\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<String> arr = new ArrayList<String>();\\n    int finalLength;\\n    public List<String> generateParenthesis(int n) {\\n        this.finalLength = 2* n;\\n        helper(2*n, \"\");\\n        \\n        List<String> ans = new ArrayList<String>();\\n        for(String str: arr)\\n        {\\n            //System.out.println(str);\\n            if(check(str))\\n                ans.add(str);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    public void helper(int n, String str)\\n    {\\n        if(str.length() == finalLength)\\n            arr.add(str);\\n        if(n <= 0)\\n            return;\\n        \\n        String str1 = new String(str + \"(\");\\n        String str2 = new String(str + \")\");\\n        helper(n-1, str1);\\n        helper(n-1, str2);\\n        \\n    }\\n    \\n    \\n    public boolean check(String str)\\n    {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch: str.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n                stack.push(ch);\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty() || stack.peek()!=\\'(\\')\\n                    return false;\\n                stack.pop();\\n            }\\n        }\\n        if(!stack.isEmpty())\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996790,
                "title": "this-c-solution-is-very-easy-to-understand-beats-100-illustration",
                "content": "From the recusrive tree its very easy to find the base cases and operation, Hope it help a lot. (vote - up)\\n```\\nclass Solution {\\n    vector<string> s;\\npublic:\\n    \\n    void solve(string combi, int n, int mimicStack) {\\n        if(n == 0 && mimicStack == 0)\\n            s.push_back(combi);\\n        \\n        if(n > 0)\\n            solve(combi + \\'(\\', n-1, mimicStack+1);\\n\\n        if(mimicStack > 0)\\n            solve(combi + \\')\\', n, mimicStack-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        solve(\"\", n, 0);\\n        return s;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/df18629d-7750-4d86-9dcb-793a36046dfe_1609517768.9531047.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> s;\\npublic:\\n    \\n    void solve(string combi, int n, int mimicStack) {\\n        if(n == 0 && mimicStack == 0)\\n            s.push_back(combi);\\n        \\n        if(n > 0)\\n            solve(combi + \\'(\\', n-1, mimicStack+1);\\n\\n        if(mimicStack > 0)\\n            solve(combi + \\')\\', n, mimicStack-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        solve(\"\", n, 0);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960608,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(string &str,int open_count,int close_count,vector<string> &ans){\\n        if(open_count==0 && close_count==0){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open_count>0){\\n            str.push_back(\\'(\\');\\n            solve(str,open_count-1,close_count,ans);\\n            str.pop_back();\\n        }\\n        \\n        if(close_count>open_count){\\n            str.push_back(\\')\\');\\n            solve(str,open_count,close_count-1,ans);\\n            str.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string str;\\n        solve(str,n,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string &str,int open_count,int close_count,vector<string> &ans){\\n        if(open_count==0 && close_count==0){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open_count>0){\\n            str.push_back(\\'(\\');\\n            solve(str,open_count-1,close_count,ans);\\n            str.pop_back();\\n        }\\n        \\n        if(close_count>open_count){\\n            str.push_back(\\')\\');\\n            solve(str,open_count,close_count-1,ans);\\n            str.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string str;\\n        solve(str,n,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796042,
                "title": "simple-python-solution",
                "content": "Simple python solution\\n\\n``` python\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        allOutput = set([])\\n        def dfs(output, numOfLeft, numOfRight, n):\\n            if len(output) == n * 2:\\n                allOutput.add(output)\\n                return\\n            if numOfLeft < n:\\n                dfs(output + \\'(\\', numOfLeft + 1, numOfRight, n)\\n            if numOfLeft > numOfRight and numOfRight < n:\\n                dfs(output + \\')\\', numOfLeft, numOfRight + 1, n)\\n        dfs(\\'(\\', 1, 0, n)\\n        return allOutput\\n```",
                "solutionTags": [],
                "code": "``` python\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        allOutput = set([])\\n        def dfs(output, numOfLeft, numOfRight, n):\\n            if len(output) == n * 2:\\n                allOutput.add(output)\\n                return\\n            if numOfLeft < n:\\n                dfs(output + \\'(\\', numOfLeft + 1, numOfRight, n)\\n            if numOfLeft > numOfRight and numOfRight < n:\\n                dfs(output + \\')\\', numOfLeft, numOfRight + 1, n)\\n        dfs(\\'(\\', 1, 0, n)\\n        return allOutput\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 653526,
                "title": "java-dfs",
                "content": "![image](https://assets.leetcode.com/users/chuanqiu/image_1590767732.png)\\n\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new LinkedList<>();\\n        if(n == 0) return res;\\n        dfs(\"\",0,0,n,res);\\n        return res;        \\n    }\\n    \\n     /**\\n     * @param curStr       The result of the current recursion\\n     * @param left          How much left bracket has been used\\n     * @param right  \\n     * @param n      \\n     * @param res         result set\\n     */\\n    \\n    public void dfs(String curstr, int left, int right, int n, List<String> res){\\n        if(left ==n && right ==n){\\n            res.add(curstr);\\n            return;\\n        }\\n        //unsatisfied condition, cut off\\n        if(left < right){\\n            return;\\n        }\\n        \\n        if(left<n){\\n            dfs(curstr+\"(\",left+1,right,n,res);\\n        }\\n        \\n         if(right<n){\\n            dfs(curstr+\")\",left,right+1,n,res);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new LinkedList<>();\\n        if(n == 0) return res;\\n        dfs(\"\",0,0,n,res);\\n        return res;        \\n    }\\n    \\n     /**\\n     * @param curStr       The result of the current recursion\\n     * @param left          How much left bracket has been used\\n     * @param right  \\n     * @param n      \\n     * @param res         result set\\n     */\\n    \\n    public void dfs(String curstr, int left, int right, int n, List<String> res){\\n        if(left ==n && right ==n){\\n            res.add(curstr);\\n            return;\\n        }\\n        //unsatisfied condition, cut off\\n        if(left < right){\\n            return;\\n        }\\n        \\n        if(left<n){\\n            dfs(curstr+\"(\",left+1,right,n,res);\\n        }\\n        \\n         if(right<n){\\n            dfs(curstr+\")\",left,right+1,n,res);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607754,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\n    vector<string>res;\\n    void dfs(int n, string curr, int left, int right) {\\n        if (left + right == 2*n)\\n            res.push_back(curr);\\n        \\n        if (left < n) dfs(n, curr + \\'(\\', left+1, right);\\n        if (left > right) dfs(n, curr + \\')\\', left, right+1);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string curr;\\n        dfs(n, curr, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<string>res;\\n    void dfs(int n, string curr, int left, int right) {\\n        if (left + right == 2*n)\\n            res.push_back(curr);\\n        \\n        if (left < n) dfs(n, curr + \\'(\\', left+1, right);\\n        if (left > right) dfs(n, curr + \\')\\', left, right+1);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string curr;\\n        dfs(n, curr, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575711,
                "title": "c-easy-understand-dfs-solution-both-recursive-iterative-version",
                "content": "Sol1 & Sol2 have the same idea.\\n**Sol1: Recursive version**\\n```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0, 0);\\n        return result;\\n    }\\n    void helper(string s, int n, int l, int r){\\n        if (l < r || l > n || r > n) return;  // exceed the bundary -> return\\n\\t    if (l == n && r == n){\\n\\t        result.push_back(s);\\n\\t        return;\\n\\t    }\\n\\t\\thelper(s + \"(\", n, l+1, r);\\n\\t\\thelper(s + \")\", n, l, r+1);\\n    }\\n};\\n```\\n**Sol2: Iterative version**\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        stack<pair<string, pair<int, int>>> st;\\n        st.push({\"\", {0, 0}});\\n        int l, r;\\n        string s;\\n        while (!st.empty()){\\n            pair<string, pair<int, int>> p;\\n            p = st.top();\\n            st.pop();\\n            l = p.second.first;\\n            r = p.second.second;\\n            s = p.first;\\n            if (l < r || l > n || r > n) continue;    // exceed the bundary -> skip the process below\\n            if (l == n && r == n) result.push_back(s);\\n            st.push({s+\"(\", {l+1, r}});\\n            st.push({s+\")\", {l, r+1}});\\n        }\\n        return result;\\n    } \\n};\\n```\\nTime & Space complexity: Pls refer to the official solution. (It is complex...)",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0, 0);\\n        return result;\\n    }\\n    void helper(string s, int n, int l, int r){\\n        if (l < r || l > n || r > n) return;  // exceed the bundary -> return\\n\\t    if (l == n && r == n){\\n\\t        result.push_back(s);\\n\\t        return;\\n\\t    }\\n\\t\\thelper(s + \"(\", n, l+1, r);\\n\\t\\thelper(s + \")\", n, l, r+1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        stack<pair<string, pair<int, int>>> st;\\n        st.push({\"\", {0, 0}});\\n        int l, r;\\n        string s;\\n        while (!st.empty()){\\n            pair<string, pair<int, int>> p;\\n            p = st.top();\\n            st.pop();\\n            l = p.second.first;\\n            r = p.second.second;\\n            s = p.first;\\n            if (l < r || l > n || r > n) continue;    // exceed the bundary -> skip the process below\\n            if (l == n && r == n) result.push_back(s);\\n            st.push({s+\"(\", {l+1, r}});\\n            st.push({s+\")\", {l, r+1}});\\n        }\\n        return result;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504773,
                "title": "swift-closure",
                "content": "Rather than passing inout array inside the backtrack method, I use closure to pass the values over here.\\n\\n``` swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var result = [String]()\\n        backtrack(\"\", 0, 0, n) { result.append($0) }\\n        return result\\n    }\\n\\n    func backtrack(_ current: String,_ open: Int,_ end: Int,_ max: Int, _ result: (String)->Void) {\\n        if current.count == max * 2 {\\n            result(current)\\n            return\\n        }\\n        \\n        if open < max { backtrack(current + \"(\", open + 1, end, max, result) }\\n        if end < open  { backtrack(current + \")\", open, end + 1, max, result) }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "``` swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var result = [String]()\\n        backtrack(\"\", 0, 0, n) { result.append($0) }\\n        return result\\n    }\\n\\n    func backtrack(_ current: String,_ open: Int,_ end: Int,_ max: Int, _ result: (String)->Void) {\\n        if current.count == max * 2 {\\n            result(current)\\n            return\\n        }\\n        \\n        if open < max { backtrack(current + \"(\", open + 1, end, max, result) }\\n        if end < open  { backtrack(current + \")\", open, end + 1, max, result) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503352,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let result = [];\\n    \\n    function go(str, closedLeft, openLeft) {\\n        if (str.length === n*2) {\\n            result.push(str);\\n        }\\n        if (openLeft > 0) {\\n            go(str + \\'(\\', closedLeft + 1, openLeft - 1);\\n        }\\n        if (closedLeft > 0) {\\n            go(str + \\')\\', closedLeft - 1, openLeft);\\n        }\\n    }\\n   \\n    go(\"\", 0, n);\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let result = [];\\n    \\n    function go(str, closedLeft, openLeft) {\\n        if (str.length === n*2) {\\n            result.push(str);\\n        }\\n        if (openLeft > 0) {\\n            go(str + \\'(\\', closedLeft + 1, openLeft - 1);\\n        }\\n        if (closedLeft > 0) {\\n            go(str + \\')\\', closedLeft - 1, openLeft);\\n        }\\n    }\\n   \\n    go(\"\", 0, n);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375856,
                "title": "simple-python-solution-without-recursion",
                "content": "```\\n    def generateParenthesis(self, N):\\n        answer, last_results = [], [(\\'(\\', 1, 0)]\\n        while last_results:\\n            new_results = []\\n            for _ in range(len(last_results)):\\n                (result, left, right) = last_results.pop()  # popping is not required, but it saves memory\\n                if right == N and left == N:\\n                    answer.append(result)\\n                else:\\n                    if left < N:\\n                        new_results.append((result + \\'(\\', left+1, right))\\n                    if right < left:\\n                        new_results.append((result + \\')\\', left, right+1))\\n            last_results = new_results\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def generateParenthesis(self, N):\\n        answer, last_results = [], [(\\'(\\', 1, 0)]\\n        while last_results:\\n            new_results = []\\n            for _ in range(len(last_results)):\\n                (result, left, right) = last_results.pop()  # popping is not required, but it saves memory\\n                if right == N and left == N:\\n                    answer.append(result)\\n                else:\\n                    if left < N:\\n                        new_results.append((result + \\'(\\', left+1, right))\\n                    if right < left:\\n                        new_results.append((result + \\')\\', left, right+1))\\n            last_results = new_results\\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 297416,
                "title": "rust-0ms-solution",
                "content": "```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        let mut result: Vec<String> = vec![];\\n        Self::_gen(&mut result, n, n, \"\".to_string());\\n        result\\n    }\\n    pub fn _gen(result: &mut Vec<String>, left: i32, right: i32, sublist: String) {\\n        if left == 0 && right == 0 {\\n            result.push(sublist);\\n            return;\\n        }\\n        if left > 0 {\\n            Self::_gen(result, left - 1, right, sublist.clone() + \"(\");\\n        }\\n        if right > left {\\n            Self::_gen(result, left, right - 1, sublist.clone() + \")\");\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        let mut result: Vec<String> = vec![];\\n        Self::_gen(&mut result, n, n, \"\".to_string());\\n        result\\n    }\\n    pub fn _gen(result: &mut Vec<String>, left: i32, right: i32, sublist: String) {\\n        if left == 0 && right == 0 {\\n            result.push(sublist);\\n            return;\\n        }\\n        if left > 0 {\\n            Self::_gen(result, left - 1, right, sublist.clone() + \"(\");\\n        }\\n        if right > left {\\n            Self::_gen(result, left, right - 1, sublist.clone() + \")\");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 253175,
                "title": "sweet-old-ruby-solution",
                "content": "```\\ndef generate_parenthesis(n)\\n  recurse(n, 0, 0, \\'\\', [])\\nend\\n\\ndef recurse(n, o, c, cur, res)\\n  res << cur if o + c == 2 * n\\n\\n  recurse(n, o + 1, c, cur + \\'(\\', res) if o < n\\n  recurse(n, o, c + 1, cur + \\')\\', res) if c < o\\n\\n  res\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef generate_parenthesis(n)\\n  recurse(n, 0, 0, \\'\\', [])\\nend\\n\\ndef recurse(n, o, c, cur, res)\\n  res << cur if o + c == 2 * n\\n\\n  recurse(n, o + 1, c, cur + \\'(\\', res) if o < n\\n  recurse(n, o, c + 1, cur + \\')\\', res) if c < o\\n\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 222314,
                "title": "javascript",
                "content": "```\\nvar generateParenthesis = function(n) {\\n  const r = [];\\n  const gen = (left, right, _r) => {\\n    if (left === n && right === n) {\\n      r.push(_r);\\n      return;\\n    }\\n    if (left < n) gen(left + 1, right, `${_r}(`);\\n    if (left > right && right < n) gen(left, right + 1, `${_r})`);\\n  }\\n  \\n  gen(0, 0, \\'\\');\\n  \\n  return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar generateParenthesis = function(n) {\\n  const r = [];\\n  const gen = (left, right, _r) => {\\n    if (left === n && right === n) {\\n      r.push(_r);\\n      return;\\n    }\\n    if (left < n) gen(left + 1, right, `${_r}(`);\\n    if (left > right && right < n) gen(left, right + 1, `${_r})`);\\n  }\\n  \\n  gen(0, 0, \\'\\');\\n  \\n  return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203137,
                "title": "ruby-backtracking-with-example-and-diagram",
                "content": "```ruby\\n# @param {Integer} n\\n# @return {String[]}\\ndef generate_parenthesis(n)\\n    backtrack(n)\\nend\\n\\ndef backtrack(n, s = \"\", l = 0, r = 0, result = [])\\n    if s.size == 2 * n\\n        result.push(s)\\n        return\\n    end\\n\\n    backtrack(n, s + \"(\", l + 1, r, result) if l < n\\n    backtrack(n, s + \")\", l, r + 1, result) if r < l\\n\\n    result\\nend\\n\\n\\n# 22. Generate Parentheses\\n# https://leetcode.com/problems/generate-parentheses/description/\\n\\n# Complexity Analysis\\n# Our complexity analysis rests on understanding how many elements there are in generateParenthesis(n).\\n# This analysis is outside the scope of this article,\\n# but it turns out this is the n-th Catalan number 1/ (n + 1) * (2nCn), which is bounded asymptotically by 4^n / n * sqrt(n).\\n\\n# Time: O(4^n/sqrt(n), Each valid sequence has at most n steps during the backtracking procedure.\\n# Space: O(4^n/sqrt(n), as described above, and using O(n) space to store the sequence.\\n\\n# *** Example: n = 3 *** Space after each DFS instance\\n# backtrack called with  0 0 []\\n#   backtrack called with ( 1 0 []\\n#     backtrack called with (( 2 0 []\\n#       backtrack called with ((( 3 0 []\\n#         backtrack called with ((() 3 1 []\\n#           backtrack called with ((()) 3 2 []\\n#             backtrack called with ((())) 3 3 []\\n#           backtrack return with ((()) 3 2 [\"((()))\"]\\n#         backtrack return with ((() 3 1 [\"((()))\"]\\n#       backtrack return with ((( 3 0 [\"((()))\"]\\n#       backtrack called with (() 2 1 [\"((()))\"]\\n#         backtrack called with (()( 3 1 [\"((()))\"]\\n#           backtrack called with (()() 3 2 [\"((()))\"]\\n#             backtrack called with (()()) 3 3 [\"((()))\"]\\n#           backtrack return with (()() 3 2 [\"((()))\", \"(()())\"]\\n#         backtrack return with (()( 3 1 [\"((()))\", \"(()())\"]\\n#         backtrack called with (()) 2 2 [\"((()))\", \"(()())\"]\\n#           backtrack called with (())( 3 2 [\"((()))\", \"(()())\"]\\n#             backtrack called with (())() 3 3 [\"((()))\", \"(()())\"]\\n#           backtrack return with (())( 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack return with (()) 2 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack return with (() 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack return with (( 2 0 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack called with () 1 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack called with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack called with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack called with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#             backtrack called with ()(()) 3 3 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack return with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack return with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack called with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack called with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#             backtrack called with ()()() 3 3 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack return with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#         backtrack return with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#       backtrack return with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#     backtrack return with () 1 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#   backtrack return with ( 1 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n# backtrack return with  0 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n\\n# Refer to the attached diagram for recursion,\\n# The numbers next to each node are the counts of left and right parantheses\\n\\n```\\n![image](https://assets.leetcode.com/users/vkommi2/image_1544322836.png)\\n",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer} n\\n# @return {String[]}\\ndef generate_parenthesis(n)\\n    backtrack(n)\\nend\\n\\ndef backtrack(n, s = \"\", l = 0, r = 0, result = [])\\n    if s.size == 2 * n\\n        result.push(s)\\n        return\\n    end\\n\\n    backtrack(n, s + \"(\", l + 1, r, result) if l < n\\n    backtrack(n, s + \")\", l, r + 1, result) if r < l\\n\\n    result\\nend\\n\\n\\n# 22. Generate Parentheses\\n# https://leetcode.com/problems/generate-parentheses/description/\\n\\n# Complexity Analysis\\n# Our complexity analysis rests on understanding how many elements there are in generateParenthesis(n).\\n# This analysis is outside the scope of this article,\\n# but it turns out this is the n-th Catalan number 1/ (n + 1) * (2nCn), which is bounded asymptotically by 4^n / n * sqrt(n).\\n\\n# Time: O(4^n/sqrt(n), Each valid sequence has at most n steps during the backtracking procedure.\\n# Space: O(4^n/sqrt(n), as described above, and using O(n) space to store the sequence.\\n\\n# *** Example: n = 3 *** Space after each DFS instance\\n# backtrack called with  0 0 []\\n#   backtrack called with ( 1 0 []\\n#     backtrack called with (( 2 0 []\\n#       backtrack called with ((( 3 0 []\\n#         backtrack called with ((() 3 1 []\\n#           backtrack called with ((()) 3 2 []\\n#             backtrack called with ((())) 3 3 []\\n#           backtrack return with ((()) 3 2 [\"((()))\"]\\n#         backtrack return with ((() 3 1 [\"((()))\"]\\n#       backtrack return with ((( 3 0 [\"((()))\"]\\n#       backtrack called with (() 2 1 [\"((()))\"]\\n#         backtrack called with (()( 3 1 [\"((()))\"]\\n#           backtrack called with (()() 3 2 [\"((()))\"]\\n#             backtrack called with (()()) 3 3 [\"((()))\"]\\n#           backtrack return with (()() 3 2 [\"((()))\", \"(()())\"]\\n#         backtrack return with (()( 3 1 [\"((()))\", \"(()())\"]\\n#         backtrack called with (()) 2 2 [\"((()))\", \"(()())\"]\\n#           backtrack called with (())( 3 2 [\"((()))\", \"(()())\"]\\n#             backtrack called with (())() 3 3 [\"((()))\", \"(()())\"]\\n#           backtrack return with (())( 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack return with (()) 2 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack return with (() 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack return with (( 2 0 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack called with () 1 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack called with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack called with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack called with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#             backtrack called with ()(()) 3 3 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack return with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack return with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack called with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack called with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#             backtrack called with ()()() 3 3 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack return with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#         backtrack return with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#       backtrack return with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#     backtrack return with () 1 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#   backtrack return with ( 1 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n# backtrack return with  0 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n\\n# Refer to the attached diagram for recursion,\\n# The numbers next to each node are the counts of left and right parantheses\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 10173,
                "title": "my-0ms-c-solution-without-recursion-and-dfs",
                "content": "    class Solution {\\n        //\\u8fd9\\u4e00\\u7248\\u4e0d\\u4f7f\\u7528\\u9012\\u5f52\\uff0c\\u901f\\u5ea6\\u66f4\\u5feb\\u3002\\n        //\\u9996\\u5148\\u662f\\u6700\\u539a\\u7684\\u62ec\\u53f7\\u5305\\u88f9\\u72b6\\u6001\\uff0c\\u5373\\u4e00\\u5f00\\u59cb\\u5de6\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u5de6\\u62ec\\u53f7\\uff0c\\u53f3\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u53f3\\u62ec\\u53f7\\uff0c\\u7136\\u540e\\u6267\\u884c\\u4ee5\\u4e0b\\u903b\\u8f91\\uff1a\\n        //1\\u3001\\u53f3\\u62ec\\u53f7\\u4e0d\\u80fd\\u6bd4\\u5de6\\u62ec\\u53f7\\u591a\\uff1b\\n        //2\\u3001\\u5f39\\u51fa\\u53f3\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u9047\\u5230\\u7b2c\\u4e00\\u4e2a\\u5de6\\u62ec\\u53f7\\uff0c\\u5982\\u679c\\u5de6\\u62ec\\u53f7\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\u4ecd\\u7136\\u5408\\u6cd5\\uff0c\\u5219\\u628a\\u5b83\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\uff1b\\u5426\\u5219\\uff0c\\u5de6\\u62ec\\u53f7\\u7ee7\\u7eed\\u5f39\\u51fa\\uff1b\\n        //3\\u3001\\u6539\\u5b8c\\u4e4b\\u540e\\u4e00\\u4e2a\\u52b2\\u52a0\\u5de6\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u6240\\u6709\\u53ef\\u4ee5\\u7528\\u7684\\u5de6\\u62ec\\u53f7\\u90fd\\u52a0\\u5b8c\\u4e3a\\u6b62\\u3002\\n        //4\\u3001\\u5faa\\u73af\\u4e00\\u76f4\\u6267\\u884c\\u5230\\u4e00\\u5f00\\u59cb\\u7684\\u8fde\\u7eed\\u5de6\\u62ec\\u53f7\\u6ca1\\u6709\\u4e3a\\u6b62\\u3002\\n        //\\u8be5\\u7a0b\\u5e8f\\u662f\\u4e0a\\u4e00\\u7248\\u9012\\u5f52\\u7a0b\\u5e8f\\u7684\\u7b49\\u4ef7\\u7248\\u3002\\n    public:\\n        vector<string> generateParenthesis(int n) \\n        {\\n            vector<string> result;\\n            if(n==0)\\n                return result;\\n            string s;\\n            for(int i=0;i<n;i++)\\n                s+=\"(\";\\n            for(int i=0;i<n;i++)\\n                s+=\")\";\\n            int left=n;\\n            int right=n;\\n            do\\n            {\\n                result.push_back(s);\\n                while(s!=\"\"&&(s.back()==')'||left-1<right+1))\\n                {\\n                    if(s.back()==')')\\n                        right--;\\n                    else\\n                        left--;\\n                    s.pop_back();\\n                }\\n                if(s!=\"\")\\n                {\\n                    s.back()=')';\\n                    left--;\\n                    right++;\\n                    while(left<n)\\n                    {\\n                        s+=\"(\";\\n                        left++;\\n                    }\\n                    while(right<n)\\n                    {\\n                        s+=\")\";\\n                        right++;\\n                    }\\n                }\\n            }while(s!=\"\");\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        //\\u8fd9\\u4e00\\u7248\\u4e0d\\u4f7f\\u7528\\u9012\\u5f52\\uff0c\\u901f\\u5ea6\\u66f4\\u5feb\\u3002\\n        //\\u9996\\u5148\\u662f\\u6700\\u539a\\u7684\\u62ec\\u53f7\\u5305\\u88f9\\u72b6\\u6001\\uff0c\\u5373\\u4e00\\u5f00\\u59cb\\u5de6\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u5de6\\u62ec\\u53f7\\uff0c\\u53f3\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u53f3\\u62ec\\u53f7\\uff0c\\u7136\\u540e\\u6267\\u884c\\u4ee5\\u4e0b\\u903b\\u8f91\\uff1a\\n        //1\\u3001\\u53f3\\u62ec\\u53f7\\u4e0d\\u80fd\\u6bd4\\u5de6\\u62ec\\u53f7\\u591a\\uff1b\\n        //2\\u3001\\u5f39\\u51fa\\u53f3\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u9047\\u5230\\u7b2c\\u4e00\\u4e2a\\u5de6\\u62ec\\u53f7\\uff0c\\u5982\\u679c\\u5de6\\u62ec\\u53f7\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\u4ecd\\u7136\\u5408\\u6cd5\\uff0c\\u5219\\u628a\\u5b83\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\uff1b\\u5426\\u5219\\uff0c\\u5de6\\u62ec\\u53f7\\u7ee7\\u7eed\\u5f39\\u51fa\\uff1b\\n        //3\\u3001\\u6539\\u5b8c\\u4e4b\\u540e\\u4e00\\u4e2a\\u52b2\\u52a0\\u5de6\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u6240\\u6709\\u53ef\\u4ee5\\u7528\\u7684\\u5de6\\u62ec\\u53f7\\u90fd\\u52a0\\u5b8c\\u4e3a\\u6b62\\u3002\\n        //4\\u3001\\u5faa\\u73af\\u4e00\\u76f4\\u6267\\u884c\\u5230\\u4e00\\u5f00\\u59cb\\u7684\\u8fde\\u7eed\\u5de6\\u62ec\\u53f7\\u6ca1\\u6709\\u4e3a\\u6b62\\u3002\\n        //\\u8be5\\u7a0b\\u5e8f\\u662f\\u4e0a\\u4e00\\u7248\\u9012\\u5f52\\u7a0b\\u5e8f\\u7684\\u7b49\\u4ef7\\u7248\\u3002\\n    public:\\n        vector<string> generateParenthesis(int n) \\n        {\\n            vector<string> result;\\n            if(n==0)\\n                return result;\\n            string s;\\n            for(int i=0;i<n;i++)\\n                s+=\"(\";\\n            for(int i=0;i<n;i++)\\n                s+=\")\";\\n            int left=n;\\n            int right=n;\\n            do\\n            {\\n                result.push_back(s);\\n                while(s!=\"\"&&(s.back()==')'||left-1<right+1))\\n                {\\n                    if(s.back()==')')\\n                        right--;\\n                    else\\n                        left--;\\n                    s.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 10349,
                "title": "my-java-code-using-dp",
                "content": "The idea is clear. Use cache to store the already calculated results, from f(0) to f(n). For each f(i), get f(j) and f(i - j - 1) from cache, 0 <= j < = j-1.\\n\\n    public static List<String> generateParenthesis(int n) {\\n        List<List<String>> cache = new LinkedList<>();\\n        cache.add(Arrays.asList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> nList = new LinkedList<>();\\n            for (int j = 0; j < i; j++) {\\n                List<String> inside = cache.get(j);\\n                List<String> tail = cache.get(i - j - 1);\\n                for (int k = 0; k < inside.size(); k++) {\\n                    for (int l = 0; l < tail.size(); l++) {\\n                        nList.add(\"(\" + inside.get(k) + \")\" + tail.get(l));\\n                    }\\n                }\\n            }\\n            cache.add(nList);\\n        }\\n        return cache.get(n);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is clear. Use cache to store the already calculated results, from f(0) to f(n). For each f(i), get f(j) and f(i - j - 1) from cache, 0 <= j < = j-1.\\n\\n    public static List<String> generateParenthesis(int n) {\\n        List<List<String>> cache = new LinkedList<>();\\n        cache.add(Arrays.asList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> nList = new LinkedList<>();\\n            for (int j = 0; j < i; j++) {\\n                List<String> inside = cache.get(j);\\n                List<String> tail = cache.get(i - j - 1);\\n                for (int k = 0; k < inside.size(); k++) {\\n                    for (int l = 0; l < tail.size(); l++) {\\n                        nList.add(\"(\" + inside.get(k) + \")\" + tail.get(l));\\n                    }\\n                }\\n            }\\n            cache.add(nList);\\n        }\\n        return cache.get(n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10423,
                "title": "java-recursive-simple-with-8-lines",
                "content": "    List<String> list = new ArrayList<String>();\\n    \\tpublic List<String> generateParenthesis(int n) {\\n        \\tloop(\"(\",n-1,1);\\n        \\treturn list;\\n        }\\n        private void loop(String s, int n, int o){\\n        \\tif (n==0 && o==0) list.add(s);\\n        \\tif (n>0) loop(s+\"(\", n-1, o+1);\\n        \\tif (o>0) loop(s+\")\", n, o-1);\\n        }",
                "solutionTags": [],
                "code": "    List<String> list = new ArrayList<String>();\\n    \\tpublic List<String> generateParenthesis(int n) {\\n        \\tloop(\"(\",n-1,1);\\n        \\treturn list;\\n        }\\n        private void loop(String s, int n, int o){\\n        \\tif (n==0 && o==0) list.add(s);\\n        \\tif (n>0) loop(s+\"(\", n-1, o+1);\\n        \\tif (o>0) loop(s+\")\", n, o-1);\\n        }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564779,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574327,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1566162,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1565657,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574405,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568042,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1980901,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568840,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568013,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1575229,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1564779,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574327,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1566162,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1565657,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574405,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568042,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1980901,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568840,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568013,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1575229,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1571058,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1569242,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1928921,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1826653,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1573015,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1571057,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1576172,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 2053376,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 2037019,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1983146,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1963949,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1901261,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1861473,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1763055,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1572241,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1832940,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1573326,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2072646,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2049319,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2034589,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2030949,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 2026050,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 2013656,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1991502,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1967225,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1928158,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1891528,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1872258,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1870152,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1852609,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1844051,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1817918,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1814298,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1803751,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1803743,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1793042,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1777093,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1767681,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1764232,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1754546,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1742960,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1741168,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1710452,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1710412,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1709243,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1694707,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1690739,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1671277,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1670975,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1653635,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Best Time to Buy and Sell Stock II",
        "question_content": "<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p>\n\n<p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,1,5,3,6,4]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 208241,
                "title": "explanation-for-the-dummy-like-me",
                "content": "The profit is the sum of sub-profits. Each sub-profit is the difference between selling at day ```j```, and buying at day ```i``` (with ```j > i```). The range ```[i, j]``` should be chosen so that the sub-profit is **maximum**:\\n\\n```sub-profit = prices[j] - prices[i]```\\n\\nWe should choose ```j``` that ```prices[j]``` is as **big** as possible, and choose ```i``` that ```prices[i]``` is as **small** as possible (of course in their local range).\\n\\nLet\\'s say, we have a range ```[3, 2, 5]```, we will choose ```(2,5)``` instead of ```(3,5)```, because ```2<3```.\\nNow, if we add ```8``` into this range: ```[3, 2, 5, 8]```, we will choose ```(2, 8)``` instead of ```(2,5)``` because ```8>5```.\\n\\nFrom this observation, from day ```X```, the buying day will be the last **continuous** day that the price is smallest. Then, the selling day will be the last **continuous** day that the price is biggest.\\n\\nTake another range ```[3, 2, 5, 8, 1, 9]```, though ```1``` is the smallest, but ```2``` is chosen, because ```2``` is the smallest in a consecutive decreasing prices starting from ```3```.\\nSimilarly, ```9``` is the biggest, but ```8``` is chosen, because ```8``` is the biggest in a consecutive increasing prices starting from ```2``` (the buying price). \\nActually, the range ```[3, 2, 5, 8, 1, 9]``` will be splitted into 2 sub-ranges ```[3, 2, 5, 8]``` and ```[1, 9]```.\\n\\nWe come up with the following code:\\n```\\npublic int maxProfit(int[] prices) {\\n        int i = 0, buy, sell, profit = 0, N = prices.length - 1;\\n        while (i < N) {\\n            while (i < N && prices[i + 1] <= prices[i]) i++;\\n            buy = prices[i];\\n\\n            while (i < N && prices[i + 1] > prices[i]) i++;\\n            sell = prices[i];\\n\\n            profit += sell - buy;\\n        }\\n        return profit;\\n}\\n```\\n\\nThe time complexity is ```O(N)```, space complexity is ```O(5)```\\n\\n### **BONUS**: \\nWith this approach, we still can calculate on which buying days and selling days, we reach the max profit:\\n\\n```\\npublic Pair<List<Pair<Integer, Integer>>, Integer> buysAndSells(int[] prices) {\\n        int i = 0, iBuy, iSell, profit = 0, N = prices.length - 1;\\n        List<Pair<Integer, Integer>> buysAndSells = new ArrayList<Pair<Integer, Integer>>();\\n        while (i < N) {\\n            while (i < N && prices[i + 1] <= prices[i]) i++;\\n            iBuy = i;\\n\\n            while (i < N && prices[i + 1] > prices[i]) i++;\\n            iSell = i;\\n\\n            profit += prices[iSell] - prices[iBuy];\\n            Pair<Integer, Integer> bs = new Pair<Integer, Integer>(iBuy, iSell);\\n            buysAndSells.add(bs);\\n        }\\n        return new Pair<List<Pair<Integer, Integer>>, Integer>(buysAndSells, profit);\\n}\\n\\t\\npublic class Pair<T1, T2> {\\n    public T1 fst;\\n    public T2 snd;\\n    public Pair(T1 f, T2 s) {\\n        fst = f;\\n        snd = s;\\n    }\\n}\\n```\\n\\nP.S: After a long time, this problem came back to me again, and I forgot what I solved :) . I came up with [different approach](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/564729/Java-Simple-Code-DP)",
                "solutionTags": [],
                "code": "```j```\n```i```\n```j > i```\n```[i, j]```\n```sub-profit = prices[j] - prices[i]```\n```j```\n```prices[j]```\n```i```\n```prices[i]```\n```[3, 2, 5]```\n```(2,5)```\n```(3,5)```\n```2<3```\n```8```\n```[3, 2, 5, 8]```\n```(2, 8)```\n```(2,5)```\n```8>5```\n```X```\n```[3, 2, 5, 8, 1, 9]```\n```1```\n```2```\n```2```\n```3```\n```9```\n```8```\n```8```\n```2```\n```[3, 2, 5, 8, 1, 9]```\n```[3, 2, 5, 8]```\n```[1, 9]```\n```\\npublic int maxProfit(int[] prices) {\\n        int i = 0, buy, sell, profit = 0, N = prices.length - 1;\\n        while (i < N) {\\n            while (i < N && prices[i + 1] <= prices[i]) i++;\\n            buy = prices[i];\\n\\n            while (i < N && prices[i + 1] > prices[i]) i++;\\n            sell = prices[i];\\n\\n            profit += sell - buy;\\n        }\\n        return profit;\\n}\\n```\n```O(N)```\n```O(5)```\n```\\npublic Pair<List<Pair<Integer, Integer>>, Integer> buysAndSells(int[] prices) {\\n        int i = 0, iBuy, iSell, profit = 0, N = prices.length - 1;\\n        List<Pair<Integer, Integer>> buysAndSells = new ArrayList<Pair<Integer, Integer>>();\\n        while (i < N) {\\n            while (i < N && prices[i + 1] <= prices[i]) i++;\\n            iBuy = i;\\n\\n            while (i < N && prices[i + 1] > prices[i]) i++;\\n            iSell = i;\\n\\n            profit += prices[iSell] - prices[iBuy];\\n            Pair<Integer, Integer> bs = new Pair<Integer, Integer>(iBuy, iSell);\\n            buysAndSells.add(bs);\\n        }\\n        return new Pair<List<Pair<Integer, Integer>>, Integer>(buysAndSells, profit);\\n}\\n\\t\\npublic class Pair<T1, T2> {\\n    public T1 fst;\\n    public T2 snd;\\n    public Pair(T1 f, T2 s) {\\n        fst = f;\\n        snd = s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803206,
                "title": "python-js-java-go-c-o-n-by-dp-greedy-visualization",
                "content": "Method_#1\\nO(n) sol by DP + state machine\\n\\nDefine \"**Hold**\" as the state of **holding stock**. (\\u6301\\u6709\\u80A1\\u7968)\\nDefine \"**NotHold**\" as the state of **keep cash**. (\\u6301\\u6709\\u73FE\\u91D1)\\n\\nGeneral rule aka recursive relationship.\\n\\n```\\nDP[Hold] \\n= max(keep holding stock, or just buy stock & hold today)\\n= max( DP[Previous Hold], DP[previous NotHold] - stock price)\\n```\\n---\\n\\n```\\nDP[NotHold] \\n= max(keep cash, or just sell out stock today)\\n= max( DP[Previous NotHold], DP[previous Hold] + stock price)\\n```\\n\\n---\\n\\n**State machine diagram**:\\n\\n<img src=\"https://assets.leetcode.com/users/images/62d26ff8-bba1-497c-b429-702e002a05d1_1684081274.8362317.png\" width=\"1000\" height=\"600\">\\n\\n---\\n\\n**Implementation** by botoom-up DP + iteration:\\n<iframe src=\"https://leetcode.com/playground/J7fnkkAb/shared\" frameBorder=\"0\" width=\"1000\" height=\"600\"></iframe>\\n\\nTime Complexity: O(n), for single level for loop\\nSpace Complexity: O(1), for fixed size of temporary variables\\n\\n---\\n\\n**Implementation** with Top down DP + recursion \\n<iframe src=\"https://leetcode.com/playground/2zaLvs2H/shared\" frameBorder=\"0\" width=\"1000\" height=\"600\"></iframe>\\n\\nTime Complexity: O(n), for single level for loop\\nSpace Complexity: O(n), for 1D DP recursion call depth\\n\\n---\\n\\nMethod_#2\\nO(n) sol by Greedy\\n\\nShare another O(n) solution by price gain collection with **greedy** value taking concept.\\n\\nMax profit with [long position](https://en.wikipedia.org/wiki/Long_(finance)) ,\\'\\u505A\\u591A\\' in chinese, is met by **collecting all price gain** in the stock price sequence.\\n\\nTake care that holding **multiple position at the same time is NOT allowed** by [description](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/).\\n\\n---\\n\\n**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1586173126.png)\\n\\n---\\n\\n**Implementation** based on container and summation function:\\n\\n\\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\n        price_gain = []\\n        \\n        for idx in range( len(prices)-1 ):\\n            \\n            if prices[idx] < prices[idx+1]:\\n                \\n                price_gain.append( prices[idx+1]- prices[idx])\\n                \\n        return sum( price_gain )\\n```\\n```Java []\\nclass Solution {\\n    \\n    \\n    public int maxProfit(int[] prices) {\\n\\n        ArrayList<Integer> priceGain = new ArrayList<Integer>();\\n        \\n        for(int idx = 0 ; idx < prices.length-1; idx++){\\n            \\n            if( prices[idx] < prices[idx+1] ){\\n                priceGain.add( prices[idx+1]- prices[idx]);\\n            }\\n                \\n        }\\n        return priceGain.stream().mapToInt(n->n).sum();\\n        \\n    }\\n}\\n```\\n```Javascript []\\nconst accumulate = ( (prev, cur) => (prev + cur) );\\n\\nvar maxProfit = function(prices) {\\n    \\n    let profit = new Array();\\n    \\n    for( let i = 0 ; i < prices.length-1 ; i++ ){\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit.push(  prices[i+1] - prices[i] );\\n        }\\n    }\\n    return profit.reduce(accumulate, 0);\\n}\\n```\\n```Go []\\nfunc Accumulate(elements ...int) int {  \\n     sum := 0  \\n     for _, elem := range elements {  \\n          sum += elem  \\n     }  \\n     return sum  \\n} \\n\\n\\nfunc maxProfit(prices []int) int {\\n    \\n    profit := make([]int, 0)\\n    \\n    for i := 0 ; i < len(prices)-1 ; i++{\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit = append(profit, ( prices[i+1] - prices[i] ))\\n        }\\n    }\\n\\n    return Accumulate(profit...)\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        vector<int> profit;\\n        \\n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profit.push_back( prices[i+1] - prices[i] );\\n            }\\n            \\n        }\\n        return accumulate( profit.begin(), profit.end(), 0);\\n    }\\n};\\n```\\n\\nTime Complexity: O(n), for single level for loop\\nSpace Complexity: O(n), for array storage sapce\\n\\n\\n---\\n\\n**Implementation** based on generator expression and sum( ... ):\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\n        return sum( ( prices[idx+1]-prices[idx] ) for idx in range(len(prices)-1) if prices[idx] < prices[idx+1] )\\n```\\n\\n---\\n\\n**Implementation** based on O(1) aux space:\\n\\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        profit_from_price_gain = 0\\n        for idx in range( len(prices)-1 ):\\n            \\n            if prices[idx] < prices[idx+1]:\\n                profit_from_price_gain += ( prices[idx+1] - prices[idx])\\n                \\n        return profit_from_price_gain\\n```\\n```Javascript []\\nvar maxProfit = function(prices) {\\n    \\n    let profitFromPriceGain = 0;\\n    \\n    for( let i = 0 ; i < prices.length-1 ; i++ ){\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profitFromPriceGain += (  prices[i+1] - prices[i] );\\n        }\\n    }\\n    \\n    return profitFromPriceGain;\\n}\\n```\\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {      \\n        int profitFromPriceGain = 0;\\n        \\n        for( int i = 0 ; i < prices.length-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profitFromPriceGain += ( prices[i+1] - prices[i] );\\n            }\\n        }\\n        \\n        return profitFromPriceGain;\\n    }\\n}\\n```\\n```Go []\\nfunc maxProfit(prices []int) int {\\n    \\n    profitFromPriceGain := 0\\n    \\n    for i := 0 ; i < len(prices)-1 ; i++{\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profitFromPriceGain += ( prices[i+1] - prices[i] )\\n        }\\n    }\\n\\n    return profitFromPriceGain\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int profitFromPriceGain = 0;\\n        \\n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profitFromPriceGain += ( prices[i+1] - prices[i] );\\n            }\\n            \\n        }\\n        return profitFromPriceGain;\\n    }\\n};\\n```\\n\\nTime Complexity: O(n), for single level for loop\\nSpace Complexity: O(1), for fixed size of temporary variables\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #309 Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)\\n\\n[Leetcode #714 Best Time to Buy and Sell Stock with Transaction Fee  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) \\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about generator expression](https://www.python.org/dev/peps/pep-0289/)\\n\\n[2] [Python official docs about sum( ... )](https://docs.python.org/3/library/functions.html#sum)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nDP[Hold] \\n= max(keep holding stock, or just buy stock & hold today)\\n= max( DP[Previous Hold], DP[previous NotHold] - stock price)\\n```\n```\\nDP[NotHold] \\n= max(keep cash, or just sell out stock today)\\n= max( DP[Previous NotHold], DP[previous Hold] + stock price)\\n```\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\n        price_gain = []\\n        \\n        for idx in range( len(prices)-1 ):\\n            \\n            if prices[idx] < prices[idx+1]:\\n                \\n                price_gain.append( prices[idx+1]- prices[idx])\\n                \\n        return sum( price_gain )\\n```\n```Java []\\nclass Solution {\\n    \\n    \\n    public int maxProfit(int[] prices) {\\n\\n        ArrayList<Integer> priceGain = new ArrayList<Integer>();\\n        \\n        for(int idx = 0 ; idx < prices.length-1; idx++){\\n            \\n            if( prices[idx] < prices[idx+1] ){\\n                priceGain.add( prices[idx+1]- prices[idx]);\\n            }\\n                \\n        }\\n        return priceGain.stream().mapToInt(n->n).sum();\\n        \\n    }\\n}\\n```\n```Javascript []\\nconst accumulate = ( (prev, cur) => (prev + cur) );\\n\\nvar maxProfit = function(prices) {\\n    \\n    let profit = new Array();\\n    \\n    for( let i = 0 ; i < prices.length-1 ; i++ ){\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit.push(  prices[i+1] - prices[i] );\\n        }\\n    }\\n    return profit.reduce(accumulate, 0);\\n}\\n```\n```Go []\\nfunc Accumulate(elements ...int) int {  \\n     sum := 0  \\n     for _, elem := range elements {  \\n          sum += elem  \\n     }  \\n     return sum  \\n} \\n\\n\\nfunc maxProfit(prices []int) int {\\n    \\n    profit := make([]int, 0)\\n    \\n    for i := 0 ; i < len(prices)-1 ; i++{\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit = append(profit, ( prices[i+1] - prices[i] ))\\n        }\\n    }\\n\\n    return Accumulate(profit...)\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        vector<int> profit;\\n        \\n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profit.push_back( prices[i+1] - prices[i] );\\n            }\\n            \\n        }\\n        return accumulate( profit.begin(), profit.end(), 0);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\n        return sum( ( prices[idx+1]-prices[idx] ) for idx in range(len(prices)-1) if prices[idx] < prices[idx+1] )\\n```\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        profit_from_price_gain = 0\\n        for idx in range( len(prices)-1 ):\\n            \\n            if prices[idx] < prices[idx+1]:\\n                profit_from_price_gain += ( prices[idx+1] - prices[idx])\\n                \\n        return profit_from_price_gain\\n```\n```Javascript []\\nvar maxProfit = function(prices) {\\n    \\n    let profitFromPriceGain = 0;\\n    \\n    for( let i = 0 ; i < prices.length-1 ; i++ ){\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profitFromPriceGain += (  prices[i+1] - prices[i] );\\n        }\\n    }\\n    \\n    return profitFromPriceGain;\\n}\\n```\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {      \\n        int profitFromPriceGain = 0;\\n        \\n        for( int i = 0 ; i < prices.length-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profitFromPriceGain += ( prices[i+1] - prices[i] );\\n            }\\n        }\\n        \\n        return profitFromPriceGain;\\n    }\\n}\\n```\n```Go []\\nfunc maxProfit(prices []int) int {\\n    \\n    profitFromPriceGain := 0\\n    \\n    for i := 0 ; i < len(prices)-1 ; i++{\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profitFromPriceGain += ( prices[i+1] - prices[i] )\\n        }\\n    }\\n\\n    return profitFromPriceGain\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int profitFromPriceGain = 0;\\n        \\n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profitFromPriceGain += ( prices[i+1] - prices[i] );\\n            }\\n            \\n        }\\n        return profitFromPriceGain;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39420,
                "title": "three-lines-in-c-with-explanation",
                "content": "  First we post the code here.\\n\\n    int maxProfit(vector<int> &prices) {\\n        int ret = 0;\\n        for (size_t p = 1; p < prices.size(); ++p) \\n          ret += max(prices[p] - prices[p - 1], 0);    \\n        return ret;\\n    }\\n\\nSecond, suppose the first sequence is \"a <= b <= c <= d\", the profit is \"d - a = (b - a) + (c - b) + (d - c)\" without a doubt.  And suppose another one is \"a <= b >= b' <= c <= d\", the profit is not difficult to be figured out as \"(b - a) + (d - b')\". So you just target at monotone sequences.",
                "solutionTags": [],
                "code": "  First we post the code here.\\n\\n    int maxProfit(vector<int> &prices) {\\n        int ret = 0;\\n        for (size_t p = 1; p < prices.size(); ++p) \\n          ret += max(prices[p] - prices[p - 1], 0);    \\n        return ret;\\n    }\\n\\nSecond, suppose the first sequence is \"a <= b <= c <= d\", the profit is \"d - a = (b - a) + (c - b) + (d - c)\" without a doubt.  And suppose another one is \"a <= b >= b' <= c <= d\", the profit is not difficult to be figured out as \"(b - a) + (d - b')\". So you just target at monotone sequences.",
                "codeTag": "Unknown"
            },
            {
                "id": 1569081,
                "title": "java-simple-clean-dp-solutions-for-all-6-buy-sell-stock-questions-on-leetcode",
                "content": "*<ins>Note:</ins> Kindly upvote if you find this article helpful. Thanks for reading!*\\n\\n**\\u2714\\uFE0F Solution & Explanation for - [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)**\\n\\nThere are multiple ways to solve this question, but the most optimal one is this one-pass solution.\\n\\nIn this solution, we are trying to buy the stock if the previous day\\'s price is lower than the current price. We will buy the stock at the previous price and sell it today to make a profit. If we repeat this for all such days (where the current price is higher than the previous day\\'s price), we can add all the profits to get the total profit.\\n\\n**For example:**\\nIf Input is `prices = [7,1,5,3,6,4]`\\nLet us assume the day is represented by the array indexes.\\nThen on `day 2`, the `current price is 5` and on the `previous day (day 1)` the `price is 1`. This matches our criteria. `Profit will be 5-1 = 4`.\\nThen on `day 4`, the `current price is 6` and on the `previous day (day 3)` the `price is 3`. This matches our criteria. `Profit will be 6-3 = 3`.\\nNo other pair of consecuitive days match the our crtiteria `prices[i - 1] < prices[i]`\\n`Total Profit = 4 + 3 = 7`.\\n\\n**Time Complexity:** `O(N)` --> `N` is length of the input price array\\n**Space Complexity:** `O(1)` --> Constant Space\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\t\\t// We need prices for 2 days at least to find the profit.\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int totalProfit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            // Checking if we can profit with previous day\\'s price.\\n            // If yes, then we buy on previous day and sell on current day.\\n            // Add all such profits to get the total profit.\\n            if (prices[i - 1] < prices[i]) {\\n                totalProfit += prices[i] - prices[i - 1];\\n            }\\n        }\\n\\n        return totalProfit;\\n    }\\n}\\n```\\n\\n---\\n\\n**<ins>Solutions to other Buy and Sell Stock questions on Leetcode:</ins>**\\n\\n**\\u2714\\uFE0F Solution for - [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)**\\n\\n**Time Complexity:** `O(N)` --> `N` is length of the input price array\\n**Space Complexity:** `O(1)` --> Constant Space\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int maxProfitHere = 0;\\n        int maxProfitSoFar = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            maxProfitHere = Math.max(0, maxProfitHere + prices[i] - prices[i - 1]);\\n            maxProfitSoFar = Math.max(maxProfitSoFar, maxProfitHere);\\n        }\\n\\n        return maxProfitSoFar;\\n    }\\n}\\n```\\n\\n---\\n\\n**\\u2714\\uFE0F Solution for - [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)**\\n\\n**Time Complexity:** `O(N)` --> `N` is length of the input price array\\n**Space Complexity:** `O(1)` --> Constant Space\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int buy1 = -prices[0];\\n        int sell1 = buy1 + prices[0];\\n        int buy2 = sell1 - prices[0];\\n        int sell2 = buy2 + prices[0];\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            // The maximum money left after buying 1st stock.\\n            buy1 = Math.max(buy1, -prices[i]);\\n\\n            // The maximum money left after selling 1st stock.\\n            sell1 = Math.max(sell1, buy1 + prices[i]);\\n\\n            // The maximum money left after buying 2nd stock.\\n            buy2 = Math.max(buy2, sell1 - prices[i]);\\n\\n            // The maximum money left after selling 2nd stock.\\n            sell2 = Math.max(sell2, buy2 + prices[i]);\\n        }\\n\\n        return Math.max(sell1, sell2);\\n    }\\n}\\n```\\n\\n---\\n\\n**\\u2714\\uFE0F Solution for - [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)**\\n\\n**Time Complexity:** `O(N * k)`\\n**Space Complexity:** `O(N)` --> Space required for `dp1` and `dp2` arrays.\\nWhere: \\n--> `N` is length of the input price array. \\n--> `k` is the input number representing maximum number of transactions.\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if (prices == null || prices.length <= 1 || k <= 0) {\\n            return 0;\\n        }\\n        if (k >= prices.length / 2) {\\n            return quickSolve(prices);\\n        }\\n\\n        int len = prices.length;\\n        int[] dp1 = new int[len];\\n        int[] dp2 = new int[len];\\n        for (int i = 0; i < k; i++) {\\n            int tempMax = -prices[0];\\n            for (int j = 1; j < len; j++) {\\n                dp2[j] = Math.max(dp2[j - 1], prices[j] + tempMax);\\n                tempMax = Math.max(tempMax, dp1[j] - prices[j]);\\n            }\\n            dp1 = Arrays.copyOf(dp2, len);\\n        }\\n\\n        return dp2[len - 1];\\n    }\\n\\n    private int quickSolve(int[] prices) {\\n        int totalProfit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i - 1] < prices[i]) {\\n                totalProfit += prices[i] - prices[i - 1];\\n            }\\n        }\\n        return totalProfit;\\n    }\\n}\\n```\\n\\n---\\n\\n**\\u2714\\uFE0F Solution for - [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)**\\n\\n**Time Complexity:** `O(N)` --> `N` is length of the input price array\\n**Space Complexity:** `O(1)` --> Constant Space\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int buy = -prices[0];\\n        int sell = 0;\\n        int prevSell = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            // buy[i] = Math.max(sell[i-2]-prices[i], buy[i-1])\\n            // sell[i-2]-prices[i] -> Buy after a 1 day cooldown\\n            // buy[i-1] -> cooldown\\n            buy = Math.max(prevSell - prices[i], buy);\\n\\n            // sell[i-1];\\n            prevSell = sell;\\n\\n            // sell[i] = Math.max(buy[i]+prices, sell[i-1])\\n            // buy[i]+prices -> sell the stock.\\n            // sell[i-1] -> cooldown\\n            sell = Math.max(buy + prices[i], sell);\\n        }\\n\\n        return sell;\\n    }\\n}\\n```\\n\\n---\\n\\n**\\u2714\\uFE0F Solution for - [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)**\\n\\n**Time Complexity:** `O(N)` --> `N` is length of the input price array\\n**Space Complexity:** `O(1)` --> Constant Space\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        if (prices == null || prices.length < 2) {\\n            return 0;\\n        }\\n\\n        int buy = -prices[0];\\n        int sell = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n\\n            // buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i])\\n            buy = Math.max(sell - prices[i], buy);\\n\\n            // sell[i] = Math.max(sell[i - 1], buy[i] + prices[i])\\n            sell = Math.max(buy + prices[i] - fee, sell);\\n        }\\n\\n        return sell;\\n    }\\n}\\n```\\n\\n---\\n\\n**<ins>Time & Space complexity Cheatsheet for all Buy & Sell Stock questions on Leetcode:</ins>**\\n\\n| Buy & Sell Stock Question                                                                                                                        | Time Complexity | Space Complexity |\\n|--------------------------------------------------------------------------------------------------------------------------------------------------|:---------------:|:----------------:|\\n| [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)                                           |       O(N)      |       O(1)       |\\n| [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)                                     |       O(N)      |       O(1)       |\\n| [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)                                   |       O(N)      |       O(1)       |\\n| [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)                                     |     O(N * k)    |       O(N)       |\\n| [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)               |       O(N)      |       O(1)       |\\n| [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/) |       O(N)      |       O(1)       |\\n\\n---\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\t\\t// We need prices for 2 days at least to find the profit.\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int totalProfit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            // Checking if we can profit with previous day\\'s price.\\n            // If yes, then we buy on previous day and sell on current day.\\n            // Add all such profits to get the total profit.\\n            if (prices[i - 1] < prices[i]) {\\n                totalProfit += prices[i] - prices[i - 1];\\n            }\\n        }\\n\\n        return totalProfit;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int maxProfitHere = 0;\\n        int maxProfitSoFar = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            maxProfitHere = Math.max(0, maxProfitHere + prices[i] - prices[i - 1]);\\n            maxProfitSoFar = Math.max(maxProfitSoFar, maxProfitHere);\\n        }\\n\\n        return maxProfitSoFar;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int buy1 = -prices[0];\\n        int sell1 = buy1 + prices[0];\\n        int buy2 = sell1 - prices[0];\\n        int sell2 = buy2 + prices[0];\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            // The maximum money left after buying 1st stock.\\n            buy1 = Math.max(buy1, -prices[i]);\\n\\n            // The maximum money left after selling 1st stock.\\n            sell1 = Math.max(sell1, buy1 + prices[i]);\\n\\n            // The maximum money left after buying 2nd stock.\\n            buy2 = Math.max(buy2, sell1 - prices[i]);\\n\\n            // The maximum money left after selling 2nd stock.\\n            sell2 = Math.max(sell2, buy2 + prices[i]);\\n        }\\n\\n        return Math.max(sell1, sell2);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if (prices == null || prices.length <= 1 || k <= 0) {\\n            return 0;\\n        }\\n        if (k >= prices.length / 2) {\\n            return quickSolve(prices);\\n        }\\n\\n        int len = prices.length;\\n        int[] dp1 = new int[len];\\n        int[] dp2 = new int[len];\\n        for (int i = 0; i < k; i++) {\\n            int tempMax = -prices[0];\\n            for (int j = 1; j < len; j++) {\\n                dp2[j] = Math.max(dp2[j - 1], prices[j] + tempMax);\\n                tempMax = Math.max(tempMax, dp1[j] - prices[j]);\\n            }\\n            dp1 = Arrays.copyOf(dp2, len);\\n        }\\n\\n        return dp2[len - 1];\\n    }\\n\\n    private int quickSolve(int[] prices) {\\n        int totalProfit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i - 1] < prices[i]) {\\n                totalProfit += prices[i] - prices[i - 1];\\n            }\\n        }\\n        return totalProfit;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int buy = -prices[0];\\n        int sell = 0;\\n        int prevSell = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            // buy[i] = Math.max(sell[i-2]-prices[i], buy[i-1])\\n            // sell[i-2]-prices[i] -> Buy after a 1 day cooldown\\n            // buy[i-1] -> cooldown\\n            buy = Math.max(prevSell - prices[i], buy);\\n\\n            // sell[i-1];\\n            prevSell = sell;\\n\\n            // sell[i] = Math.max(buy[i]+prices, sell[i-1])\\n            // buy[i]+prices -> sell the stock.\\n            // sell[i-1] -> cooldown\\n            sell = Math.max(buy + prices[i], sell);\\n        }\\n\\n        return sell;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        if (prices == null || prices.length < 2) {\\n            return 0;\\n        }\\n\\n        int buy = -prices[0];\\n        int sell = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n\\n            // buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i])\\n            buy = Math.max(sell - prices[i], buy);\\n\\n            // sell[i] = Math.max(sell[i - 1], buy[i] + prices[i])\\n            sell = Math.max(buy + prices[i] - fee, sell);\\n        }\\n\\n        return sell;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564729,
                "title": "java-simple-code-dp",
                "content": "The action we can do on `ith` day is either `buy` (if last action is sell), or `sell` (if last action is buy), or do nothing (not buy, not sell).\\n\\n```\\npublic int maxProfit(int[] A) {                        \\n        int n = A.length, lastBuy = -A[0], lastSold = 0;\\n        if (n == 0) return 0;\\n                                \\n        for (int i = 1; i < n; i++) {\\n            int curBuy = Math.max(lastBuy, lastSold - A[i]);\\n            int curSold = Math.max(lastSold, lastBuy + A[i]);\\n            lastBuy = curBuy;\\n            lastSold = curSold;\\n        }\\n        \\n        return lastSold;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfit(int[] A) {                        \\n        int n = A.length, lastBuy = -A[0], lastSold = 0;\\n        if (n == 0) return 0;\\n                                \\n        for (int i = 1; i < n; i++) {\\n            int curBuy = Math.max(lastBuy, lastSold - A[i]);\\n            int curSold = Math.max(lastSold, lastBuy + A[i]);\\n            lastBuy = curBuy;\\n            lastSold = curSold;\\n        }\\n        \\n        return lastSold;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1569093,
                "title": "c-python-clean-and-simple-solution-w-detailed-explanation-images-buy-low-sell-high",
                "content": "\\u2714\\uFE0F ***Solution - I (Buy Low, Sell High)***\\n\\nThis solution just uses simple approach of trading - **buy low, sell high**. Think about how you could maximize your profits if you knew prices of stocks on each day with only 1 stock allowed at hand? You would of-course buy on the day where price was **lowest in the local range** and sell when it was **highest in local range** and perform as many trades as you can since you are allowed only 1 stock.\\n\\nIt\\'s always better to consider every low & highs and trade between them and not skip any low/highs or not just consider the global minimum and maximum because it is always equal or more profitable to buy and sell at every local *valleys* (lowest) and *peaks* (highest) and trade multiple times in between if there are multiple valleys and peaks. This is best illustrated by LeetCode\\'s official solution diagram (allow me to borrow it for educational purpose \\uD83D\\uDE05) - \\n\\n<table>\\n<tr>\\n<td><img  src=\"https://leetcode.com/media/original_images/122_maxprofit_1.PNG\" width=800 /></td>\\n<td>\\nWe can see that we have choices to either perform two trades -</br></br>\\n&emsp;&emsp;&emsp;1. Buy at valley<sub>2</sub>, sell at peak<sub>3</sub> and again buy at valley<sub>4</sub>, sell at peak<sub>5</sub>. </br>&emsp;&emsp;&emsp;&emsp;<b>Profit = A+B</b></br>\\n&emsp;&emsp;&emsp;2. Buy at valley<sub>2</sub>, sell at peak<sub>5</sub>. <b>Profit = C</b></br></br>\\nIn any case, we have <b>A + B > C</b> because if A+B == C, then valley<sub>4</sub> can\\'t exist.\\n</td>\\n</tr>\\n<tr>\\n<td><img src=\"https://leetcode.com/media/original_images/122_maxprofit_2.PNG\" width=800 /></td>\\n<td>\\nWe can see that we will buy at valley<sub>3</sub> and sell at peak<sub>6</sub>. </br></br>As you will see later on in solution, this is simulated as <b>buy<sub>3</sub>, sell <sub>4</sub>+buy<sub>4</sub>, sell <sub>5</sub>+buy<sub>5</sub>, sell <sub>6</sub></b> which is nothing but equivalent to <b>buy<sub>3</sub> and sell<sub>6</sub></b>\\n</td>\\n</tr>\\n</table>\\n\\nFrom above, we can see that we need to perform multiple trades buying at valley, selling at peak every time possible. Whenever we find that **today\\'s price is higher than yesterday**, we know we should have **bought yesterday and sold today**. It can be implemented in a naive way as below - \\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P) {\\n        int n = size(P), i = 1, profit = 0, buy, sell;\\n        while(i < n) {\\n            // find lowest price to buy - local valley \\uD83D\\uDCC9\\n            for(buy = P[i-1]; i < n && P[i] < buy; i++) \\n                buy = P[i];    \\n            if(i >= n) break;      // break if no more days remaining\\n            // find highest price to sell - local peak  \\uD83D\\uDCC8 \\n            for(sell = P[i]; i < n && sell <= P[i]; i++)\\n                sell = P[i];    \\n            profit += sell - buy; // keep adding the \\uD83D\\uDCB8\\n            i++;\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\nThe above code can be simplified by considering every day when price is greater than yesterday and trading that day (buying at yesterday\\'s low price and selling at today\\'s high price).\\n\\nThe first case of finding local valley will be handled in this case as well since we only engage in trade when yesterday\\'s price was lower than today meaning we bought at local valley.\\n\\nBut what if there are consecutive days where we find today was higher price than yesterday? That cases would be handled as well because it will be simulated as buy yesterday and sell today for multiple times and that eventually sums out to buying at every valley and selling at peak as we saw in the diagram-2 above.\\n\\nThe above also means that our answer remains same with or without this allowed - **`However, you can buy it then immediately sell it on the same day.`**\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P) {\\n        int profit = 0;\\n        for(int i = 1; i < size(P); i++)\\n            if(P[i] > P[i-1])              // yesterday was valley, today is peak\\n                profit += P[i] - P[i-1];   // buy yesterday, sell today\\n        return profit;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def maxProfit(self, P: List[int]) -> int:\\n        return sum(P[i]-P[i-1] if P[i] > P[i-1] else 0 for i in range(1, len(P)))\\n```\\n\\n***Time Complexity :*** **<code>O(N)</code>** where `N` is the size of `P` array.\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P) {\\n        int n = size(P), i = 1, profit = 0, buy, sell;\\n        while(i < n) {\\n            // find lowest price to buy - local valley \\uD83D\\uDCC9\\n            for(buy = P[i-1]; i < n && P[i] < buy; i++) \\n                buy = P[i];    \\n            if(i >= n) break;      // break if no more days remaining\\n            // find highest price to sell - local peak  \\uD83D\\uDCC8 \\n            for(sell = P[i]; i < n && sell <= P[i]; i++)\\n                sell = P[i];    \\n            profit += sell - buy; // keep adding the \\uD83D\\uDCB8\\n            i++;\\n        }\\n        return profit;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P) {\\n        int profit = 0;\\n        for(int i = 1; i < size(P); i++)\\n            if(P[i] > P[i-1])              // yesterday was valley, today is peak\\n                profit += P[i] - P[i-1];   // buy yesterday, sell today\\n        return profit;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, P: List[int]) -> int:\\n        return sum(P[i]-P[i-1] if P[i] > P[i-1] else 0 for i in range(1, len(P)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39531,
                "title": "java-o-n-solution-if-we-re-not-greedy",
                "content": "Hi guys!\\n\\nThe greedy pair-wise approach mentioned in other posts is great for this problem indeed, but if we're not allowed to buy and sell stocks within the same day it can't be applied (logically, of course; the answer will be the same). Actually, the straight-forward way of finding next local minimum and next local maximum is not much more complicated, so, just for the sake of having an alternative I share the code in Java for such case.\\n\\n    public int maxProfit(int[] prices) {\\n        int profit = 0, i = 0;\\n        while (i < prices.length) {\\n            // find next local minimum\\n            while (i < prices.length-1 && prices[i+1] <= prices[i]) i++;\\n            int min = prices[i++]; // need increment to avoid infinite loop for \"[1]\"\\n            // find next local maximum\\n            while (i < prices.length-1 && prices[i+1] >= prices[i]) i++;\\n            profit += i < prices.length ? prices[i++] - min : 0;\\n        }\\n        return profit;\\n    }\\n\\nHappy coding!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nThe greedy pair-wise approach mentioned in other posts is great for this problem indeed, but if we're not allowed to buy and sell stocks within the same day it can't be applied (logically, of course; the answer will be the same). Actually, the straight-forward way of finding next local minimum and next local maximum is not much more complicated, so, just for the sake of having an alternative I share the code in Java for such case.\\n\\n    public int maxProfit(int[] prices) {\\n        int profit = 0, i = 0;\\n        while (i < prices.length) {\\n            // find next local minimum\\n            while (i < prices.length-1 && prices[i+1] <= prices[i]) i++;\\n            int min = prices[i++]; // need increment to avoid infinite loop for \"[1]\"\\n            // find next local maximum\\n            while (i < prices.length-1 && prices[i+1] >= prices[i]) i++;\\n            profit += i < prices.length ? prices[i++] - min : 0;\\n        }\\n        return profit;\\n    }\\n\\nHappy coding!",
                "codeTag": "Unknown"
            },
            {
                "id": 900051,
                "title": "fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference",
                "content": "***Resources: https://github.com/AJAYKR00KJ/LeetCode_Solution***\\n\\n**To solve this problem just start from basic similar problem. After solving these peoblems we wil reach at final this problem.**\\n\\n``` I have discussed all the problems by recursive and memoization approach , so that everyone can figure out minor differences between the questions :)```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n**Recursive Solution and memoize solutions:**\\n\\n1. https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\\n\\n   **You can do at most one transaction**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices, int i,int k,bool buy,vector<vector<int>> &v)\\n    {\\n        //if we have no stock or we have no chance of transaction(k=0)\\n        if(i>=prices.size()||k<=0) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  //if we are buying then next time we will sell else next time we will buy\\n        {        //-prices[i], because bought stock of prices[i], expend money\\n            \\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,k,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n        else    //it\\'s time to sell , now decrease k, we have done 1 transaction\\n        {       //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n           return v[i][buy]=max( prices[i]+find(prices,i+1,k-1,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size(); \\n        vector<vector<int>> v(n,vector<int> (2,-1));\\n        //passing here buy=1 because we will first buy then sell\\n        //we can do atmost k=1 transaction\\n        return find(prices,0,1,1,v);\\n    }\\n};\\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n2. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\\n\\n    **You can do as many transactions as you like**\\n\\n```\\nclass Solution {\\npublic:\\nint find(int ind,vector<int> &v,bool buy,vector<vector<int>> &memo)\\n{    \\n    if(ind>=v.size()) return 0;\\n    if(memo[ind][buy]!=-1) return memo[ind][buy];\\n    \\n    if(buy) //if we are buying then next time we will sell else next time we will buy\\n    {      //-prices[i], because bought stock of prices[i], expend money, !buy because next time sell\\n        \\n       return memo[ind][buy]=max(-v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n    else   //it\\'s time to sell \\n    {      //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n        \\n       return memo[ind][buy]=max(v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n     \\n}\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        if(n<2) return 0;\\n        vector<vector<int>> v(n+1,vector<int>(2,-1));\\n        //passing here buy=1 because we will first buy then sell \\n        return find(0,prices,1,v); \\n    }\\n};\\n```\\n \\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n 3.  https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\n\\n      **You may complete at most two transactions.**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,vector<vector<vector<int>>> &memo)\\n    {   \\n        //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=2) return 0; //counter\\n        if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n            return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n            return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        //here we can do maximum two transaction\\n        //Use 3-D vector because here three states i,k,buy/sell\\n        vector<vector<vector<int>>> memo(prices.size(),vector<vector<int>>(2,vector<int>(2,-1)));\\n          \\n       return find(prices,0,1,0,memo); \\n    }\\n};\\n \\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n4. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\\n\\n     **You may complete at most k transactions.**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,int k,vector<vector<vector<int>>> &memo)\\n    {   //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=k) return 0; //counter\\n        \\n        else if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n         \\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n        return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n        return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        \\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        //edge case we are not able to pick 2k points from n points, which means \\n        //we will not reach the limit no matter how we try. \\n        //if the price of day i arise, buy the stock in i-1th day and sell it at ith day.\\n        if (2 * k > prices.size()) {\\n            int res = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                res += max(0, prices[i] - prices[i - 1]);\\n            }\\n            return res;\\n        }\\n        \\n         //here we can do maximum k transaction\\n        vector<vector<vector<int>>> memo(prices.size()+1,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return find(prices,0,1,0,k,memo); \\n    }\\n};\\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n\\n**Hit \\uD83D\\uDC4D if you like it :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` I have discussed all the problems by recursive and memoization approach , so that everyone can figure out minor differences between the questions :)```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices, int i,int k,bool buy,vector<vector<int>> &v)\\n    {\\n        //if we have no stock or we have no chance of transaction(k=0)\\n        if(i>=prices.size()||k<=0) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  //if we are buying then next time we will sell else next time we will buy\\n        {        //-prices[i], because bought stock of prices[i], expend money\\n            \\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,k,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n        else    //it\\'s time to sell , now decrease k, we have done 1 transaction\\n        {       //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n           return v[i][buy]=max( prices[i]+find(prices,i+1,k-1,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size(); \\n        vector<vector<int>> v(n,vector<int> (2,-1));\\n        //passing here buy=1 because we will first buy then sell\\n        //we can do atmost k=1 transaction\\n        return find(prices,0,1,1,v);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint find(int ind,vector<int> &v,bool buy,vector<vector<int>> &memo)\\n{    \\n    if(ind>=v.size()) return 0;\\n    if(memo[ind][buy]!=-1) return memo[ind][buy];\\n    \\n    if(buy) //if we are buying then next time we will sell else next time we will buy\\n    {      //-prices[i], because bought stock of prices[i], expend money, !buy because next time sell\\n        \\n       return memo[ind][buy]=max(-v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n    else   //it\\'s time to sell \\n    {      //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n        \\n       return memo[ind][buy]=max(v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n     \\n}\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        if(n<2) return 0;\\n        vector<vector<int>> v(n+1,vector<int>(2,-1));\\n        //passing here buy=1 because we will first buy then sell \\n        return find(0,prices,1,v); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,vector<vector<vector<int>>> &memo)\\n    {   \\n        //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=2) return 0; //counter\\n        if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n            return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n            return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        //here we can do maximum two transaction\\n        //Use 3-D vector because here three states i,k,buy/sell\\n        vector<vector<vector<int>>> memo(prices.size(),vector<vector<int>>(2,vector<int>(2,-1)));\\n          \\n       return find(prices,0,1,0,memo); \\n    }\\n};\\n \\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,int k,vector<vector<vector<int>>> &memo)\\n    {   //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=k) return 0; //counter\\n        \\n        else if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n         \\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n        return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n        return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        \\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        //edge case we are not able to pick 2k points from n points, which means \\n        //we will not reach the limit no matter how we try. \\n        //if the price of day i arise, buy the stock in i-1th day and sell it at ith day.\\n        if (2 * k > prices.size()) {\\n            int res = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                res += max(0, prices[i] - prices[i - 1]);\\n            }\\n            return res;\\n        }\\n        \\n         //here we can do maximum k transaction\\n        vector<vector<vector<int>>> memo(prices.size()+1,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return find(prices,0,1,0,k,memo); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39406,
                "title": "clear-1-line-python-solution",
                "content": "Basically, if tomorrow's price is higher than today's, we buy it today and sell tomorrow. Otherwise, we don't. Here is the code:\\n\\n    class Solution(object):\\n        def maxProfit(self, prices):\\n            return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))",
                "solutionTags": [],
                "code": "Basically, if tomorrow's price is higher than today's, we buy it today and sell tomorrow. Otherwise, we don't. Here is the code:\\n\\n    class Solution(object):\\n        def maxProfit(self, prices):\\n            return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))",
                "codeTag": "Java"
            },
            {
                "id": 1569156,
                "title": "c-easy-intuitive-solutions-with-explanation",
                "content": "Firstly, thanks for refering to my solution, in advance :)\\n\\n **Valley Peak approach :** \\nWe buy the stock on the day with least local rate and sell it when we find a peak that is raise in prices again. i.e; we just need to find the next greater element and subtract it from the current element so that the difference keeps increasing and so does the profit.\\nIf the sequence is decreasing sequence then, no profit can be made because no matter on which day we buy the stock, we would have to sell it incurring a loss. So then we don\\'t buy and make \\'0\\' profit rather than negative. \\nWe can just understand which day we buy and sell the stock, by simply using a peak Valley Diagram.\\n\\nFor instance, \\n![image](https://assets.leetcode.com/users/images/8a071173-ac5b-4bda-97a9-74da3637398d_1636509428.7270691.png)\\n* Here, the first valley is seen on day-2, we buy the stock on day2 and sell when the prices raise the next day, i.e on day-3 - Profit+=A\\n* Then again, we buy on the day the next valley is seen on day-4, so we buy on day-4 and sell on the day, the next peak is seen i.e; on day-5 - Profit+=B\\nThus, the max-profit we can make with this sequence of stock-rates is A+B.\\n\\n![image](https://assets.leetcode.com/users/images/47631773-0c33-4080-ac31-1e8942f64b2b_1636509698.8262544.png) In this graph, we see the first valley on day-3, we buy on day-3, sell on day-4. \\nThen again, the price on day-5 is less than that on day-4, So we buy again on day-4 and sell on day-5. \\nSimilarly, we buy on day-5 again and sell on day-6.\\nThe Valley-Peak graph is known in advance to us. So, we can see the future prices and make decision accordingly.\\n\\n**Time and Space Complexity**\\n* Time Complexity - O(n) - We traverse through the array of stock-rates only once\\n* Auxiliary Space - O(1)\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int i=0, profit=0, buy, sell;\\n        while(i < prices.size()-1){\\n            while(i < prices.size()-1 && prices[i+1] <= prices[i]){\\n                i++;\\n            }\\n            buy = prices[i];\\n            while(i < prices.size()-1 && prices[i+1] > prices[i]){\\n                i++;\\n            }\\n            sell = prices[i];\\n            profit += sell - buy;\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\nA faster approach would be :\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxProfit=0;\\n        \\n        for(int i=1; i<prices.size(); ++i) \\n            maxProfit += max(prices[i] - prices[i-1], 0);\\n   \\n        return maxProfit;\\n    }\\n};\\n```\\n\\nIf you like my solution, please upvote! It will keep me motivated and consistent.\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int i=0, profit=0, buy, sell;\\n        while(i < prices.size()-1){\\n            while(i < prices.size()-1 && prices[i+1] <= prices[i]){\\n                i++;\\n            }\\n            buy = prices[i];\\n            while(i < prices.size()-1 && prices[i+1] > prices[i]){\\n                i++;\\n            }\\n            sell = prices[i];\\n            profit += sell - buy;\\n        }\\n        return profit;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxProfit=0;\\n        \\n        for(int i=1; i<prices.size(); ++i) \\n            maxProfit += max(prices[i] - prices[i-1], 0);\\n   \\n        return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39564,
                "title": "another-accepted-java-solution",
                "content": "    public class Solution {\\n        public int maxProfit(int[] prices) {\\n            int profit = 0;\\n            \\n            for (int i = 1; i < prices.length; i++) \\n                profit += Math.max(0, prices[i] - prices[i - 1]);\\n            \\n            return profit;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maxProfit(int[] prices) {\\n            int profit = 0;\\n            \\n            for (int i = 1; i < prices.length; i++) \\n                profit += Math.max(0, prices[i] - prices[i - 1]);\\n            \\n            return profit;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39407,
                "title": "an-iterative-python-solution-greedy",
                "content": "    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            if not prices or len(prices) is 1:\\n                return 0\\n            \\n            profit = 0\\n            \\n            for i in range(1, len(prices)):\\n                if prices[i] > prices[i-1]:\\n                    profit += prices[i] - prices[i-1]\\n    \\n            return profit",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            if not prices or len(prices) is 1:\\n                return 0\\n            \\n            profit = 0\\n            \\n            for i in range(1, len(prices)):\\n                if prices[i] > prices[i-1]:\\n                    profit += prices[i] - prices[i-1]\\n    \\n            return profit",
                "codeTag": "Java"
            },
            {
                "id": 39404,
                "title": "shortest-and-fastest-solution-with-explanation-you-can-never-beat-this",
                "content": "For Buy and Sell 1, we were limited to 1 transaction, so we had to find the largest sum of contiguous ints in an array of price differences. \\n\\nQ: Why does finding the most profitable transaction boils down to finding the largest sum of contiguous ints in the array of price differences?\\n\\nA: Define D[i] = Prices[i] - Prices[i-1] (difference between 2 consecutive prices)\\n\\nD[i] is essentially a \"delta\" trade. \\n\\nA transaction is defined as buying at Prices[X] and selling at Prices[Y], \\n\\n    the profit of the transaction\\n    = Prices[Y] - Prices[X] \\n    = Prices[Y] - Prices[Y-1] +\\n       Prices[Y-1] - Prices[Y-2] ...\\n        ....\\n       Prices[X+1] - Prices[X] \\n    = D[Y] + D[Y-1] + ... + D[X+1]\\n    = sum of D from X+1 to Y\\n   \\nThe problem is to find max(Prices[Y] - Prices[X]) which is equivalent to finding the largest sum of contiguous D's.\\n\\nTo illustrate, if D[Y+1] is positive, it means  Prices[Y+1] > Prices[Y], which implies I should sell at Prices[Y+1] instead of Prices[Y]. Basically it means I just add D[Y+1] to D[Y] + ... + D[X+1].  \\n\\nNote that there could be a negative or zero D in the best running sequence. It doesn't matter so long the  sum of the sequence is the largest.\\n\\nNow we are allowed unlimited transactions. So if there is a negative D, we could just break the sequence into 2, that is, into 2 transactions so as to avoid the negative element. \\n\\nThis boils the whole problem down to adding up all positive sums of contiguous ints in D, which simplifies to  just adding up all the positive ints.\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            const size_t n = prices.size();\\n            int ans = 0;\\n            for (size_t i=1;i<n;i++)\\n                ans += max(0,prices[i]-prices[i-1]);\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            const size_t n = prices.size();\\n            int ans = 0;\\n            for (size_t i=1;i<n;i++)\\n                ans += max(0,prices[i]-prices[i-1]);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 306427,
                "title": "different-python-solutions-with-thinking-process",
                "content": "Please see and vote for my different solutions with thinking process.\\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/306438/Python-O(n)-solution-with-thinking-process)\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/306427/Different-O(n)-Python-solutions-with-thinking-process)\\n[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/306235/Different-DP-Python-solutions-with-thinking-process)\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/306282/Different-DP-Python-solutions-with-thinking-process)\\n[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/444413/Different-Python-solutions-with-thinking-process-to-solve-the-series-of-stock-problems)\\n\\n**Method 1: straightforward algorithm with O(n) time and O(1) space**\\nFor each day, there are 3 possible actions: buy, sell, nothing. \\nThe action nothing can be interpreted at \"sell then immediately buy\". \\nSo positive changes of prices are profitable.\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        for i in range(len(prices) - 1):\\n            max_profit += max(prices[i+1] - prices[i], 0)\\n        return max_profit\\n```\\n\\n**Method 2: DP algorithm with O(n) time and O(1) space**\\nFor each day, there are 3 possible actions: buy, sell, nothing. Let us define\\nbuy[i] = maxProfit of prices[:i+1] with the action buy at day i,\\nsell[i] = maxProfit of prices[:i+1] with the action sell at day i,\\nnothing[i] = maxProfit of prices[:i+1] with the action nothing at day i.\\n\\nThe base cases are buy[0] = -prices[0], sell[0] = nothing[0] = 0. The recursive relationships are\\nbuy[i] = max(max(sell[i-1], nothing[i-1]) - prices[i], buy[i-1]) # no cool down\\nsell[i] = max(buy[i-1] + prices[i], sell[i-1])\\nnothing[i] = max(sell[i-1], buy[i-1], nothing[i-1]).\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        prev_buy, prev_sell, prev_nothing = -prices[0], 0, 0\\n        for i in range(1, n):\\n            buy  = max(max(prev_sell, prev_nothing) - prices[i], prev_buy) \\n            sell = max(prev_buy + prices[i], prev_sell)\\n            nothing = max(prev_sell, prev_buy, prev_nothing)\\n            prev_buy, prev_sell, prev_nothing = buy, sell, nothing\\n        return max(sell, nothing)\\n```\\n\\n**Method 3: naive DP algorithm with O(n^2) time and O(n) space**\\nLet dp[i] = maxProfit of prices[:i+1], the base cases and recursive relationship are\\n(i) dp[i] = 0 if i <= 0\\n(ii) dp[i] = max(dp[i-1], prices[i] - prices[j] + dp[j-1] for j from 0 to i-1)\\nBecause we have two choices at day i: (1) do nothing at day i, (2) maxProfit of prices[:j], buy at day j, sell at day i.\\n\\nSolution 3: bottom-up approach with a table (Time Limit Exceeded, 200 / 201 test cases passed.)\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1]\\n            for j in range(i):\\n                tmp = prices[i] - prices[j]\\n                tmp += dp[j-1] if j > 0 else 0\\n                dp[i] = max(dp[i], tmp)\\n        return dp[n-1]\\n```\\n\\nSolution 4: top-down approach with memoization (Time Limit Exceeded, 200 / 201 test cases passed.)\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def recursive(i):\\n            if i <= 0:\\n                return 0\\n            if i in mp:\\n                return mp[i]\\n            max_profit = recursive(i - 1)\\n            for j in range(i):\\n                tmp = prices[i] - prices[j] + recursive(j - 1)\\n                max_profit = max(max_profit, tmp)\\n            mp[i] = max_profit\\n            return mp[i]\\n        \\n        mp = {}\\n        return recursive(len(prices) - 1)\\n```\\n\\n**Method 4: DP algorithm with O(n) time and O(n) space** (Beat 27.94%)\\nLet dp[i] = maxProfit of prices[:i+1], the base cases and recursive relationship are\\n(i) dp[i] = 0 if i <= 0\\n(ii) dp[i] = max(dp[i-1], prices[i] - prices[j] + dp[j-1] for j from 0 to i-1)\\n**We can further use DP to get local_max = - prices[j] + dp[j-1] for j from 0 to i-1.**\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        local_max = -prices[0]\\n        for i in range(1, n):\\n            dp[i] = max(dp[i-1], prices[i] + local_max)\\n            local_max = max(local_max, dp[i-1] - prices[i])\\n        return dp[n-1]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        for i in range(len(prices) - 1):\\n            max_profit += max(prices[i+1] - prices[i], 0)\\n        return max_profit\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        prev_buy, prev_sell, prev_nothing = -prices[0], 0, 0\\n        for i in range(1, n):\\n            buy  = max(max(prev_sell, prev_nothing) - prices[i], prev_buy) \\n            sell = max(prev_buy + prices[i], prev_sell)\\n            nothing = max(prev_sell, prev_buy, prev_nothing)\\n            prev_buy, prev_sell, prev_nothing = buy, sell, nothing\\n        return max(sell, nothing)\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1]\\n            for j in range(i):\\n                tmp = prices[i] - prices[j]\\n                tmp += dp[j-1] if j > 0 else 0\\n                dp[i] = max(dp[i], tmp)\\n        return dp[n-1]\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def recursive(i):\\n            if i <= 0:\\n                return 0\\n            if i in mp:\\n                return mp[i]\\n            max_profit = recursive(i - 1)\\n            for j in range(i):\\n                tmp = prices[i] - prices[j] + recursive(j - 1)\\n                max_profit = max(max_profit, tmp)\\n            mp[i] = max_profit\\n            return mp[i]\\n        \\n        mp = {}\\n        return recursive(len(prices) - 1)\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        local_max = -prices[0]\\n        for i in range(1, n):\\n            dp[i] = max(dp[i-1], prices[i] + local_max)\\n            local_max = max(local_max, dp[i-1] - prices[i])\\n        return dp[n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 590168,
                "title": "easy-python-solution-faster-than-98-39",
                "content": "The key idea is to take down all daily returns and sum up all positive returns. This works because we can break every trade down to several overnigt trades. For example, considering [1, 2, 3], buy 1 sell 3 is equivalent to buy 1 sell 2 + buy 2 sell 3.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 1: # edge case\\n            return 0\\n        \\n        # take down positive daily return only\\n        profit = [] \\n        for i in range(1, len(prices)):\\n            profit.append(max(0, prices[i] - prices[i-1])) \\n        return sum(profit)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 1: # edge case\\n            return 0\\n        \\n        # take down positive daily return only\\n        profit = [] \\n        for i in range(1, len(prices)):\\n            profit.append(max(0, prices[i] - prices[i-1])) \\n        return sum(profit)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259375,
                "title": "python-2-solutions-top-down-dp-greedy-clean-concise",
                "content": "**Solution 1: Top down DP**\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        \\n        @lru_cache(None)\\n        def dp(i, canBuy):\\n            if i == n:\\n                return 0\\n            ans = dp(i+1, canBuy)  # Skip\\n            if canBuy:\\n                ans = max(ans, dp(i+1, False) - prices[i])  # Buy\\n            else:\\n                ans = max(ans, dp(i+1, True) + prices[i])  # Sell\\n            return ans\\n        \\n        return dp(0, True)\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n---\\n**Solution 2: Greedy**\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        maxProfit = 0\\n        for i in range(n-1):\\n            if prices[i+1] > prices[i]:\\n                maxProfit += prices[i+1] - prices[i]\\n        return maxProfit\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        \\n        @lru_cache(None)\\n        def dp(i, canBuy):\\n            if i == n:\\n                return 0\\n            ans = dp(i+1, canBuy)  # Skip\\n            if canBuy:\\n                ans = max(ans, dp(i+1, False) - prices[i])  # Buy\\n            else:\\n                ans = max(ans, dp(i+1, True) + prices[i])  # Sell\\n            return ans\\n        \\n        return dp(0, True)\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        maxProfit = 0\\n        for i in range(n-1):\\n            if prices[i+1] > prices[i]:\\n                maxProfit += prices[i+1] - prices[i]\\n        return maxProfit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376873,
                "title": "javascript-easy-understand",
                "content": "```\\nvar maxProfit = function (prices) {\\n    let profit = 0;\\n\\n    for (let i = 1; i < prices.length; i++) {\\n        let prev = prices[i - 1];\\n        let current = prices[i];\\n\\n        if (prev < current) {\\n            profit += current - prev;\\n        }\\n    }\\n    \\n    return profit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function (prices) {\\n    let profit = 0;\\n\\n    for (let i = 1; i < prices.length; i++) {\\n        let prev = prices[i - 1];\\n        let current = prices[i];\\n\\n        if (prev < current) {\\n            profit += current - prev;\\n        }\\n    }\\n    \\n    return profit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1569060,
                "title": "daily-leetcoding-challenge-november-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Peak Valley Approach\n\n  \n**Approach 3:** Simple One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 39507,
                "title": "8ms-c-solution-with-only-6-lines-of-code",
                "content": "    int maxProfit(vector<int>& prices) {\\n      if(prices.size() <= 1) return 0;\\n\\n      int res = 0;\\n\\n      for( size_t i = 1; i < prices.size(); i++)\\n        if( prices[i] - prices[i-1] > 0 ) \\n          res += prices[i] - prices[i-1];\\n      \\n      return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "    int maxProfit(vector<int>& prices) {\\n      if(prices.size() <= 1) return 0;\\n\\n      int res = 0;\\n\\n      for( size_t i = 1; i < prices.size(); i++)\\n        if( prices[i] - prices[i-1] > 0 ) \\n          res += prices[i] - prices[i-1];\\n      \\n      return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 596502,
                "title": "c-with-diagram-explaination-100-speed-and-100-space",
                "content": "```\\n/*\\nHere the way to tackle this problem is to visualize it.\\nIf I were to buy the data at every small value and sell it at the immediate biggest value i can get the answer.\\nLet me demonstrate:\\n \\t\\t\\t\\t   7\\n \\t\\t\\t\\t\\t\\\\     5    6 \\n \\t\\t\\t\\t\\t \\\\    /\\\\  /\\\\\\n \\t\\t\\t\\t\\t  \\\\  /  \\\\/  4 --------->[7,1,5,3,6,4]\\n \\t\\t\\t\\t\\t   \\\\/\\t3\\t\\t  \\n                       1\\nSo if we were to buy at every valley and sell at evry peak we can acheive the goal given in this q.\\n      buy-1,3,4\\n      sell-5,6\\n      but as 4 doesnt have a pair we discard it\\n      profit = (sum of peaks) - (sum of valleys)\\n                11 - 4 = 7\\n*/\\n     int maxProfit(vector<int>& prices) {\\n        int ans=0,profit=0;\\n        int valley,peak;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            while(i<prices.size()-1 && prices[i]>=prices[i+1])i++;\\n            valley = prices[i];\\n            while(i<prices.size()-1 && prices[i]<=prices[i+1])i++;\\n            peak = prices[i];\\n            profit += peak-valley;\\n        }\\n        return profit;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nHere the way to tackle this problem is to visualize it.\\nIf I were to buy the data at every small value and sell it at the immediate biggest value i can get the answer.\\nLet me demonstrate:\\n \\t\\t\\t\\t   7\\n \\t\\t\\t\\t\\t\\\\     5    6 \\n \\t\\t\\t\\t\\t \\\\    /\\\\  /\\\\\\n \\t\\t\\t\\t\\t  \\\\  /  \\\\/  4 --------->[7,1,5,3,6,4]\\n \\t\\t\\t\\t\\t   \\\\/\\t3\\t\\t  \\n                       1\\nSo if we were to buy at every valley and sell at evry peak we can acheive the goal given in this q.\\n      buy-1,3,4\\n      sell-5,6\\n      but as 4 doesnt have a pair we discard it\\n      profit = (sum of peaks) - (sum of valleys)\\n                11 - 4 = 7\\n*/\\n     int maxProfit(vector<int>& prices) {\\n        int ans=0,profit=0;\\n        int valley,peak;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            while(i<prices.size()-1 && prices[i]>=prices[i+1])i++;\\n            valley = prices[i];\\n            while(i<prices.size()-1 && prices[i]<=prices[i+1])i++;\\n            peak = prices[i];\\n            profit += peak-valley;\\n        }\\n        return profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343376,
                "title": "python3-greedy",
                "content": "# Please Upvote \\uD83D\\uDE07\\n\\n## Python3\\n```\\nclass Solution:\\n    def maxProfit(self, a: List[int]) -> int:\\n        ans=0\\n        x=a[0]\\n        for i in range(1,len(a)):\\n            if(x>a[i]):\\n                x=a[i]\\n            else:\\n                ans+=a[i]-x\\n                x=a[i]\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, a: List[int]) -> int:\\n        ans=0\\n        x=a[0]\\n        for i in range(1,len(a)):\\n            if(x>a[i]):\\n                x=a[i]\\n            else:\\n                ans+=a[i]-x\\n                x=a[i]\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423189,
                "title": "c-intuition-memoization-tabulation-1d-array",
                "content": "***PLEASE UPVOTE IF YOU LIKE :)***\\n\\nIntuition - ***When we are at (i) th stock, we have 2 states possible*** - \\n\\n* We have bought a stock before and have not sold it. {We cannot buy a new stock right now, we can only sell or not sell today}. -> **2 options -> [ sell, not sell]**\\n\\n* We have no stock bought right now.  {We can buy a new stock right now. we may or may not buy today}. -> **2 options -> [buy, not buy]**\\n\\n* We can keep a boolean variable ```buy```, which will track ***whether we can buy on (i)th day or not.*** \\n\\n* When ```buy = true```, we can buy or not buy a new stock. \\n\\n* When ```buy = false```, we can sell or not sell the current stock we have.\\n\\n* We also have an integer variable - ```idx``` to ***track which day we\\'re at***. If ```idx == prices.size()```, we will earn 0 profit on that day, as we can neither buy nor sell.\\n\\n* When we ***buy*** a new stock on day ```idx``` - our ***net profit decreases by ```prices[idx]```*** , as the **price of the stock on this day will be deducted from the net profit earned.**\\n\\n* Similarily, when we ***sell*** a new stock on day ```idx``` - our ***net profit increases by ```prices[idx]```*** , as the **price of the stock on this day will be added to the net profit earned.**\\n\\nLet\\'s look at the code -\\n\\nNote -\\n* nb = net profit earned if we don\\'t buy on day ```idx```.\\n* ns = net profit earned if we don\\'t sell on day ```idx```.\\n* b = net profit earned if we buy on day ```idx```.\\n* s = net profit earned if we sell on day ```idx```.\\n\\nRecursion\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &p, int idx, bool buy){\\n        int n = p.size();\\n        if(idx == n) return 0; // end of days. Can\\'t buy or sell\\n        \\n        int ans = 0;\\n        if(buy){\\n\\t\\t\\t// either buy or don\\'t buy\\n            int b = -p[idx] + f(p, idx+1, 0);\\n            int nb = 0 + f(p, idx+1, 1);\\n            ans = max(b, nb);\\n        }\\n        else{\\n\\t\\t\\t// either sell or don\\'t sell\\n            int s = p[idx] + f(p, idx+1, 1);\\n            int ns = 0 + f(p, idx+1, 0);\\n            ans = max(s, ns);\\n        }\\n        return ans;\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n\\t\\t// Initially, we are at day 0 and we can buy a stock. \\n        return f(prices, 0, 1);\\n    }\\n};\\n```\\n\\nTC -> O(2 ^ N) where N - number of days\\nSC -> O(N)\\n\\nWe can ***reduce time complexity***, as there are overlapping subproblems that can be ***memoized***.\\n\\nMemoization -\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &p, int idx, bool buy, vector<vector<int>> &dp){\\n        int n = p.size();\\n        if(idx == n) return 0;\\n        \\n        if(dp[idx][buy] != -1) return dp[idx][buy];\\n        \\n        int ans = 0;\\n        if(buy){\\n            int b = -p[idx] + f(p, idx+1, 0, dp);\\n            int nb = 0 + f(p, idx+1, 1, dp);\\n            ans = max(b, nb);\\n        }\\n        else{\\n            int s = p[idx] + f(p, idx+1, 1, dp);\\n            int ns = 0 + f(p, idx+1, 0, dp);\\n            ans = max(s, ns);\\n        }\\n        return dp[idx][buy] = ans;\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\\n        return f(prices, 0, 1,dp);\\n    }\\n};\\n```\\n\\nTC -> O(2 * N)\\nSC -> O(2 * N) + O(N)\\n\\nThis ***extra O(N) stack space*** can be avoided by tabulating the above code.\\n\\nTabulation( Top - Down) -\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, 0));\\n        for(int idx = n-1; idx >= 0; idx--){\\n\\n            int b = -p[idx] + dp[idx+1][0];\\n\\n            int nb = 0 + dp[idx+1][1];\\n\\n            int s = p[idx] + dp[idx+1][1];\\n\\n            int ns = 0 + dp[idx+1][0];\\n\\n            dp[idx][0] = max(s, ns);\\n\\n            dp[idx][1] = max(b, nb);\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\nTC -> O( N )\\nSC -> O(2 * N)\\n\\nNow, note that we just need 2 info , to calculate max profit for each day ```idx``` -> max profit if we buy/not buy on ```idx+1``` day and max profit if we sell/not sell on ```idx + 1``` day.\\n\\nSo , we just need 2 array -> curr and next. ```next``` stores the 2 profits( can buy , can sell) for the ```idx + 1``` day and ```curr``` stores the 2 profits for ```idx``` day.\\n\\n1D array Optimized Code - \\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int n = p.size();\\n        vector<int> next(2, 0), curr(2, 0);\\n        for(int idx = n-1; idx >= 0; idx--){\\n\\n            int b = -p[idx] + next[0];\\n\\n            int nb = 0 + next[1];\\n\\n            int s = p[idx] + next[1];\\n\\n            int ns = 0 + next[0];\\n\\n            curr[0] = max(s, ns);\\n\\n            curr[1] = max(b, nb);\\n            \\n            next = curr;\\n        }\\n        return curr[1];\\n    }\\n};\\n```\\n\\nTC -> O( N )\\nSC -> O(1)\\n\\n***PLEASE UPVOTE IF YOU LIKE :)***\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```buy```\n```buy = true```\n```buy = false```\n```idx```\n```idx == prices.size()```\n```idx```\n```prices[idx]```\n```idx```\n```prices[idx]```\n```idx```\n```idx```\n```idx```\n```idx```\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &p, int idx, bool buy){\\n        int n = p.size();\\n        if(idx == n) return 0; // end of days. Can\\'t buy or sell\\n        \\n        int ans = 0;\\n        if(buy){\\n\\t\\t\\t// either buy or don\\'t buy\\n            int b = -p[idx] + f(p, idx+1, 0);\\n            int nb = 0 + f(p, idx+1, 1);\\n            ans = max(b, nb);\\n        }\\n        else{\\n\\t\\t\\t// either sell or don\\'t sell\\n            int s = p[idx] + f(p, idx+1, 1);\\n            int ns = 0 + f(p, idx+1, 0);\\n            ans = max(s, ns);\\n        }\\n        return ans;\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n\\t\\t// Initially, we are at day 0 and we can buy a stock. \\n        return f(prices, 0, 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &p, int idx, bool buy, vector<vector<int>> &dp){\\n        int n = p.size();\\n        if(idx == n) return 0;\\n        \\n        if(dp[idx][buy] != -1) return dp[idx][buy];\\n        \\n        int ans = 0;\\n        if(buy){\\n            int b = -p[idx] + f(p, idx+1, 0, dp);\\n            int nb = 0 + f(p, idx+1, 1, dp);\\n            ans = max(b, nb);\\n        }\\n        else{\\n            int s = p[idx] + f(p, idx+1, 1, dp);\\n            int ns = 0 + f(p, idx+1, 0, dp);\\n            ans = max(s, ns);\\n        }\\n        return dp[idx][buy] = ans;\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\\n        return f(prices, 0, 1,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, 0));\\n        for(int idx = n-1; idx >= 0; idx--){\\n\\n            int b = -p[idx] + dp[idx+1][0];\\n\\n            int nb = 0 + dp[idx+1][1];\\n\\n            int s = p[idx] + dp[idx+1][1];\\n\\n            int ns = 0 + dp[idx+1][0];\\n\\n            dp[idx][0] = max(s, ns);\\n\\n            dp[idx][1] = max(b, nb);\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```idx```\n```idx+1```\n```idx + 1```\n```next```\n```idx + 1```\n```curr```\n```idx```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int n = p.size();\\n        vector<int> next(2, 0), curr(2, 0);\\n        for(int idx = n-1; idx >= 0; idx--){\\n\\n            int b = -p[idx] + next[0];\\n\\n            int nb = 0 + next[1];\\n\\n            int s = p[idx] + next[1];\\n\\n            int ns = 0 + next[0];\\n\\n            curr[0] = max(s, ns);\\n\\n            curr[1] = max(b, nb);\\n            \\n            next = curr;\\n        }\\n        return curr[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298585,
                "title": "java-c-python-easy-and-concise",
                "content": "# **Intuition**\\nWe don\\'t want miss any increase value of the stock.\\n<br>\\n\\n# **Explanation**\\nSo we compare each neighbour,\\nif `A[i] < A[i + 1]`, we add this value to our result `res`\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int maxProfit(int[] A) {\\n        int res = 0;\\n        for (int i = 1; i < A.length; ++i)\\n            res += Math.max(A[i] - A[i - 1], 0);\\n        return res;\\n    }\\n```\\n**C++:**\\n```cpp\\n    int maxProfit(vector<int>& A) {\\n        int res = 0;\\n        for (int i = 1; i < A.size(); ++i)\\n            res += max(A[i] - A[i - 1], 0);\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def maxProfit(self, A):\\n        return sum(A[i] - A[i - 1] for i in xrange(1, len(A)) if A[i] > A[i - 1])\\n\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxProfit(int[] A) {\\n        int res = 0;\\n        for (int i = 1; i < A.length; ++i)\\n            res += Math.max(A[i] - A[i - 1], 0);\\n        return res;\\n    }\\n```\n```cpp\\n    int maxProfit(vector<int>& A) {\\n        int res = 0;\\n        for (int i = 1; i < A.size(); ++i)\\n            res += max(A[i] - A[i - 1], 0);\\n        return res;\\n    }\\n```\n```py\\n    def maxProfit(self, A):\\n        return sum(A[i] - A[i - 1] for i in xrange(1, len(A)) if A[i] > A[i - 1])\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3307280,
                "title": "fantastic-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        maxprofit=0\\n        for i in range(len(prices)-1):\\n            if prices[i+1]>prices[i]:\\n                maxprofit+=prices[i+1]-prices[i]\\n        return maxprofit\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        maxprofit=0\\n        for i in range(len(prices)-1):\\n            if prices[i+1]>prices[i]:\\n                maxprofit+=prices[i+1]-prices[i]\\n        return maxprofit\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264604,
                "title": "c-recursion-memoisation-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[30001][2];\\n    \\n    int recurs(int i,bool hold,vector<int>& prices)\\n    {\\n        if(i>=prices.size())\\n            return 0;\\n        \\n        if(dp[i][hold]!=-1)\\n            return dp[i][hold];\\n        \\n        // 1 indicates we have stock currently\\n        // 0 indicates no stock is possesed currently\\n        \\n        if(hold==1)//sell or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,0,prices)+prices[i],recurs(i+1,1,prices));\\n        }\\n        if(hold==0)//buy or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,1,prices)-prices[i],recurs(i+1,0,prices));\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return recurs(0,0,prices);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[30001][2];\\n    \\n    int recurs(int i,bool hold,vector<int>& prices)\\n    {\\n        if(i>=prices.size())\\n            return 0;\\n        \\n        if(dp[i][hold]!=-1)\\n            return dp[i][hold];\\n        \\n        // 1 indicates we have stock currently\\n        // 0 indicates no stock is possesed currently\\n        \\n        if(hold==1)//sell or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,0,prices)+prices[i],recurs(i+1,1,prices));\\n        }\\n        if(hold==0)//buy or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,1,prices)-prices[i],recurs(i+1,0,prices));\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return recurs(0,0,prices);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39441,
                "title": "a-simple-solution-with-o-n-time-and-o-1-space",
                "content": " //now we try to improve the solution above.\\n        //(a[i]-a[i-1])+(a[i-1]-a[i-2])=a[i]-a[i-2] which is the profits created by i and i-2\\n        //so we travel from the end of the array and continually calculate the differece of i and i-1,\\n        //we only sum those positive profits then the final results is the maximum profits\\n\\n        if(prices.size()==0|| prices.size()==1) return 0;\\n        int max_pro=0;\\n        for(int i=prices.size()-1;i>0;i--){\\n            if(prices[i]-prices[i-1]>0) max_pro+=prices[i]-prices[i-1];\\n        }\\n        return max_pro;",
                "solutionTags": [],
                "code": " //now we try to improve the solution above.\\n        //(a[i]-a[i-1])+(a[i-1]-a[i-2])=a[i]-a[i-2] which is the profits created by i and i-2\\n        //so we travel from the end of the array and continually calculate the differece of i and i-1,\\n        //we only sum those positive profits then the final results is the maximum profits\\n\\n        if(prices.size()==0|| prices.size()==1) return 0;\\n        int max_pro=0;\\n        for(int i=prices.size()-1;i>0;i--){\\n            if(prices[i]-prices[i-1]>0) max_pro+=prices[i]-prices[i-1];\\n        }\\n        return max_pro;",
                "codeTag": "Unknown"
            },
            {
                "id": 2966220,
                "title": "2-solutions-0-ms-1ms-2-different-approaches-explained-super-easy-java",
                "content": "# Explaination for Approach 2 : (Peak Valley Approach)\\n```\\nSay the given array is:\\n\\n[7, 1, 5, 3, 6, 4].\\n\\nIf we plot the numbers of the given array on a graph, we get:\\n```\\n![122_maxprofit_1.png](https://assets.leetcode.com/users/images/7521e81c-818b-4eab-8a4c-b544838ffb13_1672298793.4726715.png)\\n# Mathematically speaking:\\n```\\nTotalProfit =\\u2211i(height(peaki)\\u2212height(valleyi)).\\n```\\n---\\n\\n```\\nThe key point is we need to consider every peak immediately \\nfollowing a valley to maximize the profit. In case we skip one \\nof the peaks (trying to obtain more profit), we will end up \\nlosing the profit over one of the transactions leading to an overall \\nlesser profit.\\n\\nFor example, in the above case, if we skip peakipeaki\\u200B and valleyj\\n trying to obtain more profit by considering points with more \\ndifference in heights, the net profit obtained will always be \\nlesser than the one obtained by including them, since C will \\nalways be lesser than A+B.\\n```\\n\\n\\n# Request \\uD83D\\uDE0A :\\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [0 ms] approach).\\n```\\n\\n# Approach 1 : 1ms Solution\\n```\\nclass Solution \\n{\\n\\tint maxProfit(int[] prices) //basic approach\\n    {\\n        int maximumProfit = 0;\\n        for (int i = 1; i < prices.length; i++) \\n        {\\n            if (prices[i] > prices[i - 1])\\n                maximumProfit += prices[i] - prices[i - 1];\\n        }\\n        return maximumProfit;\\n\\t}\\n}\\n```\\n# Approach 2 : 0ms Solution [Fastest]\\n```\\nclass Solution \\n{\\n\\tint maxProfit(int[] prices) //peak valley approach\\n    {\\n        int i=0;\\n        int peak=prices[0];\\n        int valley=prices[0];\\n        int maxProfit=0;\\n        while(i<prices.length-1)\\n        {\\n            while(i<prices.length-1 && prices[i]>=prices[i+1])\\n                i++;\\n            valley=prices[i];\\n            while(i<prices.length-1 && prices[i+1]>=prices[i])\\n                i++;//post fix use \\n            peak=prices[i];\\n            maxProfit+=peak-valley;\\n        }\\n        return maxProfit;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nSay the given array is:\\n\\n[7, 1, 5, 3, 6, 4].\\n\\nIf we plot the numbers of the given array on a graph, we get:\\n```\n```\\nTotalProfit =\\u2211i(height(peaki)\\u2212height(valleyi)).\\n```\n```\\nThe key point is we need to consider every peak immediately \\nfollowing a valley to maximize the profit. In case we skip one \\nof the peaks (trying to obtain more profit), we will end up \\nlosing the profit over one of the transactions leading to an overall \\nlesser profit.\\n\\nFor example, in the above case, if we skip peakipeaki\\u200B and valleyj\\n trying to obtain more profit by considering points with more \\ndifference in heights, the net profit obtained will always be \\nlesser than the one obtained by including them, since C will \\nalways be lesser than A+B.\\n```\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [0 ms] approach).\\n```\n```\\nclass Solution \\n{\\n\\tint maxProfit(int[] prices) //basic approach\\n    {\\n        int maximumProfit = 0;\\n        for (int i = 1; i < prices.length; i++) \\n        {\\n            if (prices[i] > prices[i - 1])\\n                maximumProfit += prices[i] - prices[i - 1];\\n        }\\n        return maximumProfit;\\n\\t}\\n}\\n```\n```\\nclass Solution \\n{\\n\\tint maxProfit(int[] prices) //peak valley approach\\n    {\\n        int i=0;\\n        int peak=prices[0];\\n        int valley=prices[0];\\n        int maxProfit=0;\\n        while(i<prices.length-1)\\n        {\\n            while(i<prices.length-1 && prices[i]>=prices[i+1])\\n                i++;\\n            valley=prices[i];\\n            while(i<prices.length-1 && prices[i+1]>=prices[i])\\n                i++;//post fix use \\n            peak=prices[i];\\n            maxProfit+=peak-valley;\\n        }\\n        return maxProfit;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542036,
                "title": "c-solution-in-easy-way-valley-peak-approach-explained",
                "content": "\\n\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Valley Peak Approach.***\\n- As we need maximum profit so we can compare prices between 2 days!\\n- If the next day price is greater than the current day, we\\'ll buy it and sell it the next day!\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- Same as 1, but here we\\u2019ll store previous value in ***mn***.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n= prices.size(), profit=0;\\n        for(int i=1; i<n; i++){\\n            if(prices[i]>prices[i-1])\\n                profit += prices[i]-prices[i-1];\\n        }\\n        return profit;\\n    }\\n};\\n\\n//Solution 02: \\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size(), profit=0;\\n        int mn=prices[0];\\n        \\n        for(int i=1; i<n; i++){\\n            if(mn<prices[i]){\\n                profit += prices[i]-mn;\\n            }\\n            mn = prices[i];\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n= prices.size(), profit=0;\\n        for(int i=1; i<n; i++){\\n            if(prices[i]>prices[i-1])\\n                profit += prices[i]-prices[i-1];\\n        }\\n        return profit;\\n    }\\n};\\n\\n//Solution 02: \\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size(), profit=0;\\n        int mn=prices[0];\\n        \\n        for(int i=1; i<n; i++){\\n            if(mn<prices[i]){\\n                profit += prices[i]-mn;\\n            }\\n            mn = prices[i];\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39565,
                "title": "shortest-one-liners-in-ruby-python",
                "content": "**Idea**\\n\\nYou can do it on a day-to-day basis. If buying on day 1 and selling on day 2 is profitable, do it. If buying on day 2 and selling on day 3 is profitable, do it. And so on. Yes, you can do **both** day1-to-day2 **and** day2-to-day3, even though there are multiple transactions on day 2. Either think of it as selling first and then buying later on that day, or think of it as **keeping** instead of selling+buying.\\n\\n---\\n\\n**Ruby**\\n\\nRuby has the fabulicious `each_cons` and doesn't need a `return`.\\n\\n    def max_profit(prices)\\n        s=0;prices.each_cons(2){|a,b|b>a&&s+=b-a};s\\n    end\\n\\nOr as a single expression:\\n\\n    def max_profit(prices)\\n        prices.each_cons(2).reduce(0){|s,(a,b)|s+[b-a,0].max}\\n    end\\n\\nOr:\\n\\n    def max_profit(prices)\\n        prices.each_cons(2).reduce(0){|s,(a,b)|b>a ?s+b-a :s}\\n    end\\n\\n---\\n\\n**Python**\\n\\nPython's `zip` is also quite nice, and you can give it lists of different sizes, which none of the similar solutions I've seen from others exploited.\\n\\n    def maxProfit(self, prices):\\n        return sum(b-a for a,b in zip(prices,prices[1:])if b>a)\\n\\nOr:\\n\\n    def maxProfit(self, prices):\\n        return sum(max(b-a,0)for a,b in zip(prices,prices[1:]))",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "**Idea**\\n\\nYou can do it on a day-to-day basis. If buying on day 1 and selling on day 2 is profitable, do it. If buying on day 2 and selling on day 3 is profitable, do it. And so on. Yes, you can do **both** day1-to-day2 **and** day2-to-day3, even though there are multiple transactions on day 2. Either think of it as selling first and then buying later on that day, or think of it as **keeping** instead of selling+buying.\\n\\n---\\n\\n**Ruby**\\n\\nRuby has the fabulicious `each_cons` and doesn't need a `return`.\\n\\n    def max_profit(prices)\\n        s=0;prices.each_cons(2){|a,b|b>a&&s+=b-a};s\\n    end\\n\\nOr as a single expression:\\n\\n    def max_profit(prices)\\n        prices.each_cons(2).reduce(0){|s,(a,b)|s+[b-a,0].max}\\n    end\\n\\nOr:\\n\\n    def max_profit(prices)\\n        prices.each_cons(2).reduce(0){|s,(a,b)|b>a ?s+b-a :s}\\n    end\\n\\n---\\n\\n**Python**\\n\\nPython's `zip` is also quite nice, and you can give it lists of different sizes, which none of the similar solutions I've seen from others exploited.\\n\\n    def maxProfit(self, prices):\\n        return sum(b-a for a,b in zip(prices,prices[1:])if b>a)\\n\\nOr:\\n\\n    def maxProfit(self, prices):\\n        return sum(max(b-a,0)for a,b in zip(prices,prices[1:]))",
                "codeTag": "Python3"
            },
            {
                "id": 564672,
                "title": "python-time-o-n-space-o-1-easy-to-understand-solutions",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        for i in range(1, len(prices)):\\n            profit += max(prices[i]-prices[i-1], 0)\\n        return profit\\n```\\nOne-liner for fun\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        return sum(max(prices[i]-prices[i-1], 0) for i in range(1, len(prices)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        for i in range(1, len(prices)):\\n            profit += max(prices[i]-prices[i-1], 0)\\n        return profit\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        return sum(max(prices[i]-prices[i-1], 0) for i in range(1, len(prices)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354753,
                "title": "dp-bottom-up-o-n",
                "content": "This approach involves solving subproblems from length 1 to length n. Here we represent subproblem as dp(i) which indicates maximum profit made till ith day. \\nResults for subproblem is based on following recurrence.\\n\\n`dp(i) = dp(i-1) + price(i) - price(i-1)`\\n`dp(0) = 0,  zero profit for first day (this is a base case)`\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] dp = new int[n];\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            dp[i] = dp[i-1] + Math.max(0,prices[i]-prices[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] dp = new int[n];\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            dp[i] = dp[i-1] + Math.max(0,prices[i]-prices[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278953,
                "title": "another-view-to-the-problem-in-a-dp-way",
                "content": "If we want to get max profit on day N, it can be broken down into two cases:\\n1. if the last operation during day 1 to day N - 1 is sell, we keep current profit and do nothing, then max_profit on day N = max profit on day N - 1\\n2. if the last operation during day 1 to day N - 1 is buy, we sell it on day N to maximize profit, then max_profit on day N = max profit on day N - 1 + prices[N]\\n3. Hence, max_profit on day N = max(answers of #1 and #2)\\n\\nSo this can form a recursive structure that can be solved using DP.\\n\\n```\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.empty()) return 0;\\n        // dynamic programing tables (The arrays are not really necessary. just keep them so the original DP is easier to understand)\\n        vector<int> max_profit_last_op_is_sell(prices.size());\\n        vector<int> max_profit_last_op_is_buy(prices.size());\\n\\n        // boundary condition on the first day\\n        max_profit_last_op_is_sell[0] = 0;\\n        max_profit_last_op_is_buy[0] = -prices[0];\\n        for(int i = 1; i < prices.size(); ++i) {\\n\\n            // max profit we can get on day i if the last operation during day 0 to i - 1 is sell\\n            max_profit_last_op_is_sell[i] = max(\\n                max_profit_last_op_is_sell[i - 1],  // do nothing on day i and keep current profit\\n                max_profit_last_op_is_buy[i - 1] + prices[i]  // sell on day i\\n            );\\n\\n            // max profit we can get on day i if the last operation during day 0 to i - 1 is buy\\n            max_profit_last_op_is_buy[i] = max(\\n                max_profit_last_op_is_buy[i - 1], // do nothing on day i and keep current profit\\n                max_profit_last_op_is_sell[i - 1] - prices[i] // buy on day i\\n            );\\n        }\\n\\n        return max(\\n            // if the last operation before day N is buy, then we sell on day N to get max profit\\n            max_profit_last_op_is_buy[prices.size() - 1] + prices[prices.size() - 1],\\n            // if the last operation before day N is sell, then we do nothing to keep current profit\\n            max_profit_last_op_is_sell[prices.size() - 1]\\n        );\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.empty()) return 0;\\n        // dynamic programing tables (The arrays are not really necessary. just keep them so the original DP is easier to understand)\\n        vector<int> max_profit_last_op_is_sell(prices.size());\\n        vector<int> max_profit_last_op_is_buy(prices.size());\\n\\n        // boundary condition on the first day\\n        max_profit_last_op_is_sell[0] = 0;\\n        max_profit_last_op_is_buy[0] = -prices[0];\\n        for(int i = 1; i < prices.size(); ++i) {\\n\\n            // max profit we can get on day i if the last operation during day 0 to i - 1 is sell\\n            max_profit_last_op_is_sell[i] = max(\\n                max_profit_last_op_is_sell[i - 1],  // do nothing on day i and keep current profit\\n                max_profit_last_op_is_buy[i - 1] + prices[i]  // sell on day i\\n            );\\n\\n            // max profit we can get on day i if the last operation during day 0 to i - 1 is buy\\n            max_profit_last_op_is_buy[i] = max(\\n                max_profit_last_op_is_buy[i - 1], // do nothing on day i and keep current profit\\n                max_profit_last_op_is_sell[i - 1] - prices[i] // buy on day i\\n            );\\n        }\\n\\n        return max(\\n            // if the last operation before day N is buy, then we sell on day N to get max profit\\n            max_profit_last_op_is_buy[prices.size() - 1] + prices[prices.size() - 1],\\n            // if the last operation before day N is sell, then we do nothing to keep current profit\\n            max_profit_last_op_is_sell[prices.size() - 1]\\n        );\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1336030,
                "title": "c-optimal-solution-time-o-n-auxiliary-space-o-1",
                "content": "\\t\\t\\t\\t   7\\n \\t\\t\\t\\t\\t\\\\     5    6 \\n \\t\\t\\t\\t\\t \\\\    /\\\\  /\\\\\\n \\t\\t\\t\\t\\t  \\\\  /  \\\\/  4 --------->[7,1,5,3,6,4]\\n \\t\\t\\t\\t\\t   \\\\/\\t3\\t\\t  \\n                       1\\n\\t\\t\\t\\t\\t   \\n**Valley to Peak approach : Add all gains from positive slopes i.e. profit = (5-1) + (6-3) = 7**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\t\\t// Optimal Solution Time O(N) & Auxiliary Space O(1)\\n        int res = 0;\\n        for (int i = 1; i < prices.size(); ++i)\\n            res += max(prices[i] - prices[i - 1], 0);\\n        return res;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\t\\t// Optimal Solution Time O(N) & Auxiliary Space O(1)\\n        int res = 0;\\n        for (int i = 1; i < prices.size(); ++i)\\n            res += max(prices[i] - prices[i - 1], 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39479,
                "title": "reduction-to-greedy-from-dp",
                "content": "This is not the canonical solution, but just wanted to post a DP to greedy reduction since we are always making the greedy choice. At any given day, the max gain includes the current day or it is the gain from the previous day. If it includes the current day `i` (i.e., sell) then identify a `j` such that we make a profit between `j` and `i` in addition to profit at `j`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        vector<int> G(prices.size(), 0);\\n        for (int i = 1; i < prices.size(); ++i) {\\n            int g = G[i - 1];\\n            for (int j = 0; j < i; ++j) {\\n                if (prices[i] > prices[j]) {\\n                    g = max(g, G[j] + prices[i] - prices[j]);\\n                }\\n            }\\n            G[i] = g;\\n        }\\n        return G[prices.size() - 1];\\n    }\\n};\\n```\\n\\nAfter eliminating the greedy choice... i.e., inner loop is making the greedy choice.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        vector<int> G(prices.size(), 0);\\n        int maxM = -prices[0];\\n        for (int i = 1; i < prices.size(); ++i) {\\n            G[i] = max(G[i - 1], maxM + prices[i]);\\n            maxM = max(G[i] - prices[i], maxM);\\n        }\\n        return G[prices.size() - 1];\\n    }\\n};\\n```\\n\\nAfter reducing the space on G.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        int maxM = -prices[0];\\n        int gi = 0;\\n        for (int i = 1; i < prices.size(); ++i) {\\n            gi = max(gi, maxM + prices[i]);\\n            maxM = max(gi - prices[i], maxM);\\n        }\\n        return gi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        vector<int> G(prices.size(), 0);\\n        for (int i = 1; i < prices.size(); ++i) {\\n            int g = G[i - 1];\\n            for (int j = 0; j < i; ++j) {\\n                if (prices[i] > prices[j]) {\\n                    g = max(g, G[j] + prices[i] - prices[j]);\\n                }\\n            }\\n            G[i] = g;\\n        }\\n        return G[prices.size() - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        vector<int> G(prices.size(), 0);\\n        int maxM = -prices[0];\\n        for (int i = 1; i < prices.size(); ++i) {\\n            G[i] = max(G[i - 1], maxM + prices[i]);\\n            maxM = max(G[i] - prices[i], maxM);\\n        }\\n        return G[prices.size() - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        int maxM = -prices[0];\\n        int gi = 0;\\n        for (int i = 1; i < prices.size(); ++i) {\\n            gi = max(gi, maxM + prices[i]);\\n            maxM = max(gi - prices[i], maxM);\\n        }\\n        return gi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39582,
                "title": "quite-easy-share-my-c-code-with-explanation",
                "content": "###1. Calculate `prices[i+1]-prices[i]`\\n\\n###2. Turn the array `prices[] = [1,2,4,2,5,7,2,4,9,0]` into \\n`difference[] = [+1,+2,-2,+3,+2,-5,+2,+5,-9]`\\n\\n###3. Then add all positive numbers `sum = 1+2+3+2+2+5 = 15` in difference\\n###4. Return `15`\\n\\n\\n*The code is a simplified and optimized version.*\\n\\n#Code:\\n\\n    int maxProfit(int prices[], int n){\\n        int profit = 0;\\n        for(int i=0;i<n-1;i++){\\n            int temp = prices[i+1]-prices[i];\\n            if(temp>0)\\n                profit += temp;\\n        }\\n        return profit;\\n    }",
                "solutionTags": [],
                "code": "###1. Calculate `prices[i+1]-prices[i]`\\n\\n###2. Turn the array `prices[] = [1,2,4,2,5,7,2,4,9,0]` into \\n`difference[] = [+1,+2,-2,+3,+2,-5,+2,+5,-9]`\\n\\n###3. Then add all positive numbers `sum = 1+2+3+2+2+5 = 15` in difference\\n###4. Return `15`\\n\\n\\n*The code is a simplified and optimized version.*\\n\\n#Code:\\n\\n    int maxProfit(int prices[], int n){\\n        int profit = 0;\\n        for(int i=0;i<n-1;i++){\\n            int temp = prices[i+1]-prices[i];\\n            if(temp>0)\\n                profit += temp;\\n        }\\n        return profit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 582462,
                "title": "122-javascript-solution-explained-with-time-travel",
                "content": "This is the best way I could think of to make it easy to understand.\\nI think meaningful variable names are important for easy understanding.\\nAnd I think \"yesterday and today\" is easier to understand than \"today and tomorrow\".\\nBecause time travel is something we all dream about.\\n\\n> Runtime: **68 ms**, faster than *32.11%* of JavaScript online submissions\\n> Memory Usage: **36.6 MB**, less than *23.81%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * You have a time travel machine that can only go back 1 day.\\n * You will use it to exploit the stock market.\\n * But somehow had infinite money to start with. (Whatever.)\\n *\\n * @param {number[]} prices\\n * @return {number}\\n */\\nconst maxProfit = prices => {\\n  // Start with nothing and take every profitable opportunity from time travel\\n  let profit = 0;\\n  // Start from the second day (because that is the first day you could sell)\\n  for (let i = 1; i < prices.length; i++) {\\n    // Our Delorean only goes back 1 day, but that is all we need\\n    const [priceYesterday, priceToday] = [prices[i - 1], prices[i]];\\n    // Whenever there is profit, engage that Flux Capacitor!\\n    if (priceYesterday < priceToday) profit += priceToday - priceYesterday;\\n    // Buy yesterday; sell today\\n  }\\n  // Take every Monday off!\\n  return profit;\\n  // Time travel trading makes every weekend is a three-day weekend!\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * You have a time travel machine that can only go back 1 day.\\n * You will use it to exploit the stock market.\\n * But somehow had infinite money to start with. (Whatever.)\\n *\\n * @param {number[]} prices\\n * @return {number}\\n */\\nconst maxProfit = prices => {\\n  // Start with nothing and take every profitable opportunity from time travel\\n  let profit = 0;\\n  // Start from the second day (because that is the first day you could sell)\\n  for (let i = 1; i < prices.length; i++) {\\n    // Our Delorean only goes back 1 day, but that is all we need\\n    const [priceYesterday, priceToday] = [prices[i - 1], prices[i]];\\n    // Whenever there is profit, engage that Flux Capacitor!\\n    if (priceYesterday < priceToday) profit += priceToday - priceYesterday;\\n    // Buy yesterday; sell today\\n  }\\n  // Take every Monday off!\\n  return profit;\\n  // Time travel trading makes every weekend is a three-day weekend!\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524020,
                "title": "c-java-python-javascript-simple-code-easy-to-understand",
                "content": "# Intuition:\\nThe intuition behind this approach is to find all the local minima and maxima in the given array of prices. We buy the stock at the local minima and sell it at the corresponding local maxima. By doing this, we can accumulate the maximum profit.\\n\\n# Approach:\\n1. Initialize the variables `profit` and `minPrice` to 0 and `INT_MAX` respectively.\\n2. Iterate through the prices array using a for loop.\\n3. For each price at index `i`:\\n   a. Update the `minPrice` by taking the minimum of the current `minPrice` and `prices[i]`.\\n   b. If the difference between `prices[i]` and `minPrice` is greater than 0, it means there is a profit to be made.\\n      - Add this profit to the `profit` variable.\\n      - Update the `minPrice` to `prices[i]` since we have sold the stock at this price.\\n4. Return the `profit`.\\n\\n# Complexity:\\n- The time complexity of this approach is O(n), where n is the size of the prices array, since we iterate through the array once.\\n- The space complexity is O(1) as we are using a constant amount of extra space to store the `profit` and `minPrice` variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minPrice=INT_MAX;\\n        for(int i=0;i<prices.size();i++){\\n            minPrice = min(minPrice,prices[i]);\\n                if((prices[i]-minPrice)>0){\\n                    profit=profit+(prices[i]-minPrice);\\n                    minPrice=prices[i];\\n                }\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int minPrice = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(minPrice, prices[i]);\\n            if (prices[i] - minPrice > 0) {\\n                profit += prices[i] - minPrice;\\n                minPrice = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        minPrice = float(\\'inf\\')\\n        for price in prices:\\n            minPrice = min(minPrice, price)\\n            if price - minPrice > 0:\\n                profit += price - minPrice\\n                minPrice = price\\n        return profit\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar maxProfit = function(prices){\\n    let profit = 0;\\n    let minPrice = Infinity;\\n    for (let i = 0; i < prices.length; i++) {\\n        minPrice = Math.min(minPrice, prices[i]);\\n        if (prices[i] - minPrice > 0) {\\n            profit += prices[i] - minPrice;\\n            minPrice = prices[i];\\n        }\\n    }\\n    return profit;\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minPrice=INT_MAX;\\n        for(int i=0;i<prices.size();i++){\\n            minPrice = min(minPrice,prices[i]);\\n                if((prices[i]-minPrice)>0){\\n                    profit=profit+(prices[i]-minPrice);\\n                    minPrice=prices[i];\\n                }\\n        }\\n        return profit;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int minPrice = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(minPrice, prices[i]);\\n            if (prices[i] - minPrice > 0) {\\n                profit += prices[i] - minPrice;\\n                minPrice = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        minPrice = float(\\'inf\\')\\n        for price in prices:\\n            minPrice = min(minPrice, price)\\n            if price - minPrice > 0:\\n                profit += price - minPrice\\n                minPrice = price\\n        return profit\\n\\n```\n```\\nvar maxProfit = function(prices){\\n    let profit = 0;\\n    let minPrice = Infinity;\\n    for (let i = 0; i < prices.length; i++) {\\n        minPrice = Math.min(minPrice, prices[i]);\\n        if (prices[i] - minPrice > 0) {\\n            profit += prices[i] - minPrice;\\n            minPrice = prices[i];\\n        }\\n    }\\n    return profit;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437135,
                "title": "c-easy-to-understand-recursion-memoization-tabulation-space-optimization",
                "content": "\\u27A1\\uFE0F Recursion\\n```\\n     int solve(vector<int>& prices,int index,int buy){\\n        if(index==prices.size()) return 0;\\n        int profit=0;\\n        if(buy){\\n            int buykaro=(-prices[index])+solve(prices,index+1,0);\\n            int skipkaro= 0 + solve(prices,index+1,1);\\n            profit=max(buykaro,skipkaro);\\n        }else{\\n            int sellkaro=(prices[index])+solve(prices,index+1,1);\\n            int skipkaro= 0 + solve(prices,index+1,0);\\n            profit=max(sellkaro,skipkaro);\\n        }\\n        return profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n         return solve(prices,0,1);\\n    }\\n```\\n\\u27A1\\uFE0F Memoization\\n\\n```\\n    int solveMem(vector<int>&prices,int index,int buy,vector<vector<int>>&dp){\\n        if(index==prices.size()) return 0;\\n        if(dp[index][buy]!=-1) return dp[index][buy];\\n        int profit=0;\\n        if(buy){\\n            int buykaro=(-prices[index])+solveMem(prices,index+1,0,dp);\\n            int skipkaro= 0 + solveMem(prices,index+1,1,dp);\\n            profit=max(buykaro,skipkaro);\\n        }else{\\n            int sellkaro=(prices[index])+solveMem(prices,index+1,1,dp);\\n            int skipkaro= 0 + solveMem(prices,index+1,0,dp);\\n            profit=max(sellkaro,skipkaro);\\n        }\\n        return dp[index][buy]=profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n         int n=prices.size();\\n         vector<vector<int>>dp(n,vector<int>(2,-1));\\n         return solveMem(prices,0,1,dp);\\n    }\\n```\\n\\u27A1\\uFE0F Tabulation\\n\\n```\\n        int solveTab(vector<int>&prices){\\n        int n=prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n           int profit=0;\\n           if(buy){\\n            int buykaro=(-prices[index])+dp[index+1][0];\\n            int skipkaro= 0 + dp[index+1][1];\\n            profit=max(buykaro,skipkaro);\\n           }else{\\n            int sellkaro=(prices[index])+dp[index+1][1];\\n            int skipkaro= 0 + dp[index+1][0];\\n            profit=max(sellkaro,skipkaro);\\n            }\\n             dp[index][buy]=profit;\\n           }\\n        }\\n        return dp[0][1];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveTab(prices);\\n    }\\n```\\n\\u27A1\\uFE0F Space Optimization\\n\\n```\\nint solveOpt(vector<int>& prices){\\n        int n=prices.size();\\n        vector<int>curr(2,0);\\n        vector<int>next(2,0);\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n           int profit=0;\\n           if(buy){\\n            int buykaro=(-prices[index])+next[0];\\n            int skipkaro= 0 + next[1];\\n            profit=max(buykaro,skipkaro);\\n           }else{\\n            int sellkaro=(prices[index])+next[1];\\n            int skipkaro= 0 + next[0];\\n            profit=max(sellkaro,skipkaro);\\n            }\\n             curr[buy]=profit;\\n           }\\n           next=curr;\\n        }\\n        return next[1];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveOpt(prices);\\n    }\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\n     int solve(vector<int>& prices,int index,int buy){\\n        if(index==prices.size()) return 0;\\n        int profit=0;\\n        if(buy){\\n            int buykaro=(-prices[index])+solve(prices,index+1,0);\\n            int skipkaro= 0 + solve(prices,index+1,1);\\n            profit=max(buykaro,skipkaro);\\n        }else{\\n            int sellkaro=(prices[index])+solve(prices,index+1,1);\\n            int skipkaro= 0 + solve(prices,index+1,0);\\n            profit=max(sellkaro,skipkaro);\\n        }\\n        return profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n         return solve(prices,0,1);\\n    }\\n```\n```\\n    int solveMem(vector<int>&prices,int index,int buy,vector<vector<int>>&dp){\\n        if(index==prices.size()) return 0;\\n        if(dp[index][buy]!=-1) return dp[index][buy];\\n        int profit=0;\\n        if(buy){\\n            int buykaro=(-prices[index])+solveMem(prices,index+1,0,dp);\\n            int skipkaro= 0 + solveMem(prices,index+1,1,dp);\\n            profit=max(buykaro,skipkaro);\\n        }else{\\n            int sellkaro=(prices[index])+solveMem(prices,index+1,1,dp);\\n            int skipkaro= 0 + solveMem(prices,index+1,0,dp);\\n            profit=max(sellkaro,skipkaro);\\n        }\\n        return dp[index][buy]=profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n         int n=prices.size();\\n         vector<vector<int>>dp(n,vector<int>(2,-1));\\n         return solveMem(prices,0,1,dp);\\n    }\\n```\n```\\n        int solveTab(vector<int>&prices){\\n        int n=prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n           int profit=0;\\n           if(buy){\\n            int buykaro=(-prices[index])+dp[index+1][0];\\n            int skipkaro= 0 + dp[index+1][1];\\n            profit=max(buykaro,skipkaro);\\n           }else{\\n            int sellkaro=(prices[index])+dp[index+1][1];\\n            int skipkaro= 0 + dp[index+1][0];\\n            profit=max(sellkaro,skipkaro);\\n            }\\n             dp[index][buy]=profit;\\n           }\\n        }\\n        return dp[0][1];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveTab(prices);\\n    }\\n```\n```\\nint solveOpt(vector<int>& prices){\\n        int n=prices.size();\\n        vector<int>curr(2,0);\\n        vector<int>next(2,0);\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n           int profit=0;\\n           if(buy){\\n            int buykaro=(-prices[index])+next[0];\\n            int skipkaro= 0 + next[1];\\n            profit=max(buykaro,skipkaro);\\n           }else{\\n            int sellkaro=(prices[index])+next[1];\\n            int skipkaro= 0 + next[0];\\n            profit=max(sellkaro,skipkaro);\\n            }\\n             curr[buy]=profit;\\n           }\\n           next=curr;\\n        }\\n        return next[1];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveOpt(prices);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258316,
                "title": "best-3-lines-of-code-easiest-solution-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int maxprofit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] > prices[i - 1])\\n                maxprofit += prices[i] - prices[i - 1];\\n        } return maxprofit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int maxprofit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] > prices[i - 1])\\n                maxprofit += prices[i] - prices[i - 1];\\n        } return maxprofit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040292,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] dp = new int[n];\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            dp[i] = dp[i-1] + Math.max(0,prices[i]-prices[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        auto [_, finalNotHold] = trade( prices.size()-1, prices );\\n        \\n        // Max profit must come from notHold state finally.\\n        return finalNotHold;\\n    }\\n    \\n    tuple<int, int> trade(int day, vector<int>& prices){\\n        \\n        if( day == 0 ){\\n            \\n            // Hold on day_0 = buy at day_#0 = -prices[0]\\n            // Not hold on day_0 = do nothing = 0            \\n            return tuple<int, int>{ -prices[0], 0};\\n        }\\n        \\n        auto [prevHold, prevNotHold] = trade( day - 1, prices );\\n        \\n        // either keep hold, or buy in stock today at stock price\\n        int curHold = max( prevHold, prevNotHold - prices[ day ] );\\n\\n        // either keep not-hold, or sell out stock today at stock price\\n        int curNotHold = max( prevNotHold, prevHold + prices[ day ] );        \\n        \\n        return tuple<int, int>{ curHold, curNotHold};\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        @cache\\n        def trade(day_d):\\n            \\n            if day_d == 0:\\n                \\n                # Hold on day_#0 = buy stock at the price of day_#0\\n                # Not-hold on day_#0 = doing nothing on day_#0\\n                return -prices[day_d], 0\\n            \\n            prev_hold, prev_not_hold = trade(day_d-1)\\n            \\n            hold = max(prev_hold, prev_not_hold - prices[day_d] )\\n            not_hold = max(prev_not_hold, prev_hold + prices[day_d] )\\n            \\n            return hold, not_hold\\n        \\n        # --------------------------------------------------\\n        last_day= len(prices)-1\\n        \\n        # Max profit must come from not_hold state (i.e., no stock position) on last day\\n        return trade(last_day)[1]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar maxProfit = function (prices) {\\n    let profit = 0;\\n\\n    for (let i = 1; i < prices.length; i++) {\\n        let prev = prices[i - 1];\\n        let current = prices[i];\\n\\n        if (prev < current) {\\n            profit += current - prev;\\n        }\\n    }\\n    \\n    return profit;\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nfun maxProfit(prices: IntArray): Int {\\n        var localMin = -1\\n        var localMax = -1\\n        var result = 0\\n        \\n        prices.forEach{\\n            if(localMin == -1 || (localMax == -1 && it < localMin)){\\n                localMin = it\\n            } else if(it > localMax){\\n                localMax = it\\n            } else {\\n                result += localMax - localMin\\n                localMin = it\\n                localMax = -1\\n            }\\n        }\\n        \\n        if(localMax > 0){\\n            result += localMax - localMin\\n        }\\n        \\n        return result\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var maxProfit = 0\\n        \\n        for i in prices.indices.dropFirst() { \\n            let priceChange = prices[i] - prices[i-1]\\n            if priceChange > 0 { \\n                maxProfit += priceChange\\n            }\\n        }\\n        return maxProfit\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] dp = new int[n];\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            dp[i] = dp[i-1] + Math.max(0,prices[i]-prices[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        auto [_, finalNotHold] = trade( prices.size()-1, prices );\\n        \\n        // Max profit must come from notHold state finally.\\n        return finalNotHold;\\n    }\\n    \\n    tuple<int, int> trade(int day, vector<int>& prices){\\n        \\n        if( day == 0 ){\\n            \\n            // Hold on day_0 = buy at day_#0 = -prices[0]\\n            // Not hold on day_0 = do nothing = 0            \\n            return tuple<int, int>{ -prices[0], 0};\\n        }\\n        \\n        auto [prevHold, prevNotHold] = trade( day - 1, prices );\\n        \\n        // either keep hold, or buy in stock today at stock price\\n        int curHold = max( prevHold, prevNotHold - prices[ day ] );\\n\\n        // either keep not-hold, or sell out stock today at stock price\\n        int curNotHold = max( prevNotHold, prevHold + prices[ day ] );        \\n        \\n        return tuple<int, int>{ curHold, curNotHold};\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        @cache\\n        def trade(day_d):\\n            \\n            if day_d == 0:\\n                \\n                # Hold on day_#0 = buy stock at the price of day_#0\\n                # Not-hold on day_#0 = doing nothing on day_#0\\n                return -prices[day_d], 0\\n            \\n            prev_hold, prev_not_hold = trade(day_d-1)\\n            \\n            hold = max(prev_hold, prev_not_hold - prices[day_d] )\\n            not_hold = max(prev_not_hold, prev_hold + prices[day_d] )\\n            \\n            return hold, not_hold\\n        \\n        # --------------------------------------------------\\n        last_day= len(prices)-1\\n        \\n        # Max profit must come from not_hold state (i.e., no stock position) on last day\\n        return trade(last_day)[1]\\n```\n```\\n```\n```\\n```\n```\\nvar maxProfit = function (prices) {\\n    let profit = 0;\\n\\n    for (let i = 1; i < prices.length; i++) {\\n        let prev = prices[i - 1];\\n        let current = prices[i];\\n\\n        if (prev < current) {\\n            profit += current - prev;\\n        }\\n    }\\n    \\n    return profit;\\n};\\n```\n```\\n```\n```\\n```\n```\\nfun maxProfit(prices: IntArray): Int {\\n        var localMin = -1\\n        var localMax = -1\\n        var result = 0\\n        \\n        prices.forEach{\\n            if(localMin == -1 || (localMax == -1 && it < localMin)){\\n                localMin = it\\n            } else if(it > localMax){\\n                localMax = it\\n            } else {\\n                result += localMax - localMin\\n                localMin = it\\n                localMax = -1\\n            }\\n        }\\n        \\n        if(localMax > 0){\\n            result += localMax - localMin\\n        }\\n        \\n        return result\\n    }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var maxProfit = 0\\n        \\n        for i in prices.indices.dropFirst() { \\n            let priceChange = prices[i] - prices[i-1]\\n            if priceChange > 0 { \\n                maxProfit += priceChange\\n            }\\n        }\\n        return maxProfit\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326823,
                "title": "complete-explanation-of-the-buy-and-sell-stock-problems-using-dp",
                "content": "I will be going over what I have learned while trying to solve these problems. I was initially using `Kadane\\'s algorithm` to do these problems. Infact, completed the first, second, and third **Buy and Sell Stock problems** using Kadane\\'s but the fourth problem gave me a concussion so, I embarked on a journey to learn a framework using which I can solve the complete set of these problems and handle any tweaks that an interviewer might throw at me in the future. I visited a number of resources, watched a number of videos and here is the culmination of everything I have picked so far.\\n\\nThese are all the problems we have in the Buy and Sell Stock set.\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n3. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n4. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n5. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n6. [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n\\nFirst, we will see how we can come up with a framework which we can apply for all the above problems. A framework which is flexible enough to accomodate any tweaks an interviewer might throw at us in the future. *A framework which exhausts all the possible outcomes and then come up with the best solution*. A recursive solution would be exhaustive but we will use \"states\" for exhaustion in these problems. **We will consider each day and see how many possible \"states\" do we have for each day and then find \"choices\" corresponding to each state.**\\n\\n**Let\\'s talk about the constraints first.**\\n1. `Sell` must be after `Buy`.\\n2. `Buy` must be after `Sell`.\\n3.  Limit on the number of transaction(k), `k>0`.\\n\\n**For each day we have three choices.**\\n1. `Buy`.\\n2. `Sell`.\\n3. `Rest`. Which further has two states.\\n\\t a. `Rest after buy`. Here we are holding the stock. We are not selling or buying. We are just resting.\\n\\t b. `Rest after selling`. Here we are not holding any stocks. We are not selling or buying. We are just resting.\\n\\n**Let\\'s talk about the states now.**\\n1. The day we are on i.e `i`.\\n2. The maximum number of allowed transactions i.e `k`.\\n3. The holding state i.e the resting state we talked about before. This is either `1(holding stock)` or `0(not holding stock)`.\\n\\nNow, we can put all the combinations of these states in a 3D matrix like so :\\n\\n```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\\n\\n\\n***For every problem we have to find the `dp[n-1][k][0]`, which is the maximum profit for the maximum number of transactions allowed on the last day.***\\n\\nOne important observation. Why didn\\'t we say **`dp[n-1][k][1]`** instead of saying **`dp[n-1][k][0]`**? because if the resting state `S` is 1, it means we are still holding a stock and the profit cannot be maximum until and unless we are done selling all the stocks we have.\\n\\n\\n\\n\\nNow, let\\'s think about what choices do we have for each state and how we can update the \"state\". Let\\'s write our state transition equations. They will be something like this.\\n\\n`dp[i][k][0] = Max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) // prices is the array of stocks`\\n\\n***This equation corresponds to when you are not holding a stock. You are not holding a stock today because perhaps you didn\\'t have any stocks yesterday which we could sell today or maybe you have stocks that you want to sell today, so at the end of the day we will not be holding any stocks.***\\n\\n`dp[i][k][1] = Max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`\\n\\n***This equation corresponds to when you are holding a stock. You are holding a stock today because perhaps you had stocks yesterday or maybe you want to buy stocks today, so at the end of the day we will be holding stocks.***\\n\\n***This explanation should be clear. If you buy, you need to subtract prices[i] from the profit, and if you sell, you need to increase prices[i] to the profit.***\\n\\n\\nNow, let\\'s talk about the base cases.\\n\\n1. `dp[-1][k][0]  = 0`     **// Because the day starts with 0 and here i is -1**\\n2. `dp[-1][k][1] = -Infinity`  **// Because we can\\'t hold any stocks before the first day**\\n3. `dp[i][0][0] = 0`  **// Because k = 0. There won\\'t be any transactions so the profit will be zero** \\n4. `dp[i][0][1] = -Infinity`  **// Because k = 0. We can\\'t hold any stocks without starting a transaction** \\n\\n\\nSo, to summarize the above base conditions and state transition equations\\n\\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\\n\\n\\nNow, let\\'s begin with the problems.\\n\\n1. ***When k = 1***\\n\\nWe will put k = 1 directly in the state transition equations and see for ourselves.\\n\\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\\n\\nWe can also see that the presence of k when it is 1 does not change the state in any way so, we can simply ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\\n\\nWe can write the solution for it like so:\\n\\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\\n\\n***We can reduce the Space complexity to 0(1) by not constructing the DP matrix as the new state is only related to an adjacent state. So, instead of the DP matrix we can store the states in a single variable. One variable for not holding and one for holding.***\\n\\nCode for that would look something like :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\\n\\n2. ***When k = + Infinity***\\n\\nWhen k is Infinity, k and k-1 are practically the same. We will use that in our state transition equations.\\n\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\\n\\nSince, the presence of k is not really impacting the states, we will ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\\n\\nAnd the solution would look like this : \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n3. ***When k = 2***\\n\\nNow, we need to exhaust the value of k as well. Before this we were ignoring k because it was not impacting our states. We need to hold the states for the second transaction as well along with the first transaction. \\n\\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\\n\\nThe solution would look like this :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\\n\\n\\n4. ***When k = + interger***\\n\\n**Important observation** : A transaction consists of buying and selling, which takes atleast 2 days. Therefore, the effective limit k should not exceed n/2( n is the number of days). If it exceeds, there is no contraint effect which makes k equivalent to +Infinity.\\n\\nThis is the only problem from this set which is a little difficult.\\n\\nSolution would look like this \\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\\n\\n5. ***When k = +Infinity with cooldown***\\n\\nWe must wait one day after selling a stock to continue trading. We can write the state transition equations as :\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\\n\\nCode would look like \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n\\n6. ***When k = +Infinity with transaction fee***\\n\\nSince now we need to pay some fee for each transaction made, the profit after buying or selling the stock on the i-th day should be subtracted by this amount, therefore the new recurrence relations will be either\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\\n\\nCode can we written as  :\\n\\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\nI hope you enjoyed this post.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 948090,
                "title": "java-very-simple-solution-with-explaination",
                "content": "For any given day, if the price is greater than the previous day, we sell it. If the price rises consecutively, then the cumulative addition will automatically reflect in the profit.\\nFor example, 5, 6, 7: The first purchase at 5, and then selling at 7 is equivalent to purchase at 5 and selling at 6, and buying at 6 and again selling at 7. So, 1+1=2 will be the profit. You can take more examples to verify this.\\nNow in case of a dip, we already sold off our stock at the previous high since we use the greedy approach. Now, as the price has dropped, we again consider the latest price as the purchase price to check for profit later. If there is a rise, we sell again. If there is another drop, we didn\\'t buy at the first drop, and are buying at the latest dip.\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length < 2) return 0;\\n        int profit = 0;\\n        for(int i = 1; i < prices.length; i++){\\n            if(prices[i-1] < prices[i]){\\n                profit += prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length < 2) return 0;\\n        int profit = 0;\\n        for(int i = 1; i < prices.length; i++){\\n            if(prices[i-1] < prices[i]){\\n                profit += prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490167,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "\\n# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/5c2c132a-e540-4a18-a577-6797fbe4a44e_1661600269.7165196.png)\\n\\n**T->O(2^n) && S->O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int buy,vector<int>& p,int n){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tif(buy){\\n\\t\\t\\t\\tint buy=-p[i]+f(i+1,0,p,n);\\n\\t\\t\\t\\tint notbuy=f(i+1,1,p,n);\\n\\t\\t\\t\\treturn max(buy,notbuy);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tint sell= p[i]+f(i+1,1,p,n);\\n\\t\\t\\t\\tint notsell=f(i+1,0,p,n);\\n\\t\\t\\t\\treturn max(sell,notsell);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint maxProfit(vector<int>& p){\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\treturn f(0,1,p,n);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method -2 [Memoization]\\t\\n\\n![image](https://assets.leetcode.com/users/images/06275f0c-6fe8-4f3f-b1b0-3b59e3827b04_1661601266.508214.png)\\n\\n**T->O(2 * n) && S->O(2 * n) + O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int buy,vector<int>& p,int n,vector<vector<int>>& dp){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tif(dp[i][buy]!=-1) return dp[i][buy];\\n\\t\\t\\tint pro1=INT_MIN,pro2=INT_MIN;\\n\\t\\t\\tif(buy){\\n\\t\\t\\t\\tint buy=-p[i]+f(i+1,0,p,n,dp);\\n\\t\\t\\t\\tint notbuy=f(i+1,1,p,n,dp);\\n\\t\\t\\t\\tpro1=max(buy,notbuy);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tint sell= p[i]+f(i+1,1,p,n,dp);\\n\\t\\t\\t\\tint notsell=f(i+1,0,p,n,dp);\\n\\t\\t\\t\\tpro2=max(sell,notsell);\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][buy]=max(pro1,pro2);\\n\\t\\t}\\n\\n\\t\\tint maxProfit(vector<int>& p){\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(2,-1));\\n\\t\\t\\treturn f(0,1,p,n,dp);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 3 [Tabulation]\\n![image](https://assets.leetcode.com/users/images/feae764c-e600-4e17-9bd9-009d414230bf_1661603061.6112258.png)\\n\\n**T->O(2 * n) && S->O(2 * n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& p){\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(2,0));\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int buy=0;buy<=1;buy++){\\n\\t\\t\\t\\t\\tint profit;\\n\\t\\t\\t\\t\\tif(buy){\\n\\t\\t\\t\\t\\t\\tint buy=-p[i]+dp[i+1][0];\\n\\t\\t\\t\\t\\t\\tint notbuy=dp[i+1][1];\\n\\t\\t\\t\\t\\t\\tprofit=max(buy,notbuy);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tint sell= p[i]+dp[i+1][1];\\n\\t\\t\\t\\t\\t\\tint notsell=dp[i+1][0];\\n\\t\\t\\t\\t\\t\\tprofit=max(sell,notsell);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[i][buy]=profit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][1];\\n\\t\\t}\\n\\t};\\n\\t\\n# Method  - 4 [SpaceOptimization]\\n\\n![image](https://assets.leetcode.com/users/images/b0b417fe-4d84-4007-a2e6-e413b1277446_1661603341.085726.png)\\n\\n**T->O(2 X n) && S->O(2 X 2)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& p){\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tvector<int> prev(2,0),curr(2,0);\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int buy=0;buy<=1;buy++){\\n\\t\\t\\t\\t\\tint profit;\\n\\t\\t\\t\\t\\tif(buy){\\n\\t\\t\\t\\t\\t\\tint buy=-p[i]+prev[0];\\n\\t\\t\\t\\t\\t\\tint notbuy=prev[1];\\n\\t\\t\\t\\t\\t\\tprofit=max(buy,notbuy);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tint sell= p[i]+prev[1];\\n\\t\\t\\t\\t\\t\\tint notsell=prev[0];\\n\\t\\t\\t\\t\\t\\tprofit=max(sell,notsell);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr[buy]=profit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev[1];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int buy,vector<int>& p,int n){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tif(buy){\\n\\t\\t\\t\\tint buy=-p[i]+f(i+1,0,p,n);\\n\\t\\t\\t\\tint notbuy=f(i+1,1,p,n);\\n\\t\\t\\t\\treturn max(buy,notbuy);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1569789,
                "title": "python-oneliner-solution-explained",
                "content": "Let us first evaluate differences between all adjacent pairs. We are allowed to do as much transactions as we need, it can be seen as if we do as many one day buy/sells as we want. We want to have the biggest profit, so we will choose only positive gains.\\n\\n#### Complexity\\nIt is `O(n)` for time and space. Space can be made `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxProfit(self, nums):\\n        return sum(max(0, x) for x in (y - x for x, y in zip(nums, nums[1:])))\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, nums):\\n        return sum(max(0, x) for x in (y - x for x, y in zip(nums, nums[1:])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739723,
                "title": "python-one-liner-top-100-speed",
                "content": "**Python |  Clean Code + One Liner | Top 100% Speed**\\n\\n**A) Clean Code**\\n\\nThe Solution below is based on the idea that we can buy and sell stocks every time we notice a higher price on the next day. We can see how this works by analyzing different cases:\\n\\n1. **Rising Slope a<b<c:** Here, the optimal solution is to buy stock at price \"a\", and sell it at price \"c\". This solution is respected by our algorithm, since we can see that our transactions would be:  (b-a)+(c-b) = c-a\\n2. **Descending Slope a>b>c:** Here, purchasing (a,b) is never a good idea, since price \"c\" is the best buying point for a new transaction. Our algorithm avoids making transactions that buy at prices (a,b).\\n3. **Equal price a=b=c:** Here, buying or selling has no effect whatsoever, so our algorithm saves system resources by avoiding trades.\\n\\n\\n```\\n# A.1: Clearest Logic\\nclass Solution:\\n    def maxProfit(self, prices):\\n        best = 0\\n        for i in range(1,len(prices)):\\n            if prices[i] > prices[i-1]:\\n                best += prices[i] - prices[i-1]\\n        return best\\n```\\n\\n```\\n# A.2: High Performance (less array accessing)\\nclass Solution:\\n    def maxProfit(self, prices):\\n        best = 0\\n        if prices:\\n            a = prices[0] # last price\\n            for b in prices[1:]:\\n                if b>a:\\n                    best += b - a\\n                a = b\\n        return best\\n```\\n\\n**B) One-Liner**\\nThis version has O(n) space complexity, since an array of micro-transactions is created, but it\\'s highly efficient nonetheless.\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        return sum([ prices[i]-prices[i-1] for i in range(1,len(prices)) if prices[i]>prices[i-1] ])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# A.1: Clearest Logic\\nclass Solution:\\n    def maxProfit(self, prices):\\n        best = 0\\n        for i in range(1,len(prices)):\\n            if prices[i] > prices[i-1]:\\n                best += prices[i] - prices[i-1]\\n        return best\\n```\n```\\n# A.2: High Performance (less array accessing)\\nclass Solution:\\n    def maxProfit(self, prices):\\n        best = 0\\n        if prices:\\n            a = prices[0] # last price\\n            for b in prices[1:]:\\n                if b>a:\\n                    best += b - a\\n                a = b\\n        return best\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        return sum([ prices[i]-prices[i-1] for i in range(1,len(prices)) if prices[i]>prices[i-1] ])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39571,
                "title": "my-1-line-python-solution",
                "content": "The logic is pretty straight, we find all peaks and related bottom elements, then sum all peaks minus all bottoms.\\n\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            return sum([y for x, y, z in zip(prices[0:-1], prices[1:], prices[2:] + [prices[-1]]) if y > x and y >= z]) - sum([y for x, y, z in zip([prices[0]] + prices[0:-2], prices[0:-1], prices[1:]) if y <= x and y < z]) if len(prices) > 0 else 0\\n\\n\\nUPDATE:\\n\\nthis version is more clear and simpler.\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            return sum([y - x for x, y in zip(prices[:-1], prices[1:]) if x < y])",
                "solutionTags": [
                    "Python"
                ],
                "code": "The logic is pretty straight, we find all peaks and related bottom elements, then sum all peaks minus all bottoms.\\n\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            return sum([y for x, y, z in zip(prices[0:-1], prices[1:], prices[2:] + [prices[-1]]) if y > x and y >= z]) - sum([y for x, y, z in zip([prices[0]] + prices[0:-2], prices[0:-1], prices[1:]) if y <= x and y < z]) if len(prices) > 0 else 0\\n\\n\\nUPDATE:\\n\\nthis version is more clear and simpler.\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            return sum([y - x for x, y in zip(prices[:-1], prices[1:]) if x < y])",
                "codeTag": "Java"
            },
            {
                "id": 4053621,
                "title": "beginner-friendly-solution-beats-100",
                "content": "\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for(int i=1;i<prices.length;i++) {\\n            if(prices[i] > prices[i-1]) {\\n                profit += prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```\\n![1271c6fe-345b-4f3d-959e-d13e791111d7_1677726484.8832572.jpeg](https://assets.leetcode.com/users/images/97c10291-2a91-4cc9-b269-93e1b045825b_1694915509.132186.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for(int i=1;i<prices.length;i++) {\\n            if(prices[i] > prices[i-1]) {\\n                profit += prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932152,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the prices.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProfit(_ prices: [Int]) -> Int {\\n        guard !prices.isEmpty else { return 0 }\\n        \\n        var ans = 0\\n        \\n        for i in 1..<prices.count {\\n            guard prices[i] > prices[i - 1] else { continue }\\n            ans += prices[i] - prices[i - 1]\\n        }\\n        \\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the prices.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProfit(_ prices: [Int]) -> Int {\\n        guard !prices.isEmpty else { return 0 }\\n        \\n        var ans = 0\\n        \\n        for i in 1..<prices.count {\\n            guard prices[i] > prices[i - 1] else { continue }\\n            ans += prices[i] - prices[i - 1]\\n        }\\n        \\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109361,
                "title": "c-very-simple-beats-100-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply go through the array and check if next day stock price is high than previous add it your answer .Since we have choice that we can buy or sell at the same day immedaitely as well so we can do that for  all the days where this condition holds ,beacuse in this way we are getting all the profit that can be achieved .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr) {\\n        int profit=0;\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i]<arr[i+1])\\n                profit+=(arr[i+1]-arr[i]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr) {\\n        int profit=0;\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i]<arr[i+1])\\n                profit+=(arr[i+1]-arr[i]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148469,
                "title": "java-solution-easy-to-understand-as-simple-as-it-should-be-o-n",
                "content": "This question may have different approaches, but i am going to explain it in the simplest possible way!!!\\nWe can buy any number of stocks and sell them and also on the same day so, we actually only need to know if the just previous price is lower than the current price, if yes then upgrade the maxProfit , or continue.\\nFor example, if prices=[2,5,1,9,7,8], then,\\nwe will just add the values of (5-2)+(9-1)+(8-7)=3+8+1=12, which is the maximum possible profit, as we have added all possible positive profits...\\nHope this will help you, as I know when explanation is simple to understand sometimes it becomes our motivation...\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int maxProfit=0;\\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i-1]<prices[i]){\\n                maxProfit+=prices[i]-prices[i-1];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}\\n```\\nIf you liked my explanation, please upvote...\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int maxProfit=0;\\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i-1]<prices[i]){\\n                maxProfit+=prices[i]-prices[i-1];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569298,
                "title": "very-easy-to-understand-c-with-explanation-and-examples-with-proof",
                "content": "Thanks in advance for reading.\\n\\nAn Important point to note here in the question is: \"**However, you can buy it then immediately sell it on the same day**.\"\\n\\n\\nso let\\'s see different trends in the prices vector.\\nThe whole prices vector can be divided into segments where each of those segments falls under any one of the below categories.\\nCase 1: it is decreasing (or non-increasing)\\n* Eg : 9 , 5 , 4 , 4, 2 , 1\\n\\n Case 2 : if it is increasing (or non decreasing)\\n*  Eg : 1, 2, 3, 4, 6, 6, 8, 10\\n\\nCase 3: constant (this case can be considered as a part of case 1 or case 2. It doesn\\'t affect the solution). So we don\\'t talk about case 3 separately\\n* Eg : 1, 1, 1, 1, 1, 1\\n\\n\\n# Assumption (let\\'s prove it)\\nNow I propose my assumption that I always sell the stock on (i+1)th day if I buy it on i-th day.\\nAs of now, it\\'s just an assumption. Let\\'s prove it.\\n \\n Case 1:\\n * Eg : 9 , 5 , 4 , 4, 2 , 1\\n Here the best way is not to buy at all. So optimal net profit is zero.\\n So, what if I tell it is equivalent to buy on i-th day  and sell on (i+1)th day if prices[i+1] > prices[i].\\n Since that condition won\\'t be satisfied in this type of segment. Net profit will be zero. \\n (*So Assumption is true for Case 1*)\\n \\n Case 2 :\\n *  Eg : 1, 2, 3, 4, 6, 6, 8, 10\\n Here the optimal way is to buy at 1 and sell at 10. So net profit will be 9.\\n According to my assumption,\\n buy at 1, sell at 2, profit = 1\\n buy at  2, sell at 3, profit = 1.\\n buy at 3, sell at 4, profit = 1\\n buy at 4, sell at 6, profit = 2\\n buy at 6, sell at 8, profit = 2\\n buy at 8, sell at 10, profit = 2\\n So net profit = 9\\n (*So Assumption is true for Case 2*)\\n \\n **Assumption Proved**\\n So my assumption gives the right answer.\\n \\n **Dividing into segments**\\n let the array be [7,1,5,3,6,4]\\n segments will be [7,1] , [1,5] , [5,3] , [3,6] , [6,4] (other ways also possible)\\n \\n \\n if we divide [5, 3, 2, 1, 3, 5] into [5, 3, 2, 1] and [3, 5].\\n Then we will miss the profit that we can get by buying at price 1 and selling at price 3. As they both are in different segments.\\n \\n This is the reason why the last element of the previous segment should be the first element in the next segment, without considering the increasing/decreasing conditions.\\n \\n So best way(for easy implementation) to divide any prices array into segments is dividing into segments of 2 consecutive elements\\n Eg :  let the array be [7,1,5,3,6,4]\\n segments will be [7,1] , [1,5] , [5,3] , [3,6] , [6,4]\\n \\n **Implementation explanation**\\n Traverse through the prices vector from prices[0] to prices[n-2]\\n ```\\n if (prices[i+1] > prices[i])\\n      buy at prices[i], sell at prices[i+1]\\n\\t  ans+=prices[i+1] - prices[i]\\n else\\n\\t do nothing.\\n```\\n which can also be written as ans+=max(prices[i+1]-prices[i],0) ;\\n \\n Below is the code\\n \\n \\n \\n```\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size() , ans = 0 ;\\n\\t\\t\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans+=(max(prices[i+1]-prices[i],0)) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n\\n```\\n\\nupvote if this is helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n if (prices[i+1] > prices[i])\\n      buy at prices[i], sell at prices[i+1]\\n\\t  ans+=prices[i+1] - prices[i]\\n else\\n\\t do nothing.\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size() , ans = 0 ;\\n\\t\\t\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans+=(max(prices[i+1]-prices[i],0)) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39536,
                "title": "simple-4-line-solution-sorry-angie-yunqi-d",
                "content": "    public int maxProfit(int[] prices) {\\n        int result = 0;\\n        for (int i = 1; i < prices.length; i++)\\n            result += Math.max(prices[i] - prices[i - 1], 0);\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int maxProfit(int[] prices) {\\n        int result = 0;\\n        for (int i = 1; i < prices.length; i++)\\n            result += Math.max(prices[i] - prices[i - 1], 0);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3671515,
                "title": "one-single-c-for-loop-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt needs only to sum up differences incr=prices[i]-prices[i-1] if incr>0 for i=1,...\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse one single for-loop to sum up max(prices[i]-prices[i-1], 0). Mathematically speaking\\n$$\\\\sum_{i=1}^{s-1} \\\\max(0,prices[i]-prices[i-1]) $$\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n[https://www.youtube.com/watch?v=sJd7Q0HyyRg](https://www.youtube.com/watch?v=sJd7Q0HyyRg)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0, len=prices.size();\\n        for(int i=1; i<len; i++)\\n        {\\n            profit+=max(prices[i]-prices[i-1],0);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0, len=prices.size();\\n        for(int i=1; i<len; i++)\\n        {\\n            profit+=max(prices[i]-prices[i-1],0);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569135,
                "title": "explanation-from-brute-force-dp-greedy",
                "content": "***Recursive Approach :***\\nThe question says we can buy and sell as many stocks we want, on a condition that we have to sell after each buy.\\n\\n***We have 2 choices at each index:***\\nIf we haven\\'t bought any stock then we have to buy:\\n```\\nWe can either buy or leave that stock i.e. ans = max ( buy, not-buy);\\n```\\nIf we have to sell a stock we can,\\n```\\nans = max (sell, not-sell);\\n```\\n\\n**Recursion Tree**\\n```\\nLet curr be final sum\\n\\n        [7,1,5,3,6,4]\\n\\t\\t  /        \\\\\\n    \\tBuy         Not Buy\\n     (Curr=-7)     (Curr=0)\\n\\t /       \\\\ \\n Sell\\t   Not Sell \\nCurr=-6     Curr=-7\\n\\nII\\'ly the recursion tree will grow\\n```\\n\\nConditions :- We will have a variable for index and buy,\\n```\\nif( buy) ans = max (-nums[i] + solve ( for sell), solve ( forbuy));\\nif( !buy) ans = max (nums[i] + solve (for buy), solve (sell)); \\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&nums,int i,bool buy){   \\n        \\n        if(i>=nums.size()) return 0;\\n        if(buy){   // we can buy at curr index or not buy   \\n            return dp[i][buy]=max(-nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n        else{     //we can sell at curr index or not sell\\n            return dp[i][buy]=max(nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        if(n<2) return 0;\\n        return solve(prices,0,true); \\n    }\\n};\\n```\\n\\n**Complxeity**\\n```\\nTime : O(2^N) // we have two choices at n steps\\nSpace : O(2^N)\\n```\\n\\n***MEMOIZATION***\\n*We can observe repeated number of same recursive calls in this questions, \\nWe can observe two variables in our recursion calls, so we will use memoization with the help of 2-D matrix*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    \\n    int solve(vector<int>&nums,int i,bool buy){   \\n        \\n        if(i>=nums.size()) return 0;\\n        if(dp[i][buy]!=-1) return dp[i][buy];\\n        if(buy){      \\n            return dp[i][buy]=max(-nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n        else{\\n            return dp[i][buy]=max(nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        if(n<2) return 0;\\n        dp.resize(n+1,vector<int>(2,-1));\\n        return solve(prices,0,true); \\n    }\\n};\\n```\\n\\n**Complxeity**\\n```\\nTime : O(N)\\nSpace : O(N)\\n```\\n\\n***Peak Valley Solution (Greedy)***\\nAnother intelligent solution is greedy solution which will solve this question in `O(n) time and O(1) space`\\nAs we know that we can only buy or sell at a certain index (As it is saying that be maximum productive or profitable in current time, don\\'t care about future)\\n\\nWe can vizualize the current stock prices in the form of a graph\\n\\n```\\n[7,1,5,3,6,4]\\n\\n7\\n\\\\               6\\n \\\\       5     /\\\\\\n  \\\\     / \\\\   /  \\\\\\n   \\\\   /   \\\\ /    4\\n    \\\\ /     3\\n\\t 1\\n```\\nAs we can see, if we calculate the maximum profit for every local maxima we observe we can have the maximum profit, eg : `[1->5] [3->6]`\\nSo, in this approach we have simply calculated profit at every local maixima we observe\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>nums[i-1]){\\n                ans+=nums[i]-nums[i-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Complxeity**\\n```\\nTime : O(N)\\nSpace : O(1)\\n```",
                "solutionTags": [],
                "code": "```\\nWe can either buy or leave that stock i.e. ans = max ( buy, not-buy);\\n```\n```\\nans = max (sell, not-sell);\\n```\n```\\nLet curr be final sum\\n\\n        [7,1,5,3,6,4]\\n\\t\\t  /        \\\\\\n    \\tBuy         Not Buy\\n     (Curr=-7)     (Curr=0)\\n\\t /       \\\\ \\n Sell\\t   Not Sell \\nCurr=-6     Curr=-7\\n\\nII\\'ly the recursion tree will grow\\n```\n```\\nif( buy) ans = max (-nums[i] + solve ( for sell), solve ( forbuy));\\nif( !buy) ans = max (nums[i] + solve (for buy), solve (sell)); \\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&nums,int i,bool buy){   \\n        \\n        if(i>=nums.size()) return 0;\\n        if(buy){   // we can buy at curr index or not buy   \\n            return dp[i][buy]=max(-nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n        else{     //we can sell at curr index or not sell\\n            return dp[i][buy]=max(nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        if(n<2) return 0;\\n        return solve(prices,0,true); \\n    }\\n};\\n```\n```\\nTime : O(2^N) // we have two choices at n steps\\nSpace : O(2^N)\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    \\n    int solve(vector<int>&nums,int i,bool buy){   \\n        \\n        if(i>=nums.size()) return 0;\\n        if(dp[i][buy]!=-1) return dp[i][buy];\\n        if(buy){      \\n            return dp[i][buy]=max(-nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n        else{\\n            return dp[i][buy]=max(nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        if(n<2) return 0;\\n        dp.resize(n+1,vector<int>(2,-1));\\n        return solve(prices,0,true); \\n    }\\n};\\n```\n```\\nTime : O(N)\\nSpace : O(N)\\n```\n```\\n[7,1,5,3,6,4]\\n\\n7\\n\\\\               6\\n \\\\       5     /\\\\\\n  \\\\     / \\\\   /  \\\\\\n   \\\\   /   \\\\ /    4\\n    \\\\ /     3\\n\\t 1\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>nums[i-1]){\\n                ans+=nums[i]-nums[i-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nTime : O(N)\\nSpace : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214014,
                "title": "python-solution-with-detailed-explanation-why-it-works",
                "content": "```\\n\\nclass Solution:\\n    def maxProfit(self, prices):\\n\\n        # By drawing out the prices as y, and days as x,\\n        # the graph suggests that we should maximize the profit\\n        # by buying and selling and the two end points of a continuously\\n        # non-decreasing price sequence. But I had trouble proving it.\\n        # NOTE, after doing the proof I realized that the same proof could\\n        # be done on prices. No need to construct a new array\\n\\n        # However, by converting this problem to an equivalent, yet different one,\\n        # I will prove that the above approach is correct.\\n\\n        # Construct an array S with length = len(prices) - 1\\n        # S[i] = prices[i+1] - prices[i].\\n        # Ex: for prices = [7, 1, 5, 3, 6], S = [-6, 4, -2, 3]\\n        # Consider each buy-sell pair (b, s) -- one buys on day \\'b\\', sells on day \\'s\\'\\n        # one obtains a net profit prices[b] - prices[s].\\n        # By definition of S, that is just sum(S[s:b-1])\\n\\n        # The original problem, is looking for a set of buy-sell pairs\\n        # {p1, p2, ..., pn} s.t. pi = (bi, si), and bi < si < bi+1 for i \\u2208 [1, n)\\n        # that maximizes sum(prices[si] - prices[bi] for i \\u2208 [1, n))\\n        \\n        # can be converted into using the same pairs to maximize\\n        # sum(S[si:bi - 1] for i \\u2208 [1, n)).\\n        # Conceptually, this is simply looking for a set of non-overlapping sub-arrays\\n        # from S whose entry sums are maximized.\\n\\n        # We prove that we should simply select all the non-negative entries, and\\n        # combine them with adjacent selected entries into such sub-arrays.\\n\\n        # Proof by contradiction: if there exists any negative entries in the a set of optimal subarrays\\n        # we can simply exclude that entry, and break the subarray in half if necessary.\\n        # The total sum will be higher, since we excluded a negative number. The total sum\\n        # increases. This cannot be an optimal answer.\\n\\n        # Back to the original problem. Selecting positive entries and forming subarrays, \\n        # results in buy-sell pairs (b, s) s.t. prices[b:s] is non-decreasing, \\n        # as the array S represents the difference between adjacent entries.\\n\\n\\n        profit = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                profit += prices[i] - prices[i-1]\\n\\n        return profit\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxProfit(self, prices):\\n\\n        # By drawing out the prices as y, and days as x,\\n        # the graph suggests that we should maximize the profit\\n        # by buying and selling and the two end points of a continuously\\n        # non-decreasing price sequence. But I had trouble proving it.\\n        # NOTE, after doing the proof I realized that the same proof could\\n        # be done on prices. No need to construct a new array\\n\\n        # However, by converting this problem to an equivalent, yet different one,\\n        # I will prove that the above approach is correct.\\n\\n        # Construct an array S with length = len(prices) - 1\\n        # S[i] = prices[i+1] - prices[i].\\n        # Ex: for prices = [7, 1, 5, 3, 6], S = [-6, 4, -2, 3]\\n        # Consider each buy-sell pair (b, s) -- one buys on day \\'b\\', sells on day \\'s\\'\\n        # one obtains a net profit prices[b] - prices[s].\\n        # By definition of S, that is just sum(S[s:b-1])\\n\\n        # The original problem, is looking for a set of buy-sell pairs\\n        # {p1, p2, ..., pn} s.t. pi = (bi, si), and bi < si < bi+1 for i \\u2208 [1, n)\\n        # that maximizes sum(prices[si] - prices[bi] for i \\u2208 [1, n))\\n        \\n        # can be converted into using the same pairs to maximize\\n        # sum(S[si:bi - 1] for i \\u2208 [1, n)).\\n        # Conceptually, this is simply looking for a set of non-overlapping sub-arrays\\n        # from S whose entry sums are maximized.\\n\\n        # We prove that we should simply select all the non-negative entries, and\\n        # combine them with adjacent selected entries into such sub-arrays.\\n\\n        # Proof by contradiction: if there exists any negative entries in the a set of optimal subarrays\\n        # we can simply exclude that entry, and break the subarray in half if necessary.\\n        # The total sum will be higher, since we excluded a negative number. The total sum\\n        # increases. This cannot be an optimal answer.\\n\\n        # Back to the original problem. Selecting positive entries and forming subarrays, \\n        # results in buy-sell pairs (b, s) s.t. prices[b:s] is non-decreasing, \\n        # as the array S represents the difference between adjacent entries.\\n\\n\\n        profit = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                profit += prices[i] - prices[i-1]\\n\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592060,
                "title": "c-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int ans = 0,n=prices.size();\\n        for(int i = 1; i < n; i++){\\n            if(prices[i]>prices[i-1])ans += prices[i]-prices[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int ans = 0,n=prices.size();\\n        for(int i = 1; i < n; i++){\\n            if(prices[i]>prices[i-1])ans += prices[i]-prices[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214590,
                "title": "2-line-c-time-o-n-space-o-1-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       int ans = 0, i = 0, n = prices.size()-1;\\n        for(; i < n; i++){\\n            ans += max(prices[i+1]-prices[i],0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       int ans = 0, i = 0, n = prices.size()-1;\\n        for(; i < n; i++){\\n            ans += max(prices[i+1]-prices[i],0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434293,
                "title": "easy-100-4-line-fully-explained-java-c-python-js-c-python3",
                "content": "Given an integer array prices where prices[i] is the price of a given stock on the ith day.\\nOn each day, decide to buy and/or sell the stock and one can only hold at most one share of the stock at any time. However, buy it then immediately sell it on the same day.\\nFind and return the maximum profit achieve.\\n**Example:**\\n\\t\\t\\t\\t\\t\\tInput: prices = [7,1,5,3,6,4]\\n\\t\\t\\t\\t\\t\\tOutput: 7\\n**Explanation**: \\n\\t\\t\\t\\t\\t\\t\\tBuy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n\\t\\t\\t\\t\\t\\t\\tThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\\n\\t\\t\\t\\t\\t\\t\\tTotal profit is 4 + 3 = 7.\\n\\n# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Best Time to Buy and Sell Stock II.\\nMemory Usage: 42.1 MB, less than 96.76% of Java online submissions for Best Time to Buy and Sell Stock II.\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // Initialize the max profit...\\n        int maximumProfit = 0;\\n        // Traverse all the element through loop...\\n        for(int i=1; i<prices.length; i++) {\\n            // Set the difference so that we can get the max profit...\\n            int diff = prices[i]-prices[i-1];\\n            // If the difference is positive value, add to profit and increse it...\\n            if(diff > 0){\\n                maximumProfit += diff;\\n            }\\n        }\\n        return maximumProfit;      // Return the max profit...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        // Initialize the max profit...\\n        int maximumProfit = 0;\\n        // Traverse all the element through loop...\\n        for (int i = 1; i < prices.size(); i++) {\\n            // check if the price is greater at i...\\n            if (prices[i] > prices[i - 1])\\n                // Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i - 1];\\n        }\\n        return maximumProfit;      // Return the meximum profit...\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        # Initialize the max profit...\\n        maximumProfit = 0\\n        # Traverse all the element through loop...\\n        for i in range(1, len(prices)):\\n            # check if the price is greater at i...\\n            if prices[i] > prices[i-1]:\\n                # Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i-1]\\n        return maximumProfit        # Return the max profit...\\n```\\n                    \\n# **JavaScript Solution:**\\n```\\nvar maxProfit = function(prices) {\\n    // Initialize the max profit...\\n    let maximumProfit = 0;\\n    // Traverse all the element through loop...\\n    for (let i = 1; i < prices.length; i++) {\\n        // check if the price is greater at i...\\n        if (prices[i] > prices[i - 1])\\n            // Add the difference to profit and increse it...\\n            maximumProfit += prices[i] - prices[i - 1];\\n    }\\n    return maximumProfit;      // Return the meximum profit...\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # Initialize the max profit...\\n        maximumProfit = 0\\n        # Traverse all the element through loop...\\n        for i in range(1, len(prices)):\\n            # check if the price is greater at i...\\n            if prices[i] > prices[i-1]:\\n                # Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i-1]\\n        return maximumProfit        # Return the max profit...\\n```\\n\\n# **C Language:**\\n```\\nint maxProfit(int* prices, int pricesSize){\\n    // Initialize the max profit...\\n    int maximumProfit = 0;\\n    // Traverse all the element through loop...\\n    for (int i = 1; i < pricesSize; i++) {\\n        // check if the price is greater at i...\\n        if (prices[i] > prices[i - 1])\\n            // Add the difference to profit and increse it...\\n            maximumProfit += prices[i] - prices[i - 1];\\n    }\\n    return maximumProfit;      // Return the meximum profit...\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // Initialize the max profit...\\n        int maximumProfit = 0;\\n        // Traverse all the element through loop...\\n        for(int i=1; i<prices.length; i++) {\\n            // Set the difference so that we can get the max profit...\\n            int diff = prices[i]-prices[i-1];\\n            // If the difference is positive value, add to profit and increse it...\\n            if(diff > 0){\\n                maximumProfit += diff;\\n            }\\n        }\\n        return maximumProfit;      // Return the max profit...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        // Initialize the max profit...\\n        int maximumProfit = 0;\\n        // Traverse all the element through loop...\\n        for (int i = 1; i < prices.size(); i++) {\\n            // check if the price is greater at i...\\n            if (prices[i] > prices[i - 1])\\n                // Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i - 1];\\n        }\\n        return maximumProfit;      // Return the meximum profit...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        # Initialize the max profit...\\n        maximumProfit = 0\\n        # Traverse all the element through loop...\\n        for i in range(1, len(prices)):\\n            # check if the price is greater at i...\\n            if prices[i] > prices[i-1]:\\n                # Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i-1]\\n        return maximumProfit        # Return the max profit...\\n```\n```\\nvar maxProfit = function(prices) {\\n    // Initialize the max profit...\\n    let maximumProfit = 0;\\n    // Traverse all the element through loop...\\n    for (let i = 1; i < prices.length; i++) {\\n        // check if the price is greater at i...\\n        if (prices[i] > prices[i - 1])\\n            // Add the difference to profit and increse it...\\n            maximumProfit += prices[i] - prices[i - 1];\\n    }\\n    return maximumProfit;      // Return the meximum profit...\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # Initialize the max profit...\\n        maximumProfit = 0\\n        # Traverse all the element through loop...\\n        for i in range(1, len(prices)):\\n            # check if the price is greater at i...\\n            if prices[i] > prices[i-1]:\\n                # Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i-1]\\n        return maximumProfit        # Return the max profit...\\n```\n```\\nint maxProfit(int* prices, int pricesSize){\\n    // Initialize the max profit...\\n    int maximumProfit = 0;\\n    // Traverse all the element through loop...\\n    for (int i = 1; i < pricesSize; i++) {\\n        // check if the price is greater at i...\\n        if (prices[i] > prices[i - 1])\\n            // Add the difference to profit and increse it...\\n            maximumProfit += prices[i] - prices[i - 1];\\n    }\\n    return maximumProfit;      // Return the meximum profit...\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569071,
                "title": "c-simple-and-clean-one-pass-solution-brief-explanation",
                "content": "**Idea:**\\nThe main idea is that we want to buy when the price is the lowest, and sell when it\\'s the highest.\\nSo we loop while the next stock price is lower - `prices[i] >= prices[i+1]`. When we reach a valley - a local minimum - we buy.\\nNow, we loop while the next stock price is higher, to get to the peak - a local maximum - and then we want to buy.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0, i = 0, n = prices.size();\\n        \\n        while (i < n - 1) {\\n            while ((i+1 != n) && (prices[i] >= prices[i+1])) i++;\\n            profit -= prices[i];\\n\\n            while ((i+1 != n) && (prices[i] < prices[i+1])) i++;\\n            profit += prices[i];\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0, i = 0, n = prices.size();\\n        \\n        while (i < n - 1) {\\n            while ((i+1 != n) && (prices[i] >= prices[i+1])) i++;\\n            profit -= prices[i];\\n\\n            while ((i+1 != n) && (prices[i] < prices[i+1])) i++;\\n            profit += prices[i];\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930074,
                "title": "java-easy-to-understand-t-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(prices[i]>prices[i-1]){\\n                profit+=prices[i]-prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(prices[i]>prices[i-1]){\\n                profit+=prices[i]-prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426192,
                "title": "c-dp-recursive-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int c(int i,int buy,vector<int>&prices,vector<vector<int>>&dp){\\n        if(i>=prices.size())return 0;\\n        int ans;\\n        if(dp[i][buy]!=-1)return dp[i][buy];\\n        if(buy){\\n         ans=max(-1*prices[i]+c(i+1,0,prices,dp), c(i+1,1,prices,dp));\\n        }\\n        else {\\n            ans=max(prices[i] + c(i+1,1,prices,dp),c(i+1,0,prices,dp));\\n        }\\n        dp[i][buy]=ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(prices.size(),vector<int>(2,-1));\\n        return c(0,1,prices,dp);\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/2620af2b-36ef-4fff-9380-6acad68acba1_1681716576.5439.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c(int i,int buy,vector<int>&prices,vector<vector<int>>&dp){\\n        if(i>=prices.size())return 0;\\n        int ans;\\n        if(dp[i][buy]!=-1)return dp[i][buy];\\n        if(buy){\\n         ans=max(-1*prices[i]+c(i+1,0,prices,dp), c(i+1,1,prices,dp));\\n        }\\n        else {\\n            ans=max(prices[i] + c(i+1,1,prices,dp),c(i+1,0,prices,dp));\\n        }\\n        dp[i][buy]=ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(prices.size(),vector<int>(2,-1));\\n        return c(0,1,prices,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772169,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[30001][2];\\n    \\n    int recurs(int i,bool hold,vector<int>& prices)\\n    {\\n        if(i>=prices.size())\\n            return 0;\\n        \\n        if(dp[i][hold]!=-1)\\n            return dp[i][hold];\\n        \\n        // 1 indicates we have stock currently\\n        // 0 indicates no stock is possesed currently\\n        \\n        if(hold==1)//sell or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,0,prices)+prices[i],recurs(i+1,1,prices));\\n        }\\n        if(hold==0)//buy or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,1,prices)-prices[i],recurs(i+1,0,prices));\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return recurs(0,0,prices);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[30001][2];\\n    \\n    int recurs(int i,bool hold,vector<int>& prices)\\n    {\\n        if(i>=prices.size())\\n            return 0;\\n        \\n        if(dp[i][hold]!=-1)\\n            return dp[i][hold];\\n        \\n        // 1 indicates we have stock currently\\n        // 0 indicates no stock is possesed currently\\n        \\n        if(hold==1)//sell or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,0,prices)+prices[i],recurs(i+1,1,prices));\\n        }\\n        if(hold==0)//buy or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,1,prices)-prices[i],recurs(i+1,0,prices));\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return recurs(0,0,prices);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39444,
                "title": "intuitive-javascript-solution",
                "content": "This solution is based on @jyan 's [post](https://discuss.leetcode.com/topic/726/is-this-question-a-joke).\\n```\\nvar maxProfit = function(prices) {\\n    // sell immediately when it's profitable\\n    return prices.reduce((profit, price, i, prices) => \\n        i > 0 && price > prices[i-1] ? profit + price - prices[i-1] : profit, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function(prices) {\\n    // sell immediately when it's profitable\\n    return prices.reduce((profit, price, i, prices) => \\n        i > 0 && price > prices[i-1] ? profit + price - prices[i-1] : profit, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39579,
                "title": "89ms-javascript-solution-js-is-much-faster-than-java",
                "content": "    var maxProfit = function(prices) {\\n        var len = prices.length;\\n        if(len <= 1) return 0;\\n        var ret = 0;\\n        for(var i = 1; i < len; i++) {\\n            ret += Math.max(0, prices[i] - prices[i-1]);\\n        }\\n        return ret;\\n    };",
                "solutionTags": [],
                "code": "    var maxProfit = function(prices) {\\n        var len = prices.length;\\n        if(len <= 1) return 0;\\n        var ret = 0;\\n        for(var i = 1; i < len; i++) {\\n            ret += Math.max(0, prices[i] - prices[i-1]);\\n        }\\n        return ret;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1888672,
                "title": "4-solutions-recursion-to-memoization-peak-valley-simple-explanation",
                "content": "# **Recursive Solution (TLE)**\\n\\n-   For current index If we can buy stock, we choose to buy it or not buy it.\\n-   Similarly if we can sell stock, we choose to sell it or not sell it.\\n-   In both cases we choose action which gives maximum profit to us.\\n-   The base case arises when index goes out of bound of array.\\n-   **TC: O(2^n)**\\n-   **SC: O(1)**\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    int maxProfitRec(vector<int>& prices, int i, bool canBuy)\\n    {\\n        if (i >= prices.size())\\n            return 0;\\n\\n        if (canBuy) {\\n            int notBuy = maxProfitRec(prices, i + 1, canBuy);\\n            int buy = maxProfitRec(prices, i + 1, !canBuy) - prices[i];\\n            return max(notBuy, buy);\\n        } else {\\n            int notSell = maxProfitRec(prices, i + 1, canBuy);\\n            int sell = maxProfitRec(prices, i + 1, !canBuy) + prices[i];\\n            return max(notSell, sell);\\n        }\\n    }\\n\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n        return maxProfitRec(prices, 0, true);\\n    }\\n};\\n```\\n**Note:** `canBuy` represents `Can we buy the stock?`\\n\\n# **Memoization**\\n\\n-   The recursive solution is exponential in time complexity so gives TLE.\\n-   We can use extra space to store the computation of subproblems.(memoization)\\n-   If we have calculated the subproblem before, we can directly return the result else store new result.\\n-   **TC: O(n)**\\n-   **SC: O(n)**\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    int maxProfitRec(vector<int>& prices, int i, bool canBuy, vector<vector<int>>& memo)\\n    {\\n        if (i >= prices.size())\\n            return 0;\\n\\n        if (memo[i][canBuy] != -1)\\n            return memo[i][canBuy];\\n\\n        if (canBuy) {\\n            int notBuy = maxProfitRec(prices, i + 1, canBuy, memo);\\n            int buy = maxProfitRec(prices, i + 1, !canBuy, memo) - prices[i];\\n            return memo[i][canBuy] = max(notBuy, buy);\\n        } else {\\n            int notSell = maxProfitRec(prices, i + 1, canBuy, memo);\\n            int sell = maxProfitRec(prices, i + 1, !canBuy, memo) + prices[i];\\n            return memo[i][canBuy] = max(notSell, sell);\\n        }\\n    }\\n\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n        vector<vector<int>> memo(n + 1, vector<int>(2, -1));\\n        return maxProfitRec(prices, 0, true, memo);\\n    }\\n};\\n```\\n\\n# **Valley-peak approach**\\n\\n-   For each time at lowest cost(valley) we buy stock and at highest cost(peak) we sell stock.\\n-   **TC: O(N)**\\n-   **SC: O(1)**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        int buy = 0, sell = 0;\\n        int i = 0,profit = 0;\\n        while (i < n - 1) {\\n            // valley\\n            while (i < n - 1 && prices[i] >= prices[i + 1])\\n                i++;\\n            buy = prices[i];\\n\\n            // peak\\n            while (i < n - 1 && prices[i] < prices[i + 1])\\n                i++;\\n            sell = prices[i];\\n\\n            profit += sell - buy;\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n## **Greedy Solution**\\n\\n-   for each day we buy and on next day we sell, **If it is profitable**\\n-   **TC: O(N)**\\n-   **SC: O(1)**\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int profit = 0;\\n        int n = prices.size();\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i - 1] < prices[i])\\n                profit += prices[i] - prices[i - 1];\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n**If you like it then please upvote !**\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    int maxProfitRec(vector<int>& prices, int i, bool canBuy)\\n    {\\n        if (i >= prices.size())\\n            return 0;\\n\\n        if (canBuy) {\\n            int notBuy = maxProfitRec(prices, i + 1, canBuy);\\n            int buy = maxProfitRec(prices, i + 1, !canBuy) - prices[i];\\n            return max(notBuy, buy);\\n        } else {\\n            int notSell = maxProfitRec(prices, i + 1, canBuy);\\n            int sell = maxProfitRec(prices, i + 1, !canBuy) + prices[i];\\n            return max(notSell, sell);\\n        }\\n    }\\n\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n        return maxProfitRec(prices, 0, true);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    int maxProfitRec(vector<int>& prices, int i, bool canBuy, vector<vector<int>>& memo)\\n    {\\n        if (i >= prices.size())\\n            return 0;\\n\\n        if (memo[i][canBuy] != -1)\\n            return memo[i][canBuy];\\n\\n        if (canBuy) {\\n            int notBuy = maxProfitRec(prices, i + 1, canBuy, memo);\\n            int buy = maxProfitRec(prices, i + 1, !canBuy, memo) - prices[i];\\n            return memo[i][canBuy] = max(notBuy, buy);\\n        } else {\\n            int notSell = maxProfitRec(prices, i + 1, canBuy, memo);\\n            int sell = maxProfitRec(prices, i + 1, !canBuy, memo) + prices[i];\\n            return memo[i][canBuy] = max(notSell, sell);\\n        }\\n    }\\n\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n        vector<vector<int>> memo(n + 1, vector<int>(2, -1));\\n        return maxProfitRec(prices, 0, true, memo);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        int buy = 0, sell = 0;\\n        int i = 0,profit = 0;\\n        while (i < n - 1) {\\n            // valley\\n            while (i < n - 1 && prices[i] >= prices[i + 1])\\n                i++;\\n            buy = prices[i];\\n\\n            // peak\\n            while (i < n - 1 && prices[i] < prices[i + 1])\\n                i++;\\n            sell = prices[i];\\n\\n            profit += sell - buy;\\n        }\\n        return profit;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int profit = 0;\\n        int n = prices.size();\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i - 1] < prices[i])\\n                profit += prices[i] - prices[i - 1];\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569085,
                "title": "c-easy-intuitive-solution-straight-forward-approach-dp",
                "content": "Hello everyone, first of all thanks a lot for reading in advance!\\n\\n**My Approach:**\\n1. Since, we want to maximize our profit then, I claim that we should take consecutive profit of (high - low) where we buy at low and sell at high.\\n\\n2. Like, if our sequence is somewhat like this: `a <= b <= c <= d`, the profit is `d - a = (b - a) + (c - b) + (d - c)` without a doubt.\\n\\n3. And, if our sequence is somewhat like this: `a <= b >= b\\' <= c <= d`, the profit is `(b - a) + (d - b)`.\\n\\n4. So we just target at monotonously increasing sequences, i.e., we need to consider every high immediately following a low to maximize the profit.\\n\\n5. Below is the graph for more intuition:\\n\\n![image](https://assets.leetcode.com/users/images/fa480019-a7db-4b28-a0ab-19fe757402e3_1636504280.3363073.png)\\nIn the above graph, if we skip peaki and valleyj, then trying to obtain more profit by considering points with more difference in heights, the net profit obtained will always be lesser than the one obtained by including them, since `C` will always be lesser than `A+B`.\\n\\n**Time Complexity:** `O(N)`\\n**Space Complexity:** `O(1)`\\n \\nBelow is the code for my approach mentioned above:\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit{};\\n        \\n        for(int i{1}; i<prices.size(); ++i) \\n            profit += max(prices[i] - prices[i-1], 0);\\n        \\n        return profit;\\n    }\\n};\\n```\\n\\n`Please Do Upvote \\uD83D\\uDD3C if this post helped you, it keeps me motivated to write more such posts.`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit{};\\n        \\n        for(int i{1}; i<prices.size(); ++i) \\n            profit += max(prices[i] - prices[i-1], 0);\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523377,
                "title": "c-recursive-memoization-dp",
                "content": "*   **Here is an observation,** it is given then you can buy a stock if you hold at most one stock but you have to sell the hold stock on the same day of purchasing the second stock. It means your profit is zero or you can say you don\\'t have profit on second stock.\\n\\n*  **Proof :-** let say, on day 1 you buy a stock1 = 1, here your profit = -1;\\n   on day 3 you buy stock2 = 5, then your profit = -6, then immediately sell stock1 = 5, then your profit = -1;\\n\\t   on day 7 you sell your stock2 = 9, then your profit = 8; \\n\\t   It is same as you buy a stock on day 1 and sell it on day 7\\n   \\n*  Now, you can observe that on day 3 your profit = 0, as you buy a stock at 5 and sell previous stock at 5;\\nso this statement `(You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day)` is **absolutly worthless**. and **the question reduced to just \"buy and sell stock\" with condition you have to sell a stock before you buy another.**\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int dp[30003][2];\\n    int solve(vector<int>& prices, int pos, bool hold){\\n        if(pos==prices.size()) return 0;\\n        if(dp[pos][hold]!=-1) return dp[pos][hold];\\n        int buy=0, notbuy=0, sell=0, notsell=0;\\n        //if you want to buy \\n        if(!hold) buy = solve(prices,pos+1,!hold) - prices[pos];\\n        //if you don\\'t want to buy \\n        notbuy = solve(prices,pos+1,hold);\\n        // if you want to sell the stock\\n        if(hold) sell = solve(prices,pos+1,!hold) + prices[pos];\\n        // if you don\\'t want to sell the stock\\n        notsell = solve(prices,pos+1,hold);\\n        return dp[pos][hold] = max(max(buy,notbuy),max(sell,notsell));\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,false);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[30003][2];\\n    int solve(vector<int>& prices, int pos, bool hold){\\n        if(pos==prices.size()) return 0;\\n        if(dp[pos][hold]!=-1) return dp[pos][hold];\\n        int buy=0, notbuy=0, sell=0, notsell=0;\\n        //if you want to buy \\n        if(!hold) buy = solve(prices,pos+1,!hold) - prices[pos];\\n        //if you don\\'t want to buy \\n        notbuy = solve(prices,pos+1,hold);\\n        // if you want to sell the stock\\n        if(hold) sell = solve(prices,pos+1,!hold) + prices[pos];\\n        // if you don\\'t want to sell the stock\\n        notsell = solve(prices,pos+1,hold);\\n        return dp[pos][hold] = max(max(buy,notbuy),max(sell,notsell));\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167130,
                "title": "c-solution-to-all-the-stock-problems-using-dynamic-programming",
                "content": "## Related Questions\\n\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n3. [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n4. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n5. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n6. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n\\n#### Best Time to Buy and Sell Stock\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy[prices.size()], sell[prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1],-prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock II\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock with Transaction Fee\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1] - fee);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock with Cooldown ( Generalised for k cooldown period )\\nO(N) Time, O(N) Space\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int cooldown = 1) {\\n        int buy[prices.size()];\\n        int sell[prices.size()];\\n        memset(buy, 0, sizeof(buy));\\n        memset(sell, 0, sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1], (i-cooldown-1 >= 0 ? sell[i-cooldown-1] : 0) - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(sell[prices.size()-1], buy[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock III ( Generalised for atmost k transactions )\\nO(Nk) Time, O(Nk) Space ( Can be made O(k) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int transactions = 2) {\\n        if(transactions == 0) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock IV\\nO(Nk) Time, O(Nk) Space ( Can be made O(k) Space by tracking only the previous buy sell values )\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int transactions, vector<int>& prices) {\\n        if(transactions == 0 || prices.size() <= 1) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy[prices.size()], sell[prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1],-prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1] - fee);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int cooldown = 1) {\\n        int buy[prices.size()];\\n        int sell[prices.size()];\\n        memset(buy, 0, sizeof(buy));\\n        memset(sell, 0, sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1], (i-cooldown-1 >= 0 ? sell[i-cooldown-1] : 0) - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(sell[prices.size()-1], buy[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int transactions = 2) {\\n        if(transactions == 0) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int transactions, vector<int>& prices) {\\n        if(transactions == 0 || prices.size() <= 1) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452422,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        arr=[0 for i in range(len(prices))]\\n        for i in range(len(prices)-1):\\n            arr[i+1]=prices[i+1]-prices[i]\\n        \\n        maxProfit=0\\n        for i in range(len(arr)):\\n            if arr[i]>0:\\n                maxProfit+=arr[i]\\n        return maxProfit        \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        arr=[0 for i in range(len(prices))]\\n        for i in range(len(prices)-1):\\n            arr[i+1]=prices[i+1]-prices[i]\\n        \\n        maxProfit=0\\n        for i in range(len(arr)):\\n            if arr[i]>0:\\n                maxProfit+=arr[i]\\n        return maxProfit        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235886,
                "title": "javascript-java-c-100-fast-o-n-time-best-time-to-buy-and-sell-stock-ii",
                "content": "# Intuition\\nTo solve this problem, we need to find all the points where the price is increasing and calculate the difference between each pair of adjacent points. This will give us the profit that can be made by buying at the lower price and selling at the higher price. We then add up all these profits to get the maximum profit that can be made.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo implement this approach, we can initialize a variable max_profit to 0 and loop through the array, checking each pair of adjacent points for a price increase. Whenever we find an increase, we add it to max_profit. At the end of the loop, we return max_profit.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the input array prices. This is because we are looping through the input array once and doing a constant amount of work for each element.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1), because we are only using a constant amount of extra space to store the variables diff and max_profit, and we are not using any additional data structures. Therefore, the space used by the algorithm does not depend on the size of the input.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# ***C++ Code***\\n``````\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int max=0,diff;\\n        for(int i=0;i<prices.size()-1;i++)\\n        {\\n            diff=prices[i+1]-prices[i];\\n            if(diff>0)\\n                max+=diff;\\n        }\\n        return max;\\n    }\\n};\\n\\n\\n``````\\n# ***Java Code***\\n``````\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,diff;\\n        for(int i=0;i<prices.length-1;i++)\\n        {\\n            diff=prices[i+1]-prices[i];\\n            if(diff>0)\\n                max+=diff;\\n        }\\n        return max;  \\n    }\\n}\\n\\n``````\\n# ***JavaScript Code***\\n``````\\nvar maxProfit = function(prices) {\\n    var max=0,diff;\\n    for(var i=0;i<prices.length-1;i++)\\n    {\\n        diff=prices[i+1]-prices[i];\\n        if(diff>0)\\n            max+=diff;\\n    }\\n    return max;\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "``````\n``````\n``````\n``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 3195867,
                "title": "with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation:\\n\\nWe iterate through the array and check if the current price is greater than the previous price. If it is, we add the difference between the two prices to our max_profit variable.\\n\\nAt the end, we return the max_profit. This is because we can buy and sell multiple times, so we just add up the profits from all possible transactions.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                max_profit += prices[i] - prices[i-1]\\n        return max_profit\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                max_profit += prices[i] - prices[i-1]\\n        return max_profit\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986870,
                "title": "6-line-code-simple-greedy-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a) {\\n        \\n        int sum=0;\\n        for(int i=1;i<a.size();i++){\\n            int t=a[i]-a[i-1];\\n            if(t>0)\\n            sum+=t;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a) {\\n        \\n        int sum=0;\\n        for(int i=1;i<a.size();i++){\\n            int t=a[i]-a[i-1];\\n            if(t>0)\\n            sum+=t;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356923,
                "title": "simplest-solution-possible",
                "content": "I have seen a lot of solutions finding the best subarray, but the problem really boils down to wether the price is increasing or decreasing day over day. For example, if the prices are ```[1, 2, 3, 4, 5]```. Solving for the max profit by buying on Day 1 at $1 and selling on Day 5 at $5 for a profit of $4 is the same as buying and selling every day ($2-$1 + $3 - $2 + $4 - $3 + $5 -$4). For cases when the price goes down, there is no reason to track the price as it will either increase on the next iteration (in which case it will be added) or it will continue going down. Hope this helps!\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        total = 0\\n        for i in range(len(prices)-1):\\n            if prices[i] < prices[i+1]:\\n                total += (prices[i+1]-prices[i])\\n        \\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```[1, 2, 3, 4, 5]```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        total = 0\\n        for i in range(len(prices)-1):\\n            if prices[i] < prices[i+1]:\\n                total += (prices[i+1]-prices[i])\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271744,
                "title": "best-explanation-using-state-machine-with-diagram",
                "content": "The best way to solve any question related to buy and sell stock is by making state machines.\\nIt is very intuitive to draw the state machine for this question.\\nThere are three things we need to do\\n1) Buy\\n2) Hold\\n3) Sell\\n\\n![image](https://assets.leetcode.com/users/images/7d650a21-13c8-44d6-b88d-6f591b963c49_1657615804.1454897.png)\\n\\nWe have two states x and y.\\nIn state x we have to decide if we want to buy a stock or do nothing.\\nIn state y we have to decide if we want to sell a stock or do nothing.\\nTo move from state x to y we have to buy a stock, similarly from y to x we have to sell the stock.\\n\\nOur task is to maximize the profit hence in each state we take decision by looking at maximum profit.\\nTo write the state equation we look at the incoming edges on a given state.\\n\\nThe state equations are:\\n**x[i] = max( x[i-1] , y[i-1] + prices[i])\\ny[i]= max( y[i-1] , x[i-1] - prices[i])**\\n\\n**Note: Here we are deciding at current price we need to buy or sell or hold the stock, thats why we have to take prices[i] and not prices[i-1].**\\n\\n C++ code with O(n) space:\\n ```\\n int maxProfit(vector<int>& prices) {\\n\\t\\tint n=prices.size();\\n        vector<int> x(n,0),y(n);\\n\\t\\t// initially we dont have anything, so moving to state y requires prices[0]\\n        y[0]=-prices[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            x[i]=max(x[i-1],y[i-1]+prices[i]);\\n            y[i]=max(x[i-1]-prices[i],y[i-1]); \\n            \\n        }\\n        return max(x[n-1],y[n-1]);\\n\\t\\t}\\n```\\n\\nAnd with little tweaking the space is optimized to O(1):\\n```\\nint maxProfit(vector<int>& prices) {\\n\\t\\tint y=-prices[0];\\n        int x=0,last_x=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            x=max(last_x,y+prices[i]);\\n            y=max(last_x-prices[i],y);\\n            last_x=x;\\n        }\\n        \\n        return max(x,y);\\n\\t\\t}\\n```\\n\\n**Do post your doubts, and upvote if you like the explanation..happy coding**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n int maxProfit(vector<int>& prices) {\\n\\t\\tint n=prices.size();\\n        vector<int> x(n,0),y(n);\\n\\t\\t// initially we dont have anything, so moving to state y requires prices[0]\\n        y[0]=-prices[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            x[i]=max(x[i-1],y[i-1]+prices[i]);\\n            y[i]=max(x[i-1]-prices[i],y[i-1]); \\n            \\n        }\\n        return max(x[n-1],y[n-1]);\\n\\t\\t}\\n```\n```\\nint maxProfit(vector<int>& prices) {\\n\\t\\tint y=-prices[0];\\n        int x=0,last_x=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            x=max(last_x,y+prices[i]);\\n            y=max(last_x-prices[i],y);\\n            last_x=x;\\n        }\\n        \\n        return max(x,y);\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661828,
                "title": "solution-swift-best-time-to-buy-and-sell-stock-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var i = 1, profit = 0\\n        while i < prices.count {\\n            let cur = prices[i], last = prices[i-1]\\n            if cur > last { profit += cur - last }\\n            i += 1\\n        }\\n        return profit\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.007 (0.009) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n    /// Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\\n    /// Total profit is 4 + 3 = 7.\\n    func test0() {\\n        let value = solution.maxProfit([7,1,5,3,6,4])\\n        XCTAssertEqual(value, 7)\\n    }\\n    \\n    /// Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\\n    /// Total profit is 4.\\n    func test1() {\\n        let value = solution.maxProfit([1,2,3,4,5])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    /// There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\\n    func test2() {\\n        let value = solution.maxProfit([7,6,4,3,1])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var i = 1, profit = 0\\n        while i < prices.count {\\n            let cur = prices[i], last = prices[i-1]\\n            if cur > last { profit += cur - last }\\n            i += 1\\n        }\\n        return profit\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n    /// Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\\n    /// Total profit is 4 + 3 = 7.\\n    func test0() {\\n        let value = solution.maxProfit([7,1,5,3,6,4])\\n        XCTAssertEqual(value, 7)\\n    }\\n    \\n    /// Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\\n    /// Total profit is 4.\\n    func test1() {\\n        let value = solution.maxProfit([1,2,3,4,5])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    /// There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\\n    func test2() {\\n        let value = solution.maxProfit([7,6,4,3,1])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635298,
                "title": "o-n-c-one-pass-iterative-solution-100-speed-and-space-with-explaination",
                "content": "We don\\u2019t have any restrictions on the number of deals so we will suppose of a greedy algorithm then. So every time we will buy a stock at a minimum price and sell it at a maximum price. We can observe it as, at each minimum we will buy a stock and at each maximum, we will sell a stock.\\nWe can make it simpler if we observe that a maximum is formed when small values are added to minimum. So instead of tracking every minimum and maximum to calculate the maximum profit, we can directly add those values to our profit for which we form a positive pitch that\\'s ``prices [i]> prices [i-1].`` The addition of all similar values will give us maximum profit. \\n\\n \\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n         int n=prices.size();\\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] > prices[i - 1])\\n                ans += prices[i] - prices[i - 1];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(n)\\n**Auxiliary Space:** O(1)\\n\\nHit \\uD83D\\uDC4D if you like it :)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n         int n=prices.size();\\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] > prices[i - 1])\\n                ans += prices[i] - prices[i - 1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539147,
                "title": "c-single-loop-o-n-time-and-o-1-space",
                "content": "# Code for learners who already know this\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        \\n        int profit = 0;\\n        \\n        for(int i = 1; i < prices.Length; i++)\\n        {\\n            if(prices[i] > prices[i - 1])\\n                profit += prices[i] - prices[i - 1];\\n        }\\n        \\n        return profit;\\n        \\n    }\\n}\\n```\\n\\n\\n# TL;DR;\\n\\nKey here is you can buy and sell the stock at same day. only constraint is you can only hold 1 stock at a time. so you sell it when profit and buy it same again and sell it if tomorrow price is higher, the profit just cummulates\\n\\n# Details\\n\\nTake the example [8, 2, 5, 6, 3, 10, 1]\\n\\nTry to plot it in a paper as a graph\\nit looks like \\n\\n![image](https://assets.leetcode.com/users/images/610aecf9-fe3b-4d47-a41c-01982b353ae2_1635116844.8589506.png)\\n\\nNow the problem becomes very easy\\nyou just buy when you see low point and sell at high point\\nBut you may think: what if today is low (but you still get profit as the amout you got is lesser than todays market value) but tomorrow may be really high, should i hold onto the stock? \\nYes you can --> but the problem becomes very hard now that you have to know the values ahead and keep a state. \\ninstead --> you sell today, get a profit and store the profit, and then buy the stock back again, and hold the new one and sell it off tomorrow, again when the market is higher. \\n\\nthis is emulated in the code where i just sell and then rebuy. but in a code way where i just get the difference. \\n\\nlets take an example: \\n\\ni got a stock brought at Rs 1 (got yesterday -- say)\\ntoday value is Rs 5 ( if i sell today the profit is 4) but tomorrow the market is at 10\\nif i just hold on and sell the Rs 1 stock at 10 --> my profit is 9\\n\\nbut you still get same profit if  you sell today at 5 (profit 4) then rebuy same stock at 5 and sell tomorrow at 10 (profit 5) so total profit is (4+5) still 9\\n\\n\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        \\n        int profit = 0;\\n        \\n        for(int i = 1; i < prices.Length; i++)\\n        {\\n            if(prices[i] > prices[i - 1])\\n                profit += prices[i] - prices[i - 1];\\n        }\\n        \\n        return profit;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010989,
                "title": "python-one-line",
                "content": "```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        return sum(max(b-a,0) for a,b in zip(prices, prices[1:]))\\n```\\nYay! I got to use zip finally :) Would appreciate your feedback on improving my solution.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        return sum(max(b-a,0) for a,b in zip(prices, prices[1:]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 293113,
                "title": "javascript-solution",
                "content": "```\\nvar maxProfit = function(prices) {\\n    let profit = 0;\\n    for (let i = 0; i < prices.length - 1; i++) {\\n        const possibleProfit = prices[i + 1] - prices[i];\\n        profit = Math.max(profit + possibleProfit, profit);\\n    }\\n    return profit;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxProfit = function(prices) {\\n    let profit = 0;\\n    for (let i = 0; i < prices.length - 1; i++) {\\n        const possibleProfit = prices[i + 1] - prices[i];\\n        profit = Math.max(profit + possibleProfit, profit);\\n    }\\n    return profit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39549,
                "title": "a-concise-solution-in-java",
                "content": "    public class Solution {\\n        public int maxProfit(int[] prices) {\\n            int len = prices.length;\\n            int profit = 0;\\n            for(int i = 1; i < len ; i++){\\n                if(prices[i]-prices[i-1] <= 0){\\n                    continue;\\n                }\\n                profit += prices[i]-prices[i-1];\\n            }\\n            return profit;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxProfit(int[] prices) {\\n            int len = prices.length;\\n            int profit = 0;\\n            for(int i = 1; i < len ; i++){\\n                if(prices[i]-prices[i-1] <= 0){\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3821888,
                "title": "beats-100-0ms",
                "content": "git gud\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] > prices[i - 1]) {\\n                profit += prices[i] - prices[i - 1];\\n            } \\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] > prices[i - 1]) {\\n                profit += prices[i] - prices[i - 1];\\n            } \\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665058,
                "title": "easiest-solution-for-beginners-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int ans=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i+1]>prices[i]) ans=ans+(prices[i+1]-prices[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int ans=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i+1]>prices[i]) ans=ans+(prices[i+1]-prices[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364416,
                "title": "best-5-o-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, vector<int>& prices, int n) {\\n        if (idx == n)\\n            return 0;\\n        int profit;\\n        if (buy == 1) \\n            profit = max (-prices[idx] + solve(idx+1, 0, prices, n), 0 + solve(idx+1, 1, prices, n));\\n        else\\n            profit = max (prices[idx] + solve(idx+1, 1, prices, n), 0 + solve(idx+1, 0, prices, n));\\n        return profit;     \\n    }    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return solve(0, 1, prices, n);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, vector<int>& prices, vector<vector<int>>& dp, int n) {\\n        if (idx == n)\\n            return 0;\\n        if (dp[idx][buy] != -1)\\n            return dp[idx][buy];  \\n        int profit;\\n        if (buy == 1) \\n            profit = max (-prices[idx] + solve(idx+1, 0, prices, dp, n), 0 + solve(idx+1, 1, prices, dp, n));\\n        else\\n            profit = max (prices[idx] + solve(idx+1, 1, prices, dp, n), 0 + solve(idx+1, 0, prices, dp, n));\\n        return dp[idx][buy] = profit;     \\n    }    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, -1));\\n        return solve(0, 1, prices, dp, n);\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, 0));\\n        dp[n][0] = dp[n][1] = 0;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                int profit;\\n                if (buy == 1) \\n                    profit = max (-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\\n                else\\n                    profit = max (prices[idx] + dp[idx+1][1], 0 + dp[idx+1][0]);\\n                dp[idx][buy] = profit; \\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector <int> ahead(2, 0), cur(2, 0);\\n        ahead[0] = ahead[1] = 0;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                int profit;\\n                if (buy == 1) \\n                    profit = max (-prices[idx] + ahead[0], 0 + ahead[1]);\\n                else\\n                    profit = max (prices[idx] + ahead[1], 0 + ahead[0]);\\n                cur[buy] = profit; \\n            }\\n            ahead = cur;\\n        }\\n        return ahead[1];\\n    }\\n};\\n```\\n\\n# Approach 5\\nUsing 4 Variables\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int aheadBuy, aheadNotBuy;\\n        aheadNotBuy = aheadBuy = 0;\\n        int curBuy, curNotBuy;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            curNotBuy = max (prices[idx] + aheadBuy, 0 + aheadNotBuy);\\n            curBuy = max (-prices[idx] + aheadNotBuy, 0 + aheadBuy);\\n            aheadNotBuy = curNotBuy;\\n            aheadBuy = curBuy;\\n        }\\n        return aheadBuy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, vector<int>& prices, int n) {\\n        if (idx == n)\\n            return 0;\\n        int profit;\\n        if (buy == 1) \\n            profit = max (-prices[idx] + solve(idx+1, 0, prices, n), 0 + solve(idx+1, 1, prices, n));\\n        else\\n            profit = max (prices[idx] + solve(idx+1, 1, prices, n), 0 + solve(idx+1, 0, prices, n));\\n        return profit;     \\n    }    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return solve(0, 1, prices, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, vector<int>& prices, vector<vector<int>>& dp, int n) {\\n        if (idx == n)\\n            return 0;\\n        if (dp[idx][buy] != -1)\\n            return dp[idx][buy];  \\n        int profit;\\n        if (buy == 1) \\n            profit = max (-prices[idx] + solve(idx+1, 0, prices, dp, n), 0 + solve(idx+1, 1, prices, dp, n));\\n        else\\n            profit = max (prices[idx] + solve(idx+1, 1, prices, dp, n), 0 + solve(idx+1, 0, prices, dp, n));\\n        return dp[idx][buy] = profit;     \\n    }    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, -1));\\n        return solve(0, 1, prices, dp, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, 0));\\n        dp[n][0] = dp[n][1] = 0;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                int profit;\\n                if (buy == 1) \\n                    profit = max (-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\\n                else\\n                    profit = max (prices[idx] + dp[idx+1][1], 0 + dp[idx+1][0]);\\n                dp[idx][buy] = profit; \\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector <int> ahead(2, 0), cur(2, 0);\\n        ahead[0] = ahead[1] = 0;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                int profit;\\n                if (buy == 1) \\n                    profit = max (-prices[idx] + ahead[0], 0 + ahead[1]);\\n                else\\n                    profit = max (prices[idx] + ahead[1], 0 + ahead[0]);\\n                cur[buy] = profit; \\n            }\\n            ahead = cur;\\n        }\\n        return ahead[1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int aheadBuy, aheadNotBuy;\\n        aheadNotBuy = aheadBuy = 0;\\n        int curBuy, curNotBuy;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            curNotBuy = max (prices[idx] + aheadBuy, 0 + aheadNotBuy);\\n            curBuy = max (-prices[idx] + aheadNotBuy, 0 + aheadBuy);\\n            aheadNotBuy = curNotBuy;\\n            aheadBuy = curBuy;\\n        }\\n        return aheadBuy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318165,
                "title": "easy-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this proble. -->\\nAny stock can buy or sell on same day.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Stack to find the next greater element for the stack top.\\nOnce we get the greater element that stack top we store the difference in ans .\\nElse we just pop the stack element.\\nAlso push every element in stack.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        int ans=0;\\n        stack<int>st;\\n        \\n        for(int i=0;i<n;i++){\\n            if(st.empty())st.push(prices[i]);\\n            else{\\n                if(st.top()<prices[i])ans=ans+(prices[i]-st.top());\\n                else{            \\n                   st.pop();\\n                }\\n            }\\n            st.push(prices[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        int ans=0;\\n        stack<int>st;\\n        \\n        for(int i=0;i<n;i++){\\n            if(st.empty())st.push(prices[i]);\\n            else{\\n                if(st.top()<prices[i])ans=ans+(prices[i]-st.top());\\n                else{            \\n                   st.pop();\\n                }\\n            }\\n            st.push(prices[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115181,
                "title": "tc-o-n-sc-const-recursive-memoization-tabulation-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) For Space Optimized Method\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant For Space Optimized Method\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n-> RECURSIVE SOLUTION\\n\\nclass Solution {\\npublic:\\n     int f(int ind,int buy,vector<int>&prices,int n)\\n    {\\n        if(ind==n) return 0;\\n        int profit=0;\\n        if(buy==1)\\n            profit=max(-prices[ind]+f(ind+1,0,prices,n),0+f(ind+1,1,prices,n));\\n        else\\n            profit=max(prices[ind]+f(ind+1,1,prices,n),f(ind+1,0,prices,n));\\n        return profit;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        return f(0,1,prices,n);\\n    }\\n};\\n\\n----------------------------------------------------------------------\\n-> MEMOIZATION METHOD\\n\\nclass Solution {\\npublic:\\n    int f(int ind,int buy,vector<int>&prices,int n,vector<vector<int>>&dp)\\n    {\\n        if(ind==n) return 0;\\n        int profit=0;\\n\\n        if(dp[ind][buy]!=-1) return dp[ind][buy];\\n        if(buy==1)\\n            profit=max(-prices[ind]+f(ind+1,0,prices,n,dp),0+f(ind+1,1,prices,n,dp));\\n        else\\n            profit=max(prices[ind]+f(ind+1,1,prices,n,dp),f(ind+1,0,prices,n,dp));\\n\\n        return dp[ind][buy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        return f(0,1,prices,n,dp);\\n    }\\n};\\n\\n----------------------------------------------------------------------\\n-> TABULATION METHOD\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        dp[n][0]=dp[n][1]=0;\\n        int profit=0;\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int buy=0;buy<=1;buy++)\\n            {\\n                if(buy==1)\\n                    profit=max(-prices[ind]+dp[ind+1][0],dp[ind+1][1]);\\n                else\\n                    profit=max(prices[ind]+dp[ind+1][1],dp[ind+1][0]);\\n\\n                dp[ind][buy]=profit;\\n            }\\n            \\n        }\\n        return dp[0][1];\\n    }\\n};\\n\\n----------------------------------------------------------------------\\n->SPACE OPTIMIZATION METHOD\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<int>prev(2,0),curr(2,0);\\n        prev[0]=prev[1]=0;\\n        int profit=0;\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int buy=0;buy<=1;buy++)\\n            {\\n                if(buy==1)\\n                    profit=max(-prices[ind]+prev[0],prev[1]);\\n                else\\n                    profit=max(prices[ind]+prev[1],prev[0]);\\n\\n                curr[buy]=profit;\\n            }\\n            prev=curr;\\n        }\\n        return prev[1];   \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n     int f(int ind,int buy,vector<int>&prices,int n)\\n    {\\n        if(ind==n) return 0;\\n        int profit=0;\\n        if(buy==1)\\n            profit=max(-prices[ind]+f(ind+1,0,prices,n),0+f(ind+1,1,prices,n));\\n        else\\n            profit=max(prices[ind]+f(ind+1,1,prices,n),f(ind+1,0,prices,n));\\n        return profit;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2700891,
                "title": "c-easy-fast-short-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(prices[i]<prices[i-1])\\n            {\\n                min = prices[i];\\n                continue;\\n            }\\n            profit += prices[i] - min;\\n            min = prices[i];\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(prices[i]<prices[i-1])\\n            {\\n                min = prices[i];\\n                continue;\\n            }\\n            profit += prices[i] - min;\\n            min = prices[i];\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113567,
                "title": "python-4-approaches-entire-dp",
                "content": "\\n**Recursion -> TLE\\nTime Complexity: O(N*2)\\nSpace Complexity: O(N)**\\n\\n```\\ndef f(ind,buy,prices):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices), 0 + f(ind+1,1,prices))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+1,1,prices), 0 + f(ind+1,0,prices))\\n\\t\\t\\n    return profit    \\n\\t\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        return f(0,1,prices)\\n```\\n\\n**Memoization**\\n**Time Complexity: O(N*2)**\\n**Space Complexity: O(N*2) + O(N)**\\n\\n```\\ndef f(ind,buy,prices,dp):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(dp[ind][buy] != -1):\\n        return dp[ind][buy]\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices,dp), 0 + f(ind+1,1,prices,dp))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+1,1,prices,dp), 0 + f(ind+1,0,prices,dp))\\n        \\n    dp[ind][buy] = profit\\n    return dp[ind][buy]\\n\\t\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\t\\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n)]\\n\\t\\t\\n        return f(0,1,prices,dp)\\n```\\n\\n**Tabulation**\\n**Time Complexity: O(N*2)**\\n**Space Complexity: O(N*2)**\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n+1)]\\n        \\n        dp[n][0] = dp[n][1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n\\t\\t\\t\\tif(buy):\\n                    profit = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + dp[ind+1][1], 0 + dp[ind+1][0])\\n                    \\n                dp[ind][buy] = profit\\n\\t\\t\\t\\t\\n            ind -= 1    \\n\\t\\t\\t\\n        return dp[0][1]\\n```\\n\\n**Tabulation with SPACE OPTIMIZED**\\n**Time Complexity: O(N*2)**\\n**Space Complexity: O(N)**\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        \\n        ahead = [0 for i in range(2)]\\n        curr = [0 for i in range(2)]\\n        \\n        ahead[0] = ahead[1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n                if(buy):\\n                    profit = max(-prices[ind] + ahead[0], 0 + ahead[1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + ahead[1], 0 + ahead[0])\\n                    \\n                curr[buy] = profit\\n\\t\\t\\t\\t\\n            ahead = [x for x in curr]    \\n            ind -= 1    \\n\\t\\t\\t\\n        return ahead[1]\\n```\\n\\n**Please upvote if you find it useful !!!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ndef f(ind,buy,prices):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices), 0 + f(ind+1,1,prices))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+1,1,prices), 0 + f(ind+1,0,prices))\\n\\t\\t\\n    return profit    \\n\\t\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        return f(0,1,prices)\\n```\n```\\ndef f(ind,buy,prices,dp):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(dp[ind][buy] != -1):\\n        return dp[ind][buy]\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices,dp), 0 + f(ind+1,1,prices,dp))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+1,1,prices,dp), 0 + f(ind+1,0,prices,dp))\\n        \\n    dp[ind][buy] = profit\\n    return dp[ind][buy]\\n\\t\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\t\\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n)]\\n\\t\\t\\n        return f(0,1,prices,dp)\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n+1)]\\n        \\n        dp[n][0] = dp[n][1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n\\t\\t\\t\\tif(buy):\\n                    profit = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + dp[ind+1][1], 0 + dp[ind+1][0])\\n                    \\n                dp[ind][buy] = profit\\n\\t\\t\\t\\t\\n            ind -= 1    \\n\\t\\t\\t\\n        return dp[0][1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        \\n        ahead = [0 for i in range(2)]\\n        curr = [0 for i in range(2)]\\n        \\n        ahead[0] = ahead[1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n                if(buy):\\n                    profit = max(-prices[ind] + ahead[0], 0 + ahead[1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + ahead[1], 0 + ahead[0])\\n                    \\n                curr[buy] = profit\\n\\t\\t\\t\\t\\n            ahead = [x for x in curr]    \\n            ind -= 1    \\n\\t\\t\\t\\n        return ahead[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540602,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)we can use [Kadane\\'s algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem) to track the \"best ending here\" during a linear scan of the input array of prices `A`, ie. we greedily buy/sell when the prices are monotonically increasing, since this is the only time proft is made.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray): Int {\\n        var best = 0\\n        for (i in 1 until A.size)\\n            best += Math.max(0, A[i] - A[i - 1])\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxProfit = (A, best = 0) => {\\n    for (let i = 1; i < A.length; ++i)\\n        best += Math.max(0, A[i] - A[i - 1]);\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], best = 0) -> int:\\n        for i in range(1, len(A)):\\n            best += max(0, A[i] - A[i - 1])\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxProfit(VI& A, int best = 0) {\\n        for (auto i{ 1 }; i < A.size(); ++i)\\n            best += max(0, A[i] - A[i - 1]);\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProfit(A: IntArray): Int {\\n        var best = 0\\n        for (i in 1 until A.size)\\n            best += Math.max(0, A[i] - A[i - 1])\\n        return best\\n    }\\n}\\n```\n```\\nlet maxProfit = (A, best = 0) => {\\n    for (let i = 1; i < A.length; ++i)\\n        best += Math.max(0, A[i] - A[i - 1]);\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], best = 0) -> int:\\n        for i in range(1, len(A)):\\n            best += max(0, A[i] - A[i - 1])\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxProfit(VI& A, int best = 0) {\\n        for (auto i{ 1 }; i < A.size(); ++i)\\n            best += max(0, A[i] - A[i - 1]);\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465876,
                "title": "java-both-greedy-and-dp-most-intuitive-dp-explanation-time-o-n-space-o-1",
                "content": "Greedy solution:\\n```\\n// 1) If there is any price increase p[i] > p[i-1], we can purchase at\\n// day[i-1] and see day[i] and make a profit.\\n// 2) If there is any price decrease, we would sell in the previous day\\n// and avoid that lost.\\n// So overall, the max will be sum(all_gain_delta).\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int result = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            int delta = prices[i] - prices[i - 1];\\n            result += delta > 0 ? delta : 0;\\n            // result += Math.max(delta, 0);  // Same as above.\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nDP solution:\\n```\\n// State machine:\\n// At each day i, there are two states: [have] / [don\\'t] have the stock.\\n// At each state, there are two moves one can do:\\n// 1) [i-1][have]: do_nothing -> [i][have], sell -> [i][don\\'t]; \\n// 2) [i-1][don\\'t]: do nothing -> [i][don\\'t], buy -> [i][have];\\n// Which gives us the following DP equation.\\n//    dp[i][have] = max(dp[i-1][don\\'t] - prices[i], dp[i-1][have])\\n//    dp[i][don\\'t] = max(dp[i-1][have] + prices[i], dp[i-1][don\\'t])\\n// Where:\\n//  1) dp[i][x] is at that state, the money one has. which means:\\n//  2) buying stock cause you lose money (- prices[i] above)\\n//  3) and selling stock cause you gain money (+ prices[i] above)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // 0 have, 1 don\\'t.\\n        int[][] dp = new int[prices.length][2];\\n        dp[0][0] = - prices[0];  // Buy at prices[0] (1st day).\\n        dp[0][1] = 0; // Impossible to sell at day 1. Keep it 0.\\n        for (int i = 1; i < prices.length; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][1] - prices[i], dp[i - 1][0]);\\n            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);\\n        }\\n        // Return the last day at the sell state.\\n        return dp[prices.length - 1][1];\\n    }\\n}\\n// Optimization:\\n// We don\\'t need a O(2n) size 2D arr to store every day.\\n// Just store the previous day\\'s sell or buy state is enough.\\n// Which makes the Space O(1).\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n// 1) If there is any price increase p[i] > p[i-1], we can purchase at\\n// day[i-1] and see day[i] and make a profit.\\n// 2) If there is any price decrease, we would sell in the previous day\\n// and avoid that lost.\\n// So overall, the max will be sum(all_gain_delta).\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int result = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            int delta = prices[i] - prices[i - 1];\\n            result += delta > 0 ? delta : 0;\\n            // result += Math.max(delta, 0);  // Same as above.\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\n// State machine:\\n// At each day i, there are two states: [have] / [don\\'t] have the stock.\\n// At each state, there are two moves one can do:\\n// 1) [i-1][have]: do_nothing -> [i][have], sell -> [i][don\\'t]; \\n// 2) [i-1][don\\'t]: do nothing -> [i][don\\'t], buy -> [i][have];\\n// Which gives us the following DP equation.\\n//    dp[i][have] = max(dp[i-1][don\\'t] - prices[i], dp[i-1][have])\\n//    dp[i][don\\'t] = max(dp[i-1][have] + prices[i], dp[i-1][don\\'t])\\n// Where:\\n//  1) dp[i][x] is at that state, the money one has. which means:\\n//  2) buying stock cause you lose money (- prices[i] above)\\n//  3) and selling stock cause you gain money (+ prices[i] above)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // 0 have, 1 don\\'t.\\n        int[][] dp = new int[prices.length][2];\\n        dp[0][0] = - prices[0];  // Buy at prices[0] (1st day).\\n        dp[0][1] = 0; // Impossible to sell at day 1. Keep it 0.\\n        for (int i = 1; i < prices.length; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][1] - prices[i], dp[i - 1][0]);\\n            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);\\n        }\\n        // Return the last day at the sell state.\\n        return dp[prices.length - 1][1];\\n    }\\n}\\n// Optimization:\\n// We don\\'t need a O(2n) size 2D arr to store every day.\\n// Just store the previous day\\'s sell or buy state is enough.\\n// Which makes the Space O(1).\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428296,
                "title": "all-c-solutions-from-brute-force-to-simple-one-pass",
                "content": "***All possible solutions in C++. Please Upvote if found useful!*** \\n*Ask doubts in comment section.*\\n\\n1. Iterative Brute Force with O(1) space complexity\\n```\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maxProfit=0;\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n && prices[j]>prices[i]; j++){\\n                sum += prices[j]-prices[i];\\n                if(sum>maxProfit)\\n                    maxProfit = sum;\\n                break;\\n            }\\n        }\\n        return maxProfit;\\n    }\\n```\\n2. Peak - Valley Approach: O(n) Single Pass Time and O(1) Space -> If we plot all the stock prices on graph, we can see this clearly that valleys and peaks(tips) of the graph are our only interest points.\\n```\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maxProfit=0;\\n        int valley = prices[0]; //Initialize valley\\n        int peak = prices[0];  //Initialize peak\\n        int i=0;\\n        while(i < n-1){\\n            //To find earliest valley\\n            while(i<n-1 && prices[i]>=prices[i+1])\\n                i++;\\n            valley = prices[i];\\n            \\n            //To find farthest peak\\n            while(i<n-1 && prices[i]<=prices[i+1])\\n                i++;\\n            peak = prices[i];\\n            maxProfit += peak - valley;            \\n        }\\n\\t\\t\\t\\treturn maxProfit\\n        \\n    }\\n```\\n3. Simple One Pass Approach (O(n) Time complexity and O(1) Space complexity)\\n\\t```\\t\\t\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        for (int i = 1; i < prices.size(); i++) {\\n            if (prices[i] > prices[i - 1])\\n                max_profit += prices[i] - prices[i - 1];\\n        }\\n        return max_profit;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maxProfit=0;\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n && prices[j]>prices[i]; j++){\\n                sum += prices[j]-prices[i];\\n                if(sum>maxProfit)\\n                    maxProfit = sum;\\n                break;\\n            }\\n        }\\n        return maxProfit;\\n    }\\n```\n```\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maxProfit=0;\\n        int valley = prices[0]; //Initialize valley\\n        int peak = prices[0];  //Initialize peak\\n        int i=0;\\n        while(i < n-1){\\n            //To find earliest valley\\n            while(i<n-1 && prices[i]>=prices[i+1])\\n                i++;\\n            valley = prices[i];\\n            \\n            //To find farthest peak\\n            while(i<n-1 && prices[i]<=prices[i+1])\\n                i++;\\n            peak = prices[i];\\n            maxProfit += peak - valley;            \\n        }\\n\\t\\t\\t\\treturn maxProfit\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886074,
                "title": "beginner-friendly-solution-100-space-efficient-and-100-time-efficient",
                "content": "```\\nint maxProfit(vector<int>& prices) \\n    {\\n        int profit=0;\\n        for(int i=0;i<prices.size()-1;i++)\\n        {\\n            if(prices[i]<prices[i+1])\\n                profit += prices[i+1]-prices[i];            \\n        }\\n        return profit;\\n    }\\n```\\n\\nExplaination : \\nPrices will go up and down, hence it will form a zig-zag curve. Part of the curve will go from up to down and part of the curve will go down to up.\\n\\nWe have to consider the part when it goes down to up i.e prices[i] < prices[i+1]. If that\\'s the case then add to your profit else ignore.\\n\\nHope it\\'s clear if not please let me know.\\nWill be happy to help.\\n\\nP.S: If this helps you, Please upvote it. It will motivate me put good posts in discussion forum.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices) \\n    {\\n        int profit=0;\\n        for(int i=0;i<prices.size()-1;i++)\\n        {\\n            if(prices[i]<prices[i+1])\\n                profit += prices[i+1]-prices[i];            \\n        }\\n        return profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 320865,
                "title": "c-o-n-linear-solution-pretty-straight-forward",
                "content": "With as many buys and sells and you\\'d like, it\\'s a very easy solution. Any two days are either a positive gain or a loss. Add up all the gains. Ignore the losses.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int aResult = 0;\\n        for (int i=1;i<prices.size();i++) {\\n            aResult = max(aResult, aResult + (prices[i] - prices[i - 1]));\\n        }\\n        return aResult;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int aResult = 0;\\n        for (int i=1;i<prices.size();i++) {\\n            aResult = max(aResult, aResult + (prices[i] - prices[i - 1]));\\n        }\\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240505,
                "title": "ruby-2-solutions-with-explanation",
                "content": "**Good Solution**\\nEssentially you want to find each peak and each valley, and every time you go from a peak to a valley, you\\'ll add the difference as profit. That would simulate buying at the valley, and selling at the peak. The first instance where the next price is higher, indicates a valley, so buy a share and indicate that you have a share. If you reach a peak, any point where the next price is lower, then if you have a share you can sell it and make your profit. Once you\\'ve reached the end, if you have a share, sell it off.\\n```\\ndef max_profit(prices)\\n     return 0 if prices.length < 2\\n    \\n     bought_share = false\\n     money = 0\\n     i = 0\\n    \\n     while i < prices.length - 1\\n         if prices[i] < prices[i + 1] && !bought_share\\n             bought_share = true\\n             money -= prices[i]\\n         end\\n         if prices[i] > prices[i + 1] && bought_share\\n             bought_share = false\\n             money += prices[i]\\n         end\\n         i += 1\\n     end\\n\\t \\n     money += prices[i] if bought_share\\n     money\\nend\\n```\\n\\n**Better Solution**\\nNow to show that you really know how to think beyond the obvious, you\\'ll want to answer this way. If you think about this question, all you really need to do is make profit anytime the next share price is higher than the current share price. You don\\'t need to reach the maximum price point on a run of shares that keep increasing, you can just calculate each step along the way, and put them together, and that\\'s the same as calculating the difference between the lowest point and the highest point. If the share prices are [1, 3, 9], 9 - 1 = 8. However, (3-1)+(9-3) = 8 as well. So just add profit for every little sub peak, and there you have it.\\n```\\ndef max_profit(prices)\\n    money = 0\\n    \\n    prices.each_with_index do |price, i|\\n        if prices[i + 1] && price < prices[i + 1]\\n            money += (prices[i + 1] - price)\\n        end\\n    end\\n    \\n    money \\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef max_profit(prices)\\n     return 0 if prices.length < 2\\n    \\n     bought_share = false\\n     money = 0\\n     i = 0\\n    \\n     while i < prices.length - 1\\n         if prices[i] < prices[i + 1] && !bought_share\\n             bought_share = true\\n             money -= prices[i]\\n         end\\n         if prices[i] > prices[i + 1] && bought_share\\n             bought_share = false\\n             money += prices[i]\\n         end\\n         i += 1\\n     end\\n\\t \\n     money += prices[i] if bought_share\\n     money\\nend\\n```\n```\\ndef max_profit(prices)\\n    money = 0\\n    \\n    prices.each_with_index do |price, i|\\n        if prices[i + 1] && price < prices[i + 1]\\n            money += (prices[i + 1] - price)\\n        end\\n    end\\n    \\n    money \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 159307,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(prices) <= 1:\\n            return 0\\n        l = 0\\n        r = 1\\n        tot = 0\\n        while r < len(prices):\\n            while r < len(prices)-1 and prices[l] >= prices[r]:\\n                l += 1\\n                r += 1\\n            while r < len(prices)-1 and prices[r+1] >= prices[r]:\\n                r += 1\\n            if prices[r] > prices[l]:\\n                tot += prices[r] - prices[l]\\n            l = r\\n            r += 1\\n        return tot\\n```\\nA simpler solution implementing the same algorithm:\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(prices) <= 1:\\n            return 0\\n        tot = 0\\n        for i in range(1,len(prices)):\\n            if prices[i] > prices[i-1]:\\n                tot += prices[i] - prices[i-1]\\n        return tot\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(prices) <= 1:\\n            return 0\\n        l = 0\\n        r = 1\\n        tot = 0\\n        while r < len(prices):\\n            while r < len(prices)-1 and prices[l] >= prices[r]:\\n                l += 1\\n                r += 1\\n            while r < len(prices)-1 and prices[r+1] >= prices[r]:\\n                r += 1\\n            if prices[r] > prices[l]:\\n                tot += prices[r] - prices[l]\\n            l = r\\n            r += 1\\n        return tot\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(prices) <= 1:\\n            return 0\\n        tot = 0\\n        for i in range(1,len(prices)):\\n            if prices[i] > prices[i-1]:\\n                tot += prices[i] - prices[i-1]\\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111149,
                "title": "clean-kotlin-solution",
                "content": "```\\nfun maxProfit(prices: IntArray): Int {\\n        return (1 until prices.size)\\n            .map {date -> prices[date] - prices[date - 1] }\\n            .sumBy { profit -> maxOf(profit, 0) }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun maxProfit(prices: IntArray): Int {\\n        return (1 until prices.size)\\n            .map {date -> prices[date] - prices[date - 1] }\\n            .sumBy { profit -> maxOf(profit, 0) }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39509,
                "title": "c-8ms-o-n-time-and-o-1-space",
                "content": "Actually it's much easier than the previous DP question. For this one, we just need to sum up all profits together.\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n\\t    int length = prices.size();\\n\\t    if (!length)\\n\\t    {\\n\\t\\t    return 0;\\n\\t    }\\n\\t    int profit = 0;\\n\\t    int temp = 0;\\n\\t    for (int i = length - 1; i > 0; i--)\\n\\t    {\\n\\t\\t    temp = prices[i] - prices[i-1];\\n\\t\\t    if (temp > 0)\\n\\t\\t    {\\n\\t\\t\\t    profit += temp;\\n\\t\\t    }\\n\\t    }\\n\\t\\n\\t    return profit;\\n    }",
                "solutionTags": [],
                "code": "Actually it's much easier than the previous DP question. For this one, we just need to sum up all profits together.\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n\\t    int length = prices.size();\\n\\t    if (!length)\\n\\t    {\\n\\t\\t    return 0;\\n\\t    }\\n\\t    int profit = 0;\\n\\t    int temp = 0;\\n\\t    for (int i = length - 1; i > 0; i--)\\n\\t    {\\n\\t\\t    temp = prices[i] - prices[i-1];\\n\\t\\t    if (temp > 0)\\n\\t\\t    {\\n\\t\\t\\t    profit += temp;\\n\\t\\t    }\\n\\t    }\\n\\t\\n\\t    return profit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39558,
                "title": "8ms-easy-c-solution",
                "content": "This problem is similar to [Best Time to Buy and Sell Stock][1]. Given `prices`, we find the day (denoted as `buy`) of the first local minimum and the day (denoted as `sell`) of the first local maximum (note that we initialize `sell` to be `buy + 1` each time to guarantee the transaction is valid). Then we earn the profit `prices[sell] - prices[buy]`, after which we update `buy` to be `sell + 1` to check for the remaining `prices`.\\n\\nThe code is as follows.\\n\\n    class Solution {\\n    public: \\n        int maxProfit(vector<int>& prices) {\\n            int buy = 0, sell = 0, profit = 0, n = prices.size();\\n            while (buy < n && sell < n) {\\n                while (buy + 1 < n && prices[buy + 1] < prices[buy])\\n                    buy++; \\n                sell = buy; \\n                while (sell + 1 < n && prices[sell + 1] > prices[sell])\\n                    sell++;\\n                profit += prices[sell] - prices[buy];\\n                buy = sell + 1;\\n            }\\n            return profit;\\n        }\\n    };\\n\\n[1]: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public: \\n        int maxProfit(vector<int>& prices) {\\n            int buy = 0, sell = 0, profit = 0, n = prices.size();\\n            while (buy < n && sell < n) {\\n                while (buy + 1 < n && prices[buy + 1] < prices[buy])\\n                    buy++; \\n                sell = buy; \\n                while (sell + 1 < n && prices[sell + 1] > prices[sell])\\n                    sell++;\\n                profit += prices[sell] - prices[buy];\\n                buy = sell + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3990075,
                "title": "beats-with-100-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwhen prices goes down buy the stock and if it goes up sell it...\\nIterate through all and sum up all profits!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size(),i,p;\\n        int profit=0,min=prices[0];\\n        for(i=1;i<n;i++) {\\n            if(prices[i]<min)\\n                min=prices[i];\\n            else if(prices[i]-min>0 )\\n            { \\n               profit+=prices[i]-min;\\n               min=prices[i];\\n            }\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size(),i,p;\\n        int profit=0,min=prices[0];\\n        for(i=1;i<n;i++) {\\n            if(prices[i]<min)\\n                min=prices[i];\\n            else if(prices[i]-min>0 )\\n            { \\n               profit+=prices[i]-min;\\n               min=prices[i];\\n            }\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774318,
                "title": "easy-to-understand-clear-code-c",
                "content": "\\n\\n# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/b32a0e29-fd1f-4f59-bf43-cd16edcf31f6_1689521691.2615888.png)\\n\\n# Approach\\n- max_profit=max_profit+prices[i] - prices[i-1];\\n\\n- jaha jaha profit hota jai usko max_profit me add krte jaooooo.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n    int max_profit=0;\\n\\n    for(int i=1;i<prices.size();i++){\\n        if(prices[i] > prices[i-1]){\\n            max_profit=max_profit+prices[i] - prices[i-1];\\n        }\\n    }\\n    return max_profit;   \\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       \\n        int buy = prices[0];\\n        int max_profit = 0;\\n\\n        for(int i=1; i<prices.size(); i++){\\n            if(prices[i]<=buy){\\n                buy = prices[i];\\n            }\\n            else{\\n                max_profit += prices[i] - buy;\\n                //most imp step \\n                // buy ko update krna hogaaaaaa\\n                buy = prices[i];\\n            }\\n        }\\n\\n        return max_profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n    int max_profit=0;\\n\\n    for(int i=1;i<prices.size();i++){\\n        if(prices[i] > prices[i-1]){\\n            max_profit=max_profit+prices[i] - prices[i-1];\\n        }\\n    }\\n    return max_profit;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       \\n        int buy = prices[0];\\n        int max_profit = 0;\\n\\n        for(int i=1; i<prices.size(); i++){\\n            if(prices[i]<=buy){\\n                buy = prices[i];\\n            }\\n            else{\\n                max_profit += prices[i] - buy;\\n                //most imp step \\n                // buy ko update krna hogaaaaaa\\n                buy = prices[i];\\n            }\\n        }\\n\\n        return max_profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770405,
                "title": "c-easiest-solution-kaam-ki-baat-no-bakwaas",
                "content": "- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![graph.webp](https://assets.leetcode.com/users/images/e8934b4f-88ab-4e64-a44a-1b64b7dd3738_1689450378.8204722.webp)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n        int pro = 0;\\n        for(int i = 1;i < v.size();i++){\\n            if(v[i - 1] < v[i]) \\n                pro += (v[i] - v[i - 1]);\\n        }\\n        return pro;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n        int pro = 0;\\n        for(int i = 1;i < v.size();i++){\\n            if(v[i - 1] < v[i]) \\n                pro += (v[i] - v[i - 1]);\\n        }\\n        return pro;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746496,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //General Approach\\n        int oldPrices = prices[0];\\n        int profit = 0;\\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i]<oldPrices){\\n                //update the oldPrices\\n                oldPrices = prices[i];\\n            }\\n            else{\\n                //find Profit\\n                profit +=prices[i]-oldPrices;\\n                //update the oldPrices\\n                oldPrices = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //General Approach\\n        int oldPrices = prices[0];\\n        int profit = 0;\\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i]<oldPrices){\\n                //update the oldPrices\\n                oldPrices = prices[i];\\n            }\\n            else{\\n                //find Profit\\n                profit +=prices[i]-oldPrices;\\n                //update the oldPrices\\n                oldPrices = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668889,
                "title": "c-recurssive-memoization-dp",
                "content": "# Recursive approach will give TLE\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#   Memoization Code\\n```\\n// class Solution {\\n//     private:\\n//     //recursive approach gives TLE in last 3 cases\\n//     int f(int index, int buy, vector<int>& prices){\\n//         if(index==prices.size()) return 0;\\n\\n//             int profit=0;\\n//             //ya to buy karega ya nhi karega(profit=sell-buy)\\n//         if(buy){\\n//             profit=max(-prices[index]+f(index+1, 0, prices), 0+f(index+1, 1, prices));\\n//         }\\n//         //ya to sell karega ya nhi karega\\n//         else{\\n//             profit=max(prices[index]+f(index+1, 1, prices), 0+f(index+1, 0, prices));\\n//          }\\n//          return profit;\\n//     }\\n// public:\\n//     int maxProfit(vector<int>& prices) {\\n//         return f(0,1,prices);\\n//     }\\n// };\\n\\nclass Solution {\\n    private:\\n    //MEMOIZATION approach(accepted)\\n    int f(int index, int buy, vector<int>& prices, vector<vector<int>>&dp){\\n        if(index==prices.size()) return 0;\\n\\n            int profit=0;\\n            //ya to buy karega ya nhi karega(profit=sell-buy)\\n            if(dp[index][buy]!=-1) return dp[index][buy];\\n        if(buy){\\n            profit=max(-prices[index]+f(index+1, 0, prices,dp), 0+f(index+1, 1, prices, dp));\\n        }\\n        //ya to sell karega ya nhi karega\\n        else{\\n            profit=max(prices[index]+f(index+1, 1, prices,dp), 0+f(index+1, 0, prices, dp));\\n         }\\n         return dp[index][buy] = profit;\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(prices.size()+1, vector<int>(2,-1));\\n        return f(0,1,prices,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// class Solution {\\n//     private:\\n//     //recursive approach gives TLE in last 3 cases\\n//     int f(int index, int buy, vector<int>& prices){\\n//         if(index==prices.size()) return 0;\\n\\n//             int profit=0;\\n//             //ya to buy karega ya nhi karega(profit=sell-buy)\\n//         if(buy){\\n//             profit=max(-prices[index]+f(index+1, 0, prices), 0+f(index+1, 1, prices));\\n//         }\\n//         //ya to sell karega ya nhi karega\\n//         else{\\n//             profit=max(prices[index]+f(index+1, 1, prices), 0+f(index+1, 0, prices));\\n//          }\\n//          return profit;\\n//     }\\n// public:\\n//     int maxProfit(vector<int>& prices) {\\n//         return f(0,1,prices);\\n//     }\\n// };\\n\\nclass Solution {\\n    private:\\n    //MEMOIZATION approach(accepted)\\n    int f(int index, int buy, vector<int>& prices, vector<vector<int>>&dp){\\n        if(index==prices.size()) return 0;\\n\\n            int profit=0;\\n            //ya to buy karega ya nhi karega(profit=sell-buy)\\n            if(dp[index][buy]!=-1) return dp[index][buy];\\n        if(buy){\\n            profit=max(-prices[index]+f(index+1, 0, prices,dp), 0+f(index+1, 1, prices, dp));\\n        }\\n        //ya to sell karega ya nhi karega\\n        else{\\n            profit=max(prices[index]+f(index+1, 1, prices,dp), 0+f(index+1, 0, prices, dp));\\n         }\\n         return dp[index][buy] = profit;\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(prices.size()+1, vector<int>(2,-1));\\n        return f(0,1,prices,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667918,
                "title": "python-short-1-liner-functional-programming",
                "content": "# Approach\\n1. For every day $$d_i$$, if $$prices[d_i] < prices[d_{i + 1}]$$ then buy the stock on $$d_i$$ and sell it on $$d_{i + 1}$$ else do nothing.\\n\\n2. Continue this for each day and return the `sum` of all the profits.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of prices`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: list[int]) -> int:\\n        return sum(max(b - a, 0) for a, b in pairwise(prices))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: list[int]) -> int:\\n        return sum(max(b - a, 0) for a, b in pairwise(prices))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343157,
                "title": "go-greedy-solution",
                "content": "# Intuition\\n\\nBy greedily selling every time we see a value higher than the current minimum, we can ensure the maximum possible profit. \\n\\nWith this approach, the current minimum is always the previous day\\'s price (as long as it is lower than the current day\\'s price).\\n\\n# Approach\\n\\nThere are two cases to consider:\\n\\n1. `prices[i] < prices[i-1]`\\n    We set `prices[i]` as the current minimum, and __forget__ any previous values\\n2. `prices[i] > prices[i-1]`\\n    We sell greedily to record whatever profit is available, and __reset__ the minimum to `prices[i]`\\n\\nThe above two conditions mean the problem can be solved simply by comparing `prices[i]` and `prices[i-1]`. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$ because we only scan the input array once.\\n\\n- Space complexity: $$O(1)$$ because we only store a local variables to track the result.\\n\\n# Code\\n```\\nfunc maxProfit(prices []int) int {\\n    profit := 0\\n    // no profit available at index 0, so start at index 1\\n    for i := 1; i < len(prices); i++ {\\n        // Only when the current price is higher than the previous\\n        // can we make a profitable sale.\\n        if prices[i] > prices[i-1] {\\n            profit += prices[i] - prices[i-1]\\n        }\\n        // The else case is handled implicitly by incrementing i.\\n        // When prices[i] is lower than prices[i-1], we just skip\\n        // the sale. \\n        //\\n        // If this is confusing, try keeping a `min` variable yourself,\\n        // and you\\'ll soon realise it\\'s redundant.\\n    }\\n    return profit\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc maxProfit(prices []int) int {\\n    profit := 0\\n    // no profit available at index 0, so start at index 1\\n    for i := 1; i < len(prices); i++ {\\n        // Only when the current price is higher than the previous\\n        // can we make a profitable sale.\\n        if prices[i] > prices[i-1] {\\n            profit += prices[i] - prices[i-1]\\n        }\\n        // The else case is handled implicitly by incrementing i.\\n        // When prices[i] is lower than prices[i-1], we just skip\\n        // the sale. \\n        //\\n        // If this is confusing, try keeping a `min` variable yourself,\\n        // and you\\'ll soon realise it\\'s redundant.\\n    }\\n    return profit\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2986446,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int ans = 0;\\n        for(int i=1; i<n; i++) {\\n            int dif = prices[i] - prices[i-1];\\n            if(dif > 0) ans += dif;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int ans = 0;\\n        for(int i=1; i<n; i++) {\\n            int dif = prices[i] - prices[i-1];\\n            if(dif > 0) ans += dif;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778944,
                "title": "java-100-faster-o-n",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit =0;\\n        for(int i =1;i<prices.length;i++)\\n        {\\n            if(prices[i]>prices[i-1])\\n            {\\n                profit=profit+(prices[i]-prices[i-1]);\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit =0;\\n        for(int i =1;i<prices.length;i++)\\n        {\\n            if(prices[i]>prices[i-1])\\n            {\\n                profit=profit+(prices[i]-prices[i-1]);\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210061,
                "title": "java-in-depth-explanation-o-n-time-o-1-space",
                "content": "Actually, the problem is not that hard as it seems. In problem description, we can buy it then immediately sell it on the same day. That means **\"we can sell then buy the same stock on the same day\"**. That makes the problem surprisingly easier. \\n\\n  `profit = prices[i] - prices[i-1]` Whenever `profit > 0`, we update `max` as `max += profit`. That\\'s it ! We can achieve O(n) time | O(1) space w/ such a straightforward solution.\\n\\n```\\nclass Solution\\n{\\n    public int maxProfit(int[] prices) \\n    {\\n        // O(n) time | O(1) space\\n        \\n        int max = 0;\\n        \\n        for(int i = 1; i < prices.length; i++)\\n        {\\n            if(prices[i] > prices[i-1])\\n                max += prices[i] - prices[i-1];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int maxProfit(int[] prices) \\n    {\\n        // O(n) time | O(1) space\\n        \\n        int max = 0;\\n        \\n        for(int i = 1; i < prices.length; i++)\\n        {\\n            if(prices[i] > prices[i-1])\\n                max += prices[i] - prices[i-1];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175471,
                "title": "buy-the-dip-cannot-get-easier-than-this",
                "content": "**There is a classical saying in the stock market - \"Buy the Dip\".\\nSame concept you need to apply here\\nCompare two consecutive days and if you are making a profit, just buy on 1st day and sell on 2nd day**\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) \\n    {\\n        int profit = 0;\\n        for(int i = 1 ; i < prices.length ; i++)\\n            profit += Math.max(0 , prices[i] - prices[i-1]);\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) \\n    {\\n        int profit = 0;\\n        for(int i = 1 ; i < prices.length ; i++)\\n            profit += Math.max(0 , prices[i] - prices[i-1]);\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004963,
                "title": "c-o-n-time-o-1-space-one-pass-algorithm",
                "content": "\\nThe problem is simple and can be approached in a greedy way .If we look the values as points on a graph , we can say that we need to buy a stock at every minima and sell it at the next maxima whenever it comes . \\nE.g.\\n1 2 3 4 5 1 9 \\nLike ,\\nWe can buy it at 1 and the sell for 5 , then again buy it for 1 and sell for 9 making a total profit of 4+8 = 12 .\\n\\n# Time Complexity : O(n)\\n# Space Complexity : O(1)\\n\\n```\\n       int profit =0;  \\n        int buy = prices[0];  \\n        \\n        for(int i=0;i<prices.size();i++){\\n            if(i == prices.size()-1){\\n                \\n                profit += prices[i]-buy;\\n                break;\\n            }\\n            \\n            if(prices[i]> prices[i+1]){   \\n                //*** if we see that i+1 has lower price than i we sell it prices[i] and buy again for prices[i+1] \\n                \\n                profit += prices[i]-buy;\\n                buy = prices[i+1];\\n            }\\n            \\n         \\n            \\n            \\n        }\\n        \\n        \\n        \\n        return profit;\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n       int profit =0;  \\n        int buy = prices[0];  \\n        \\n        for(int i=0;i<prices.size();i++){\\n            if(i == prices.size()-1){\\n                \\n                profit += prices[i]-buy;\\n                break;\\n            }\\n            \\n            if(prices[i]> prices[i+1]){   \\n                //*** if we see that i+1 has lower price than i we sell it prices[i] and buy again for prices[i+1] \\n                \\n                profit += prices[i]-buy;\\n                buy = prices[i+1];\\n            }\\n            \\n         \\n            \\n            \\n        }\\n        \\n        \\n        \\n        return profit;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915204,
                "title": "easy-dynamic-programming-solution-explained",
                "content": "Let\\'s assume `P(k)` is our max profit if we buy/sell stocks during `0..k` days.\\n`P(0) = 0` \\u2013 is our base case. We have 0 profit: if we only traded during 1 day, we bought 1 stock for `price[0]` and didn\\'t have the chance to sell for a higher price.\\n\\nHow do we determine `P(k)`?\\nOn day `k` we have several options:\\n1. do nothing\\n2. sell stock that we might have previously bought\\n\\nThe first case is simple. Since we do nothing on day `k`, our total max profit didn\\'t change and is the same as `P(k-1)`.\\n\\nLet\\'s now consider the second case. On day `k` we sell a stock that we previously bought on some day `j`. If we do that, we will potentially get profit or loss in this transaction: `prices[k] - prices[j]`. But our total profit/loss will be `P(j) + prices[k] - prices[j]`. We need to maximize the total profit, so we need to consider all `j` such that `j < k`. \\nIf we try to write it down mathematically, we will get:\\n`P(k) = max { P(j) + prices[k] - prices[j] } for j < k`.\\n\\nCoding according to this formula naively will produce `O(N^2)` algorithm. But it\\'s easy to optimize.\\nWe can see that in the formula, `k` is fixed, so `price[k]` is constant and we can move it out for `max { ... }`:\\n`P(k) = prices[k] + max { P(j) - prices[j] } for j < k`.\\n\\nNow let `T(k) = max { P(j) - prices[j] }  for j < k`, then `P(k) = prices[k] + T(k)`.\\n\\nCombining all this with our \"do nothing\" case, we get:\\n`P(k) = max { P(k-1), prices[k] + T(k) }`, where `T(k) = max { P(j) - prices[j] }  for j < k, P(0) = 0`.\\n\\nSince to compute `P(k)` we only need `P(k-1)` and `T(k)`, we don\\'t need to allocate array for it.\\n`T(k)` is just the current maximum of `P(j) - prices[j]` and can be computed as `T(k) = max { T(k-1),  P(k-1) - prices[k-1]`. We don\\'t need to allocate an array for it either.\\n\\n```\\nclass Solution {\\n    fun maxProfit(prices: IntArray): Int {\\n        if (prices.isEmpty()) return 0\\n        \\n        // p[k] = maxOf(prices[k]-prices[j] + p[j]) \\n        //      = prices[k] + maxOf(p[j] - prices[j])\\n        //      = prices[k] + t[k]\\n        var t = -prices[0] // t[0]\\n        var p = 0 // p[0]\\n        \\n\\t\\tfor (k in prices.indices) {\\n\\t\\t\\t// colculate next p[k]\\n            p = maxOf(p, prices[k] + t)\\n            t = maxOf(t, p - prices[k])\\n        } \\n        \\n        return p\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    fun maxProfit(prices: IntArray): Int {\\n        if (prices.isEmpty()) return 0\\n        \\n        // p[k] = maxOf(prices[k]-prices[j] + p[j]) \\n        //      = prices[k] + maxOf(p[j] - prices[j])\\n        //      = prices[k] + t[k]\\n        var t = -prices[0] // t[0]\\n        var p = 0 // p[0]\\n        \\n\\t\\tfor (k in prices.indices) {\\n\\t\\t\\t// colculate next p[k]\\n            p = maxOf(p, prices[k] + t)\\n            t = maxOf(t, p - prices[k])\\n        } \\n        \\n        return p\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819596,
                "title": "java-recursion-dynamic-programming-step-by-step",
                "content": "Well there are more efficient ways to solve this problem but I consider this code is helpful in understanding recursion+DP approach. Below is the recursive approach. I further memoise it. Through memoising it is able to pass all test cases.\\n\\nRecursion plays important role here. At any specific day we will have 3 options - \\n\\n1. Buy the stock\\n2. Sell the stock\\n3. Neither buy nor sell, move to next day\\n\\nNow for obvious reasons we cannot sell on the first day(as we will have no holdings). Similarly we cannot buy on the last day. It is also specified in the problem that we can sell the stock and buy it on the same day, so there is chance that we don\\'t move on the next day and remain there only. But for buy condition we need to move on next day because buying and selling on the same day will not affect aur answer (as net profit will be 0).\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        return helper(0, -1, n, prices);\\n    }\\n    \\n    public int helper(int day, int holding, int n, int[] arr){\\n        if(day>=n) return 0;\\n        int buy = day!=n-1 && holding==-1 ? helper(day+1, arr[day], n, arr) : 0;\\n        int sell = day!=0 && holding!=-1 ? arr[day]-holding + helper(day, -1, n, arr) : 0;\\n        int leave = helper(day+1, holding, n, arr);\\n        return Math.max(leave, Math.max(buy, sell));\\n    }\\n    \\n}\\n```\\n\\nAfter memoising (Top-Down Approach) - \\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] tp = new int[n];\\n        Arrays.fill(tp, -1);\\n        return helper(0, -1, n, prices, tp);\\n    }\\n    \\n    public int helper(int day, int holding, int n, int[] arr, int[] tp){\\n        if(day>=n) return 0;\\n        if(tp[day]!=-1) return tp[day];\\n        int buy = day!=n-1 && holding==-1 ? helper(day+1, arr[day], n, arr, tp) : 0;\\n        int sell = day!=0 && holding!=-1 ? arr[day]-holding + helper(day, -1, n, arr, tp) : 0;\\n        int leave = helper(day+1, holding, n, arr, tp);\\n        return tp[day] = Math.max(leave, Math.max(buy, sell));\\n    }\\n    \\n}\\n```\\n\\nThanks, you can suggest more optimisations to this approach (or even provide a better one in the comments!! :)).",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        return helper(0, -1, n, prices);\\n    }\\n    \\n    public int helper(int day, int holding, int n, int[] arr){\\n        if(day>=n) return 0;\\n        int buy = day!=n-1 && holding==-1 ? helper(day+1, arr[day], n, arr) : 0;\\n        int sell = day!=0 && holding!=-1 ? arr[day]-holding + helper(day, -1, n, arr) : 0;\\n        int leave = helper(day+1, holding, n, arr);\\n        return Math.max(leave, Math.max(buy, sell));\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] tp = new int[n];\\n        Arrays.fill(tp, -1);\\n        return helper(0, -1, n, prices, tp);\\n    }\\n    \\n    public int helper(int day, int holding, int n, int[] arr, int[] tp){\\n        if(day>=n) return 0;\\n        if(tp[day]!=-1) return tp[day];\\n        int buy = day!=n-1 && holding==-1 ? helper(day+1, arr[day], n, arr, tp) : 0;\\n        int sell = day!=0 && holding!=-1 ? arr[day]-holding + helper(day, -1, n, arr, tp) : 0;\\n        int leave = helper(day+1, holding, n, arr, tp);\\n        return tp[day] = Math.max(leave, Math.max(buy, sell));\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074144,
                "title": "javascript-one-liner-faster-than-80-space-less-than-86",
                "content": "```\\nreturn prices.reduce((acc,curr,i)=>acc+Math.max(0,i && prices[i]-prices[i-1]),0);\\n```",
                "solutionTags": [],
                "code": "```\\nreturn prices.reduce((acc,curr,i)=>acc+Math.max(0,i && prices[i]-prices[i-1]),0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832626,
                "title": "easy-js-solution",
                "content": "```\\n/*\\nSolution\\n\\nProfit from Buying - Selling - Re-buying Selling\\nand\\nProfit from Buying - Wait for Best price - Selling\\nare the same. That\\'s why the logic behind this solution.\\n*/\\nvar maxProfit = function(prices) {\\n    if (prices === null || prices.length === 0) {\\n        return 0;\\n    }\\n    let profit = 0;\\n    let buyingPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        if (prices[i] > buyingPrice) {\\n            profit += prices[i] - buyingPrice;\\n            buyingPrice = prices[i]; // Re-buying \\n        } else if (prices[i] < buyingPrice) {\\n            buyingPrice = prices[i]; // Better price\\n        }\\n    }\\n    return profit;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nSolution\\n\\nProfit from Buying - Selling - Re-buying Selling\\nand\\nProfit from Buying - Wait for Best price - Selling\\nare the same. That\\'s why the logic behind this solution.\\n*/\\nvar maxProfit = function(prices) {\\n    if (prices === null || prices.length === 0) {\\n        return 0;\\n    }\\n    let profit = 0;\\n    let buyingPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        if (prices[i] > buyingPrice) {\\n            profit += prices[i] - buyingPrice;\\n            buyingPrice = prices[i]; // Re-buying \\n        } else if (prices[i] < buyingPrice) {\\n            buyingPrice = prices[i]; // Better price\\n        }\\n    }\\n    return profit;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788360,
                "title": "c-simple-solution-with-local-minima-and-maxima-explained-99-time-82-space",
                "content": "I approached this problem with a stock market perspective - what would you do if you were actually there, with a crystal ball.\\n\\nSo I decided to go hunting for local minima (because that is how you properly do the plural form of Latin *-um* words!) and local maxima, defined as numbers who are respectively lower or higher than their neighbours.\\n\\nI don\\'t even need to store the maxima, since every time I catch them, I can just increase my accumulator variable `res`  by a `n - lMin` amount and move on.\\n\\nOnce I parsed the whole vector, I return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int lMin = prices[0], res = 0, lastValue = prices.size() - 1, n;\\n        for (int i = 0; i < prices.size(); i++) {\\n            n = prices[i];\\n            // checking if the value is a local min\\n            if ((!i || prices[i - 1] > n) && (i == lastValue || n <= prices[i + 1])) {\\n                lMin = n;\\n            }\\n            // checking if the value is a local max\\n            if ((!i || prices[i - 1] < n) && (i == lastValue || n >= prices[i + 1])) {\\n                res += n - lMin;\\n                lMin = n;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThen I realised that unlike the real stock market, there are no transactions costs here, so I might as well think of selling and buying every single time the previous value suggest so and I got this more efficient solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int prev = prices[0], res = 0;\\n        for (int curr: prices) {\\n            if (prev < curr) res += curr - prev;\\n            prev = curr;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nI guess there are times in which too much domain knowledge is more of a burden than an asset.\\n\\nDiscussion of the most general case of `k` different sales [here](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/900061/).",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int lMin = prices[0], res = 0, lastValue = prices.size() - 1, n;\\n        for (int i = 0; i < prices.size(); i++) {\\n            n = prices[i];\\n            // checking if the value is a local min\\n            if ((!i || prices[i - 1] > n) && (i == lastValue || n <= prices[i + 1])) {\\n                lMin = n;\\n            }\\n            // checking if the value is a local max\\n            if ((!i || prices[i - 1] < n) && (i == lastValue || n >= prices[i + 1])) {\\n                res += n - lMin;\\n                lMin = n;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int prev = prices[0], res = 0;\\n        for (int curr: prices) {\\n            if (prev < curr) res += curr - prev;\\n            prev = curr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564905,
                "title": "super-easy-cpp-solution",
                "content": "The basic idea is ->To get maximum profit we need to buy a share if it\\'s price is going to increase the next day \\n\\n```\\n int maxProfit(vector<int>& prices) {\\n       \\n        int maxProfit = 0;\\n        int n=prices.size();\\n        for(int i = 1; i < n; i++) {\\n            int j = i - 1;\\n            \\n            if(prices[i] - prices[j]>0) {\\n                maxProfit += (prices[i] - prices[j]);\\n            }\\n        }\\n        \\n        return maxProfit;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int maxProfit(vector<int>& prices) {\\n       \\n        int maxProfit = 0;\\n        int n=prices.size();\\n        for(int i = 1; i < n; i++) {\\n            int j = i - 1;\\n            \\n            if(prices[i] - prices[j]>0) {\\n                maxProfit += (prices[i] - prices[j]);\\n            }\\n        }\\n        \\n        return maxProfit;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417536,
                "title": "python3-accepted-answer-simple-to-code-and-understand",
                "content": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_profit = 0\\n        for day in range(len(prices) - 1):\\n            # if profit would be negative max(profit, 0)\\n            max_profit += max(prices[day + 1] - prices[day], 0)\\n        return max_profit\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_profit = 0\\n        for day in range(len(prices) - 1):\\n            # if profit would be negative max(profit, 0)\\n            max_profit += max(prices[day + 1] - prices[day], 0)\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382021,
                "title": "simple-c-solution",
                "content": "```\\n\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int total = 0;\\n        for(int i=0 ; i < prices.Length - 1; i++)\\n        {\\n            if(prices[i+1] > prices[i])\\n                total+= prices[i+1] - prices[i];\\n        }\\n        return total;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int total = 0;\\n        for(int i=0 ; i < prices.Length - 1; i++)\\n        {\\n            if(prices[i+1] > prices[i])\\n                total+= prices[i+1] - prices[i];\\n        }\\n        return total;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292619,
                "title": "javascript-reduce-solution-faster-than-97-29-less-than-93-19",
                "content": "Similar to [My post about Question 121.](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/292608/javascript-reduce-solution-faster-than-9931-less-than-9371)\\n```\\nvar maxProfit = function(prices) {\\n    let diff = 0\\n    if (prices.length > 0) { // []\\n        prices.reduce((acc, next) => {\\n            if (next > acc) {\\n                diff += next - acc\\n            }\\n            return next\\n        })\\n    }\\n    return diff\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function(prices) {\\n    let diff = 0\\n    if (prices.length > 0) { // []\\n        prices.reduce((acc, next) => {\\n            if (next > acc) {\\n                diff += next - acc\\n            }\\n            return next\\n        })\\n    }\\n    return diff\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271867,
                "title": "python-greedy",
                "content": "Since we can transaction as many as we want, we can gain profit from every stock price increase.\\nSuppose ```[xi,xi+1,...xj]``` is a range of increasing price, we can buy at ```i``` and sell at ```j```.\\nSo whenver ```prices[i] > prices[i-1]```, we add ```price[i]-price[i-1]``` to our profit.\\n```\\ndef maxProfit(prices):\\n\\treturn sum(prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]>prices[i])\\n```",
                "solutionTags": [],
                "code": "```[xi,xi+1,...xj]```\n```i```\n```j```\n```prices[i] > prices[i-1]```\n```price[i]-price[i-1]```\n```\\ndef maxProfit(prices):\\n\\treturn sum(prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]>prices[i])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 231869,
                "title": "top-down-dp-logical-thinking",
                "content": "> we can decide 1st transaction as buy on prices[lo] and sell on prices[hi]\\n> the 2nd transaction may start at day hi + 1 or latter\\n> assume we know max profit from day hi + 1 (to prices.length - 1)\\n> `max profit from day i, state[i] = max(prices[hi] - prices[lo] + state[hi + 1])`\\n> we define `maxProfitFrom(start)` to represent `state[i]` and enumerate `lo, hi`\\n> we add memorization to avoid duplicate calls on maxProfitFrom\\n```\\n    private int[] memo; // Memorization to avoid duplicate calls on maxProfitFrom.\\n    \\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length == 0) return 0;\\n        \\n        memo = new int[prices.length];\\n        return maxProfitFrom(prices, 0);\\n    }\\n    \\n    private int maxProfitFrom(int[] prices, int start) {\\n        if (start == prices.length) return 0;\\n        if (memo[start] != 0) return memo[start];\\n        \\n        int maxProfit = 0;\\n        for (int lo = start; lo < prices.length - 1; lo++) {\\n            int maxProfitBuyOnLo = 0;\\n            for (int hi = lo + 1; hi < prices.length; hi++) {\\n                if (prices[hi] > prices[lo]) maxProfitBuyOnLo = Math.max(maxProfitBuyOnLo, prices[hi] - prices[lo] + maxProfitFrom(prices, hi + 1));\\n            }\\n            maxProfit = Math.max(maxProfit, maxProfitBuyOnLo);\\n        }\\n        \\n        memo[start] = maxProfit;\\n        return maxProfit;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    private int[] memo; // Memorization to avoid duplicate calls on maxProfitFrom.\\n    \\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length == 0) return 0;\\n        \\n        memo = new int[prices.length];\\n        return maxProfitFrom(prices, 0);\\n    }\\n    \\n    private int maxProfitFrom(int[] prices, int start) {\\n        if (start == prices.length) return 0;\\n        if (memo[start] != 0) return memo[start];\\n        \\n        int maxProfit = 0;\\n        for (int lo = start; lo < prices.length - 1; lo++) {\\n            int maxProfitBuyOnLo = 0;\\n            for (int hi = lo + 1; hi < prices.length; hi++) {\\n                if (prices[hi] > prices[lo]) maxProfitBuyOnLo = Math.max(maxProfitBuyOnLo, prices[hi] - prices[lo] + maxProfitFrom(prices, hi + 1));\\n            }\\n            maxProfit = Math.max(maxProfit, maxProfitBuyOnLo);\\n        }\\n        \\n        memo[start] = maxProfit;\\n        return maxProfit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 118222,
                "title": "dp-version-solution",
                "content": "```\\nclass Solution(object):\\n    def maxProfitDP(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(prices)\\n        if len(prices) <= 1:\\n            return 0\\n        # We use a two dimensional array to represent states, 0 means sell, 1 means buy \\n        dp = [[0] * 2 for _ in xrange(n)]\\n        dp[0][1] = -prices[0]\\n        for i in xrange(1, n):\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n        return dp[n-1][0]\\n\\n    def maxProfitOptimizedDP(self, prices):\\n        n = len(prices)\\n        if len(prices) <= 1:\\n            return 0\\n        prev_sell = 0\\n        prev_buy = -prices[0]\\n        for i in xrange(1, n):\\n            curr_sell = max(prev_sell, prev_buy + prices[i])\\n            curr_buy = max(prev_buy, prev_sell - prices[i])         \\n            prev_sell = curr_sell\\n            prev_buy = curr_buy\\n        return prev_sell\\n\\n    def maxProfitGreedy(self, prices):\\n        max_profit = 0\\n        for i in xrange(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                max_profit += prices[i] - prices[i-1]\\n        return max_profit\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfitDP(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(prices)\\n        if len(prices) <= 1:\\n            return 0\\n        # We use a two dimensional array to represent states, 0 means sell, 1 means buy \\n        dp = [[0] * 2 for _ in xrange(n)]\\n        dp[0][1] = -prices[0]\\n        for i in xrange(1, n):\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n        return dp[n-1][0]\\n\\n    def maxProfitOptimizedDP(self, prices):\\n        n = len(prices)\\n        if len(prices) <= 1:\\n            return 0\\n        prev_sell = 0\\n        prev_buy = -prices[0]\\n        for i in xrange(1, n):\\n            curr_sell = max(prev_sell, prev_buy + prices[i])\\n            curr_buy = max(prev_buy, prev_sell - prices[i])         \\n            prev_sell = curr_sell\\n            prev_buy = curr_buy\\n        return prev_sell\\n\\n    def maxProfitGreedy(self, prices):\\n        max_profit = 0\\n        for i in xrange(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                max_profit += prices[i] - prices[i-1]\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39503,
                "title": "a-easy-understand-c-solution",
                "content": "    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int maxProfit = 0;\\n            for( int i = 1; i < prices.size(); i++) {\\n                if(prices[i] > prices[i - 1]) maxProfit += (prices[i] - prices[i - 1]);\\n            }\\n            return maxProfit;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int maxProfit = 0;\\n            for( int i = 1; i < prices.size(); i++) {\\n                if(prices[i] > prices[i - 1]) maxProfit += (prices[i] - prices[i - 1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 39518,
                "title": "4-lines-java-solution-very-easy",
                "content": "    public class Solution {\\n    public int maxProfit(int[] prices) {\\n            \\n        int profit = 0;\\n        \\n        for(int i=1; i<prices.length; i++)\\n                profit += ( prices[i]>prices[i-1] ? prices[i]-prices[i-1] : 0);\\n             \\n        return profit;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxProfit(int[] prices) {\\n            \\n        int profit = 0;\\n        \\n        for(int i=1; i<prices.length; i++)\\n                profit += ( prices[i]>prices[i-1] ? prices[i]-prices[i-1] : 0);\\n             \\n        return profit;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 39521,
                "title": "simple-solution-with-concise-explanation",
                "content": "Assume we buy a stock yesterday, what will we do today? \\n\\n - If today's price is higher than yesterday, we can sell it right now and get profit.\\n - What's about tomorrow the price grows higher?We just buy today's stock, that's equal to that we buy yesterday and sell tomorrow. \\n - What if today's price is lower than yesterday's? We just pretend we buy today's stock but not yesterday's .\\n - In a word, what's we should do is compare today's price to yesterday's.If higher,we get profit,\\nset buy-in price to today's price.If lower, we don't get profit,and set buy-in price to today's price.\\n\\n\\n\\n  \\n\\n\\n \\n\\n  ` int res=0,buy_in=prices[0];`\\n  \\n ` for(int i=1;i<n;i++){`\\n     \\n  ` int profit = prices[i]-buy_in;`\\n\\n  `  if(profit>0)`\\n\\n   ` res += profit;`\\n        \\n    `buy_in = prices[i];`\\n    \\n    `}`\\n\\n    `return res;`",
                "solutionTags": [],
                "code": "Assume we buy a stock yesterday, what will we do today? \\n\\n - If today's price is higher than yesterday, we can sell it right now and get profit.\\n - What's about tomorrow the price grows higher?We just buy today's stock, that's equal to that we buy yesterday and sell tomorrow. \\n - What if today's price is lower than yesterday's? We just pretend we buy today's stock but not yesterday's .\\n - In a word, what's we should do is compare today's price to yesterday's.If higher,we get profit,\\nset buy-in price to today's price.If lower, we don't get profit,and set buy-in price to today's price.\\n\\n\\n\\n  \\n\\n\\n \\n\\n  ` int res=0,buy_in=prices[0];`\\n  \\n ` for(int i=1;i<n;i++){`\\n     \\n  ` int profit = prices[i]-buy_in;`\\n\\n  `  if(profit>0)`\\n\\n   ` res += profit;`\\n        \\n    `buy_in = prices[i];`\\n    \\n    `}`\\n\\n    `return res;`",
                "codeTag": "Unknown"
            },
            {
                "id": 39577,
                "title": "a-5ms-c-solution",
                "content": "This problem can be called \"cumulative gain\" instead. I hope this is clear enough.\\n\\n    int maxProfit(int* prices, int pricesSize) {\\n        int cumulativeGain = 0;\\n        int lastVal = prices[0];\\n        for (int i = 1; i < pricesSize; i++) {\\n            if (prices[i] > lastVal) {\\n                cumulativeGain += prices[i] - lastVal;\\n            }\\n            lastVal = prices[i];\\n        }\\n        return cumulativeGain;\\n    }",
                "solutionTags": [],
                "code": "This problem can be called \"cumulative gain\" instead. I hope this is clear enough.\\n\\n    int maxProfit(int* prices, int pricesSize) {\\n        int cumulativeGain = 0;\\n        int lastVal = prices[0];\\n        for (int i = 1; i < pricesSize; i++) {\\n            if (prices[i] > lastVal) {\\n                cumulativeGain += prices[i] - lastVal;\\n            }\\n            lastVal = prices[i];\\n        }\\n        return cumulativeGain;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3936284,
                "title": "beats-98-c-iterative-solution-o-n-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n// See firstly acc to question we can buy and sell stocks any number of times now the intuition is until the stock prices will be increasing we will not sell the stock and the index after  which the stocks are decreasing we will sell the stock and again start with the next index in order to get the maximum profit\\n\\n# Complexity\\n- Time complexity:\\n O(N)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        //  base case\\n        if( prices.size() == 1)\\n        {\\n            return 0; // as no profit will come\\n        }\\n       \\n    int ans = 0;\\n    int startdayprice = prices[0];\\n    int index = 0;\\n    while(index < prices.size())\\n        {\\n            int profitgot = 0;\\n            while(index < prices.size() - 1 && prices[index] <= prices[index+1] )\\n            {\\n                index++;\\n            }\\n            if( index < prices.size()  )\\n            {\\n            // so we must got  the last increasing stock day so sell it\\n            profitgot = prices[index] - startdayprice;\\n            if( index < prices.size() - 1)\\n            {\\n            startdayprice = prices[index + 1];\\n            }\\n            index++;\\n            ans = ans + profitgot;\\n            }\\n            \\n        }\\n        return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        //  base case\\n        if( prices.size() == 1)\\n        {\\n            return 0; // as no profit will come\\n        }\\n       \\n    int ans = 0;\\n    int startdayprice = prices[0];\\n    int index = 0;\\n    while(index < prices.size())\\n        {\\n            int profitgot = 0;\\n            while(index < prices.size() - 1 && prices[index] <= prices[index+1] )\\n            {\\n                index++;\\n            }\\n            if( index < prices.size()  )\\n            {\\n            // so we must got  the last increasing stock day so sell it\\n            profitgot = prices[index] - startdayprice;\\n            if( index < prices.size() - 1)\\n            {\\n            startdayprice = prices[index + 1];\\n            }\\n            index++;\\n            ans = ans + profitgot;\\n            }\\n            \\n        }\\n        return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922654,
                "title": "java-easiest-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/d9a61fbd-5075-4cd0-9409-56f565bbdbaa_1692280264.2094002.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int maxProfit[][] = new int[n][2];  // maxProfit[i][0] represents the maximum profit on day i when not holding a stock\\n                                           // maxProfit[i][1] represents the maximum profit on day i when holding a stock\\n\\n        maxProfit[0][0] = 0;  // Initial profit on the first day when not holding a stock is 0\\n        maxProfit[0][1] = -prices[0];  // Initial profit on the first day when holding a stock is the negative of its price\\n\\n        for (int i = 1; i < n; i++) {\\n            // Update the maximum profit on day i when not holding a stock\\n            maxProfit[i][0] = Math.max(maxProfit[i - 1][0], maxProfit[i - 1][1] + prices[i]);\\n            \\n            // Update the maximum profit on day i when holding a stock\\n            maxProfit[i][1] = Math.max(maxProfit[i - 1][1], maxProfit[i - 1][0] - prices[i]);\\n        }\\n        \\n        return maxProfit[n - 1][0];  // Return the maximum profit on the last day when not holding a stock\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int maxProfit[][] = new int[n][2];  // maxProfit[i][0] represents the maximum profit on day i when not holding a stock\\n                                           // maxProfit[i][1] represents the maximum profit on day i when holding a stock\\n\\n        maxProfit[0][0] = 0;  // Initial profit on the first day when not holding a stock is 0\\n        maxProfit[0][1] = -prices[0];  // Initial profit on the first day when holding a stock is the negative of its price\\n\\n        for (int i = 1; i < n; i++) {\\n            // Update the maximum profit on day i when not holding a stock\\n            maxProfit[i][0] = Math.max(maxProfit[i - 1][0], maxProfit[i - 1][1] + prices[i]);\\n            \\n            // Update the maximum profit on day i when holding a stock\\n            maxProfit[i][1] = Math.max(maxProfit[i - 1][1], maxProfit[i - 1][0] - prices[i]);\\n        }\\n        \\n        return maxProfit[n - 1][0];  // Return the maximum profit on the last day when not holding a stock\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856785,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Not the best solution but very easy to understand. Any improvements are welcome :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        for i in range(len(prices) - 1):\\n            if prices[i] < prices[i + 1]:\\n                profit += prices[i + 1] - prices[i]\\n\\n        return profit\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        for i in range(len(prices) - 1):\\n            if prices[i] < prices[i + 1]:\\n                profit += prices[i + 1] - prices[i]\\n\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808766,
                "title": "0-1-space-optimized-solution",
                "content": "# PLS UPVOTE IF YOU LIKE MY SOLUTION AND FEEL FREE TO ASK IN COMMENTS\\n# CODE WITH SPACE OPTIMIZATION\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe function solvetab is used to find the maximum profit using the bottom-up dynamic programming approach with optimized space complexity.\\n\\nInstead of using a 2D vector dp, the function uses two 1D vectors curr and next to store the maximum profits for the current state and the next state, respectively. Each vector has two elements, one for the \"buy\" state and the other for the \"sell\" state.\\n\\nThe curr vector is initialized with zeros to represent the base case when there are no prices left (index n).\\n\\nThe outer loop iterates over the indices of the prices vector in reverse order (from n-1 to 0`). This order ensures that we are computing the maximum profit from the last index to the first index.\\n\\nThe inner loop iterates over the two possible states: \"buy\" (buy=1) and \"sell\" (buy=0).\\n\\nFor each index and state, the function calculates the maximum profit by considering two choices, similar to the previous approach:\\n\\nIf the current state is \"buy\" (buy == 1), the function calculates the profit from buying the stock at the current index (prices[index]) and adding the profit from the next state in the \"sell\" state (next[0]).\\nIf the current state is \"sell\" (buy == 0), the function calculates the profit from selling the stock at the current index (prices[index]) and adding the profit from the next state in the \"buy\" state (next[1]).\\nAfter calculating the profit for both choices at each index and state, the function updates the curr vector with the new maximum profit for the current state.\\n\\nThe next vector is then updated to be equal to the curr vector, which essentially moves to the next day for the next iteration.\\n\\nFinally, after the loop ends, the function returns the maximum profit that can be obtained from the initial state (state \"buy\" at index 0), which is stored in next[1].\\n\\nIn the maxProfit function, it calls the solvetab function to calculate and return the maximum profit using the tabulation approach with optimized space complexity.\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solvetab(vector<int>& prices)\\n{\\n    int n = prices.size();\\n    vector<int>curr(2,0);\\n    vector<int>next(2,0);\\n    int profit=0;\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+ next[0] , 0 + next[1]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[1] , 0 + next[0]); \\n            }\\n            curr[buy]=profit;\\n        }\\n        next=curr;\\n    }\\n    return next[1];\\n}\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n        return solvetab(prices); \\n    }\\n};\\n```\\n# CODE WITH BOTTOM UP APPROACH\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe function solvetab is used to find the maximum profit using the bottom-up dynamic programming approach.\\n\\nThe function initializes a 2D vector dp with dimensions (n+1) x 2, where n is the size of the prices vector. The dp table is used to store the maximum profit that can be obtained at each index with two states: \"buy\" (buying the stock) and \"sell\" (selling the stock). The first dimension of the table (n+1) accounts for the base case when there are no prices left (index n).\\n\\nThe outer loop iterates over the indices of the prices vector in reverse order (from n-1 to 0`). This order ensures that we are computing the maximum profit from the last index to the first index.\\n\\nThe inner loop iterates over the two possible states: \"buy\" (buy=1) and \"sell\" (buy=0).\\n\\nFor each index and state, the function calculates the maximum profit by considering two choices:\\n\\nIf the current state is \"buy\" (buy == 1), the function calculates the profit from buying the stock at the current index (prices[index]) and adding the profit from the next index in the \"sell\" state (dp[index+1][0]).\\nIf the current state is \"sell\" (buy == 0), the function calculates the profit from selling the stock at the current index (prices[index]) and adding the profit from the next index in the \"buy\" state (dp[index+1][1]).\\nAfter calculating the profit for both choices at each index and state, the function stores the result in the dp table.\\n\\nFinally, the function returns the maximum profit that can be obtained from the initial state (state \"buy\" at index 0), which is stored in dp[0][1].\\n\\nIn the maxProfit function, it calls the solvetab function to calculate and return the maximum profit using the tabulation approach.\\n\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solvetab(vector<int>& prices)\\n{\\n    int n = prices.size();\\n    vector<vector<int>>dp(n+1,vector<int>(2,0));\\n    int profit=0;\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+ dp[index+1][0] , 0 + dp[index+1][1]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ dp[index+1][1] , 0 + dp[index+1][0]); \\n            }\\n            dp[index][buy]=profit;\\n        }\\n    }\\n    return dp[0][1];\\n}\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n        return solvetab(prices); \\n    }\\n};\\n```\\n\\n\\n\\n# CODE WITH MEMOISATION\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe function solve is a recursive function that takes the following parameters:\\n\\nprices: The vector of stock prices.\\nbuy: A flag to indicate whether we are in the \"buy\" state (buying the stock) or \"sell\" state (selling the stock). It is represented as an integer where 1 indicates \"buy\" state, and 0 indicates \"sell\" state.\\nindex: The current index in the prices vector that we are considering.\\ndp: A 2D memoization table to store the results of subproblems. dp[index][buy] stores the maximum profit that can be obtained at the current index with the given \"buy\" state.\\nThe base case for the recursion is when the index is equal to or greater than the size of the prices vector. In this case, we cannot perform any more transactions, so the profit is 0.\\n\\nBefore starting any computation at a given index and state, the function checks if the result is already computed and stored in the dp table. If so, it returns the precomputed result to avoid redundant calculations.\\n\\nThe recursive approach simulates the decisions to buy or sell the stock at each index and calculates the profit for both scenarios. It then takes the maximum of the two options to determine the maximum profit at the current state.\\n\\nIf the current state is \"buy\" (buy == 1), the function has two choices:\\n\\nBuy the stock at the current index, which means we need to deduct the price of the stock from the profit, and then recursively call the function for the next index in \"sell\" state (buy=0).\\nDo not buy the stock at the current index, and directly move to the next index while staying in \"buy\" state (buy=1).\\nIf the current state is \"sell\" (buy == 0), the function has two choices:\\n\\nSell the stock at the current index, which means we need to add the price of the stock to the profit, and then recursively call the function for the next index in \"buy\" state (buy=1).\\nDo not sell the stock at the current index and directly move to the next index while staying in \"sell\" state (buy=0).\\nAfter calculating the profit for both choices at each index and state, the function stores the result in the dp table for future reference and returns the maximum profit for the current index and state.\\n\\nIn the maxProfit function, a memoization table (dp) is initialized with -1 to indicate that the results are not computed yet.\\n\\nThe maxProfit function calls the solve function with the initial state as \"buy\" (buy=1), starting from the first index (index 0) of the prices vector.\\n\\nThe solve function uses recursion with memoization to calculate and return the maximum profit.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& prices,int buy,int index , vector<vector<int>>&dp)\\n{\\n    int profit= 0;\\n    if(index>=prices.size())\\n    {\\n        return 0;\\n    }\\n    if(dp[index][buy]!=-1)\\n    {\\n        return dp[index][buy];\\n    }\\n    if(buy==1)\\n    {\\n        profit=max(-prices[index]+ solve(prices,0,index+1,dp) ,0 + solve(prices,1,index+1,dp) );\\n    }\\n    else\\n    {\\n         profit=max(prices[index]+ solve(prices,1,index+1,dp) , 0 + solve(prices,0,index+1,dp)); \\n    }\\n    return dp[index][buy] = profit;\\n}\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,-1));\\n        bool buy=1;\\n        return solve(prices,buy,0,dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solvetab(vector<int>& prices)\\n{\\n    int n = prices.size();\\n    vector<int>curr(2,0);\\n    vector<int>next(2,0);\\n    int profit=0;\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+ next[0] , 0 + next[1]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[1] , 0 + next[0]); \\n            }\\n            curr[buy]=profit;\\n        }\\n        next=curr;\\n    }\\n    return next[1];\\n}\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n        return solvetab(prices); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\nint solvetab(vector<int>& prices)\\n{\\n    int n = prices.size();\\n    vector<vector<int>>dp(n+1,vector<int>(2,0));\\n    int profit=0;\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+ dp[index+1][0] , 0 + dp[index+1][1]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ dp[index+1][1] , 0 + dp[index+1][0]); \\n            }\\n            dp[index][buy]=profit;\\n        }\\n    }\\n    return dp[0][1];\\n}\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n        return solvetab(prices); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& prices,int buy,int index , vector<vector<int>>&dp)\\n{\\n    int profit= 0;\\n    if(index>=prices.size())\\n    {\\n        return 0;\\n    }\\n    if(dp[index][buy]!=-1)\\n    {\\n        return dp[index][buy];\\n    }\\n    if(buy==1)\\n    {\\n        profit=max(-prices[index]+ solve(prices,0,index+1,dp) ,0 + solve(prices,1,index+1,dp) );\\n    }\\n    else\\n    {\\n         profit=max(prices[index]+ solve(prices,1,index+1,dp) , 0 + solve(prices,0,index+1,dp)); \\n    }\\n    return dp[index][buy] = profit;\\n}\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,-1));\\n        bool buy=1;\\n        return solve(prices,buy,0,dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715824,
                "title": "easy-c-2-line-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for (int i=1; i<prices.size(); i++){\\n            profit+= max(0, prices[i]-prices[i-1]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for (int i=1; i<prices.size(); i++){\\n            profit+= max(0, prices[i]-prices[i-1]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689180,
                "title": "o-n-python-solution",
                "content": "# Intuition\\nThe meaning of the solution is that we buy as soon as the rate starts to rise and sell as soon as the rate starts to fall\\n\\n# Approach\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-06-27 \\u0432 15.50.55.png](https://assets.leetcode.com/users/images/118dce43-205c-4675-98b4-847b486c5f80_1687871325.5935972.png)\\nFirst we check that there are at least 2 shares in the array, otherwise we will not get any benefit.\\n\\n---\\n\\nThe variable **flag** shows whether we have a stock now or not, **buy** shows at what price we bought the stock, we initialize it 10 ** 10 because in the start we didn\\'t buy any stock.\\nNext, we go through the array and at the extremes of the chart we buy or sell a stock\\n\\n---\\n```\\nans += (prices[i + 1] - buy > 0) * (prices[i + 1] - buy)\\n```\\nHere we take into account the boundary case when we bought a share and did not sell it until the end of the array, then we should fix the profit\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        ans,flag,buy = 0, 0, 10 ** 10\\n        if len(prices) <= 1:\\n            return 0\\n        for i in range(len(prices) - 1):\\n            if prices[i + 1] > prices[i]:\\n                if not flag:\\n                    flag = 1\\n                    buy = prices[i]\\n            else:\\n                if flag:\\n                    flag = 0\\n                    ans += prices[i] - buy\\n                    buy = 10 **  10\\n        ans += (prices[i + 1] - buy > 0) * (prices[i + 1] - buy)\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nans += (prices[i + 1] - buy > 0) * (prices[i + 1] - buy)\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        ans,flag,buy = 0, 0, 10 ** 10\\n        if len(prices) <= 1:\\n            return 0\\n        for i in range(len(prices) - 1):\\n            if prices[i + 1] > prices[i]:\\n                if not flag:\\n                    flag = 1\\n                    buy = prices[i]\\n            else:\\n                if flag:\\n                    flag = 0\\n                    ans += prices[i] - buy\\n                    buy = 10 **  10\\n        ans += (prices[i + 1] - buy > 0) * (prices[i + 1] - buy)\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571488,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int l= 0;\\n          int r =1;\\n          int k=0;\\n        int p=0;\\n        int max =0;\\n      while(r<prices.length){\\n      if(prices[l]<prices[r] && prices[k]<prices[r]){\\n       max = Math.max(max,(prices[r]- prices[l]));\\n       r++;\\n       k++;\\n     }\\n      else{ \\n      \\n         l=r;\\n          p+=max;\\n          max =0;\\n          r++;\\n          k++;\\n      }\\n      \\n      }\\n   p+= max;\\n    return p; }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int l= 0;\\n          int r =1;\\n          int k=0;\\n        int p=0;\\n        int max =0;\\n      while(r<prices.length){\\n      if(prices[l]<prices[r] && prices[k]<prices[r]){\\n       max = Math.max(max,(prices[r]- prices[l]));\\n       r++;\\n       k++;\\n     }\\n      else{ \\n      \\n         l=r;\\n          p+=max;\\n          max =0;\\n          r++;\\n          k++;\\n      }\\n      \\n      }\\n   p+= max;\\n    return p; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535712,
                "title": "single-for-loop-solution",
                "content": "# Intuition\\nLooking at the examples, it looks like making the sale just before the prices drops the first time since the buy day, ignoring there might be a higher price in the future and then repeat from the new, lower price.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. three vars to keep track of buy price (min), highest price including buy day (max), and the total profit (sum).\\n2. Store day one prices in min and max\\n3. Loop through the prices. \\n3.1 if the price is higher than max, update max. \\n3.2 if the price is lower than max: 1) add diff(max-min) to sum. 2) update max and min with new day price. \\n4. When the loop finishes, add diff(max-min) to sum in case the last day was not a sell. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) where n is size of the array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) since only three variables is needed. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) \\n    {\\n        if(prices.Length < 2) {return 0;}\\n        int min = prices[0];\\n        int max = prices[0];\\n        int sum = 0;\\n        for(int i = 1; i < prices.Length; i++)\\n        {\\n            if(prices[i] > max)\\n            {\\n                max = prices[i];\\n                continue;\\n            }\\n            if(prices[i] < max)\\n            {\\n                sum += max - min;\\n                min = prices[i];\\n                max = prices[i];\\n            }\\n        }\\n        sum+= max - min;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) \\n    {\\n        if(prices.Length < 2) {return 0;}\\n        int min = prices[0];\\n        int max = prices[0];\\n        int sum = 0;\\n        for(int i = 1; i < prices.Length; i++)\\n        {\\n            if(prices[i] > max)\\n            {\\n                max = prices[i];\\n                continue;\\n            }\\n            if(prices[i] < max)\\n            {\\n                sum += max - min;\\n                min = prices[i];\\n                max = prices[i];\\n            }\\n        }\\n        sum+= max - min;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401920,
                "title": "buy-only-if-next-price-is-higher-just-like-what-you-d-do-in-real-life",
                "content": "Imagin what life would be like if you already knew what the next day price is going be?\\nYou\\'d be able to trade everyday and make decisions which always result in profit.\\n\\nIf you knew next day price is going to be lower, you\\'d not buy the stock today.\\nIf you knew next day price is going to be higher, you\\'d buy the stock today and **sell it tomorrow**.\\n\\n**If you trade everyday, and everyday is resulting in maximum profit then your profit will obviously also be maxium through all of the day combined.**\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buy = 0;\\n        int to = prices.length - 2;\\n        for (int i = 0; i <= to; i++) {\\n            if (prices[i] < prices[i + 1])\\n                buy += prices[i + 1] - prices[i];\\n        }\\n        return buy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buy = 0;\\n        int to = prices.length - 2;\\n        for (int i = 0; i <= to; i++) {\\n            if (prices[i] < prices[i + 1])\\n                buy += prices[i + 1] - prices[i];\\n        }\\n        return buy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245585,
                "title": "c-easiest-intuitive-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuying and selling stock may feel like a complicated question, but when you break it down, the rules are very simple.\\n\\nThis problem boils down to buying stock at the local minima, and selling stock at the local maxima.\\n\\n![extremaPoints.png](https://assets.leetcode.com/users/images/e6610c4d-a07e-41de-8272-ab70fb517d59_1677716743.8909247.png)\\n(Taken from google)\\n\\nLogically, this makes sense, as you are buying when the stock is lowest and selling when the stock is highest.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe implementation for this is very simple. For every point in time,\\n1. If you are buying, check if the price ahead in time is greater. If it is, buy.\\n2. If you are selling, check if the price ahead in time is lower. If it is, sell.\\n\\nThe algorithm only has 3 variables. The total profit, the price that you are buying at, and a boolean whether you are buying or not.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n        int buyPrice = 0;\\n        bool buying=true;\\n\\n        for (int i = 0; i < prices.size()-1; i++)\\n        {\\n            if (buying)\\n            {\\n                // If at local minima, buy stock\\n                if (prices[i+1]>prices[i]) { \\n                    buying = false;\\n                    buyPrice = prices[i];\\n                }\\n            }\\n            else {\\n                // If at local maxima, sell stock\\n                if (prices[i+1]<prices[i]) {\\n                    buying = true;\\n                    profit += prices[i]-buyPrice;\\n                }\\n            }\\n        }\\n        \\n        // Edge case for selling stock\\n        if (!buying && prices[prices.size()-2]<=prices[prices.size()-1]) profit += prices[prices.size()-1]-buyPrice; \\n\\n        return profit;\\n    }\\n};\\n```\\n\\nUpvote if this helps please \\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n        int buyPrice = 0;\\n        bool buying=true;\\n\\n        for (int i = 0; i < prices.size()-1; i++)\\n        {\\n            if (buying)\\n            {\\n                // If at local minima, buy stock\\n                if (prices[i+1]>prices[i]) { \\n                    buying = false;\\n                    buyPrice = prices[i];\\n                }\\n            }\\n            else {\\n                // If at local maxima, sell stock\\n                if (prices[i+1]<prices[i]) {\\n                    buying = true;\\n                    profit += prices[i]-buyPrice;\\n                }\\n            }\\n        }\\n        \\n        // Edge case for selling stock\\n        if (!buying && prices[prices.size()-2]<=prices[prices.size()-1]) profit += prices[prices.size()-1]-buyPrice; \\n\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078266,
                "title": "memoization-tabulation-space-optimization-dp-greedy-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int buy, int n, vector<int> &prices, vector<vector<int>> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i][buy] != -1) return dp[i][buy];\\n\\n        int profit = 0;\\n        if(buy) {\\n            profit = max(-prices[i] + dfs(i + 1, 0, n, prices, dp), 0 + dfs(i + 1, 1, n, prices, dp));\\n        }\\n        else {\\n            profit = max(prices[i] + dfs(i + 1, 1, n, prices, dp), 0 + dfs(i + 1, 0, n, prices, dp));\\n        }\\n        return dp[i][buy] = profit;\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n\\n        return dfs(0, 1, n, prices, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(2));\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int buy=0; buy<=1; buy++) {\\n                int profit = 0;\\n                if(buy) {\\n                    profit = max(-prices[i] + dp[i + 1][0], 0 + dp[i + 1][1]);\\n                }\\n                else {\\n                    profit = max(prices[i] + dp[i + 1][1], 0 + dp[i + 1][0]);\\n                }\\n                dp[i][buy] = profit;\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> dp(2), temp(2);\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int buy=0; buy<=1; buy++) {\\n                int profit = 0;\\n                if(buy) {\\n                    profit = max(-prices[i] + dp[0], 0 + dp[1]);\\n                }\\n                else {\\n                    profit = max(prices[i] + dp[1], 0 + dp[0]);\\n                }\\n                temp[buy] = profit;\\n            }\\n            dp = temp;\\n        }\\n        return dp[1];\\n    }\\n};\\n```\\n\\n# Greedy\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(), ans = 0;\\n        for(int i=1; i<n; i++) ans += max(0, prices[i] - prices[i - 1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int buy, int n, vector<int> &prices, vector<vector<int>> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i][buy] != -1) return dp[i][buy];\\n\\n        int profit = 0;\\n        if(buy) {\\n            profit = max(-prices[i] + dfs(i + 1, 0, n, prices, dp), 0 + dfs(i + 1, 1, n, prices, dp));\\n        }\\n        else {\\n            profit = max(prices[i] + dfs(i + 1, 1, n, prices, dp), 0 + dfs(i + 1, 0, n, prices, dp));\\n        }\\n        return dp[i][buy] = profit;\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n\\n        return dfs(0, 1, n, prices, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(2));\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int buy=0; buy<=1; buy++) {\\n                int profit = 0;\\n                if(buy) {\\n                    profit = max(-prices[i] + dp[i + 1][0], 0 + dp[i + 1][1]);\\n                }\\n                else {\\n                    profit = max(prices[i] + dp[i + 1][1], 0 + dp[i + 1][0]);\\n                }\\n                dp[i][buy] = profit;\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> dp(2), temp(2);\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int buy=0; buy<=1; buy++) {\\n                int profit = 0;\\n                if(buy) {\\n                    profit = max(-prices[i] + dp[0], 0 + dp[1]);\\n                }\\n                else {\\n                    profit = max(prices[i] + dp[1], 0 + dp[0]);\\n                }\\n                temp[buy] = profit;\\n            }\\n            dp = temp;\\n        }\\n        return dp[1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(), ans = 0;\\n        for(int i=1; i<n; i++) ans += max(0, prices[i] - prices[i - 1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955148,
                "title": "simple-java-solution-o-n-time-with-o-1-space-beats-100",
                "content": "# Intuition\\nIt was similar to [https://leetcode.com/problems/best-time-to-buy-and-sell-stock/](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/), but with a improvised version.\\n\\n# Approach\\nThis was similar to Mountain valley approach. Simple loop over the array and remember that we need to find the higher grounded values not the lower. Once we start the loop find the least element and traverse trhough it. Two conditions to be remembered.\\n\\n1. If you find the number higher than the current stop the loop and start counting from it.\\n2. If you find smaller than current then count the profit from it until you drop the graph of increasing elements.\\n\\nOnce you find the decrease in the profit stop there note the profit and then add it to total profit then make the current element as min then again start the process.\\n\\n\\nThe below line was written to handle the last element \\n```\\n  if (pos<nums.length) min = nums[pos];\\n```\\n# Complexity\\n- Time complexity:\\n   $$O(n)$$\\n\\n- Space complexity:\\n   $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] nums) {\\n         int min = nums[0], totalProfit = 0;\\n        int pos = 1, max = -1;\\n        while (pos < nums.length) {\\n            // Track the Min of the list and start tracking it\\n            if (nums[pos] < min)\\n                min = nums[pos];\\n            // Track the valley until it reaches down \\n            while (pos < nums.length && max < nums[pos])\\n                max = nums[pos++];\\n\\n            totalProfit+=max-min;\\n            max = -1;\\n            if (pos<nums.length) min = nums[pos];\\n            pos++;\\n        }\\n\\n        return totalProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  if (pos<nums.length) min = nums[pos];\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] nums) {\\n         int min = nums[0], totalProfit = 0;\\n        int pos = 1, max = -1;\\n        while (pos < nums.length) {\\n            // Track the Min of the list and start tracking it\\n            if (nums[pos] < min)\\n                min = nums[pos];\\n            // Track the valley until it reaches down \\n            while (pos < nums.length && max < nums[pos])\\n                max = nums[pos++];\\n\\n            totalProfit+=max-min;\\n            max = -1;\\n            if (pos<nums.length) min = nums[pos];\\n            pos++;\\n        }\\n\\n        return totalProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558077,
                "title": "7-approach-explained-greedy-recursion-memoization-tabulation-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    //APPROACH 1:-  PEAK VALLEY APPROACH (PEAK -> HIGHEST POINT) (VALLEY -> LOWEST POINT)\\n    // consider every peak immediately after a valley and take difference of peak and valley in profit \\n    int peakValley(vector<int>&prices){\\n       int n = prices.size();\\n       int peak = prices[0] ;\\n       int valley = prices[0] ; \\n       int profit=0;\\n\\n       // peak -> prices[i]>prices[i+1] \\n       // valley -> prices[i]<prices[i+1] \\n        \\n        int i=0;\\n      while(i<n-1){\\n         //for valley \\n          while(i<n-1 && prices[i]>=prices[i+1]) i++;\\n          valley = prices[i] ; \\n       \\n         //for peak \\n          while(i<n-1 && prices[i]<=prices[i+1]) i++;\\n          peak = prices[i] ; \\n       \\n          profit+=(peak-valley);\\n      }\\n      return profit;\\n    }\\n    //APPROACH 2:-  PEAK VALLEY APPROACH EXTENSION \\n    int peakValleyExtension(vector<int>&prices){\\n      int n = prices.size();\\n      int profit=0;\\n\\n      for(int i=0;i<n-1;i++){\\n          int currProfit = prices[i+1] - prices[i] ; \\n          int isProfitable = max(0,currProfit);\\n          profit+=isProfitable;\\n      }\\n      return profit;\\n    }\\n    //Approach-3 Recursion Time Complexity: O(2^N)[Take,notTake] Space Complexity: O(N)[Auxillary Stack Space]\\n    int solve(int ind,int buy,vector<int>&prices){\\n        int n = prices.size() , profit=0; \\n\\n        if(ind==n) return 0;\\n        \\n        //Buying Stock when buy = 1 \\n        if(buy){\\n            //take -> means we bought ind stock \\n            //now,we can\\'t buy untill we sell this stock. ThereFore, buy=0\\n            //notTake -> means we didn\\'t bought ind stock \\n            //now,we can buy other stock. ThereFore, buy=1\\n            int take = -prices[ind]+solve(ind+1,0,prices) ; \\n            int notTake = 0+solve(ind+1,1,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        //Selling Stock when buy = 0 \\n        else if(buy==0){\\n            //take -> means we sold ind stock \\n            //now,we can buy stock. ThereFore, buy=1\\n            //notTake -> means we didn\\'t sold ind stock \\n            //now,we can\\'t buy other stock. ThereFore, buy=0\\n            int take = prices[ind]+solve(ind+1,1,prices) ; \\n            int notTake = 0+solve(ind+1,0,prices) ;\\n            profit = max(take,notTake);\\n        }\\n\\n        return profit;\\n    }\\n    //Approach-4 Memoization Time Complexity: O(N*2)[buy->0 or 1 --> 2 states] Space Complexity:O(N*2) + O(N) [O(N)[Auxillary Stack Space]]\\n    int solve2(int ind,int buy,vector<int>&prices,vector<vector<int>>&dp){\\n        int n = prices.size() , profit=0; \\n\\n        if(ind==n) return 0;\\n        \\n        if(dp[ind][buy]!=-1) return dp[ind][buy] ; \\n        //Buying Stock when buy = 1 \\n        if(buy){\\n            //take -> means we bought ind stock \\n            //now,we can\\'t buy untill we sell this stock. ThereFore, buy=0\\n            //notTake -> means we didn\\'t bought ind stock \\n            //now,we can buy other stock. ThereFore, buy=1\\n            int take = -prices[ind]+solve2(ind+1,0,prices,dp) ; \\n            int notTake = 0+solve2(ind+1,1,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n        //Selling Stock when buy = 0 \\n        else if(buy==0){\\n            //take -> means we sold ind stock \\n            //now,we can buy stock. ThereFore, buy=1\\n            //notTake -> means we didn\\'t sold ind stock \\n            //now,we can\\'t buy other stock. ThereFore, buy=0\\n            int take = prices[ind]+solve2(ind+1,1,prices,dp) ; \\n            int notTake = 0+solve2(ind+1,0,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n\\n        return dp[ind][buy] =  profit;\\n    }\\n    //Approach-5 Tabulation :- Time Complexity: O(N*2) Space Complexity: O(N*2)\\n    int tabulation(vector<int>& prices){\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0)) ; \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        dp[n][0] = dp[n][1] = 0 ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n            // buy = 0 to 1 or buy = 1 to 0 -> both correct\\n            //for(int buy=0;buy<=1;buy++){\\n                 for(int buy=1;buy>=0;buy--){\\n                int profit=0;\\n                if(buy==1){\\n                    int take = -prices[ind]+dp[ind+1][0] ; //buy \\n                    int notTake = 0+dp[ind+1][1]; //not buy -> buy further\\n                    profit = max(take,notTake);\\n                }\\n                else if(buy==0){\\n                    int take = prices[ind]+dp[ind+1][1] ; //sell -> now we can buy \\n                    int notTake = 0+dp[ind+1][0]; //not sell -> not buy\\n                    profit = max(take,notTake);\\n                }\\n                dp[ind][buy]=profit;\\n            }\\n        }\\n        return dp[0][1];//as Recursion Call from (0,1)\\n    }\\n    //Approach-6 tabulation With Space Optimization :- Time Complexity: O(N*2) Space Complexity: O(1)\\n    int tabulationWithSpaceOptimization(vector<int>& prices){\\n        int n = prices.size();\\n        //ind      n-1  n\\n        //(buy=0)  |    |\\n        //(buy=1)  |    |\\n        //        curr ahead\\n        vector<int>ahead(2,0),curr(2,0) ; \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        ahead[0] = ahead[1] = 0 ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int buy=0;buy<=1;buy++){\\n                int profit=0;\\n                if(buy==1){\\n                    //dp[ind+1][buy]-> ahead[buy]\\n                    //dp[ind][buy] -> curr[buy] \\n                    int take = -prices[ind]+ahead[0] ; //buy \\n                    int notTake = 0+ahead[1]; //not buy -> buy further\\n                    profit = max(take,notTake);\\n                }\\n                else if(buy==0){\\n                    int take = prices[ind]+ahead[1] ; //sell -> now we can buy \\n                    int notTake = 0+ahead[0]; //not sell -> not buy\\n                    profit = max(take,notTake);\\n                }\\n                curr[buy]=profit;\\n            }\\n            ahead=curr;//update\\n        }\\n        return ahead[1];//as Recursion Call from (0,1)\\n    }\\n     //Approach-7 tabulation With Space Optimization Using Variables :- Time Complexity: O(N*2) Space Complexity: O(1)\\n    int tabulationWithSpaceOptimization2(vector<int>& prices){\\n        int n = prices.size();\\n        \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        int aheadBuy = 0 ,  aheadNotBuy = 0 ;\\n         int currBuy ,  currNotBuy  ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n                      //ahead[0]-> aheadNotBuy\\n                    //ahead[1] -> aheadBuy \\n\\n                    //curr[0] -> currNotBuy\\n                    //curr[1] -> currBuy\\n\\n                    //CASE FOR BUY=1\\n                    int take = -prices[ind]+aheadNotBuy ; //buy \\n                    int notTake = 0+aheadBuy; //not buy -> buy further\\n                    currBuy =max(take,notTake);\\n\\n                    //CASE FOR BUY=0\\n                    int take2 = prices[ind]+aheadBuy ; //sell -> now we can buy \\n                    int notTake2 = 0+aheadNotBuy; //not sell -> not buy\\n                    currNotBuy =max(take2,notTake2);\\n\\n            //update step like ahead=curr one \\n            aheadBuy=currBuy;\\n            aheadNotBuy=currNotBuy;\\n         }\\n        return aheadBuy;//as Recursion Call from (0,1)\\n    }\\n    int maxProfit(vector<int>& prices) {\\n         int n = prices.size();\\n      // return peakValley(prices); //APPROACH 1:-  PEAK VALLEY APPROACH\\n     //  return peakValleyExtension(prices); //APPROACH 2:-  PEAK VALLEY APPROACH EXTENSION\\n     \\n     //START WITH BUY=1 AS FIRST WE WANT TO BUY A STOCK THAN ONLY SELL IT\\n     //    return solve(0,1,prices); //Approach-3 Recursion\\n        \\n       //  vector<vector<int>>dp(n,vector<int>(2,-1)); \\n       //  return solve2(0,1,prices,dp); //Approach-4 Memoization\\n       //return tabulation(prices); //Approach-5 Tabulation \\n      //return tabulationWithSpaceOptimization(prices); //Approach-6 tabulation With Space Optimization\\n      return tabulationWithSpaceOptimization2(prices); //Approach-7 tabulation With Space Optimization Using Variables\\n    }\\n};\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //APPROACH 1:-  PEAK VALLEY APPROACH (PEAK -> HIGHEST POINT) (VALLEY -> LOWEST POINT)\\n    // consider every peak immediately after a valley and take difference of peak and valley in profit \\n    int peakValley(vector<int>&prices){\\n       int n = prices.size();\\n       int peak = prices[0] ;\\n       int valley = prices[0] ; \\n       int profit=0;\\n\\n       // peak -> prices[i]>prices[i+1] \\n       // valley -> prices[i]<prices[i+1] \\n        \\n        int i=0;\\n      while(i<n-1){\\n         //for valley \\n          while(i<n-1 && prices[i]>=prices[i+1]) i++;\\n          valley = prices[i] ; \\n       \\n         //for peak \\n          while(i<n-1 && prices[i]<=prices[i+1]) i++;\\n          peak = prices[i] ; \\n       \\n          profit+=(peak-valley);\\n      }\\n      return profit;\\n    }\\n    //APPROACH 2:-  PEAK VALLEY APPROACH EXTENSION \\n    int peakValleyExtension(vector<int>&prices){\\n      int n = prices.size();\\n      int profit=0;\\n\\n      for(int i=0;i<n-1;i++){\\n          int currProfit = prices[i+1] - prices[i] ; \\n          int isProfitable = max(0,currProfit);\\n          profit+=isProfitable;\\n      }\\n      return profit;\\n    }\\n    //Approach-3 Recursion Time Complexity: O(2^N)[Take,notTake] Space Complexity: O(N)[Auxillary Stack Space]\\n    int solve(int ind,int buy,vector<int>&prices){\\n        int n = prices.size() , profit=0; \\n\\n        if(ind==n) return 0;\\n        \\n        //Buying Stock when buy = 1 \\n        if(buy){\\n            //take -> means we bought ind stock \\n            //now,we can\\'t buy untill we sell this stock. ThereFore, buy=0\\n            //notTake -> means we didn\\'t bought ind stock \\n            //now,we can buy other stock. ThereFore, buy=1\\n            int take = -prices[ind]+solve(ind+1,0,prices) ; \\n            int notTake = 0+solve(ind+1,1,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        //Selling Stock when buy = 0 \\n        else if(buy==0){\\n            //take -> means we sold ind stock \\n            //now,we can buy stock. ThereFore, buy=1\\n            //notTake -> means we didn\\'t sold ind stock \\n            //now,we can\\'t buy other stock. ThereFore, buy=0\\n            int take = prices[ind]+solve(ind+1,1,prices) ; \\n            int notTake = 0+solve(ind+1,0,prices) ;\\n            profit = max(take,notTake);\\n        }\\n\\n        return profit;\\n    }\\n    //Approach-4 Memoization Time Complexity: O(N*2)[buy->0 or 1 --> 2 states] Space Complexity:O(N*2) + O(N) [O(N)[Auxillary Stack Space]]\\n    int solve2(int ind,int buy,vector<int>&prices,vector<vector<int>>&dp){\\n        int n = prices.size() , profit=0; \\n\\n        if(ind==n) return 0;\\n        \\n        if(dp[ind][buy]!=-1) return dp[ind][buy] ; \\n        //Buying Stock when buy = 1 \\n        if(buy){\\n            //take -> means we bought ind stock \\n            //now,we can\\'t buy untill we sell this stock. ThereFore, buy=0\\n            //notTake -> means we didn\\'t bought ind stock \\n            //now,we can buy other stock. ThereFore, buy=1\\n            int take = -prices[ind]+solve2(ind+1,0,prices,dp) ; \\n            int notTake = 0+solve2(ind+1,1,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n        //Selling Stock when buy = 0 \\n        else if(buy==0){\\n            //take -> means we sold ind stock \\n            //now,we can buy stock. ThereFore, buy=1\\n            //notTake -> means we didn\\'t sold ind stock \\n            //now,we can\\'t buy other stock. ThereFore, buy=0\\n            int take = prices[ind]+solve2(ind+1,1,prices,dp) ; \\n            int notTake = 0+solve2(ind+1,0,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n\\n        return dp[ind][buy] =  profit;\\n    }\\n    //Approach-5 Tabulation :- Time Complexity: O(N*2) Space Complexity: O(N*2)\\n    int tabulation(vector<int>& prices){\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0)) ; \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        dp[n][0] = dp[n][1] = 0 ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n            // buy = 0 to 1 or buy = 1 to 0 -> both correct\\n            //for(int buy=0;buy<=1;buy++){\\n                 for(int buy=1;buy>=0;buy--){\\n                int profit=0;\\n                if(buy==1){\\n                    int take = -prices[ind]+dp[ind+1][0] ; //buy \\n                    int notTake = 0+dp[ind+1][1]; //not buy -> buy further\\n                    profit = max(take,notTake);\\n                }\\n                else if(buy==0){\\n                    int take = prices[ind]+dp[ind+1][1] ; //sell -> now we can buy \\n                    int notTake = 0+dp[ind+1][0]; //not sell -> not buy\\n                    profit = max(take,notTake);\\n                }\\n                dp[ind][buy]=profit;\\n            }\\n        }\\n        return dp[0][1];//as Recursion Call from (0,1)\\n    }\\n    //Approach-6 tabulation With Space Optimization :- Time Complexity: O(N*2) Space Complexity: O(1)\\n    int tabulationWithSpaceOptimization(vector<int>& prices){\\n        int n = prices.size();\\n        //ind      n-1  n\\n        //(buy=0)  |    |\\n        //(buy=1)  |    |\\n        //        curr ahead\\n        vector<int>ahead(2,0),curr(2,0) ; \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        ahead[0] = ahead[1] = 0 ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int buy=0;buy<=1;buy++){\\n                int profit=0;\\n                if(buy==1){\\n                    //dp[ind+1][buy]-> ahead[buy]\\n                    //dp[ind][buy] -> curr[buy] \\n                    int take = -prices[ind]+ahead[0] ; //buy \\n                    int notTake = 0+ahead[1]; //not buy -> buy further\\n                    profit = max(take,notTake);\\n                }\\n                else if(buy==0){\\n                    int take = prices[ind]+ahead[1] ; //sell -> now we can buy \\n                    int notTake = 0+ahead[0]; //not sell -> not buy\\n                    profit = max(take,notTake);\\n                }\\n                curr[buy]=profit;\\n            }\\n            ahead=curr;//update\\n        }\\n        return ahead[1];//as Recursion Call from (0,1)\\n    }\\n     //Approach-7 tabulation With Space Optimization Using Variables :- Time Complexity: O(N*2) Space Complexity: O(1)\\n    int tabulationWithSpaceOptimization2(vector<int>& prices){\\n        int n = prices.size();\\n        \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        int aheadBuy = 0 ,  aheadNotBuy = 0 ;\\n         int currBuy ,  currNotBuy  ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n                      //ahead[0]-> aheadNotBuy\\n                    //ahead[1] -> aheadBuy \\n\\n                    //curr[0] -> currNotBuy\\n                    //curr[1] -> currBuy\\n\\n                    //CASE FOR BUY=1\\n                    int take = -prices[ind]+aheadNotBuy ; //buy \\n                    int notTake = 0+aheadBuy; //not buy -> buy further\\n                    currBuy =max(take,notTake);\\n\\n                    //CASE FOR BUY=0\\n                    int take2 = prices[ind]+aheadBuy ; //sell -> now we can buy \\n                    int notTake2 = 0+aheadNotBuy; //not sell -> not buy\\n                    currNotBuy =max(take2,notTake2);\\n\\n            //update step like ahead=curr one \\n            aheadBuy=currBuy;\\n            aheadNotBuy=currNotBuy;\\n         }\\n        return aheadBuy;//as Recursion Call from (0,1)\\n    }\\n    int maxProfit(vector<int>& prices) {\\n         int n = prices.size();\\n      // return peakValley(prices); //APPROACH 1:-  PEAK VALLEY APPROACH\\n     //  return peakValleyExtension(prices); //APPROACH 2:-  PEAK VALLEY APPROACH EXTENSION\\n     \\n     //START WITH BUY=1 AS FIRST WE WANT TO BUY A STOCK THAN ONLY SELL IT\\n     //    return solve(0,1,prices); //Approach-3 Recursion\\n        \\n       //  vector<vector<int>>dp(n,vector<int>(2,-1)); \\n       //  return solve2(0,1,prices,dp); //Approach-4 Memoization\\n       //return tabulation(prices); //Approach-5 Tabulation \\n      //return tabulationWithSpaceOptimization(prices); //Approach-6 tabulation With Space Optimization\\n      return tabulationWithSpaceOptimization2(prices); //Approach-7 tabulation With Space Optimization Using Variables\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219302,
                "title": "easy-c-solution",
                "content": "Easy C++ Solution\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        for(int i=1; i<prices.size(); i++){\\n            if(prices[i] > prices[i-1]){\\n                profit += (prices[i] - prices[i-1]);\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        for(int i=1; i<prices.size(); i++){\\n            if(prices[i] > prices[i-1]){\\n                profit += (prices[i] - prices[i-1]);\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099424,
                "title": "122-best-time-to-buy-and-sell-stock-ii",
                "content": "```\\nint maxProfit(vector<int>& prices) {\\n        \\n        int profit = 0;\\n        \\n        for(int i = 1; i < prices.size(); i++)\\n        {\\n            profit += max(0, prices[i] - prices[i-1]);\\n        }\\n        return profit;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices) {\\n        \\n        int profit = 0;\\n        \\n        for(int i = 1; i < prices.size(); i++)\\n        {\\n            profit += max(0, prices[i] - prices[i-1]);\\n        }\\n        return profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1854408,
                "title": "pyhton-c-greedy-no-dp-needed-time-o-n",
                "content": "Buy stock on Day 1 and store it in cur_buy\\n\\nNow to get max profit we need to buy stock at min possible cost befor selling it\\n<b>1st condition:</b>If we encounter a day where price of stock is less than cur_buy,we replace cur_buy with it\\n\\n<b>2nd condition:</b>If we encounter a day where price of stock is greater than curr_buy,we sell the stock,now there can be two conditions if we sell on this day:\\n1.We got max profit possible\\n2.There is another day where we can sell stock and get even greater profit\\n\\n<b>Eg: [4,5,7] <b> According to 2nd condition we need to buy at 4 and sell at 5 and profit = 1 but if we sell at 7 we will get profit = 3</b> </b>\\n\\n<b>Thus to get max profit after buying at 4 and selling at 5 we update our profit to 1 and than again buy at 5 and sell at 7,so profit = 1(profit till now) + 2(current profit) = 3 which is max profit we can get</b> \\n\\nAnd if there was 3 instead of 7 i.e. [4,5,3] than we already had max profit = 1 by buying at 4 and selling at 5\\n\\nPython\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        cur_buy = prices[0]\\n        for price in prices:\\n            if price<cur_buy:cur_buy = price  #As stated in Condition 1\\n            \\n            if price>cur_buy:  #As stated in Condition 2\\n                profit += (price-cur_buy)\\n                cur_buy = price\\n    \\n        return profit\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0 , cur_buy = prices[0];\\n        for(int& price : prices){\\n            if(price<cur_buy) {\\n                cur_buy = price;  //As stated in Condition 1\\n            }\\n            if(price>cur_buy){  //As stated in Condition 2\\n                profit += (price-cur_buy);\\n                cur_buy = price;\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\nP.S.:If you still have any doubts comment below,I will try my best to explain you",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        cur_buy = prices[0]\\n        for price in prices:\\n            if price<cur_buy:cur_buy = price  #As stated in Condition 1\\n            \\n            if price>cur_buy:  #As stated in Condition 2\\n                profit += (price-cur_buy)\\n                cur_buy = price\\n    \\n        return profit\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0 , cur_buy = prices[0];\\n        for(int& price : prices){\\n            if(price<cur_buy) {\\n                cur_buy = price;  //As stated in Condition 1\\n            }\\n            if(price>cur_buy){  //As stated in Condition 2\\n                profit += (price-cur_buy);\\n                cur_buy = price;\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569301,
                "title": "c-solution-with-4ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int> &prices) {\\n    int profit = 0;\\n    for (size_t p = 1; p < prices.size(); ++p) \\n      profit += max(prices[p] - prices[p - 1], 0);    \\n    return profit;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int> &prices) {\\n    int profit = 0;\\n    for (size_t p = 1; p < prices.size(); ++p) \\n      profit += max(prices[p] - prices[p - 1], 0);    \\n    return profit;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569086,
                "title": "c-recursion-memoization-with-each-line-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n      // we have created an dp array of size of array length \\n\\t  // here 2nd dimension of dp array we are using for toggling the buy and sell values\\n\\t  // 0 -  no stock on hold\\n\\t  // 1 - mean we have one stock we need to first sell it as given in question\\n    int dp[30000][2];\\n    int solve(vector<int>& v,int i,int flag=0){\\n        if(i>=v.size()) return 0;  // if index is out of bound no profit will be generated so return zero\\n        if(dp[i][flag]!=-1)\\n           return dp[i][flag]; // if this problem occured previously then we will directly return from here\\n        int profit=0; \\n        if(flag==0){   // if flag==0  which means we don\\'t have any stock\\n\\t\\t  // first we need to buy one\\n\\t\\t  // it implies two possibilities  either we buy or we dont\\'t buy \\n            int x=solve(v,i+1,1)-v[i];  // if we buy then this stock price is deducted from our overall profit\\n            int y=solve(v,i+1,0); // or we can also skip this day\\n\\t\\t\\t// now after recursively solving both the case we get the profit amount from both scenario\\n            profit=max(x,y); // we will choose maximum\\n// here thing to be noticed that if we buy the stock then flag value become 1 (as we considered above)\\n\\t\\t\\t// or if we don\\'t buy it remain as it is\\n        }\\n        else{\\n\\t\\t    // flag==1 \\n\\t\\t\\t// we again have two possibilities either we can sell the stock or we can skip this day\\n            int x=solve(v,i+1,0)+v[i];  // if we sell the stock we will get some profit which we will add in  overall profit ( flag will beome 0 )\\n            int y=solve(v,i+1,1); // we can also skip the day flag remain as it is\\n\\t\\t\\t//after taking both the cases and solving problem recursively we will take maximum profit\\n            profit=max(x,y);\\n        }\\n        return dp[i][flag]=profit; // for this particular day at this particular flag value we are storing our //answer for repeating sub problems\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,0); // here we are passing flag value equal to zero which mean we don\\'t \\n\\t\\t// have any stock initially\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n      // we have created an dp array of size of array length \\n\\t  // here 2nd dimension of dp array we are using for toggling the buy and sell values\\n\\t  // 0 -  no stock on hold\\n\\t  // 1 - mean we have one stock we need to first sell it as given in question\\n    int dp[30000][2];\\n    int solve(vector<int>& v,int i,int flag=0){\\n        if(i>=v.size()) return 0;  // if index is out of bound no profit will be generated so return zero\\n        if(dp[i][flag]!=-1)\\n           return dp[i][flag]; // if this problem occured previously then we will directly return from here\\n        int profit=0; \\n        if(flag==0){   // if flag==0  which means we don\\'t have any stock\\n\\t\\t  // first we need to buy one\\n\\t\\t  // it implies two possibilities  either we buy or we dont\\'t buy \\n            int x=solve(v,i+1,1)-v[i];  // if we buy then this stock price is deducted from our overall profit\\n            int y=solve(v,i+1,0); // or we can also skip this day\\n\\t\\t\\t// now after recursively solving both the case we get the profit amount from both scenario\\n            profit=max(x,y); // we will choose maximum\\n// here thing to be noticed that if we buy the stock then flag value become 1 (as we considered above)\\n\\t\\t\\t// or if we don\\'t buy it remain as it is\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1526882,
                "title": "you-will-like-this-solution",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        res=0\\n        for  p in range(len(prices)-1):\\n            if prices[p]<=prices[p+1]:\\n                res+=prices[p+1]-prices[p]    \\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        res=0\\n        for  p in range(len(prices)-1):\\n            if prices[p]<=prices[p+1]:\\n                res+=prices[p+1]-prices[p]    \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1483621,
                "title": "easy-for-beginner-in-c-o-n",
                "content": "class Solution {\\npublic:\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int n=prices.size();\\n        for(int i=1;i<n;i++){\\n            if(prices[i]>prices[i-1]){\\n                profit+=(prices[i]-prices[i-1]);\\n            }\\n        }\\n        return profit;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int n=prices.size();\\n        for(int i=1;i<n;i++){\\n            if(prices[i]>prices[i-1]){\\n                profit+=(prices[i]-prices[i-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1204333,
                "title": "java-0ms-solution-beats-100-performance",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for(int i = 1; i < prices.length; i++) {\\n            if(prices[i-1] < prices[i]) {\\n                profit = profit + prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for(int i = 1; i < prices.length; i++) {\\n            if(prices[i-1] < prices[i]) {\\n                profit = profit + prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127612,
                "title": "simple-c-solution-4-lines",
                "content": "```\\n    public int MaxProfit(int[] prices) {\\n        int max = 0;\\n        \\n        for(int i = 1; i < prices.Length; i++)\\n            max += (prices[i] - prices[i - 1]) > 0 ? (prices[i] - prices[i - 1]) : 0;\\n        \\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int MaxProfit(int[] prices) {\\n        int max = 0;\\n        \\n        for(int i = 1; i < prices.Length; i++)\\n            max += (prices[i] - prices[i - 1]) > 0 ? (prices[i] - prices[i - 1]) : 0;\\n        \\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1101371,
                "title": "oms-and-100-faster-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0 ;\\n        for(int i = 1 ; i < prices.length ; i++){\\n            if(prices[i] > prices[i-1])\\n                profit += (prices[i] - prices[i-1]);\\n        }\\n        return profit ;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6970e5b4-9da4-40b2-aab6-ad43773ece54_1615297299.8992136.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0 ;\\n        for(int i = 1 ; i < prices.length ; i++){\\n            if(prices[i] > prices[i-1])\\n                profit += (prices[i] - prices[i-1]);\\n        }\\n        return profit ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042025,
                "title": "c-very-easy-solution-using-explanantion",
                "content": "### T = O(N) where N is number of days\\n### S = O(1)\\n\\n```\\nint maxProfit(vector<int>& prices) {\\n          int sum = 0;  // to store result\\n        int minCost = prices[0];  // initialise minimum cost as first day price\\n        int maxProfit = 0;  // initially profit is zero\\n        for(int i = 1; i < prices.size(); i++) {    // Now check from day 2\\n            if(prices[i] > minCost && prices[i] > prices[i-1]) {  // if current day price is better than previous day price & also greater than minimum cost so that to get maximum profit till date\\n                maxProfit = max(maxProfit, prices[i] - minCost);\\n                cout << maxProfit << \" \";\\n            } else {      // since current day price is less as compared to previous also we have got maximum profit till date\\n                sum = sum + maxProfit;\\n                minCost = prices[i];   // Again we will set minimum cost as current day price\\n                maxProfit = 0;      // Now again from next day we will buy i.e maximum profit is now zero in hand\\n            }\\n        }\\n        sum = sum + maxProfit;\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices) {\\n          int sum = 0;  // to store result\\n        int minCost = prices[0];  // initialise minimum cost as first day price\\n        int maxProfit = 0;  // initially profit is zero\\n        for(int i = 1; i < prices.size(); i++) {    // Now check from day 2\\n            if(prices[i] > minCost && prices[i] > prices[i-1]) {  // if current day price is better than previous day price & also greater than minimum cost so that to get maximum profit till date\\n                maxProfit = max(maxProfit, prices[i] - minCost);\\n                cout << maxProfit << \" \";\\n            } else {      // since current day price is less as compared to previous also we have got maximum profit till date\\n                sum = sum + maxProfit;\\n                minCost = prices[i];   // Again we will set minimum cost as current day price\\n                maxProfit = 0;      // Now again from next day we will buy i.e maximum profit is now zero in hand\\n            }\\n        }\\n        sum = sum + maxProfit;\\n        return sum;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 941225,
                "title": "python-o-n-solution",
                "content": "Simple Python Logic\\n* If the price at 1 day is greater than the price of the previous day, buy the previous day and sell at the current day to get that profit, and do it for all the stocks in o(N) time and you\\'ll get the maximum profit.\\n\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n    return sum([prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]>prices[i]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef maxProfit(self, prices: List[int]) -> int:\\n    return sum([prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]>prices[i]])\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1566137,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1576892,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1575662,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1570091,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1565315,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1566747,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1568310,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1567200,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1956066,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1568307,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1566137,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1576892,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1575662,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1570091,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1565315,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1566747,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1568310,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1567200,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1956066,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1568307,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1567199,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1885082,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1572661,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1567869,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1576242,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1576032,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1575751,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1572619,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1567868,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1979433,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1941475,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1574923,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1574828,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1573213,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1572278,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1571254,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1571252,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1570794,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1567870,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 2075996,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 2066818,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2066047,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2064376,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2064080,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2059765,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2057799,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2043585,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2041415,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2036633,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2036560,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2036258,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2034210,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2029069,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2017581,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2012463,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2011063,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2001753,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2001665,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 1988359,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 1988239,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 1973208,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1962711,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1956828,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1942645,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1939317,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1938075,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1930707,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1928781,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1928190,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1908981,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1899340,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1894741,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1892088,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1880969,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1870133,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1868089,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1863935,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1860872,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1860713,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1841474,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1840210,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1827141,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1815153,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1815151,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1808623,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1793546,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1781018,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1775919,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1764764,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1759225,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1756344,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1746030,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1726313,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1726080,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1723743,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1709001,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1702303,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1696583,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1694710,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1635909,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Complete Tree Nodes",
        "question_content": "<p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>\n\n<p>According to <strong><a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>\n\n<p>Design an algorithm that runs in less than&nbsp;<code data-stringify-type=\"code\">O(n)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" style=\"width: 372px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>The tree is guaranteed to be <strong>complete</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 61958,
                "title": "concise-java-solutions-o-log-n-2",
                "content": "**Main Solution** - 572 ms\\n\\n    class Solution {\\n        int height(TreeNode root) {\\n            return root == null ? -1 : 1 + height(root.left);\\n        }\\n        public int countNodes(TreeNode root) {\\n            int h = height(root);\\n            return h < 0 ? 0 :\\n                   height(root.right) == h-1 ? (1 << h) + countNodes(root.right)\\n                                             : (1 << h-1) + countNodes(root.left);\\n        }\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nThe height of a tree can be found by just going left. Let a single node tree have height 0. Find the height `h` of the whole tree. If the whole tree is empty, i.e., has height -1, there are 0 nodes.\\n\\nOtherwise check whether the height of the right subtree is just one less than that of the whole tree, meaning left and right subtree have the same height.\\n\\n- If yes, then the last node on the last tree row is in the right subtree and the left subtree is a full tree of height h-1. So we take the 2^h-1 nodes of the left subtree plus the 1 root node plus recursively the number of nodes in the right subtree.\\n- If no, then the last node on the last tree row is in the left subtree and the right subtree is a full tree of height h-2. So we take the 2^(h-1)-1 nodes of the right subtree plus the 1 root node plus recursively the number of nodes in the left subtree.\\n\\nSince I halve the tree in every recursive step, I have O(log(n)) steps. Finding a height costs O(log(n)). So overall O(log(n)^2).\\n\\n---\\n\\n**Iterative Version** - 508 ms\\n\\nHere's an iterative version as well, with the benefit that I don't recompute `h` in every step.\\n\\n    class Solution {\\n        int height(TreeNode root) {\\n            return root == null ? -1 : 1 + height(root.left);\\n        }\\n        public int countNodes(TreeNode root) {\\n            int nodes = 0, h = height(root);\\n            while (root != null) {\\n                if (height(root.right) == h - 1) {\\n                    nodes += 1 << h;\\n                    root = root.right;\\n                } else {\\n                    nodes += 1 << h-1;\\n                    root = root.left;\\n                }\\n                h--;\\n            }\\n            return nodes;\\n        }\\n    }\\n\\n---\\n\\n**A Different Solution** - 544 ms\\n\\nHere's one based on [victorlee's C++ solution](https://leetcode.com/discuss/38899/easy-short-c-recursive-solution).\\n\\n    class Solution {\\n        public int countNodes(TreeNode root) {\\n            if (root == null)\\n                return 0;\\n            TreeNode left = root, right = root;\\n            int height = 0;\\n            while (right != null) {\\n                left = left.left;\\n                right = right.right;\\n                height++;\\n            }\\n            if (left == null)\\n                return (1 << height) - 1;\\n            return 1 + countNodes(root.left) + countNodes(root.right);\\n        }\\n    }\\n\\nNote that that's basically this:\\n\\n    public int countNodes(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        return 1 + countNodes(root.left) + countNodes(root.right)\\n\\nThat would be O(n). But... the actual solution has a gigantic optimization. It first walks all the way left and right to determine the height and whether it's a full tree, meaning the last row is full. If so, then the answer is just 2^height-1. And since always at least one of the two recursive calls is such a full tree, at least one of the two calls immediately stops. Again we have runtime O(log(n)^2).",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        int height(TreeNode root) {\\n            return root == null ? -1 : 1 + height(root.left);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 61953,
                "title": "easy-short-c-recursive-solution",
                "content": "    class Solution {\\n    \\n    public:\\n    \\n        int countNodes(TreeNode* root) {\\n    \\n            if(!root) return 0;\\n    \\n            int hl=0, hr=0;\\n    \\n            TreeNode *l=root, *r=root;\\n    \\n            while(l) {hl++;l=l->left;}\\n    \\n            while(r) {hr++;r=r->right;}\\n    \\n            if(hl==hr) return pow(2,hl)-1;\\n    \\n            return 1+countNodes(root->left)+countNodes(root->right);\\n    \\n        }\\n    \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public:\\n    \\n        int countNodes(TreeNode* root) {\\n    \\n            if(!root) return 0;\\n    \\n            int hl=0, hr=0;\\n    \\n            TreeNode *l=root, *r=root;\\n    \\n            while(l) {hl++;l=l->left;}",
                "codeTag": "Java"
            },
            {
                "id": 62088,
                "title": "my-python-solution-in-o-lgn-lgn-time",
                "content": "   compare the depth between left sub tree and right sub tree.\\nA, If it is equal, it means the left sub tree is a full binary tree\\nB, It it is not , it means the right sub tree is a full binary tree \\n\\n     class Solution:\\n            # @param {TreeNode} root\\n            # @return {integer}\\n            def countNodes(self, root):\\n                if not root:\\n                    return 0\\n                leftDepth = self.getDepth(root.left)\\n                rightDepth = self.getDepth(root.right)\\n                if leftDepth == rightDepth:\\n                    return pow(2, leftDepth) + self.countNodes(root.right)\\n                else:\\n                    return pow(2, rightDepth) + self.countNodes(root.left)\\n        \\n            def getDepth(self, root):\\n                if not root:\\n                    return 0\\n                return 1 + self.getDepth(root.left)",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "class Solution:\\n            # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 61948,
                "title": "accepted-easy-understand-java-solution",
                "content": "\\npublic class Solution {\\n\\n    public int countNodes(TreeNode root) {\\n\\n        int leftDepth = leftDepth(root);\\n\\t\\tint rightDepth = rightDepth(root);\\n\\n\\t\\tif (leftDepth == rightDepth)\\n\\t\\t\\treturn (1 << leftDepth) - 1;\\n\\t\\telse\\n\\t\\t\\treturn 1+countNodes(root.left) + countNodes(root.right);\\n\\n\\t}\\n\\n\\tprivate int rightDepth(TreeNode root) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tint dep = 0;\\n\\t\\twhile (root != null) {\\n\\t\\t\\troot = root.right;\\n\\t\\t\\tdep++;\\n\\t\\t}\\n\\t\\treturn dep;\\n\\t}\\n\\n\\tprivate int leftDepth(TreeNode root) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tint dep = 0;\\n\\t\\twhile (root != null) {\\n\\t\\t\\troot = root.left;\\n\\t\\t\\tdep++;\\n\\t\\t}\\n\\t\\treturn dep;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int countNodes(TreeNode root) {\\n\\n        int leftDepth = leftDepth(root);\\n\\t\\tint rightDepth = rightDepth(root);\\n\\n\\t\\tif (leftDepth == rightDepth)\\n\\t\\t\\treturn (1 << leftDepth) - 1;\\n\\t\\telse\\n\\t\\t\\treturn 1+countNodes(root.left) + countNodes(root.right);\\n\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2815375,
                "title": "python-c-java-rust-logn-logn-with-proof-bonus-complete-list-of-solutions-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs the main property of a complete tree, namely, that children of a complete tree are also complete trees, with at least one of them being a full tree. Time complexity is **O(logN\\\\*logN)**. Space complexity is **O(logN)**.\\n****\\n**Comment.** Straightforward solutions (by completely traversing the tree) are trivial (see **BONUS**). However, given a constraint (namely, that the tree is a *complete tree*), we can do better. The main property of a *complete tree* is that both of its children are also *complete trees*. Thus, we can quickly, i.e., in **O(logN)** time, check whether a *complete tree* is also a *full tree* (with all levels being filled) by just comparing its left height to its right height. For each node, at least one of child nodes is a full tree, with the total number of nodes equal `2^depth - 1`. \\n\\nThe complete proof of complexity goes as follows:\\n1. Determining the height of each node is **O(logN)** time complexity (just go all the way down both to the left and to the right, with no branching).\\n2. When performing DFS, we consider two child nodes. At least one of them is a full tree (think why). Thus in the worst case, we\\'ll only have to continue exploring another one. So on the 1st level, we explore just 1 node out of 2. The same is true for the 2nd level and so on until we explore **O(logN)** nodes, 1 node on each level.\\n3. Having **O(logN)** nodes explored with DFS, each taking **O(logN)** steps to determine height, results in the overall **O(logN\\\\*logN)** complexity.\\n\\n**Python.** Please note the trick with `:=` operator here. \\n``` \\nclass Solution:\\n    def countNodes(self, root, l=1, r=1):\\n\\n        if not root : return 0\\n        \\n        left = right = root                           # compute both left and right heights of\\n        while left  := left.left   : l += 1           # each subtree by going all way down to\\n        while right := right.right : r += 1           # the left and right (in logN time)\\n\\n        if l == r : return 2**l - 1                   # if it\\'s a full tree, its size is known\\n        \\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/hyiTnCBt/shared\" frameBorder=\"0\" width=\"800\" height=\"370\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\nAs a **BONUS**, I provide a complete (LOL, of course not) list of soutions.\\n\\n**Python #1.** BFS with the traversal of every node. Time/space complexity is linear: **O(N)**.\\n```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n\\n        dq, m = deque([root]), 0\\n        while dq:\\n            node = dq.popleft()\\n            if node:\\n                m +=1\\n                dq.append(node.left)\\n                dq.append(node.right)\\n        return m\\n```\\n\\n**Python #2.** A recursive DFS one-liner. Time/space complexity is linear: **O(N)**.\\n```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n\\t\\t# counting 1 for every node that is not None\\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right) if root else 0\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def countNodes(self, root, l=1, r=1):\\n\\n        if not root : return 0\\n        \\n        left = right = root                           # compute both left and right heights of\\n        while left  := left.left   : l += 1           # each subtree by going all way down to\\n        while right := right.right : r += 1           # the left and right (in logN time)\\n\\n        if l == r : return 2**l - 1                   # if it\\'s a full tree, its size is known\\n        \\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n```\n```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n\\n        dq, m = deque([root]), 0\\n        while dq:\\n            node = dq.popleft()\\n            if node:\\n                m +=1\\n                dq.append(node.left)\\n                dq.append(node.right)\\n        return m\\n```\n```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n\\t\\t# counting 1 for every node that is not None\\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right) if root else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701466,
                "title": "python-o-log-n-log-n-solution-with-binary-search-explained",
                "content": "Here we are given, that our tree is **complete** and we need to use this property to make it faster. Let us consider the following tree:\\n\\n![image](https://assets.leetcode.com/users/images/f7f87be1-a1db-4a9a-bdc0-237967e45e6a_1592898732.3434315.png)\\n\\n1. I denoted values for nodes in the way of how we are going to count them, note that it does not matter in fact what is inside.\\n2. First step is to find the number of  levels in our tree, you can see, that levels with depth `0,1,2` are full levels and level with `depth = 3` is not full here.\\n3. So, when we found that `depth = 3`, we know, that there can be between `8` and `15` nodes when we fill the last layer.\\n4. How we can find the number of elements in last layer? We use **binary search**, because we know, that elements go from left to right in complete binary tree. To reach the last layer we use binary decoding, for example for number `10`, we write it as `1010` in binary, remove first element (it always will be `1` and we not interested in it), and now we need to take `3` steps: `010`, which means `left, right, left`.\\n\\n**Complexity.** To find number of layers we need `O(log n)`. We also need `O(log n)` iterations for binary search, on each of them we reach the bottom layer in `O(log n)`. So, overall time complexity is `O(log n * log n)`.  Space complexity is `O(log n)`.\\n\\n**Code** I use auxiliary funcion `Path`, which returns True if it found node with given number and False in opposite case. In main function we first evaluate depth, and then start binary search with interval `2^depth, 2^{depth+1} - 1`. We also need to process one border case, where last layer is full.\\n\\n```\\nclass Solution:\\n    def Path(self, root, num):\\n        for s in bin(num)[3:]:\\n            if s == \"0\": \\n                root = root.left\\n            else:\\n                root = root.right\\n            if not root: return False\\n        return True\\n        \\n    def countNodes(self, root):\\n        if not root: return 0\\n        \\n        left, depth = root, 0\\n        while left.left:\\n            left, depth = left.left, depth + 1\\n\\n        begin, end = (1<<depth), (1<<(depth+1)) - 1\\n        if self.Path(root,end): return end\\n        \\n        while begin + 1 < end:\\n            mid = (begin + end)//2\\n            if self.Path(root, mid):\\n                begin = mid\\n            else:\\n                end = mid\\n        return begin\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def Path(self, root, num):\\n        for s in bin(num)[3:]:\\n            if s == \"0\": \\n                root = root.left\\n            else:\\n                root = root.right\\n            if not root: return False\\n        return True\\n        \\n    def countNodes(self, root):\\n        if not root: return 0\\n        \\n        left, depth = root, 0\\n        while left.left:\\n            left, depth = left.left, depth + 1\\n\\n        begin, end = (1<<depth), (1<<(depth+1)) - 1\\n        if self.Path(root,end): return end\\n        \\n        while begin + 1 < end:\\n            mid = (begin + end)//2\\n            if self.Path(root, mid):\\n                begin = mid\\n            else:\\n                end = mid\\n        return begin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61950,
                "title": "my-java-solution-with-explanation-which-beats-99",
                "content": "Basically my solution contains 2 steps.\\n(1) Firstly, we need to find the height of the binary tree and count the nodes above the last level.\\n(2) Then we should find a way to count the nodes on the last level. \\n\\nHere I used a kind of binary search. We define the \"midNode\" of the last level as a node following the path \"root->left->right->right->...->last level\". \\n\\nIf midNode is null, then it means we should count the nodes on the last level in the left subtree.\\n\\nIf midNode is not null, then we add half of the last level nodes to our result and then count the nodes on the last level in the right subtree.\\n\\nOf course I used some stop condition to make the code more efficient, e.g. when a tree has height 1, it means it only has 3 cases: 1. has right son; 2. only has left son; 3. has no son.\\n\\n    public int countNodes(TreeNode root) {\\n    \\tif (root==null) return 0;\\n    \\tif (root.left==null) return 1;\\n    \\tint height = 0;\\n        int nodesSum = 0;\\n    \\tTreeNode curr = root;\\n        while(curr.left!=null) {\\n        \\tnodesSum += (1<<height);\\n        \\theight++;\\n        \\tcurr = curr.left;\\n        }\\n        return nodesSum + countLastLevel(root, height);\\n    }\\n    \\n\\tprivate int countLastLevel(TreeNode root, int height) {\\n\\t\\tif(height==1) \\n\\t\\t\\tif (root.right!=null) return 2;\\n\\t\\t\\telse if (root.left!=null) return 1;\\n\\t\\t\\telse return 0;\\n\\t\\tTreeNode midNode = root.left;\\n\\t\\tint currHeight = 1;\\n\\t\\twhile(currHeight<height) {\\n\\t\\t\\tcurrHeight++;\\n\\t\\t\\tmidNode = midNode.right;\\n\\t\\t}\\n\\t\\tif (midNode==null) return countLastLevel(root.left, height-1);\\n\\t\\telse return (1<<(height-1)) + countLastLevel(root.right, height-1);\\n\\t}",
                "solutionTags": [],
                "code": "Basically my solution contains 2 steps.\\n(1) Firstly, we need to find the height of the binary tree and count the nodes above the last level.\\n(2) Then we should find a way to count the nodes on the last level. \\n\\nHere I used a kind of binary search. We define the \"midNode\" of the last level as a node following the path \"root->left->right->right->...->last level\". \\n\\nIf midNode is null, then it means we should count the nodes on the last level in the left subtree.\\n\\nIf midNode is not null, then we add half of the last level nodes to our result and then count the nodes on the last level in the right subtree.\\n\\nOf course I used some stop condition to make the code more efficient, e.g. when a tree has height 1, it means it only has 3 cases: 1. has right son; 2. only has left son; 3. has no son.\\n\\n    public int countNodes(TreeNode root) {\\n    \\tif (root==null) return 0;\\n    \\tif (root.left==null) return 1;\\n    \\tint height = 0;\\n        int nodesSum = 0;\\n    \\tTreeNode curr = root;\\n        while(curr.left!=null) {\\n        \\tnodesSum += (1<<height);\\n        \\theight++;\\n        \\tcurr = curr.left;\\n        }\\n        return nodesSum + countLastLevel(root, height);\\n    }\\n    \\n\\tprivate int countLastLevel(TreeNode root, int height) {\\n\\t\\tif(height==1) \\n\\t\\t\\tif (root.right!=null) return 2;\\n\\t\\t\\telse if (root.left!=null) return 1;\\n\\t\\t\\telse return 0;\\n\\t\\tTreeNode midNode = root.left;\\n\\t\\tint currHeight = 1;\\n\\t\\twhile(currHeight<height) {\\n\\t\\t\\tcurrHeight++;\\n\\t\\t\\tmidNode = midNode.right;\\n\\t\\t}\\n\\t\\tif (midNode==null) return countLastLevel(root.left, height-1);\\n\\t\\telse return (1<<(height-1)) + countLastLevel(root.right, height-1);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 61967,
                "title": "a-very-clear-recursive-solution-isn-t-it",
                "content": "        /**\\n         * Definition for a binary tree node.\\n         * struct TreeNode {\\n         *     int val;\\n         *     TreeNode *left;\\n         *     TreeNode *right;\\n         *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n         * };\\n         */\\n        class Solution {\\n        public:\\n            int countNodes(TreeNode* root) {\\n                if(!root) return 0;\\n                int lh = height(root->left);\\n                int rh = height(root->right);     \\n                if(lh == rh) \\n                   return (1 << lh) + countNodes(root->right);  /*1(\\u6839\\u8282\\u70b9) + (1<<lh)-1(\\u5b8c\\u5168\\u5de6\\u5b50\\u6811) + # of rightNode */               \\n                else \\n                   return (1 << rh) + countNodes(root->left);  /*1(\\u6839\\u8282\\u70b9) + (1<<rh)-1(\\u5b8c\\u5168\\u53f3\\u5b50\\u6811) + # of leftNode*/\\n            }\\n        private:\\n            int height(TreeNode *root){ //get the height of a complete binary tree.\\n                if(!root) return 0;\\n                return 1 + height(root->left);\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int countNodes(TreeNode* root) {\\n                if(!root) return 0;\\n                int lh = height(root->left);\\n                int rh = height(root->right);     \\n                if(lh == rh) \\n                   return (1 << lh) + countNodes(root->right);  /*1(\\u6839\\u8282\\u70b9) + (1<<lh)-1(\\u5b8c\\u5168\\u5de6\\u5b50\\u6811) + # of rightNode */               \\n                else \\n                   return (1 << rh) + countNodes(root->left);  /*1(\\u6839\\u8282\\u70b9) + (1<<rh)-1(\\u5b8c\\u5168\\u53f3\\u5b50\\u6811) + # of leftNode*/\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1538170,
                "title": "c-simple-and-concise-recursive-solution-o-logn-logn",
                "content": "**Idea:**\\nWe go all the way to the left and count height, and all the way to the right and count height.\\nIf they are equal, both subtrees are complete.\\nOtherwise, we will do the same for each subtree.\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if (!root) return 0;\\n        \\n        int l = 1, r = 1;\\n        TreeNode *ptr_r = root, *ptr_l = root;\\n        while (ptr_l = ptr_l->left) l++;\\n        while (ptr_r = ptr_r->right) r++;\\n        \\n        if (l == r) return pow(2, l) - 1;\\n        return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if (!root) return 0;\\n        \\n        int l = 1, r = 1;\\n        TreeNode *ptr_r = root, *ptr_l = root;\\n        while (ptr_l = ptr_l->left) l++;\\n        while (ptr_r = ptr_r->right) r++;\\n        \\n        if (l == r) return pow(2, l) - 1;\\n        return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815567,
                "title": "python3-general-binary-search-using-template",
                "content": "There is a shorter/smarter solution, but I\\'m trying to explain a more **general binary search** approach in detail with a good **Template** giveaway.\\n\\n(1) The input is a complete binary tree.\\n(2) The question is asking for an algorithm better than O(n).\\n\\nStart with (1):\\nThe input is a complete binary tree, which means if we know the depth of the tree, we know the number of nodes up to depth-1 level. \\ne.g., \\ndepth=1 (level0 with only a root), numberOfNode = ```2^depth -1``` = (1)\\ndepth=2 (level1), numberOfNode = ```2^depth -1``` = 3 = (1) + (2)\\ndepth=3 (level2), numberOfNode = ```2^depth -1``` = 7 = (1) + (2) + (4)\\n\\nSo the first problem we need to solve is **finding the depth** of the tree, and we can easily get it following the leftmost path in the tree.\\n\\n```\\ndef findDepth(node):\\n    if not node.left:\\n        return 0\\n    return findDepth(node.left)+1\\n```\\n\\nNow the problem becomes finding the number of nodes on the last level. \\nA complete binary tree will have all nodes in the last level that are as far left as possible. \\nLet\\'s think about the last level nodes as an array like this: ```[1,2,3,4,None,None,None,None]```, and we need to find the index of the last element that is not ```None```. \\nRemember (2), we need an algorithm better than O(n), which means we may want to use a binary search algorithm.\\n\\nI was looking for an **intuitive binary search template** for a while and eventually found this one which I really like:\\n```python\\ndef binarySearch():\\n    s = 0               ### a start index (a valid index)\\n    e = len(something)  ### the total length of something (an invalid index, assuming 0-indexed)\\n    while s+1<e:\\n        mid = (s+e)//2\\n        ### when we check mid, if it meets the condition, we assign mid to s\\n        ### because we want to make sure s is always at a valid index\\n        if check(mid):\\n            s = mid\\n        else:\\n            e = mid\\n    return s ### again s is always a valid index, so it should be the answer\\n```\\nThe advantage of this template is that we don\\'t need to think too much about the indices (e.g., +1, -1, odd, even, etc.) because we know that s will always be valid and it will be the result at the end. Note that, sometimes, depending on the problem, we may want to make ```e``` be the result, and in that case, we will assign ```s``` to -1 (0-indexed) and let ```e``` be len(something)-1 at the beginning, and make sure ```e``` is always valid during the search.\\n\\nBack to the problem, we can have ```s = 1``` (1-indexed for this problem), and ```e = 2^depth + 1```, which is the number of nodes at the last level; if all nodes are not ```None```, we use +1 to make ```e```an invalid index.\\n\\nNow the problem is **how to do the check using the tree instead of an array**. \\nAt each node, we will use a ```left``` and ```right``` to represent the start and end indices (inclusive) of the sub-array at the last level, rooted at the current node. And we check to see if ```mid``` is on the left side ```mid<=(left+right)//2``` or is on the right side ```mid>(left+right)//2``` of this sub-array. Remember to shrink the sub-array for the next level. i.e., if it is on the left side, then ```left``` remains, and ```right = (left+right)//2```. If it is on the right side, then ```right``` remains, and ```left = (left+right)//2```. We return True if we are at the last level, ```current depth == full depth```, and the node is not None.\\n\\n```python\\ndef check(node,mid,d,left,right):\\n    if d == depth: return True if node else False\\n    if mid <= (left+right)//2:\\n        return check(node.left,mid,d+1,left,(left+right)//2)\\n    else:\\n        return check(node.right,mid,d+1,(left+right)//2,right)\\n```\\n\\n**Now putting everything together** O(logN * logN)\\n\\n```python\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root: return 0\\n        \\n        def findDepth(node):\\n            if not node.left:\\n                return 0\\n            return findDepth(node.left)+1\\n\\n        def check(node,mid,curDepth,left,right):\\n            if curDepth == depth: return True if node else False\\n            if mid <= (left+right)//2:\\n                return check(node.left,mid,curDepth+1,left,(left+right)//2)\\n            else:\\n                return check(node.right,mid,curDepth+1,(left+right)//2,right)\\n        \\n        depth = findDepth(root)\\n        lastLevelLength = 2**depth\\n        \\n        s,e = 1,lastLevelLength+1\\n        while s+1<e:\\n            mid = (s+e)//2\\n            if check(root,mid,0,1,lastLevelLength):\\n                s = mid\\n            else:\\n                e = mid\\n\\n        return lastLevelLength - 1 + s\\n```\\n\\n**Try a few other binary search problem using this template**\\n[Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n[Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n[Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n[Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\n**Another solution** which fully utilized the complete binary tree property from [stanislav-iablokov](https://leetcode.com/problems/count-complete-tree-nodes/discuss/2815375/PythonC%2B%2BJavaRust-logN*logN-%2B-BONUS-complete-list-of-solutions-(explained)). O(logN * logN)\\n\\n```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root: return 0\\n        \\n        def getHeight(node,side):\\n            if not node: return 1\\n            return getHeight(node.left,side)+1 if side==\\'l\\' else getHeight(node.right,side)+1\\n        \\n        l = getHeight(root.left,\\'l\\')\\n        r = getHeight(root.right,\\'r\\')\\n        if l==r: return pow(2,l) - 1\\n        return self.countNodes(root.left)+self.countNodes(root.right) + 1\\n```\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```2^depth -1```\n```2^depth -1```\n```2^depth -1```\n```\\ndef findDepth(node):\\n    if not node.left:\\n        return 0\\n    return findDepth(node.left)+1\\n```\n```[1,2,3,4,None,None,None,None]```\n```None```\n```python\\ndef binarySearch():\\n    s = 0               ### a start index (a valid index)\\n    e = len(something)  ### the total length of something (an invalid index, assuming 0-indexed)\\n    while s+1<e:\\n        mid = (s+e)//2\\n        ### when we check mid, if it meets the condition, we assign mid to s\\n        ### because we want to make sure s is always at a valid index\\n        if check(mid):\\n            s = mid\\n        else:\\n            e = mid\\n    return s ### again s is always a valid index, so it should be the answer\\n```\n```e```\n```s```\n```e```\n```e```\n```s = 1```\n```e = 2^depth + 1```\n```None```\n```e```\n```left```\n```right```\n```mid```\n```mid<=(left+right)//2```\n```mid>(left+right)//2```\n```left```\n```right = (left+right)//2```\n```right```\n```left = (left+right)//2```\n```current depth == full depth```\n```python\\ndef check(node,mid,d,left,right):\\n    if d == depth: return True if node else False\\n    if mid <= (left+right)//2:\\n        return check(node.left,mid,d+1,left,(left+right)//2)\\n    else:\\n        return check(node.right,mid,d+1,(left+right)//2,right)\\n```\n```python\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root: return 0\\n        \\n        def findDepth(node):\\n            if not node.left:\\n                return 0\\n            return findDepth(node.left)+1\\n\\n        def check(node,mid,curDepth,left,right):\\n            if curDepth == depth: return True if node else False\\n            if mid <= (left+right)//2:\\n                return check(node.left,mid,curDepth+1,left,(left+right)//2)\\n            else:\\n                return check(node.right,mid,curDepth+1,(left+right)//2,right)\\n        \\n        depth = findDepth(root)\\n        lastLevelLength = 2**depth\\n        \\n        s,e = 1,lastLevelLength+1\\n        while s+1<e:\\n            mid = (s+e)//2\\n            if check(root,mid,0,1,lastLevelLength):\\n                s = mid\\n            else:\\n                e = mid\\n\\n        return lastLevelLength - 1 + s\\n```\n```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root: return 0\\n        \\n        def getHeight(node,side):\\n            if not node: return 1\\n            return getHeight(node.left,side)+1 if side==\\'l\\' else getHeight(node.right,side)+1\\n        \\n        l = getHeight(root.left,\\'l\\')\\n        r = getHeight(root.right,\\'r\\')\\n        if l==r: return pow(2,l) - 1\\n        return self.countNodes(root.left)+self.countNodes(root.right) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62041,
                "title": "simple-c-recursive-solution",
                "content": "    int getLeftHeight(TreeNode* root) {\\n        int height = 0;\\n        while(root) { \\n            root = root->left;\\n            height++;\\n        }\\n        return height;\\n    }\\n\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int left_height = getLeftHeight(root->left);\\n        int right_height = getLeftHeight(root->right);\\n        \\n        if(left_height == right_height) \\n            return pow(2, left_height) + countNodes(root->right);\\n            \\n        return pow(2, right_height) + countNodes(root->left);\\n    }",
                "solutionTags": [],
                "code": "    int getLeftHeight(TreeNode* root) {\\n        int height = 0;\\n        while(root) { \\n            root = root->left;\\n            height++;\\n        }\\n        return height;\\n    }\\n\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int left_height = getLeftHeight(root->left);\\n        int right_height = getLeftHeight(root->right);\\n        \\n        if(left_height == right_height) \\n            return pow(2, left_height) + countNodes(root->right);\\n            \\n        return pow(2, right_height) + countNodes(root->left);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61999,
                "title": "java-concise-solution",
                "content": "        \\n    public int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int l = leftHeight(root.left);\\n        int r = leftHeight(root.right);\\n        if (l == r) { // left side is full\\n            return countNodes(root.right) + (1<<l);\\n        } \\n        return countNodes(root.left) + (1<<r);\\n    }\\n    \\n    private int leftHeight(TreeNode node) {\\n        int h = 0;\\n        while (node != null) {\\n            h++;\\n            node = node.left;\\n        }\\n        return h;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        \\n    public int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int l = leftHeight(root.left);\\n        int r = leftHeight(root.right);\\n        if (l == r) { // left side is full\\n            return countNodes(root.right) + (1<<l);\\n        } \\n        return countNodes(root.left) + (1<<r);\\n    }\\n    \\n    private int leftHeight(TreeNode node) {\\n        int h = 0;\\n        while (node != null) {\\n            h++;\\n            node = node.left;\\n        }\\n        return h;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62056,
                "title": "68ms-c-solution-using-binary-search-with-brief-explanation",
                "content": "The thought is simple. We just consider the lowest level of the tree.\\nThe left child and right child just divide the tree lower than the current node to 2 part.\\nSo what this code do is first check the right most child of the current node's left child.\\nIf this child is exist, we know that there may be more nodes on the right side of the tree. So we move the current node to it's right child. And repeat until we reach the lowest level.\\n\\n     int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        TreeNode *temp = root;\\n        int height = 0, count = 0, level;\\n        while(temp) {\\n            temp = temp->left;\\n            height ++;\\n        }\\n        temp = root;\\n        level = height - 2;\\n        while(level >= 0) {\\n            TreeNode *left = temp->left;\\n            for(int i = 0;i < level;i ++) {\\n                left = left->right;\\n            }\\n            if(left) {\\n                temp = temp->right;\\n                count += (1 << level);\\n            } else temp = temp->left;\\n            level --;\\n        }\\n        if(temp) count ++;\\n        return (1 << (height - 1)) + count - 1;\\n    }",
                "solutionTags": [],
                "code": "The thought is simple. We just consider the lowest level of the tree.\\nThe left child and right child just divide the tree lower than the current node to 2 part.\\nSo what this code do is first check the right most child of the current node's left child.\\nIf this child is exist, we know that there may be more nodes on the right side of the tree. So we move the current node to it's right child. And repeat until we reach the lowest level.\\n\\n     int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        TreeNode *temp = root;\\n        int height = 0, count = 0, level;\\n        while(temp) {\\n            temp = temp->left;\\n            height ++;\\n        }\\n        temp = root;\\n        level = height - 2;\\n        while(level >= 0) {\\n            TreeNode *left = temp->left;\\n            for(int i = 0;i < level;i ++) {\\n                left = left->right;\\n            }\\n            if(left) {\\n                temp = temp->right;\\n                count += (1 << level);\\n            } else temp = temp->left;\\n            level --;\\n        }\\n        if(temp) count ++;\\n        return (1 << (height - 1)) + count - 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1538458,
                "title": "c-4-methods-one-line-solution-easy-to-understand-clean-code",
                "content": "\\n\\n***Method-1 : ( 1-Line )***\\n```\\nint countNodes(TreeNode* root) {\\n        return root == NULL ? 0 : countNodes(root->left) + countNodes(root->right) + 1;\\n    }\\n};\\n```\\n\\n***Method - 2 : ( Effecient Approach )***\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        int lh = 0, rh = 0;\\n        TreeNode* l = root, *r = root;\\n        while(l){\\n            lh++;\\n            l = l->left;\\n        }\\n        while(r){\\n            rh++;\\n            r = r->right;\\n        }\\n        if(lh == rh)\\n            return pow(2, lh) - 1;\\n        \\n        return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};\\n```\\n*Time Complexity : O( logN  logN )*\\n\\n***Method - 3 : ( Using queue )***\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root == NULL)\\n        return 0;\\n    \\n        int res = 0;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n\\n            for(int i = 0; i < q.size(); ++ i)\\n            {\\n                 ++ res;\\n                TreeNode *p = q.front();\\n                q.pop();\\n\\n                if(p -> left != NULL)\\n                    q.push(p -> left);\\n                if(p -> right != NULL)\\n                    q.push(p -> right);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\n***Method - 4 : ( 0(n) approach )***\\n\\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void helper(TreeNode* root){\\n         \\n        if(root)\\n            count++;\\n        \\n        if(root->left)\\n        helper(root->left);\\n        if(root->right)\\n        helper(root->right);\\n        \\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n       helper(root);\\n        return count;\\n    }\\n};\\n```\\n*Time Complexity : O(n)*\\n\\nHope you liked it , kindly upvote !!\\n\\nHappy Coding \\uD83E\\uDD17",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nint countNodes(TreeNode* root) {\\n        return root == NULL ? 0 : countNodes(root->left) + countNodes(root->right) + 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        int lh = 0, rh = 0;\\n        TreeNode* l = root, *r = root;\\n        while(l){\\n            lh++;\\n            l = l->left;\\n        }\\n        while(r){\\n            rh++;\\n            r = r->right;\\n        }\\n        if(lh == rh)\\n            return pow(2, lh) - 1;\\n        \\n        return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root == NULL)\\n        return 0;\\n    \\n        int res = 0;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n\\n            for(int i = 0; i < q.size(); ++ i)\\n            {\\n                 ++ res;\\n                TreeNode *p = q.front();\\n                q.pop();\\n\\n                if(p -> left != NULL)\\n                    q.push(p -> left);\\n                if(p -> right != NULL)\\n                    q.push(p -> right);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void helper(TreeNode* root){\\n         \\n        if(root)\\n            count++;\\n        \\n        if(root->left)\\n        helper(root->left);\\n        if(root->right)\\n        helper(root->right);\\n        \\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n       helper(root);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126600,
                "title": "python-o-n-and-o-log-n-2-solution-with-explanation",
                "content": "O(N):\\nThe idea is just count all the nodes in the tree\\n```\\nclass Solution:\\n    def countNodes(self, root):\\n        if root is None:\\n            return 0\\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n```\\n\\nO(log(n) ^ 2):\\nThe idea is compare the left subtree depth with the right subtree depth. If they are equal, we have a full tree, thus we return 2^height - 1. If they aren\\'t equal, we do recursive call for the root.left subtree and the root.right subtree. Note that everytime we do recursive call for the root.left subtree or the root.right subtree, one of them must be a full tree due to the condition of the problem.\\n\\n```\\nclass Solution:\\n    def countNodes(self, root):\\n        leftdepth = self.getdepth(root, True)\\n        rightdepth = self.getdepth(root, False)\\n\\n        if leftdepth == rightdepth:\\n            return 2 ** leftdepth - 1\\n        else:\\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n\\n    def getdepth(self, root, isLeft):\\n        if root is None:\\n            return 0\\n        if isLeft:\\n            return 1 + self.getdepth(root.left, isLeft)\\n        else:\\n            return 1 + self.getdepth(root.right, isLeft)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNodes(self, root):\\n        if root is None:\\n            return 0\\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n```\n```\\nclass Solution:\\n    def countNodes(self, root):\\n        leftdepth = self.getdepth(root, True)\\n        rightdepth = self.getdepth(root, False)\\n\\n        if leftdepth == rightdepth:\\n            return 2 ** leftdepth - 1\\n        else:\\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n\\n    def getdepth(self, root, isLeft):\\n        if root is None:\\n            return 0\\n        if isLeft:\\n            return 1 + self.getdepth(root.left, isLeft)\\n        else:\\n            return 1 + self.getdepth(root.right, isLeft)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62029,
                "title": "c-solution-inspired-by-couple-of-good-ones",
                "content": "Concise C++ code I came up with after some inspiration from other solutions.<br>\\nThanks to:<br>\\n1. [Divide & Conquer C++ solution][1]<br>\\n2. [80ms C++ solution][2]\\n\\n    class Solution {\\n    public:\\n        int countNodes(TreeNode* root) {\\n            if (!root)\\n                return 0;\\n            int leftDepth = 0, rightDepth= 0;\\n            for(TreeNode* p=root; p; p=p->left) ++leftDepth;\\n            for(TreeNode* p=root; p; p=p->right) ++rightDepth;\\n            if (leftDepth==rightDepth) {\\n                return (1<< leftDepth) - 1 ;\\n            }\\n            else {\\n                return countNodes(root->left) + countNodes(root->right) + 1 ;\\n            }\\n        }\\n        \\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/39043/divide-&-conquer-c-solution\\n  [2]: https://leetcode.com/discuss/38929/80ms-c-solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int countNodes(TreeNode* root) {\\n            if (!root)\\n                return 0;\\n            int leftDepth = 0, rightDepth= 0;\\n            for(TreeNode* p=root; p; p=p->left) ++leftDepth;\\n            for(TreeNode* p=root; p; p=p->right) ++rightDepth;\\n            if (leftDepth==rightDepth) {\\n                return (1<< leftDepth) - 1 ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 693831,
                "title": "python-elegant-solution",
                "content": "```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n        ## TIME COMPLEXICITY : LOG N * LOG N ##\\n        \\n        ## LOGIC ##\\n        # If left sub tree height equals right sub tree height then,\\n        #       a. left sub tree is perfect binary tree\\n        #       b. right sub tree is complete binary tree\\n        # If left sub tree height greater than right sub tree height then,\\n        #       a. left sub tree is complete binary tree\\n        #       b. right sub tree is perfect binary tree\\n        \\n        if not root:\\n            return 0\\n        \\n        def depthLeft(node):\\n            d = 0\\n            while node:\\n                d += 1\\n                node = node.left\\n            return d\\n\\n        def depthRight(node):\\n            d = 0\\n            while node:\\n                d += 1\\n                node = node.right\\n            return d\\n        \\n        ld = depthLeft(root.left)\\n        rd = depthRight(root.right)\\n        \\n        if ld == rd:\\n            return 2**(ld + 1) - 1\\n        else:\\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n        ## TIME COMPLEXICITY : LOG N * LOG N ##\\n        \\n        ## LOGIC ##\\n        # If left sub tree height equals right sub tree height then,\\n        #       a. left sub tree is perfect binary tree\\n        #       b. right sub tree is complete binary tree\\n        # If left sub tree height greater than right sub tree height then,\\n        #       a. left sub tree is complete binary tree\\n        #       b. right sub tree is perfect binary tree\\n        \\n        if not root:\\n            return 0\\n        \\n        def depthLeft(node):\\n            d = 0\\n            while node:\\n                d += 1\\n                node = node.left\\n            return d\\n\\n        def depthRight(node):\\n            d = 0\\n            while node:\\n                d += 1\\n                node = node.right\\n            return d\\n        \\n        ld = depthLeft(root.left)\\n        rd = depthRight(root.right)\\n        \\n        if ld == rd:\\n            return 2**(ld + 1) - 1\\n        else:\\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62043,
                "title": "simple-java-solution-o-log-n-2-108-ms-with-explanation",
                "content": "    public class Solution {\\n        public int countNodes(TreeNode root) {\\n            return root == null ? 0 : findLastIndex(root, 1);\\n        }\\n        private int lHeight(TreeNode node, int count) {\\n            return node == null ? count - 1 : lHeight(node.left, count + 1);\\n        }\\n        private int findLastIndex(TreeNode node, int currIndex) {\\n            if (node.left == null && node.right == null) return currIndex;\\n            if (lHeight(node.left, 1) == lHeight(node.right, 1))\\n                return findLastIndex(node.right, currIndex * 2 + 1);\\n            else return findLastIndex(node.left, currIndex * 2);\\n        }\\n    }\\n\\nBefore understanding my solution, I'm gonna explain what does \"index\" mean in this solution.<br><br>\\nIf we mark the tree nodes from left to right, top to bottom with increasing integers, starting with 1, then let's call this number \"Index\". There are some properties of it:<br>\\n(1) The largest index is the answer we want. It equals to the number of nodes.<br>\\n(2) Since it's complete binary tree, for a node with index x, the left child, if exist, has index `2 * x`. The right child, if exist, has index `2 * x + 1`.<br><br>\\n\\nSo in this solution, I'm trying to \"walk\" to the node with largest index starting from the root, which has index  `1`. Let's denote the height of left child tree is `lH`, the height of right child tree is `rH`:<br>\\n(1) if `lH == rH`, meaning left child tree is a full tree, the last node must be in the right child tree. So we move to the right child node.<br>\\n(2) Otherwise, the last node must be in the left child tree, so we move to the left.<br>\\n\\nSo by \"tracing\" the node with largest index, we can find the answer. <br><br>\\n\\nTime complexity:<br>Because the total number of steps equals to the height of the tree `h`, at each step, calculating the height will cost time `O(h - current step)` so the time complexity is `h + (h - 1) + (h - 2) + ... + 1 = O(h^2) = O(log(n)^2)`.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int countNodes(TreeNode root) {\\n            return root == null ? 0 : findLastIndex(root, 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62124,
                "title": "concise-java-iterative-solution-o-logn-2",
                "content": "Using the intrinsic property of binary tree to do a binary search. The image shows the meaning of variables in my code. In each loop, if the the total tree is complete, we add all the nodes and stop. If the left subtree is incomplete, add all nodes in the right subtree (plus the parent node) and let the left subtree be the new tree. If the left subtree is complete, add all nodes in the left subtree (plus the parent node) and let the right  subtree be the new tree. The out loop run at most O(logn) and the inner loops for finding depths are also O(logn). So the total running time is O((logn)^2).\\n\\n![][1]\\n\\n      public int countNodes(TreeNode root) {\\n            int sum = 0;\\n    \\n            while (root != null) {\\n                int llh = leftDepth(root.left);\\n                int lrh = rightDepth(root.left);\\n                int rrh = rightDepth(root.right);\\n                if (llh == rrh) {\\n                    sum += (1 << llh + 1) - 1;\\n                    break;\\n                } else if (llh > lrh) {\\n                    sum += 1 << rrh;\\n                    root = root.left;\\n                } else {\\n                    sum += 1 << llh;\\n                    root = root.right;\\n                }\\n            }\\n            return sum;\\n        }\\n    \\n        public int leftDepth(TreeNode root) {\\n            int h = 0;\\n            while (root != null) {\\n                root = root.left;\\n                h++;\\n            }\\n            return h;\\n        }\\n    \\n        public int rightDepth(TreeNode root) {\\n            int h = 0;\\n            while (root != null) {\\n                root = root.right;\\n                h++;\\n            }\\n            return h;\\n        }\\n\\n\\n  [1]: http://i57.tinypic.com/mucgm.jpg",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "Using the intrinsic property of binary tree to do a binary search. The image shows the meaning of variables in my code. In each loop, if the the total tree is complete, we add all the nodes and stop. If the left subtree is incomplete, add all nodes in the right subtree (plus the parent node) and let the left subtree be the new tree. If the left subtree is complete, add all nodes in the left subtree (plus the parent node) and let the right  subtree be the new tree. The out loop run at most O(logn) and the inner loops for finding depths are also O(logn). So the total running time is O((logn)^2).\\n\\n![][1]\\n\\n      public int countNodes(TreeNode root) {\\n            int sum = 0;\\n    \\n            while (root != null) {\\n                int llh = leftDepth(root.left);\\n                int lrh = rightDepth(root.left);\\n                int rrh = rightDepth(root.right);\\n                if (llh == rrh) {\\n                    sum += (1 << llh + 1) - 1;\\n                    break;\\n                } else if (llh > lrh) {\\n                    sum += 1 << rrh;\\n                    root = root.left;\\n                } else {\\n                    sum += 1 << llh;\\n                    root = root.right;\\n                }\\n            }\\n            return sum;\\n        }\\n    \\n        public int leftDepth(TreeNode root) {\\n            int h = 0;\\n            while (root != null) {\\n                root = root.left;\\n                h++;\\n            }\\n            return h;\\n        }\\n    \\n        public int rightDepth(TreeNode root) {\\n            int h = 0;\\n            while (root != null) {\\n                root = root.right;\\n                h++;\\n            }\\n            return h;\\n        }\\n\\n\\n  [1]: http://i57.tinypic.com/mucgm.jpg",
                "codeTag": "Unknown"
            },
            {
                "id": 1537986,
                "title": "java-better-than-o-n-approach-log-n-log-n",
                "content": "**Idea**\\nWe are taking help of **Full Binary Tree**\\nFor calculating the height of the full binary tree, the formula is **[pow(2,height)-1]**\\n\\nFirst count height of left and right side of a tree and check ->\\nif they both have the same value that mean this is Full Binary Tree then we can calulate total number nodes by formula \\n**2*((int)Math.pow(2,value)-1)+1**  (for full left tree  and full right tree and plus 1 for the root ) and return it!!\\nelse recurse it again for its left and right nodes untill it ends!!!\\n\\n**Time Complexity**\\nO(log(n)log(m))\\nlog(n) for calculating the height and log(m) for how many times we are calculating the height since it may reach to leaf nodes in worst case!!!\\n\\n````\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        \\n        if(root==null)\\n            return 0;\\n        int lef=0,rig=0;\\n        TreeNode tmp=root;\\n        while(tmp.left!=null) {\\n\\t\\t\\n            tmp=tmp.left;\\n            lef++;\\n        }\\n        tmp=root;\\n        while(tmp.right!=null){\\n\\t\\t\\n            tmp=tmp.right;\\n            rig++;\\n        }\\n        if(lef==rig)\\n            return 2*((int)Math.pow(2,lef)-1)+1;\\n        return countNodes(root.left)+countNodes(root.right)+1;\\n    }\\n}\\n````\\n\\nIf this post was **helpful** then please  **upvote**  it :))",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        \\n        if(root==null)\\n            return 0;\\n        int lef=0,rig=0;\\n        TreeNode tmp=root;\\n        while(tmp.left!=null) {\\n\\t\\t\\n            tmp=tmp.left;\\n            lef++;\\n        }\\n        tmp=root;\\n        while(tmp.right!=null){\\n\\t\\t\\n            tmp=tmp.right;\\n            rig++;\\n        }\\n        if(lef==rig)\\n            return 2*((int)Math.pow(2,lef)-1)+1;\\n        return countNodes(root.left)+countNodes(root.right)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533887,
                "title": "python-java-c-by-binary-search-w-visualization",
                "content": "O( h * log n  ) = O( log n * log n ) = O( (log n)^2 ) sol by binary search.\\n\\n---\\n\\n**Hint**:\\n\\n**Complete tree** is **leftward compact**.\\n\\nNumbe each node start on root, with 1, 2, 3, ... and so on\\n\\nThen carry out **binary search** to locate the **last existing node** on **the last level**.\\n\\nThe number of last existing node also is the counting of total nodes in complete binary tree. \\n\\n---\\n\\n**Diagram and abstract model**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583731808.png)\\n\\n---\\n\\n**implementation** by recursion:\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n\\n        def get_tree_height( node: TreeNode) -> int:\\n            \\n            if not node:\\n                # base case\\n                return 0\\n            \\n            else:\\n                # general case\\n                return 1 + get_tree_height( node.left )\\n            \\n        # -----------------------------------------------\\n        \\n        def counting( node: TreeNode ) -> int:\\n            \\n            h = get_tree_height( node )\\n            \\n            if h == 0:\\n                # base case (with empty tree)\\n                return 0\\n            \\n            else:\\n                # general case\\n                if (h - 1) == get_tree_height( node.right ):\\n                    \\n                    # left subtree and right subtree are of the same height\\n                    # last node is on the right subtree\\n                    return 2 ** (h - 1) + counting( node.right )\\n                \\n                else:\\n                    # left subtree is higher than right subtree\\n                    # last node is on the left subtree\\n                    return 2 ** (h - 2) + counting( node.left )\\n        \\n        # -----------------------------------------------\\n        return counting(root)\\n```\\n\\n---\\n\\n**Java**:\\n\\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n    \\n        int h = countTreeHeight( root );\\n        \\n        if( h == 0 ){\\n            return 0;\\n        }\\n        \\n \\n        if( countTreeHeight(root.right) == (h-1) ){\\n            \\n            // left subtree and right subtree are of the same height\\n            // last node is on the right subtree\\n            \\n            return (1 << (h-1)) + countNodes(root.right); \\n            \\n        }else{\\n            \\n            // left subtree is higher than right subtree\\n            // last node is on the left subtree\\n            \\n            return (1 << (h-2)) + countNodes(root.left); \\n        }\\n        \\n    }\\n```\\n\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n    \\n        int h = countTreeHeight( root );\\n        \\n        if( h == 0 ){\\n            return 0;\\n        }\\n        \\n \\n        if( countTreeHeight(root->right) == (h-1) ){\\n            \\n            // left subtree and right subtree are of the same height\\n            // last node is on the right subtree\\n            \\n            return (1 << (h-1)) + countNodes(root->right); \\n            \\n        }else{\\n            \\n            // left subtree is higher than right subtree\\n            // last node is on the left subtree\\n            \\n            return (1 << (h-2)) + countNodes(root->left); \\n        }\\n        \\n    }\\n    \\n    // ---------------------------------------------\\n    inline int countTreeHeight( TreeNode* node){\\n        \\n        if( node == nullptr ){\\n            return 0;\\n        }\\n        \\n        return 1 + countTreeHeight( node->left );\\n        \\n    }\\n\\n};\\n```\\n\\n---\\n**Implementation** by iteration:\\n\\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        \\n        \\n        def helper( node: TreeNode):\\n            \\n            root = node\\n            \\n            if not node:\\n                \\n                # Quick response for empty tree\\n                return 0\\n            \\n            \\n            height = 0\\n            while node:\\n                node = node.left\\n                height += 1\\n            \\n            \\n            if height == 1:\\n                \\n                # Quick response for tree with one level only\\n                return 1\\n            \\n            \\n            # boundary of node numbering on last level\\n            \\n            left, right = 2 ** (height - 1), (2 ** height - 1)\\n            \\n            # For complete binary tree, the leftmost node on last level must exist\\n            \\n            last_exist = left\\n            \\n            \\n            # Launch binary search to find the numbering of last non-empty node on last level\\n            \\n            while left <= right:\\n                cur = root\\n                mid = left + (right-left) // 2\\n                \\n                # path finding for node with numbering with mid\\n                for h in range(height-2, -1, -1):\\n                    \\n                    mask =  1 << h\\n                    \\n                    if mid & mask :\\n                        cur = cur.right\\n                        \\n                    else:\\n                        cur = cur.left\\n                    \\n                    mask >>= 1\\n                    \\n                if cur is not None:\\n                    # update latest finding on last level\\n                    last_exist = mid\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n                    \\n            return last_exist\\n        \\n        # -------------------------------\\n        \\n        return helper( root )\\n```\\n\\n---\\n\\nExtra sharing of O( n ) algorithm\\n\\n**Implementation** by DFS and simple node counting:\\n\\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        \\n        def counting( node: TreeNode ) -> int:\\n            \\n            if not node:\\n                return 0\\n            \\n            else:\\n                return counting( node.left ) + counting( node.right ) + 1\\n            \\n        # -----------------------------------------------------------\\n        \\n        return counting( root )\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #958 Check Completeness of a Binary Tree](https://leetcode.com/problems/check-completeness-of-a-binary-tree/)\\n\\n[Leetcode #919 Complete Binary Tree Inserter](https://leetcode.com/problems/complete-binary-tree-inserter/)\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Complete binary tree](https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)\\n\\n[2] [GfG: Complete binary tree](https://bit.ly/3aFrrYQ)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n\\n        def get_tree_height( node: TreeNode) -> int:\\n            \\n            if not node:\\n                # base case\\n                return 0\\n            \\n            else:\\n                # general case\\n                return 1 + get_tree_height( node.left )\\n            \\n        # -----------------------------------------------\\n        \\n        def counting( node: TreeNode ) -> int:\\n            \\n            h = get_tree_height( node )\\n            \\n            if h == 0:\\n                # base case (with empty tree)\\n                return 0\\n            \\n            else:\\n                # general case\\n                if (h - 1) == get_tree_height( node.right ):\\n                    \\n                    # left subtree and right subtree are of the same height\\n                    # last node is on the right subtree\\n                    return 2 ** (h - 1) + counting( node.right )\\n                \\n                else:\\n                    # left subtree is higher than right subtree\\n                    # last node is on the left subtree\\n                    return 2 ** (h - 2) + counting( node.left )\\n        \\n        # -----------------------------------------------\\n        return counting(root)\\n```\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n    \\n        int h = countTreeHeight( root );\\n        \\n        if( h == 0 ){\\n            return 0;\\n        }\\n        \\n \\n        if( countTreeHeight(root.right) == (h-1) ){\\n            \\n            // left subtree and right subtree are of the same height\\n            // last node is on the right subtree\\n            \\n            return (1 << (h-1)) + countNodes(root.right); \\n            \\n        }else{\\n            \\n            // left subtree is higher than right subtree\\n            // last node is on the left subtree\\n            \\n            return (1 << (h-2)) + countNodes(root.left); \\n        }\\n        \\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n    \\n        int h = countTreeHeight( root );\\n        \\n        if( h == 0 ){\\n            return 0;\\n        }\\n        \\n \\n        if( countTreeHeight(root->right) == (h-1) ){\\n            \\n            // left subtree and right subtree are of the same height\\n            // last node is on the right subtree\\n            \\n            return (1 << (h-1)) + countNodes(root->right); \\n            \\n        }else{\\n            \\n            // left subtree is higher than right subtree\\n            // last node is on the left subtree\\n            \\n            return (1 << (h-2)) + countNodes(root->left); \\n        }\\n        \\n    }\\n    \\n    // ---------------------------------------------\\n    inline int countTreeHeight( TreeNode* node){\\n        \\n        if( node == nullptr ){\\n            return 0;\\n        }\\n        \\n        return 1 + countTreeHeight( node->left );\\n        \\n    }\\n\\n};\\n```\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        \\n        \\n        def helper( node: TreeNode):\\n            \\n            root = node\\n            \\n            if not node:\\n                \\n                # Quick response for empty tree\\n                return 0\\n            \\n            \\n            height = 0\\n            while node:\\n                node = node.left\\n                height += 1\\n            \\n            \\n            if height == 1:\\n                \\n                # Quick response for tree with one level only\\n                return 1\\n            \\n            \\n            # boundary of node numbering on last level\\n            \\n            left, right = 2 ** (height - 1), (2 ** height - 1)\\n            \\n            # For complete binary tree, the leftmost node on last level must exist\\n            \\n            last_exist = left\\n            \\n            \\n            # Launch binary search to find the numbering of last non-empty node on last level\\n            \\n            while left <= right:\\n                cur = root\\n                mid = left + (right-left) // 2\\n                \\n                # path finding for node with numbering with mid\\n                for h in range(height-2, -1, -1):\\n                    \\n                    mask =  1 << h\\n                    \\n                    if mid & mask :\\n                        cur = cur.right\\n                        \\n                    else:\\n                        cur = cur.left\\n                    \\n                    mask >>= 1\\n                    \\n                if cur is not None:\\n                    # update latest finding on last level\\n                    last_exist = mid\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n                    \\n            return last_exist\\n        \\n        # -------------------------------\\n        \\n        return helper( root )\\n```\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        \\n        def counting( node: TreeNode ) -> int:\\n            \\n            if not node:\\n                return 0\\n            \\n            else:\\n                return counting( node.left ) + counting( node.right ) + 1\\n            \\n        # -----------------------------------------------------------\\n        \\n        return counting( root )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62002,
                "title": "clean-python-code",
                "content": "    class Solution(object):\\n        def getHeight(self, root):\\n            height = 0\\n            while root:\\n                height += 1\\n                root = root.left\\n            return height\\n    \\n        def countNodes(self, root):\\n            count = 0\\n            while root:\\n                l, r = map(self.getHeight, (root.left, root.right))\\n                if l == r:\\n                    count += 2 ** l\\n                    root = root.right\\n                else:\\n                    count += 2 ** r\\n                    root = root.left\\n            return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def getHeight(self, root):\\n            height = 0\\n            while root:\\n                height += 1\\n                root = root.left\\n            return height\\n    \\n        def countNodes(self, root):\\n            count = 0\\n            while root:\\n                l, r = map(self.getHeight, (root.left, root.right))\\n                if l == r:\\n                    count += 2 ** l\\n                    root = root.right\\n                else:\\n                    count += 2 ** r\\n                    root = root.left\\n            return count",
                "codeTag": "Java"
            },
            {
                "id": 2815625,
                "title": "java-3-liner-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511439,
                "title": "count-complete-tree-nodes-c-optimal-solution-easy-to-understand",
                "content": "**Using Recursion :-**\\n\\n\\t\\t class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countNodes(TreeNode* root) {\\n\\t\\t\\t\\tif(root==NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn countNodes(root->left)+countNodes(root->right)+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\nTime Complexity :- O(N)\\nSpace Complexity :- O(N)\\n\\n**Optimal Solution :-**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\n\\t\\tint countNodes(TreeNode* root) {\\n\\t\\t\\tint lh=0,rh=0;\\n\\t\\t\\tTreeNode* curr=root;\\n\\t\\t\\twhile(curr!= NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlh++;\\n\\t\\t\\t\\tcurr=curr->left;\\n\\t\\t\\t}\\n\\t\\t   curr=root;\\n        \\n        while(curr!= NULL)\\n        {\\n            rh++;\\n            curr=curr->right;\\n        }\\n        if(lh==rh)\\n        {\\n            return pow(2,lh)-1;\\n        }\\n        else\\n        {\\n            return countNodes(root->left)+countNodes(root->right)+1;\\n        }\\n     }\\n    };\\n\\t\\nTime Complexity :- O( (logN)^2 )\\nSpace Complexity :- O(LogN)\\n\\n**Properties** :-\\nA complete binary tree has (2^n \\u2013 1) nodes in total.\\n\\n\\n**if you like this solution. so please upvoted.**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countNodes(TreeNode* root) {\\n\\t\\t\\t\\tif(root==NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 62070,
                "title": "72-ms-c-solution",
                "content": "calculate height of right tree, if the same as height, go to right tree(append 1 to binary result), otherwise go to left tree (Append 0 to binary result)\\n\\n    int countNodes(TreeNode* root)\\n    {\\n        int result,height,RTreeHeight;\\n        TreeNode* visit,*p;\\n    \\n        if (root==NULL) return 0;\\n    \\n        p = visit = root;\\n        height = 0;\\n        for(;p;p = p -> left) height++;\\n        result = 1;\\n        \\n        while(--height)\\n        {\\n            result <<= 1;\\n            \\n            RTreeHeight = 0;\\n            p = visit->right;\\n            for(;p;p = p -> left) RTreeHeight++;\\n            \\n            if (RTreeHeight < height) visit = visit->left;\\n            else\\n            {\\n                result |= 1;\\n                visit = visit->right;\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "calculate height of right tree, if the same as height, go to right tree(append 1 to binary result), otherwise go to left tree (Append 0 to binary result)\\n\\n    int countNodes(TreeNode* root)\\n    {\\n        int result,height,RTreeHeight;\\n        TreeNode* visit,*p;\\n    \\n        if (root==NULL) return 0;\\n    \\n        p = visit = root;\\n        height = 0;\\n        for(;p;p = p -> left) height++;\\n        result = 1;\\n        \\n        while(--height)\\n        {\\n            result <<= 1;\\n            \\n            RTreeHeight = 0;\\n            p = visit->right;\\n            for(;p;p = p -> left) RTreeHeight++;\\n            \\n            if (RTreeHeight < height) visit = visit->left;\\n            else\\n            {\\n                result |= 1;\\n                visit = visit->right;\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2816040,
                "title": "simple-observation-based-solution-o-log-n-log-n-beats-93",
                "content": "My logic is when we are in a current node... We can see we have 2 cases for SUBTREE heights:\\nA. if both lh(left subtree height)  == rh(right subtree height)\\nB. lh > rh \\n\\nfor A we go to the right as we can observe that we have inequality on the RIGHT\\nand for B we go the the left as we observe we can have inequality on the LEFT \\n\\nONLY base case is if rh == 0 then there are two cases (SEE CODE :)\\n\\nThe trick part is to take care on how many nodes we have covered till now.. We can use \"CUR\":\\nand can use the property that left  = (2xCUR) and right = (2xCUR + 1)... \\n\\nand rest is as it is..\\n\\n```\\nint ans;\\nclass Solution {\\n    int height(TreeNode *root){\\n        if(root == NULL) return 0;\\n        int h = 1;\\n        int lh = height(root->left), rh = height(root->right);\\n        h += max(lh, rh);\\n        return h;\\n    }\\npublic:\\n    int countNodes(TreeNode* root, int cur = 1) {\\n        ans = 0;\\n        if(root == NULL) return 0;\\n        int lh = height(root->left), rh = height(root->right);\\n        if(rh == 0)\\n            if(root->left != NULL) ans = cur*2;\\n            else ans = cur;\\n        else\\n            if(lh == rh) countNodes(root->right, cur*2 + 1);\\n            else countNodes(root->left, cur*2);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**EDIT :**\\n\\nAs pointed out by **@user1132rN**  the above code can be optimized by calculating height in a better way. Actually, I was very happy to find this logic on my own that I didn\\'t thought about the height code much.. \\nThank You to @user1132rN.\\n\\nSo the code finally becomes:\\n\\n```\\nint ans;\\nclass Solution {\\n    int height(TreeNode *root){\\n        if(root == NULL) return 0;\\n        int h = 1;\\n        while(root->left){            // OPTIMISED HEIGHT CALCULATION BCOZ \\n            root = root->left; h++;   // OF THE \"COMPLETE BINARY TREE PROPERTY\"\\n\\t\\t}                             // Credit:  @user1132rN\\n        return h;\\n    }\\npublic:\\n    int countNodes(TreeNode* root, int cur = 1) {\\n        ans = 0;\\n        if(root == NULL) return 0;\\n        int lh = height(root->left), rh = height(root->right);\\n        if(rh == 0)\\n            if(root->left != NULL) ans = cur*2;\\n            else ans = cur;\\n        else\\n            if(lh == rh) countNodes(root->right, cur*2 + 1);\\n            else countNodes(root->left, cur*2);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE if Found helpful :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint ans;\\nclass Solution {\\n    int height(TreeNode *root){\\n        if(root == NULL) return 0;\\n        int h = 1;\\n        int lh = height(root->left), rh = height(root->right);\\n        h += max(lh, rh);\\n        return h;\\n    }\\npublic:\\n    int countNodes(TreeNode* root, int cur = 1) {\\n        ans = 0;\\n        if(root == NULL) return 0;\\n        int lh = height(root->left), rh = height(root->right);\\n        if(rh == 0)\\n            if(root->left != NULL) ans = cur*2;\\n            else ans = cur;\\n        else\\n            if(lh == rh) countNodes(root->right, cur*2 + 1);\\n            else countNodes(root->left, cur*2);\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nint ans;\\nclass Solution {\\n    int height(TreeNode *root){\\n        if(root == NULL) return 0;\\n        int h = 1;\\n        while(root->left){            // OPTIMISED HEIGHT CALCULATION BCOZ \\n            root = root->left; h++;   // OF THE \"COMPLETE BINARY TREE PROPERTY\"\\n\\t\\t}                             // Credit:  @user1132rN\\n        return h;\\n    }\\npublic:\\n    int countNodes(TreeNode* root, int cur = 1) {\\n        ans = 0;\\n        if(root == NULL) return 0;\\n        int lh = height(root->left), rh = height(root->right);\\n        if(rh == 0)\\n            if(root->left != NULL) ans = cur*2;\\n            else ans = cur;\\n        else\\n            if(lh == rh) countNodes(root->right, cur*2 + 1);\\n            else countNodes(root->left, cur*2);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816121,
                "title": "2-line-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if(root==None):\\n            return 0\\n        return(self.countNodes(root.left)+self.countNodes(root.right)+1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if(root==None):\\n            return 0\\n        return(self.countNodes(root.left)+self.countNodes(root.right)+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122684,
                "title": "clean-python-solution-o-log-2-n-time",
                "content": "```\\n\\'\\'\\' \\nOnly traversing along the left and right boundary. \\nIf both left and right height are equal then\\nthe bottom level would be full from left to right and total no. of nodes in that subtree\\nis 2^h - 1. \\n\\nIf left and right height are not equal then add +1 for current root and go to left child \\nand right child. \\n\\'\\'\\'\\n\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root: return 0\\n        \\n        leftHeight = self.getLeftHeight(root)\\n        rightHeight = self.getRightHeight(root)\\n        \\n        if leftHeight == rightHeight: \\n            return 2 ** leftHeight - 1\\n        else:\\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)         \\n        \\n    \\n    def getLeftHeight(self, node):\\n        height = 0\\n        while node:\\n            height += 1\\n            node = node.left\\n        return height\\n    \\n    def getRightHeight(self, node):\\n        height = 0\\n        while node:\\n            height += 1\\n            node = node.right\\n        return height\\n    \\n# Height = H = log(n) where n = total number of nodes\\n# Time: O(H * H) = O(log(n)^2) = O(Log^2 n)\\n# Auxiliary Space: O(H) = O(log(n))\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\'\\'\\' \\nOnly traversing along the left and right boundary. \\nIf both left and right height are equal then\\nthe bottom level would be full from left to right and total no. of nodes in that subtree\\nis 2^h - 1. \\n\\nIf left and right height are not equal then add +1 for current root and go to left child \\nand right child. \\n\\'\\'\\'\\n\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root: return 0\\n        \\n        leftHeight = self.getLeftHeight(root)\\n        rightHeight = self.getRightHeight(root)\\n        \\n        if leftHeight == rightHeight: \\n            return 2 ** leftHeight - 1\\n        else:\\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)         \\n        \\n    \\n    def getLeftHeight(self, node):\\n        height = 0\\n        while node:\\n            height += 1\\n            node = node.left\\n        return height\\n    \\n    def getRightHeight(self, node):\\n        height = 0\\n        while node:\\n            height += 1\\n            node = node.right\\n        return height\\n    \\n# Height = H = log(n) where n = total number of nodes\\n# Time: O(H * H) = O(log(n)^2) = O(Log^2 n)\\n# Auxiliary Space: O(H) = O(log(n))\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 704112,
                "title": "javascript-clean-binary-search-o-logn-logn",
                "content": "Time Complexity = `O(logN * logN)`. Because at each step during the binary search we\\'re traversing  `logN` height. At end of each binary search step we\\'re discarding half the tree. \\n```javascript\\nvar countNodes = function(root) {\\n    \\n    function leftDepth(node) {\\n        if(!node) return 0;\\n        return leftDepth(node.left) + 1;\\n    }\\n    \\n    function rightDepth(node) {\\n        if(!node) return 0;\\n        return rightDepth(node.right) + 1;\\n    }\\n    \\n    function traverse(node) {\\n        const leftLen = leftDepth(node);\\n        const rightLen = rightDepth(node);\\n        \\n        if(leftLen === rightLen) return Math.pow(2, leftLen) - 1;\\n        return traverse(node.left) + traverse(node.right) + 1;\\n    }\\n    return traverse(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```javascript\\nvar countNodes = function(root) {\\n    \\n    function leftDepth(node) {\\n        if(!node) return 0;\\n        return leftDepth(node.left) + 1;\\n    }\\n    \\n    function rightDepth(node) {\\n        if(!node) return 0;\\n        return rightDepth(node.right) + 1;\\n    }\\n    \\n    function traverse(node) {\\n        const leftLen = leftDepth(node);\\n        const rightLen = rightDepth(node);\\n        \\n        if(leftLen === rightLen) return Math.pow(2, leftLen) - 1;\\n        return traverse(node.left) + traverse(node.right) + 1;\\n    }\\n    return traverse(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62053,
                "title": "7-line-clean-c-solution-recursive-116ms",
                "content": "The solution is based on the characteristics of full and complete binary trees: if the rightmost leaf is at the same level of leftmost leaf, this is a full tree; and the number of nodes of a full tree is 2^h-1.  Otherwise, count left and sub trees separately.\\n\\n\\n    typedef struct TreeNode tn;\\n    int countNodes(tn* root)\\n    {\\n      /* get left depth and right depth */\\n      tn *pL = root, *pR = root;\\n      int dep = 0;\\n      for(; pL && pR; dep++)\\n      {\\n        pL = pL->left;\\n        pR = pR->right;\\n      }\\n      \\n      /* count the full tree collectively */\\n      if(!pL && !pR) return (1<<dep) -1;\\n    \\n      /* count left and right sub-trees separately */\\n      return countNodes(root->left) + 1 + countNodes(root->right);\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "The solution is based on the characteristics of full and complete binary trees: if the rightmost leaf is at the same level of leftmost leaf, this is a full tree; and the number of nodes of a full tree is 2^h-1.  Otherwise, count left and sub trees separately.\\n\\n\\n    typedef struct TreeNode tn;\\n    int countNodes(tn* root)\\n    {\\n      /* get left depth and right depth */\\n      tn *pL = root, *pR = root;\\n      int dep = 0;\\n      for(; pL && pR; dep++)\\n      {\\n        pL = pL->left;\\n        pR = pR->right;\\n      }\\n      \\n      /* count the full tree collectively */\\n      if(!pL && !pR) return (1<<dep) -1;\\n    \\n      /* count left and right sub-trees separately */\\n      return countNodes(root->left) + 1 + countNodes(root->right);\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 61977,
                "title": "accepted-clean-java-solution",
                "content": "The idea is simple, if the height of left sub tree is the same to the right sub tree, we know that left sub tree is a full binary tree, so the total count of the nodes in left sub tree plus the root node is 2^h where h is the height of left sub tree, then we just need to count the nodes in right sub tree. \\n\\nThe bit manipulation in this code is doing the calculation of 2^h.\\n\\n    public class Solution {\\n    \\n      public int countNodes(TreeNode root) {\\n        if (root == null)\\n          return 0;\\n                \\n        int hLeft = getHeight(root.left);\\n        int hRight = getHeight(root.right);\\n            \\n        if (hLeft == hRight)\\n          return (1 << hLeft) + countNodes(root.right);\\n        else\\n          return (1 << hRight) + countNodes(root.left);\\n        \\n      }\\n        \\n      int getHeight(TreeNode root) {\\n        if (root == null)\\n          return 0;\\n            \\n        return 1 + getHeight(root.left);\\n      }\\n    \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n      public int countNodes(TreeNode root) {\\n        if (root == null)\\n          return 0;\\n                \\n        int hLeft = getHeight(root.left);\\n        int hRight = getHeight(root.right);\\n            \\n        if (hLeft == hRight)\\n          return (1 << hLeft) + countNodes(root.right);\\n        else\\n          return (1 << hRight) + countNodes(root.left);\\n        \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2816474,
                "title": "java-easy-to-understand-with-comments-beats-100",
                "content": "*Upvote if you like :D*\\n```\\nclass Solution {\\n     //function to find depth of tree on left side\\n    int leftDepth(TreeNode node){\\n        int depth=0;\\n        while(node!=null){\\n            node=node.left;\\n            depth++;\\n        }\\n        return depth;\\n    }\\n    \\n    //function to find depth of tree on right side\\n    int rightDepth(TreeNode node){\\n        int depth=0;\\n        while(node!=null){\\n            node=node.right;\\n            depth++;\\n        }\\n        return depth;\\n    }\\n    \\n    //main function\\n    public int countNodes(TreeNode root) {\\n        \\n        int left=leftDepth(root);\\n        int right=rightDepth(root);\\n        \\n        //if both the leftmost and right most depth are equal that means\\n\\t\\t//its perfect tree so no. of nodes would be 2^h-1\\n        if(left==right){\\n            return (int)Math.pow(2,left)-1;\\n        }\\n        //otherwise it will call count function for left and right subtrees\\n\\t\\t//and add 1 for root node\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n     //function to find depth of tree on left side\\n    int leftDepth(TreeNode node){\\n        int depth=0;\\n        while(node!=null){\\n            node=node.left;\\n            depth++;\\n        }\\n        return depth;\\n    }\\n    \\n    //function to find depth of tree on right side\\n    int rightDepth(TreeNode node){\\n        int depth=0;\\n        while(node!=null){\\n            node=node.right;\\n            depth++;\\n        }\\n        return depth;\\n    }\\n    \\n    //main function\\n    public int countNodes(TreeNode root) {\\n        \\n        int left=leftDepth(root);\\n        int right=rightDepth(root);\\n        \\n        //if both the leftmost and right most depth are equal that means\\n\\t\\t//its perfect tree so no. of nodes would be 2^h-1\\n        if(left==right){\\n            return (int)Math.pow(2,left)-1;\\n        }\\n        //otherwise it will call count function for left and right subtrees\\n\\t\\t//and add 1 for root node\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816018,
                "title": "less-than-n-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe complete proof of complexity goes as follows:\\n\\n1:-Determining the height of each node is O(logN) time complexity (just go all the way down both to the left and to the right, with no branching).\\n2:-When performing DFS, we consider two child nodes. At least one of them is a full tree (think why). Thus in the worst case, we\\'ll only have to continue exploring another one. So on the 1st level, we explore just 1 node out of 2. The same is true for the 2nd level and so on until we explore O(logN) nodes, 1 node on each level.\\n3:-Having O(logN) nodes explored with DFS, each taking O(logN) steps to determine height, results in the overall O(logN*logN) complexity.\\n\\n# Complexity\\n- Time complexity:\\n*Less Than N*\\n\\n- Space complexity:\\n*O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        int left=0,right=0;\\n        TreeNode* curr=root;\\n        while(curr!=NULL){\\n            left++;\\n            curr=curr->left;\\n        }\\n        curr=root;\\n        while(curr!=NULL){\\n            right++;\\n            curr=curr->right;\\n        }\\n        if(left==right)\\n            return pow(2,left)-1;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Indexed Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        int left=0,right=0;\\n        TreeNode* curr=root;\\n        while(curr!=NULL){\\n            left++;\\n            curr=curr->left;\\n        }\\n        curr=root;\\n        while(curr!=NULL){\\n            right++;\\n            curr=curr->right;\\n        }\\n        if(left==right)\\n            return pow(2,left)-1;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62026,
                "title": "o-logn-logn-c-implementation",
                "content": "Thanks to the post from @victorlee.\\n\\nIn each level, we count the left-most-depth and right-most-depth.  \\n\\n          if  #l == #r   2^l-1\\n          else  1+count(left)+count(right)\\n\\nHere is the AC c++ implementation\\n\\n    class Solution {\\n    public:\\n        int countNodes(TreeNode* root) {\\n            if(!root)  return 0;\\n            int hl=0, hr=0;\\n            TreeNode *l=root, *r=root;\\n            while(l) { hl++; l=l->left; }\\n            while(r) { hr++; r=r->right; }\\n            \\n            if(hl==hr) return pow(2, hl)-1;\\n            return 1+countNodes(root->left)+countNodes(root->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int countNodes(TreeNode* root) {\\n            if(!root)  return 0;\\n            int hl=0, hr=0;\\n            TreeNode *l=root, *r=root;\\n            while(l) { hl++; l=l->left; }",
                "codeTag": "Java"
            },
            {
                "id": 2815487,
                "title": "most-easy-c-solution-beginner-friendly",
                "content": "**Please Upvote if you like the solution**\\n\\nSolution 1 : O(n) Solution\\n\\n* In this solution i am basically counting every node by visiting every Node\\n\\nclass Solution {\\npublic:\\n\\n    int countNodes(TreeNode* root) {\\n        if(root == NULL) {\\n            return 0;\\n        }\\n        int a = countNodes(root->left);\\n        int b = countNodes(root->right);\\n        return a+b+1;\\n    }\\n};\\n\\nSolution 2 : Efficient Solution\\n*  Here we are calculating the height of left and right side of complete binary tree of they are equal then we are calculating the nodes by formulla else we are counting every node this we are doing recursively for every node\\n\\nclass Solution {\\npublic:\\n\\n    int countNodes(TreeNode* root) {\\n        if(root == NULL) {\\n            return 0;\\n        }\\n        int left = 0, right = 0;\\n        TreeNode *leftNode = root, *rightNode = root;\\n        while(leftNode != NULL) {\\n            left++;\\n            leftNode = leftNode->left;\\n        }\\n        \\n        while(rightNode != NULL) {\\n            right++;\\n            rightNode = rightNode->right;\\n        }\\n        \\n        if(left == right) {\\n            return pow(2,right) - 1;\\n        }\\n        \\n        return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countNodes(TreeNode* root) {\\n        if(root == NULL) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1939545,
                "title": "c-o-log-n-2-solution-with-proper-explanation",
                "content": "**Approach:-This is the Efficient approach than simple BFS or DFS.**\\n-->This Work in O(logn*logn) time.\\n-->**Concept use:-For Any Perfect Binary Tree which have \\'l\\' levels.\\nthen the total number of nodes= pow(2,l)-1.**\\n-->As We know A Complete Binary Tree is Perfect Binary Tree till 2nd Last Level.\\n\\n-->For Every root node We check wheather left_high of tree is equal to Right_hight or not.\\n-->If it is equal then we return pow(2,left_hight)-1;\\n\\n-->Otherwise we for evrery function call we increase node with +1 and send our function to check the Perefetness for root\\'s left and right.\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int left_hight=0,right_hight=0;\\n        TreeNode *ptr1=root,*ptr2=root;\\n        \\n        while(ptr1!=NULL) //Count the Left hight\\n            ptr1=ptr1->left,left_hight++;\\n        while(ptr2!=NULL) //Count the Right hight\\n            ptr2=ptr2->right,right_hight++;\\n        \\n        if(left_hight==right_hight)\\n            return pow(2,left_hight)-1;\\n        \\n        return 1+countNodes(root->left)+countNodes(root->right);\\n        \\n    }\\n};\\n```\\n*If you find it helpful. Please UPvote.*",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int left_hight=0,right_hight=0;\\n        TreeNode *ptr1=root,*ptr2=root;\\n        \\n        while(ptr1!=NULL) //Count the Left hight\\n            ptr1=ptr1->left,left_hight++;\\n        while(ptr2!=NULL) //Count the Right hight\\n            ptr2=ptr2->right,right_hight++;\\n        \\n        if(left_hight==right_hight)\\n            return pow(2,left_hight)-1;\\n        \\n        return 1+countNodes(root->left)+countNodes(root->right);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073501,
                "title": "java-binary-search-solution-w-detailed-comments",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countNodes(TreeNode root) {\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\tThe number of possible nodes: 2^(height+1) - 1\\n\\t\\t\\t\\tThe number of nodes on the last level: 2^(height)\\n\\n\\n\\t\\t\\t\\tThe height of the tree is 3\\n\\n\\t\\t\\t\\th:2 d:0            (1)\\n\\t\\t\\t\\t\\t\\t\\t\\t   /  \\\\\\n\\t\\t\\t\\th:1 d:1           5    4\\n\\t\\t\\t\\t\\t\\t\\t\\t / \\\\   /\\\\\\n\\t\\t\\t\\th:0 d:2          2  4  n n\\n\\t\\t\\t\\t\\t\\t\\t\\t[0  1  2 3]\\n\\n\\t\\t\\t\\tSince this is a complete tree (levels are filled from left-to-right), we can therefore\\n\\t\\t\\t\\tfind the height of the tree by just traversing the left-most branch \\n\\n\\t\\t\\t\\t\\t- height = 3\\n\\n\\t\\t\\t\\tWith this information, we can determine the maximum possible nodes for the given complete \\n\\t\\t\\t\\tbinary tree and the total number of possible nodes on the last level\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t- maximum possible = 2^(2+1) - 1 = 7\\n\\t\\t\\t\\t\\t- nodes on the last level = 2^(2) = 4\\n\\n\\t\\t\\t\\tTo find the number of missing nodes in the last level, we utilize binary search O(log n). \\n\\t\\t\\t\\tStarting at the head node, we need to determine whether to traverse left or traverse right subtree. \\n\\t\\t\\t\\tComparing the height of the left subtree and the right subtree will help us.\\n\\n\\t\\t\\t\\t\\t- height(root.left) = 1  \\n\\t\\t\\t\\t\\t- height(root.right) = 0\\n\\n\\t\\t\\t\\tWith this information, we can determine the right subtree is missing. We need to subtract the \\n\\t\\t\\t\\tnodes accordingly. The number of missing nodes can be determined by \\n\\n\\t\\t\\t\\t\\t- nodes on the last level - nodes on the last level of left subtree \\n\\n\\t\\t\\t\\t\\tWith move left: 4 - 2^(1) = 2\\n\\n\\t\\t\\t\\t\\t\\t   ->    1\\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t h:1  (5)  (4)  h:0\\n\\t\\t\\t\\t\\t\\t\\t  / \\\\  / \\\\\\n\\t\\t\\t\\t\\t\\t\\t  2  4  n n\\n\\t\\t\\t\\t\\t\\t\\t [0  1]\\n\\n\\n\\t\\t\\t\\tSince the right subtree is greater or equal to the left subtree height, we will move right \\n\\n\\n\\t\\t\\t\\t\\t\\t   ->    1\\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t h:1  (5)  (4)  h:0\\n\\t\\t\\t\\t\\t\\t\\t  / \\\\  / \\\\\\n\\t\\t\\t\\t\\t\\t\\t  2  4  n n\\n\\t\\t\\t\\t\\t\\t\\t\\t[1]\\n\\n\\t\\t\\t\\tWe have reached the last node\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t 1\\n\\t\\t\\t\\t\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t\\t\\t\\t\\t   5   4x \\n\\t\\t\\t\\t\\t\\t\\t  / \\\\\\n\\t\\t\\t\\t\\t\\t\\t 2 ->4 \\n\\n\\t\\t\\t\\treturn \\n\\t\\t\\t\\t\\t\\tthe total number of possible nodes \\n\\t\\t\\t\\t\\t\\t- \\n\\t\\t\\t\\t\\t\\tnumber of nodes possible on last level \\n\\t\\t\\t\\t\\t\\t+ \\n\\t\\t\\t\\t\\t\\tactual number of nodes\\n\\n\\n\\n\\t\\t\\t\\tALGORITHM\\n\\t\\t\\t\\t\\tStep 1: if the root is null, return 0\\n\\t\\t\\t\\t\\tStep 2: find the height of the current tree and calculate the max possible nodes\\n\\t\\t\\t\\t\\tStep 3: calculate the possible nodes on the last level\\n\\t\\t\\t\\t\\tStep 4: loop while the root node is not null\\n\\t\\t\\t\\t\\t\\t\\t-> calculcate the height of the right subtree\\n\\t\\t\\t\\t\\t\\t\\t-> calculate the height of the left subtree\\n\\t\\t\\t\\t\\t\\t\\t-> if the left subtree\\'s height is greater than the right subtree\\n\\t\\t\\t\\t\\t\\t\\t\\t-> calculate nodes missing for right side\\n\\t\\t\\t\\t\\t\\t\\t\\t-> update possible nodes on last level\\n\\t\\t\\t\\t\\t\\t\\t\\t-> move root to left subtree\\n\\t\\t\\t\\t\\t\\t\\t-> else move root to right subtree\\n\\t\\t\\t\\t\\t\\t\\t\\t-> move root to right subtree\\n\\t\\t\\t\\t\\tStep 5: return max possible nodes \\n\\t\\t\\t\\t\\t\\t\\t\\t- possible nodes on last levelnodes on last level\\n\\t\\t\\t\\t\\t\\t\\t\\t+ actual number of nodes\\n\\n\\t\\t\\t*/\\n\\n\\t\\t\\tif(root == null) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(root.left == null && root.right == null) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint height = getHeight(root, 0);\\n\\t\\t\\tint nodes = (int)Math.pow(2, height+1) - 1;\\n\\t\\t\\tint possibleNodesOnLastLevel = (int)Math.pow(2, height);\\n\\t\\t\\tint nodesOnLastLevel = (int)Math.pow(2, height);\\n\\n\\t\\t\\twhile(root != null) {\\n\\n\\t\\t\\t\\tint leftHeight = getHeight(root.left, 0);\\n\\t\\t\\t\\tint rightHeight = getHeight(root.right, 0);\\n\\n\\t\\t\\t\\tif(leftHeight > rightHeight) {\\n\\n\\t\\t\\t\\t\\tint nodesMissing = (int)Math.pow(2, leftHeight);\\n\\t\\t\\t\\t\\tnodesOnLastLevel = nodesOnLastLevel - nodesMissing;\\n\\t\\t\\t\\t\\troot = root.left; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse { \\n\\t\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn nodes - possibleNodesOnLastLevel + nodesOnLastLevel;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t\\tThis method will find the height of a complete binary tree in O(log n)\\n\\t\\t\\tThis method will return -1 if the passed complete binary tree is null\\n\\t\\t\\tOtherwise, it will return the height of the tree\\n\\t\\t*/  \\n\\t\\tpublic int getHeight(TreeNode root, int height) {\\n\\n\\t\\t\\tif(root == null) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(root.left == null && root.right == null) {\\n\\t\\t\\t\\treturn height;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn getHeight(root.left, height + 1);\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic int countNodes(TreeNode root) {\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\tThe number of possible nodes: 2^(height+1) - 1\\n\\t\\t\\t\\tThe number of nodes on the last level: 2^(height)\\n\\n\\n\\t\\t\\t\\tThe height of the tree is 3\\n\\n\\t\\t\\t\\th:2 d:0            (1)\\n\\t\\t\\t\\t\\t\\t\\t\\t   /  \\\\\\n\\t\\t\\t\\th:1 d:1           5    4\\n\\t\\t\\t\\t\\t\\t\\t\\t / \\\\   /\\\\\\n\\t\\t\\t\\th:0 d:2          2  4  n n\\n\\t\\t\\t\\t\\t\\t\\t\\t[0  1  2 3]\\n\\n\\t\\t\\t\\tSince this is a complete tree (levels are filled from left-to-right), we can therefore\\n\\t\\t\\t\\tfind the height of the tree by just traversing the left-most branch \\n\\n\\t\\t\\t\\t\\t- height = 3\\n\\n\\t\\t\\t\\tWith this information, we can determine the maximum possible nodes for the given complete \\n\\t\\t\\t\\tbinary tree and the total number of possible nodes on the last level\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t- maximum possible = 2^(2+1) - 1 = 7\\n\\t\\t\\t\\t\\t- nodes on the last level = 2^(2) = 4\\n\\n\\t\\t\\t\\tTo find the number of missing nodes in the last level, we utilize binary search O(log n). \\n\\t\\t\\t\\tStarting at the head node, we need to determine whether to traverse left or traverse right subtree. \\n\\t\\t\\t\\tComparing the height of the left subtree and the right subtree will help us.\\n\\n\\t\\t\\t\\t\\t- height(root.left) = 1  \\n\\t\\t\\t\\t\\t- height(root.right) = 0\\n\\n\\t\\t\\t\\tWith this information, we can determine the right subtree is missing. We need to subtract the \\n\\t\\t\\t\\tnodes accordingly. The number of missing nodes can be determined by \\n\\n\\t\\t\\t\\t\\t- nodes on the last level - nodes on the last level of left subtree \\n\\n\\t\\t\\t\\t\\tWith move left: 4 - 2^(1) = 2\\n\\n\\t\\t\\t\\t\\t\\t   ->    1\\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t h:1  (5)  (4)  h:0\\n\\t\\t\\t\\t\\t\\t\\t  / \\\\  / \\\\\\n\\t\\t\\t\\t\\t\\t\\t  2  4  n n\\n\\t\\t\\t\\t\\t\\t\\t [0  1]\\n\\n\\n\\t\\t\\t\\tSince the right subtree is greater or equal to the left subtree height, we will move right \\n\\n\\n\\t\\t\\t\\t\\t\\t   ->    1\\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t h:1  (5)  (4)  h:0\\n\\t\\t\\t\\t\\t\\t\\t  / \\\\  / \\\\\\n\\t\\t\\t\\t\\t\\t\\t  2  4  n n\\n\\t\\t\\t\\t\\t\\t\\t\\t[1]\\n\\n\\t\\t\\t\\tWe have reached the last node\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t 1\\n\\t\\t\\t\\t\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t\\t\\t\\t\\t   5   4x \\n\\t\\t\\t\\t\\t\\t\\t  / \\\\\\n\\t\\t\\t\\t\\t\\t\\t 2 ->4 \\n\\n\\t\\t\\t\\treturn \\n\\t\\t\\t\\t\\t\\tthe total number of possible nodes \\n\\t\\t\\t\\t\\t\\t- \\n\\t\\t\\t\\t\\t\\tnumber of nodes possible on last level \\n\\t\\t\\t\\t\\t\\t+ \\n\\t\\t\\t\\t\\t\\tactual number of nodes\\n\\n\\n\\n\\t\\t\\t\\tALGORITHM\\n\\t\\t\\t\\t\\tStep 1: if the root is null, return 0\\n\\t\\t\\t\\t\\tStep 2: find the height of the current tree and calculate the max possible nodes\\n\\t\\t\\t\\t\\tStep 3: calculate the possible nodes on the last level\\n\\t\\t\\t\\t\\tStep 4: loop while the root node is not null\\n\\t\\t\\t\\t\\t\\t\\t-> calculcate the height of the right subtree\\n\\t\\t\\t\\t\\t\\t\\t-> calculate the height of the left subtree\\n\\t\\t\\t\\t\\t\\t\\t-> if the left subtree\\'s height is greater than the right subtree\\n\\t\\t\\t\\t\\t\\t\\t\\t-> calculate nodes missing for right side\\n\\t\\t\\t\\t\\t\\t\\t\\t-> update possible nodes on last level\\n\\t\\t\\t\\t\\t\\t\\t\\t-> move root to left subtree\\n\\t\\t\\t\\t\\t\\t\\t-> else move root to right subtree\\n\\t\\t\\t\\t\\t\\t\\t\\t-> move root to right subtree\\n\\t\\t\\t\\t\\tStep 5: return max possible nodes \\n\\t\\t\\t\\t\\t\\t\\t\\t- possible nodes on last levelnodes on last level\\n\\t\\t\\t\\t\\t\\t\\t\\t+ actual number of nodes\\n\\n\\t\\t\\t*/\\n\\n\\t\\t\\tif(root == null) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 357767,
                "title": "java-full-explanation-100-memory-100-speed",
                "content": "\\n\\n We can apply the same logic of calculating the height of binary tree with slight changes.\\n Recall: Height of binary tree is Max (height of left sub-tree , height of right sub-tree ) + 1.\\n\\n As we know, this is complete binary tree, which means the height of left sub-tree >= height of right sub-tree. As complete binary tree is left oriented.\\n\\n case 1: When Height(Left sub-tree) = Height(right sub-tree)\\n This only possible when this tree is full binary tree.\\n ```    \\n\\t 1\\n    / \\\\\\n   2   3\\n  / \\\\   /\\\\\\n 4  5   6 7\\n ```\\n\\n At root 1, the height of left  = height of right.\\n\\n so number of nodes in full binary tree is 2^height-1; For above 2^3-1 = 7\\n\\n case 2: When Height(Left sub-tree) > Height(right sub-tree)\\n\\n```\\n     1\\n    / \\\\\\n   2   3\\n  / \\\\   /\\n 4  5  6\\n```\\n\\n Height of left = 3 while height of right is = 2\\n in this case, the total number of nodes is depends on its sub-tree. So if we know how many number of nodes are there in left and right then total would be\\n count(left) + count(right) + 1 [ for root ]\\n\\n Base case:\\n When root is leaf, its height is always 1 so tha number of nodes=1\\n\\n\\n Hence\\n Algorithm:\\n 1. find height of left sub-tree [Lh] and right sub-tree [Rh]\\n 2. if Lh == Rh then total nodes at this root is 2^height-1\\n 3. if Lh > rH then total nodes at this root is 1 + count(left) + count(right)\\n\\n Example:\\n ```\\n     1\\n    / \\\\\\n   2    3\\n  / \\\\   /\\n 4  5  6\\n```\\n Step 1: Root = 1; Lh = 3 and Rh = 2 (3!=2)\\n step 2.a : Root = 2, Lh = 2 and Rh = 2 hence number of nodes rooted at this root is 2^2 -1 = 3\\n step 2.b; Root = 3; Lh = 2 and Rh = 0 (2!=0\\n Step 2.b.a: Root=6 nodes at this is 1 [ base case ]\\n step 2.b.b: Root = null, nodes is 0\\n Hence\\n step 2.b: 1 + 1 + 0 = 2\\n And\\n Step 1: 3 + 2 + 1 = 6 output\\n\\n\\n Complexity:\\n Height  = O(log(n))\\n count nodes = O(log(n))\\n\\n Total: O((log(n))^2) => O(h^2)\\n\\n\\n Runtime: 0 ms, faster than 100.00% of Java online submissions for Count Complete Tree Nodes.\\n Memory Usage: 37.4 MB, less than 100.00% of Java online submissions for Count Complete Tree Nodes.\\n\\n\\n```\\n\\n\\n    public int countNodes(TreeNode root) {\\n\\n        if (root == null)\\n            return 0;\\n\\n\\n        int leftHeight = leftHeight(root);\\n        int rightHeight = rightHeight(root);\\n\\n        /**\\n         * case 1: When Height(Left sub-tree) = Height(right sub-tree)\\n         * 2^h - 1\\n         */\\n        if (leftHeight == rightHeight)\\n            return (1 << leftHeight) - 1;\\n        else\\n            return 1 + countNodes(root.left) + countNodes(root.right);\\n\\n\\n    }\\n\\n\\n    private int leftHeight(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        return 1 + leftHeight(root.left);\\n    }\\n\\n    private int rightHeight(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        return 1 + rightHeight(root.right);\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```    \\n\\t 1\\n    / \\\\\\n   2   3\\n  / \\\\   /\\\\\\n 4  5   6 7\\n ```\n```\\n     1\\n    / \\\\\\n   2   3\\n  / \\\\   /\\n 4  5  6\\n```\n```\\n     1\\n    / \\\\\\n   2    3\\n  / \\\\   /\\n 4  5  6\\n```\n```\\n\\n\\n    public int countNodes(TreeNode root) {\\n\\n        if (root == null)\\n            return 0;\\n\\n\\n        int leftHeight = leftHeight(root);\\n        int rightHeight = rightHeight(root);\\n\\n        /**\\n         * case 1: When Height(Left sub-tree) = Height(right sub-tree)\\n         * 2^h - 1\\n         */\\n        if (leftHeight == rightHeight)\\n            return (1 << leftHeight) - 1;\\n        else\\n            return 1 + countNodes(root.left) + countNodes(root.right);\\n\\n\\n    }\\n\\n\\n    private int leftHeight(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        return 1 + leftHeight(root.left);\\n    }\\n\\n    private int rightHeight(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        return 1 + rightHeight(root.right);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62031,
                "title": "java-solution-beats-90",
                "content": "Always check the depth of the right sub tree. If the depth equals that of left sub tree, the nodes count of left sub tree would be clear.\\nThe depth of left sub tree will always be known by node's father, so this value can be passed recursively.\\n\\npublic class Solution {\\n\\n    public int countNodes(TreeNode root) {\\n        TreeNode temp = root;\\n        int height = -1;\\n        while(temp != null) {\\n            height++;\\n            temp = temp.left;\\n        }\\n        return count(root, height);\\n    }\\n    \\n    public int count(TreeNode node, int depth) {\\n        if(node == null) {\\n            return 0;\\n        }\\n        TreeNode temp = node.right;\\n        int rightHeight = 0;\\n        while(temp != null) {\\n            rightHeight++;\\n            temp = temp.left;\\n        }\\n        if(rightHeight == depth) {\\n            return (1 << depth) + count(node.right, rightHeight - 1);\\n        } else {\\n            return (1 << (depth - 1)) + count(node.left, depth - 1);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int countNodes(TreeNode root) {\\n        TreeNode temp = root;\\n        int height = -1;\\n        while(temp != null) {\\n            height++;\\n            temp = temp.left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62061,
                "title": "ac-python-iterative-solution",
                "content": "    class Solution(object):\\n        def countNodes(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: int\\n            \"\"\"\\n            # O(logn logn)\\n            h = self.height(root)\\n            nodes = 0\\n            while root:\\n                if self.height(root.right) == h - 1:\\n                    nodes += 2 ** h  # left half (2 ** h - 1) and the root (1)\\n                    root = root.right\\n                else:\\n                    nodes += 2 ** (h - 1)\\n                    root = root.left\\n                h -= 1\\n            return nodes        \\n    \\n        def height(self, root):\\n            return -1 if not root else 1 + self.height(root.left)\\n\\nAn implementation of [StefanPochmann][1]'s O(logn^2) [solution][2], which has 144 ms runtime and beats 100% Python submission.\\n\\n  [1]: https://leetcode.com/discuss/user/StefanPochmann\\n  [2]: https://leetcode.com/discuss/38930/concise-java-solutions-o-log-n-2",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def countNodes(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: int\\n            \"\"\"\\n            # O(logn logn)\\n            h = self.height(root)\\n            nodes = 0\\n            while root:\\n                if self.height(root.right) == h - 1:\\n                    nodes += 2 ** h  # left half (2 ** h - 1) and the root (1)\\n                    root = root.right\\n                else:\\n                    nodes += 2 ** (h - 1)\\n                    root = root.left\\n                h -= 1\\n            return nodes        \\n    \\n        def height(self, root):\\n            return -1 if not root else 1 + self.height(root.left)\\n\\nAn implementation of [StefanPochmann][1]'s O(logn^2) [solution][2], which has 144 ms runtime and beats 100% Python submission.\\n\\n  [1]: https://leetcode.com/discuss/user/StefanPochmann\\n  [2]: https://leetcode.com/discuss/38930/concise-java-solutions-o-log-n-2",
                "codeTag": "Java"
            },
            {
                "id": 3227589,
                "title": "222-time-95-20-and-space-98-59-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses binary search to count the number of nodes in a complete binary tree.\\n\\nThe main idea of this algorithm is to first find the height of the leftmost and rightmost subtree of the given complete binary tree, then check if the height of both subtrees is the same. If it is the same, then the tree is a perfect binary tree and we can easily calculate the total number of nodes in the tree. Otherwise, we recursively count the nodes in the left and right subtree.\\n\\nHere\\'s a step-by-step explanation of the code:\\n\\n1. The function countNodes takes in a root node of the tree as input.\\n\\n2. If the root node is None, it means that the tree is empty and we return 0.\\n\\n3. We initialize two pointers l and r to point to the root node. We also initialize two variables heightL and heightR to 0.\\n\\n4. We use a while loop to traverse the leftmost subtree starting from the root node. In each iteration of the loop, we increment the heightL variable and move the l pointer to its left child. This gives us the height of the leftmost subtree.\\n\\n5. We use another while loop to traverse the rightmost subtree starting from the root node. In each iteration of the loop, we increment the heightR variable and move the r pointer to its right child. This gives us the height of the rightmost subtree.\\n\\n6. We check if the height of the leftmost and rightmost subtree is the same. If they are the same, it means that the tree is a perfect binary tree and we can easily calculate the total number of nodes in the tree using the formula (2^h) - 1, where h is the height of the tree. We return this value.\\n\\n7. If the height of the leftmost and rightmost subtree is not the same, it means that the tree is not a perfect binary tree and we need to recursively count the nodes in the left and right subtree.\\n\\n8. We return the sum of 1 (the root node) and the number of nodes in the left and right subtree, which are computed recursively by calling the countNodes function on the left and right child of the root node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def countNodes(self, root: Optional[TreeNode]) -> int:\\n    if not root:\\n      return 0\\n\\n    l = root\\n    r = root\\n    heightL = 0\\n    heightR = 0\\n\\n    while l:\\n      heightL += 1\\n      l = l.left\\n\\n    while r:\\n      heightR += 1\\n      r = r.right\\n\\n    if heightL == heightR:  # Root is a complete tree\\n      return pow(2, heightL) - 1\\n    return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n  def countNodes(self, root: Optional[TreeNode]) -> int:\\n    if not root:\\n      return 0\\n\\n    l = root\\n    r = root\\n    heightL = 0\\n    heightR = 0\\n\\n    while l:\\n      heightL += 1\\n      l = l.left\\n\\n    while r:\\n      heightR += 1\\n      r = r.right\\n\\n    if heightL == heightR:  # Root is a complete tree\\n      return pow(2, heightL) - 1\\n    return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330269,
                "title": "easy-brief-explanation-with-o-n-complexity-c-recursion",
                "content": "This code has time complexity less than O{n) , Here the worst case would be when tree is [1,2,3] as we will be travelling all the nodes in this case and in rest we wont, As we will be finding only edges. \\uD83D\\uDC47\\n\\n1. Traversal in edges and findind height in O(1) **when tree is complete** so < O(n) \\n```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    We need to design an algo which runs in less than O(n) time complexity. So, one \\n    way is to just travel the edges as this is a complete binary tree (except last level) \\n    so we know the number of nodes at any level. So, we must travel on edges only as we can find nodes       between the edges at any level as 2^level. \\n    */ \\n\\t\\n    int countNodes(TreeNode* root) \\n    {\\n        if(root == NULL) return 0;\\n        \\n        TreeNode* l = root; \\n        TreeNode* r = root;\\n        \\n        int leftH = 0, rightH = 0;  //To compare heights\\n        \\n        while(l)                    //Traverse left edge till left node exists and count the left height\\n        {\\n            l = l->left;\\n            leftH++;\\n        }\\n        \\n        while(r)                    //Tranverse right edge till right node exists and count the right height\\n        {\\n            r = r->right;\\n            rightH++;\\n        }\\n        \\n        if(leftH == rightH)     //If left and Right height are equal then return the height in O(n)\\n        {\\n            return (1 << leftH) - 1;\\n        }\\n        \\n        return 1 + countNodes(root->left) + countNodes(root->right); //If height and right heights are not equal then go in recursion and look for that subtree which is complete.\\n    }\\n};\\n```\\n2. Basic Traversal in O(n)\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int countNodes(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;                           //Base Case\\n        \\n        int leftHeight = 0, rightHeight = 0;    // Define left and right Height as 0 if not found\\n\\n        if(root->left) leftHeight = countNodes(root->left);     //Make left call and traverse till left node edge exists\\n        if(root->right) rightHeight = countNodes(root->right);  //Make right call and traverse till right node edge exists.\\n        \\n        // cout<<1 + leftHeight + rightHeight<<\" \";\\n        \\n        return 1 + leftHeight + rightHeight;        //Return node itself + no of left nodes + no of right nodes\\n    }\\n};\\n```\\n\\n*\\u2728 I am not a pro just a begineer, If I can improve anywhere please comment below or if you have any doubt feel free to ask.*",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    We need to design an algo which runs in less than O(n) time complexity. So, one \\n    way is to just travel the edges as this is a complete binary tree (except last level) \\n    so we know the number of nodes at any level. So, we must travel on edges only as we can find nodes       between the edges at any level as 2^level. \\n    */ \\n\\t\\n    int countNodes(TreeNode* root) \\n    {\\n        if(root == NULL) return 0;\\n        \\n        TreeNode* l = root; \\n        TreeNode* r = root;\\n        \\n        int leftH = 0, rightH = 0;  //To compare heights\\n        \\n        while(l)                    //Traverse left edge till left node exists and count the left height\\n        {\\n            l = l->left;\\n            leftH++;\\n        }\\n        \\n        while(r)                    //Tranverse right edge till right node exists and count the right height\\n        {\\n            r = r->right;\\n            rightH++;\\n        }\\n        \\n        if(leftH == rightH)     //If left and Right height are equal then return the height in O(n)\\n        {\\n            return (1 << leftH) - 1;\\n        }\\n        \\n        return 1 + countNodes(root->left) + countNodes(root->right); //If height and right heights are not equal then go in recursion and look for that subtree which is complete.\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int countNodes(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;                           //Base Case\\n        \\n        int leftHeight = 0, rightHeight = 0;    // Define left and right Height as 0 if not found\\n\\n        if(root->left) leftHeight = countNodes(root->left);     //Make left call and traverse till left node edge exists\\n        if(root->right) rightHeight = countNodes(root->right);  //Make right call and traverse till right node edge exists.\\n        \\n        // cout<<1 + leftHeight + rightHeight<<\" \";\\n        \\n        return 1 + leftHeight + rightHeight;        //Return node itself + no of left nodes + no of right nodes\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 259458,
                "title": "java-compare-heights",
                "content": "Runtime - O(logN * logN)\\n\\n```java\\nclass Solution {\\n    \\n    // If height of left and right tree are same, left tree must be full tree\\n    // If height of left and right are different, right tree must be full tree\\n    public int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int leftHeight = getHeight(root.left);\\n        int rightHeight = getHeight(root.right);\\n        \\n        \\n        if (leftHeight == rightHeight) {\\n            return (1 << leftHeight) + countNodes(root.right);\\n        } else {\\n            return (1 << rightHeight) + countNodes(root.left);\\n        }\\n    }\\n    \\n    // Since it\\'s a complete tree, height must be the length of left edge\\n    public int getHeight(TreeNode root) {\\n        int count = 0;\\n        while (root != null) {\\n            root = root.left;\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    // If height of left and right tree are same, left tree must be full tree\\n    // If height of left and right are different, right tree must be full tree\\n    public int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int leftHeight = getHeight(root.left);\\n        int rightHeight = getHeight(root.right);\\n        \\n        \\n        if (leftHeight == rightHeight) {\\n            return (1 << leftHeight) + countNodes(root.right);\\n        } else {\\n            return (1 << rightHeight) + countNodes(root.left);\\n        }\\n    }\\n    \\n    // Since it\\'s a complete tree, height must be the length of left edge\\n    public int getHeight(TreeNode root) {\\n        int count = 0;\\n        while (root != null) {\\n            root = root.left;\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62106,
                "title": "time-limit-for-the-python-solution",
                "content": "Hi my algorithm is o((log n)^2) and it still can't pass the special judge, any idea why?\\nmy code is as follows:\\nit checks the leftmost and rightmost nodes and if they are on the same level, then the nodes in this full complete tree is added, otherwise break the two subtrees and calculate the number of nodes in each separately.\\n\\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer}\\n        def countNodes(self, root):\\n            if not root:\\n                return 0\\n            h1=h2=0\\n            node=root\\n            while node:\\n                h1+=1\\n                node=node.left\\n            node=root\\n            while node:\\n                h2+=1\\n                node=node.right\\n            if h1==h2:\\n                return 2**h1-1\\n            return self.countNodes(root.left)+self.countNodes(root.right)+1",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 2815314,
                "title": "daily-leetcoding-challenge-november-day-15",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/count-complete-tree-nodes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Linear Time\n\n  \n**Approach 2:** Binary search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/count-complete-tree-nodes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 413399,
                "title": "clean-javascript-binary-search-and-dfs-solution",
                "content": "\\n**DFS**\\n```js\\n// Time O(n)\\n// Space O(d) = O(log n) to keep the recursion stack, where d is a tree depth\\nfunction countNodes(root) {\\n  if (root == null) return 0;\\n  return countNodes(root.left) + countNodes(root.right) + 1;\\n}\\n```\\n\\n**Binary Search**\\n\\n```js\\n// Time O(d^2) = O((log n)^2), where d is a tree depth\\n// Space O(1)\\nfunction countNodes(root) {\\n  // if the tree is empty\\n  if (root == null) return 0;\\n\\n  const d = getDepth(root);\\n\\n  // Last level nodes are enumerated from 0 to 2^d - 1 (left -> right).\\n  // Perform binary search to check how many nodes exist.\\n  let l = 0;\\n  let r = 2 ** d - 1;\\n  while (l <= r) {\\n    const m = ~~((l + r) / 2);\\n    if (exists(m, d, root)) l = m + 1;\\n    else r = m - 1;\\n  }\\n\\n  // The tree contains 2^d - 1 nodes on the first (d - 1) levels\\n  // and l nodes on the last level.\\n  return 2 ** d - 1 + l;\\n}\\n\\n// Return tree depth in O(d) time.\\nfunction getDepth(node) {\\n  let d = 0;\\n  while (node.left != null) {\\n    node = node.left;\\n    d++;\\n  }\\n  return d;\\n}\\n\\n// Last level nodes are enumerated from 0 to 2^d - 1 (left -> right).\\n// Return true if last level node idx exists.\\n// Binary search with O(d) complexity.\\nfunction exists(idx, d, node) {\\n  let l = 0;\\n  let r = 2 ** d - 1;\\n  while (l < r) {\\n    const m = ~~((l + r) / 2);\\n    if (idx > m) {\\n      node = node.right;\\n      l = m + 1;\\n    } else {\\n      node = node.left;\\n      r = m;\\n    }\\n  }\\n  return node != null;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```js\\n// Time O(n)\\n// Space O(d) = O(log n) to keep the recursion stack, where d is a tree depth\\nfunction countNodes(root) {\\n  if (root == null) return 0;\\n  return countNodes(root.left) + countNodes(root.right) + 1;\\n}\\n```\n```js\\n// Time O(d^2) = O((log n)^2), where d is a tree depth\\n// Space O(1)\\nfunction countNodes(root) {\\n  // if the tree is empty\\n  if (root == null) return 0;\\n\\n  const d = getDepth(root);\\n\\n  // Last level nodes are enumerated from 0 to 2^d - 1 (left -> right).\\n  // Perform binary search to check how many nodes exist.\\n  let l = 0;\\n  let r = 2 ** d - 1;\\n  while (l <= r) {\\n    const m = ~~((l + r) / 2);\\n    if (exists(m, d, root)) l = m + 1;\\n    else r = m - 1;\\n  }\\n\\n  // The tree contains 2^d - 1 nodes on the first (d - 1) levels\\n  // and l nodes on the last level.\\n  return 2 ** d - 1 + l;\\n}\\n\\n// Return tree depth in O(d) time.\\nfunction getDepth(node) {\\n  let d = 0;\\n  while (node.left != null) {\\n    node = node.left;\\n    d++;\\n  }\\n  return d;\\n}\\n\\n// Last level nodes are enumerated from 0 to 2^d - 1 (left -> right).\\n// Return true if last level node idx exists.\\n// Binary search with O(d) complexity.\\nfunction exists(idx, d, node) {\\n  let l = 0;\\n  let r = 2 ** d - 1;\\n  while (l < r) {\\n    const m = ~~((l + r) / 2);\\n    if (idx > m) {\\n      node = node.right;\\n      l = m + 1;\\n    } else {\\n      node = node.left;\\n      r = m;\\n    }\\n  }\\n  return node != null;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62037,
                "title": "80ms-simple-c-recurrence-solution-uff0ceasy-to-understand",
                "content": "    class Solution {\\n    public:\\n        int countNodes(int l_level,TreeNode* root)\\n        {\\n            if(!root) return 0;\\n            TreeNode* r=root->right;\\n            int r_level=0;\\n            while(r) {r_level++;r=r->left;}\\n            if(l_level==r_level) return (1<<l_level)+countNodes(l_level-1,root->right);\\n            return countNodes(l_level-1,root->left)+(1<<r_level);\\n        }\\n        int countNodes(TreeNode* root) {\\n            if(!root) return 0;\\n            TreeNode* l=root->left,*r=root->right;\\n            int l_level=0,r_level=0;\\n            while(l) {l_level++;l=l->left;}\\n            while(r) {r_level++;r=r->left;}\\n            if(l_level==r_level) return (1<<l_level)+countNodes(l_level-1,root->right);\\n            return (1<<r_level)+countNodes(l_level-1,root->left);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int countNodes(int l_level,TreeNode* root)\\n        {\\n            if(!root) return 0;\\n            TreeNode* r=root->right;\\n            int r_level=0;\\n            while(r) {r_level++;r=r->left;}",
                "codeTag": "Java"
            },
            {
                "id": 62059,
                "title": "o-log-2-n-using-binary-search-python-iterative",
                "content": "The key idea of this binary search approach is to search in the last level of the tree. \\n\\nIf the ***mid*** of the last level is not None, then the size of last level is at least ***mid***. We keep searching until we find the last not None leaf node, so we can know the size of the last level.\\n\\nTo get to the Kth node in the last level, I use the binary representation of K to track the path from root to leaf. If current bit is '1' then turn the right child, else turn right.\\n\\n\\n    def countNodes(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        height = self.getHeight(root)\\n        last_level = 0\\n        left, right = 0, 2**height-1\\n        while left <= right:\\n            mid = (left+right)/2\\n            if self.getKthNode(root, height, mid) is None:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n                last_level = mid+1\\n        return last_level + 2**height - 1\\n        \\n    def getHeight(self, root):\\n        count = 0\\n        while root.left is not None:\\n            count += 1\\n            root = root.left\\n        return count\\n        \\n    def getKthNode(self, root, height, k):\\n        # binary bits representation of the root-to-leaf path\\n        while height > 0:\\n            if 2**(height-1) & k == 2**(height-1): # current bit is '1', turn right\\n                root = root.right\\n            else: # current bit is '0', turn left\\n                root = root.left\\n            height -= 1\\n        return root",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "The key idea of this binary search approach is to search in the last level of the tree. \\n\\nIf the ***mid*** of the last level is not None, then the size of last level is at least ***mid***. We keep searching until we find the last not None leaf node, so we can know the size of the last level.\\n\\nTo get to the Kth node in the last level, I use the binary representation of K to track the path from root to leaf. If current bit is '1' then turn the right child, else turn right.\\n\\n\\n    def countNodes(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        height = self.getHeight(root)\\n        last_level = 0\\n        left, right = 0, 2**height-1\\n        while left <= right:\\n            mid = (left+right)/2\\n            if self.getKthNode(root, height, mid) is None:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n                last_level = mid+1\\n        return last_level + 2**height - 1\\n        \\n    def getHeight(self, root):\\n        count = 0\\n        while root.left is not None:\\n            count += 1\\n            root = root.left\\n        return count\\n        \\n    def getKthNode(self, root, height, k):\\n        # binary bits representation of the root-to-leaf path\\n        while height > 0:\\n            if 2**(height-1) & k == 2**(height-1): # current bit is '1', turn right\\n                root = root.right\\n            else: # current bit is '0', turn left\\n                root = root.left\\n            height -= 1\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 61980,
                "title": "java-iterative-solution",
                "content": "    public class Solution {\\n        public int countNodes(TreeNode root) {\\n            int k = 0;\\n            if(root == null){\\n                return 0;\\n            }\\n            int h1 = leftH(root.left);\\n            while(root != null){\\n                int h2 = leftH(root.right);\\n                if(h1 == h2){\\n                    root = root.right;\\n                }else{\\n                    root = root.left;\\n                }\\n                k += 1 << h2;\\n                h1--;\\n            }\\n            return k;\\n        }\\n        private int leftH(TreeNode curr){\\n            int h = 0;\\n            while(curr != null){\\n                curr = curr.left;\\n                h++;\\n            }\\n            return h;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int countNodes(TreeNode root) {\\n            int k = 0;\\n            if(root == null){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3888111,
                "title": "java-less-than-o-n-time-complexity-o-log-n-explained",
                "content": "# Intuition\\nBinary search of last filled item in last level.\\n\\n# Approach\\nSample depth in the middle of the tree. For instance leftmost depth of right sub tree. If it\\'s filled - you can easily drop the entire left subtree and check only right subtree.\\n\\n![1.png](https://assets.leetcode.com/users/images/dbc132da-f013-48e6-9afa-d485eec2204b_1691619087.932586.png)\\n![2.png](https://assets.leetcode.com/users/images/0b618ce2-174c-4ddb-928c-26e517116384_1691619135.595773.png)\\n![3.png](https://assets.leetcode.com/users/images/a87203ae-4b39-4483-9ecc-f213177cfef5_1691619220.5503738.png)\\n![4.png](https://assets.leetcode.com/users/images/e2a37459-6dce-4ebc-baa0-a6d65a504206_1691619227.7590718.png)\\n\\n\\n# Complexity\\n- Time complexity: O(log n)\\n\\n- Space complexity: O(log n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int leftDepth = leftDepth(root);\\n        return countNodes(root, leftDepth - 1);\\n    }\\n\\n    private int countNodes(TreeNode root, int depth) {\\n        if (root == null) return 0;\\n        int ld = leftDepth(root.right);\\n        TreeNode next = ld == depth ? root.right : root.left;\\n        // root node + size of filled subtree of ld depth\\n        return (1 << ld) + countNodes(next, depth - 1);\\n    }\\n\\n    private int leftDepth(TreeNode node) {\\n        int depth = 0;\\n        while (node != null) {\\n            depth++;\\n            node = node.left;\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int leftDepth = leftDepth(root);\\n        return countNodes(root, leftDepth - 1);\\n    }\\n\\n    private int countNodes(TreeNode root, int depth) {\\n        if (root == null) return 0;\\n        int ld = leftDepth(root.right);\\n        TreeNode next = ld == depth ? root.right : root.left;\\n        // root node + size of filled subtree of ld depth\\n        return (1 << ld) + countNodes(next, depth - 1);\\n    }\\n\\n    private int leftDepth(TreeNode node) {\\n        int depth = 0;\\n        while (node != null) {\\n            depth++;\\n            node = node.left;\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813143,
                "title": "javascript-222-count-complete-tree-nodes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nNo formula\\n```\\nvar countNodes = function (r) {\\n\\n  function dfs(r) {\\n    if (!r) return 0;\\n\\n    let ll = dfs(r.left)\\n    let rr = dfs(r.right)\\n\\n    return 1 + ll + rr;\\n  }\\n\\n  return dfs(r);\\n};\\n```\\n\\nWith formula\\n```\\nvar countNodes = function (r) {\\n  /*\\n                x\\n        A               B\\n    x      x          x   x\\n   x x    x x   \\n\\n  A and B are have    same depth   for left & right subtrees, it is 2 & 1\\n\\n  */\\n  function depthLeftMostNode(r) {\\n    if (!r) return 0\\n    return 1 + depthLeftMostNode(r.left)\\n  }\\n  function depthRightMostNode(r) {\\n    if (!r) return 0\\n    return 1 + depthRightMostNode(r.right)\\n  }\\n\\n  function dfs(r) {\\n    const ldepth = depthLeftMostNode(r);\\n    const rdepth = depthRightMostNode(r);\\n\\n    if (ldepth === rdepth)\\t\\t\\t\\t\\t// same height for  left & right sub tree\\n      return Math.pow(2, ldepth) - 1;\\t\\t//   so, 0th level has 2**0 - 1 = 1, 1st level has 2**1 - 1 = 3\\n\\n    return 1 + dfs(r.left) + dfs(r.right) // may be, left subtree has same height\\n  }\\n  return dfs(r);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countNodes = function (r) {\\n\\n  function dfs(r) {\\n    if (!r) return 0;\\n\\n    let ll = dfs(r.left)\\n    let rr = dfs(r.right)\\n\\n    return 1 + ll + rr;\\n  }\\n\\n  return dfs(r);\\n};\\n```\n```\\nvar countNodes = function (r) {\\n  /*\\n                x\\n        A               B\\n    x      x          x   x\\n   x x    x x   \\n\\n  A and B are have    same depth   for left & right subtrees, it is 2 & 1\\n\\n  */\\n  function depthLeftMostNode(r) {\\n    if (!r) return 0\\n    return 1 + depthLeftMostNode(r.left)\\n  }\\n  function depthRightMostNode(r) {\\n    if (!r) return 0\\n    return 1 + depthRightMostNode(r.right)\\n  }\\n\\n  function dfs(r) {\\n    const ldepth = depthLeftMostNode(r);\\n    const rdepth = depthRightMostNode(r);\\n\\n    if (ldepth === rdepth)\\t\\t\\t\\t\\t// same height for  left & right sub tree\\n      return Math.pow(2, ldepth) - 1;\\t\\t//   so, 0th level has 2**0 - 1 = 1, 1st level has 2**1 - 1 = 3\\n\\n    return 1 + dfs(r.left) + dfs(r.right) // may be, left subtree has same height\\n  }\\n  return dfs(r);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2816653,
                "title": "c-standard-and-standard-solution-explained",
                "content": "**1. Recursively counting the number of nodes**\\n# Thought Process:\\nRecursively count the number of nodes in the left subtree and right tree. Then, return the ```1 + no_of_left_nodes + no_of_right_nodes;```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper (TreeNode *root){        \\n        if (root == NULL)\\n            return 0;\\n        \\n        int no_of_left_nodes = helper (root -> left);\\n        int no_of_right_nodes = helper (root -> right);\\n        \\n        return 1 + no_of_left_nodes + no_of_right_nodes;\\n    }\\n    int countNodes(TreeNode* root) {\\n        return helper (root);\\n    }\\n};\\n```\\n\\n# Complexities:\\n**TC:** O(N)\\n**SC:** O(height of the tree)\\n\\n**2. Comparing the height of left and right boundary**\\n# Thought Process:\\nFor each node, traverse left and right boundary and store its height in two seperate variables.\\nNow, there arise two case:-\\n\\n*Case 1:* if left and right boundaries are equal, return ```pow (2, left_height)-1``` (Nodes at each level are in Geometric Progression (GP))\\n\\n*Case 2:* If ther are not equal, repeat the above process for the left subtree and right subtree of the node.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper (TreeNode *root){\\n        \\n        if (root == NULL) return 0;\\n        \\n        auto ptr1 = root;\\n        auto ptr2 = root;\\n        \\n        int left_height = 0;\\n        int right_height = 0;\\n        \\n        while (ptr1) ptr1 = ptr1 -> left, left_height++;\\n        while (ptr2) ptr2 = ptr2 -> right, right_height++;\\n        \\n        if (left_height == right_height) return pow (2,left_height)-1;\\n        \\n        return helper (root->left) + helper (root->right) + 1;        \\n    }\\n    int countNodes(TreeNode* root) {\\n        return helper (root);\\n    }\\n};\\n```\\n\\n# Complexities: \\n**TC:** O(logn * logn)\\n**SC:** O(height of the tree)",
                "solutionTags": [
                    "C"
                ],
                "code": "```1 + no_of_left_nodes + no_of_right_nodes;```\n```\\nclass Solution {\\npublic:\\n    \\n    int helper (TreeNode *root){        \\n        if (root == NULL)\\n            return 0;\\n        \\n        int no_of_left_nodes = helper (root -> left);\\n        int no_of_right_nodes = helper (root -> right);\\n        \\n        return 1 + no_of_left_nodes + no_of_right_nodes;\\n    }\\n    int countNodes(TreeNode* root) {\\n        return helper (root);\\n    }\\n};\\n```\n```pow (2, left_height)-1```\n```\\nclass Solution {\\npublic:\\n    \\n    int helper (TreeNode *root){\\n        \\n        if (root == NULL) return 0;\\n        \\n        auto ptr1 = root;\\n        auto ptr2 = root;\\n        \\n        int left_height = 0;\\n        int right_height = 0;\\n        \\n        while (ptr1) ptr1 = ptr1 -> left, left_height++;\\n        while (ptr2) ptr2 = ptr2 -> right, right_height++;\\n        \\n        if (left_height == right_height) return pow (2,left_height)-1;\\n        \\n        return helper (root->left) + helper (root->right) + 1;        \\n    }\\n    int countNodes(TreeNode* root) {\\n        return helper (root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815820,
                "title": "93-faster-o-log-n-o-h-dfs-to-find-depth",
                "content": "![image](https://assets.leetcode.com/users/images/5e83151d-b283-4bb3-97d7-e316322ce356_1668486901.5655644.png)\\n\\n\\n    public int CountNodes(TreeNode root) \\n    {\\n        int leftDepth = GetLeftDepth(root);\\n        int rightDepth = GetRightDepth(root);\\n        \\n        //for perfect binary tree\\n        if(leftDepth == rightDepth)\\n        {\\n            return (int)Math.Pow(2, leftDepth) -1; //say there are 4 levels, each has 2 nodes : 2^4 - 1 = 15\\n        }\\n        \\n        // for complete binary tree\\n        return CountNodes(root.left) + CountNodes(root.right) +1;  //say left has 4 levels, count nodes on left + count nodes on right, add 1 and return\\n    }\\n    \\n    private int GetLeftDepth(TreeNode root)\\n    {\\n        if(root == null) return 0;\\n        return GetLeftDepth(root.left) +1;\\n    }\\n    \\n    private int GetRightDepth(TreeNode root)\\n    {\\n        if(root == null) return 0;\\n        return GetRightDepth(root.right) +1;\\n    }",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/5e83151d-b283-4bb3-97d7-e316322ce356_1668486901.5655644.png)\\n\\n\\n    public int CountNodes(TreeNode root) \\n    {\\n        int leftDepth = GetLeftDepth(root);\\n        int rightDepth = GetRightDepth(root);\\n        \\n        //for perfect binary tree\\n        if(leftDepth == rightDepth)\\n        {\\n            return (int)Math.Pow(2, leftDepth) -1; //say there are 4 levels, each has 2 nodes : 2^4 - 1 = 15\\n        }\\n        \\n        // for complete binary tree\\n        return CountNodes(root.left) + CountNodes(root.right) +1;  //say left has 4 levels, count nodes on left + count nodes on right, add 1 and return\\n    }\\n    \\n    private int GetLeftDepth(TreeNode root)\\n    {\\n        if(root == null) return 0;\\n        return GetLeftDepth(root.left) +1;\\n    }\\n    \\n    private int GetRightDepth(TreeNode root)\\n    {\\n        if(root == null) return 0;\\n        return GetRightDepth(root.right) +1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2449076,
                "title": "c-o-log-n-2-solution-clean-code",
                "content": "**PLZ Upvote**\\n\\n```\\nclass Solution {\\n    // This Runs in O(Log N) time.\\n    int findLeftH(TreeNode* node){\\n        int height = 0;\\n        while(node){\\n            node = node->left;\\n            height++;\\n        }\\n        return height;\\n    }\\n    // This Runs in O(Log N) time.\\n    int findRightH(TreeNode* node){\\n        int height = 0;\\n        while(node){\\n            node = node->right;\\n            height++;\\n        }\\n        return height;\\n    }\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int leftHeight = findLeftH(root);\\n        int rightHeight = findRightH(root);\\n        \\n        if(leftHeight == rightHeight) return (pow(2, leftHeight) - 1);\\n        \\n        else return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // This Runs in O(Log N) time.\\n    int findLeftH(TreeNode* node){\\n        int height = 0;\\n        while(node){\\n            node = node->left;\\n            height++;\\n        }\\n        return height;\\n    }\\n    // This Runs in O(Log N) time.\\n    int findRightH(TreeNode* node){\\n        int height = 0;\\n        while(node){\\n            node = node->right;\\n            height++;\\n        }\\n        return height;\\n    }\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int leftHeight = findLeftH(root);\\n        int rightHeight = findRightH(root);\\n        \\n        if(leftHeight == rightHeight) return (pow(2, leftHeight) - 1);\\n        \\n        else return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598413,
                "title": "o-log-2-n-approach-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int heightleft(TreeNode* node)\\n    {\\n        int h=0;\\n        while(node)\\n        {\\n            h++;\\n            node = node->left;\\n        }\\n        return h;\\n    }\\n    int heightright(TreeNode* node)\\n    {\\n        int h=0;\\n        while(node)\\n        {\\n            h++;\\n            node = node->right;\\n        }\\n        return h;\\n    }\\n    int countNodes(TreeNode* root) {\\n        int ans;\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        int lh = heightleft(root->left);\\n        int rh = heightright(root->right);\\n        if(lh==rh)\\n        {\\n           return (1<<(lh+1)) -1;\\n            \\n        }\\n          return 1 + countNodes(root->left) + countNodes(root->right);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int heightleft(TreeNode* node)\\n    {\\n        int h=0;\\n        while(node)\\n        {\\n            h++;\\n            node = node->left;\\n        }\\n        return h;\\n    }\\n    int heightright(TreeNode* node)\\n    {\\n        int h=0;\\n        while(node)\\n        {\\n            h++;\\n            node = node->right;\\n        }\\n        return h;\\n    }\\n    int countNodes(TreeNode* root) {\\n        int ans;\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        int lh = heightleft(root->left);\\n        int rh = heightright(root->right);\\n        if(lh==rh)\\n        {\\n           return (1<<(lh+1)) -1;\\n            \\n        }\\n          return 1 + countNodes(root->left) + countNodes(root->right);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119444,
                "title": "python-o-logn-soln",
                "content": "```\\n\"\"\"\\n             1 visit \\n           /    \\\\ \\n    (^3)  2      3 visit\\n        /   \\\\   /  \\n       4     5 6 visit\\n     \\n     visit half nodes so logn\\n\\n\"\"\"\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        left = self.getLeftHeight(root) #logn op\\n        right = self.getRightHeight(root) #logn op\\n        \\n        if left == right:\\n            count = (2**left)-1 #if left == right then it\\'s a complete BT. number of nodes in a comp BT is 2^h-1\\n            return count\\n        else:\\n            #one subtree will always return immediately because it is complete. Hence time complexity is O(logn)\\n            return self.countNodes(root.left) + self.countNodes(root.right) + 1 \\n        \\n    \\n    def getLeftHeight(self, root):\\n        count=1\\n        while root.left:\\n            count += 1\\n            root = root.left\\n        return count\\n    \\n    def getRightHeight(self, root):\\n        count=1\\n        while root.right:\\n            count += 1\\n            root = root.right\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n             1 visit \\n           /    \\\\ \\n    (^3)  2      3 visit\\n        /   \\\\   /  \\n       4     5 6 visit\\n     \\n     visit half nodes so logn\\n\\n\"\"\"\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        left = self.getLeftHeight(root) #logn op\\n        right = self.getRightHeight(root) #logn op\\n        \\n        if left == right:\\n            count = (2**left)-1 #if left == right then it\\'s a complete BT. number of nodes in a comp BT is 2^h-1\\n            return count\\n        else:\\n            #one subtree will always return immediately because it is complete. Hence time complexity is O(logn)\\n            return self.countNodes(root.left) + self.countNodes(root.right) + 1 \\n        \\n    \\n    def getLeftHeight(self, root):\\n        count=1\\n        while root.left:\\n            count += 1\\n            root = root.left\\n        return count\\n    \\n    def getRightHeight(self, root):\\n        count=1\\n        while root.right:\\n            count += 1\\n            root = root.right\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702446,
                "title": "python-3-solutions-with-detail-explanation",
                "content": "This problem could be very simple but also very worth to dive deep.\\n\\nHere I listed out 3 different solutions with optimization one by one.\\n\\n#### 1. O(N) Method\\nUse very straight forward and simple `DFS` & `BFS` to search each node in the tree. Thus don\\'t even use any property of \\n`Completed Binary Search Tree`. \\n\\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        return 1 + self.countNodes(root.right) + self.countNodes(root.left) if root else 0\\n```\\n\\n#### 2. O(N * log(N)) Method\\nAccording to the property of `Completed Binary Search Tree`, all nodes must be as left as possible, which mean as\\n long as we get the height of tree and number of nodes in final level, we can compute the number of nodes:\\n```\\nNumber of Nodes = 2 ** (level number) - 1 + final level nodes number\\n```\\nThus we can design a `DFS` start searching from the most left, then count the `# final level nodes`. When the runner\\n reaches a leaf node not in final level, then stop search. \\n\\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n\\n        self.last_level_count = 0\\n        self.level = 0\\n        # Stop flag to end searching\\n        self.stop = 0\\n\\n        # Start with -1 since the searching ends on the children of leafs (None)\\n        # Make -1 offset then self.level can be the real value\\n        self.dfs(root, -1)\\n        return 2 ** self.level - 1 + self.last_level_count // 2\\n\\n    def dfs(self, node, level):\\n        if self.stop:\\n            return\\n\\n        if not node:\\n            self.level = max(self.level, level)\\n            # If the reaches the final level, then count 1\\n            # Note this is actually counting for # of children (None) of final level nodes\\n            if self.level == level:\\n                self.last_level_count += 1\\n            else:\\n                self.stop = 1\\n            return\\n\\n        self.dfs(node.left, level + 1)\\n        self.dfs(node.right, level + 1)\\n```\\n\\n#### 3. O(log(N) * log(N)) Method\\nAfter we find out the rule, we can still make optimization. From previous solution, we count the `# final level nodes\\n` one by one, which is `O(N)` time complexity. However, using `Binary Search` can improve it to `O(log(N))`. \\n\\nHere is one little trick when implementing `Binary Search`. After we get the `left`, `right`, `mid` index, how to\\n find the tree path to the correct `mid` final level node?\\n \\n We can convert the `mid` index into **binary format with leading zeros** to make sure the length is equal to the number\\n  of levels.\\n  \\nExample:\\n\\n![alt text](https://web.cecs.pdx.edu/~sheard/course/Cs163/Graphics/CompleteBinary.jpg)\\n\\nCheck out final level, `right, left = 0, 4`. Given `mid = 2` we need to find out path to the node `J`.\\n- First, we convert 2 to binary adding with leading zeros: `010`.\\n- Consider `0` as left, `1` as right, then `010` could be `left -> right -> left`. Here is the node `J`!\\n\\nAfter we find out the trick, it\\'s not hard to implement the code.\\n\\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n\\n        # Find tree final level (Tree Height)\\n        self.root = root\\n        node = root\\n        self.level = -1\\n        while node:\\n            node = node.left\\n            self.level += 1\\n\\n        # Start Binary Search\\n        left = 0\\n        right = 2 ** self.level - 1\\n\\n        # If it\\'s full binary tree then directly return # nodes\\n        if self.check_node(right):\\n            return 2 ** self.level + right\\n\\n        while left < right - 1:\\n            mid = (left + right) // 2\\n            if self.check_node(mid):\\n                left = mid\\n            else:\\n                right = mid\\n\\n        return 2 ** self.level + left\\n\\n    def check_node(self, idx):\\n        node = self.root\\n        # The order if search path could be regarded as binary value converted from index\\n        # Make sure the len(order) = self.level\\n        order = format(idx, \\'0{}b\\'.format(self.level))\\n        for num in order:\\n            if num == \\'0\\':\\n                node = node.left\\n            else:\\n                node = node.right\\n        return True if node else False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        return 1 + self.countNodes(root.right) + self.countNodes(root.left) if root else 0\\n```\n```\\nNumber of Nodes = 2 ** (level number) - 1 + final level nodes number\\n```\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n\\n        self.last_level_count = 0\\n        self.level = 0\\n        # Stop flag to end searching\\n        self.stop = 0\\n\\n        # Start with -1 since the searching ends on the children of leafs (None)\\n        # Make -1 offset then self.level can be the real value\\n        self.dfs(root, -1)\\n        return 2 ** self.level - 1 + self.last_level_count // 2\\n\\n    def dfs(self, node, level):\\n        if self.stop:\\n            return\\n\\n        if not node:\\n            self.level = max(self.level, level)\\n            # If the reaches the final level, then count 1\\n            # Note this is actually counting for # of children (None) of final level nodes\\n            if self.level == level:\\n                self.last_level_count += 1\\n            else:\\n                self.stop = 1\\n            return\\n\\n        self.dfs(node.left, level + 1)\\n        self.dfs(node.right, level + 1)\\n```\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n\\n        # Find tree final level (Tree Height)\\n        self.root = root\\n        node = root\\n        self.level = -1\\n        while node:\\n            node = node.left\\n            self.level += 1\\n\\n        # Start Binary Search\\n        left = 0\\n        right = 2 ** self.level - 1\\n\\n        # If it\\'s full binary tree then directly return # nodes\\n        if self.check_node(right):\\n            return 2 ** self.level + right\\n\\n        while left < right - 1:\\n            mid = (left + right) // 2\\n            if self.check_node(mid):\\n                left = mid\\n            else:\\n                right = mid\\n\\n        return 2 ** self.level + left\\n\\n    def check_node(self, idx):\\n        node = self.root\\n        # The order if search path could be regarded as binary value converted from index\\n        # Make sure the len(order) = self.level\\n        order = format(idx, \\'0{}b\\'.format(self.level))\\n        for num in order:\\n            if num == \\'0\\':\\n                node = node.left\\n            else:\\n                node = node.right\\n        return True if node else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157868,
                "title": "i-m-really-confused-by-the-top-solution-which-beats-100",
                "content": "The top solution is as below:\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        if(root->val!=INT_MIN){\\n            root->val=INT_MIN;\\n            return 1+countNodes(root->left)+countNodes(root->right);\\n        }\\n        else return 0;\\n    }\\n};\\n```\\n\\nWhy is it necessary to reset traversed nodes to INT_MIN? I don\\'t see how the traverse can skip any node by doing this, as the traverse only visits each node once.\\nCould anyone pls shine some light on how it\\'s more efficient than normal DFS which gets TLE:\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        if(root->val!=INT_MIN){\\n            root->val=INT_MIN;\\n            return 1+countNodes(root->left)+countNodes(root->right);\\n        }\\n        else return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62075,
                "title": "an-extremely-fast-solution-with-o-log-n-time-using-bit-manipulation-and-binary-search",
                "content": "I want to share an efficient solution of mine for this problem, which is extremely fast because the time complexity is indeed O(log N) !\\nI will explain my solution here:\\n\\nTake the following complete binary tree as our example:\\n\\n              1\\n            /   \\\\\\n           2     3\\n         /  \\\\   / \\\\\\n        4    5 6   7\\n       / \\\\   /\\n      8  9  10\\n\\nThis problem is solved according to the following steps:\\n\\n1) Get the maximal height **h** of the tree. Here, **h** = 3.\\n\\n2) Number the nodes in the lowest level starting from 0. In the above example, the nodes 8,9,10 are numbered 0, 1, 2. (If there are more nodes like 11, 12, 13, they will also be numbered.)\\n\\n3) Look at the binary pattern of the assigned numbers. For example, the number of node 10 is **3**, its binary pattern is **011**. Start walking from the root of the tree according to the binary pattern from left to right, go to the left child when encountered bit **0**, go to the right child encountered bit **1**. You will finally end at the node in the lowest level, or encountered **NULL**.\\n\\n4) If you encountered **NULL**, it suggests that the number of existing nodes in the lowest level are less than that number. So, we can use binary searching to find the number of the last node in the lowest level.\\n\\n5) When **h** and the assigned number **n** of the last node in the lowest level is found, the number of all nodes in the complete binary tree is there.\\n\\nThe solution is as follows:\\n\\n    class Solution {\\n    public:\\n        int countNodes(TreeNode* root) {\\n            if ( !root ) return 0;\\n            int h = 0;\\n            TreeNode* p = root;\\n            while ( p->left ) {\\n                h++;\\n                p = p->left;\\n            }\\n            int full_nodes = pow(2, h) - 1;\\n            // the nodes in the lowest level are numbered from 0 to 2^h - 1\\n            int low = 0, high = pow(2, h) - 1;\\n            while ( low <= high ) {\\n                int n = (low + high) / 2;\\n                int mask = 0;\\n                if ( h > 0 ) {\\n                    mask = (1 << (h - 1));\\n                }\\n                TreeNode* p = root;\\n                while ( mask ) {\\n                    if ( mask & n ) {\\n                        p = p->right;\\n                    } else {\\n                        p = p->left;\\n                    }\\n                    mask >>= 1;\\n                }\\n                if ( !p ) {\\n                    high = n - 1;\\n                } else {\\n                    low = n + 1;\\n                }\\n            }\\n            return full_nodes + low;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int countNodes(TreeNode* root) {\\n            if ( !root ) return 0;\\n            int h = 0;\\n            TreeNode* p = root;\\n            while ( p->left ) {\\n                h++;\\n                p = p->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3646801,
                "title": "count-total-nodes-in-a-complete-binary-tree-o-log-2-n-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int countNodes(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        int leftHeight = findHeightLeft(root);\\n        int rightHeight = findHeightRight(root);\\n        \\n        if(leftHeight == rightHeight)\\n            return (1<<rightHeight) - 1;\\n        \\n        else\\n            return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n    \\n    int findHeightLeft(TreeNode* root){\\n        int height = 0;\\n        while(root){\\n            height++;\\n            root = root->left;\\n        }\\n        return height;\\n    }\\n    \\n    int findHeightRight(TreeNode* root){\\n        int height = 0;\\n        while(root){\\n            height++;\\n            root = root->right;\\n        }\\n        return height;\\n    }\\n};\\n```\\n\\n**Please upvote!! if you like**\\ncomment below!\\uD83D\\uDC47\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int countNodes(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        int leftHeight = findHeightLeft(root);\\n        int rightHeight = findHeightRight(root);\\n        \\n        if(leftHeight == rightHeight)\\n            return (1<<rightHeight) - 1;\\n        \\n        else\\n            return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n    \\n    int findHeightLeft(TreeNode* root){\\n        int height = 0;\\n        while(root){\\n            height++;\\n            root = root->left;\\n        }\\n        return height;\\n    }\\n    \\n    int findHeightRight(TreeNode* root){\\n        int height = 0;\\n        while(root){\\n            height++;\\n            root = root->right;\\n        }\\n        return height;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508708,
                "title": "easy-optimized-c-code-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Auxillary stack space fore recursive calls\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int leftHeight(TreeNode* root){\\n        if(!root)\\n        return 0;\\n\\n        return 1+leftHeight(root->left);\\n    }\\n\\n    int rightHeight(TreeNode* root){\\n        if(!root)\\n        return 0;\\n\\n        return 1+rightHeight(root->right);\\n    }\\n\\n\\n    int countNodes(TreeNode* root) {\\n        if(!root)\\n        return 0;\\n\\n        int lh=leftHeight(root);\\n        int rh=rightHeight(root);\\n\\n        if(lh==rh){\\n            return (2<<(lh-1)) -1;   //or pow(2,lh)\\n        } \\n        return 1+ countNodes(root->left)+countNodes(root->right);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int leftHeight(TreeNode* root){\\n        if(!root)\\n        return 0;\\n\\n        return 1+leftHeight(root->left);\\n    }\\n\\n    int rightHeight(TreeNode* root){\\n        if(!root)\\n        return 0;\\n\\n        return 1+rightHeight(root->right);\\n    }\\n\\n\\n    int countNodes(TreeNode* root) {\\n        if(!root)\\n        return 0;\\n\\n        int lh=leftHeight(root);\\n        int rh=rightHeight(root);\\n\\n        if(lh==rh){\\n            return (2<<(lh-1)) -1;   //or pow(2,lh)\\n        } \\n        return 1+ countNodes(root->left)+countNodes(root->right);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817249,
                "title": "two-short-solutions",
                "content": "The most straightforward solution requires O(n) time:\\n```csharp\\npublic class Solution\\n{\\n    public int CountNodes(TreeNode n) =>\\n        n is null ? 0 : 1 + CountNodes(n.left) + CountNodes(n.right);\\n}\\n```\\n\\nThe more advanced approach works in O((log n)^2). Here we do not count the nodes if the tree is a perfect binary tree. Instead we just return a power of two: `1 << height - 1`. This is a basic formula. You can read about it here: https://en.wikipedia.org/wiki/Binary_tree\\n```csharp\\npublic class Solution\\n{\\n    public int CountNodes(TreeNode n)\\n    {\\n        if (n is null) return 0;\\n        int h = GetHeight(n, toLeft: true);\\n        return h == GetHeight(n, toLeft: false)\\n            ? (1 << h) - 1\\n            : 1 + CountNodes(n.left) + CountNodes(n.right);\\n        \\n        int GetHeight(TreeNode n, bool toLeft)\\n        {\\n            if (n is null) return 0;\\n            int res = 1;\\n            while ((n = toLeft ? n.left : n.right) is not null) res++;\\n            return res;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int CountNodes(TreeNode n) =>\\n        n is null ? 0 : 1 + CountNodes(n.left) + CountNodes(n.right);\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public int CountNodes(TreeNode n)\\n    {\\n        if (n is null) return 0;\\n        int h = GetHeight(n, toLeft: true);\\n        return h == GetHeight(n, toLeft: false)\\n            ? (1 << h) - 1\\n            : 1 + CountNodes(n.left) + CountNodes(n.right);\\n        \\n        int GetHeight(TreeNode n, bool toLeft)\\n        {\\n            if (n is null) return 0;\\n            int res = 1;\\n            while ((n = toLeft ? n.left : n.right) is not null) res++;\\n            return res;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816979,
                "title": "python-simple-python-solution-using-two-approach-bfs-dfs",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using DFS :-\\n# Runtime: 101 ms, faster than 82.04% of Python3 online submissions for Count Complete Tree Nodes.\\n# Memory Usage: 21.5 MB, less than 46.74% of Python3 online submissions for Count Complete Tree Nodes.\\n\\t\\n\\tclass Solution:\\n\\t\\tdef countNodes(self, root: Optional[TreeNode]) -> int:\\n\\n\\t\\t\\tself.result = 0\\n\\n\\t\\t\\tdef DFS(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tself.result = self.result + 1\\n\\n\\t\\t\\t\\tDFS(node.left)\\n\\t\\t\\t\\tDFS(node.right)\\n\\n\\t\\t\\tDFS(root)\\n\\t\\t\\treturn self.result\\n\\n# Approach 2 Using BFS :-\\n# Runtime: 178 ms, faster than 48.71% of Python3 online submissions for Count Complete Tree Nodes.\\n# Memory Usage: 21.3 MB, less than 87.06% of Python3 online submissions for Count Complete Tree Nodes.\\n\\t\\n\\tclass Solution:\\n\\t\\tdef countNodes(self, root: Optional[TreeNode]) -> int:\\n\\n\\t\\t\\tdef BFS(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tqueue = [node]\\n\\t\\t\\t\\tself.result = 0\\n\\n\\t\\t\\t\\twhile queue:\\n\\n\\t\\t\\t\\t\\tcurrent_node = queue.pop()\\n\\t\\t\\t\\t\\tself.result = self.result + 1\\n\\n\\t\\t\\t\\t\\tif current_node.left != None:\\n\\t\\t\\t\\t\\t\\tqueue.append(current_node.left)\\n\\t\\t\\t\\t\\tif current_node.right != None:\\n\\t\\t\\t\\t\\t\\tqueue.append(current_node.right)\\n\\n\\t\\t\\t\\treturn self.result\\n\\n\\t\\t\\treturn BFS(root)\\n\\n# Thank You \\uD83D\\uDC4D\\uD83D\\uDE4F",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using DFS :-\\n# Runtime: 101 ms, faster than 82.04% of Python3 online submissions for Count Complete Tree Nodes.\\n# Memory Usage: 21.5 MB, less than 46.74% of Python3 online submissions for Count Complete Tree Nodes.\\n\\t\\n\\tclass Solution:\\n\\t\\tdef countNodes(self, root: Optional[TreeNode]) -> int:\\n\\n\\t\\t\\tself.result = 0\\n\\n\\t\\t\\tdef DFS(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tself.result = self.result + 1\\n\\n\\t\\t\\t\\tDFS(node.left)\\n\\t\\t\\t\\tDFS(node.right)\\n\\n\\t\\t\\tDFS(root)\\n\\t\\t\\treturn self.result\\n\\n# Approach 2 Using BFS :-\\n# Runtime: 178 ms, faster than 48.71% of Python3 online submissions for Count Complete Tree Nodes.\\n# Memory Usage: 21.3 MB, less than 87.06% of Python3 online submissions for Count Complete Tree Nodes.\\n\\t\\n\\tclass Solution:\\n\\t\\tdef countNodes(self, root: Optional[TreeNode]) -> int:\\n\\n\\t\\t\\tdef BFS(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tqueue = [node]\\n\\t\\t\\t\\tself.result = 0\\n\\n\\t\\t\\t\\twhile queue:\\n\\n\\t\\t\\t\\t\\tcurrent_node = queue.pop()\\n\\t\\t\\t\\t\\tself.result = self.result + 1\\n\\n\\t\\t\\t\\t\\tif current_node.left != None:\\n\\t\\t\\t\\t\\t\\tqueue.append(current_node.left)\\n\\t\\t\\t\\t\\tif current_node.right != None:\\n\\t\\t\\t\\t\\t\\tqueue.append(current_node.right)\\n\\n\\t\\t\\t\\treturn self.result\\n\\n\\t\\t\\treturn BFS(root)\\n\\n# Thank You \\uD83D\\uDC4D\\uD83D\\uDE4F",
                "codeTag": "Java"
            },
            {
                "id": 2815866,
                "title": "1-line-dfs-c-solution-time-o-n-space-o-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to count the number of vertices. For this, any passage through the tree will do.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nRecursively traverse each vertex. If it exists then return 1.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        return !root ? 0 : 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        return !root ? 0 : 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815685,
                "title": "java-2-lines-code100-faster-0ms",
                "content": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root == null ) return 0 ;\\n        return countNodes(root.left ) +countNodes(root.right )  + 1;\\n    }\\n}\\n**Upvote please**\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root == null ) return 0 ;\\n        return countNodes(root.left ) +countNodes(root.right )  + 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2815572,
                "title": "python-sides-checking",
                "content": "**Solution**:\\nSince we are working with complete binary tree, there are full nodes at all levels execept for the last level where nodes are packed to the left. There are two cases to consider:\\n\\n1. If the height of left side are equal to the height of the right side, then the tree are perfect. Thus, the number of nodes are 2\\\\**height - 1\\n\\n```\\n    Ex: \\n          1\\n      2       2\\n    3   3   3   3\\n\\n    left == right == 3 => #s of nodes = 2**3 - 1 = 7 \\n```\\n\\n2. If the height of both sides are not equal, we have to check each side seperately and sum up the number of nodes. \\n```\\n    Ex: \\n          1\\n      2       2\\n    3   3   3   \\n\\n    left == 3 != right == 2\\n    Thus, \\n    #s of nodes = 1 + count(left) + count(right) \\n                = 1 + 2**2 - 1 + (1 + count(right.left) + count(right.right)) \\n                = 1 + 2**2 - 1 + (1 + 2**1-1 + 2**0-1) \\n                = 1 + 3 + 1 + 1 \\n                = 6\\n```\\n**Complexity**:\\n    Time: O(logn)\\n    Space: O(logn)\\n\\t\\n```\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n\\n        # Find the height of the left side\\n        def leftHeight(node):\\n            return 0 if not node else 1 + leftHeight(node.left)\\n\\n        # Find the height of the right side\\n        def rightHeight(node):\\n            return 0 if not node else 1 + rightHeight(node.right)\\n\\n        # Count the number of nodes in a tree starting from a given node\\n        def count(node):\\n\\n            # If there is no node, return 0\\n            if not node:\\n                return 0\\n\\n            # Find height of both sides\\n            left, right = leftHeight(node), rightHeight(node)\\n\\n            # If they are equal, we have a perfect binary tree\\n            if left == right:\\n                return 2 ** (left) - 1\\n\\n            # Else, count each subtree seperately\\n            return 1 + count(node.left) + count(node.right)\\n\\n        return count(root)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    Ex: \\n          1\\n      2       2\\n    3   3   3   3\\n\\n    left == right == 3 => #s of nodes = 2**3 - 1 = 7 \\n```\n```\\n    Ex: \\n          1\\n      2       2\\n    3   3   3   \\n\\n    left == 3 != right == 2\\n    Thus, \\n    #s of nodes = 1 + count(left) + count(right) \\n                = 1 + 2**2 - 1 + (1 + count(right.left) + count(right.right)) \\n                = 1 + 2**2 - 1 + (1 + 2**1-1 + 2**0-1) \\n                = 1 + 3 + 1 + 1 \\n                = 6\\n```\n```\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n\\n        # Find the height of the left side\\n        def leftHeight(node):\\n            return 0 if not node else 1 + leftHeight(node.left)\\n\\n        # Find the height of the right side\\n        def rightHeight(node):\\n            return 0 if not node else 1 + rightHeight(node.right)\\n\\n        # Count the number of nodes in a tree starting from a given node\\n        def count(node):\\n\\n            # If there is no node, return 0\\n            if not node:\\n                return 0\\n\\n            # Find height of both sides\\n            left, right = leftHeight(node), rightHeight(node)\\n\\n            # If they are equal, we have a perfect binary tree\\n            if left == right:\\n                return 2 ** (left) - 1\\n\\n            # Else, count each subtree seperately\\n            return 1 + count(node.left) + count(node.right)\\n\\n        return count(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539484,
                "title": "very-easy-to-understand-java-2-liner",
                "content": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if (root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if (root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808826,
                "title": "easy-explanation-brute-to-optimized-c-solution",
                "content": "**Approach1**: Using Tree Traversal techniques(preorder, postorder, inorder)\\nJust traverse the tree using any traversal technique and increment your count variable and return.\\n```\\nvoid inorder(TreeNode* root, int& count)\\n    {\\n        if(root==NULL)\\n            return;\\n        count++;\\n        inorder(root->left, count);\\n        inorder(root->right, count);\\n    }\\n    int countNodes(TreeNode* root) {\\n        int count=0;\\n        inorder(root, count);\\n        return count;\\n    }\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(h)~O(logn) for recursion\\n\\n**Approach2**: We will make use of the property of Complete Binary Tree. Now consider the example below\\n![image](https://assets.leetcode.com/users/images/5c406a38-dce4-4c47-b931-cfd0d02a4c55_1646114452.6606946.png)\\n\\nIn this case the tree is a full binary tree and the number of nodes will be 2^h -1 (where h= height of binary tree) in this case h=3, so the number of nodes would be 2^3-1 = 7. But what if we dont have 7th node i.e. example below\\n![image](https://assets.leetcode.com/users/images/b543e9cc-8baa-4e37-ad52-9e98d0269c14_1646114586.1379333.png)\\n\\nIn this case also h=3, but since it is not a full binary tree we cannot say that number of nodes will be 2^h-1. After analising the above two examples we can say that if the left height and the right height of a subtree are equal, that subtree is a full subtree and we can easily apply our formula. Otherwise we can say that number of nodes=1+leftSubtreeNodes+RightSubtreeNodes. Let us look at this through an example\\n\\n![image](https://assets.leetcode.com/users/images/0e11fa3e-87c4-4798-9470-46c1ed6c34eb_1646115395.6510472.png)\\nFrom node 2 we can apply our formula, no. of nodes=2^2-1=3\\nFrom node3, we can recursively find no. of nodes as =1+countleftnodes+countrightnodes\\n![image](https://assets.leetcode.com/users/images/b0ab11b9-9955-49e3-858c-d810bc7a5878_1646115780.567602.png)\\nSince from node1, leftheight=3, rightheight=2\\n```\\nint leftheight(TreeNode* root)\\n   {\\n       int h=0;\\n       while(root)\\n       {\\n           h++;\\n           root=root->left;\\n       }\\n       return h;\\n   }\\n    int rightheight(TreeNode* root)\\n   {\\n       int h=0;\\n       while(root)\\n       {\\n           h++;\\n           root=root->right;\\n       }\\n       return h;\\n   }\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int leftsubtreeheight=leftheight(root);\\n        int rightsubtreeheight=rightheight(root);\\n        \\n        if(leftsubtreeheight == rightsubtreeheight)\\n            return pow(2, leftsubtreeheight)-1;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n```\\nTime Complexity: O(logn ^2) because log n for height of the tree(complete binary tree) and log n for the number of nodes.\\nSpace Complexity: O(log n)",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\nvoid inorder(TreeNode* root, int& count)\\n    {\\n        if(root==NULL)\\n            return;\\n        count++;\\n        inorder(root->left, count);\\n        inorder(root->right, count);\\n    }\\n    int countNodes(TreeNode* root) {\\n        int count=0;\\n        inorder(root, count);\\n        return count;\\n    }\\n```\n```\\nint leftheight(TreeNode* root)\\n   {\\n       int h=0;\\n       while(root)\\n       {\\n           h++;\\n           root=root->left;\\n       }\\n       return h;\\n   }\\n    int rightheight(TreeNode* root)\\n   {\\n       int h=0;\\n       while(root)\\n       {\\n           h++;\\n           root=root->right;\\n       }\\n       return h;\\n   }\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int leftsubtreeheight=leftheight(root);\\n        int rightsubtreeheight=rightheight(root);\\n        \\n        if(leftsubtreeheight == rightsubtreeheight)\\n            return pow(2, leftsubtreeheight)-1;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538100,
                "title": "simple-to-understand-using-recursion-with-comments",
                "content": "The idea is to find whether a subtree is full binary tree or not. If it is then we can directly count the nodes, otherwise check recursively.\\n\\nIf the heights of the left tree and right tree are same, then we can confidently say that the left subtree is full (Even right may be full, but we are not sure), but we can surely say that left subtree is full [This is because in a complete binary tree left sub tree is filled first and then the right subtree is filled).\\n\\n```\\npublic class Solution {\\n    public int CountNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        // If height of left and right tree are same, left tree must be full tree\\n        int leftHeight = GetHeight(root.left);\\n        \\n        // If height of left and right are different, right tree must be full tree\\n        int rightHeight = GetHeight(root.right);\\n        \\n        if (leftHeight == rightHeight) {\\n            return (int)Math.Pow(2, leftHeight) + CountNodes(root.right);\\n        } else {\\n            return (int)Math.Pow(2, rightHeight) + CountNodes(root.left);\\n        }\\n    }\\n    \\n    private int GetHeight(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        }        \\n        return 1 + GetHeight(node.left);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        // If height of left and right tree are same, left tree must be full tree\\n        int leftHeight = GetHeight(root.left);\\n        \\n        // If height of left and right are different, right tree must be full tree\\n        int rightHeight = GetHeight(root.right);\\n        \\n        if (leftHeight == rightHeight) {\\n            return (int)Math.Pow(2, leftHeight) + CountNodes(root.right);\\n        } else {\\n            return (int)Math.Pow(2, rightHeight) + CountNodes(root.left);\\n        }\\n    }\\n    \\n    private int GetHeight(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        }        \\n        return 1 + GetHeight(node.left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537848,
                "title": "c-easy-solution-less-than-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        int height_left=0, height_right=0;\\n        TreeNode * tr=root, *tl=root;\\n        while(tr){tr=tr->right; ++height_right;}\\n        while(tl){tl=tl->left; ++height_left;}\\n        // cout<<height_left<<\" \"<<height_right<<\"\\\\n\";\\n        if(height_left==height_right) return pow(2,height_right)-1;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        int height_left=0, height_right=0;\\n        TreeNode * tr=root, *tl=root;\\n        while(tr){tr=tr->right; ++height_right;}\\n        while(tl){tl=tl->left; ++height_left;}\\n        // cout<<height_left<<\" \"<<height_right<<\"\\\\n\";\\n        if(height_left==height_right) return pow(2,height_right)-1;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1537770,
                "title": "short-logn-2-solution-with-detailed-explanation",
                "content": "Notice that if the tree is **100% filled**, there would be **2^h - 1** nodes\\nFor example if h == 3: \\n\\tnumber of nodes = 1 + 2 + 4 (1st, 2nd and 3rd level) = 2^3 - 1 = 7\\n\\nKnowing that, we just need to compute the tree\\'s height on the left and right side\\nIf left height == right height (tree is 100% filled), we can apply the formula above \\nOtherwise count the root and all nodes on root.left and root.right recursively\\n\\n```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        get_left_height = lambda root: 0 if root is None else 1 + get_left_height(root.left)\\n        get_right_height = lambda root: 0 if root is None else 1 + get_right_height(root.right)\\n        \\n        left_height, right_height = get_left_height(root), get_right_height(root)\\n        \\n        if left_height == right_height:  # tree is 100% filled\\n            return 2**left_height - 1  # or 2**right_height - 1, they\\'re equal\\n        \\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n```\\nTime: O((logn)^2)\\n\\tComputing left and right height on every level takes O(logn) time\\n\\tThere are at most logn levels",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        get_left_height = lambda root: 0 if root is None else 1 + get_left_height(root.left)\\n        get_right_height = lambda root: 0 if root is None else 1 + get_right_height(root.right)\\n        \\n        left_height, right_height = get_left_height(root), get_right_height(root)\\n        \\n        if left_height == right_height:  # tree is 100% filled\\n            return 2**left_height - 1  # or 2**right_height - 1, they\\'re equal\\n        \\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298021,
                "title": "c-two-line-recursive-solution-in-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738651,
                "title": "java-most-efficient-approach-o-log-n-2",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int lh=0,rh=0;\\n        TreeNode curr=root;\\n        while(curr!=null)\\n        {\\n            lh++;\\n            curr=curr.left;\\n        }\\n        curr=root;\\n        while(curr!=null)\\n        {\\n            rh++;\\n            curr=curr.right;\\n        }\\n        if(lh == rh)\\n            return (int)Math.pow(2,lh)-1;\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int lh=0,rh=0;\\n        TreeNode curr=root;\\n        while(curr!=null)\\n        {\\n            lh++;\\n            curr=curr.left;\\n        }\\n        curr=root;\\n        while(curr!=null)\\n        {\\n            rh++;\\n            curr=curr.right;\\n        }\\n        if(lh == rh)\\n            return (int)Math.pow(2,lh)-1;\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733609,
                "title": "python3-simple-binary-search-o-log-n-log-n",
                "content": "```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root: return 0\\n\\n        def dfs(node):\\n            if not node: return 0\\n\\n            left = node.left\\n            left_count = 1\\n            while left:\\n                left = left.left\\n                left_count += 1\\n\\n            right = node.right\\n            right_count = 1\\n            while right:\\n                right = right.right\\n                right_count += 1\\n\\n            if left_count == right_count:\\n                return (2**left_count) - 1\\n            else:\\n                left = dfs(node.left)\\n                right = dfs(node.right)\\n\\n                return left + right + 1\\n        \\n        return dfs(root)\\n```\\n\\nReference:\\nhttps://www.youtube.com/watch?v=CvrPf1-flAA\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root: return 0\\n\\n        def dfs(node):\\n            if not node: return 0\\n\\n            left = node.left\\n            left_count = 1\\n            while left:\\n                left = left.left\\n                left_count += 1\\n\\n            right = node.right\\n            right_count = 1\\n            while right:\\n                right = right.right\\n                right_count += 1\\n\\n            if left_count == right_count:\\n                return (2**left_count) - 1\\n            else:\\n                left = dfs(node.left)\\n                right = dfs(node.right)\\n\\n                return left + right + 1\\n        \\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702232,
                "title": "c-o-log-n-2-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\n    int height(TreeNode* node) {\\n        int h = 0;\\n        while (node) {\\n            ++h;\\n            node = node->left;\\n        }\\n        return h;\\n    }\\npublic:\\n    int countNodes(TreeNode* root) {\\n        int res = 0;\\n        while (root) {\\n            const int leftHeight = height(root->left);\\n            if (leftHeight > height(root->right)) {\\n                res += 1 << leftHeight >> 1;\\n                root = root->left;\\n            }\\n            else {\\n                res += 1 << leftHeight;\\n                root = root->right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    int height(TreeNode* node) {\\n        int h = 0;\\n        while (node) {\\n            ++h;\\n            node = node->left;\\n        }\\n        return h;\\n    }\\npublic:\\n    int countNodes(TreeNode* root) {\\n        int res = 0;\\n        while (root) {\\n            const int leftHeight = height(root->left);\\n            if (leftHeight > height(root->right)) {\\n                res += 1 << leftHeight >> 1;\\n                root = root->left;\\n            }\\n            else {\\n                res += 1 << leftHeight;\\n                root = root->right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490413,
                "title": "java-binary-search-solution-o-lg-n-2-time-complexity",
                "content": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int h = height(root);\\n        return h == 0 ? 0 : binarySearch(root, (int)Math.pow(2, h - 1), (int)Math.pow(2, h)) - 1;\\n    }\\n\\n    private int height(TreeNode root) {\\n        return root == null ? 0 : 1 + height(root.left);\\n    }\\n\\n    private int binarySearch(TreeNode root, int st, int en) {\\n        if(st == en) {\\n            return st;\\n        }\\n        int mid = st + (en - st) / 2;\\n        Stack<Integer> step = new Stack<>();\\n        int curr = mid;\\n        while(curr > 1) {\\n            step.push(curr % 2);\\n            curr /= 2;\\n        }\\n        TreeNode node = root;\\n        while(!step.isEmpty()) {\\n            node = step.pop() == 0 ? node.left : node.right;\\n        }\\n        return node == null ? binarySearch(root, st, mid) : binarySearch(root, mid + 1, en);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int h = height(root);\\n        return h == 0 ? 0 : binarySearch(root, (int)Math.pow(2, h - 1), (int)Math.pow(2, h)) - 1;\\n    }\\n\\n    private int height(TreeNode root) {\\n        return root == null ? 0 : 1 + height(root.left);\\n    }\\n\\n    private int binarySearch(TreeNode root, int st, int en) {\\n        if(st == en) {\\n            return st;\\n        }\\n        int mid = st + (en - st) / 2;\\n        Stack<Integer> step = new Stack<>();\\n        int curr = mid;\\n        while(curr > 1) {\\n            step.push(curr % 2);\\n            curr /= 2;\\n        }\\n        TreeNode node = root;\\n        while(!step.isEmpty()) {\\n            node = step.pop() == 0 ? node.left : node.right;\\n        }\\n        return node == null ? binarySearch(root, st, mid) : binarySearch(root, mid + 1, en);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442644,
                "title": "beat-99-3-python-easy-understand",
                "content": "Assume last layer of nodes\\' indexes are range from 0 - 2 ( height - 1) - 1\\nThen use binary search find the index of the last right node.\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        height = 0\\n        cur = root\\n        while cur:\\n            height += 1\\n            cur = cur.left\\n           \\n        start, end = 0, 2 ** (height - 1) - 1\\n        while start + 1 < end:\\n            mid = start + (end - start) // 2\\n            \\n            if self.is_valid_leaf(mid, root, height):\\n                start = mid\\n            else:\\n                end = mid\\n        \\n        if self.is_valid_leaf(end, root, height):\\n            \\n            return 2 ** (height - 1) + end\\n        \\n        return 2 ** (height - 1) + start\\n    \\n    def is_valid_leaf(self, index, root, height):\\n        s, e = 0, 2 ** (height - 1) - 1\\n        cur = root\\n        for i in range(height - 1):\\n            mid = s + (e - s) // 2\\n            if mid >= index:\\n                cur = cur.left\\n                e = mid\\n            else:\\n                cur = cur.right\\n                s = mid + 1\\n        \\n        return cur != None\\n\\'\\'\\'",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "Assume last layer of nodes\\' indexes are range from 0 - 2 ( height - 1) - 1\\nThen use binary search find the index of the last right node.\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        height = 0\\n        cur = root\\n        while cur:\\n            height += 1\\n            cur = cur.left\\n           \\n        start, end = 0, 2 ** (height - 1) - 1\\n        while start + 1 < end:\\n            mid = start + (end - start) // 2\\n            \\n            if self.is_valid_leaf(mid, root, height):\\n                start = mid\\n            else:\\n                end = mid\\n        \\n        if self.is_valid_leaf(end, root, height):\\n            \\n            return 2 ** (height - 1) + end\\n        \\n        return 2 ** (height - 1) + start\\n    \\n    def is_valid_leaf(self, index, root, height):\\n        s, e = 0, 2 ** (height - 1) - 1\\n        cur = root\\n        for i in range(height - 1):\\n            mid = s + (e - s) // 2\\n            if mid >= index:\\n                cur = cur.left\\n                e = mid\\n            else:\\n                cur = cur.right\\n                s = mid + 1\\n        \\n        return cur != None\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 194695,
                "title": "c-32ms-o-log-n-log-log-n",
                "content": "First we get the height of the tree and compute the sum, assuming that it is a complete tree.\\nThe idea is finding the depth of leftest branch because it would be the deepest one of the subtree.\\nEach time compare the tree height between the leftest branch of left child and leftest branch of right child.\\nIf they are equal, then the gap (the place makes tree not complete) lies in right child, and we move to there.\\nIf they are not equal, then the gap lies in left child or in between, and we have to subtract the missing node in right child.\\nThis gives us Time Complexity of sum_(h = 1)^(h = log(n)) (log(h)).\\nSo we find that the integral of log(x) for x from 1 to x is xlog(x).\\nFor this problem, it\\'s xlog(x) when x = log(n), which is log(n)log(log(n)).\\n```\\nclass Solution {\\nprivate:\\n    int getLeftDepth(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        return getLeftDepth(root->left) + 1;\\n    }\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        int h = getLeftDepth(root);\\n        TreeNode* curr = root;\\n        int lh = h, rh = h, nextH = h;\\n        int ans = (1 << h) - 1;\\n        while (curr->left != NULL) {\\n            nextH--;\\n            lh = getLeftDepth(curr->left);\\n            rh = getLeftDepth(curr->right);\\n            if (rh < lh) {\\n                ans -= (1 << rh);\\n                curr = curr->left;\\n            }\\n            else\\n                curr = curr->right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getLeftDepth(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        return getLeftDepth(root->left) + 1;\\n    }\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        int h = getLeftDepth(root);\\n        TreeNode* curr = root;\\n        int lh = h, rh = h, nextH = h;\\n        int ans = (1 << h) - 1;\\n        while (curr->left != NULL) {\\n            nextH--;\\n            lh = getLeftDepth(curr->left);\\n            rh = getLeftDepth(curr->right);\\n            if (rh < lh) {\\n                ans -= (1 << rh);\\n                curr = curr->left;\\n            }\\n            else\\n                curr = curr->right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62019,
                "title": "beating-99-84-submissions-in-c-quite-intuitive-and-well-commented",
                "content": "What are we doing here is to collect the additional last-level `leaves`, always stick this in mind when reading the code below.\\n\\n\\n----------\\n\\n\\n    class Solution {\\n    public:\\n        int countNodes(TreeNode* root) \\n        {\\n            if(!root) return 0;\\n            int height = 0, sum = 0, i = 0;\\n            TreeNode *t = root, *t0 = NULL;\\n            while(t) t = t->left, height++; //get the height of the tree;\\n            t = root;\\n            int level = height - 2; //levels under the child of root;\\n            while(level > -1) //collect the bottom-level nodes by halving them apart;\\n            {\\n                t0 = t->left;\\n                for(i = 0; i < level; ++i) t0 = t0->right; \\n                if(t0) { sum += 1<<level; t = t->right; } //rightmost node is not null;\\n                else t = t->left;\\n                level--; //move to the next level;\\n            }\\n            if(t) sum++; //if it's a complete tree, collect the last right node;\\n            return sum+((1<<(height-1))-1);\\n        }  \\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int countNodes(TreeNode* root) \\n        {\\n            if(!root) return 0;\\n            int height = 0, sum = 0, i = 0;\\n            TreeNode *t = root, *t0 = NULL;\\n            while(t) t = t->left, height++; //get the height of the tree;\\n            t = root;\\n            int level = height - 2; //levels under the child of root;\\n            while(level > -1) //collect the bottom-level nodes by halving them apart;\\n            {\\n                t0 = t->left;\\n                for(i = 0; i < level; ++i) t0 = t0->right; \\n                if(t0) { sum += 1<<level; t = t->right; }",
                "codeTag": "Java"
            },
            {
                "id": 62001,
                "title": "i-found-this-solution-very-helpful-80-ms-solution-consise-and-efficient-beats-90-submissions",
                "content": "    int countNodes(TreeNode* root) {\\n            if(!root) return 0;\\n            int num=1;\\n            TreeNode *curR(root->left), *curL(root->left);\\n            while(curR) // curR is the rightmost edge, which has a height equal to or less than the leftmost edge\\n            {\\n                curL = curL->left;\\n                curR = curR->right;\\n                num = num<<1;\\n            }\\n            return  num + ( (!curL)?countNodes(root->right):countNodes(root->left) );\\n        }",
                "solutionTags": [],
                "code": "    int countNodes(TreeNode* root) {\\n            if(!root) return 0;\\n            int num=1;\\n            TreeNode *curR(root->left), *curL(root->left);\\n            while(curR) // curR is the rightmost edge, which has a height equal to or less than the leftmost edge\\n            {\\n                curL = curL->left;\\n                curR = curR->right;\\n                num = num<<1;\\n            }\\n            return  num + ( (!curL)?countNodes(root->right):countNodes(root->left) );\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3858236,
                "title": "c-solution-easy-to-understand-beats-99-26",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int lf = heightleft(root);\\n        int rt = heightright(root);\\n\\n        if(lf==rt){\\n            return (1<<lf)-1;\\n        }\\n        else{\\n           return 1 + countNodes(root->left) + countNodes(root->right);\\n        }\\n    }\\n        int heightleft(TreeNode* node){\\n            int height=0;\\n            while(node){\\n                height++;\\n                node=node->left;\\n            }\\n            return height; \\n        }\\n\\n          int heightright(TreeNode* node){\\n            int height=0;\\n            while(node){\\n                height++;\\n                node=node->right;\\n            }\\n        return height;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int lf = heightleft(root);\\n        int rt = heightright(root);\\n\\n        if(lf==rt){\\n            return (1<<lf)-1;\\n        }\\n        else{\\n           return 1 + countNodes(root->left) + countNodes(root->right);\\n        }\\n    }\\n        int heightleft(TreeNode* node){\\n            int height=0;\\n            while(node){\\n                height++;\\n                node=node->left;\\n            }\\n            return height; \\n        }\\n\\n          int heightright(TreeNode* node){\\n            int height=0;\\n            while(node){\\n                height++;\\n                node=node->right;\\n            }\\n        return height;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760068,
                "title": "4-possible-solution-have-a-look",
                "content": "# All Possible Ways : Brute .... To..... Optimised \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Method 1 : BFS --> O(N)\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        int ans=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node->left)q.push(node->left);\\n            if(node->right)q.push(node->right);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Method 2 : DFS(1) --> O(N)\\n```\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root , int &ans){\\n        if(root==NULL) return;\\n\\n        ans++;\\n        preorder(root->left,ans);\\n        preorder(root->right,ans); \\n    }\\n    int countNodes(TreeNode* root) {\\n        int ans=0;\\n        preorder(root,ans); // in / post \\n        return ans;\\n    }\\n};\\n```\\n# Method 3 : DFS(2) --> O(N)\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL) return 0;\\n\\n        int left = countNodes(root->left);\\n        int right= countNodes(root->right);\\n        \\n        return 1+left+right;\\n    }\\n};\\n```\\n# Method 4 : Optimised --> log(N)^2\\n```\\nclass Solution {\\npublic:\\n//----------------------------------------------------------------//\\n    int left_height(TreeNode* node)\\n    {\\n        int height=0;\\n        while(node)\\n        {\\n            height++;\\n            node =node->left;\\n        }\\n        return height;\\n    }\\n//----------------------------------------------------------------//\\n    int right_height(TreeNode* node)\\n    {\\n        int height=0;\\n        while(node)\\n        {\\n            height++;\\n            node =node->right;\\n        }\\n        return height;\\n    }\\n//----------------------------------------------------------------//\\n    int countNodes(TreeNode* root){\\n        if(root==NULL) return 0;\\n\\n        int lh= left_height(root);\\n        int rh= right_height(root);\\n\\n        if(lh==rh) return pow(2,lh)-1;\\n\\n        return 1 + countNodes(root->left) + countNodes(root->right) ;\\n    }\\n};\\n```\\n\\n![Screenshot 2023-07-23 001856.png](https://assets.leetcode.com/users/images/31bcad87-82a0-4678-9082-3379d40d08f4_1690051926.5468698.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        int ans=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node->left)q.push(node->left);\\n            if(node->right)q.push(node->right);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root , int &ans){\\n        if(root==NULL) return;\\n\\n        ans++;\\n        preorder(root->left,ans);\\n        preorder(root->right,ans); \\n    }\\n    int countNodes(TreeNode* root) {\\n        int ans=0;\\n        preorder(root,ans); // in / post \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL) return 0;\\n\\n        int left = countNodes(root->left);\\n        int right= countNodes(root->right);\\n        \\n        return 1+left+right;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//----------------------------------------------------------------//\\n    int left_height(TreeNode* node)\\n    {\\n        int height=0;\\n        while(node)\\n        {\\n            height++;\\n            node =node->left;\\n        }\\n        return height;\\n    }\\n//----------------------------------------------------------------//\\n    int right_height(TreeNode* node)\\n    {\\n        int height=0;\\n        while(node)\\n        {\\n            height++;\\n            node =node->right;\\n        }\\n        return height;\\n    }\\n//----------------------------------------------------------------//\\n    int countNodes(TreeNode* root){\\n        if(root==NULL) return 0;\\n\\n        int lh= left_height(root);\\n        int rh= right_height(root);\\n\\n        if(lh==rh) return pow(2,lh)-1;\\n\\n        return 1 + countNodes(root->left) + countNodes(root->right) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623086,
                "title": "c-solution-with-less-time-complexity-than-o-n-and-with-no-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main intuition behind this approach is that we just need to find the righmost node in the last level of the tree so we can do a **BINARY SEARCH** for it and leave a whole subtree to search for which reduces the time complexity and just go down to a path directly which leads us to the rightmost node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will first calculate the maximum level of the subtree (I have assigned root to the 0th level).\\n- Then we will assign a pointer to the root and find whether the middle node has the level equal to the maximum level of the tree or not by either traversing down the leftmost node in the right subtree or rightmost node in the left subtree (I have implemented the first one. Note that the maths involved may vary.)\\n- If the middle node has the same level as that of the tree itself, it implies that the left subtree of the node at which our pointer is pointing currently is completely filled and the rightmost leaf node is in the right subtree, so we need not to traverse the left subtree, we move our pointer, initially assigned to root, to its right child and repeat the process until the pointer itself points to the leaf node which is the last node.\\n- Else we move our pointer to the left child because the rightmost leaf node must be in the left subtree of the current pointing node.\\n\\n- Whenever we move to the right child of the current pointing node, we increment our answer by the number of leaf nodes that we are not checking in the left subtree, which will be equal to the $$2^r/2$$, where $$r$$ is the maximum level of that subtree which can be calculated while going down to find the middle node of that subtree.\\nIn the end we may add all the nodes in the above fully filled levels to the answer which will be $$2^k$$, where k is the maximum level of the whole subtree.\\n\\n# Complexity\\n- Time complexity: $$O((logN)^2)$$ (If I calculated correctly hopefully)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> Note - It\\'s my first attempt to write any solution, do write a comment if you want to ask something or may feel if something is wrong :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) // if no root exists, answer would be 0\\n            return 0;\\n        int maxlevel = 0, ans = 0;\\n        TreeNode *ptr = root, *temp = root; // creating variable pointers \\'ptr\\' for iterating the main tree and \\'temp\\' for iterating a subtree whether left of right\\n        while(ptr->left){ // finding the maximum level of the tree by going down to find the leftmost node\\n            ptr = ptr->left;\\n            maxlevel++;\\n        }\\n        int currlevel = 0; // \\'currlevel\\' stores the current level of the \\'ptr\\' pointer\\n        ptr = root;\\n        while(currlevel<maxlevel){\\n            temp = ptr->right; // finding the middle node\\n            int templevel = 0; // for finding the maximum level of the right subtree of the currently pointing node\\n            if(temp)\\n                templevel++;\\n            while(temp && temp->left){\\n                temp = temp->left;\\n                templevel++;\\n            }\\n            if(templevel+currlevel==maxlevel){ // if the middle node has the level same as that of the maximum level of the main tree\\n                ptr = ptr->right;\\n                ans += (1<<(templevel-1));\\n            }\\n            else\\n                ptr = ptr->left;\\n            currlevel++;\\n        }\\n        ans += (1<<maxlevel); // adding all the nodes in the above fully filled levels\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) // if no root exists, answer would be 0\\n            return 0;\\n        int maxlevel = 0, ans = 0;\\n        TreeNode *ptr = root, *temp = root; // creating variable pointers \\'ptr\\' for iterating the main tree and \\'temp\\' for iterating a subtree whether left of right\\n        while(ptr->left){ // finding the maximum level of the tree by going down to find the leftmost node\\n            ptr = ptr->left;\\n            maxlevel++;\\n        }\\n        int currlevel = 0; // \\'currlevel\\' stores the current level of the \\'ptr\\' pointer\\n        ptr = root;\\n        while(currlevel<maxlevel){\\n            temp = ptr->right; // finding the middle node\\n            int templevel = 0; // for finding the maximum level of the right subtree of the currently pointing node\\n            if(temp)\\n                templevel++;\\n            while(temp && temp->left){\\n                temp = temp->left;\\n                templevel++;\\n            }\\n            if(templevel+currlevel==maxlevel){ // if the middle node has the level same as that of the maximum level of the main tree\\n                ptr = ptr->right;\\n                ans += (1<<(templevel-1));\\n            }\\n            else\\n                ptr = ptr->left;\\n            currlevel++;\\n        }\\n        ans += (1<<maxlevel); // adding all the nodes in the above fully filled levels\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298755,
                "title": "222-leetcode-count-nodes-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int solve(TreeNode root){\\n        if(root==null)\\n            return 0;\\n        if(root.left==null && root.right==null)\\n            return 1;\\n        int lh = solve(root.left);\\n        int rh = solve(root.right);\\n        return 1+lh+rh;\\n    }\\n    public int countNodes(TreeNode root) {\\n        return solve(root);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int solve(TreeNode root){\\n        if(root==null)\\n            return 0;\\n        if(root.left==null && root.right==null)\\n            return 1;\\n        int lh = solve(root.left);\\n        int rh = solve(root.right);\\n        return 1+lh+rh;\\n    }\\n    public int countNodes(TreeNode root) {\\n        return solve(root);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815807,
                "title": "simple-4-lines-code-o-n-inorder",
                "content": "# Intuition\\n- DFS Inorder \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Check for the deepest node and count nodes.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Recursive Stack Spcae (Neglegible)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        \\n        if( root == NULL ) return 0 ;\\n\\n        int left = countNodes( root ->left );\\n        int right = countNodes( root ->right );\\n\\n        return 1 + (left+right) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        \\n        if( root == NULL ) return 0 ;\\n\\n        int left = countNodes( root ->left );\\n        int right = countNodes( root ->right );\\n\\n        return 1 + (left+right) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815541,
                "title": "c-dfs-optimized-faster-easy-to-understand",
                "content": "* ***Using DFS***\\n\\n* ***Time Complexity :- O(logN * logN)***\\n\\n* ***Space Complexity :- O(height of tree i.e. O(logN))***\\n\\n```\\n// No. of nodes in a full binary tree of height h is (2 ^ h - 1)\\n\\nclass Solution {\\npublic:\\n    \\n    int countNodes(TreeNode* root) {\\n        \\n        // base case\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        // find left height and right height for root\\n        \\n        int left_height = 0;\\n        \\n        int right_height = 0;\\n        \\n        TreeNode* left_pointer = root;\\n        \\n        TreeNode* right_pointer = root;\\n        \\n        // cal. left height\\n        \\n        while(left_pointer)\\n        {\\n            left_height++;\\n            \\n            left_pointer = left_pointer -> left;\\n        }\\n        \\n        // cal. right height\\n        \\n        while(right_pointer)\\n        {\\n            right_height++;\\n            \\n            right_pointer = right_pointer -> right;\\n        }\\n        \\n        // if left_height == right_height, then no. of nodes in subtree will be pow(2, h) - 1\\n        \\n        if(left_height == right_height)\\n            return pow(2, left_height) - 1;\\n        \\n        // if left_height != right_height then calculate no. of nodes for both the left subtree and right subtree\\n        \\n        return 1 + countNodes(root -> left) + countNodes(root -> right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n// No. of nodes in a full binary tree of height h is (2 ^ h - 1)\\n\\nclass Solution {\\npublic:\\n    \\n    int countNodes(TreeNode* root) {\\n        \\n        // base case\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        // find left height and right height for root\\n        \\n        int left_height = 0;\\n        \\n        int right_height = 0;\\n        \\n        TreeNode* left_pointer = root;\\n        \\n        TreeNode* right_pointer = root;\\n        \\n        // cal. left height\\n        \\n        while(left_pointer)\\n        {\\n            left_height++;\\n            \\n            left_pointer = left_pointer -> left;\\n        }\\n        \\n        // cal. right height\\n        \\n        while(right_pointer)\\n        {\\n            right_height++;\\n            \\n            right_pointer = right_pointer -> right;\\n        }\\n        \\n        // if left_height == right_height, then no. of nodes in subtree will be pow(2, h) - 1\\n        \\n        if(left_height == right_height)\\n            return pow(2, left_height) - 1;\\n        \\n        // if left_height != right_height then calculate no. of nodes for both the left subtree and right subtree\\n        \\n        return 1 + countNodes(root -> left) + countNodes(root -> right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815444,
                "title": "2-line-solution-easy-solution-beats-90-submissions-recursion-c-binary-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        \\n        return 1 + solve(root->left) + solve(root->right);\\n    }\\n    int countNodes(TreeNode* root) {\\n        return solve(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        \\n        return 1 + solve(root->left) + solve(root->right);\\n    }\\n    int countNodes(TreeNode* root) {\\n        return solve(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815376,
                "title": "2-approaches-preorder-traversal-level-order-traversal-beginner-friendly-c-solution",
                "content": "**Approach**\\nwe will simply calulate the number of nodes level wise and that will be required output\\n**time complexity** - O(n);\\n**method 1**\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n     \\n        int count=0;\\n        if(root==NULL)\\n            return 0;\\n        \\n       queue<TreeNode*>q;\\n        q.emplace(root);\\n        \\n        while(!q.empty())\\n        {\\n            root=q.front();\\n            q.pop();\\n            if(root==NULL)\\n            {\\n               if(!q.empty())\\n                   q.push(NULL);\\n             }\\n            else\\n            {\\n                count++;\\n                if(root->left)\\n                    q.push(root->left);\\n                if(root->right)\\n                    q.push(root->right);\\n             }\\n         }\\n        \\n        return count;\\n    }\\n};\\n```\\n**method 2**\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &count)\\n    {\\n      if(root==NULL)\\n          return;\\n        \\n      count++;\\n      if(root->left) solve(root->left,count);\\n      if(root->right) solve(root->right,count);\\n  \\n     }\\n    int countNodes(TreeNode* root) {\\n      int count=0;\\n      solve(root,count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n     \\n        int count=0;\\n        if(root==NULL)\\n            return 0;\\n        \\n       queue<TreeNode*>q;\\n        q.emplace(root);\\n        \\n        while(!q.empty())\\n        {\\n            root=q.front();\\n            q.pop();\\n            if(root==NULL)\\n            {\\n               if(!q.empty())\\n                   q.push(NULL);\\n             }\\n            else\\n            {\\n                count++;\\n                if(root->left)\\n                    q.push(root->left);\\n                if(root->right)\\n                    q.push(root->right);\\n             }\\n         }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &count)\\n    {\\n      if(root==NULL)\\n          return;\\n        \\n      count++;\\n      if(root->left) solve(root->left,count);\\n      if(root->right) solve(root->right,count);\\n  \\n     }\\n    int countNodes(TreeNode* root) {\\n      int count=0;\\n      solve(root,count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130611,
                "title": "o-logn-logn-solution-using-binary-search",
                "content": "The solution to this question is very elegant, here binary search is utilised to check whether the number of nodes in the last level. The checker function is implemented as such, that it goes to the last second level and check whether the particular node exists or not. Finally we return the answer after adding the number of nodes on every particular level.\\nFeel free to suggest any edits or ask any query \\u2282(\\u25C9\\u203F\\u25C9)\\u3064\\n```\\nclass Solution {\\npublic:\\n    int dfsLeft(TreeNode* temp) // finding the depth of the tree\\n    {\\n        if(temp->left==NULL)\\n            return 1;\\n        return 1+dfsLeft(temp->left);\\n    }\\n    bool check(TreeNode* temp, int x, int depth) // for checking whether this particular node exists or not\\n    {\\n        int d=(1<<depth);\\n        if(depth==1)\\n        {\\n            // base condition\\n            if(x==1)\\n            {\\n                if(temp->left==NULL)\\n                    return 0;\\n                return 1;\\n            }\\n            else\\n            {\\n                if(temp->right==NULL)\\n                    return 0;\\n                return 1;\\n            }\\n        }\\n        if(x>d/2)\\n        {\\n            int y=x-(d/2);\\n            if(check(temp->right,y,depth-1))\\n                return 1;\\n            return 0;\\n        }\\n        else\\n        {\\n            if(check(temp->left,x,depth-1))\\n                return 1;\\n            return 0;\\n        }\\n    }\\n    int countNodes(TreeNode* root) {\\n        TreeNode* temp=root;\\n        if(root==NULL)\\n            return 0;\\n        if(root->left==NULL)\\n            return 1;\\n        if(root->right==NULL)\\n            return 2;\\n        int depth=dfsLeft(temp);\\n        int ans=0,count=1;\\n        int low=1,high=(1<<(depth-1));\\n        int mid=(low+high)/2;\\n        while(low<=high)\\n        {\\n            // cout<<low<<\" \"<<high<<\" \"<<mid<<endl;\\n            mid=(low+high)/2;\\n            temp=root;\\n            if(check(temp,mid,depth-1))\\n            {\\n                low=mid+1;\\n                count=mid;\\n            }\\n            else high=mid-1;\\n        }\\n        for(int i=0;i<depth-1;i++)\\n            ans+=(1<<i);\\n        ans+=count;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfsLeft(TreeNode* temp) // finding the depth of the tree\\n    {\\n        if(temp->left==NULL)\\n            return 1;\\n        return 1+dfsLeft(temp->left);\\n    }\\n    bool check(TreeNode* temp, int x, int depth) // for checking whether this particular node exists or not\\n    {\\n        int d=(1<<depth);\\n        if(depth==1)\\n        {\\n            // base condition\\n            if(x==1)\\n            {\\n                if(temp->left==NULL)\\n                    return 0;\\n                return 1;\\n            }\\n            else\\n            {\\n                if(temp->right==NULL)\\n                    return 0;\\n                return 1;\\n            }\\n        }\\n        if(x>d/2)\\n        {\\n            int y=x-(d/2);\\n            if(check(temp->right,y,depth-1))\\n                return 1;\\n            return 0;\\n        }\\n        else\\n        {\\n            if(check(temp->left,x,depth-1))\\n                return 1;\\n            return 0;\\n        }\\n    }\\n    int countNodes(TreeNode* root) {\\n        TreeNode* temp=root;\\n        if(root==NULL)\\n            return 0;\\n        if(root->left==NULL)\\n            return 1;\\n        if(root->right==NULL)\\n            return 2;\\n        int depth=dfsLeft(temp);\\n        int ans=0,count=1;\\n        int low=1,high=(1<<(depth-1));\\n        int mid=(low+high)/2;\\n        while(low<=high)\\n        {\\n            // cout<<low<<\" \"<<high<<\" \"<<mid<<endl;\\n            mid=(low+high)/2;\\n            temp=root;\\n            if(check(temp,mid,depth-1))\\n            {\\n                low=mid+1;\\n                count=mid;\\n            }\\n            else high=mid-1;\\n        }\\n        for(int i=0;i<depth-1;i++)\\n            ans+=(1<<i);\\n        ans+=count;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1461319,
                "title": "binary-search-bit-pattern",
                "content": "### Idea\\n- Total number of nodes = total number of nodes not in the last level + nodes in the last level\\n- total number of nodes not in the last level = 2^h - 1\\n- total number of nodes in the last level can be found using binary search\\n- `exist` is the core of the algorithm. Index nodes starting with 1, the leftmost node of level i (root is at level 0) is indexed 2^i. For node x, each 1 in the binary digit means going right, each 0 means going left (ignore the leftmost 1). Example: 4 means root->left->left, 3 means root->right.\\n\\n```C++\\nclass Solution {\\n    int getHeight(TreeNode *node) {\\n        int height = 0;\\n        while (node && node->left) {\\n            ++height;\\n            node = node->left;\\n        }\\n        return height;\\n    }\\n\\n    bool exist(TreeNode* node, int idx, int h) {\\n        int mask = (1 << h) >> 1; // Use (1 << h) >> 1 to replace 1 << (h-1). Consider h = 0.\\n        while (mask) {\\n            node = (mask & idx) ? node->right : node->left;\\n            mask >>= 1;\\n            \\n            if (!node) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int countNodes(TreeNode* root) {\\n        if (!root) return 0;\\n        int h = getHeight(root);\\n        int start = 1 << h, end = (start << 1);\\n        while (start < end) {\\n            int mid = (start + end) >> 1;\\n            if (exist(root, mid, h)) start = mid+1;\\n            else end = mid;\\n        }\\n        return (1 << h)-1 + (start - (1<<h));\\n    }\\n};\\n```\\n\\n### Implementation issue\\n- Use `(1 << h) >> 1` instead of `1 << (h-1)`. Edge case: h = 0.\\n- For the binary search, `end` is set to be `(start<<1)` instead of `(start << 1) -1` at the beginning. We are finding the leftmost index that does NOT exist. \\n\\n\\nReference:\\nhttps://leetcode-cn.com/problems/count-complete-tree-nodes/solution/wan-quan-er-cha-shu-de-jie-dian-ge-shu-by-leetco-2/1056014\\n",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\n    int getHeight(TreeNode *node) {\\n        int height = 0;\\n        while (node && node->left) {\\n            ++height;\\n            node = node->left;\\n        }\\n        return height;\\n    }\\n\\n    bool exist(TreeNode* node, int idx, int h) {\\n        int mask = (1 << h) >> 1; // Use (1 << h) >> 1 to replace 1 << (h-1). Consider h = 0.\\n        while (mask) {\\n            node = (mask & idx) ? node->right : node->left;\\n            mask >>= 1;\\n            \\n            if (!node) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int countNodes(TreeNode* root) {\\n        if (!root) return 0;\\n        int h = getHeight(root);\\n        int start = 1 << h, end = (start << 1);\\n        while (start < end) {\\n            int mid = (start + end) >> 1;\\n            if (exist(root, mid, h)) start = mid+1;\\n            else end = mid;\\n        }\\n        return (1 << h)-1 + (start - (1<<h));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368788,
                "title": "java-o-log-2-n-time-with-o-1-space",
                "content": "![image](https://assets.leetcode.com/users/images/dfdfb971-6976-4568-af15-7b0139b69610_1627492207.6966398.png)\\n\\nWe First consider the maximum possible and minimum possible nodes from the depth of the tree.\\nThen we try to narrow down the range of possible nodes by searching in the tree. As you can see the in every subtree we take left or right based on whether the node we are searching is in the left subtree or right subtree.\\n\\nLet\\'s take an example. (The values mentioned in the diagram are not necessarily node\\'s values. they are just numbered sequentially for understanding). For a height of 4. the minimum = 8. and maximum = 15. Let\\'s say we want to navigate to the 10th node. Currently we are root node which is 1. Then the whole range of the subtree we have is 8 to 15. The middle of this is 8 + (15-8)/2 = 8 + 3 = 11. So we have to take left.. so 1->left => 2. Now the range becomes 8 to 11. Now the subtreeMiddle is 8 + (11 - 8)/2 = 8 + 1 = 9. But out target is 10. so we take right and the range is 10 to 11. Now the subtreeMiddle is 10. so we take left. We have reached the node and it is present. We are now sure that the minimum number of nodes is atleast 10.  So we make minimumNodes = 10 and maximumNodes to 15. Same way we then look for the existence of the node 12 afterwards and minimum becomes 12. now we check for 13 it is also present.  Then range minimizes to [13,14]. Now the node 14 is not present. Hence we reduce maximum = 13. Now minimum and maximum becomes equals and the loop terminates. Thus we have found the number of nodes in the complete binary tree.\\n\\n\\nTime Complexity : `O(log^2  (N))` [log squared N]\\nBecause we do binary search inside another binary search both of which take logarithmic of N. \\n\\nSpace Complexity : `O(1)`\\nWe do not use any extra space.\\n\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if (root == null) {// base case\\n            return 0;\\n        } else if (root.left == null && root.right == null) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n        int depth = 0;\\n        TreeNode node = root;\\n        while (node.left != null) {// compute the depth of the tree\\n            node = node.left;\\n            depth++;\\n        }\\n        \\n        int maximumNodes = 1;\\n         \\n        int temp = depth;\\n        while (temp-- > 0){\\n            maximumNodes = (maximumNodes << 1) | 1;//maximum possible nodes in the complete binary tree of this depth\\n        }\\n        \\n        int minimumNodes = (maximumNodes >> 1 ) + 1;// minimum possible nodes in the complete binary tree of this depth\\n        \\n        int offsetLow = minimumNodes;\\n        int offsetHigh = maximumNodes;\\n        \\n        while (minimumNodes < maximumNodes) {\\n            \\n            int middle = minimumNodes + (maximumNodes - minimumNodes)/2;\\n            \\n            if (maximumNodes - minimumNodes == 1) {\\n                middle = maximumNodes;\\n            }\\n            \\n            int currentDepth = 0;\\n            node = root;\\n            int left = offsetLow;\\n            int right = offsetHigh;\\n            while (currentDepth < depth) {// search for the existence of the middle node in the tree\\n                int subTreeMiddle = left + (right - left)/2;\\n                if (middle <= subTreeMiddle) {\\n                    node = node.left;\\n                    right = subTreeMiddle;\\n                } else {\\n                    node = node.right;\\n                    left = subTreeMiddle + 1;\\n                }\\n                currentDepth++;\\n            }\\n            \\n            if (node != null) {\\n                minimumNodes = middle;\\n            } else {\\n                maximumNodes = middle-1;\\n            }\\n        }\\n        \\n        return maximumNodes;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if (root == null) {// base case\\n            return 0;\\n        } else if (root.left == null && root.right == null) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n        int depth = 0;\\n        TreeNode node = root;\\n        while (node.left != null) {// compute the depth of the tree\\n            node = node.left;\\n            depth++;\\n        }\\n        \\n        int maximumNodes = 1;\\n         \\n        int temp = depth;\\n        while (temp-- > 0){\\n            maximumNodes = (maximumNodes << 1) | 1;//maximum possible nodes in the complete binary tree of this depth\\n        }\\n        \\n        int minimumNodes = (maximumNodes >> 1 ) + 1;// minimum possible nodes in the complete binary tree of this depth\\n        \\n        int offsetLow = minimumNodes;\\n        int offsetHigh = maximumNodes;\\n        \\n        while (minimumNodes < maximumNodes) {\\n            \\n            int middle = minimumNodes + (maximumNodes - minimumNodes)/2;\\n            \\n            if (maximumNodes - minimumNodes == 1) {\\n                middle = maximumNodes;\\n            }\\n            \\n            int currentDepth = 0;\\n            node = root;\\n            int left = offsetLow;\\n            int right = offsetHigh;\\n            while (currentDepth < depth) {// search for the existence of the middle node in the tree\\n                int subTreeMiddle = left + (right - left)/2;\\n                if (middle <= subTreeMiddle) {\\n                    node = node.left;\\n                    right = subTreeMiddle;\\n                } else {\\n                    node = node.right;\\n                    left = subTreeMiddle + 1;\\n                }\\n                currentDepth++;\\n            }\\n            \\n            if (node != null) {\\n                minimumNodes = middle;\\n            } else {\\n                maximumNodes = middle-1;\\n            }\\n        }\\n        \\n        return maximumNodes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336627,
                "title": "0ms-simple-less-than-o-n-solution",
                "content": "Imagine if my tree is a complete binary tree, and I know the height then I can always find the no of nodes by just finding (pow(2, height) - 1). That\\'s exactly what I\\'ve done, if my subtree is a complete binary tree, that I checked by finding height of both right and left sides. If it is then apply (pow(2, height) - 1). If not then apply the normal approach.\\n\\n```\\n    public int countNodes(TreeNode root) {\\n        \\n        if(root == null) return 0;\\n        \\n        TreeNode left = root;\\n        TreeNode right = root;\\n        \\n        int leftHeight = 0;\\n        int rightHeight = 0;\\n        \\n        while(left != null){\\n            \\n            left = left.left;\\n            leftHeight++;\\n            \\n        }\\n        \\n        while(right != null){\\n            \\n            right = right.right;\\n            rightHeight++;\\n            \\n        }\\n        \\n        if(leftHeight == rightHeight) return (1 << leftHeight) - 1;\\n        \\n        \\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countNodes(TreeNode root) {\\n        \\n        if(root == null) return 0;\\n        \\n        TreeNode left = root;\\n        TreeNode right = root;\\n        \\n        int leftHeight = 0;\\n        int rightHeight = 0;\\n        \\n        while(left != null){\\n            \\n            left = left.left;\\n            leftHeight++;\\n            \\n        }\\n        \\n        while(right != null){\\n            \\n            right = right.right;\\n            rightHeight++;\\n            \\n        }\\n        \\n        if(leftHeight == rightHeight) return (1 << leftHeight) - 1;\\n        \\n        \\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1268215,
                "title": "python-solution-binary-search-bit-manipulation",
                "content": "In this problem, we really only care about figuring out how many nodes there are in the last row. As long as we can do this, we can easily figure out the number of nodes in the tree. My idea was to use binary search to find out where the very last leaf node is located.\\n\\nFor a while, I was thinking, how can we use binary search when we don\\'t have a way to \"index\" into the row of leaf nodes like we can index into an array? But I realized that we actually can \"index\" into the leaf nodes. If we consider a binary tree where 0 indicates going to the left child, and 1 indicates going to the right child, we can easily use binary digits to traverse the tree and index into the ith leaf node, if it exists. This \"indexing\" takes O(h) time. For example,\\n\\n![image](https://assets.leetcode.com/users/images/9236fcf4-2f24-4cdb-b9b9-87a428775740_1623534238.2108598.jpeg)\\n\\n\\nAs you can see in the image, the leaf nodes are in the range [0, 2^h-1]. Given this insight, I performed binary search on this range. Here\\'s my code.\\n\\n\\n\\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        h = self.get_height(root)\\n        lo, hi = 0, (2**h)-1\\n        furthest_right = 0\\n        while lo <= hi:\\n            m = lo + (hi - lo) // 2\\n            if self.has_leaf(root, m, h-1):\\n                furthest_right = m\\n                lo = m + 1\\n            else:\\n                hi = m - 1\\n        return (2**h - 1) + (furthest_right + 1) \\n        \\n        \\n    def has_leaf(self, root: TreeNode, index: int, bit: int) -> TreeNode:\\n        \"\"\"\\n        Checks to see if the tree has a leaf node at this index \\n        \"\"\"\\n        while root and bit >= 0:\\n            if index & (1 << bit):\\n                root = root.right\\n            else:\\n                root = root.left\\n            bit -= 1\\n        \\n        return root\\n        \\n        \\n    def get_height(self, root: TreeNode) -> int:\\n        \"\"\"\\n        Gets the height of binary tree, which is the number of edges on the path from root\\n        to the furthest leaf node which is guaranteed to be the leftmost leaf based on definition\\n        of complete binary tree\\n        \"\"\"\\n        count = -1\\n        while root:\\n            count += 1\\n            root = root.left\\n        return count\\n```\\n\\n\\nFor runtime complexity, this is binary search so we can follow the traditional analysis of a divide and conquer algorithm by writing down the recurrence relation.\\n\\nFor a complete binary tree with n nodes, we eliminate approximately half of the nodes each time we perform binary search and each call does O(h) work where h = log(n) since it is a complete tree. Given this, we can write down the recurrence relation\\n\\nT(n) = T(n/2) + O(log(n))\\n\\n\\nIf we simplify this recurrence relation, we get T(n) = O(log(n) * log(n)) which is the runtime of this algorithm.\\n\\n\\nIt was quite interesting to see how people were able to come up with different solutions that have the same runtime, so definitely recommend taking a look at some other solutions to learn other ways of thinking about problems!\\n\\n\\n\\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        h = self.get_height(root)\\n        lo, hi = 0, (2**h)-1\\n        furthest_right = 0\\n        while lo <= hi:\\n            m = lo + (hi - lo) // 2\\n            if self.has_leaf(root, m, h-1):\\n                furthest_right = m\\n                lo = m + 1\\n            else:\\n                hi = m - 1\\n        return (2**h - 1) + (furthest_right + 1) \\n        \\n        \\n    def has_leaf(self, root: TreeNode, index: int, bit: int) -> TreeNode:\\n        \"\"\"\\n        Checks to see if the tree has a leaf node at this index \\n        \"\"\"\\n        while root and bit >= 0:\\n            if index & (1 << bit):\\n                root = root.right\\n            else:\\n                root = root.left\\n            bit -= 1\\n        \\n        return root\\n        \\n        \\n    def get_height(self, root: TreeNode) -> int:\\n        \"\"\"\\n        Gets the height of binary tree, which is the number of edges on the path from root\\n        to the furthest leaf node which is guaranteed to be the leftmost leaf based on definition\\n        of complete binary tree\\n        \"\"\"\\n        count = -1\\n        while root:\\n            count += 1\\n            root = root.left\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168308,
                "title": "java-o-logn-logn-solution-with-comments-runtime-0-ms-faster-than-100-00",
                "content": "The problem can be solved by doing inorder, postorder, preorder and level order traversals, which will have a time complexity of O(n).\\n\\nHowever, the follow-up requests for a solution faster than O(n). This solution is approx. - O(logn x logn), as we move through half of branches at a time for each visited node\\'s sub-tree.\\n\\nThe main idea here is to use the Complete binary tree property i.e. all levels are filled except the last one from left to right. \\n\\nSo, if a sub-tree is fully complete, that means that the left traversal to deepest node will be equal to right traversal of the deepest node. \\nApplying the formula- 2^depth - 1, we can find the number of nodes for this sub-tree.\\n\\nWe perform this recursively to find the total number of nodes. A leaf node always has equal left traversal depth and right traversal depth i.e. 1\\n\\nYou can do dry-runs on multiple examples to visualise and understand how it works.\\n\\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        \\n\\t\\t// If node is null, we return 0 count\\n        if(root == null) {\\n            return 0;\\n        }\\n        \\n\\t\\t// We set curr variable to left node or the root of left sub-tree. \\n        TreeNode curr = root.left;\\n\\t\\t\\n\\t\\t// Including the current node, the initial depth is 1\\n        int leftDepth = 1; int rightDepth = 1;\\n        \\n\\t\\t// We traverse deep into the left childs to find the depth along left boundary of the sub-tree\\n        while(curr != null) {\\n            leftDepth++;\\n            curr = curr.left;\\n        }\\n        \\n\\t\\t// We reset the curr variable, so that we can find depth along the right child\\'s path\\n        curr = root.right;\\n        \\n\\t\\t// We traverse deep into the right childs to find the depth along right boundary of the sub-tree\\n        while(curr != null) {\\n            rightDepth++;\\n            curr = curr.right;\\n        }\\n        \\n\\t\\t/* If both leftDepth and rightDepth are the same, then this means the sub-tree is completely filled. \\n\\t\\t    Hence, we return the count via the formula. We no longer need to traverse any further on this sub-tree.*/\\n        if(leftDepth == rightDepth) {\\n            return ((int)Math.pow(2, leftDepth)) -1;\\n        }\\n        \\n\\t\\t/* If leftDepth and rightDepth are not the same, then there exists a deeper sub-tree which is not completely filled\\n\\t\\t   As we recurse further, we will find the subtree which is completely balanced \\n\\t\\t   i.e. every leaf node will have leftDepth and rightDepth equal to 1\\n\\t\\t   We add 1 to include the current node\\'s count. */\\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n}\\n```\\n\\n*Thank you for reading my post!\\nIf you found it helpful, please upvote or comment.*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        \\n\\t\\t// If node is null, we return 0 count\\n        if(root == null) {\\n            return 0;\\n        }\\n        \\n\\t\\t// We set curr variable to left node or the root of left sub-tree. \\n        TreeNode curr = root.left;\\n\\t\\t\\n\\t\\t// Including the current node, the initial depth is 1\\n        int leftDepth = 1; int rightDepth = 1;\\n        \\n\\t\\t// We traverse deep into the left childs to find the depth along left boundary of the sub-tree\\n        while(curr != null) {\\n            leftDepth++;\\n            curr = curr.left;\\n        }\\n        \\n\\t\\t// We reset the curr variable, so that we can find depth along the right child\\'s path\\n        curr = root.right;\\n        \\n\\t\\t// We traverse deep into the right childs to find the depth along right boundary of the sub-tree\\n        while(curr != null) {\\n            rightDepth++;\\n            curr = curr.right;\\n        }\\n        \\n\\t\\t/* If both leftDepth and rightDepth are the same, then this means the sub-tree is completely filled. \\n\\t\\t    Hence, we return the count via the formula. We no longer need to traverse any further on this sub-tree.*/\\n        if(leftDepth == rightDepth) {\\n            return ((int)Math.pow(2, leftDepth)) -1;\\n        }\\n        \\n\\t\\t/* If leftDepth and rightDepth are not the same, then there exists a deeper sub-tree which is not completely filled\\n\\t\\t   As we recurse further, we will find the subtree which is completely balanced \\n\\t\\t   i.e. every leaf node will have leftDepth and rightDepth equal to 1\\n\\t\\t   We add 1 to include the current node\\'s count. */\\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702882,
                "title": "figure-walkthrough-o-log-n-2-solution-by-path-check-using-binary-representation",
                "content": "# Counting Nodes in a Complete Binary Tree Optimally\\n# \\nThis solution calculates the answer in O(log(n)^2) time using binary search and a properties of complete binary tree. \\n\\nSince this is a complete binary tree, we can find the height in O(h) which is in O(log (n)) time by going to the left most node and keeping a counter. Let this be height be `h`. \\n\\nNow let\\'s consider a complete binary tree tree containing 12 nodes (3 less from a full binary tree of height 4) as below : \\n![image](https://assets.leetcode.com/users/images/2dbd5637-9cb0-4abd-b839-f4db5eca0995_1592972776.628361.png)\\n\\nThe logic to count nodes is is as follows :\\n1. Calculate height of the tree (4 in this case)\\n\\n\\n2. Count the number of nodes till the last but one level since the tree will have all nodes filled till that level. (7 in this case, calculated as `2^(h-1) - 1` = 2^3 -1 = 7\\n\\n\\n3. Now we need to find the last non empty position in the last level. Since the nodes in the last level are filled from left to right, we can use binary search to find which node is the last non null node. (this is node labelled `L` in this case)\\n\\n* \\tNumber of nodes in the last level are atmost `2^(h-1)` (8 in this case)\\n*  We binary search from `0 to 2^(h-1) - 1` where the 0th element represent the leftmost element in the last level and `2^(h-1) - 1th` element represent the right most node in the last level. \\n* \\tLet\\'s say `mid` is the position of node in the last level we\\'re looking for, we can check if the node exists in another `O(log(n))` time by using the binary representation of `mid` and going left if the `ith` bit is unset and right if the `ith` bit is set. \\n\\t* \\tIn this case let\\'s say mid = (0 + 7)/2 = 4\\n\\t* \\tBinary representation is in 3 bits since the largest position 7 requires 3 bits to represent. Binary represention of 4 : `100`\\n\\t* \\tThis means from `root` (`A` in this case) , go right `once` and left `twice`. This will take you to node `L`. Now will we try for mid = (5 + 7)/2 = 6, but the node at position 110 is NULL, so the node doesn\\'t exist. Now we go to the left side of the binary search, mid = (5 + 6)/2 = 5. The node at position 101 is also NULL.\\n\\t* \\tWe stop our binary search and the position of last valid node is 4 which means there are 5 nodes in the last level. We add this to the previously calculated value till the last but one level which is 7. The final answer is 7 + 5 = 12 nodes. \\n\\nHere is the code for the same :\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        if(root->left == NULL && root->right == NULL)\\n            return 1;\\n        \\n        int h = 0;\\n        TreeNode *temp = root;\\n        \\n\\t\\t//Calculate height\\n        while(temp) {\\n            temp = temp->left;\\n            h++;\\n        }\\n        \\n        int low = 0;\\n        int high = (1 << (h-1)) - 1; //Nodes in the last level\\n        \\n        int bits = h-1;\\n        \\n        int ans = -1;\\n        \\n        \\n        while(low <= high) {\\n            int mid = low + (high - low)/2;\\n                        \\n            if(pathExists(root, mid, 1 << (bits-1))) {\\n                ans = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        \\n        return (1 << (h-1)) + ans ; // ( (1 << (h-1)) - 1 )+ (ans + 1) = (1 << (h-1)) + ans\\n    }\\n\\t\\n    //Check if a node exists satisfying the given binary representation. \\n\\t//path is the binary path representation, bit is left most set bit in this case\\n    bool pathExists(TreeNode *root, int path, int bit) {\\n        \\n        if(bit == 0 && root) //Node exists\\n            return true;\\n        \\n        if(root == NULL) //Node does not exist\\n            return false;\\n                \\n        if((path & bit) != 0) //If the leftmost bit is 1, go to right else left\\n            return pathExists(root->right, path, bit >> 1);\\n        else\\n            return pathExists(root->left, path, bit >> 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        if(root->left == NULL && root->right == NULL)\\n            return 1;\\n        \\n        int h = 0;\\n        TreeNode *temp = root;\\n        \\n\\t\\t//Calculate height\\n        while(temp) {\\n            temp = temp->left;\\n            h++;\\n        }\\n        \\n        int low = 0;\\n        int high = (1 << (h-1)) - 1; //Nodes in the last level\\n        \\n        int bits = h-1;\\n        \\n        int ans = -1;\\n        \\n        \\n        while(low <= high) {\\n            int mid = low + (high - low)/2;\\n                        \\n            if(pathExists(root, mid, 1 << (bits-1))) {\\n                ans = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        \\n        return (1 << (h-1)) + ans ; // ( (1 << (h-1)) - 1 )+ (ans + 1) = (1 << (h-1)) + ans\\n    }\\n\\t\\n    //Check if a node exists satisfying the given binary representation. \\n\\t//path is the binary path representation, bit is left most set bit in this case\\n    bool pathExists(TreeNode *root, int path, int bit) {\\n        \\n        if(bit == 0 && root) //Node exists\\n            return true;\\n        \\n        if(root == NULL) //Node does not exist\\n            return false;\\n                \\n        if((path & bit) != 0) //If the leftmost bit is 1, go to right else left\\n            return pathExists(root->right, path, bit >> 1);\\n        else\\n            return pathExists(root->left, path, bit >> 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701577,
                "title": "python-python3-count-complete-tree-nodes",
                "content": "***Shameless-Self-Promotion***: My other leetcode [solutions](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts) to various questions can be found [here](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts)\\n\\n```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n```\\n\\nTime Complexity: ```O(n)```\\nSpace Complexity: ```O(Log(n))```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countNodes(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n```\n```O(n)```\n```O(Log(n))```",
                "codeTag": "Java"
            },
            {
                "id": 523520,
                "title": "i-think-test-cases-are-lacking",
                "content": "I manage to solve it with 2 lines of code that simply count the tree nodes and it pass all 18 test cases without TLE.\\nI understand that wasn\\'t the \"idea\" but I just wanted to see how brute force will work, and it worked :)\\nThe code is in C# but it\\'s probably Java and C++ almost perfect.\\n\\n```\\npublic class Solution {\\n    public int CountNodes(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        return 1 + CountNodes(root.left) + CountNodes(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountNodes(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        return 1 + CountNodes(root.left) + CountNodes(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411221,
                "title": "simple-javascript-solution",
                "content": "This was a fast javascript solution that I came up with - I thought that alot of the solutions just seemed very complex for the problem. I know it is not perfect but wanted to share:\\n\\n```\\n\\nvar countNodes = (root) => {\\n    if (!root) return 0;\\n    if (root.left == null && root.right == null) return 1;\\n    return countNodes(root.left) + countNodes(root.right) + 1;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar countNodes = (root) => {\\n    if (!root) return 0;\\n    if (root.left == null && root.right == null) return 1;\\n    return countNodes(root.left) + countNodes(root.right) + 1;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 303135,
                "title": "binary-encoding-on-the-path-99-66-72-67-python",
                "content": "Binary code (i.e. left-right-left-... as 010...) to determine a traverse path to the final layer and binary search on the code from 0 to 1 << (depth-1) to find the first leaf in the final layer is missing (O(logn) time for binary search, each search is O(logn) for traversing the tree) -- total (O(logn^2))\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def countNodes(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        # method2: use a binary code to define traverse path to end O(logn^2) - 60ms/99.66% - 27.6MB/72.67%\\n        # get the depth first by traversing along the left O(logn)\\n        depth = 0\\n        node = root\\n        while node:\\n            node = node.left\\n            depth += 1\\n        if depth <= 1: return depth             # trivial cases for empty or single node\\n        \\n        def canTraverse(code, bit_length):      # test if it can traverse by the path defined by code, in form of 01001\\n            mask = 1 << (bit_length-1)\\n            node = root\\n            while mask > 0:\\n                if code & mask: \\n                    node = node.right   # current bit is 0: traverse right\\n                else:\\n                    node = node.left    # current bit is 1: traverse left\\n                if not node:\\n                    return False        # hit an empty node, traverse stopped pre-maturally\\n                mask >>= 1\\n            return True                 # traverse finished -> canTraverse by this path defined by code\\n            \\n        # binary search to determine the first assumed leaf that cannot be traversed: O(logn * logn)\\n        l, u = 0, 1 << (depth - 1)    \\n        while l < u:\\n            m = (l + u) // 2\\n            if canTraverse(m, depth - 1):\\n                l = m + 1\\n            else:\\n                u = m\\n        n_missing = (1<<(depth-1)) - l  # number of missed leaves in the final layer\\n        return (1 << depth) - 1 - n_missing\\n",
                "solutionTags": [],
                "code": "Binary code (i.e. left-right-left-... as 010...) to determine a traverse path to the final layer and binary search on the code from 0 to 1 << (depth-1) to find the first leaf in the final layer is missing (O(logn) time for binary search, each search is O(logn) for traversing the tree) -- total (O(logn^2))\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def countNodes(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        # method2: use a binary code to define traverse path to end O(logn^2) - 60ms/99.66% - 27.6MB/72.67%\\n        # get the depth first by traversing along the left O(logn)\\n        depth = 0\\n        node = root\\n        while node:\\n            node = node.left\\n            depth += 1\\n        if depth <= 1: return depth             # trivial cases for empty or single node\\n        \\n        def canTraverse(code, bit_length):      # test if it can traverse by the path defined by code, in form of 01001\\n            mask = 1 << (bit_length-1)\\n            node = root\\n            while mask > 0:\\n                if code & mask: \\n                    node = node.right   # current bit is 0: traverse right\\n                else:\\n                    node = node.left    # current bit is 1: traverse left\\n                if not node:\\n                    return False        # hit an empty node, traverse stopped pre-maturally\\n                mask >>= 1\\n            return True                 # traverse finished -> canTraverse by this path defined by code\\n            \\n        # binary search to determine the first assumed leaf that cannot be traversed: O(logn * logn)\\n        l, u = 0, 1 << (depth - 1)    \\n        while l < u:\\n            m = (l + u) // 2\\n            if canTraverse(m, depth - 1):\\n                l = m + 1\\n            else:\\n                u = m\\n        n_missing = (1<<(depth-1)) - l  # number of missed leaves in the final layer\\n        return (1 << depth) - 1 - n_missing\\n",
                "codeTag": "Java"
            },
            {
                "id": 260273,
                "title": "recursive-java",
                "content": "public int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        } \\n        return countNodes(root.left) + countNodes(root.right) + 1;\\n    }",
                "solutionTags": [],
                "code": "public int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        } \\n        return countNodes(root.left) + countNodes(root.right) + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 255444,
                "title": "python-recursive",
                "content": "Since the given tree is a complete binary tree, its right subtree is either incomplete or complete.\\n\\nNow supopse the tree has a height h (**a leaf node has a height 0 so that a complete tree has 2^(h+1)-1 nodes**). \\n\\nIf current node is null (height < 0), we return 0.\\n\\nIf right subtree is not complete, then left subtree is complete(its height is h-1) and has 2^h-1 nodes. So left tree nodes + root node = 2^h nodes and total nodes\\' count is 2^h + countNodes(root.right). In this case, right subtree has a height of h-1 so we can set a logic check here.\\n\\nOtherwise, right subtree is complete(including right tree being null), then right subtree has a height of (h-1) and 2^(h-1)-1 nodes. When right tree is null, root tree has a height of 1 and right tree has 2^0-1 = 0 node. So, right tree nodes + root node = 2^(h-1) nodes and total nodes\\' count is  2^(h-1) + countNodes(root.left). \\nNotice left tree could be either complete or incomplete and right tree\\'s height could be either h-1 or h-2 here.\\n```\\ndef countNodes(root):\\n\\tdef height(node): \\n\\t\\treturn height(node.left) + 1 if node else -1\\n\\th = height(root)\\n\\treturn 0 if h < 0 \\n\\t\\telse (1<<h) + countNodes(root.right) if height(root.right) == h-1 \\n\\t\\telse countNodes(root.left) + (1<<h-1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef countNodes(root):\\n\\tdef height(node): \\n\\t\\treturn height(node.left) + 1 if node else -1\\n\\th = height(root)\\n\\treturn 0 if h < 0 \\n\\t\\telse (1<<h) + countNodes(root.right) if height(root.right) == h-1 \\n\\t\\telse countNodes(root.left) + (1<<h-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 61988,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Count Complete Tree Nodes** https://leetcode.com/problems/count-complete-tree-nodes/?tab=Description\\n\\n**Algorithm**\\n\\n1. We need to use the idea of complete tree here.\\n2. Find the left depth (ld) and right depth (rd).\\n3. Only two cases are possible: ld == rd or ld > rd. rd can never be greater than ld because of the manner in which nodes are packed in the last level.\\n4. When ld == rd, then we are sure that left sub-tree is full. The right may or may not be full, but has same depth. Sketch a diagram to get the intuition.\\n5. When ld > rd, then we know that right subtree is full. Sketch a diagram to get the intuition.\\n6. Complexity: O(lgN * lgN) - There are lg(N) steps and in each step we do lg(N) work of finding the depth.\\n7. https://goo.gl/photos/eQJej6mGcToiRwGY6\\n\\n```\\nclass Solution(object):\\n    def depth(self, root):\\n        if not root:\\n            return 0\\n        return 1 + self.depth(root.left)\\n\\n    def countNodes(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        l_d = self.depth(root.left)\\n        r_d = self.depth(root.right)\\n        if l_d > r_d:\\n            return (2**r_d - 1) + self.countNodes(root.left) + 1\\n        else:\\n            return (2**l_d - 1) + self.countNodes(root.right) + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def depth(self, root):\\n        if not root:\\n            return 0\\n        return 1 + self.depth(root.left)\\n\\n    def countNodes(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        l_d = self.depth(root.left)\\n        r_d = self.depth(root.right)\\n        if l_d > r_d:\\n            return (2**r_d - 1) + self.countNodes(root.left) + 1\\n        else:\\n            return (2**l_d - 1) + self.countNodes(root.right) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62008,
                "title": "java-use-binary-search-84ms-beats-78-with-explanation",
                "content": "     \\n  1\\n    /   \\\\ \\n   2    3\\n  /  \\\\   /  \\n4   5 6\\nwe get root's height (`h`) at first and then we get the root's right node height, if `h(root.right) == h - 1`, it means that root.left is a  complete tree node with height `h-1`, or if `h(root.right) == h - 2`, it means root.right is a complete tree with height `h-2`.\\n```    \\npublic int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int h = getHeight(root);\\n        if (h == 1) {\\n            return 1;\\n        }\\n        int hRight = getHeight(root.right);\\n        if (hRight == h - 1) {\\n            return (1 << h - 1) + countNodes(root.right);\\n        } else {\\n            return (1 << h - 2) + countNodes(root.left);\\n        }\\n    }\\n\\n    private int getHeight(TreeNode root) {\\n        int h = 0;\\n        while (root != null) {\\n            h++;\\n            root = root.left;\\n        }\\n        return h;\\n    }\\n```",
                "solutionTags": [],
                "code": "```    \\npublic int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int h = getHeight(root);\\n        if (h == 1) {\\n            return 1;\\n        }\\n        int hRight = getHeight(root.right);\\n        if (hRight == h - 1) {\\n            return (1 << h - 1) + countNodes(root.right);\\n        } else {\\n            return (1 << h - 2) + countNodes(root.left);\\n        }\\n    }\\n\\n    private int getHeight(TreeNode root) {\\n        int h = 0;\\n        while (root != null) {\\n            h++;\\n            root = root.left;\\n        }\\n        return h;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62025,
                "title": "share-my-c-solution-with-explanation-beats-90-of-submissions-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        int countNodes(TreeNode* root) {\\n            if (root == NULL)\\n                return 0;\\n            \\n            int height = 0;\\n            int cnt = 0;\\n            TreeNode *left = root->left;\\n            TreeNode *right = root->left;\\n    \\n            while(right != NULL)\\n            {\\n                height++;\\n                left = left->left;\\n                right = right->right;\\n            }\\n            \\n            cnt = (1 << height) - 1;\\n            /* <left == NULL && right == NULL> denotes the  left subtree of root must be a perfect binary tree. The right subtree? May be,may be not.\\n             * <left != NULL && right == NULL> denotes the right subtree of root must be a perfect binary tree. Similarly,it's not clear whether the left is\\n             * a perfect binary tree.\\n             * cnt denotes the number of nodes in the perfect binary tree, 1 denotes the root\\n             */\\n            if (left == NULL)\\n                return 1 + cnt + countNodes(root->right);\\n                    \\n            return 1 + cnt + countNodes(root->left);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int countNodes(TreeNode* root) {\\n            if (root == NULL)\\n                return 0;\\n            \\n            int height = 0;\\n            int cnt = 0;\\n            TreeNode *left = root->left;\\n            TreeNode *right = root->left;\\n    \\n            while(right != NULL)\\n            {\\n                height++;\\n                left = left->left;\\n                right = right->right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 62039,
                "title": "my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n\\n    int helper(TreeNode * root)\\n    {\\n        if(!root)return 0;\\n        int leftside=0, rightside=0;\\n        TreeNode *l=root, *r=root;\\n        while(l){ \\n            leftside++; \\n            l=l->left; \\n            \\n        }\\n        while(r){\\n            rightside++; r=r->right; \\n        }\\n        if(rightside==leftside) return pow(2, rightside)-1;\\n        return helper(root->left)+helper(root->right)+1;\\n    }\\n    int countNodes(TreeNode* root) {\\n        return helper(root);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n\\n    int helper(TreeNode * root)\\n    {\\n        if(!root)return 0;\\n        int leftside=0, rightside=0;\\n        TreeNode *l=root, *r=root;\\n        while(l){ \\n            leftside++; \\n            l=l->left; \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62073,
                "title": "python-o-lgn-o-lgn-solution-with-comments",
                "content": "        \\n    def countNodes(self, root):\\n        if not root:\\n            return 0\\n        h1, h2 = self.height(root.left), self.height(root.right)\\n        if h1 > h2: # right child is full \\n            return self.countNodes(root.left) +  2 ** h2 \\n        else: # left child is full \\n            return 2 ** h1 + self.countNodes(root.right)\\n    \\n    # the height of the left-most leaf node\\n    def height1(self, root):\\n        h = 0\\n        while root:\\n            h += 1\\n            root = root.left\\n        return h\\n        \\n    def height(self, root):\\n        if not root:\\n            return 0\\n        return self.height(root.left) + 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def countNodes(self, root):\\n        if not root:\\n            return 0\\n        h1, h2 = self.height(root.left), self.height(root.right)\\n        if h1 > h2: # right child is full \\n            return self.countNodes(root.left) +  2 ** h2 \\n        else: # left child is full \\n            return 2 ** h1 + self.countNodes(root.right)\\n    \\n    # the height of the left-most leaf node\\n    def height1(self, root):\\n        h = 0\\n        while root:\\n            h += 1\\n            root = root.left\\n        return h\\n        \\n    def height(self, root):\\n        if not root:\\n            return 0\\n        return self.height(root.left) + 1",
                "codeTag": "Python3"
            },
            {
                "id": 62102,
                "title": "my-java-recursive-solution-in-o-log-n-log-n-time",
                "content": "Below is my Java solution, after inspiration from some of the answers on this forum and working out the problem by hand.\\n\\nFor those who don't want to look at the code below directly, here's a pointer: **Analyze simple  4, 5 and 6 node trees.** Covering these three cases covers ***ALL*** cases.\\n\\nMy code is as below:\\n\\n    public class Solution {\\n        \\n        private int totalNodes = 0;\\n        \\n        public int countNodes(TreeNode root) {\\n            if(root == null) return 0;\\n            totalNodes = 0;\\n            count(root);\\n            return totalNodes;\\n        }\\n    \\n        private void count(TreeNode node) {\\n            if(node.left == null && node.right == null) {\\n                totalNodes += 1;\\n                return;\\n            }\\n    \\n            if(height(node.left) == height(node.right)) {\\n                totalNodes += (1 << height(node.left));\\n                if(node.right != null) count(node.right);\\n            } else {\\n                totalNodes += (1 << height(node.right));\\n                if(node.left != null) count(node.left);\\n            }\\n        }\\n    \\n        private int height(TreeNode node) {\\n            if(node == null) return 0;\\n            int height = 1;\\n            TreeNode tmp = node;\\n            while(tmp != null) {\\n                tmp = tmp.left;\\n                height++;\\n            }\\n            return height-1;\\n        }\\n    }\\n\\nTwo key differences from other answers I've observed on this topic here:\\n\\n 1. I've used a private variable, to store final counts instead of\\n    passing around an argument to recursion. I thought this would be\\n    much cleaner.\\n 2. I've sped up my computation by using the bit-shift operator <<. As a side note, if you replace this with Math.pow(2, ...), LeetCode OJ throws a \"Time limit exceeded\" error. :)\\n\\n\\nAlso, in the beginning of the `count()` method, you can see the termination condition laid out very simply: If a node is ever reached, where it has no more children, increment totalNodes by 1 and exit.",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        \\n        private int totalNodes = 0;\\n        \\n        public int countNodes(TreeNode root) {\\n            if(root == null) return 0;\\n            totalNodes = 0;\\n            count(root);\\n            return totalNodes;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62108,
                "title": "ruby-o-lg-n-2-solution",
                "content": "    # @param {TreeNode} root\\n    # @return {Integer}\\n    def count_nodes(root)\\n      return 0 if root.nil?\\n      \\n      curr = root\\n      hl = 1\\n      hl += 1 while curr = curr.left\\n      \\n      curr = root\\n      hr = 1\\n      hr += 1 while curr = curr.right\\n      \\n      return 2**hl - 1 if hl == hr\\n      1 + count_nodes(root.left) + count_nodes(root.right)\\n    end",
                "solutionTags": [],
                "code": "    # @param {TreeNode} root\\n    # @return {Integer}\\n    def count_nodes(root)\\n      return 0 if root.nil?\\n      \\n      curr = root\\n      hl = 1\\n      hl += 1 while curr = curr.left\\n      \\n      curr = root\\n      hr = 1\\n      hr += 1 while curr = curr.right\\n      \\n      return 2**hl - 1 if hl == hr\\n      1 + count_nodes(root.left) + count_nodes(root.right)\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 3957522,
                "title": "easy-to-understand-o-n-solution-using-recursive-traversal-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We declare count as global variable outside the function\\n- Inside the function we have the termination condition for recursion i.e.      \\nroot != null\\n- Then comes the recursive tree traversal till the termination condition is satified, alongside traversal increment the count using count++. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    //counter variable\\n    int count = 0;\\n    public int countNodes(TreeNode root) {\\n    \\n        if(root != null){\\n        countNodes(root.left);\\n        count++;        \\n        countNodes(root.right);\\n        }\\n\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    //counter variable\\n    int count = 0;\\n    public int countNodes(TreeNode root) {\\n    \\n        if(root != null){\\n        countNodes(root.left);\\n        count++;        \\n        countNodes(root.right);\\n        }\\n\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640508,
                "title": "simple-c-python-solutions-only-2-lines-beats-beats-93-58",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust use  preorder/postorder transversal in recursive way!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if (root==NULL) return 0;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n};\\n```\\n# Python solution\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if root==None: return 0\\n        return 1+self.countNodes(root.left)+self.countNodes(root.right)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if (root==NULL) return 0;\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n};\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if root==None: return 0\\n        return 1+self.countNodes(root.left)+self.countNodes(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524394,
                "title": "java-beats-100-oms-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int count=0;\\n        if (root != null) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while (!queue.isEmpty()) {\\n            TreeNode node = queue.poll();\\n            count++;\\n            if (node.left != null) {\\n                queue.add(node.left);\\n            }\\n            if (node.right != null) {\\n                queue.add(node.right);\\n            }\\n        }}\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int count=0;\\n        if (root != null) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while (!queue.isEmpty()) {\\n            TreeNode node = queue.poll();\\n            count++;\\n            if (node.left != null) {\\n                queue.add(node.left);\\n            }\\n            if (node.right != null) {\\n                queue.add(node.right);\\n            }\\n        }}\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508666,
                "title": "java-easiest-solution-beats-100",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    List<Integer> list = new ArrayList<Integer>();\\n    public int countNodes(TreeNode root) {\\n        if(root==null) return 0;\\n        int left=countNodes(root.left);\\n        int right=countNodes(root.right);\\n        return left+right+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> list = new ArrayList<Integer>();\\n    public int countNodes(TreeNode root) {\\n        if(root==null) return 0;\\n        int left=countNodes(root.left);\\n        int right=countNodes(root.right);\\n        return left+right+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386731,
                "title": "java-100-faster-easiest-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log^2 n)\\n\\nThe time complexity of this code is O(log^2 n), where n is the number of nodes in the binary tree.\\n\\nThe getLeftHeight and getRightHeight helper functions each have a time complexity of O(log n), since they traverse down the height of the tree.\\n\\nThe countNodes function has a worst-case time complexity of O(log^2 n), because in the worst case, the tree is a complete binary tree and the getLeftHeight and getRightHeight functions will each be called recursively on a subproblem that is half the size of the original problem. This means that the number of times each function is called will be proportional to the height of the tree, which is log n. Since both functions are called for each node in the tree, the overall time complexity of the algorithm is O(log^2 n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(log n)\\n\\nThe space complexity of this code is O(log n), which is the space used by the recursive call stack. In the worst case, the height of the tree is log n, so the maximum number of recursive calls on the stack is log n.\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/a763fc9d-92b2-47b1-96e0-9135af4adf09_1680789931.014916.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public int countNodes(TreeNode root) {\\n\\n        // If the root is null, then there are no nodes in the tree\\n        if(root == null){\\n            return 0;\\n        }\\n\\n        // Get the heights of the left and right subtrees\\n        int leftHeight = getLeftHeight(root);\\n        int rightHeight = getRightHeight(root);\\n\\n        // If the left and right subtrees have the same height, then the tree is a perfect binary tree,\\n        // and the total number of nodes in the tree can be calculated using the formula (2^h - 1), where h is the height of the tree\\n        if(leftHeight == rightHeight){\\n            return ((2<<leftHeight)-1);\\n        }\\n\\n        // If the left and right subtrees do not have the same height, then the tree is not a perfect binary tree,\\n        // and we need to recursively count the nodes in the left and right subtrees and add 1 for the root node\\n        else{\\n            return countNodes(root.left) + countNodes(root.right) + 1;\\n        }\\n    }\\n\\n\\n\\n\\n    // Helper function to get the height of the left subtree\\n    public int getLeftHeight(TreeNode root){\\n        \\n        int height = 0;\\n\\n        // Traverse down the left side of the tree and count the number of levels\\n        while(root.left != null){\\n            height++;\\n            root = root.left;\\n        }\\n      return height;\\n    }\\n\\n    // Helper function to get the height of the right subtree\\n    public int getRightHeight(TreeNode root){\\n        \\n        int height = 0;\\n\\n        // Traverse down the right side of the tree and count the number of levels\\n        while(root.right != null){\\n            height++;\\n            root = root.right;\\n        }\\n      return height;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public int countNodes(TreeNode root) {\\n\\n        // If the root is null, then there are no nodes in the tree\\n        if(root == null){\\n            return 0;\\n        }\\n\\n        // Get the heights of the left and right subtrees\\n        int leftHeight = getLeftHeight(root);\\n        int rightHeight = getRightHeight(root);\\n\\n        // If the left and right subtrees have the same height, then the tree is a perfect binary tree,\\n        // and the total number of nodes in the tree can be calculated using the formula (2^h - 1), where h is the height of the tree\\n        if(leftHeight == rightHeight){\\n            return ((2<<leftHeight)-1);\\n        }\\n\\n        // If the left and right subtrees do not have the same height, then the tree is not a perfect binary tree,\\n        // and we need to recursively count the nodes in the left and right subtrees and add 1 for the root node\\n        else{\\n            return countNodes(root.left) + countNodes(root.right) + 1;\\n        }\\n    }\\n\\n\\n\\n\\n    // Helper function to get the height of the left subtree\\n    public int getLeftHeight(TreeNode root){\\n        \\n        int height = 0;\\n\\n        // Traverse down the left side of the tree and count the number of levels\\n        while(root.left != null){\\n            height++;\\n            root = root.left;\\n        }\\n      return height;\\n    }\\n\\n    // Helper function to get the height of the right subtree\\n    public int getRightHeight(TreeNode root){\\n        \\n        int height = 0;\\n\\n        // Traverse down the right side of the tree and count the number of levels\\n        while(root.right != null){\\n            height++;\\n            root = root.right;\\n        }\\n      return height;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285137,
                "title": "2-approaches-brute-force-o-n-to-optimized-solution-o-log-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Brute Force\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    void inorder(TreeNode root){ // inroder traversal\\n        if(root==null) return;\\n        count++;\\n        inorder(root.left);\\n        inorder(root.right);\\n    }\\n    public int countNodes(TreeNode root) {\\n        inorder(root);\\n        return count;\\n    }\\n}\\n```\\n\\n# Optimzed Approach\\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) return 0;\\n        int lh = heightLeft(root);\\n        int rh = heightRight(root);\\n        if(lh==rh){\\n            return ((2<<lh)-1);\\n        }\\n        else return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n\\n    int heightLeft(TreeNode root){\\n        int lh = 0;\\n        while(root.left!=null){\\n            lh++;\\n            root=root.left;\\n        }\\n        return lh;\\n    }\\n\\n    int heightRight(TreeNode root){\\n        int rh = 0;\\n        while(root.right!=null){\\n            rh++;\\n            root=root.right;\\n        }\\n        return rh;\\n    }\\n\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(logn)^2$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    void inorder(TreeNode root){ // inroder traversal\\n        if(root==null) return;\\n        count++;\\n        inorder(root.left);\\n        inorder(root.right);\\n    }\\n    public int countNodes(TreeNode root) {\\n        inorder(root);\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) return 0;\\n        int lh = heightLeft(root);\\n        int rh = heightRight(root);\\n        if(lh==rh){\\n            return ((2<<lh)-1);\\n        }\\n        else return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n\\n    int heightLeft(TreeNode root){\\n        int lh = 0;\\n        while(root.left!=null){\\n            lh++;\\n            root=root.left;\\n        }\\n        return lh;\\n    }\\n\\n    int heightRight(TreeNode root){\\n        int rh = 0;\\n        while(root.right!=null){\\n            rh++;\\n            root=root.right;\\n        }\\n        return rh;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983851,
                "title": "c-code-using-recursion",
                "content": "# Intuition\\n- Traversing using Recursion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Perform Inorder traversal on tree and count the nodes.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n        void inorder(TreeNode* root, int &count)\\n        {\\n            if(root==NULL)\\n                return;\\n            inorder(root->left,count);\\n            count++;\\n            inorder(root->right,count);\\n        }\\npublic:\\n    int countNodes(TreeNode* root) {\\n        int count=0;\\n        inorder(root,count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n        void inorder(TreeNode* root, int &count)\\n        {\\n            if(root==NULL)\\n                return;\\n            inorder(root->left,count);\\n            count++;\\n            inorder(root->right,count);\\n        }\\npublic:\\n    int countNodes(TreeNode* root) {\\n        int count=0;\\n        inorder(root,count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817694,
                "title": "non-recurisve-logn-logn-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool exists(TreeNode* root, int leaf, int h) {\\n        h--;\\n        if (root) {\\n            // if we\\'d reached the leaf then it does exist\\n            if (h == -1) return true;\\n            \\n            // the hardest part is to understand how \\n            // we traverse to specific leaf\\n            // here is my idea\\n            //\\n            //              *                 level value = 4\\n            //             / \\\\\\n            //            /   \\\\\\n            //           /     \\\\\\n            //          /       \\\\\\n            //         /         \\\\\\n            //        /           \\\\\\n            //       *             *          level value = 2\\n            //     /   \\\\         /   \\\\\\n            //    /     \\\\       /     \\\\\\n            //   *       *     *       *      level value = 1\\n            //  / \\\\     / \\\\   / \\\\     / \\\\\\n            // *   *   *   * *   *   *   *    level value = 0\\n            // 0   1   2   3 4   5   6   7\\n            \\n            // for instance let\\'s have a leaf value = 6\\n            //\\n            //              6                 leaf -> 6 - 4\\n            //             / \\\\                6 is enough to go right\\n            //            /   \\\\\\n            //           /     \\\\\\n            //          /       \\\\\\n            //         /         \\\\\\n            //        /           \\\\\\n            //       *             2          leaf -> 2 - 2\\n            //     /   \\\\         /   \\\\        2 is enough to move right\\n            //    /     \\\\       /     \\\\\\n            //   *       *     *       0      leaf -> 0 - 1 and it is negative\\n            //  / \\\\     / \\\\   / \\\\     / \\\\     0 is not enough then we go left\\n            // *   *   *   * *   *   0   *    \\n            // 0   1   2   3 4   5   6   7\\n            \\n            if (leaf >= 1 << h) {\\n                leaf -= 1 << h;\\n                return exists(root -> right, leaf, h);\\n            }\\n            return exists(root -> left, leaf, h);\\n        }\\n        // if we reach nothing return false\\n        else return false;\\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        \\n        // if tree is empty return 0;\\n        if (!root) return 0;\\n        \\n        // let\\'s count the tree\\'s height\\n        int h = -1;\\n        auto n = root;\\n        while (n) h++, n = n -> left;\\n        \\n        // potentially we have leaves that\\n        // we can count from 0 to 2^h - 1\\n        // initial guess for binary search\\n        int l = 0, r = 1 << h;\\n        \\n        // bs by itself\\n        while (r - l > 1) {\\n            int mid = (l + r) / 2;\\n            \\n            // if leaf with number mid (starting from 0)\\n            // exists than we say that l will store mid value\\n            if (exists(root, mid, h)) l = mid;\\n            else r = mid;\\n        }\\n        \\n        return ((1 << h) - 1) + (l + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool exists(TreeNode* root, int leaf, int h) {\\n        h--;\\n        if (root) {\\n            // if we\\'d reached the leaf then it does exist\\n            if (h == -1) return true;\\n            \\n            // the hardest part is to understand how \\n            // we traverse to specific leaf\\n            // here is my idea\\n            //\\n            //              *                 level value = 4\\n            //             / \\\\\\n            //            /   \\\\\\n            //           /     \\\\\\n            //          /       \\\\\\n            //         /         \\\\\\n            //        /           \\\\\\n            //       *             *          level value = 2\\n            //     /   \\\\         /   \\\\\\n            //    /     \\\\       /     \\\\\\n            //   *       *     *       *      level value = 1\\n            //  / \\\\     / \\\\   / \\\\     / \\\\\\n            // *   *   *   * *   *   *   *    level value = 0\\n            // 0   1   2   3 4   5   6   7\\n            \\n            // for instance let\\'s have a leaf value = 6\\n            //\\n            //              6                 leaf -> 6 - 4\\n            //             / \\\\                6 is enough to go right\\n            //            /   \\\\\\n            //           /     \\\\\\n            //          /       \\\\\\n            //         /         \\\\\\n            //        /           \\\\\\n            //       *             2          leaf -> 2 - 2\\n            //     /   \\\\         /   \\\\        2 is enough to move right\\n            //    /     \\\\       /     \\\\\\n            //   *       *     *       0      leaf -> 0 - 1 and it is negative\\n            //  / \\\\     / \\\\   / \\\\     / \\\\     0 is not enough then we go left\\n            // *   *   *   * *   *   0   *    \\n            // 0   1   2   3 4   5   6   7\\n            \\n            if (leaf >= 1 << h) {\\n                leaf -= 1 << h;\\n                return exists(root -> right, leaf, h);\\n            }\\n            return exists(root -> left, leaf, h);\\n        }\\n        // if we reach nothing return false\\n        else return false;\\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        \\n        // if tree is empty return 0;\\n        if (!root) return 0;\\n        \\n        // let\\'s count the tree\\'s height\\n        int h = -1;\\n        auto n = root;\\n        while (n) h++, n = n -> left;\\n        \\n        // potentially we have leaves that\\n        // we can count from 0 to 2^h - 1\\n        // initial guess for binary search\\n        int l = 0, r = 1 << h;\\n        \\n        // bs by itself\\n        while (r - l > 1) {\\n            int mid = (l + r) / 2;\\n            \\n            // if leaf with number mid (starting from 0)\\n            // exists than we say that l will store mid value\\n            if (exists(root, mid, h)) l = mid;\\n            else r = mid;\\n        }\\n        \\n        return ((1 << h) - 1) + (l + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817549,
                "title": "100-faster-java-code-o-log-n-2-simple-and-easy",
                "content": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int LH=leftHeight(root);\\n        int RH=rightHeight(root);\\n        if(LH==RH){\\n            return (int)(Math.pow(2,LH))-1; //if both height are are equal then no of nodes are (2^h-1)\\n        }\\n        else{\\n            return 1+countNodes(root.left)+countNodes(root.right);\\n        }\\n    }\\n    public int leftHeight(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n        else{\\n            return 1+leftHeight(root.left);\\n        }\\n    }\\n    public int rightHeight(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n        else{\\n            return 1+rightHeight(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int LH=leftHeight(root);\\n        int RH=rightHeight(root);\\n        if(LH==RH){\\n            return (int)(Math.pow(2,LH))-1; //if both height are are equal then no of nodes are (2^h-1)\\n        }\\n        else{\\n            return 1+countNodes(root.left)+countNodes(root.right);\\n        }\\n    }\\n    public int leftHeight(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n        else{\\n            return 1+leftHeight(root.left);\\n        }\\n    }\\n    public int rightHeight(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n        else{\\n            return 1+rightHeight(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816831,
                "title": "c-recursion-2-line-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n\\t\\n\\t//count no of nodes until root=NULL\\n\\t\\n        if(root!=NULL){\\n            return countNodes(root->left)+countNodes(root->right)+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n\\t\\n\\t//count no of nodes until root=NULL\\n\\t\\n        if(root!=NULL){\\n            return countNodes(root->left)+countNodes(root->right)+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816772,
                "title": "correct-solution-o-n-easy-explanation-with-code-in-java-o-log-n",
                "content": "Please upvote if you found this helpful.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to use the property of a perfect binary tree that total number of nodes in a perfect binary tree equals **(2^n)-1**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe check left depth and right depth of the tree.\\n\\n**CASE I** \\nIf both depths are **equal** it means that the tree is a perfect binary tree we can use the formula above to calculate the number of nodes in the tree. \\n                **n = (2^n)-1**\\n\\n**CASE II**\\nif the depths are not equal we will use recursion to find the number of nodes in the subtree and add them till we reach the root of the tree.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n        int left_level = 1;\\n        TreeNode l = root.left;\\n        while(l!=null){\\n            l = l.left;\\n            left_level++;\\n        }\\n        int right_level = 1;\\n        TreeNode r = root.right;\\n        while(r!=null){\\n            r = r.right;\\n            right_level++;\\n        }\\n        if(right_level == left_level){\\n            return(int) Math.pow(2 , left_level) - 1;\\n        }\\n\\n\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n        int left_level = 1;\\n        TreeNode l = root.left;\\n        while(l!=null){\\n            l = l.left;\\n            left_level++;\\n        }\\n        int right_level = 1;\\n        TreeNode r = root.right;\\n        while(r!=null){\\n            r = r.right;\\n            right_level++;\\n        }\\n        if(right_level == left_level){\\n            return(int) Math.pow(2 , left_level) - 1;\\n        }\\n\\n\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816691,
                "title": "easy-2-liner-solution-explained-c",
                "content": "Here is the simple two liner solution using recursion:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        // if node is null we return 0 which goes to the previous sum\\n        if (!root) return 0;\\n        // we\\'re adding 1 to the sum along with the sum which we get from the\\n        // left and right tree children\\n        // this sum gets returned to the previous point from where this function\\n        // was recursively called and gets added there\\n        return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};\\n```\\n\\n*If this solution helped you, then this solution deserves an upvote!*",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        // if node is null we return 0 which goes to the previous sum\\n        if (!root) return 0;\\n        // we\\'re adding 1 to the sum along with the sum which we get from the\\n        // left and right tree children\\n        // this sum gets returned to the previous point from where this function\\n        // was recursively called and gets added there\\n        return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816387,
                "title": "c-binary-search-o-log-2-h",
                "content": "**Solution using binary search**\\n\\nWe know that all levels except the last one are full-completed. Let\\'s use this info:\\n1. Firstly, find depth. It means that Tree has at least 2^h - 1 nodes. \\n2. Count how many nodes does Tree have at last level. There are 2^h possible counts.\\n3. Check them using binary search. Each check needs O(log(h)) time complexity(TC).\\n4. To check 2^h nodes we need O(log(h)) TC.\\n5. So, overall TC is O(log^2(h)).\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getHeight(TreeNode* root, int h = 0) {\\n        if (!root) {\\n            return h - 1;\\n        }\\n        return getHeight(root->left, h + 1);\\n    }\\n    \\n    bool check(TreeNode* root, int v) {\\n        vector<bool> path;\\n        while (v > 1) {\\n            if (v % 2 == 1) {\\n                path.push_back(true);\\n            } else {\\n                path.push_back(false);\\n            }\\n            v /= 2;\\n        }\\n        reverse(path.begin(), path.end());\\n        for (const auto& way: path) {\\n            if (!root)\\n                return false;\\n            if (!way) {\\n                root = root->left;\\n            } else {\\n                root = root->right;\\n            }\\n        }\\n        return root != nullptr;\\n        \\n    }\\n    \\n    inline bool complete(TreeNode* root, int h) {\\n        for (int i = 0; i < h; ++i) {\\n            root = root->right;\\n            if (!root)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        \\n        const int h = getHeight(root);\\n        \\n        if (complete(root, h))\\n            return (1 << (h + 1)) - 1;\\n        \\n        int l = (1 << h), r = (1 << (h + 1)) - 1, it = h;\\n        while (it--) {\\n            int m = (l + r) / 2;\\n            if (check(root, m)) {\\n                l = m;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        \\n        return check(root, r) ? r : l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getHeight(TreeNode* root, int h = 0) {\\n        if (!root) {\\n            return h - 1;\\n        }\\n        return getHeight(root->left, h + 1);\\n    }\\n    \\n    bool check(TreeNode* root, int v) {\\n        vector<bool> path;\\n        while (v > 1) {\\n            if (v % 2 == 1) {\\n                path.push_back(true);\\n            } else {\\n                path.push_back(false);\\n            }\\n            v /= 2;\\n        }\\n        reverse(path.begin(), path.end());\\n        for (const auto& way: path) {\\n            if (!root)\\n                return false;\\n            if (!way) {\\n                root = root->left;\\n            } else {\\n                root = root->right;\\n            }\\n        }\\n        return root != nullptr;\\n        \\n    }\\n    \\n    inline bool complete(TreeNode* root, int h) {\\n        for (int i = 0; i < h; ++i) {\\n            root = root->right;\\n            if (!root)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        \\n        const int h = getHeight(root);\\n        \\n        if (complete(root, h))\\n            return (1 << (h + 1)) - 1;\\n        \\n        int l = (1 << h), r = (1 << (h + 1)) - 1, it = h;\\n        while (it--) {\\n            int m = (l + r) / 2;\\n            if (check(root, m)) {\\n                l = m;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        \\n        return check(root, r) ? r : l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816293,
                "title": "fastest-beats-99-submissions-easiest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider Two Cases where its completely filled once and in other cases the last level is not completely filled with nodes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive call to determine the height.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)x O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root :\\n            return 0\\n        def lheight(root):\\n            if not root:\\n                return 0\\n            return 1 + lheight(root.left)\\n        def rheight(root):\\n            if not root:\\n                return 0\\n            return 1+ rheight(root.right)\\n        l,r=lheight(root),rheight(root)\\n        if l>r :\\n            return 1+self.countNodes(root.left)+self.countNodes(root.right)\\n        else :\\n            return (2**l)-1\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root :\\n            return 0\\n        def lheight(root):\\n            if not root:\\n                return 0\\n            return 1 + lheight(root.left)\\n        def rheight(root):\\n            if not root:\\n                return 0\\n            return 1+ rheight(root.right)\\n        l,r=lheight(root),rheight(root)\\n        if l>r :\\n            return 1+self.countNodes(root.left)+self.countNodes(root.right)\\n        else :\\n            return (2**l)-1\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816004,
                "title": "easy-2-line-code",
                "content": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815778,
                "title": "two-line-solution-recussion-based",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Line solution Recurssion\\n\\n# Complexity\\n- Time complexity:\\nO(N) where is the number of Nodes \\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        return 1+countNodes(root->left)+ countNodes(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        return 1+countNodes(root->left)+ countNodes(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815440,
                "title": "free-test-cases",
                "content": "[]\\n[0]\\n[0,1]\\n[0,1,2]\\n[0,1,2,3]\\n[0,1,2,3,4]\\n[0,1,2,3,4,5]\\n[0,1,2,3,4,5,6]\\n[0,1,2,3,4,5,6,7]\\n[0,1,2,3,4,5,6,7,8]\\n[0,1,2,3,4,5,6,7,8,9]\\n[0,1,2,3,4,5,6,7,8,9,10]\\n[0,1,2,3,4,5,6,7,8,9,10,11]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68]\\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69]\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2671485,
                "title": "brute-to-optimized-c-approach-commented-solution",
                "content": "#### Brute Force Approach :\\nJust traverse all nodes of the tree and maintain a counter and return that counter.\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, int &cnt){\\n        if(!root) return;\\n        cnt++; //increament the counter\\n        inorder(root->left, cnt); //traversing left subtree\\n        inorder(root->right, cnt); //traversing right subtree\\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        int cnt = 0;\\n        inorder(root, cnt); //we are using inorder traversal here\\n        return cnt; //returning the counter\\n    }\\n};\\n\\n// T.C => O(N) & S.C => O(N)\\n```\\n\\n#### Optimal Approach:\\nIt is mention in question that it is a complete Binary tree... so, we can use the complete tree property. i.e., n = 2^h - 1.\\nwhere, n = no. of nodes in binary tree.\\nh = height of the binary tree.\\n```\\nclass Solution {\\npublic:\\n    int findLeftHeight(TreeNode* node){ //calculating left height by normal traversal\\n        int height = 0;\\n        while(node){\\n            height++;\\n            node = node->left;\\n        }\\n        return height;\\n    }\\n    \\n    int findRightHeight(TreeNode* node){  //calculating right height by normal traversal\\n        int height = 0;\\n        while(node){\\n            height++;\\n            node = node->right;\\n        }\\n        return height;\\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        int lh = findLeftHeight(root); // find left height of tree\\n        int rh = findRightHeight(root); // find right height of tree\\n        if(lh == rh) return (1 << lh) - 1; //if balaced tree(having 0 or 2 child of every node) then we\\'ll use [n = 2^h - 1].\\n        return 1 + countNodes(root->left) + countNodes(root->right); //if not a balanced tree then we\\'ll use [1+left subtree+right subtree}\\n    }\\n};\\n\\n// T.C => O(log^2 N) [one \"log N\" for traversing x one \"log N\" for finding height] \\n// S.C => O(log N) [recursive space equal to height of the tree]\\n```\\n\\n### If you found it helpful then  please upvote it... Thank You...",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, int &cnt){\\n        if(!root) return;\\n        cnt++; //increament the counter\\n        inorder(root->left, cnt); //traversing left subtree\\n        inorder(root->right, cnt); //traversing right subtree\\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        int cnt = 0;\\n        inorder(root, cnt); //we are using inorder traversal here\\n        return cnt; //returning the counter\\n    }\\n};\\n\\n// T.C => O(N) & S.C => O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int findLeftHeight(TreeNode* node){ //calculating left height by normal traversal\\n        int height = 0;\\n        while(node){\\n            height++;\\n            node = node->left;\\n        }\\n        return height;\\n    }\\n    \\n    int findRightHeight(TreeNode* node){  //calculating right height by normal traversal\\n        int height = 0;\\n        while(node){\\n            height++;\\n            node = node->right;\\n        }\\n        return height;\\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        int lh = findLeftHeight(root); // find left height of tree\\n        int rh = findRightHeight(root); // find right height of tree\\n        if(lh == rh) return (1 << lh) - 1; //if balaced tree(having 0 or 2 child of every node) then we\\'ll use [n = 2^h - 1].\\n        return 1 + countNodes(root->left) + countNodes(root->right); //if not a balanced tree then we\\'ll use [1+left subtree+right subtree}\\n    }\\n};\\n\\n// T.C => O(log^2 N) [one \"log N\" for traversing x one \"log N\" for finding height] \\n// S.C => O(log N) [recursive space equal to height of the tree]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651917,
                "title": "optimised-approach-c-easy-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        //Here we are solving this problem by using the concept of count of nodes in full binary tree i.e. (2 ^n - 1).\\n        // we will search full binary trees in given binary tree to avoid extra node traversals which will give better time complexity for large number of trees.\\n        // For every sub-tree it will count the number of nodes using that formula\\n        if(root == NULL) return 0;\\n        int lh = findLeftHeight(root);\\n        int rh = findRightHeight(root);\\n        \\n        if(lh == rh) return (1 << lh) - 1;\\n        \\n        return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n    \\n    int findLeftHeight(TreeNode* root) {\\n        int height = 0;\\n        while(root) {\\n            height++;\\n            root = root->left;\\n        }\\n        return height;\\n    }\\n    \\n    int findRightHeight(TreeNode* root) {\\n        int height = 0;\\n        while(root) {\\n            height++;\\n            root = root->right;\\n        }\\n        return height;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        //Here we are solving this problem by using the concept of count of nodes in full binary tree i.e. (2 ^n - 1).\\n        // we will search full binary trees in given binary tree to avoid extra node traversals which will give better time complexity for large number of trees.\\n        // For every sub-tree it will count the number of nodes using that formula\\n        if(root == NULL) return 0;\\n        int lh = findLeftHeight(root);\\n        int rh = findRightHeight(root);\\n        \\n        if(lh == rh) return (1 << lh) - 1;\\n        \\n        return 1 + countNodes(root->left) + countNodes(root->right);\\n    }\\n    \\n    int findLeftHeight(TreeNode* root) {\\n        int height = 0;\\n        while(root) {\\n            height++;\\n            root = root->left;\\n        }\\n        return height;\\n    }\\n    \\n    int findRightHeight(TreeNode* root) {\\n        int height = 0;\\n        while(root) {\\n            height++;\\n            root = root->right;\\n        }\\n        return height;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278555,
                "title": "c-o-log-2n-short-clean-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tint countNodes(TreeNode* root) {\\n        \\n        if(!root) return 0;\\n        \\n        int lh=leftheight(root);\\n        int rh=rightheight(root);\\n        \\n        if(lh==rh) return pow(2,lh)-1;\\n        \\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n    \\n    int leftheight(TreeNode *root){\\n        \\n        int ht=0;\\n        while(root){\\n            ht++;\\n            root=root->left;\\n        }\\n        return ht;\\n    }\\n    \\n    int rightheight(TreeNode *root){\\n        \\n        int ht=0;\\n        while(root){\\n            ht++;\\n            root=root->right;\\n        }\\n        return ht;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tint countNodes(TreeNode* root) {\\n        \\n        if(!root) return 0;\\n        \\n        int lh=leftheight(root);\\n        int rh=rightheight(root);\\n        \\n        if(lh==rh) return pow(2,lh)-1;\\n        \\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n    \\n    int leftheight(TreeNode *root){\\n        \\n        int ht=0;\\n        while(root){\\n            ht++;\\n            root=root->left;\\n        }\\n        return ht;\\n    }\\n    \\n    int rightheight(TreeNode *root){\\n        \\n        int ht=0;\\n        while(root){\\n            ht++;\\n            root=root->right;\\n        }\\n        return ht;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2256453,
                "title": "a-simple-binary-search-solution",
                "content": "Treat Complete binary tree as a Perfect binary tree and find the first `NULL` node in the last level and then return total number of nodes above last level + number of nodes before first `NULL` in the last level.\\nIf height of the tree is equals to the height of the subtree means last node is NOT `NULL` otherwise `NULL`. So if it is `NULL` we\\'ll recurse for the left subtree else recurse for right subtree. This way we\\'ll find the first `NULL` node in the last level.\\n\\nTime Complexity: $$O(log^2(n))$$\\nSpace Complexity: $$O(log(n))$$\\n\\n```\\nint height(TreeNode* root){\\n\\tint h = 0;\\n\\twhile(root){\\n        ++h;\\n        root=root->left;\\n    } \\n\\treturn h;\\n}\\n\\nint countNodes(TreeNode* root) {\\n\\tint h = height(root);\\n\\tif(h==0) return h;\\n\\tconst int H = h, leafNodes = 1<<(H-1);\\n\\tint low = 1, high = leafNodes, mid, temp;\\n\\twhile(low <= high && root){\\n\\t\\tmid = low + ((high-low)>>1);\\n\\t\\ttemp = height(root->right) + 1;\\n\\t\\tif(temp != h) {\\n\\t\\t\\troot = root->left;\\n\\t\\t\\thigh = mid-1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\troot = root->right;\\n\\t\\t\\tlow = mid+1;\\n\\t\\t} \\n\\t\\t--h;\\n\\t}\\n\\n\\tif(low > leafNodes) --low;\\n\\treturn leafNodes - 1 + (low);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint height(TreeNode* root){\\n\\tint h = 0;\\n\\twhile(root){\\n        ++h;\\n        root=root->left;\\n    } \\n\\treturn h;\\n}\\n\\nint countNodes(TreeNode* root) {\\n\\tint h = height(root);\\n\\tif(h==0) return h;\\n\\tconst int H = h, leafNodes = 1<<(H-1);\\n\\tint low = 1, high = leafNodes, mid, temp;\\n\\twhile(low <= high && root){\\n\\t\\tmid = low + ((high-low)>>1);\\n\\t\\ttemp = height(root->right) + 1;\\n\\t\\tif(temp != h) {\\n\\t\\t\\troot = root->left;\\n\\t\\t\\thigh = mid-1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\troot = root->right;\\n\\t\\t\\tlow = mid+1;\\n\\t\\t} \\n\\t\\t--h;\\n\\t}\\n\\n\\tif(low > leafNodes) --low;\\n\\treturn leafNodes - 1 + (low);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2164879,
                "title": "brute-force-and-optimal-c",
                "content": "# Brute force O(N)\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        return !root ? 0 : countNodes(root -> left) + countNodes(root -> right) + 1;\\n    }\\n};\\n```\\n\\n# Optimal O(log^2 N)\\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int lh = 0, rh = 0;\\n        TreeNode* ln = root, *rn = root;\\n        \\n        while(ln) lh++, ln = ln -> left;\\n        while(rn) rh++, rn = rn -> right;\\n        \\n        if(lh == rh) return pow(2, lh) - 1;\\n        \\n        return 1 + countNodes(root -> left) + countNodes(root -> right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        return !root ? 0 : countNodes(root -> left) + countNodes(root -> right) + 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int lh = 0, rh = 0;\\n        TreeNode* ln = root, *rn = root;\\n        \\n        while(ln) lh++, ln = ln -> left;\\n        while(rn) rh++, rn = rn -> right;\\n        \\n        if(lh == rh) return pow(2, lh) - 1;\\n        \\n        return 1 + countNodes(root -> left) + countNodes(root -> right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911007,
                "title": "easy-solution-o-logn-logn-faster-than-others-perfect-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int lh=0,rh=0;\\n        TreeNode *curr=root;\\n        while(curr!=NULL){\\n            lh++;\\n            curr=curr->left;\\n        }\\n        curr=root;\\n        while(curr!=NULL){\\n            rh++;\\n            curr=curr->right;\\n        }\\n        if(lh==rh)\\n            return( pow(2,lh)-1);\\n        else\\n            return 1+(countNodes(root->left)+countNodes(root->right));\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int lh=0,rh=0;\\n        TreeNode *curr=root;\\n        while(curr!=NULL){\\n            lh++;\\n            curr=curr->left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1789974,
                "title": "java-bs-better-than-o-n-0ms-explained",
                "content": "I actually like this question. \\n\\n**Intuition**: We know that it is a complete binary tree, this means we can get its depth in O(log n) time just going from root to its left child until we reach the end. With `depth` obtained, we are able to deduce the number of nodes in the last level is between 1 to `pow(2, depth)`. The only difficulty is that we have to figure out a way to find exactly what that number is... and this is where `BINARY SEARCH` comes in to rescue us! \\n\\n**Q: Why Binary Search?** It is because the tree is a complete binary tree, we know that in the last level, it\\'s node is going to fill from left to right with no gap in between, so essentially, we are looking for the last T in `TTTTTTTFFFFFFFF...` sequence, and that\\'s what binary search is good at.\\n\\n**Q: But how do we determine the \"mid\" number we get is in the tree or not?** \\nGood question! We can actually just traverse down the tree from root based on what the `mid` is. If `mid` is greater than half of the number of nodes in the last level, we go down right subtree. Otherwise, we go down left subtree. It will take us `O(log n)` time to determine whether `mid` is in the tree. \\n\\nRemember, if we are going down right subtree, `mid` position will now become `mid - half number of nodes in the last level in the current root subtree`. It is because we are discarding the left subtree and we have to adjust the position accordingly.\\n\\nPlease **UPVOTE** if you find it helpful ;)\\n\\n`Time Complexity: O(logn * logn)`\\n`Space Complexity: O(1)`\\n```Java\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int lvl = 0;\\n        TreeNode cur = root;\\n        while(cur != null){\\n            cur = cur.left;\\n            lvl++;\\n        }\\n        int lo = 1, hi = (int)Math.pow(2, lvl - 1), tp = hi - 1;\\n        while(lo < hi){\\n            cur = root;\\n            int mid = lo + (hi - lo + 1) / 2;\\n            int pos = mid, ttl = tp + 1;\\n            while(ttl > 1){\\n                ttl >>= 1;\\n                if (pos > ttl){\\n                    pos -= ttl;\\n                    cur = cur.right;\\n                }else{\\n                    cur = cur.left;\\n                }\\n            }\\n            if (cur != null) lo = mid;\\n            else hi = mid - 1;\\n        }\\n\\n        return tp + lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```Java\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int lvl = 0;\\n        TreeNode cur = root;\\n        while(cur != null){\\n            cur = cur.left;\\n            lvl++;\\n        }\\n        int lo = 1, hi = (int)Math.pow(2, lvl - 1), tp = hi - 1;\\n        while(lo < hi){\\n            cur = root;\\n            int mid = lo + (hi - lo + 1) / 2;\\n            int pos = mid, ttl = tp + 1;\\n            while(ttl > 1){\\n                ttl >>= 1;\\n                if (pos > ttl){\\n                    pos -= ttl;\\n                    cur = cur.right;\\n                }else{\\n                    cur = cur.left;\\n                }\\n            }\\n            if (cur != null) lo = mid;\\n            else hi = mid - 1;\\n        }\\n\\n        return tp + lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762932,
                "title": "java-o-logn-logn-0ms-beats-100",
                "content": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        if(root.left == null && root.right == null) return 1;\\n        \\n        int a = checkLeft(root);\\n        int b = checkRight(root);\\n        \\n        if(a == b){\\n            return (int) Math.pow(2, a) - 1;\\n        }\\n        \\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n    \\n    int checkLeft(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        return 1 + checkLeft(root.left);\\n    }\\n    \\n    int checkRight(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        return 1 + checkRight(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        if(root.left == null && root.right == null) return 1;\\n        \\n        int a = checkLeft(root);\\n        int b = checkRight(root);\\n        \\n        if(a == b){\\n            return (int) Math.pow(2, a) - 1;\\n        }\\n        \\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n    \\n    int checkLeft(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        return 1 + checkLeft(root.left);\\n    }\\n    \\n    int checkRight(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        return 1 + checkRight(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722963,
                "title": "python-solution-with-comment",
                "content": "```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n        \\n        def get_depth(node):\\n            if not node:\\n                return 0\\n            return 1 + get_depth(node.left)\\n        \\n        def dfs(node, n):\\n            if not (node.left or node.right):                   # when it is leaf, return it \\n                return n\\n            elif get_depth(node.left) == get_depth(node.right): # go to right-child\\n                return dfs(node.right, n*2+1)                   # therefor n = n*2 + 1\\n            else:\\n                return dfs(node.left, n*2)                      # go to left-child, so n = n*2\\n            \\n        return  dfs(root, 1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n        \\n        def get_depth(node):\\n            if not node:\\n                return 0\\n            return 1 + get_depth(node.left)\\n        \\n        def dfs(node, n):\\n            if not (node.left or node.right):                   # when it is leaf, return it \\n                return n\\n            elif get_depth(node.left) == get_depth(node.right): # go to right-child\\n                return dfs(node.right, n*2+1)                   # therefor n = n*2 + 1\\n            else:\\n                return dfs(node.left, n*2)                      # go to left-child, so n = n*2\\n            \\n        return  dfs(root, 1)",
                "codeTag": "Java"
            },
            {
                "id": 1603927,
                "title": "c-code-using-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        int leftnode = countNodes(root->left);\\n         int rightnode = countNodes(root->right);\\n        int total = leftnode + rightnode;\\n        return total+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        int leftnode = countNodes(root->left);\\n         int rightnode = countNodes(root->right);\\n        int total = leftnode + rightnode;\\n        return total+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538367,
                "title": "python-binary-search-explained",
                "content": "**Idea**\\nSince it is a complete tree, to count the nodes all we need is the height of the tree and which leaf node is the \"last\" node. In the image below is a tree with heigh `2`, where the leaf node with index `2` is the \"last\" node.\\n\\n![image](https://assets.leetcode.com/users/images/d2c9e369-a9e7-44a1-a516-9645131d6ea1_1635077963.6826.jpeg)\\n\\n\\nWe know that for a tree with height `h` the maximum amount of leaf nodes is `2^h`. So we assign each leaf node an index, from `0` to `2^h-1`. Notice that the binary representation of such index is exactly the path from root to the given leaf node, where `0` is going left and `1` is going right, illustrated in the image above: leaf node `0` has a binary representation of `00` which is `root.left.left`, leaf node `2` is `10` in binary which is then `root.right.right`.\\n\\nMoreover, we can binary search to find the index of such \"last\" leaf node, since the existence of leaf nodes is essetially an array of boolean where the index of the array is the leaf node index: `[true, true, true, false]`. To find the index of the \"last\" leaf node is exactly to find the first `true` in this array.\\n\\n**Time Complexity**\\nO((logN)^2)  where `N` number of nodes.\\n\\nConsidering `h` is the height of the tree. Function `exists` costs `h` and we will call it `log(2^h)` time since there are `2^h ` leaf nodes and we are using binary search, which yields to `h * log(2^h)`, equals to `h*h`. The height of a tree `h` is then `log(N)` where N is the amount of nodes. Therefore the time complexity is O((logN)^2) .\\n**Space Complexity**\\nO(logN) since we use space linear to the height of the tree.\\n\\n```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n        self.height = self.countHeight(root)\\n        if self.height == 0:\\n            return 1\\n        \\n        # binary search\\n        lo = 0\\n        hi = 2 ** self.height - 1\\n        lastIdx = -1\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if self.exists(root, mid):\\n                lastIdx = mid\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n                \\n        nonLeafNodesCount = 2 ** self.height - 1\\n        # since node start from index 0, the amount of leaf nodes is lastIdx + 1\\n        return nonLeafNodesCount + lastIdx + 1\\n    \\n    def exists(self, root, idx):\\n        # first retrieve the binary representation, which is also the path \\n        # from root to the leaf node\\n        # 0 represents going left, 1 represents going right\\n        path = [0] * self.height\\n        n = idx\\n        i = self.height - 1\\n        while i >= 0:\\n            path[i] = 0 if n % 2 == 0 else 1\\n            n = n >> 1\\n            i -= 1\\n        cur = root\\n        \\n        for direction in path:\\n            if direction == 0:\\n                cur = cur.left\\n            else:\\n                cur = cur.right\\n            if not cur:\\n                return False\\n        return True\\n        \\n    def countHeight(self, root):\\n        height = 0\\n        cur = root\\n        while cur.left:\\n            height += 1\\n            cur = cur.left\\n        return height     \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNodes(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n        self.height = self.countHeight(root)\\n        if self.height == 0:\\n            return 1\\n        \\n        # binary search\\n        lo = 0\\n        hi = 2 ** self.height - 1\\n        lastIdx = -1\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if self.exists(root, mid):\\n                lastIdx = mid\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n                \\n        nonLeafNodesCount = 2 ** self.height - 1\\n        # since node start from index 0, the amount of leaf nodes is lastIdx + 1\\n        return nonLeafNodesCount + lastIdx + 1\\n    \\n    def exists(self, root, idx):\\n        # first retrieve the binary representation, which is also the path \\n        # from root to the leaf node\\n        # 0 represents going left, 1 represents going right\\n        path = [0] * self.height\\n        n = idx\\n        i = self.height - 1\\n        while i >= 0:\\n            path[i] = 0 if n % 2 == 0 else 1\\n            n = n >> 1\\n            i -= 1\\n        cur = root\\n        \\n        for direction in path:\\n            if direction == 0:\\n                cur = cur.left\\n            else:\\n                cur = cur.right\\n            if not cur:\\n                return False\\n        return True\\n        \\n    def countHeight(self, root):\\n        height = 0\\n        cur = root\\n        while cur.left:\\n            height += 1\\n            cur = cur.left\\n        return height     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400878,
                "title": "c-recursion-o-logn-logn",
                "content": "class Solution {\\npublic:\\n\\n    pair<bool, int> isperfectbinary(TreeNode* root){\\n        TreeNode* temp =  root;\\n        int hleft = 0, hright = 0;\\n        while(temp){\\n            hleft++;\\n            temp =temp->left;\\n        }\\n        while(temp){\\n            hright++;\\n            temp = temp->right;\\n        }\\n        return {hleft == hright, hleft};\\n    }\\n    \\n    int countNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        int cnt = 1;\\n        pair<bool, int> pleft = isperfectbinary(root->left);\\n        pair<bool, int> pright = isperfectbinary(root->right);\\n        \\n        if(pleft.first){\\n            cnt += pow(2, pleft.second) - 1;\\n        }else{\\n            cnt += countNodes(root->left);\\n        }\\n        if(pright.first){\\n            cnt += pow(2, pright.second) - 1;\\n        }else{\\n            cnt += countNodes(root->right);\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    pair<bool, int> isperfectbinary(TreeNode* root){\\n        TreeNode* temp =  root;\\n        int hleft = 0, hright = 0;\\n        while(temp){\\n            hleft++;\\n            temp =temp->left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1397595,
                "title": "golang-binary-search-time-o-logn-logn",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc countNodes(root *TreeNode) int {\\n    if root == nil {\\n        return 0\\n    }\\n    leftHeight := getHeight(root.Left)\\n    rightHeight := getHeight(root.Right)\\n    res := 1\\n    if leftHeight == rightHeight {\\n        //we go to right\\n        res += (1 << leftHeight) - 1 //left subtree nodes\\n        res += countNodes(root.Right)\\n    } else {\\n        res += (1 << rightHeight) - 1 //right subtree nodes\\n        res += countNodes(root.Left)\\n    }\\n    return res\\n}\\n\\nfunc getHeight(node *TreeNode) int {\\n    if node == nil {\\n        return 0\\n    }\\n    return 1 + getHeight(node.Left)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc countNodes(root *TreeNode) int {\\n    if root == nil {\\n        return 0\\n    }\\n    leftHeight := getHeight(root.Left)\\n    rightHeight := getHeight(root.Right)\\n    res := 1\\n    if leftHeight == rightHeight {\\n        //we go to right\\n        res += (1 << leftHeight) - 1 //left subtree nodes\\n        res += countNodes(root.Right)\\n    } else {\\n        res += (1 << rightHeight) - 1 //right subtree nodes\\n        res += countNodes(root.Left)\\n    }\\n    return res\\n}\\n\\nfunc getHeight(node *TreeNode) int {\\n    if node == nil {\\n        return 0\\n    }\\n    return 1 + getHeight(node.Left)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1340505,
                "title": "python-o-log-n-solution",
                "content": "First find the depth of the left-most node, call it d1 (where depth of root = 0). Then find depth of right-most node, call it d2. Since the tree is complete, d1 == d2 or d1-1 == d2. If d1 == d2, then the total number of nodes will be 2^(d1+1)-1, since the tree is fully populated. On the other hand, if d1-1 == d2, we compute the number of leaves by traversing the tree again up to the last but one level and the parent node to the leaves will check how many child leaves exist. The number of nodes up till the last but one level is 2^(d1)-1. Thus, the total number of nodes will be 2^(d1)-1 + number of leaves. Note that we do not visit the leaf nodes in the second step and so only log(N) nodes are visited. \\n\\n\\n\\t\\tif root == None:\\n            return 0\\n        \\n        d1 = 0\\n        n = root\\n        while n.left is not None:\\n            n = n.left\\n            d1 += 1\\n        \\n        d2 = 0\\n        n = root\\n        while n.right is not None:\\n            n = n.right\\n            d2 += 1\\n        \\n        assert d1 == d2 or d1-1 == d2\\n        \\n        if d1 == d2:\\n            return 2**(d1+1)-1\\n        \\n        self.leaves = 0\\n            \\n        def trav_tree(n, depth):\\n                \\n            if depth == d2:\\n                if n.right is not None:\\n                    self.leaves += 2\\n                elif n.left is not None and n.right == None:\\n                    self.leaves += 1\\n                \\n            if depth < d2:\\n                trav_tree(n.left, depth+1)\\n                trav_tree(n.right, depth+1)\\n            \\n        trav_tree(root, 0)\\n        \\n        return 2**(d1)-1 + self.leaves \\n",
                "solutionTags": [],
                "code": "First find the depth of the left-most node, call it d1 (where depth of root = 0). Then find depth of right-most node, call it d2. Since the tree is complete, d1 == d2 or d1-1 == d2. If d1 == d2, then the total number of nodes will be 2^(d1+1)-1, since the tree is fully populated. On the other hand, if d1-1 == d2, we compute the number of leaves by traversing the tree again up to the last but one level and the parent node to the leaves will check how many child leaves exist. The number of nodes up till the last but one level is 2^(d1)-1. Thus, the total number of nodes will be 2^(d1)-1 + number of leaves. Note that we do not visit the leaf nodes in the second step and so only log(N) nodes are visited. \\n\\n\\n\\t\\tif root == None:\\n            return 0\\n        \\n        d1 = 0\\n        n = root\\n        while n.left is not None:\\n            n = n.left\\n            d1 += 1\\n        \\n        d2 = 0\\n        n = root\\n        while n.right is not None:\\n            n = n.right\\n            d2 += 1\\n        \\n        assert d1 == d2 or d1-1 == d2\\n        \\n        if d1 == d2:\\n            return 2**(d1+1)-1\\n        \\n        self.leaves = 0\\n            \\n        def trav_tree(n, depth):\\n                \\n            if depth == d2:\\n                if n.right is not None:\\n                    self.leaves += 2\\n                elif n.left is not None and n.right == None:\\n                    self.leaves += 1\\n                \\n            if depth < d2:\\n                trav_tree(n.left, depth+1)\\n                trav_tree(n.right, depth+1)\\n            \\n        trav_tree(root, 0)\\n        \\n        return 2**(d1)-1 + self.leaves \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1318391,
                "title": "recursive-java-solution-beats-100-of-solutions-intuitive-explained",
                "content": "\\n```\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;     // handle case where root = null\\n        return countNodesUtil(root);\\n    }\\n    \\n    public int countNodesUtil(TreeNode node){\\n        int lCount = 0, rCount = 0, sum = 1;\\n\\t\\t\\n\\t\\t//recurr until h - 1 nodes\\n        if(node.left != null && node.left.left != null){\\n            lCount = countNodesUtil(node.left);\\n            rCount = countNodesUtil(node.right);\\n        }else{\\n\\t\\t\\t//you\\'re at h-1 level. \\n\\t\\t\\t//If node.right != null -->add 2 nodes to size since last level is filled from left\\n            if(node.right != null) sum += 2;\\n\\t\\t\\t//If node.left != null -->add 1 node to size since last level is filled from left\\n            else if(node.left != null) sum += 1;\\n        }\\n\\t\\t//count from left + count from right + sum\\n        return lCount + rCount + sum; \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;     // handle case where root = null\\n        return countNodesUtil(root);\\n    }\\n    \\n    public int countNodesUtil(TreeNode node){\\n        int lCount = 0, rCount = 0, sum = 1;\\n\\t\\t\\n\\t\\t//recurr until h - 1 nodes\\n        if(node.left != null && node.left.left != null){\\n            lCount = countNodesUtil(node.left);\\n            rCount = countNodesUtil(node.right);\\n        }else{\\n\\t\\t\\t//you\\'re at h-1 level. \\n\\t\\t\\t//If node.right != null -->add 2 nodes to size since last level is filled from left\\n            if(node.right != null) sum += 2;\\n\\t\\t\\t//If node.left != null -->add 1 node to size since last level is filled from left\\n            else if(node.left != null) sum += 1;\\n        }\\n\\t\\t//count from left + count from right + sum\\n        return lCount + rCount + sum; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799214,
                "title": "google-phone-interview-o-logn-o-logn-binary-search-sol-in-cpp",
                "content": "- Function `exist` checks whether a node with given index exists in O(logn) time.\\n- Use binary search to find first index whose corresponding node doesn\\'t exist.\\n- The idea comes from a google phone interview, see my solution here: https://leetcode.com/discuss/interview-question/236898/Google-or-Check-if-a-node-exists-in-a-complete-tree/237628\\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    bool exist(TreeNode* root, int idx) {\\n        string bin;\\n        while (idx) {\\n            if (idx & 1)\\n                bin += \\'1\\';\\n            else\\n                bin += \\'0\\';\\n            idx >>= 1;\\n        }\\n        for (int i = bin.size() - 2; i >= 0; i--) {\\n            if (root == nullptr)\\n                return false;\\n            if (bin[i] == \\'1\\')\\n                root = root->right;\\n            else\\n                root = root->left;\\n        }\\n        return root != nullptr;\\n    }\\npublic:\\n    int countNodes(TreeNode* root) {\\n        int lo = 1, hi = INT_MAX;\\n        exist(root, 11);\\n        while (lo < hi) {\\n            int mi = (hi - lo) / 2 + lo;\\n            if (exist(root, mi))\\n                lo = mi + 1;\\n            else\\n                hi = mi;\\n        }\\n        return lo - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    bool exist(TreeNode* root, int idx) {\\n        string bin;\\n        while (idx) {\\n            if (idx & 1)\\n                bin += \\'1\\';\\n            else\\n                bin += \\'0\\';\\n            idx >>= 1;\\n        }\\n        for (int i = bin.size() - 2; i >= 0; i--) {\\n            if (root == nullptr)\\n                return false;\\n            if (bin[i] == \\'1\\')\\n                root = root->right;\\n            else\\n                root = root->left;\\n        }\\n        return root != nullptr;\\n    }\\npublic:\\n    int countNodes(TreeNode* root) {\\n        int lo = 1, hi = INT_MAX;\\n        exist(root, 11);\\n        while (lo < hi) {\\n            int mi = (hi - lo) / 2 + lo;\\n            if (exist(root, mi))\\n                lo = mi + 1;\\n            else\\n                hi = mi;\\n        }\\n        return lo - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701452,
                "title": "simple-java-solution-with-explaination-logn-logn-times-100-faster-0ms",
                "content": "**Approach 1 -**\\n\\nJust count nodes. but that takes o(n) time.\\n\\n**Approach 2 -**\\n\\n1.A fully completed tree has node number-> count = 2 ^ depth - 1\\nfor example: [1,4,5]\\ndepth is 2\\ncount = 2 ^ 2 - 1 = 3\\n2.Compare left height and right height, if equal, use the formula, otherwise recurvisely search left and right at next level\\n3.The search pattern is very similar to binary search, the difference of heights either exists in left side, or right side\\n4.Due to the reason stated in point 3, the time complexity is h ^ 2, there is h times for each level, and h times for calculating height at each level.\\n5. to avoid using power function left shift operator is used 1<<h is equal to pow(2,h)\\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int left = height(root,true);\\n        int right = height(root,false);\\n        if(left==right) {\\n            return (1<<left)-1;\\n        }\\n        return countNodes(root.left)+countNodes(root.right)+1;\\n    }\\n    \\n    private int height(TreeNode root,boolean isLeft) {\\n        int h=0;\\n        while(root!=null) {\\n            root=isLeft?root.left:root.right;\\n            h++;\\n        }\\n        return h;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        int left = height(root,true);\\n        int right = height(root,false);\\n        if(left==right) {\\n            return (1<<left)-1;\\n        }\\n        return countNodes(root.left)+countNodes(root.right)+1;\\n    }\\n    \\n    private int height(TreeNode root,boolean isLeft) {\\n        int h=0;\\n        while(root!=null) {\\n            root=isLeft?root.left:root.right;\\n            h++;\\n        }\\n        return h;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564764,
                "title": "log-n-log-n-with-huffman-coding-technique-java-100-faster",
                "content": "For tree numbered sequentially and complete tree we can get the sequence number of any node by the below technique.\\nLet binaryString = \"1\"; // For root\\n1. Moving left add 0, binary string becomes \"10\"\\n2. Moving right add 1, binary string becomes \"11\"\\n\\nHe I tried to reach to the last node and got the binary sequence. Converting the binary sequence to interger will give the sequence number of the node.\\n\\n![image](https://assets.leetcode.com/users/ashishdey0/image_1586075459.png)\\n\\n\\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if (root == null)\\n        {\\n            return 0;\\n        }\\n        \\n        String binary = \"1\";\\n        int treeHeight = getLeftMostNodeHeight(root);\\n        while (!(root.left == null && root.right == null))\\n        {\\n            int rightsLeftMostNodeHeight = getLeftMostNodeHeight(root.right) + 1;    \\n            if (treeHeight == rightsLeftMostNodeHeight)\\n            {\\n                root = root.right;\\n                binary += 1;\\n            } \\n            else\\n            {\\n                root = root.left;\\n                binary += 0;\\n            }\\n            \\n            treeHeight--;\\n        }\\n                \\n        return Integer.parseInt(binary, 2);\\n        \\n    }\\n\\n    int getLeftMostNodeHeight(TreeNode root)\\n    {\\n        int h = 0;\\n        while (root != null)\\n        {\\n            root = root.left;\\n            h++;\\n        }\\n        \\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if (root == null)\\n        {\\n            return 0;\\n        }\\n        \\n        String binary = \"1\";\\n        int treeHeight = getLeftMostNodeHeight(root);\\n        while (!(root.left == null && root.right == null))\\n        {\\n            int rightsLeftMostNodeHeight = getLeftMostNodeHeight(root.right) + 1;    \\n            if (treeHeight == rightsLeftMostNodeHeight)\\n            {\\n                root = root.right;\\n                binary += 1;\\n            } \\n            else\\n            {\\n                root = root.left;\\n                binary += 0;\\n            }\\n            \\n            treeHeight--;\\n        }\\n                \\n        return Integer.parseInt(binary, 2);\\n        \\n    }\\n\\n    int getLeftMostNodeHeight(TreeNode root)\\n    {\\n        int h = 0;\\n        while (root != null)\\n        {\\n            root = root.left;\\n            h++;\\n        }\\n        \\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514004,
                "title": "rust-recursive-solution",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn count_nodes(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        if let Some(r) = root {\\n            let ld = {\\n                let mut h = 1;\\n                let mut node = r.borrow().left.clone();\\n                while let Some(n) = node {\\n                    h += 1;\\n                    node = n.borrow().left.clone();\\n                }\\n                h\\n            };\\n            let rd = {\\n                let mut h = 1;\\n                let mut node = r.borrow().right.clone();\\n                while let Some(n) = node {\\n                    h += 1;\\n                    node = n.borrow().right.clone();\\n                }\\n                h\\n            };\\n            if ld == rd {\\n                2i32.pow(ld) - 1\\n            } else {\\n                1 + Solution::count_nodes(r.borrow().left.clone())\\n                    + Solution::count_nodes(r.borrow().right.clone())\\n            }\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn count_nodes(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        if let Some(r) = root {\\n            let ld = {\\n                let mut h = 1;\\n                let mut node = r.borrow().left.clone();\\n                while let Some(n) = node {\\n                    h += 1;\\n                    node = n.borrow().left.clone();\\n                }\\n                h\\n            };\\n            let rd = {\\n                let mut h = 1;\\n                let mut node = r.borrow().right.clone();\\n                while let Some(n) = node {\\n                    h += 1;\\n                    node = n.borrow().right.clone();\\n                }\\n                h\\n            };\\n            if ld == rd {\\n                2i32.pow(ld) - 1\\n            } else {\\n                1 + Solution::count_nodes(r.borrow().left.clone())\\n                    + Solution::count_nodes(r.borrow().right.clone())\\n            }\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459041,
                "title": "java-0-ms-o-lgn-lgn-intuitive-eliminating-half-tree-at-each-step",
                "content": "On observing a complete binary tree, we notice that it fulfills one of the following cases:\\n```\\nCase 1: Tree is a full binary tree with all leaves at last level\\n        1\\n      /   \\\\\\n     2     3\\n    / \\\\   / \\\\\\n   4   5 6   7       count =  2^(level+1)-1\\n\\nCase 2: Left subtree is full\\n        1\\n      /   \\\\\\n     2     3\\n    / \\\\   / \\n   4   5 6           count = size of root(1) + left full tree + recurse in right subtree\\n\\nCase 3: Right subtree is full\\n        1\\n      /   \\\\\\n     2     3\\n    / \\\\   / \\\\\\n   4   5 6   7\\n  / \\\\\\n 8   9                count = size of root(1) + right full tree + recurse in left subtree\\n```\\n\\nThat will form the main function. Now, the question comes down to how to identify if a complete binary tree is full? Simple. Look at the depths of the tree through the leftmost nodes vs. rightmost nodes. If left depth == right depth, you have a full binary tree.\\n\\nHere\\'s the code:\\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if (root==null) return 0;\\n        int ld = leftDepth(root);\\n        int rd = rightDepth(root);\\n        if (ld==rd) // full tree\\n            return (int)Math.pow(2, ld+1)-1;\\n        int lrd = rightDepth(root.left);\\n        if (lrd==ld-1) {// left subtree is full\\n            return (int)Math.pow(2, ld) + countNodes(root.right);\\n        } else {// right subtree is full\\n            return (int)Math.pow(2, rd) + countNodes(root.left);\\n        }\\n    }\\n    \\n    private int leftDepth(TreeNode root) {\\n        if (root==null) return 0;\\n        int d = 0;\\n        while (root.left!=null) {\\n            root=root.left;\\n            d++;\\n        }\\n        return d;\\n    }\\n    \\n    private int rightDepth(TreeNode root) {\\n        if (root==null) return 0;\\n        int d = 0;\\n        while (root.right!=null) {\\n            root=root.right;\\n            d++;\\n        }\\n        return d;\\n    }\\n}\\n```\\nEdit: Using the optimizations mentioned by [@aarvee](https://leetcode.com/aarvee) , we can modify the recursive calls to avoid repeated call to leftDepth or rightDepth. The new function becomes:\\n```\\npublic int countNodes(TreeNode root) {\\n\\treturn countNodes(root, -1, -1);\\n}\\n\\nprivate int countNodes(TreeNode root, int leftDepth, int rightDepth) {\\n\\tif (root==null) return 0;\\n\\t// calculate depths only if not already available\\n\\tint ld = leftDepth == -1 ? leftDepth(root) : leftDepth;\\n\\tint rd = rightDepth == -1 ? rightDepth(root) : rightDepth;\\n\\tif (ld==rd) // full tree\\n\\t\\treturn (int)Math.pow(2, ld+1)-1;\\n\\tint lrd = rightDepth(root.left);\\n\\tif (lrd==ld-1) {//left subtree is full\\n\\t\\treturn (int)Math.pow(2, ld) + countNodes(root.right, -1, rd-1);\\n\\t} else {// right subtree is full\\n\\t\\treturn (int)Math.pow(2, rd) + countNodes(root.left, ld-1, -1);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nCase 1: Tree is a full binary tree with all leaves at last level\\n        1\\n      /   \\\\\\n     2     3\\n    / \\\\   / \\\\\\n   4   5 6   7       count =  2^(level+1)-1\\n\\nCase 2: Left subtree is full\\n        1\\n      /   \\\\\\n     2     3\\n    / \\\\   / \\n   4   5 6           count = size of root(1) + left full tree + recurse in right subtree\\n\\nCase 3: Right subtree is full\\n        1\\n      /   \\\\\\n     2     3\\n    / \\\\   / \\\\\\n   4   5 6   7\\n  / \\\\\\n 8   9                count = size of root(1) + right full tree + recurse in left subtree\\n```\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if (root==null) return 0;\\n        int ld = leftDepth(root);\\n        int rd = rightDepth(root);\\n        if (ld==rd) // full tree\\n            return (int)Math.pow(2, ld+1)-1;\\n        int lrd = rightDepth(root.left);\\n        if (lrd==ld-1) {// left subtree is full\\n            return (int)Math.pow(2, ld) + countNodes(root.right);\\n        } else {// right subtree is full\\n            return (int)Math.pow(2, rd) + countNodes(root.left);\\n        }\\n    }\\n    \\n    private int leftDepth(TreeNode root) {\\n        if (root==null) return 0;\\n        int d = 0;\\n        while (root.left!=null) {\\n            root=root.left;\\n            d++;\\n        }\\n        return d;\\n    }\\n    \\n    private int rightDepth(TreeNode root) {\\n        if (root==null) return 0;\\n        int d = 0;\\n        while (root.right!=null) {\\n            root=root.right;\\n            d++;\\n        }\\n        return d;\\n    }\\n}\\n```\n```\\npublic int countNodes(TreeNode root) {\\n\\treturn countNodes(root, -1, -1);\\n}\\n\\nprivate int countNodes(TreeNode root, int leftDepth, int rightDepth) {\\n\\tif (root==null) return 0;\\n\\t// calculate depths only if not already available\\n\\tint ld = leftDepth == -1 ? leftDepth(root) : leftDepth;\\n\\tint rd = rightDepth == -1 ? rightDepth(root) : rightDepth;\\n\\tif (ld==rd) // full tree\\n\\t\\treturn (int)Math.pow(2, ld+1)-1;\\n\\tint lrd = rightDepth(root.left);\\n\\tif (lrd==ld-1) {//left subtree is full\\n\\t\\treturn (int)Math.pow(2, ld) + countNodes(root.right, -1, rd-1);\\n\\t} else {// right subtree is full\\n\\t\\treturn (int)Math.pow(2, rd) + countNodes(root.left, ld-1, -1);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361309,
                "title": "java-o-log-n-2-solution",
                "content": "```java\\n// time: O(log(n)^2)\\n// space: O(1)\\npublic int countNodes(TreeNode root) {\\n\\tif (root == null) return 0;\\n\\tint h = height(root);\\n\\tif (height(root.right) == h-1)\\n\\t\\treturn (1 << h) + countNodes(root.right);\\n\\telse\\n\\t\\treturn (1 << (h-1)) + countNodes(root.left);\\n}\\n\\npublic int height(TreeNode root) {\\n\\tif (root == null) return -1;\\n\\tint res = 0;\\n\\twhile (root.left != null) {\\n\\t\\tres++;\\n\\t\\troot = root.left;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// time: O(log(n)^2)\\n// space: O(1)\\npublic int countNodes(TreeNode root) {\\n\\tif (root == null) return 0;\\n\\tint h = height(root);\\n\\tif (height(root.right) == h-1)\\n\\t\\treturn (1 << h) + countNodes(root.right);\\n\\telse\\n\\t\\treturn (1 << (h-1)) + countNodes(root.left);\\n}\\n\\npublic int height(TreeNode root) {\\n\\tif (root == null) return -1;\\n\\tint res = 0;\\n\\twhile (root.left != null) {\\n\\t\\tres++;\\n\\t\\troot = root.left;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295712,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public int CountNodes(TreeNode root) {\\n        var leftDepth = GetLeftDepth(root);\\n        var rightDepth = GetRightDepth(root);\\n\\n        if (leftDepth == rightDepth) {\\n            return (int)Math.Pow(2, leftDepth) - 1;\\n        }\\n        return CountNodes(root.left) + CountNodes(root.right) + 1;\\n    }\\n\\n    private int GetLeftDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        return GetLeftDepth(root.left) + 1;\\n    }\\n\\n    private int GetRightDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        return GetRightDepth(root.right) + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountNodes(TreeNode root) {\\n        var leftDepth = GetLeftDepth(root);\\n        var rightDepth = GetRightDepth(root);\\n\\n        if (leftDepth == rightDepth) {\\n            return (int)Math.Pow(2, leftDepth) - 1;\\n        }\\n        return CountNodes(root.left) + CountNodes(root.right) + 1;\\n    }\\n\\n    private int GetLeftDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        return GetLeftDepth(root.left) + 1;\\n    }\\n\\n    private int GetRightDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        return GetRightDepth(root.right) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295362,
                "title": "java-code-beats-100-in-3-line",
                "content": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left)+countNodes(root.right)+1;\\n    }\\n}\\n\\n// Consider Recursive approach for the tree problems first\\n//For the complete Node, it is always a node if it is not null(which means that you do not need to consider the status of its children)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left)+countNodes(root.right)+1;\\n    }\\n}\\n\\n// Consider Recursive approach for the tree problems first\\n//For the complete Node, it is always a node if it is not null(which means that you do not need to consider the status of its children)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265456,
                "title": "swift-two-line-solution",
                "content": "Time complexity O(N), N is the number of nodes in this tree.\\n```\\nclass Solution {\\n    func countNodes(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n\\t\\treturn 1 + countNodes(root.left) + countNodes(root.right)\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func countNodes(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n\\t\\treturn 1 + countNodes(root.left) + countNodes(root.right)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241237,
                "title": "java-solution-w-picture-explanation",
                "content": "![image](https://assets.leetcode.com/users/sunnymeow/image_1550736413.png)\\n1. get the height of left and right subtree\\n2. compare the height\\n\\t- if left == right, then the left subtree must be complete\\n\\t- if left > right, then the right subtree must be complete\\n\\t- if a subtree is complete, the number of whole subtree + the root = 2^subtree height\\n3. recursion\\n\\n```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int leftHeight = getHeight(root.left);\\n        int rightHeight = getHeight(root.right);\\n        \\n        // left tree is complete\\n        if (leftHeight == rightHeight) {\\n            return (1 << leftHeight) + countNodes(root.right);\\n        } \\n        // right tree is complete\\n        return (1 << rightHeight) + countNodes(root.left); \\n    }\\n    \\n    public int getHeight(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }    \\n        return 1 + Math.max(getHeight(root.left), getHeight(root.right));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int leftHeight = getHeight(root.left);\\n        int rightHeight = getHeight(root.right);\\n        \\n        // left tree is complete\\n        if (leftHeight == rightHeight) {\\n            return (1 << leftHeight) + countNodes(root.right);\\n        } \\n        // right tree is complete\\n        return (1 << rightHeight) + countNodes(root.left); \\n    }\\n    \\n    public int getHeight(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }    \\n        return 1 + Math.max(getHeight(root.left), getHeight(root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569575,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1575888,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1570647,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 2010748,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1949002,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 2058771,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1685371,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1573628,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1572829,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1572426,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1569575,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1575888,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1570647,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 2010748,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1949002,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 2058771,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1685371,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1573628,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1572829,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 1572426,
                "content": [
                    {
                        "username": "adorabledev",
                        "content": "How is this even a medium?"
                    },
                    {
                        "username": "R2Wang",
                        "content": "It is intuitive to guess log(N). As we all know, going from top to bottom takes log(N) times. Then it is the tricky part, how to take advantage of this. I came up with the answer after this: 1) it is easy to get the depth of the tree 2) Can we do something like binary search to find the last node, therefore knowing the total #. After having this \"binary search\" idea, I began to write a litte bit of the code, think how to implement this \"binary\" idea, then I find the recursion."
                    },
                    {
                        "username": "chakder",
                        "content": "Cause, you are expected to solve in O(log(n) * log(n)) time... doing in o(n) is not the intended solution... like a follow up question"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Because of your comment, I went back to take a deeper look at the question otherwise the wording of problem description was enough to intimidate me haha ;)"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Not sure, but I\\'ll take a free daily anytime :-) "
                    },
                    {
                        "username": "hosua",
                        "content": "That\\'s a very good question lol"
                    },
                    {
                        "username": "fekico7489",
                        "content": "Your comment holds true 3 years later \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "glugglug",
                        "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this."
                    },
                    {
                        "username": "godshiva",
                        "content": "I\\'m not gonna give anybody a hard time for thumbsing down this question for that exact reason. But it was still an interesting thought experiment."
                    },
                    {
                        "username": "priyankkoul",
                        "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2)."
                    },
                    {
                        "username": "conquer",
                        "content": "[@over_under](/over_under) Hi,\\nInitially, we cut the tree into two branches. If the counts of nodes in the far-right and far-left branches are equal, we promptly provide the answer. If it\\'s not we cut the tree again to two branches. As we proceed with this process, the complexity of determining the answer follows a pattern of n/2, n/4, n/8, and so forth."
                    },
                    {
                        "username": "itsHitler_999",
                        "content": "[@over_under](/over_under)  we can use binary search using bitmask."
                    },
                    {
                        "username": "over_under",
                        "content": "Regarding this approach, I couldn\\'t get the idea on how to implement binary search on tree nodes though. Like when we have a list we simply know where each index lies, but for a tree we are given with the root node only, how to traverse to the mid node between left = 0 and right = n/2 - 1, how do we make the decision to goto left or right of a node when we don\\'t have indexing, etc.\\n      If anyone does know and understand this approach, I would be grateful if you could clarify this to me."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL"
                    },
                    {
                        "username": "michaelmo123",
                        "content": "i suspect that 'less than O(N)' was a 'follow up' clause at some stage, and that they changed the description without changing the difficulty of the problem."
                    },
                    {
                        "username": "SteveGan",
                        "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here."
                    },
                    {
                        "username": "keerthanss",
                        "content": "Binary search works based on the position, which is ordered. The actual values in that position are not used, nor relevant."
                    },
                    {
                        "username": "Iseiryu",
                        "content": "This is a valid test case and the nodes\\' values are NOT in order.\\n```\\n[5,2,30,4,2,1]\\n```"
                    },
                    {
                        "username": "ugonna100",
                        "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I think the editor overlooked the less than O(n) TC requirement. This is definitely medium at least."
                    },
                    {
                        "username": "godshiva",
                        "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number."
                    },
                    {
                        "username": "Estevao",
                        "content": "Hi guys. The problem doesn\\'t explicitly says if the tree could be `null`. But I think that according to the definition that it quotes, the root can\\'t be `null`. Because, by the definition, a complete tree must have at least 1 node in the last level, and the problem says \"given a complete binary tree\". So, as I thought, if the tree given is said to be complete and it defines that it has at least one node in the last level, the tree must be non-null. \\nDon\\'t get me wrong, I don\\'t want to be annoying or anything, but that\\'s really what a thought, and I got surprised when I find out after submitting that the judge does check for a `null` root tree."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The constraints now include the length of the tree, and it can be as small as 0, i.e., root is null"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "https://www.cnblogs.com/yrbbest/p/4993469.html\\n\\nPS.\\n\\u6700\\u8FD1\\u82E6\\u4E8Eleetcode\\u4E0A\\u7684\\u89E3\\u7B54\\u8D28\\u91CF\\u53C2\\u5DEE\\u4E0D\\u9F50\\u8BB8\\u591A\\u89E3\\u7B54\\u770B\\u4E0D\\u61C2\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u628A\\u81EA\\u5DF1\\u89C9\\u5F97ok\\u7684\\u89E3\\u7B54\\u94FE\\u63A5\\u9644\\u5728\\u8FD9\\u91CC\\u65B9\\u4FBF\\u8001\\u54E5\\u8001\\u59D0\\u76F4\\u63A5\\u67E5\\u770B\\u3002\\u975E\\u539F\\u4F5C\\uFF0C\\u8F6C\\u8F7D\\u3002\\n\\u9274\\u4E8Eleetcode\\u6E05\\u4E00\\u8272\\u82F1\\u6587\\u89E3\\u7B54\\u82F1\\u6587\\u53D1\\u5E16\\uFF0C\\u6211\\u4E0D\\u77E5\\u9053\\u53D1\\u4E2D\\u6587\\u5E16\\u5B50\\u597D\\u4E0D\\u597D\\u3002\\n\\u5982\\u679C\\u8001\\u54E5\\u8001\\u59D0\\u4E0D\\u8BA4\\u53EF\\u6211\\u7684\\u505A\\u6CD5\\u8BF7\\u4E2D\\u6587\\u56DE\\u590D\\u6211\\uFF0C\\u6211\\u4F1A\\u505C\\u6B62\\u53D1\\u5E16\\u3002\\n\\u5982\\u679C\\u8BA4\\u540C\\uFF0C\\u671B\\u8001\\u54E5\\u8001\\u59D0\\u9644\\u4E0A\\u81EA\\u5DF1\\u89C9\\u5F97\\u597D\\u7684leetcode\\u89E3\\u7B54\\uFF0C\\u65B9\\u4FBF\\u540E\\u4EBA\\u540C\\u65F6\\u4E3A\\u81EA\\u5DF1\\u7701\\u65F6\\u95F4\\u5E76\\u4E14\\u6709bookmark?"
                    },
                    {
                        "username": "fzakaria",
                        "content": "Kinda stupid."
                    }
                ]
            },
            {
                "id": 2040241,
                "content": [
                    {
                        "username": "LesterX",
                        "content": "How is this a easy?"
                    },
                    {
                        "username": "kve315",
                        "content": "I hate it when they don\\'t get the difficulty level for a question right. How is this a medium?"
                    },
                    {
                        "username": "sk3404",
                        "content": "it\\'s \"Easy\" now"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ , striver solution. less than O(n) complexity. Optimal\\n\\n# Approach\\n\\n1. The function `findLeftHeight` takes a TreeNode pointer `root` as input and returns the height of the left subtree rooted at `root`. It initializes a variable `count` to 0.\\n\\n2. While `root` is not null:\\n   a. Update `root` to its left child (`root = root->left`).\\n   b. Increment `count` by 1.\\n\\n3. Return the final value of `count`, which represents the height of the left subtree.\\n\\n4. The function `findRightHeight` is similar to `findLeftHeight` but calculates the height of the right subtree.\\n\\n5. The function `countNodes` takes a TreeNode pointer `root` as input and returns the total number of nodes in the tree rooted at `root`.\\n\\n6. If `root` is null, i.e., the tree is empty, return 0.\\n\\n7. Calculate the left height of the tree using `findLeftHeight(root)` and store it in variable `l`.\\n\\n8. Calculate the right height of the tree using `findRightHeight(root)` and store it in variable `r`.\\n\\n9. If the left and right heights are equal (`l == r`), it means the tree is a perfect binary tree. In this case, return `pow(2, l) - 1`, which gives the total number of nodes in a perfect binary tree of height `l`.\\n\\n10. If the left and right heights are not equal, the tree is not a perfect binary tree. In this case, return `1 + countNodes(root->left) + countNodes(root->right)`. This recursively calculates the total number of nodes in the left and right subtrees and adds 1 for the current root node.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(logn)^2\\n\\n- Space complexity:\\nS.C=O(logn)\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/count-complete-tree-nodes/solutions/3704687/c-striver-solution-less-than-o-n-complexity-optimal/"
                    },
                    {
                        "username": "user0223qc",
                        "content": "The runtime complexity of your approach is O(n). In your approach your 10th point states that if left height not equals your right height, then you need to calculate the count of left subtree and right subtree which is equal to counting all the nodes in the tree. The time complexity here is you visit all the nodes in the tree and it take time n. Hence your approach is O(n). Isn\\'t it?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Don\\'t tell me if anyone used an ArrayList in this question also.\\uD83E\\uDD23"
                    },
                    {
                        "username": "GregorySDTaylor",
                        "content": "* Originally, I assumed that the previous row depth would need to be calculated iteratively. Now I see that that there is a formula for the nodes in a full tree: (2 ^ depth) -1\\n* I also assumed that the binary search would need to find two adjacent nodes, one existing and one empty. Turns out the binary search process does this for you."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Complete binary tree: all levels are complete, last level can be incomplete.\\nSo, if leftHeight and rightHeight of a tree are equal, last level is also complete, and total nodes will be 2^height - 1.\\nother wise total nodes will be 1+ count nodes recursively for left and right subtree."
                    },
                    {
                        "username": "dash_dash",
                        "content": "[@phooda804](/phooda804)  leftHeight and rightHeight will take logn each\nand our countNodes will not be called for all nodes mostly it will be called for logn nodes \n\nso i think complexity should be logn* (logn+logn) = logn*logn\n\nplease correct me if i am wrong :P"
                    },
                    {
                        "username": "phooda804",
                        "content": "Isn\\'t this O(N) for recursion?"
                    },
                    {
                        "username": "kessomo",
                        "content": "How are the test case values [1,2,3,4] becomes complete binary tree?!"
                    },
                    {
                        "username": "CHORK",
                        "content": "I would love to solve this kind of problem in OCaml. "
                    },
                    {
                        "username": "Fanindra",
                        "content": "We can do it in O(n) time complexity. Though the question asked us to do it in less then O(n).\\n\\nBy traversing though the tree and incrementing the count.\\n\\nS1 : Create a void function that takes a root and address of an int variable\\n\\nI am doing preorder traversal but you can do any of the DFS\\n\\nS2 increment the count and go to left and right of the tree using recursion\\n\\nS3 in the countNodes function create a int count or any variable\\n\\nS4 call the function created in the S1\\n\\nS5 return ans.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "I am still not sure about the time complexity O(log(n)^2)?, how do we get this,\\nsince according to me in good case T.C should be O(logN) and in worst it may be O(N), please help"
                    }
                ]
            },
            {
                "id": 2000138,
                "content": [
                    {
                        "username": "LesterX",
                        "content": "How is this a easy?"
                    },
                    {
                        "username": "kve315",
                        "content": "I hate it when they don\\'t get the difficulty level for a question right. How is this a medium?"
                    },
                    {
                        "username": "sk3404",
                        "content": "it\\'s \"Easy\" now"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ , striver solution. less than O(n) complexity. Optimal\\n\\n# Approach\\n\\n1. The function `findLeftHeight` takes a TreeNode pointer `root` as input and returns the height of the left subtree rooted at `root`. It initializes a variable `count` to 0.\\n\\n2. While `root` is not null:\\n   a. Update `root` to its left child (`root = root->left`).\\n   b. Increment `count` by 1.\\n\\n3. Return the final value of `count`, which represents the height of the left subtree.\\n\\n4. The function `findRightHeight` is similar to `findLeftHeight` but calculates the height of the right subtree.\\n\\n5. The function `countNodes` takes a TreeNode pointer `root` as input and returns the total number of nodes in the tree rooted at `root`.\\n\\n6. If `root` is null, i.e., the tree is empty, return 0.\\n\\n7. Calculate the left height of the tree using `findLeftHeight(root)` and store it in variable `l`.\\n\\n8. Calculate the right height of the tree using `findRightHeight(root)` and store it in variable `r`.\\n\\n9. If the left and right heights are equal (`l == r`), it means the tree is a perfect binary tree. In this case, return `pow(2, l) - 1`, which gives the total number of nodes in a perfect binary tree of height `l`.\\n\\n10. If the left and right heights are not equal, the tree is not a perfect binary tree. In this case, return `1 + countNodes(root->left) + countNodes(root->right)`. This recursively calculates the total number of nodes in the left and right subtrees and adds 1 for the current root node.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(logn)^2\\n\\n- Space complexity:\\nS.C=O(logn)\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/count-complete-tree-nodes/solutions/3704687/c-striver-solution-less-than-o-n-complexity-optimal/"
                    },
                    {
                        "username": "user0223qc",
                        "content": "The runtime complexity of your approach is O(n). In your approach your 10th point states that if left height not equals your right height, then you need to calculate the count of left subtree and right subtree which is equal to counting all the nodes in the tree. The time complexity here is you visit all the nodes in the tree and it take time n. Hence your approach is O(n). Isn\\'t it?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Don\\'t tell me if anyone used an ArrayList in this question also.\\uD83E\\uDD23"
                    },
                    {
                        "username": "GregorySDTaylor",
                        "content": "* Originally, I assumed that the previous row depth would need to be calculated iteratively. Now I see that that there is a formula for the nodes in a full tree: (2 ^ depth) -1\\n* I also assumed that the binary search would need to find two adjacent nodes, one existing and one empty. Turns out the binary search process does this for you."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Complete binary tree: all levels are complete, last level can be incomplete.\\nSo, if leftHeight and rightHeight of a tree are equal, last level is also complete, and total nodes will be 2^height - 1.\\nother wise total nodes will be 1+ count nodes recursively for left and right subtree."
                    },
                    {
                        "username": "dash_dash",
                        "content": "[@phooda804](/phooda804)  leftHeight and rightHeight will take logn each\nand our countNodes will not be called for all nodes mostly it will be called for logn nodes \n\nso i think complexity should be logn* (logn+logn) = logn*logn\n\nplease correct me if i am wrong :P"
                    },
                    {
                        "username": "phooda804",
                        "content": "Isn\\'t this O(N) for recursion?"
                    },
                    {
                        "username": "kessomo",
                        "content": "How are the test case values [1,2,3,4] becomes complete binary tree?!"
                    },
                    {
                        "username": "CHORK",
                        "content": "I would love to solve this kind of problem in OCaml. "
                    },
                    {
                        "username": "Fanindra",
                        "content": "We can do it in O(n) time complexity. Though the question asked us to do it in less then O(n).\\n\\nBy traversing though the tree and incrementing the count.\\n\\nS1 : Create a void function that takes a root and address of an int variable\\n\\nI am doing preorder traversal but you can do any of the DFS\\n\\nS2 increment the count and go to left and right of the tree using recursion\\n\\nS3 in the countNodes function create a int count or any variable\\n\\nS4 call the function created in the S1\\n\\nS5 return ans.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "I am still not sure about the time complexity O(log(n)^2)?, how do we get this,\\nsince according to me in good case T.C should be O(logN) and in worst it may be O(N), please help"
                    }
                ]
            },
            {
                "id": 1951778,
                "content": [
                    {
                        "username": "LesterX",
                        "content": "How is this a easy?"
                    },
                    {
                        "username": "kve315",
                        "content": "I hate it when they don\\'t get the difficulty level for a question right. How is this a medium?"
                    },
                    {
                        "username": "sk3404",
                        "content": "it\\'s \"Easy\" now"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ , striver solution. less than O(n) complexity. Optimal\\n\\n# Approach\\n\\n1. The function `findLeftHeight` takes a TreeNode pointer `root` as input and returns the height of the left subtree rooted at `root`. It initializes a variable `count` to 0.\\n\\n2. While `root` is not null:\\n   a. Update `root` to its left child (`root = root->left`).\\n   b. Increment `count` by 1.\\n\\n3. Return the final value of `count`, which represents the height of the left subtree.\\n\\n4. The function `findRightHeight` is similar to `findLeftHeight` but calculates the height of the right subtree.\\n\\n5. The function `countNodes` takes a TreeNode pointer `root` as input and returns the total number of nodes in the tree rooted at `root`.\\n\\n6. If `root` is null, i.e., the tree is empty, return 0.\\n\\n7. Calculate the left height of the tree using `findLeftHeight(root)` and store it in variable `l`.\\n\\n8. Calculate the right height of the tree using `findRightHeight(root)` and store it in variable `r`.\\n\\n9. If the left and right heights are equal (`l == r`), it means the tree is a perfect binary tree. In this case, return `pow(2, l) - 1`, which gives the total number of nodes in a perfect binary tree of height `l`.\\n\\n10. If the left and right heights are not equal, the tree is not a perfect binary tree. In this case, return `1 + countNodes(root->left) + countNodes(root->right)`. This recursively calculates the total number of nodes in the left and right subtrees and adds 1 for the current root node.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(logn)^2\\n\\n- Space complexity:\\nS.C=O(logn)\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/count-complete-tree-nodes/solutions/3704687/c-striver-solution-less-than-o-n-complexity-optimal/"
                    },
                    {
                        "username": "user0223qc",
                        "content": "The runtime complexity of your approach is O(n). In your approach your 10th point states that if left height not equals your right height, then you need to calculate the count of left subtree and right subtree which is equal to counting all the nodes in the tree. The time complexity here is you visit all the nodes in the tree and it take time n. Hence your approach is O(n). Isn\\'t it?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Don\\'t tell me if anyone used an ArrayList in this question also.\\uD83E\\uDD23"
                    },
                    {
                        "username": "GregorySDTaylor",
                        "content": "* Originally, I assumed that the previous row depth would need to be calculated iteratively. Now I see that that there is a formula for the nodes in a full tree: (2 ^ depth) -1\\n* I also assumed that the binary search would need to find two adjacent nodes, one existing and one empty. Turns out the binary search process does this for you."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Complete binary tree: all levels are complete, last level can be incomplete.\\nSo, if leftHeight and rightHeight of a tree are equal, last level is also complete, and total nodes will be 2^height - 1.\\nother wise total nodes will be 1+ count nodes recursively for left and right subtree."
                    },
                    {
                        "username": "dash_dash",
                        "content": "[@phooda804](/phooda804)  leftHeight and rightHeight will take logn each\nand our countNodes will not be called for all nodes mostly it will be called for logn nodes \n\nso i think complexity should be logn* (logn+logn) = logn*logn\n\nplease correct me if i am wrong :P"
                    },
                    {
                        "username": "phooda804",
                        "content": "Isn\\'t this O(N) for recursion?"
                    },
                    {
                        "username": "kessomo",
                        "content": "How are the test case values [1,2,3,4] becomes complete binary tree?!"
                    },
                    {
                        "username": "CHORK",
                        "content": "I would love to solve this kind of problem in OCaml. "
                    },
                    {
                        "username": "Fanindra",
                        "content": "We can do it in O(n) time complexity. Though the question asked us to do it in less then O(n).\\n\\nBy traversing though the tree and incrementing the count.\\n\\nS1 : Create a void function that takes a root and address of an int variable\\n\\nI am doing preorder traversal but you can do any of the DFS\\n\\nS2 increment the count and go to left and right of the tree using recursion\\n\\nS3 in the countNodes function create a int count or any variable\\n\\nS4 call the function created in the S1\\n\\nS5 return ans.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "I am still not sure about the time complexity O(log(n)^2)?, how do we get this,\\nsince according to me in good case T.C should be O(logN) and in worst it may be O(N), please help"
                    }
                ]
            },
            {
                "id": 1897226,
                "content": [
                    {
                        "username": "LesterX",
                        "content": "How is this a easy?"
                    },
                    {
                        "username": "kve315",
                        "content": "I hate it when they don\\'t get the difficulty level for a question right. How is this a medium?"
                    },
                    {
                        "username": "sk3404",
                        "content": "it\\'s \"Easy\" now"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ , striver solution. less than O(n) complexity. Optimal\\n\\n# Approach\\n\\n1. The function `findLeftHeight` takes a TreeNode pointer `root` as input and returns the height of the left subtree rooted at `root`. It initializes a variable `count` to 0.\\n\\n2. While `root` is not null:\\n   a. Update `root` to its left child (`root = root->left`).\\n   b. Increment `count` by 1.\\n\\n3. Return the final value of `count`, which represents the height of the left subtree.\\n\\n4. The function `findRightHeight` is similar to `findLeftHeight` but calculates the height of the right subtree.\\n\\n5. The function `countNodes` takes a TreeNode pointer `root` as input and returns the total number of nodes in the tree rooted at `root`.\\n\\n6. If `root` is null, i.e., the tree is empty, return 0.\\n\\n7. Calculate the left height of the tree using `findLeftHeight(root)` and store it in variable `l`.\\n\\n8. Calculate the right height of the tree using `findRightHeight(root)` and store it in variable `r`.\\n\\n9. If the left and right heights are equal (`l == r`), it means the tree is a perfect binary tree. In this case, return `pow(2, l) - 1`, which gives the total number of nodes in a perfect binary tree of height `l`.\\n\\n10. If the left and right heights are not equal, the tree is not a perfect binary tree. In this case, return `1 + countNodes(root->left) + countNodes(root->right)`. This recursively calculates the total number of nodes in the left and right subtrees and adds 1 for the current root node.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(logn)^2\\n\\n- Space complexity:\\nS.C=O(logn)\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/count-complete-tree-nodes/solutions/3704687/c-striver-solution-less-than-o-n-complexity-optimal/"
                    },
                    {
                        "username": "user0223qc",
                        "content": "The runtime complexity of your approach is O(n). In your approach your 10th point states that if left height not equals your right height, then you need to calculate the count of left subtree and right subtree which is equal to counting all the nodes in the tree. The time complexity here is you visit all the nodes in the tree and it take time n. Hence your approach is O(n). Isn\\'t it?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Don\\'t tell me if anyone used an ArrayList in this question also.\\uD83E\\uDD23"
                    },
                    {
                        "username": "GregorySDTaylor",
                        "content": "* Originally, I assumed that the previous row depth would need to be calculated iteratively. Now I see that that there is a formula for the nodes in a full tree: (2 ^ depth) -1\\n* I also assumed that the binary search would need to find two adjacent nodes, one existing and one empty. Turns out the binary search process does this for you."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Complete binary tree: all levels are complete, last level can be incomplete.\\nSo, if leftHeight and rightHeight of a tree are equal, last level is also complete, and total nodes will be 2^height - 1.\\nother wise total nodes will be 1+ count nodes recursively for left and right subtree."
                    },
                    {
                        "username": "dash_dash",
                        "content": "[@phooda804](/phooda804)  leftHeight and rightHeight will take logn each\nand our countNodes will not be called for all nodes mostly it will be called for logn nodes \n\nso i think complexity should be logn* (logn+logn) = logn*logn\n\nplease correct me if i am wrong :P"
                    },
                    {
                        "username": "phooda804",
                        "content": "Isn\\'t this O(N) for recursion?"
                    },
                    {
                        "username": "kessomo",
                        "content": "How are the test case values [1,2,3,4] becomes complete binary tree?!"
                    },
                    {
                        "username": "CHORK",
                        "content": "I would love to solve this kind of problem in OCaml. "
                    },
                    {
                        "username": "Fanindra",
                        "content": "We can do it in O(n) time complexity. Though the question asked us to do it in less then O(n).\\n\\nBy traversing though the tree and incrementing the count.\\n\\nS1 : Create a void function that takes a root and address of an int variable\\n\\nI am doing preorder traversal but you can do any of the DFS\\n\\nS2 increment the count and go to left and right of the tree using recursion\\n\\nS3 in the countNodes function create a int count or any variable\\n\\nS4 call the function created in the S1\\n\\nS5 return ans.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "I am still not sure about the time complexity O(log(n)^2)?, how do we get this,\\nsince according to me in good case T.C should be O(logN) and in worst it may be O(N), please help"
                    }
                ]
            },
            {
                "id": 1575949,
                "content": [
                    {
                        "username": "LesterX",
                        "content": "How is this a easy?"
                    },
                    {
                        "username": "kve315",
                        "content": "I hate it when they don\\'t get the difficulty level for a question right. How is this a medium?"
                    },
                    {
                        "username": "sk3404",
                        "content": "it\\'s \"Easy\" now"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ , striver solution. less than O(n) complexity. Optimal\\n\\n# Approach\\n\\n1. The function `findLeftHeight` takes a TreeNode pointer `root` as input and returns the height of the left subtree rooted at `root`. It initializes a variable `count` to 0.\\n\\n2. While `root` is not null:\\n   a. Update `root` to its left child (`root = root->left`).\\n   b. Increment `count` by 1.\\n\\n3. Return the final value of `count`, which represents the height of the left subtree.\\n\\n4. The function `findRightHeight` is similar to `findLeftHeight` but calculates the height of the right subtree.\\n\\n5. The function `countNodes` takes a TreeNode pointer `root` as input and returns the total number of nodes in the tree rooted at `root`.\\n\\n6. If `root` is null, i.e., the tree is empty, return 0.\\n\\n7. Calculate the left height of the tree using `findLeftHeight(root)` and store it in variable `l`.\\n\\n8. Calculate the right height of the tree using `findRightHeight(root)` and store it in variable `r`.\\n\\n9. If the left and right heights are equal (`l == r`), it means the tree is a perfect binary tree. In this case, return `pow(2, l) - 1`, which gives the total number of nodes in a perfect binary tree of height `l`.\\n\\n10. If the left and right heights are not equal, the tree is not a perfect binary tree. In this case, return `1 + countNodes(root->left) + countNodes(root->right)`. This recursively calculates the total number of nodes in the left and right subtrees and adds 1 for the current root node.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(logn)^2\\n\\n- Space complexity:\\nS.C=O(logn)\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/count-complete-tree-nodes/solutions/3704687/c-striver-solution-less-than-o-n-complexity-optimal/"
                    },
                    {
                        "username": "user0223qc",
                        "content": "The runtime complexity of your approach is O(n). In your approach your 10th point states that if left height not equals your right height, then you need to calculate the count of left subtree and right subtree which is equal to counting all the nodes in the tree. The time complexity here is you visit all the nodes in the tree and it take time n. Hence your approach is O(n). Isn\\'t it?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Don\\'t tell me if anyone used an ArrayList in this question also.\\uD83E\\uDD23"
                    },
                    {
                        "username": "GregorySDTaylor",
                        "content": "* Originally, I assumed that the previous row depth would need to be calculated iteratively. Now I see that that there is a formula for the nodes in a full tree: (2 ^ depth) -1\\n* I also assumed that the binary search would need to find two adjacent nodes, one existing and one empty. Turns out the binary search process does this for you."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Complete binary tree: all levels are complete, last level can be incomplete.\\nSo, if leftHeight and rightHeight of a tree are equal, last level is also complete, and total nodes will be 2^height - 1.\\nother wise total nodes will be 1+ count nodes recursively for left and right subtree."
                    },
                    {
                        "username": "dash_dash",
                        "content": "[@phooda804](/phooda804)  leftHeight and rightHeight will take logn each\nand our countNodes will not be called for all nodes mostly it will be called for logn nodes \n\nso i think complexity should be logn* (logn+logn) = logn*logn\n\nplease correct me if i am wrong :P"
                    },
                    {
                        "username": "phooda804",
                        "content": "Isn\\'t this O(N) for recursion?"
                    },
                    {
                        "username": "kessomo",
                        "content": "How are the test case values [1,2,3,4] becomes complete binary tree?!"
                    },
                    {
                        "username": "CHORK",
                        "content": "I would love to solve this kind of problem in OCaml. "
                    },
                    {
                        "username": "Fanindra",
                        "content": "We can do it in O(n) time complexity. Though the question asked us to do it in less then O(n).\\n\\nBy traversing though the tree and incrementing the count.\\n\\nS1 : Create a void function that takes a root and address of an int variable\\n\\nI am doing preorder traversal but you can do any of the DFS\\n\\nS2 increment the count and go to left and right of the tree using recursion\\n\\nS3 in the countNodes function create a int count or any variable\\n\\nS4 call the function created in the S1\\n\\nS5 return ans.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "I am still not sure about the time complexity O(log(n)^2)?, how do we get this,\\nsince according to me in good case T.C should be O(logN) and in worst it may be O(N), please help"
                    }
                ]
            },
            {
                "id": 1684900,
                "content": [
                    {
                        "username": "LesterX",
                        "content": "How is this a easy?"
                    },
                    {
                        "username": "kve315",
                        "content": "I hate it when they don\\'t get the difficulty level for a question right. How is this a medium?"
                    },
                    {
                        "username": "sk3404",
                        "content": "it\\'s \"Easy\" now"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ , striver solution. less than O(n) complexity. Optimal\\n\\n# Approach\\n\\n1. The function `findLeftHeight` takes a TreeNode pointer `root` as input and returns the height of the left subtree rooted at `root`. It initializes a variable `count` to 0.\\n\\n2. While `root` is not null:\\n   a. Update `root` to its left child (`root = root->left`).\\n   b. Increment `count` by 1.\\n\\n3. Return the final value of `count`, which represents the height of the left subtree.\\n\\n4. The function `findRightHeight` is similar to `findLeftHeight` but calculates the height of the right subtree.\\n\\n5. The function `countNodes` takes a TreeNode pointer `root` as input and returns the total number of nodes in the tree rooted at `root`.\\n\\n6. If `root` is null, i.e., the tree is empty, return 0.\\n\\n7. Calculate the left height of the tree using `findLeftHeight(root)` and store it in variable `l`.\\n\\n8. Calculate the right height of the tree using `findRightHeight(root)` and store it in variable `r`.\\n\\n9. If the left and right heights are equal (`l == r`), it means the tree is a perfect binary tree. In this case, return `pow(2, l) - 1`, which gives the total number of nodes in a perfect binary tree of height `l`.\\n\\n10. If the left and right heights are not equal, the tree is not a perfect binary tree. In this case, return `1 + countNodes(root->left) + countNodes(root->right)`. This recursively calculates the total number of nodes in the left and right subtrees and adds 1 for the current root node.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(logn)^2\\n\\n- Space complexity:\\nS.C=O(logn)\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/count-complete-tree-nodes/solutions/3704687/c-striver-solution-less-than-o-n-complexity-optimal/"
                    },
                    {
                        "username": "user0223qc",
                        "content": "The runtime complexity of your approach is O(n). In your approach your 10th point states that if left height not equals your right height, then you need to calculate the count of left subtree and right subtree which is equal to counting all the nodes in the tree. The time complexity here is you visit all the nodes in the tree and it take time n. Hence your approach is O(n). Isn\\'t it?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Don\\'t tell me if anyone used an ArrayList in this question also.\\uD83E\\uDD23"
                    },
                    {
                        "username": "GregorySDTaylor",
                        "content": "* Originally, I assumed that the previous row depth would need to be calculated iteratively. Now I see that that there is a formula for the nodes in a full tree: (2 ^ depth) -1\\n* I also assumed that the binary search would need to find two adjacent nodes, one existing and one empty. Turns out the binary search process does this for you."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Complete binary tree: all levels are complete, last level can be incomplete.\\nSo, if leftHeight and rightHeight of a tree are equal, last level is also complete, and total nodes will be 2^height - 1.\\nother wise total nodes will be 1+ count nodes recursively for left and right subtree."
                    },
                    {
                        "username": "dash_dash",
                        "content": "[@phooda804](/phooda804)  leftHeight and rightHeight will take logn each\nand our countNodes will not be called for all nodes mostly it will be called for logn nodes \n\nso i think complexity should be logn* (logn+logn) = logn*logn\n\nplease correct me if i am wrong :P"
                    },
                    {
                        "username": "phooda804",
                        "content": "Isn\\'t this O(N) for recursion?"
                    },
                    {
                        "username": "kessomo",
                        "content": "How are the test case values [1,2,3,4] becomes complete binary tree?!"
                    },
                    {
                        "username": "CHORK",
                        "content": "I would love to solve this kind of problem in OCaml. "
                    },
                    {
                        "username": "Fanindra",
                        "content": "We can do it in O(n) time complexity. Though the question asked us to do it in less then O(n).\\n\\nBy traversing though the tree and incrementing the count.\\n\\nS1 : Create a void function that takes a root and address of an int variable\\n\\nI am doing preorder traversal but you can do any of the DFS\\n\\nS2 increment the count and go to left and right of the tree using recursion\\n\\nS3 in the countNodes function create a int count or any variable\\n\\nS4 call the function created in the S1\\n\\nS5 return ans.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "I am still not sure about the time complexity O(log(n)^2)?, how do we get this,\\nsince according to me in good case T.C should be O(logN) and in worst it may be O(N), please help"
                    }
                ]
            },
            {
                "id": 2075595,
                "content": [
                    {
                        "username": "LesterX",
                        "content": "How is this a easy?"
                    },
                    {
                        "username": "kve315",
                        "content": "I hate it when they don\\'t get the difficulty level for a question right. How is this a medium?"
                    },
                    {
                        "username": "sk3404",
                        "content": "it\\'s \"Easy\" now"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ , striver solution. less than O(n) complexity. Optimal\\n\\n# Approach\\n\\n1. The function `findLeftHeight` takes a TreeNode pointer `root` as input and returns the height of the left subtree rooted at `root`. It initializes a variable `count` to 0.\\n\\n2. While `root` is not null:\\n   a. Update `root` to its left child (`root = root->left`).\\n   b. Increment `count` by 1.\\n\\n3. Return the final value of `count`, which represents the height of the left subtree.\\n\\n4. The function `findRightHeight` is similar to `findLeftHeight` but calculates the height of the right subtree.\\n\\n5. The function `countNodes` takes a TreeNode pointer `root` as input and returns the total number of nodes in the tree rooted at `root`.\\n\\n6. If `root` is null, i.e., the tree is empty, return 0.\\n\\n7. Calculate the left height of the tree using `findLeftHeight(root)` and store it in variable `l`.\\n\\n8. Calculate the right height of the tree using `findRightHeight(root)` and store it in variable `r`.\\n\\n9. If the left and right heights are equal (`l == r`), it means the tree is a perfect binary tree. In this case, return `pow(2, l) - 1`, which gives the total number of nodes in a perfect binary tree of height `l`.\\n\\n10. If the left and right heights are not equal, the tree is not a perfect binary tree. In this case, return `1 + countNodes(root->left) + countNodes(root->right)`. This recursively calculates the total number of nodes in the left and right subtrees and adds 1 for the current root node.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(logn)^2\\n\\n- Space complexity:\\nS.C=O(logn)\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/count-complete-tree-nodes/solutions/3704687/c-striver-solution-less-than-o-n-complexity-optimal/"
                    },
                    {
                        "username": "user0223qc",
                        "content": "The runtime complexity of your approach is O(n). In your approach your 10th point states that if left height not equals your right height, then you need to calculate the count of left subtree and right subtree which is equal to counting all the nodes in the tree. The time complexity here is you visit all the nodes in the tree and it take time n. Hence your approach is O(n). Isn\\'t it?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Don\\'t tell me if anyone used an ArrayList in this question also.\\uD83E\\uDD23"
                    },
                    {
                        "username": "GregorySDTaylor",
                        "content": "* Originally, I assumed that the previous row depth would need to be calculated iteratively. Now I see that that there is a formula for the nodes in a full tree: (2 ^ depth) -1\\n* I also assumed that the binary search would need to find two adjacent nodes, one existing and one empty. Turns out the binary search process does this for you."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Complete binary tree: all levels are complete, last level can be incomplete.\\nSo, if leftHeight and rightHeight of a tree are equal, last level is also complete, and total nodes will be 2^height - 1.\\nother wise total nodes will be 1+ count nodes recursively for left and right subtree."
                    },
                    {
                        "username": "dash_dash",
                        "content": "[@phooda804](/phooda804)  leftHeight and rightHeight will take logn each\nand our countNodes will not be called for all nodes mostly it will be called for logn nodes \n\nso i think complexity should be logn* (logn+logn) = logn*logn\n\nplease correct me if i am wrong :P"
                    },
                    {
                        "username": "phooda804",
                        "content": "Isn\\'t this O(N) for recursion?"
                    },
                    {
                        "username": "kessomo",
                        "content": "How are the test case values [1,2,3,4] becomes complete binary tree?!"
                    },
                    {
                        "username": "CHORK",
                        "content": "I would love to solve this kind of problem in OCaml. "
                    },
                    {
                        "username": "Fanindra",
                        "content": "We can do it in O(n) time complexity. Though the question asked us to do it in less then O(n).\\n\\nBy traversing though the tree and incrementing the count.\\n\\nS1 : Create a void function that takes a root and address of an int variable\\n\\nI am doing preorder traversal but you can do any of the DFS\\n\\nS2 increment the count and go to left and right of the tree using recursion\\n\\nS3 in the countNodes function create a int count or any variable\\n\\nS4 call the function created in the S1\\n\\nS5 return ans.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "I am still not sure about the time complexity O(log(n)^2)?, how do we get this,\\nsince according to me in good case T.C should be O(logN) and in worst it may be O(N), please help"
                    }
                ]
            },
            {
                "id": 2067529,
                "content": [
                    {
                        "username": "LesterX",
                        "content": "How is this a easy?"
                    },
                    {
                        "username": "kve315",
                        "content": "I hate it when they don\\'t get the difficulty level for a question right. How is this a medium?"
                    },
                    {
                        "username": "sk3404",
                        "content": "it\\'s \"Easy\" now"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ , striver solution. less than O(n) complexity. Optimal\\n\\n# Approach\\n\\n1. The function `findLeftHeight` takes a TreeNode pointer `root` as input and returns the height of the left subtree rooted at `root`. It initializes a variable `count` to 0.\\n\\n2. While `root` is not null:\\n   a. Update `root` to its left child (`root = root->left`).\\n   b. Increment `count` by 1.\\n\\n3. Return the final value of `count`, which represents the height of the left subtree.\\n\\n4. The function `findRightHeight` is similar to `findLeftHeight` but calculates the height of the right subtree.\\n\\n5. The function `countNodes` takes a TreeNode pointer `root` as input and returns the total number of nodes in the tree rooted at `root`.\\n\\n6. If `root` is null, i.e., the tree is empty, return 0.\\n\\n7. Calculate the left height of the tree using `findLeftHeight(root)` and store it in variable `l`.\\n\\n8. Calculate the right height of the tree using `findRightHeight(root)` and store it in variable `r`.\\n\\n9. If the left and right heights are equal (`l == r`), it means the tree is a perfect binary tree. In this case, return `pow(2, l) - 1`, which gives the total number of nodes in a perfect binary tree of height `l`.\\n\\n10. If the left and right heights are not equal, the tree is not a perfect binary tree. In this case, return `1 + countNodes(root->left) + countNodes(root->right)`. This recursively calculates the total number of nodes in the left and right subtrees and adds 1 for the current root node.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(logn)^2\\n\\n- Space complexity:\\nS.C=O(logn)\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/count-complete-tree-nodes/solutions/3704687/c-striver-solution-less-than-o-n-complexity-optimal/"
                    },
                    {
                        "username": "user0223qc",
                        "content": "The runtime complexity of your approach is O(n). In your approach your 10th point states that if left height not equals your right height, then you need to calculate the count of left subtree and right subtree which is equal to counting all the nodes in the tree. The time complexity here is you visit all the nodes in the tree and it take time n. Hence your approach is O(n). Isn\\'t it?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Don\\'t tell me if anyone used an ArrayList in this question also.\\uD83E\\uDD23"
                    },
                    {
                        "username": "GregorySDTaylor",
                        "content": "* Originally, I assumed that the previous row depth would need to be calculated iteratively. Now I see that that there is a formula for the nodes in a full tree: (2 ^ depth) -1\\n* I also assumed that the binary search would need to find two adjacent nodes, one existing and one empty. Turns out the binary search process does this for you."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Complete binary tree: all levels are complete, last level can be incomplete.\\nSo, if leftHeight and rightHeight of a tree are equal, last level is also complete, and total nodes will be 2^height - 1.\\nother wise total nodes will be 1+ count nodes recursively for left and right subtree."
                    },
                    {
                        "username": "dash_dash",
                        "content": "[@phooda804](/phooda804)  leftHeight and rightHeight will take logn each\nand our countNodes will not be called for all nodes mostly it will be called for logn nodes \n\nso i think complexity should be logn* (logn+logn) = logn*logn\n\nplease correct me if i am wrong :P"
                    },
                    {
                        "username": "phooda804",
                        "content": "Isn\\'t this O(N) for recursion?"
                    },
                    {
                        "username": "kessomo",
                        "content": "How are the test case values [1,2,3,4] becomes complete binary tree?!"
                    },
                    {
                        "username": "CHORK",
                        "content": "I would love to solve this kind of problem in OCaml. "
                    },
                    {
                        "username": "Fanindra",
                        "content": "We can do it in O(n) time complexity. Though the question asked us to do it in less then O(n).\\n\\nBy traversing though the tree and incrementing the count.\\n\\nS1 : Create a void function that takes a root and address of an int variable\\n\\nI am doing preorder traversal but you can do any of the DFS\\n\\nS2 increment the count and go to left and right of the tree using recursion\\n\\nS3 in the countNodes function create a int count or any variable\\n\\nS4 call the function created in the S1\\n\\nS5 return ans.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "I am still not sure about the time complexity O(log(n)^2)?, how do we get this,\\nsince according to me in good case T.C should be O(logN) and in worst it may be O(N), please help"
                    }
                ]
            },
            {
                "id": 2065806,
                "content": [
                    {
                        "username": "LesterX",
                        "content": "How is this a easy?"
                    },
                    {
                        "username": "kve315",
                        "content": "I hate it when they don\\'t get the difficulty level for a question right. How is this a medium?"
                    },
                    {
                        "username": "sk3404",
                        "content": "it\\'s \"Easy\" now"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ , striver solution. less than O(n) complexity. Optimal\\n\\n# Approach\\n\\n1. The function `findLeftHeight` takes a TreeNode pointer `root` as input and returns the height of the left subtree rooted at `root`. It initializes a variable `count` to 0.\\n\\n2. While `root` is not null:\\n   a. Update `root` to its left child (`root = root->left`).\\n   b. Increment `count` by 1.\\n\\n3. Return the final value of `count`, which represents the height of the left subtree.\\n\\n4. The function `findRightHeight` is similar to `findLeftHeight` but calculates the height of the right subtree.\\n\\n5. The function `countNodes` takes a TreeNode pointer `root` as input and returns the total number of nodes in the tree rooted at `root`.\\n\\n6. If `root` is null, i.e., the tree is empty, return 0.\\n\\n7. Calculate the left height of the tree using `findLeftHeight(root)` and store it in variable `l`.\\n\\n8. Calculate the right height of the tree using `findRightHeight(root)` and store it in variable `r`.\\n\\n9. If the left and right heights are equal (`l == r`), it means the tree is a perfect binary tree. In this case, return `pow(2, l) - 1`, which gives the total number of nodes in a perfect binary tree of height `l`.\\n\\n10. If the left and right heights are not equal, the tree is not a perfect binary tree. In this case, return `1 + countNodes(root->left) + countNodes(root->right)`. This recursively calculates the total number of nodes in the left and right subtrees and adds 1 for the current root node.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(logn)^2\\n\\n- Space complexity:\\nS.C=O(logn)\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/count-complete-tree-nodes/solutions/3704687/c-striver-solution-less-than-o-n-complexity-optimal/"
                    },
                    {
                        "username": "user0223qc",
                        "content": "The runtime complexity of your approach is O(n). In your approach your 10th point states that if left height not equals your right height, then you need to calculate the count of left subtree and right subtree which is equal to counting all the nodes in the tree. The time complexity here is you visit all the nodes in the tree and it take time n. Hence your approach is O(n). Isn\\'t it?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Don\\'t tell me if anyone used an ArrayList in this question also.\\uD83E\\uDD23"
                    },
                    {
                        "username": "GregorySDTaylor",
                        "content": "* Originally, I assumed that the previous row depth would need to be calculated iteratively. Now I see that that there is a formula for the nodes in a full tree: (2 ^ depth) -1\\n* I also assumed that the binary search would need to find two adjacent nodes, one existing and one empty. Turns out the binary search process does this for you."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Complete binary tree: all levels are complete, last level can be incomplete.\\nSo, if leftHeight and rightHeight of a tree are equal, last level is also complete, and total nodes will be 2^height - 1.\\nother wise total nodes will be 1+ count nodes recursively for left and right subtree."
                    },
                    {
                        "username": "dash_dash",
                        "content": "[@phooda804](/phooda804)  leftHeight and rightHeight will take logn each\nand our countNodes will not be called for all nodes mostly it will be called for logn nodes \n\nso i think complexity should be logn* (logn+logn) = logn*logn\n\nplease correct me if i am wrong :P"
                    },
                    {
                        "username": "phooda804",
                        "content": "Isn\\'t this O(N) for recursion?"
                    },
                    {
                        "username": "kessomo",
                        "content": "How are the test case values [1,2,3,4] becomes complete binary tree?!"
                    },
                    {
                        "username": "CHORK",
                        "content": "I would love to solve this kind of problem in OCaml. "
                    },
                    {
                        "username": "Fanindra",
                        "content": "We can do it in O(n) time complexity. Though the question asked us to do it in less then O(n).\\n\\nBy traversing though the tree and incrementing the count.\\n\\nS1 : Create a void function that takes a root and address of an int variable\\n\\nI am doing preorder traversal but you can do any of the DFS\\n\\nS2 increment the count and go to left and right of the tree using recursion\\n\\nS3 in the countNodes function create a int count or any variable\\n\\nS4 call the function created in the S1\\n\\nS5 return ans.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "I am still not sure about the time complexity O(log(n)^2)?, how do we get this,\\nsince according to me in good case T.C should be O(logN) and in worst it may be O(N), please help"
                    }
                ]
            },
            {
                "id": 1993623,
                "content": [
                    {
                        "username": "LesterX",
                        "content": "How is this a easy?"
                    },
                    {
                        "username": "kve315",
                        "content": "I hate it when they don\\'t get the difficulty level for a question right. How is this a medium?"
                    },
                    {
                        "username": "sk3404",
                        "content": "it\\'s \"Easy\" now"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ , striver solution. less than O(n) complexity. Optimal\\n\\n# Approach\\n\\n1. The function `findLeftHeight` takes a TreeNode pointer `root` as input and returns the height of the left subtree rooted at `root`. It initializes a variable `count` to 0.\\n\\n2. While `root` is not null:\\n   a. Update `root` to its left child (`root = root->left`).\\n   b. Increment `count` by 1.\\n\\n3. Return the final value of `count`, which represents the height of the left subtree.\\n\\n4. The function `findRightHeight` is similar to `findLeftHeight` but calculates the height of the right subtree.\\n\\n5. The function `countNodes` takes a TreeNode pointer `root` as input and returns the total number of nodes in the tree rooted at `root`.\\n\\n6. If `root` is null, i.e., the tree is empty, return 0.\\n\\n7. Calculate the left height of the tree using `findLeftHeight(root)` and store it in variable `l`.\\n\\n8. Calculate the right height of the tree using `findRightHeight(root)` and store it in variable `r`.\\n\\n9. If the left and right heights are equal (`l == r`), it means the tree is a perfect binary tree. In this case, return `pow(2, l) - 1`, which gives the total number of nodes in a perfect binary tree of height `l`.\\n\\n10. If the left and right heights are not equal, the tree is not a perfect binary tree. In this case, return `1 + countNodes(root->left) + countNodes(root->right)`. This recursively calculates the total number of nodes in the left and right subtrees and adds 1 for the current root node.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(logn)^2\\n\\n- Space complexity:\\nS.C=O(logn)\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/count-complete-tree-nodes/solutions/3704687/c-striver-solution-less-than-o-n-complexity-optimal/"
                    },
                    {
                        "username": "user0223qc",
                        "content": "The runtime complexity of your approach is O(n). In your approach your 10th point states that if left height not equals your right height, then you need to calculate the count of left subtree and right subtree which is equal to counting all the nodes in the tree. The time complexity here is you visit all the nodes in the tree and it take time n. Hence your approach is O(n). Isn\\'t it?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Don\\'t tell me if anyone used an ArrayList in this question also.\\uD83E\\uDD23"
                    },
                    {
                        "username": "GregorySDTaylor",
                        "content": "* Originally, I assumed that the previous row depth would need to be calculated iteratively. Now I see that that there is a formula for the nodes in a full tree: (2 ^ depth) -1\\n* I also assumed that the binary search would need to find two adjacent nodes, one existing and one empty. Turns out the binary search process does this for you."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Complete binary tree: all levels are complete, last level can be incomplete.\\nSo, if leftHeight and rightHeight of a tree are equal, last level is also complete, and total nodes will be 2^height - 1.\\nother wise total nodes will be 1+ count nodes recursively for left and right subtree."
                    },
                    {
                        "username": "dash_dash",
                        "content": "[@phooda804](/phooda804)  leftHeight and rightHeight will take logn each\nand our countNodes will not be called for all nodes mostly it will be called for logn nodes \n\nso i think complexity should be logn* (logn+logn) = logn*logn\n\nplease correct me if i am wrong :P"
                    },
                    {
                        "username": "phooda804",
                        "content": "Isn\\'t this O(N) for recursion?"
                    },
                    {
                        "username": "kessomo",
                        "content": "How are the test case values [1,2,3,4] becomes complete binary tree?!"
                    },
                    {
                        "username": "CHORK",
                        "content": "I would love to solve this kind of problem in OCaml. "
                    },
                    {
                        "username": "Fanindra",
                        "content": "We can do it in O(n) time complexity. Though the question asked us to do it in less then O(n).\\n\\nBy traversing though the tree and incrementing the count.\\n\\nS1 : Create a void function that takes a root and address of an int variable\\n\\nI am doing preorder traversal but you can do any of the DFS\\n\\nS2 increment the count and go to left and right of the tree using recursion\\n\\nS3 in the countNodes function create a int count or any variable\\n\\nS4 call the function created in the S1\\n\\nS5 return ans.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "I am still not sure about the time complexity O(log(n)^2)?, how do we get this,\\nsince according to me in good case T.C should be O(logN) and in worst it may be O(N), please help"
                    }
                ]
            },
            {
                "id": 1988572,
                "content": [
                    {
                        "username": "avneets2103",
                        "content": "This was easily done and solution was beating like 95% people but I wanna know what was the use of a complete binary tree here\\n\\nbfs and dfs sol are gonn a work anyways"
                    },
                    {
                        "username": "Omerdw",
                        "content": "bfs and dfs work, but they are O(n) and not better than O(n) as the question requires"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Cant we just use any traversals like INORDER,PREORDER or POSTORDER?\nIs it not allowed?\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "I don\\'t write such things often, usually opposite, but it is 100% easy problem. Just tree traversal "
                    },
                    {
                        "username": "Omerdw",
                        "content": "tree traversal is O(n) because you traverse all the nodes, the question requires a better than O(n) solution"
                    },
                    {
                        "username": "countdankula",
                        "content": "In Python, for some reason, the Preorder traversal is running faster than the Log^2(N)  approach. \\uD83D\\uDE03"
                    },
                    {
                        "username": "letrung",
                        "content": "This should be in the easy category \\uD83D\\uDE02. This one is good for new learners of tree traversal algorithms. \\uD83D\\uDE06"
                    },
                    {
                        "username": "SeineAle",
                        "content": "My solution even in worst case wont traverse the complete tree only half of  it and general complexity is O(h^2) than why better than only 80 %"
                    },
                    {
                        "username": "SeineAle",
                        "content": "isnt counting nodes always supposed to be O(n) ?"
                    },
                    {
                        "username": "afeefuddin",
                        "content": "Should be marked as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "2024ec1085",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "deep01",
                        "content": "java code :\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) +1;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jstark6",
                        "content": "Read read read"
                    }
                ]
            },
            {
                "id": 1970107,
                "content": [
                    {
                        "username": "avneets2103",
                        "content": "This was easily done and solution was beating like 95% people but I wanna know what was the use of a complete binary tree here\\n\\nbfs and dfs sol are gonn a work anyways"
                    },
                    {
                        "username": "Omerdw",
                        "content": "bfs and dfs work, but they are O(n) and not better than O(n) as the question requires"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Cant we just use any traversals like INORDER,PREORDER or POSTORDER?\nIs it not allowed?\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "I don\\'t write such things often, usually opposite, but it is 100% easy problem. Just tree traversal "
                    },
                    {
                        "username": "Omerdw",
                        "content": "tree traversal is O(n) because you traverse all the nodes, the question requires a better than O(n) solution"
                    },
                    {
                        "username": "countdankula",
                        "content": "In Python, for some reason, the Preorder traversal is running faster than the Log^2(N)  approach. \\uD83D\\uDE03"
                    },
                    {
                        "username": "letrung",
                        "content": "This should be in the easy category \\uD83D\\uDE02. This one is good for new learners of tree traversal algorithms. \\uD83D\\uDE06"
                    },
                    {
                        "username": "SeineAle",
                        "content": "My solution even in worst case wont traverse the complete tree only half of  it and general complexity is O(h^2) than why better than only 80 %"
                    },
                    {
                        "username": "SeineAle",
                        "content": "isnt counting nodes always supposed to be O(n) ?"
                    },
                    {
                        "username": "afeefuddin",
                        "content": "Should be marked as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "2024ec1085",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "deep01",
                        "content": "java code :\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) +1;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jstark6",
                        "content": "Read read read"
                    }
                ]
            },
            {
                "id": 1964925,
                "content": [
                    {
                        "username": "avneets2103",
                        "content": "This was easily done and solution was beating like 95% people but I wanna know what was the use of a complete binary tree here\\n\\nbfs and dfs sol are gonn a work anyways"
                    },
                    {
                        "username": "Omerdw",
                        "content": "bfs and dfs work, but they are O(n) and not better than O(n) as the question requires"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Cant we just use any traversals like INORDER,PREORDER or POSTORDER?\nIs it not allowed?\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "I don\\'t write such things often, usually opposite, but it is 100% easy problem. Just tree traversal "
                    },
                    {
                        "username": "Omerdw",
                        "content": "tree traversal is O(n) because you traverse all the nodes, the question requires a better than O(n) solution"
                    },
                    {
                        "username": "countdankula",
                        "content": "In Python, for some reason, the Preorder traversal is running faster than the Log^2(N)  approach. \\uD83D\\uDE03"
                    },
                    {
                        "username": "letrung",
                        "content": "This should be in the easy category \\uD83D\\uDE02. This one is good for new learners of tree traversal algorithms. \\uD83D\\uDE06"
                    },
                    {
                        "username": "SeineAle",
                        "content": "My solution even in worst case wont traverse the complete tree only half of  it and general complexity is O(h^2) than why better than only 80 %"
                    },
                    {
                        "username": "SeineAle",
                        "content": "isnt counting nodes always supposed to be O(n) ?"
                    },
                    {
                        "username": "afeefuddin",
                        "content": "Should be marked as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "2024ec1085",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "deep01",
                        "content": "java code :\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) +1;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jstark6",
                        "content": "Read read read"
                    }
                ]
            },
            {
                "id": 1950390,
                "content": [
                    {
                        "username": "avneets2103",
                        "content": "This was easily done and solution was beating like 95% people but I wanna know what was the use of a complete binary tree here\\n\\nbfs and dfs sol are gonn a work anyways"
                    },
                    {
                        "username": "Omerdw",
                        "content": "bfs and dfs work, but they are O(n) and not better than O(n) as the question requires"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Cant we just use any traversals like INORDER,PREORDER or POSTORDER?\nIs it not allowed?\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "I don\\'t write such things often, usually opposite, but it is 100% easy problem. Just tree traversal "
                    },
                    {
                        "username": "Omerdw",
                        "content": "tree traversal is O(n) because you traverse all the nodes, the question requires a better than O(n) solution"
                    },
                    {
                        "username": "countdankula",
                        "content": "In Python, for some reason, the Preorder traversal is running faster than the Log^2(N)  approach. \\uD83D\\uDE03"
                    },
                    {
                        "username": "letrung",
                        "content": "This should be in the easy category \\uD83D\\uDE02. This one is good for new learners of tree traversal algorithms. \\uD83D\\uDE06"
                    },
                    {
                        "username": "SeineAle",
                        "content": "My solution even in worst case wont traverse the complete tree only half of  it and general complexity is O(h^2) than why better than only 80 %"
                    },
                    {
                        "username": "SeineAle",
                        "content": "isnt counting nodes always supposed to be O(n) ?"
                    },
                    {
                        "username": "afeefuddin",
                        "content": "Should be marked as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "2024ec1085",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "deep01",
                        "content": "java code :\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) +1;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jstark6",
                        "content": "Read read read"
                    }
                ]
            },
            {
                "id": 1945148,
                "content": [
                    {
                        "username": "avneets2103",
                        "content": "This was easily done and solution was beating like 95% people but I wanna know what was the use of a complete binary tree here\\n\\nbfs and dfs sol are gonn a work anyways"
                    },
                    {
                        "username": "Omerdw",
                        "content": "bfs and dfs work, but they are O(n) and not better than O(n) as the question requires"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Cant we just use any traversals like INORDER,PREORDER or POSTORDER?\nIs it not allowed?\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "I don\\'t write such things often, usually opposite, but it is 100% easy problem. Just tree traversal "
                    },
                    {
                        "username": "Omerdw",
                        "content": "tree traversal is O(n) because you traverse all the nodes, the question requires a better than O(n) solution"
                    },
                    {
                        "username": "countdankula",
                        "content": "In Python, for some reason, the Preorder traversal is running faster than the Log^2(N)  approach. \\uD83D\\uDE03"
                    },
                    {
                        "username": "letrung",
                        "content": "This should be in the easy category \\uD83D\\uDE02. This one is good for new learners of tree traversal algorithms. \\uD83D\\uDE06"
                    },
                    {
                        "username": "SeineAle",
                        "content": "My solution even in worst case wont traverse the complete tree only half of  it and general complexity is O(h^2) than why better than only 80 %"
                    },
                    {
                        "username": "SeineAle",
                        "content": "isnt counting nodes always supposed to be O(n) ?"
                    },
                    {
                        "username": "afeefuddin",
                        "content": "Should be marked as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "2024ec1085",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "deep01",
                        "content": "java code :\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) +1;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jstark6",
                        "content": "Read read read"
                    }
                ]
            },
            {
                "id": 1922936,
                "content": [
                    {
                        "username": "avneets2103",
                        "content": "This was easily done and solution was beating like 95% people but I wanna know what was the use of a complete binary tree here\\n\\nbfs and dfs sol are gonn a work anyways"
                    },
                    {
                        "username": "Omerdw",
                        "content": "bfs and dfs work, but they are O(n) and not better than O(n) as the question requires"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Cant we just use any traversals like INORDER,PREORDER or POSTORDER?\nIs it not allowed?\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "I don\\'t write such things often, usually opposite, but it is 100% easy problem. Just tree traversal "
                    },
                    {
                        "username": "Omerdw",
                        "content": "tree traversal is O(n) because you traverse all the nodes, the question requires a better than O(n) solution"
                    },
                    {
                        "username": "countdankula",
                        "content": "In Python, for some reason, the Preorder traversal is running faster than the Log^2(N)  approach. \\uD83D\\uDE03"
                    },
                    {
                        "username": "letrung",
                        "content": "This should be in the easy category \\uD83D\\uDE02. This one is good for new learners of tree traversal algorithms. \\uD83D\\uDE06"
                    },
                    {
                        "username": "SeineAle",
                        "content": "My solution even in worst case wont traverse the complete tree only half of  it and general complexity is O(h^2) than why better than only 80 %"
                    },
                    {
                        "username": "SeineAle",
                        "content": "isnt counting nodes always supposed to be O(n) ?"
                    },
                    {
                        "username": "afeefuddin",
                        "content": "Should be marked as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "2024ec1085",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "deep01",
                        "content": "java code :\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) +1;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jstark6",
                        "content": "Read read read"
                    }
                ]
            },
            {
                "id": 1922891,
                "content": [
                    {
                        "username": "avneets2103",
                        "content": "This was easily done and solution was beating like 95% people but I wanna know what was the use of a complete binary tree here\\n\\nbfs and dfs sol are gonn a work anyways"
                    },
                    {
                        "username": "Omerdw",
                        "content": "bfs and dfs work, but they are O(n) and not better than O(n) as the question requires"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Cant we just use any traversals like INORDER,PREORDER or POSTORDER?\nIs it not allowed?\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "I don\\'t write such things often, usually opposite, but it is 100% easy problem. Just tree traversal "
                    },
                    {
                        "username": "Omerdw",
                        "content": "tree traversal is O(n) because you traverse all the nodes, the question requires a better than O(n) solution"
                    },
                    {
                        "username": "countdankula",
                        "content": "In Python, for some reason, the Preorder traversal is running faster than the Log^2(N)  approach. \\uD83D\\uDE03"
                    },
                    {
                        "username": "letrung",
                        "content": "This should be in the easy category \\uD83D\\uDE02. This one is good for new learners of tree traversal algorithms. \\uD83D\\uDE06"
                    },
                    {
                        "username": "SeineAle",
                        "content": "My solution even in worst case wont traverse the complete tree only half of  it and general complexity is O(h^2) than why better than only 80 %"
                    },
                    {
                        "username": "SeineAle",
                        "content": "isnt counting nodes always supposed to be O(n) ?"
                    },
                    {
                        "username": "afeefuddin",
                        "content": "Should be marked as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "2024ec1085",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "deep01",
                        "content": "java code :\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) +1;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jstark6",
                        "content": "Read read read"
                    }
                ]
            },
            {
                "id": 1879113,
                "content": [
                    {
                        "username": "avneets2103",
                        "content": "This was easily done and solution was beating like 95% people but I wanna know what was the use of a complete binary tree here\\n\\nbfs and dfs sol are gonn a work anyways"
                    },
                    {
                        "username": "Omerdw",
                        "content": "bfs and dfs work, but they are O(n) and not better than O(n) as the question requires"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Cant we just use any traversals like INORDER,PREORDER or POSTORDER?\nIs it not allowed?\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "I don\\'t write such things often, usually opposite, but it is 100% easy problem. Just tree traversal "
                    },
                    {
                        "username": "Omerdw",
                        "content": "tree traversal is O(n) because you traverse all the nodes, the question requires a better than O(n) solution"
                    },
                    {
                        "username": "countdankula",
                        "content": "In Python, for some reason, the Preorder traversal is running faster than the Log^2(N)  approach. \\uD83D\\uDE03"
                    },
                    {
                        "username": "letrung",
                        "content": "This should be in the easy category \\uD83D\\uDE02. This one is good for new learners of tree traversal algorithms. \\uD83D\\uDE06"
                    },
                    {
                        "username": "SeineAle",
                        "content": "My solution even in worst case wont traverse the complete tree only half of  it and general complexity is O(h^2) than why better than only 80 %"
                    },
                    {
                        "username": "SeineAle",
                        "content": "isnt counting nodes always supposed to be O(n) ?"
                    },
                    {
                        "username": "afeefuddin",
                        "content": "Should be marked as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "2024ec1085",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "deep01",
                        "content": "java code :\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) +1;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jstark6",
                        "content": "Read read read"
                    }
                ]
            },
            {
                "id": 1866711,
                "content": [
                    {
                        "username": "avneets2103",
                        "content": "This was easily done and solution was beating like 95% people but I wanna know what was the use of a complete binary tree here\\n\\nbfs and dfs sol are gonn a work anyways"
                    },
                    {
                        "username": "Omerdw",
                        "content": "bfs and dfs work, but they are O(n) and not better than O(n) as the question requires"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Cant we just use any traversals like INORDER,PREORDER or POSTORDER?\nIs it not allowed?\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "I don\\'t write such things often, usually opposite, but it is 100% easy problem. Just tree traversal "
                    },
                    {
                        "username": "Omerdw",
                        "content": "tree traversal is O(n) because you traverse all the nodes, the question requires a better than O(n) solution"
                    },
                    {
                        "username": "countdankula",
                        "content": "In Python, for some reason, the Preorder traversal is running faster than the Log^2(N)  approach. \\uD83D\\uDE03"
                    },
                    {
                        "username": "letrung",
                        "content": "This should be in the easy category \\uD83D\\uDE02. This one is good for new learners of tree traversal algorithms. \\uD83D\\uDE06"
                    },
                    {
                        "username": "SeineAle",
                        "content": "My solution even in worst case wont traverse the complete tree only half of  it and general complexity is O(h^2) than why better than only 80 %"
                    },
                    {
                        "username": "SeineAle",
                        "content": "isnt counting nodes always supposed to be O(n) ?"
                    },
                    {
                        "username": "afeefuddin",
                        "content": "Should be marked as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "2024ec1085",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "deep01",
                        "content": "java code :\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) +1;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jstark6",
                        "content": "Read read read"
                    }
                ]
            },
            {
                "id": 1831399,
                "content": [
                    {
                        "username": "avneets2103",
                        "content": "This was easily done and solution was beating like 95% people but I wanna know what was the use of a complete binary tree here\\n\\nbfs and dfs sol are gonn a work anyways"
                    },
                    {
                        "username": "Omerdw",
                        "content": "bfs and dfs work, but they are O(n) and not better than O(n) as the question requires"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Cant we just use any traversals like INORDER,PREORDER or POSTORDER?\nIs it not allowed?\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "I don\\'t write such things often, usually opposite, but it is 100% easy problem. Just tree traversal "
                    },
                    {
                        "username": "Omerdw",
                        "content": "tree traversal is O(n) because you traverse all the nodes, the question requires a better than O(n) solution"
                    },
                    {
                        "username": "countdankula",
                        "content": "In Python, for some reason, the Preorder traversal is running faster than the Log^2(N)  approach. \\uD83D\\uDE03"
                    },
                    {
                        "username": "letrung",
                        "content": "This should be in the easy category \\uD83D\\uDE02. This one is good for new learners of tree traversal algorithms. \\uD83D\\uDE06"
                    },
                    {
                        "username": "SeineAle",
                        "content": "My solution even in worst case wont traverse the complete tree only half of  it and general complexity is O(h^2) than why better than only 80 %"
                    },
                    {
                        "username": "SeineAle",
                        "content": "isnt counting nodes always supposed to be O(n) ?"
                    },
                    {
                        "username": "afeefuddin",
                        "content": "Should be marked as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "2024ec1085",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        return 1+countNodes(root.left)+countNodes(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "deep01",
                        "content": "java code :\\n    public int countNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        return countNodes(root.left) + countNodes(root.right) +1;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jstark6",
                        "content": "Read read read"
                    }
                ]
            },
            {
                "id": 1775045,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/222_Count_Complete_Tree%20_Nodes.cpp"
                    },
                    {
                        "username": "ishwarambare",
                        "content": " `        if not root:\\n            return 0\\n        l = self.countNodes(root.left)\\n        r = self.countNodes(root.right)\\n        return 1 + r + l\\n`\\n "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic int countNodes(TreeNode root) {\\n    TreeNode l = root, r = root;\\n    \\n    int hl = 0, hr = 0;\\n    while (l != null) {\\n        l = l.left;\\n        hl++;\\n    }\\n    while (r != null) {\\n        r = r.right;\\n        hr++;\\n    }\\n    \\n    if (hl == hr) {\\n        return (int)Math.pow(2, hl) - 1;\\n    }\\n    \\n    return 1 + countNodes(root.left) + countNodes(root.right);\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "amankunwar",
                        "content": "Count No of nodes in a tree In java\\n\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int ans = 1;\\n        ans += countNodes(root.left);\\n        ans += countNodes(root.right);\\n\\n        return ans;\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "134_Rakeshkumar",
                        "content": "@https://youtu.be/u-yWemKGWO0"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Suddenly everyone became so helpful :D "
                    },
                    {
                        "username": "rayworks",
                        "content": "We could order the tree nodes from 1, then it\\'s about locating the first missing element on the bottom level if any (However if no missing node can be found there, then it\\'s a full binary tree).\\n\\n* Calculate the depth of the tree, always traverse from left side\\n* Traverse the tree recursively, check the first missing node **on the bottom level**\\n\\n"
                    },
                    {
                        "username": "Sourav_Kumar_Singh",
                        "content": "Can we use a simple level order traversal and count the number of nodes present in that tree??"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "As level-order traversal is not faster than its pre-order counterpart, we can just simply use a recursive pre-order traversal to count the tree. And we would not need to implement queue. If only we did not need to consider the time complexity"
                    },
                    {
                        "username": "rncs074",
                        "content": "But it would still be O(n), since we will have to visit all the nodes to move forward."
                    },
                    {
                        "username": "r_patwari",
                        "content": "Then the complexity is going to be `O(n)`.  As per question, we should try for better than that."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Yes level order traversal would also work"
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "order level traversal worked for me"
                    },
                    {
                        "username": "Dev_Gaurav",
                        "content": "why this is medium level question, this is below easy"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This should be a medium question. Tree traversals take O(N) time and we have to do in less than that"
                    }
                ]
            },
            {
                "id": 1774004,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/222_Count_Complete_Tree%20_Nodes.cpp"
                    },
                    {
                        "username": "ishwarambare",
                        "content": " `        if not root:\\n            return 0\\n        l = self.countNodes(root.left)\\n        r = self.countNodes(root.right)\\n        return 1 + r + l\\n`\\n "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic int countNodes(TreeNode root) {\\n    TreeNode l = root, r = root;\\n    \\n    int hl = 0, hr = 0;\\n    while (l != null) {\\n        l = l.left;\\n        hl++;\\n    }\\n    while (r != null) {\\n        r = r.right;\\n        hr++;\\n    }\\n    \\n    if (hl == hr) {\\n        return (int)Math.pow(2, hl) - 1;\\n    }\\n    \\n    return 1 + countNodes(root.left) + countNodes(root.right);\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "amankunwar",
                        "content": "Count No of nodes in a tree In java\\n\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int ans = 1;\\n        ans += countNodes(root.left);\\n        ans += countNodes(root.right);\\n\\n        return ans;\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "134_Rakeshkumar",
                        "content": "@https://youtu.be/u-yWemKGWO0"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Suddenly everyone became so helpful :D "
                    },
                    {
                        "username": "rayworks",
                        "content": "We could order the tree nodes from 1, then it\\'s about locating the first missing element on the bottom level if any (However if no missing node can be found there, then it\\'s a full binary tree).\\n\\n* Calculate the depth of the tree, always traverse from left side\\n* Traverse the tree recursively, check the first missing node **on the bottom level**\\n\\n"
                    },
                    {
                        "username": "Sourav_Kumar_Singh",
                        "content": "Can we use a simple level order traversal and count the number of nodes present in that tree??"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "As level-order traversal is not faster than its pre-order counterpart, we can just simply use a recursive pre-order traversal to count the tree. And we would not need to implement queue. If only we did not need to consider the time complexity"
                    },
                    {
                        "username": "rncs074",
                        "content": "But it would still be O(n), since we will have to visit all the nodes to move forward."
                    },
                    {
                        "username": "r_patwari",
                        "content": "Then the complexity is going to be `O(n)`.  As per question, we should try for better than that."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Yes level order traversal would also work"
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "order level traversal worked for me"
                    },
                    {
                        "username": "Dev_Gaurav",
                        "content": "why this is medium level question, this is below easy"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This should be a medium question. Tree traversals take O(N) time and we have to do in less than that"
                    }
                ]
            },
            {
                "id": 1764202,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/222_Count_Complete_Tree%20_Nodes.cpp"
                    },
                    {
                        "username": "ishwarambare",
                        "content": " `        if not root:\\n            return 0\\n        l = self.countNodes(root.left)\\n        r = self.countNodes(root.right)\\n        return 1 + r + l\\n`\\n "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic int countNodes(TreeNode root) {\\n    TreeNode l = root, r = root;\\n    \\n    int hl = 0, hr = 0;\\n    while (l != null) {\\n        l = l.left;\\n        hl++;\\n    }\\n    while (r != null) {\\n        r = r.right;\\n        hr++;\\n    }\\n    \\n    if (hl == hr) {\\n        return (int)Math.pow(2, hl) - 1;\\n    }\\n    \\n    return 1 + countNodes(root.left) + countNodes(root.right);\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "amankunwar",
                        "content": "Count No of nodes in a tree In java\\n\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int ans = 1;\\n        ans += countNodes(root.left);\\n        ans += countNodes(root.right);\\n\\n        return ans;\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "134_Rakeshkumar",
                        "content": "@https://youtu.be/u-yWemKGWO0"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Suddenly everyone became so helpful :D "
                    },
                    {
                        "username": "rayworks",
                        "content": "We could order the tree nodes from 1, then it\\'s about locating the first missing element on the bottom level if any (However if no missing node can be found there, then it\\'s a full binary tree).\\n\\n* Calculate the depth of the tree, always traverse from left side\\n* Traverse the tree recursively, check the first missing node **on the bottom level**\\n\\n"
                    },
                    {
                        "username": "Sourav_Kumar_Singh",
                        "content": "Can we use a simple level order traversal and count the number of nodes present in that tree??"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "As level-order traversal is not faster than its pre-order counterpart, we can just simply use a recursive pre-order traversal to count the tree. And we would not need to implement queue. If only we did not need to consider the time complexity"
                    },
                    {
                        "username": "rncs074",
                        "content": "But it would still be O(n), since we will have to visit all the nodes to move forward."
                    },
                    {
                        "username": "r_patwari",
                        "content": "Then the complexity is going to be `O(n)`.  As per question, we should try for better than that."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Yes level order traversal would also work"
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "order level traversal worked for me"
                    },
                    {
                        "username": "Dev_Gaurav",
                        "content": "why this is medium level question, this is below easy"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This should be a medium question. Tree traversals take O(N) time and we have to do in less than that"
                    }
                ]
            },
            {
                "id": 1733555,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/222_Count_Complete_Tree%20_Nodes.cpp"
                    },
                    {
                        "username": "ishwarambare",
                        "content": " `        if not root:\\n            return 0\\n        l = self.countNodes(root.left)\\n        r = self.countNodes(root.right)\\n        return 1 + r + l\\n`\\n "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic int countNodes(TreeNode root) {\\n    TreeNode l = root, r = root;\\n    \\n    int hl = 0, hr = 0;\\n    while (l != null) {\\n        l = l.left;\\n        hl++;\\n    }\\n    while (r != null) {\\n        r = r.right;\\n        hr++;\\n    }\\n    \\n    if (hl == hr) {\\n        return (int)Math.pow(2, hl) - 1;\\n    }\\n    \\n    return 1 + countNodes(root.left) + countNodes(root.right);\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "amankunwar",
                        "content": "Count No of nodes in a tree In java\\n\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int ans = 1;\\n        ans += countNodes(root.left);\\n        ans += countNodes(root.right);\\n\\n        return ans;\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "134_Rakeshkumar",
                        "content": "@https://youtu.be/u-yWemKGWO0"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Suddenly everyone became so helpful :D "
                    },
                    {
                        "username": "rayworks",
                        "content": "We could order the tree nodes from 1, then it\\'s about locating the first missing element on the bottom level if any (However if no missing node can be found there, then it\\'s a full binary tree).\\n\\n* Calculate the depth of the tree, always traverse from left side\\n* Traverse the tree recursively, check the first missing node **on the bottom level**\\n\\n"
                    },
                    {
                        "username": "Sourav_Kumar_Singh",
                        "content": "Can we use a simple level order traversal and count the number of nodes present in that tree??"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "As level-order traversal is not faster than its pre-order counterpart, we can just simply use a recursive pre-order traversal to count the tree. And we would not need to implement queue. If only we did not need to consider the time complexity"
                    },
                    {
                        "username": "rncs074",
                        "content": "But it would still be O(n), since we will have to visit all the nodes to move forward."
                    },
                    {
                        "username": "r_patwari",
                        "content": "Then the complexity is going to be `O(n)`.  As per question, we should try for better than that."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Yes level order traversal would also work"
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "order level traversal worked for me"
                    },
                    {
                        "username": "Dev_Gaurav",
                        "content": "why this is medium level question, this is below easy"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This should be a medium question. Tree traversals take O(N) time and we have to do in less than that"
                    }
                ]
            },
            {
                "id": 1721380,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/222_Count_Complete_Tree%20_Nodes.cpp"
                    },
                    {
                        "username": "ishwarambare",
                        "content": " `        if not root:\\n            return 0\\n        l = self.countNodes(root.left)\\n        r = self.countNodes(root.right)\\n        return 1 + r + l\\n`\\n "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic int countNodes(TreeNode root) {\\n    TreeNode l = root, r = root;\\n    \\n    int hl = 0, hr = 0;\\n    while (l != null) {\\n        l = l.left;\\n        hl++;\\n    }\\n    while (r != null) {\\n        r = r.right;\\n        hr++;\\n    }\\n    \\n    if (hl == hr) {\\n        return (int)Math.pow(2, hl) - 1;\\n    }\\n    \\n    return 1 + countNodes(root.left) + countNodes(root.right);\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "amankunwar",
                        "content": "Count No of nodes in a tree In java\\n\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int ans = 1;\\n        ans += countNodes(root.left);\\n        ans += countNodes(root.right);\\n\\n        return ans;\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "134_Rakeshkumar",
                        "content": "@https://youtu.be/u-yWemKGWO0"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Suddenly everyone became so helpful :D "
                    },
                    {
                        "username": "rayworks",
                        "content": "We could order the tree nodes from 1, then it\\'s about locating the first missing element on the bottom level if any (However if no missing node can be found there, then it\\'s a full binary tree).\\n\\n* Calculate the depth of the tree, always traverse from left side\\n* Traverse the tree recursively, check the first missing node **on the bottom level**\\n\\n"
                    },
                    {
                        "username": "Sourav_Kumar_Singh",
                        "content": "Can we use a simple level order traversal and count the number of nodes present in that tree??"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "As level-order traversal is not faster than its pre-order counterpart, we can just simply use a recursive pre-order traversal to count the tree. And we would not need to implement queue. If only we did not need to consider the time complexity"
                    },
                    {
                        "username": "rncs074",
                        "content": "But it would still be O(n), since we will have to visit all the nodes to move forward."
                    },
                    {
                        "username": "r_patwari",
                        "content": "Then the complexity is going to be `O(n)`.  As per question, we should try for better than that."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Yes level order traversal would also work"
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "order level traversal worked for me"
                    },
                    {
                        "username": "Dev_Gaurav",
                        "content": "why this is medium level question, this is below easy"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This should be a medium question. Tree traversals take O(N) time and we have to do in less than that"
                    }
                ]
            },
            {
                "id": 1689910,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/222_Count_Complete_Tree%20_Nodes.cpp"
                    },
                    {
                        "username": "ishwarambare",
                        "content": " `        if not root:\\n            return 0\\n        l = self.countNodes(root.left)\\n        r = self.countNodes(root.right)\\n        return 1 + r + l\\n`\\n "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic int countNodes(TreeNode root) {\\n    TreeNode l = root, r = root;\\n    \\n    int hl = 0, hr = 0;\\n    while (l != null) {\\n        l = l.left;\\n        hl++;\\n    }\\n    while (r != null) {\\n        r = r.right;\\n        hr++;\\n    }\\n    \\n    if (hl == hr) {\\n        return (int)Math.pow(2, hl) - 1;\\n    }\\n    \\n    return 1 + countNodes(root.left) + countNodes(root.right);\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "amankunwar",
                        "content": "Count No of nodes in a tree In java\\n\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int ans = 1;\\n        ans += countNodes(root.left);\\n        ans += countNodes(root.right);\\n\\n        return ans;\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "134_Rakeshkumar",
                        "content": "@https://youtu.be/u-yWemKGWO0"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Suddenly everyone became so helpful :D "
                    },
                    {
                        "username": "rayworks",
                        "content": "We could order the tree nodes from 1, then it\\'s about locating the first missing element on the bottom level if any (However if no missing node can be found there, then it\\'s a full binary tree).\\n\\n* Calculate the depth of the tree, always traverse from left side\\n* Traverse the tree recursively, check the first missing node **on the bottom level**\\n\\n"
                    },
                    {
                        "username": "Sourav_Kumar_Singh",
                        "content": "Can we use a simple level order traversal and count the number of nodes present in that tree??"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "As level-order traversal is not faster than its pre-order counterpart, we can just simply use a recursive pre-order traversal to count the tree. And we would not need to implement queue. If only we did not need to consider the time complexity"
                    },
                    {
                        "username": "rncs074",
                        "content": "But it would still be O(n), since we will have to visit all the nodes to move forward."
                    },
                    {
                        "username": "r_patwari",
                        "content": "Then the complexity is going to be `O(n)`.  As per question, we should try for better than that."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Yes level order traversal would also work"
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "order level traversal worked for me"
                    },
                    {
                        "username": "Dev_Gaurav",
                        "content": "why this is medium level question, this is below easy"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This should be a medium question. Tree traversals take O(N) time and we have to do in less than that"
                    }
                ]
            },
            {
                "id": 1684880,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/222_Count_Complete_Tree%20_Nodes.cpp"
                    },
                    {
                        "username": "ishwarambare",
                        "content": " `        if not root:\\n            return 0\\n        l = self.countNodes(root.left)\\n        r = self.countNodes(root.right)\\n        return 1 + r + l\\n`\\n "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic int countNodes(TreeNode root) {\\n    TreeNode l = root, r = root;\\n    \\n    int hl = 0, hr = 0;\\n    while (l != null) {\\n        l = l.left;\\n        hl++;\\n    }\\n    while (r != null) {\\n        r = r.right;\\n        hr++;\\n    }\\n    \\n    if (hl == hr) {\\n        return (int)Math.pow(2, hl) - 1;\\n    }\\n    \\n    return 1 + countNodes(root.left) + countNodes(root.right);\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "amankunwar",
                        "content": "Count No of nodes in a tree In java\\n\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int ans = 1;\\n        ans += countNodes(root.left);\\n        ans += countNodes(root.right);\\n\\n        return ans;\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "134_Rakeshkumar",
                        "content": "@https://youtu.be/u-yWemKGWO0"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Suddenly everyone became so helpful :D "
                    },
                    {
                        "username": "rayworks",
                        "content": "We could order the tree nodes from 1, then it\\'s about locating the first missing element on the bottom level if any (However if no missing node can be found there, then it\\'s a full binary tree).\\n\\n* Calculate the depth of the tree, always traverse from left side\\n* Traverse the tree recursively, check the first missing node **on the bottom level**\\n\\n"
                    },
                    {
                        "username": "Sourav_Kumar_Singh",
                        "content": "Can we use a simple level order traversal and count the number of nodes present in that tree??"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "As level-order traversal is not faster than its pre-order counterpart, we can just simply use a recursive pre-order traversal to count the tree. And we would not need to implement queue. If only we did not need to consider the time complexity"
                    },
                    {
                        "username": "rncs074",
                        "content": "But it would still be O(n), since we will have to visit all the nodes to move forward."
                    },
                    {
                        "username": "r_patwari",
                        "content": "Then the complexity is going to be `O(n)`.  As per question, we should try for better than that."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Yes level order traversal would also work"
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "order level traversal worked for me"
                    },
                    {
                        "username": "Dev_Gaurav",
                        "content": "why this is medium level question, this is below easy"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This should be a medium question. Tree traversals take O(N) time and we have to do in less than that"
                    }
                ]
            },
            {
                "id": 1684739,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/222_Count_Complete_Tree%20_Nodes.cpp"
                    },
                    {
                        "username": "ishwarambare",
                        "content": " `        if not root:\\n            return 0\\n        l = self.countNodes(root.left)\\n        r = self.countNodes(root.right)\\n        return 1 + r + l\\n`\\n "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic int countNodes(TreeNode root) {\\n    TreeNode l = root, r = root;\\n    \\n    int hl = 0, hr = 0;\\n    while (l != null) {\\n        l = l.left;\\n        hl++;\\n    }\\n    while (r != null) {\\n        r = r.right;\\n        hr++;\\n    }\\n    \\n    if (hl == hr) {\\n        return (int)Math.pow(2, hl) - 1;\\n    }\\n    \\n    return 1 + countNodes(root.left) + countNodes(root.right);\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "amankunwar",
                        "content": "Count No of nodes in a tree In java\\n\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int ans = 1;\\n        ans += countNodes(root.left);\\n        ans += countNodes(root.right);\\n\\n        return ans;\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "134_Rakeshkumar",
                        "content": "@https://youtu.be/u-yWemKGWO0"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Suddenly everyone became so helpful :D "
                    },
                    {
                        "username": "rayworks",
                        "content": "We could order the tree nodes from 1, then it\\'s about locating the first missing element on the bottom level if any (However if no missing node can be found there, then it\\'s a full binary tree).\\n\\n* Calculate the depth of the tree, always traverse from left side\\n* Traverse the tree recursively, check the first missing node **on the bottom level**\\n\\n"
                    },
                    {
                        "username": "Sourav_Kumar_Singh",
                        "content": "Can we use a simple level order traversal and count the number of nodes present in that tree??"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "As level-order traversal is not faster than its pre-order counterpart, we can just simply use a recursive pre-order traversal to count the tree. And we would not need to implement queue. If only we did not need to consider the time complexity"
                    },
                    {
                        "username": "rncs074",
                        "content": "But it would still be O(n), since we will have to visit all the nodes to move forward."
                    },
                    {
                        "username": "r_patwari",
                        "content": "Then the complexity is going to be `O(n)`.  As per question, we should try for better than that."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Yes level order traversal would also work"
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "order level traversal worked for me"
                    },
                    {
                        "username": "Dev_Gaurav",
                        "content": "why this is medium level question, this is below easy"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This should be a medium question. Tree traversals take O(N) time and we have to do in less than that"
                    }
                ]
            },
            {
                "id": 1684486,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/222_Count_Complete_Tree%20_Nodes.cpp"
                    },
                    {
                        "username": "ishwarambare",
                        "content": " `        if not root:\\n            return 0\\n        l = self.countNodes(root.left)\\n        r = self.countNodes(root.right)\\n        return 1 + r + l\\n`\\n "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic int countNodes(TreeNode root) {\\n    TreeNode l = root, r = root;\\n    \\n    int hl = 0, hr = 0;\\n    while (l != null) {\\n        l = l.left;\\n        hl++;\\n    }\\n    while (r != null) {\\n        r = r.right;\\n        hr++;\\n    }\\n    \\n    if (hl == hr) {\\n        return (int)Math.pow(2, hl) - 1;\\n    }\\n    \\n    return 1 + countNodes(root.left) + countNodes(root.right);\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "amankunwar",
                        "content": "Count No of nodes in a tree In java\\n\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int ans = 1;\\n        ans += countNodes(root.left);\\n        ans += countNodes(root.right);\\n\\n        return ans;\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "134_Rakeshkumar",
                        "content": "@https://youtu.be/u-yWemKGWO0"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Suddenly everyone became so helpful :D "
                    },
                    {
                        "username": "rayworks",
                        "content": "We could order the tree nodes from 1, then it\\'s about locating the first missing element on the bottom level if any (However if no missing node can be found there, then it\\'s a full binary tree).\\n\\n* Calculate the depth of the tree, always traverse from left side\\n* Traverse the tree recursively, check the first missing node **on the bottom level**\\n\\n"
                    },
                    {
                        "username": "Sourav_Kumar_Singh",
                        "content": "Can we use a simple level order traversal and count the number of nodes present in that tree??"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "As level-order traversal is not faster than its pre-order counterpart, we can just simply use a recursive pre-order traversal to count the tree. And we would not need to implement queue. If only we did not need to consider the time complexity"
                    },
                    {
                        "username": "rncs074",
                        "content": "But it would still be O(n), since we will have to visit all the nodes to move forward."
                    },
                    {
                        "username": "r_patwari",
                        "content": "Then the complexity is going to be `O(n)`.  As per question, we should try for better than that."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Yes level order traversal would also work"
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "order level traversal worked for me"
                    },
                    {
                        "username": "Dev_Gaurav",
                        "content": "why this is medium level question, this is below easy"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This should be a medium question. Tree traversals take O(N) time and we have to do in less than that"
                    }
                ]
            },
            {
                "id": 1950005,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/222_Count_Complete_Tree%20_Nodes.cpp"
                    },
                    {
                        "username": "ishwarambare",
                        "content": " `        if not root:\\n            return 0\\n        l = self.countNodes(root.left)\\n        r = self.countNodes(root.right)\\n        return 1 + r + l\\n`\\n "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic int countNodes(TreeNode root) {\\n    TreeNode l = root, r = root;\\n    \\n    int hl = 0, hr = 0;\\n    while (l != null) {\\n        l = l.left;\\n        hl++;\\n    }\\n    while (r != null) {\\n        r = r.right;\\n        hr++;\\n    }\\n    \\n    if (hl == hr) {\\n        return (int)Math.pow(2, hl) - 1;\\n    }\\n    \\n    return 1 + countNodes(root.left) + countNodes(root.right);\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "amankunwar",
                        "content": "Count No of nodes in a tree In java\\n\\nclass Solution {\\n    public int countNodes(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int ans = 1;\\n        ans += countNodes(root.left);\\n        ans += countNodes(root.right);\\n\\n        return ans;\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "134_Rakeshkumar",
                        "content": "@https://youtu.be/u-yWemKGWO0"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Suddenly everyone became so helpful :D "
                    },
                    {
                        "username": "rayworks",
                        "content": "We could order the tree nodes from 1, then it\\'s about locating the first missing element on the bottom level if any (However if no missing node can be found there, then it\\'s a full binary tree).\\n\\n* Calculate the depth of the tree, always traverse from left side\\n* Traverse the tree recursively, check the first missing node **on the bottom level**\\n\\n"
                    },
                    {
                        "username": "Sourav_Kumar_Singh",
                        "content": "Can we use a simple level order traversal and count the number of nodes present in that tree??"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "As level-order traversal is not faster than its pre-order counterpart, we can just simply use a recursive pre-order traversal to count the tree. And we would not need to implement queue. If only we did not need to consider the time complexity"
                    },
                    {
                        "username": "rncs074",
                        "content": "But it would still be O(n), since we will have to visit all the nodes to move forward."
                    },
                    {
                        "username": "r_patwari",
                        "content": "Then the complexity is going to be `O(n)`.  As per question, we should try for better than that."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Yes level order traversal would also work"
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "order level traversal worked for me"
                    },
                    {
                        "username": "Dev_Gaurav",
                        "content": "why this is medium level question, this is below easy"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This should be a medium question. Tree traversals take O(N) time and we have to do in less than that"
                    }
                ]
            }
        ]
    }
]